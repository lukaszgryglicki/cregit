0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/http.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/http.go][vendor/github.com/coreos/etcd/rafthttp/http.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pioutil "github.com/coreos/etcd/pkg/ioutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/version"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// connReadLimitByte limits the number of bytes
0000000000000000000000000000000000000000;;		// a single read can read out.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 64KB should be large enough for not causing
0000000000000000000000000000000000000000;;		// throughput bottleneck as well as small enough
0000000000000000000000000000000000000000;;		// for not causing a read timeout.
0000000000000000000000000000000000000000;;		connReadLimitByte = 64 * 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		RaftPrefix         = "/raft"
0000000000000000000000000000000000000000;;		ProbingPrefix      = path.Join(RaftPrefix, "probing")
0000000000000000000000000000000000000000;;		RaftStreamPrefix   = path.Join(RaftPrefix, "stream")
0000000000000000000000000000000000000000;;		RaftSnapshotPrefix = path.Join(RaftPrefix, "snapshot")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errIncompatibleVersion = errors.New("incompatible version")
0000000000000000000000000000000000000000;;		errClusterIDMismatch   = errors.New("cluster ID mismatch")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type peerGetter interface {
0000000000000000000000000000000000000000;;		Get(id types.ID) Peer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type writerToResponse interface {
0000000000000000000000000000000000000000;;		WriteTo(w http.ResponseWriter)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pipelineHandler struct {
0000000000000000000000000000000000000000;;		tr  Transporter
0000000000000000000000000000000000000000;;		r   Raft
0000000000000000000000000000000000000000;;		cid types.ID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newPipelineHandler returns a handler for handling raft messages
0000000000000000000000000000000000000000;;	// from pipeline for RaftPrefix.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The handler reads out the raft message from request body,
0000000000000000000000000000000000000000;;	// and forwards it to the given raft state machine for processing.
0000000000000000000000000000000000000000;;	func newPipelineHandler(tr Transporter, r Raft, cid types.ID) http.Handler {
0000000000000000000000000000000000000000;;		return &pipelineHandler{
0000000000000000000000000000000000000000;;			tr:  tr,
0000000000000000000000000000000000000000;;			r:   r,
0000000000000000000000000000000000000000;;			cid: cid,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *pipelineHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if r.Method != "POST" {
0000000000000000000000000000000000000000;;			w.Header().Set("Allow", "POST")
0000000000000000000000000000000000000000;;			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", h.cid.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkClusterCompatibilityFromHeader(r.Header, h.cid); err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusPreconditionFailed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if from, err := types.IDFromString(r.Header.Get("X-Server-From")); err != nil {
0000000000000000000000000000000000000000;;			if urls := r.Header.Get("X-PeerURLs"); urls != "" {
0000000000000000000000000000000000000000;;				h.tr.AddRemote(from, strings.Split(urls, ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Limit the data size that could be read from the request body, which ensures that read from
0000000000000000000000000000000000000000;;		// connection will not time out accidentally due to possible blocking in underlying implementation.
0000000000000000000000000000000000000000;;		limitedr := pioutil.NewLimitedBufferReader(r.Body, connReadLimitByte)
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(limitedr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("failed to read raft message (%v)", err)
0000000000000000000000000000000000000000;;			http.Error(w, "error reading raft message", http.StatusBadRequest)
0000000000000000000000000000000000000000;;			recvFailures.WithLabelValues(r.RemoteAddr).Inc()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var m raftpb.Message
0000000000000000000000000000000000000000;;		if err := m.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("failed to unmarshal raft message (%v)", err)
0000000000000000000000000000000000000000;;			http.Error(w, "error unmarshaling raft message", http.StatusBadRequest)
0000000000000000000000000000000000000000;;			recvFailures.WithLabelValues(r.RemoteAddr).Inc()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		receivedBytes.WithLabelValues(types.ID(m.From).String()).Add(float64(len(b)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := h.r.Process(context.TODO(), m); err != nil {
0000000000000000000000000000000000000000;;			switch v := err.(type) {
0000000000000000000000000000000000000000;;			case writerToResponse:
0000000000000000000000000000000000000000;;				v.WriteTo(w)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				plog.Warningf("failed to process raft message (%v)", err)
0000000000000000000000000000000000000000;;				http.Error(w, "error processing raft message", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				w.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;				// disconnect the http stream
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write StatusNoContent header after the message has been processed by
0000000000000000000000000000000000000000;;		// raft, which facilitates the client to report MsgSnap status.
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusNoContent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type snapshotHandler struct {
0000000000000000000000000000000000000000;;		tr          Transporter
0000000000000000000000000000000000000000;;		r           Raft
0000000000000000000000000000000000000000;;		snapshotter *snap.Snapshotter
0000000000000000000000000000000000000000;;		cid         types.ID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSnapshotHandler(tr Transporter, r Raft, snapshotter *snap.Snapshotter, cid types.ID) http.Handler {
0000000000000000000000000000000000000000;;		return &snapshotHandler{
0000000000000000000000000000000000000000;;			tr:          tr,
0000000000000000000000000000000000000000;;			r:           r,
0000000000000000000000000000000000000000;;			snapshotter: snapshotter,
0000000000000000000000000000000000000000;;			cid:         cid,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP serves HTTP request to receive and process snapshot message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If request sender dies without closing underlying TCP connection,
0000000000000000000000000000000000000000;;	// the handler will keep waiting for the request body until TCP keepalive
0000000000000000000000000000000000000000;;	// finds out that the connection is broken after several minutes.
0000000000000000000000000000000000000000;;	// This is acceptable because
0000000000000000000000000000000000000000;;	// 1. snapshot messages sent through other TCP connections could still be
0000000000000000000000000000000000000000;;	// received and processed.
0000000000000000000000000000000000000000;;	// 2. this case should happen rarely, so no further optimization is done.
0000000000000000000000000000000000000000;;	func (h *snapshotHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if r.Method != "POST" {
0000000000000000000000000000000000000000;;			w.Header().Set("Allow", "POST")
0000000000000000000000000000000000000000;;			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", h.cid.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkClusterCompatibilityFromHeader(r.Header, h.cid); err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusPreconditionFailed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if from, err := types.IDFromString(r.Header.Get("X-Server-From")); err != nil {
0000000000000000000000000000000000000000;;			if urls := r.Header.Get("X-PeerURLs"); urls != "" {
0000000000000000000000000000000000000000;;				h.tr.AddRemote(from, strings.Split(urls, ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := &messageDecoder{r: r.Body}
0000000000000000000000000000000000000000;;		m, err := dec.decode()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("failed to decode raft message (%v)", err)
0000000000000000000000000000000000000000;;			plog.Errorf(msg)
0000000000000000000000000000000000000000;;			http.Error(w, msg, http.StatusBadRequest)
0000000000000000000000000000000000000000;;			recvFailures.WithLabelValues(r.RemoteAddr).Inc()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		receivedBytes.WithLabelValues(types.ID(m.From).String()).Add(float64(m.Size()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.Type != raftpb.MsgSnap {
0000000000000000000000000000000000000000;;			plog.Errorf("unexpected raft message type %s on snapshot path", m.Type)
0000000000000000000000000000000000000000;;			http.Error(w, "wrong raft message type", http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("receiving database snapshot [index:%d, from %s] ...", m.Snapshot.Metadata.Index, types.ID(m.From))
0000000000000000000000000000000000000000;;		// save incoming database snapshot.
0000000000000000000000000000000000000000;;		n, err := h.snapshotter.SaveDBFrom(r.Body, m.Snapshot.Metadata.Index)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("failed to save KV snapshot (%v)", err)
0000000000000000000000000000000000000000;;			plog.Error(msg)
0000000000000000000000000000000000000000;;			http.Error(w, msg, http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		receivedBytes.WithLabelValues(types.ID(m.From).String()).Add(float64(n))
0000000000000000000000000000000000000000;;		plog.Infof("received and saved database snapshot [index: %d, from: %s] successfully", m.Snapshot.Metadata.Index, types.ID(m.From))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := h.r.Process(context.TODO(), m); err != nil {
0000000000000000000000000000000000000000;;			switch v := err.(type) {
0000000000000000000000000000000000000000;;			// Process may return writerToResponse error when doing some
0000000000000000000000000000000000000000;;			// additional checks before calling raft.Node.Step.
0000000000000000000000000000000000000000;;			case writerToResponse:
0000000000000000000000000000000000000000;;				v.WriteTo(w)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				msg := fmt.Sprintf("failed to process raft message (%v)", err)
0000000000000000000000000000000000000000;;				plog.Warningf(msg)
0000000000000000000000000000000000000000;;				http.Error(w, msg, http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Write StatusNoContent header after the message has been processed by
0000000000000000000000000000000000000000;;		// raft, which facilitates the client to report MsgSnap status.
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusNoContent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type streamHandler struct {
0000000000000000000000000000000000000000;;		tr         *Transport
0000000000000000000000000000000000000000;;		peerGetter peerGetter
0000000000000000000000000000000000000000;;		r          Raft
0000000000000000000000000000000000000000;;		id         types.ID
0000000000000000000000000000000000000000;;		cid        types.ID
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStreamHandler(tr *Transport, pg peerGetter, r Raft, id, cid types.ID) http.Handler {
0000000000000000000000000000000000000000;;		return &streamHandler{
0000000000000000000000000000000000000000;;			tr:         tr,
0000000000000000000000000000000000000000;;			peerGetter: pg,
0000000000000000000000000000000000000000;;			r:          r,
0000000000000000000000000000000000000000;;			id:         id,
0000000000000000000000000000000000000000;;			cid:        cid,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *streamHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		if r.Method != "GET" {
0000000000000000000000000000000000000000;;			w.Header().Set("Allow", "GET")
0000000000000000000000000000000000000000;;			http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("X-Server-Version", version.Version)
0000000000000000000000000000000000000000;;		w.Header().Set("X-Etcd-Cluster-ID", h.cid.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := checkClusterCompatibilityFromHeader(r.Header, h.cid); err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusPreconditionFailed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var t streamType
0000000000000000000000000000000000000000;;		switch path.Dir(r.URL.Path) {
0000000000000000000000000000000000000000;;		case streamTypeMsgAppV2.endpoint():
0000000000000000000000000000000000000000;;			t = streamTypeMsgAppV2
0000000000000000000000000000000000000000;;		case streamTypeMessage.endpoint():
0000000000000000000000000000000000000000;;			t = streamTypeMessage
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			plog.Debugf("ignored unexpected streaming request path %s", r.URL.Path)
0000000000000000000000000000000000000000;;			http.Error(w, "invalid path", http.StatusNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fromStr := path.Base(r.URL.Path)
0000000000000000000000000000000000000000;;		from, err := types.IDFromString(fromStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("failed to parse from %s into ID (%v)", fromStr, err)
0000000000000000000000000000000000000000;;			http.Error(w, "invalid from", http.StatusNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.r.IsIDRemoved(uint64(from)) {
0000000000000000000000000000000000000000;;			plog.Warningf("rejected the stream from peer %s since it was removed", from)
0000000000000000000000000000000000000000;;			http.Error(w, "removed member", http.StatusGone)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := h.peerGetter.Get(from)
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			// This may happen in following cases:
0000000000000000000000000000000000000000;;			// 1. user starts a remote peer that belongs to a different cluster
0000000000000000000000000000000000000000;;			// with the same cluster ID.
0000000000000000000000000000000000000000;;			// 2. local etcd falls behind of the cluster, and cannot recognize
0000000000000000000000000000000000000000;;			// the members that joined after its current progress.
0000000000000000000000000000000000000000;;			if urls := r.Header.Get("X-PeerURLs"); urls != "" {
0000000000000000000000000000000000000000;;				h.tr.AddRemote(from, strings.Split(urls, ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Errorf("failed to find member %s in cluster %s", from, h.cid)
0000000000000000000000000000000000000000;;			http.Error(w, "error sender not found", http.StatusNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wto := h.id.String()
0000000000000000000000000000000000000000;;		if gto := r.Header.Get("X-Raft-To"); gto != wto {
0000000000000000000000000000000000000000;;			plog.Errorf("streaming request ignored (ID mismatch got %s want %s)", gto, wto)
0000000000000000000000000000000000000000;;			http.Error(w, "to field mismatch", http.StatusPreconditionFailed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		w.(http.Flusher).Flush()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := newCloseNotifier()
0000000000000000000000000000000000000000;;		conn := &outgoingConn{
0000000000000000000000000000000000000000;;			t:       t,
0000000000000000000000000000000000000000;;			Writer:  w,
0000000000000000000000000000000000000000;;			Flusher: w.(http.Flusher),
0000000000000000000000000000000000000000;;			Closer:  c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.attachOutgoingConn(conn)
0000000000000000000000000000000000000000;;		<-c.closeNotify()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkClusterCompatibilityFromHeader checks the cluster compatibility of
0000000000000000000000000000000000000000;;	// the local member from the given header.
0000000000000000000000000000000000000000;;	// It checks whether the version of local member is compatible with
0000000000000000000000000000000000000000;;	// the versions in the header, and whether the cluster ID of local member
0000000000000000000000000000000000000000;;	// matches the one in the header.
0000000000000000000000000000000000000000;;	func checkClusterCompatibilityFromHeader(header http.Header, cid types.ID) error {
0000000000000000000000000000000000000000;;		if err := checkVersionCompability(header.Get("X-Server-From"), serverVersion(header), minClusterVersion(header)); err != nil {
0000000000000000000000000000000000000000;;			plog.Errorf("request version incompatibility (%v)", err)
0000000000000000000000000000000000000000;;			return errIncompatibleVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gcid := header.Get("X-Etcd-Cluster-ID"); gcid != cid.String() {
0000000000000000000000000000000000000000;;			plog.Errorf("request cluster ID mismatch (got %s want %s)", gcid, cid)
0000000000000000000000000000000000000000;;			return errClusterIDMismatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type closeNotifier struct {
0000000000000000000000000000000000000000;;		done chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newCloseNotifier() *closeNotifier {
0000000000000000000000000000000000000000;;		return &closeNotifier{
0000000000000000000000000000000000000000;;			done: make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *closeNotifier) Close() error {
0000000000000000000000000000000000000000;;		close(n.done)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *closeNotifier) closeNotify() <-chan struct{} { return n.done }
