0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/pipeline.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/pipeline.go][vendor/github.com/coreos/etcd/rafthttp/pipeline.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/stats"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/httputil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		connPerPipeline = 4
0000000000000000000000000000000000000000;;		// pipelineBufSize is the size of pipeline buffer, which helps hold the
0000000000000000000000000000000000000000;;		// temporary network latency.
0000000000000000000000000000000000000000;;		// The size ensures that pipeline does not drop messages when the network
0000000000000000000000000000000000000000;;		// is out of work for less than 1 second in good path.
0000000000000000000000000000000000000000;;		pipelineBufSize = 64
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errStopped = errors.New("stopped")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pipeline struct {
0000000000000000000000000000000000000000;;		peerID types.ID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr     *Transport
0000000000000000000000000000000000000000;;		picker *urlPicker
0000000000000000000000000000000000000000;;		status *peerStatus
0000000000000000000000000000000000000000;;		raft   Raft
0000000000000000000000000000000000000000;;		errorc chan error
0000000000000000000000000000000000000000;;		// deprecate when we depercate v2 API
0000000000000000000000000000000000000000;;		followerStats *stats.FollowerStats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgc chan raftpb.Message
0000000000000000000000000000000000000000;;		// wait for the handling routines
0000000000000000000000000000000000000000;;		wg    sync.WaitGroup
0000000000000000000000000000000000000000;;		stopc chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pipeline) start() {
0000000000000000000000000000000000000000;;		p.stopc = make(chan struct{})
0000000000000000000000000000000000000000;;		p.msgc = make(chan raftpb.Message, pipelineBufSize)
0000000000000000000000000000000000000000;;		p.wg.Add(connPerPipeline)
0000000000000000000000000000000000000000;;		for i := 0; i < connPerPipeline; i++ {
0000000000000000000000000000000000000000;;			go p.handle()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plog.Infof("started HTTP pipelining with peer %s", p.peerID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pipeline) stop() {
0000000000000000000000000000000000000000;;		close(p.stopc)
0000000000000000000000000000000000000000;;		p.wg.Wait()
0000000000000000000000000000000000000000;;		plog.Infof("stopped HTTP pipelining with peer %s", p.peerID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *pipeline) handle() {
0000000000000000000000000000000000000000;;		defer p.wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case m := <-p.msgc:
0000000000000000000000000000000000000000;;				start := time.Now()
0000000000000000000000000000000000000000;;				err := p.post(pbutil.MustMarshal(&m))
0000000000000000000000000000000000000000;;				end := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					p.status.deactivate(failureType{source: pipelineMsg, action: "write"}, err.Error())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if m.Type == raftpb.MsgApp && p.followerStats != nil {
0000000000000000000000000000000000000000;;						p.followerStats.Fail()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.raft.ReportUnreachable(m.To)
0000000000000000000000000000000000000000;;					if isMsgSnap(m) {
0000000000000000000000000000000000000000;;						p.raft.ReportSnapshot(m.To, raft.SnapshotFailure)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sentFailures.WithLabelValues(types.ID(m.To).String()).Inc()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p.status.activate()
0000000000000000000000000000000000000000;;				if m.Type == raftpb.MsgApp && p.followerStats != nil {
0000000000000000000000000000000000000000;;					p.followerStats.Succ(end.Sub(start))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isMsgSnap(m) {
0000000000000000000000000000000000000000;;					p.raft.ReportSnapshot(m.To, raft.SnapshotFinish)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sentBytes.WithLabelValues(types.ID(m.To).String()).Add(float64(m.Size()))
0000000000000000000000000000000000000000;;			case <-p.stopc:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// post POSTs a data payload to a url. Returns nil if the POST succeeds,
0000000000000000000000000000000000000000;;	// error on any failure.
0000000000000000000000000000000000000000;;	func (p *pipeline) post(data []byte) (err error) {
0000000000000000000000000000000000000000;;		u := p.picker.pick()
0000000000000000000000000000000000000000;;		req := createPostRequest(u, RaftPrefix, bytes.NewBuffer(data), "application/protobuf", p.tr.URLs, p.tr.ID, p.tr.ClusterID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		done := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;		cancel := httputil.RequestCanceler(req)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-done:
0000000000000000000000000000000000000000;;			case <-p.stopc:
0000000000000000000000000000000000000000;;				waitSchedule()
0000000000000000000000000000000000000000;;				cancel()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := p.tr.pipelineRt.RoundTrip(req)
0000000000000000000000000000000000000000;;		done <- struct{}{}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.picker.unreachable(u)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.picker.unreachable(u)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = checkPostResponse(resp, b, req, p.peerID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.picker.unreachable(u)
0000000000000000000000000000000000000000;;			// errMemberRemoved is a critical error since a removed member should
0000000000000000000000000000000000000000;;			// always be stopped. So we use reportCriticalError to report it to errorc.
0000000000000000000000000000000000000000;;			if err == errMemberRemoved {
0000000000000000000000000000000000000000;;				reportCriticalError(err, p.errorc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitSchedule waits other goroutines to be scheduled for a while
0000000000000000000000000000000000000000;;	func waitSchedule() { time.Sleep(time.Millisecond) }
