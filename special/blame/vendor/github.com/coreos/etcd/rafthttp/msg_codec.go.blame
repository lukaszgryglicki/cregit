0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/message.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/message.go][vendor/github.com/coreos/etcd/rafthttp/msg_codec.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pbutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// messageEncoder is a encoder that can encode all kinds of messages.
0000000000000000000000000000000000000000;;	// It MUST be used with a paired messageDecoder.
0000000000000000000000000000000000000000;;	type messageEncoder struct {
0000000000000000000000000000000000000000;;		w io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (enc *messageEncoder) encode(m *raftpb.Message) error {
0000000000000000000000000000000000000000;;		if err := binary.Write(enc.w, binary.BigEndian, uint64(m.Size())); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err := enc.w.Write(pbutil.MustMarshal(m))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// messageDecoder is a decoder that can decode all kinds of messages.
0000000000000000000000000000000000000000;;	type messageDecoder struct {
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		readBytesLimit     uint64 = 512 * 1024 * 1024 // 512 MB
0000000000000000000000000000000000000000;;		ErrExceedSizeLimit        = errors.New("rafthttp: error limit exceeded")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *messageDecoder) decode() (raftpb.Message, error) {
0000000000000000000000000000000000000000;;		var m raftpb.Message
0000000000000000000000000000000000000000;;		var l uint64
0000000000000000000000000000000000000000;;		if err := binary.Read(dec.r, binary.BigEndian, &l); err != nil {
0000000000000000000000000000000000000000;;			return m, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l > readBytesLimit {
0000000000000000000000000000000000000000;;			return m, ErrExceedSizeLimit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := make([]byte, int(l))
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(dec.r, buf); err != nil {
0000000000000000000000000000000000000000;;			return m, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, m.Unmarshal(buf)
0000000000000000000000000000000000000000;;	}
