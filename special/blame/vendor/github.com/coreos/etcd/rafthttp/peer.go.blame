0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/peer.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/peer.go][vendor/github.com/coreos/etcd/rafthttp/peer.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/stats"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// ConnReadTimeout and ConnWriteTimeout are the i/o timeout set on each connection rafthttp pkg creates.
0000000000000000000000000000000000000000;;		// A 5 seconds timeout is good enough for recycling bad connections. Or we have to wait for
0000000000000000000000000000000000000000;;		// tcp keepalive failing to detect a bad connection, which is at minutes level.
0000000000000000000000000000000000000000;;		// For long term streaming connections, rafthttp pkg sends application level linkHeartbeatMessage
0000000000000000000000000000000000000000;;		// to keep the connection alive.
0000000000000000000000000000000000000000;;		// For short term pipeline connections, the connection MUST be killed to avoid it being
0000000000000000000000000000000000000000;;		// put back to http pkg connection pool.
0000000000000000000000000000000000000000;;		ConnReadTimeout  = 5 * time.Second
0000000000000000000000000000000000000000;;		ConnWriteTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recvBufSize = 4096
0000000000000000000000000000000000000000;;		// maxPendingProposals holds the proposals during one leader election process.
0000000000000000000000000000000000000000;;		// Generally one leader election takes at most 1 sec. It should have
0000000000000000000000000000000000000000;;		// 0-2 election conflicts, and each one takes 0.5 sec.
0000000000000000000000000000000000000000;;		// We assume the number of concurrent proposers is smaller than 4096.
0000000000000000000000000000000000000000;;		// One client blocks on its proposal for at least 1 sec, so 4096 is enough
0000000000000000000000000000000000000000;;		// to hold all proposals.
0000000000000000000000000000000000000000;;		maxPendingProposals = 4096
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamAppV2 = "streamMsgAppV2"
0000000000000000000000000000000000000000;;		streamMsg   = "streamMsg"
0000000000000000000000000000000000000000;;		pipelineMsg = "pipeline"
0000000000000000000000000000000000000000;;		sendSnap    = "sendMsgSnap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Peer interface {
0000000000000000000000000000000000000000;;		// send sends the message to the remote peer. The function is non-blocking
0000000000000000000000000000000000000000;;		// and has no promise that the message will be received by the remote.
0000000000000000000000000000000000000000;;		// When it fails to send message out, it will report the status to underlying
0000000000000000000000000000000000000000;;		// raft.
0000000000000000000000000000000000000000;;		send(m raftpb.Message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sendSnap sends the merged snapshot message to the remote peer. Its behavior
0000000000000000000000000000000000000000;;		// is similar to send.
0000000000000000000000000000000000000000;;		sendSnap(m snap.Message)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update updates the urls of remote peer.
0000000000000000000000000000000000000000;;		update(urls types.URLs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// attachOutgoingConn attaches the outgoing connection to the peer for
0000000000000000000000000000000000000000;;		// stream usage. After the call, the ownership of the outgoing
0000000000000000000000000000000000000000;;		// connection hands over to the peer. The peer will close the connection
0000000000000000000000000000000000000000;;		// when it is no longer used.
0000000000000000000000000000000000000000;;		attachOutgoingConn(conn *outgoingConn)
0000000000000000000000000000000000000000;;		// activeSince returns the time that the connection with the
0000000000000000000000000000000000000000;;		// peer becomes active.
0000000000000000000000000000000000000000;;		activeSince() time.Time
0000000000000000000000000000000000000000;;		// stop performs any necessary finalization and terminates the peer
0000000000000000000000000000000000000000;;		// elegantly.
0000000000000000000000000000000000000000;;		stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// peer is the representative of a remote raft node. Local raft node sends
0000000000000000000000000000000000000000;;	// messages to the remote through peer.
0000000000000000000000000000000000000000;;	// Each peer has two underlying mechanisms to send out a message: stream and
0000000000000000000000000000000000000000;;	// pipeline.
0000000000000000000000000000000000000000;;	// A stream is a receiver initialized long-polling connection, which
0000000000000000000000000000000000000000;;	// is always open to transfer messages. Besides general stream, peer also has
0000000000000000000000000000000000000000;;	// a optimized stream for sending msgApp since msgApp accounts for large part
0000000000000000000000000000000000000000;;	// of all messages. Only raft leader uses the optimized stream to send msgApp
0000000000000000000000000000000000000000;;	// to the remote follower node.
0000000000000000000000000000000000000000;;	// A pipeline is a series of http clients that send http requests to the remote.
0000000000000000000000000000000000000000;;	// It is only used when the stream has not been established.
0000000000000000000000000000000000000000;;	type peer struct {
0000000000000000000000000000000000000000;;		// id of the remote raft peer node
0000000000000000000000000000000000000000;;		id types.ID
0000000000000000000000000000000000000000;;		r  Raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status *peerStatus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		picker *urlPicker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgAppV2Writer *streamWriter
0000000000000000000000000000000000000000;;		writer         *streamWriter
0000000000000000000000000000000000000000;;		pipeline       *pipeline
0000000000000000000000000000000000000000;;		snapSender     *snapshotSender // snapshot sender to send v3 snapshot messages
0000000000000000000000000000000000000000;;		msgAppV2Reader *streamReader
0000000000000000000000000000000000000000;;		msgAppReader   *streamReader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recvc chan raftpb.Message
0000000000000000000000000000000000000000;;		propc chan raftpb.Message
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu     sync.Mutex
0000000000000000000000000000000000000000;;		paused bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cancel context.CancelFunc // cancel pending works in go routine created by peer.
0000000000000000000000000000000000000000;;		stopc  chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startPeer(transport *Transport, urls types.URLs, peerID types.ID, fs *stats.FollowerStats) *peer {
0000000000000000000000000000000000000000;;		plog.Infof("starting peer %s...", peerID)
0000000000000000000000000000000000000000;;		defer plog.Infof("started peer %s", peerID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := newPeerStatus(peerID)
0000000000000000000000000000000000000000;;		picker := newURLPicker(urls)
0000000000000000000000000000000000000000;;		errorc := transport.ErrorC
0000000000000000000000000000000000000000;;		r := transport.Raft
0000000000000000000000000000000000000000;;		pipeline := &pipeline{
0000000000000000000000000000000000000000;;			peerID:        peerID,
0000000000000000000000000000000000000000;;			tr:            transport,
0000000000000000000000000000000000000000;;			picker:        picker,
0000000000000000000000000000000000000000;;			status:        status,
0000000000000000000000000000000000000000;;			followerStats: fs,
0000000000000000000000000000000000000000;;			raft:          r,
0000000000000000000000000000000000000000;;			errorc:        errorc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pipeline.start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := &peer{
0000000000000000000000000000000000000000;;			id:             peerID,
0000000000000000000000000000000000000000;;			r:              r,
0000000000000000000000000000000000000000;;			status:         status,
0000000000000000000000000000000000000000;;			picker:         picker,
0000000000000000000000000000000000000000;;			msgAppV2Writer: startStreamWriter(peerID, status, fs, r),
0000000000000000000000000000000000000000;;			writer:         startStreamWriter(peerID, status, fs, r),
0000000000000000000000000000000000000000;;			pipeline:       pipeline,
0000000000000000000000000000000000000000;;			snapSender:     newSnapshotSender(transport, picker, peerID, status),
0000000000000000000000000000000000000000;;			recvc:          make(chan raftpb.Message, recvBufSize),
0000000000000000000000000000000000000000;;			propc:          make(chan raftpb.Message, maxPendingProposals),
0000000000000000000000000000000000000000;;			stopc:          make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		p.cancel = cancel
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case mm := <-p.recvc:
0000000000000000000000000000000000000000;;					if err := r.Process(ctx, mm); err != nil {
0000000000000000000000000000000000000000;;						plog.Warningf("failed to process raft message (%v)", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-p.stopc:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// r.Process might block for processing proposal when there is no leader.
0000000000000000000000000000000000000000;;		// Thus propc must be put into a separate routine with recvc to avoid blocking
0000000000000000000000000000000000000000;;		// processing other raft messages.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case mm := <-p.propc:
0000000000000000000000000000000000000000;;					if err := r.Process(ctx, mm); err != nil {
0000000000000000000000000000000000000000;;						plog.Warningf("failed to process raft message (%v)", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-p.stopc:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.msgAppV2Reader = &streamReader{
0000000000000000000000000000000000000000;;			peerID: peerID,
0000000000000000000000000000000000000000;;			typ:    streamTypeMsgAppV2,
0000000000000000000000000000000000000000;;			tr:     transport,
0000000000000000000000000000000000000000;;			picker: picker,
0000000000000000000000000000000000000000;;			status: status,
0000000000000000000000000000000000000000;;			recvc:  p.recvc,
0000000000000000000000000000000000000000;;			propc:  p.propc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.msgAppReader = &streamReader{
0000000000000000000000000000000000000000;;			peerID: peerID,
0000000000000000000000000000000000000000;;			typ:    streamTypeMessage,
0000000000000000000000000000000000000000;;			tr:     transport,
0000000000000000000000000000000000000000;;			picker: picker,
0000000000000000000000000000000000000000;;			status: status,
0000000000000000000000000000000000000000;;			recvc:  p.recvc,
0000000000000000000000000000000000000000;;			propc:  p.propc,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.msgAppV2Reader.start()
0000000000000000000000000000000000000000;;		p.msgAppReader.start()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *peer) send(m raftpb.Message) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		paused := p.paused
0000000000000000000000000000000000000000;;		p.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if paused {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		writec, name := p.pick(m)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case writec <- m:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			p.r.ReportUnreachable(m.To)
0000000000000000000000000000000000000000;;			if isMsgSnap(m) {
0000000000000000000000000000000000000000;;				p.r.ReportSnapshot(m.To, raft.SnapshotFailure)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.status.isActive() {
0000000000000000000000000000000000000000;;				plog.MergeWarningf("dropped internal raft message to %s since %s's sending buffer is full (bad/overloaded network)", p.id, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			plog.Debugf("dropped %s to %s since %s's sending buffer is full", m.Type, p.id, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *peer) sendSnap(m snap.Message) {
0000000000000000000000000000000000000000;;		go p.snapSender.send(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *peer) update(urls types.URLs) {
0000000000000000000000000000000000000000;;		p.picker.update(urls)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *peer) attachOutgoingConn(conn *outgoingConn) {
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		switch conn.t {
0000000000000000000000000000000000000000;;		case streamTypeMsgAppV2:
0000000000000000000000000000000000000000;;			ok = p.msgAppV2Writer.attach(conn)
0000000000000000000000000000000000000000;;		case streamTypeMessage:
0000000000000000000000000000000000000000;;			ok = p.writer.attach(conn)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			plog.Panicf("unhandled stream type %s", conn.t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			conn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *peer) activeSince() time.Time { return p.status.activeSince() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pause pauses the peer. The peer will simply drops all incoming
0000000000000000000000000000000000000000;;	// messages without returning an error.
0000000000000000000000000000000000000000;;	func (p *peer) Pause() {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		p.paused = true
0000000000000000000000000000000000000000;;		p.msgAppReader.pause()
0000000000000000000000000000000000000000;;		p.msgAppV2Reader.pause()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resume resumes a paused peer.
0000000000000000000000000000000000000000;;	func (p *peer) Resume() {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		p.paused = false
0000000000000000000000000000000000000000;;		p.msgAppReader.resume()
0000000000000000000000000000000000000000;;		p.msgAppV2Reader.resume()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *peer) stop() {
0000000000000000000000000000000000000000;;		plog.Infof("stopping peer %s...", p.id)
0000000000000000000000000000000000000000;;		defer plog.Infof("stopped peer %s", p.id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(p.stopc)
0000000000000000000000000000000000000000;;		p.cancel()
0000000000000000000000000000000000000000;;		p.msgAppV2Writer.stop()
0000000000000000000000000000000000000000;;		p.writer.stop()
0000000000000000000000000000000000000000;;		p.pipeline.stop()
0000000000000000000000000000000000000000;;		p.snapSender.stop()
0000000000000000000000000000000000000000;;		p.msgAppV2Reader.stop()
0000000000000000000000000000000000000000;;		p.msgAppReader.stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pick picks a chan for sending the given message. The picked chan and the picked chan
0000000000000000000000000000000000000000;;	// string name are returned.
0000000000000000000000000000000000000000;;	func (p *peer) pick(m raftpb.Message) (writec chan<- raftpb.Message, picked string) {
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		// Considering MsgSnap may have a big size, e.g., 1G, and will block
0000000000000000000000000000000000000000;;		// stream for a long time, only use one of the N pipelines to send MsgSnap.
0000000000000000000000000000000000000000;;		if isMsgSnap(m) {
0000000000000000000000000000000000000000;;			return p.pipeline.msgc, pipelineMsg
0000000000000000000000000000000000000000;;		} else if writec, ok = p.msgAppV2Writer.writec(); ok && isMsgApp(m) {
0000000000000000000000000000000000000000;;			return writec, streamAppV2
0000000000000000000000000000000000000000;;		} else if writec, ok = p.writer.writec(); ok {
0000000000000000000000000000000000000000;;			return writec, streamMsg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.pipeline.msgc, pipelineMsg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isMsgApp(m raftpb.Message) bool { return m.Type == raftpb.MsgApp }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isMsgSnap(m raftpb.Message) bool { return m.Type == raftpb.MsgSnap }
