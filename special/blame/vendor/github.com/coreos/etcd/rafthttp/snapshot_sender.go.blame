0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a405384ce9c7fbbffc6a5a8bb2203d32e3b85976;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/snapshot_sender.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/snapshot_sender.go][vendor/github.com/coreos/etcd/rafthttp/snapshot_sender.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/httputil"
0000000000000000000000000000000000000000;;		pioutil "github.com/coreos/etcd/pkg/ioutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// timeout for reading snapshot response body
0000000000000000000000000000000000000000;;		snapResponseReadTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type snapshotSender struct {
0000000000000000000000000000000000000000;;		from, to types.ID
0000000000000000000000000000000000000000;;		cid      types.ID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr     *Transport
0000000000000000000000000000000000000000;;		picker *urlPicker
0000000000000000000000000000000000000000;;		status *peerStatus
0000000000000000000000000000000000000000;;		r      Raft
0000000000000000000000000000000000000000;;		errorc chan error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopc chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSnapshotSender(tr *Transport, picker *urlPicker, to types.ID, status *peerStatus) *snapshotSender {
0000000000000000000000000000000000000000;;		return &snapshotSender{
0000000000000000000000000000000000000000;;			from:   tr.ID,
0000000000000000000000000000000000000000;;			to:     to,
0000000000000000000000000000000000000000;;			cid:    tr.ClusterID,
0000000000000000000000000000000000000000;;			tr:     tr,
0000000000000000000000000000000000000000;;			picker: picker,
0000000000000000000000000000000000000000;;			status: status,
0000000000000000000000000000000000000000;;			r:      tr.Raft,
0000000000000000000000000000000000000000;;			errorc: tr.ErrorC,
0000000000000000000000000000000000000000;;			stopc:  make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *snapshotSender) stop() { close(s.stopc) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *snapshotSender) send(merged snap.Message) {
0000000000000000000000000000000000000000;;		m := merged.Message
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body := createSnapBody(merged)
0000000000000000000000000000000000000000;;		defer body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u := s.picker.pick()
0000000000000000000000000000000000000000;;		req := createPostRequest(u, RaftSnapshotPrefix, body, "application/octet-stream", s.tr.URLs, s.from, s.cid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("start to send database snapshot [index: %d, to %s]...", m.Snapshot.Metadata.Index, types.ID(m.To))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := s.post(req)
0000000000000000000000000000000000000000;;		defer merged.CloseWithError(err)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Warningf("database snapshot [index: %d, to: %s] failed to be sent out (%v)", m.Snapshot.Metadata.Index, types.ID(m.To), err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// errMemberRemoved is a critical error since a removed member should
0000000000000000000000000000000000000000;;			// always be stopped. So we use reportCriticalError to report it to errorc.
0000000000000000000000000000000000000000;;			if err == errMemberRemoved {
0000000000000000000000000000000000000000;;				reportCriticalError(err, s.errorc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.picker.unreachable(u)
0000000000000000000000000000000000000000;;			s.status.deactivate(failureType{source: sendSnap, action: "post"}, err.Error())
0000000000000000000000000000000000000000;;			s.r.ReportUnreachable(m.To)
0000000000000000000000000000000000000000;;			// report SnapshotFailure to raft state machine. After raft state
0000000000000000000000000000000000000000;;			// machine knows about it, it would pause a while and retry sending
0000000000000000000000000000000000000000;;			// new snapshot message.
0000000000000000000000000000000000000000;;			s.r.ReportSnapshot(m.To, raft.SnapshotFailure)
0000000000000000000000000000000000000000;;			sentFailures.WithLabelValues(types.ID(m.To).String()).Inc()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.status.activate()
0000000000000000000000000000000000000000;;		s.r.ReportSnapshot(m.To, raft.SnapshotFinish)
0000000000000000000000000000000000000000;;		plog.Infof("database snapshot [index: %d, to: %s] sent out successfully", m.Snapshot.Metadata.Index, types.ID(m.To))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sentBytes.WithLabelValues(types.ID(m.To).String()).Add(float64(merged.TotalSize))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// post posts the given request.
0000000000000000000000000000000000000000;;	// It returns nil when request is sent out and processed successfully.
0000000000000000000000000000000000000000;;	func (s *snapshotSender) post(req *http.Request) (err error) {
0000000000000000000000000000000000000000;;		cancel := httputil.RequestCanceler(req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type responseAndError struct {
0000000000000000000000000000000000000000;;			resp *http.Response
0000000000000000000000000000000000000000;;			body []byte
0000000000000000000000000000000000000000;;			err  error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make(chan responseAndError, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			resp, err := s.tr.pipelineRt.RoundTrip(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				result <- responseAndError{resp, nil, err}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// close the response body when timeouts.
0000000000000000000000000000000000000000;;			// prevents from reading the body forever when the other side dies right after
0000000000000000000000000000000000000000;;			// successfully receives the request body.
0000000000000000000000000000000000000000;;			time.AfterFunc(snapResponseReadTimeout, func() { httputil.GracefulClose(resp) })
0000000000000000000000000000000000000000;;			body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			result <- responseAndError{resp, body, err}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-s.stopc:
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;			return errStopped
0000000000000000000000000000000000000000;;		case r := <-result:
0000000000000000000000000000000000000000;;			if r.err != nil {
0000000000000000000000000000000000000000;;				return r.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return checkPostResponse(r.resp, r.body, req, s.to)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createSnapBody(merged snap.Message) io.ReadCloser {
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		enc := &messageEncoder{w: buf}
0000000000000000000000000000000000000000;;		// encode raft message
0000000000000000000000000000000000000000;;		if err := enc.encode(&merged.Message); err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("encode message error (%v)", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pioutil.ReaderAndCloser{
0000000000000000000000000000000000000000;;			Reader: io.MultiReader(buf, merged.ReadCloser),
0000000000000000000000000000000000000000;;			Closer: merged.ReadCloser,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
