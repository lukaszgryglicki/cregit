0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/stream.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/stream.go][vendor/github.com/coreos/etcd/rafthttp/stream.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/stats"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/httputil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/version"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-semver/semver"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		streamTypeMessage  streamType = "message"
0000000000000000000000000000000000000000;;		streamTypeMsgAppV2 streamType = "msgappv2"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamBufSize = 4096
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errUnsupportedStreamType = fmt.Errorf("unsupported stream type")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the key is in string format "major.minor.patch"
0000000000000000000000000000000000000000;;		supportedStream = map[string][]streamType{
0000000000000000000000000000000000000000;;			"2.0.0": {},
0000000000000000000000000000000000000000;;			"2.1.0": {streamTypeMsgAppV2, streamTypeMessage},
0000000000000000000000000000000000000000;;			"2.2.0": {streamTypeMsgAppV2, streamTypeMessage},
0000000000000000000000000000000000000000;;			"2.3.0": {streamTypeMsgAppV2, streamTypeMessage},
0000000000000000000000000000000000000000;;			"3.0.0": {streamTypeMsgAppV2, streamTypeMessage},
0000000000000000000000000000000000000000;;			"3.1.0": {streamTypeMsgAppV2, streamTypeMessage},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type streamType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t streamType) endpoint() string {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case streamTypeMsgAppV2:
0000000000000000000000000000000000000000;;			return path.Join(RaftStreamPrefix, "msgapp")
0000000000000000000000000000000000000000;;		case streamTypeMessage:
0000000000000000000000000000000000000000;;			return path.Join(RaftStreamPrefix, "message")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			plog.Panicf("unhandled stream type %v", t)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t streamType) String() string {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case streamTypeMsgAppV2:
0000000000000000000000000000000000000000;;			return "stream MsgApp v2"
0000000000000000000000000000000000000000;;		case streamTypeMessage:
0000000000000000000000000000000000000000;;			return "stream Message"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "unknown stream"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// linkHeartbeatMessage is a special message used as heartbeat message in
0000000000000000000000000000000000000000;;		// link layer. It never conflicts with messages from raft because raft
0000000000000000000000000000000000000000;;		// doesn't send out messages without From and To fields.
0000000000000000000000000000000000000000;;		linkHeartbeatMessage = raftpb.Message{Type: raftpb.MsgHeartbeat}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isLinkHeartbeatMessage(m *raftpb.Message) bool {
0000000000000000000000000000000000000000;;		return m.Type == raftpb.MsgHeartbeat && m.From == 0 && m.To == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type outgoingConn struct {
0000000000000000000000000000000000000000;;		t streamType
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;		http.Flusher
0000000000000000000000000000000000000000;;		io.Closer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamWriter writes messages to the attached outgoingConn.
0000000000000000000000000000000000000000;;	type streamWriter struct {
0000000000000000000000000000000000000000;;		peerID types.ID
0000000000000000000000000000000000000000;;		status *peerStatus
0000000000000000000000000000000000000000;;		fs     *stats.FollowerStats
0000000000000000000000000000000000000000;;		r      Raft
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu      sync.Mutex // guard field working and closer
0000000000000000000000000000000000000000;;		closer  io.Closer
0000000000000000000000000000000000000000;;		working bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgc  chan raftpb.Message
0000000000000000000000000000000000000000;;		connc chan *outgoingConn
0000000000000000000000000000000000000000;;		stopc chan struct{}
0000000000000000000000000000000000000000;;		done  chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startStreamWriter creates a streamWrite and starts a long running go-routine that accepts
0000000000000000000000000000000000000000;;	// messages and writes to the attached outgoing connection.
0000000000000000000000000000000000000000;;	func startStreamWriter(id types.ID, status *peerStatus, fs *stats.FollowerStats, r Raft) *streamWriter {
0000000000000000000000000000000000000000;;		w := &streamWriter{
0000000000000000000000000000000000000000;;			peerID: id,
0000000000000000000000000000000000000000;;			status: status,
0000000000000000000000000000000000000000;;			fs:     fs,
0000000000000000000000000000000000000000;;			r:      r,
0000000000000000000000000000000000000000;;			msgc:   make(chan raftpb.Message, streamBufSize),
0000000000000000000000000000000000000000;;			connc:  make(chan *outgoingConn),
0000000000000000000000000000000000000000;;			stopc:  make(chan struct{}),
0000000000000000000000000000000000000000;;			done:   make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go w.run()
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw *streamWriter) run() {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			msgc       chan raftpb.Message
0000000000000000000000000000000000000000;;			heartbeatc <-chan time.Time
0000000000000000000000000000000000000000;;			t          streamType
0000000000000000000000000000000000000000;;			enc        encoder
0000000000000000000000000000000000000000;;			flusher    http.Flusher
0000000000000000000000000000000000000000;;			batched    int
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		tickc := time.Tick(ConnReadTimeout / 3)
0000000000000000000000000000000000000000;;		unflushed := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("started streaming with peer %s (writer)", cw.peerID)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-heartbeatc:
0000000000000000000000000000000000000000;;				err := enc.encode(&linkHeartbeatMessage)
0000000000000000000000000000000000000000;;				unflushed += linkHeartbeatMessage.Size()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					flusher.Flush()
0000000000000000000000000000000000000000;;					batched = 0
0000000000000000000000000000000000000000;;					sentBytes.WithLabelValues(cw.peerID.String()).Add(float64(unflushed))
0000000000000000000000000000000000000000;;					unflushed = 0
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cw.status.deactivate(failureType{source: t.String(), action: "heartbeat"}, err.Error())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				sentFailures.WithLabelValues(cw.peerID.String()).Inc()
0000000000000000000000000000000000000000;;				cw.close()
0000000000000000000000000000000000000000;;				plog.Warningf("lost the TCP streaming connection with peer %s (%s writer)", cw.peerID, t)
0000000000000000000000000000000000000000;;				heartbeatc, msgc = nil, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case m := <-msgc:
0000000000000000000000000000000000000000;;				err := enc.encode(&m)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					unflushed += m.Size()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if len(msgc) == 0 || batched > streamBufSize/2 {
0000000000000000000000000000000000000000;;						flusher.Flush()
0000000000000000000000000000000000000000;;						sentBytes.WithLabelValues(cw.peerID.String()).Add(float64(unflushed))
0000000000000000000000000000000000000000;;						unflushed = 0
0000000000000000000000000000000000000000;;						batched = 0
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						batched++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cw.status.deactivate(failureType{source: t.String(), action: "write"}, err.Error())
0000000000000000000000000000000000000000;;				cw.close()
0000000000000000000000000000000000000000;;				plog.Warningf("lost the TCP streaming connection with peer %s (%s writer)", cw.peerID, t)
0000000000000000000000000000000000000000;;				heartbeatc, msgc = nil, nil
0000000000000000000000000000000000000000;;				cw.r.ReportUnreachable(m.To)
0000000000000000000000000000000000000000;;				sentFailures.WithLabelValues(cw.peerID.String()).Inc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case conn := <-cw.connc:
0000000000000000000000000000000000000000;;				cw.mu.Lock()
0000000000000000000000000000000000000000;;				closed := cw.closeUnlocked()
0000000000000000000000000000000000000000;;				t = conn.t
0000000000000000000000000000000000000000;;				switch conn.t {
0000000000000000000000000000000000000000;;				case streamTypeMsgAppV2:
0000000000000000000000000000000000000000;;					enc = newMsgAppV2Encoder(conn.Writer, cw.fs)
0000000000000000000000000000000000000000;;				case streamTypeMessage:
0000000000000000000000000000000000000000;;					enc = &messageEncoder{w: conn.Writer}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					plog.Panicf("unhandled stream type %s", conn.t)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				flusher = conn.Flusher
0000000000000000000000000000000000000000;;				unflushed = 0
0000000000000000000000000000000000000000;;				cw.status.activate()
0000000000000000000000000000000000000000;;				cw.closer = conn.Closer
0000000000000000000000000000000000000000;;				cw.working = true
0000000000000000000000000000000000000000;;				cw.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if closed {
0000000000000000000000000000000000000000;;					plog.Warningf("closed an existing TCP streaming connection with peer %s (%s writer)", cw.peerID, t)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Infof("established a TCP streaming connection with peer %s (%s writer)", cw.peerID, t)
0000000000000000000000000000000000000000;;				heartbeatc, msgc = tickc, cw.msgc
0000000000000000000000000000000000000000;;			case <-cw.stopc:
0000000000000000000000000000000000000000;;				if cw.close() {
0000000000000000000000000000000000000000;;					plog.Infof("closed the TCP streaming connection with peer %s (%s writer)", cw.peerID, t)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Infof("stopped streaming with peer %s (writer)", cw.peerID)
0000000000000000000000000000000000000000;;				close(cw.done)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw *streamWriter) writec() (chan<- raftpb.Message, bool) {
0000000000000000000000000000000000000000;;		cw.mu.Lock()
0000000000000000000000000000000000000000;;		defer cw.mu.Unlock()
0000000000000000000000000000000000000000;;		return cw.msgc, cw.working
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw *streamWriter) close() bool {
0000000000000000000000000000000000000000;;		cw.mu.Lock()
0000000000000000000000000000000000000000;;		defer cw.mu.Unlock()
0000000000000000000000000000000000000000;;		return cw.closeUnlocked()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw *streamWriter) closeUnlocked() bool {
0000000000000000000000000000000000000000;;		if !cw.working {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cw.closer.Close()
0000000000000000000000000000000000000000;;		if len(cw.msgc) > 0 {
0000000000000000000000000000000000000000;;			cw.r.ReportUnreachable(uint64(cw.peerID))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cw.msgc = make(chan raftpb.Message, streamBufSize)
0000000000000000000000000000000000000000;;		cw.working = false
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw *streamWriter) attach(conn *outgoingConn) bool {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case cw.connc <- conn:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case <-cw.done:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cw *streamWriter) stop() {
0000000000000000000000000000000000000000;;		close(cw.stopc)
0000000000000000000000000000000000000000;;		<-cw.done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// streamReader is a long-running go-routine that dials to the remote stream
0000000000000000000000000000000000000000;;	// endpoint and reads messages from the response body returned.
0000000000000000000000000000000000000000;;	type streamReader struct {
0000000000000000000000000000000000000000;;		peerID types.ID
0000000000000000000000000000000000000000;;		typ    streamType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr     *Transport
0000000000000000000000000000000000000000;;		picker *urlPicker
0000000000000000000000000000000000000000;;		status *peerStatus
0000000000000000000000000000000000000000;;		recvc  chan<- raftpb.Message
0000000000000000000000000000000000000000;;		propc  chan<- raftpb.Message
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errorc chan<- error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu     sync.Mutex
0000000000000000000000000000000000000000;;		paused bool
0000000000000000000000000000000000000000;;		cancel func()
0000000000000000000000000000000000000000;;		closer io.Closer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopc chan struct{}
0000000000000000000000000000000000000000;;		done  chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *streamReader) start() {
0000000000000000000000000000000000000000;;		r.stopc = make(chan struct{})
0000000000000000000000000000000000000000;;		r.done = make(chan struct{})
0000000000000000000000000000000000000000;;		if r.errorc == nil {
0000000000000000000000000000000000000000;;			r.errorc = r.tr.ErrorC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go r.run()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cr *streamReader) run() {
0000000000000000000000000000000000000000;;		t := cr.typ
0000000000000000000000000000000000000000;;		plog.Infof("started streaming with peer %s (%s reader)", cr.peerID, t)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			rc, err := cr.dial(t)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != errUnsupportedStreamType {
0000000000000000000000000000000000000000;;					cr.status.deactivate(failureType{source: t.String(), action: "dial"}, err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cr.status.activate()
0000000000000000000000000000000000000000;;				plog.Infof("established a TCP streaming connection with peer %s (%s reader)", cr.peerID, cr.typ)
0000000000000000000000000000000000000000;;				err := cr.decodeLoop(rc, t)
0000000000000000000000000000000000000000;;				plog.Warningf("lost the TCP streaming connection with peer %s (%s reader)", cr.peerID, cr.typ)
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				// all data is read out
0000000000000000000000000000000000000000;;				case err == io.EOF:
0000000000000000000000000000000000000000;;				// connection is closed by the remote
0000000000000000000000000000000000000000;;				case isClosedConnectionError(err):
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					cr.status.deactivate(failureType{source: t.String(), action: "read"}, err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			// Wait 100ms to create a new stream, so it doesn't bring too much
0000000000000000000000000000000000000000;;			// overhead when retry.
0000000000000000000000000000000000000000;;			case <-time.After(100 * time.Millisecond):
0000000000000000000000000000000000000000;;			case <-cr.stopc:
0000000000000000000000000000000000000000;;				plog.Infof("stopped streaming with peer %s (%s reader)", cr.peerID, t)
0000000000000000000000000000000000000000;;				close(cr.done)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cr *streamReader) decodeLoop(rc io.ReadCloser, t streamType) error {
0000000000000000000000000000000000000000;;		var dec decoder
0000000000000000000000000000000000000000;;		cr.mu.Lock()
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case streamTypeMsgAppV2:
0000000000000000000000000000000000000000;;			dec = newMsgAppV2Decoder(rc, cr.tr.ID, cr.peerID)
0000000000000000000000000000000000000000;;		case streamTypeMessage:
0000000000000000000000000000000000000000;;			dec = &messageDecoder{r: rc}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			plog.Panicf("unhandled stream type %s", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-cr.stopc:
0000000000000000000000000000000000000000;;			cr.mu.Unlock()
0000000000000000000000000000000000000000;;			if err := rc.Close(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			cr.closer = rc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			m, err := dec.decode()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cr.mu.Lock()
0000000000000000000000000000000000000000;;				cr.close()
0000000000000000000000000000000000000000;;				cr.mu.Unlock()
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			receivedBytes.WithLabelValues(types.ID(m.From).String()).Add(float64(m.Size()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cr.mu.Lock()
0000000000000000000000000000000000000000;;			paused := cr.paused
0000000000000000000000000000000000000000;;			cr.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if paused {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isLinkHeartbeatMessage(&m) {
0000000000000000000000000000000000000000;;				// raft is not interested in link layer
0000000000000000000000000000000000000000;;				// heartbeat message, so we should ignore
0000000000000000000000000000000000000000;;				// it.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			recvc := cr.recvc
0000000000000000000000000000000000000000;;			if m.Type == raftpb.MsgProp {
0000000000000000000000000000000000000000;;				recvc = cr.propc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case recvc <- m:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if cr.status.isActive() {
0000000000000000000000000000000000000000;;					plog.MergeWarningf("dropped internal raft message from %s since receiving buffer is full (overloaded network)", types.ID(m.From))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				plog.Debugf("dropped %s from %s since receiving buffer is full", m.Type, types.ID(m.From))
0000000000000000000000000000000000000000;;				recvFailures.WithLabelValues(types.ID(m.From).String()).Inc()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cr *streamReader) stop() {
0000000000000000000000000000000000000000;;		close(cr.stopc)
0000000000000000000000000000000000000000;;		cr.mu.Lock()
0000000000000000000000000000000000000000;;		if cr.cancel != nil {
0000000000000000000000000000000000000000;;			cr.cancel()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr.close()
0000000000000000000000000000000000000000;;		cr.mu.Unlock()
0000000000000000000000000000000000000000;;		<-cr.done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cr *streamReader) dial(t streamType) (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		u := cr.picker.pick()
0000000000000000000000000000000000000000;;		uu := u
0000000000000000000000000000000000000000;;		uu.Path = path.Join(t.endpoint(), cr.tr.ID.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", uu.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to make http request to %v (%v)", u, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("X-Server-From", cr.tr.ID.String())
0000000000000000000000000000000000000000;;		req.Header.Set("X-Server-Version", version.Version)
0000000000000000000000000000000000000000;;		req.Header.Set("X-Min-Cluster-Version", version.MinClusterVersion)
0000000000000000000000000000000000000000;;		req.Header.Set("X-Etcd-Cluster-ID", cr.tr.ClusterID.String())
0000000000000000000000000000000000000000;;		req.Header.Set("X-Raft-To", cr.peerID.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPeerURLsHeader(req, cr.tr.URLs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cr.mu.Lock()
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-cr.stopc:
0000000000000000000000000000000000000000;;			cr.mu.Unlock()
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("stream reader is stopped")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr.cancel = httputil.RequestCanceler(req)
0000000000000000000000000000000000000000;;		cr.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := cr.tr.streamRt.RoundTrip(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rv := serverVersion(resp.Header)
0000000000000000000000000000000000000000;;		lv := semver.Must(semver.NewVersion(version.Version))
0000000000000000000000000000000000000000;;		if compareMajorMinorVersion(rv, lv) == -1 && !checkStreamSupport(rv, t) {
0000000000000000000000000000000000000000;;			httputil.GracefulClose(resp)
0000000000000000000000000000000000000000;;			cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;			return nil, errUnsupportedStreamType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch resp.StatusCode {
0000000000000000000000000000000000000000;;		case http.StatusGone:
0000000000000000000000000000000000000000;;			httputil.GracefulClose(resp)
0000000000000000000000000000000000000000;;			cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;			reportCriticalError(errMemberRemoved, cr.errorc)
0000000000000000000000000000000000000000;;			return nil, errMemberRemoved
0000000000000000000000000000000000000000;;		case http.StatusOK:
0000000000000000000000000000000000000000;;			return resp.Body, nil
0000000000000000000000000000000000000000;;		case http.StatusNotFound:
0000000000000000000000000000000000000000;;			httputil.GracefulClose(resp)
0000000000000000000000000000000000000000;;			cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("peer %s failed to find local node %s", cr.peerID, cr.tr.ID)
0000000000000000000000000000000000000000;;		case http.StatusPreconditionFailed:
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			httputil.GracefulClose(resp)
0000000000000000000000000000000000000000;;			cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch strings.TrimSuffix(string(b), "\n") {
0000000000000000000000000000000000000000;;			case errIncompatibleVersion.Error():
0000000000000000000000000000000000000000;;				plog.Errorf("request sent was ignored by peer %s (server version incompatible)", cr.peerID)
0000000000000000000000000000000000000000;;				return nil, errIncompatibleVersion
0000000000000000000000000000000000000000;;			case errClusterIDMismatch.Error():
0000000000000000000000000000000000000000;;				plog.Errorf("request sent was ignored (cluster ID mismatch: peer[%s]=%s, local=%s)",
0000000000000000000000000000000000000000;;					cr.peerID, resp.Header.Get("X-Etcd-Cluster-ID"), cr.tr.ClusterID)
0000000000000000000000000000000000000000;;				return nil, errClusterIDMismatch
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unhandled error %q when precondition failed", string(b))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			httputil.GracefulClose(resp)
0000000000000000000000000000000000000000;;			cr.picker.unreachable(u)
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unhandled http status %d", resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cr *streamReader) close() {
0000000000000000000000000000000000000000;;		if cr.closer != nil {
0000000000000000000000000000000000000000;;			cr.closer.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr.closer = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cr *streamReader) pause() {
0000000000000000000000000000000000000000;;		cr.mu.Lock()
0000000000000000000000000000000000000000;;		defer cr.mu.Unlock()
0000000000000000000000000000000000000000;;		cr.paused = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cr *streamReader) resume() {
0000000000000000000000000000000000000000;;		cr.mu.Lock()
0000000000000000000000000000000000000000;;		defer cr.mu.Unlock()
0000000000000000000000000000000000000000;;		cr.paused = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isClosedConnectionError(err error) bool {
0000000000000000000000000000000000000000;;		operr, ok := err.(*net.OpError)
0000000000000000000000000000000000000000;;		return ok && operr.Err.Error() == "use of closed network connection"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkStreamSupport checks whether the stream type is supported in the
0000000000000000000000000000000000000000;;	// given version.
0000000000000000000000000000000000000000;;	func checkStreamSupport(v *semver.Version, t streamType) bool {
0000000000000000000000000000000000000000;;		nv := &semver.Version{Major: v.Major, Minor: v.Minor}
0000000000000000000000000000000000000000;;		for _, s := range supportedStream[nv.String()] {
0000000000000000000000000000000000000000;;			if s == t {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
