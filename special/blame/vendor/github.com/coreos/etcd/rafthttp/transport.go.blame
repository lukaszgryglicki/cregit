0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/transport.go[Godeps/_workspace/src/github.com/coreos/etcd/rafthttp/transport.go][vendor/github.com/coreos/etcd/rafthttp/transport.go];	
0000000000000000000000000000000000000000;;	package rafthttp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/stats"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/logutil"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/transport"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/raft/raftpb"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/snap"
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/capnslog"
0000000000000000000000000000000000000000;;		"github.com/xiang90/probing"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var plog = logutil.NewMergeLogger(capnslog.NewPackageLogger("github.com/coreos/etcd", "rafthttp"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Raft interface {
0000000000000000000000000000000000000000;;		Process(ctx context.Context, m raftpb.Message) error
0000000000000000000000000000000000000000;;		IsIDRemoved(id uint64) bool
0000000000000000000000000000000000000000;;		ReportUnreachable(id uint64)
0000000000000000000000000000000000000000;;		ReportSnapshot(id uint64, status raft.SnapshotStatus)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Transporter interface {
0000000000000000000000000000000000000000;;		// Start starts the given Transporter.
0000000000000000000000000000000000000000;;		// Start MUST be called before calling other functions in the interface.
0000000000000000000000000000000000000000;;		Start() error
0000000000000000000000000000000000000000;;		// Handler returns the HTTP handler of the transporter.
0000000000000000000000000000000000000000;;		// A transporter HTTP handler handles the HTTP requests
0000000000000000000000000000000000000000;;		// from remote peers.
0000000000000000000000000000000000000000;;		// The handler MUST be used to handle RaftPrefix(/raft)
0000000000000000000000000000000000000000;;		// endpoint.
0000000000000000000000000000000000000000;;		Handler() http.Handler
0000000000000000000000000000000000000000;;		// Send sends out the given messages to the remote peers.
0000000000000000000000000000000000000000;;		// Each message has a To field, which is an id that maps
0000000000000000000000000000000000000000;;		// to an existing peer in the transport.
0000000000000000000000000000000000000000;;		// If the id cannot be found in the transport, the message
0000000000000000000000000000000000000000;;		// will be ignored.
0000000000000000000000000000000000000000;;		Send(m []raftpb.Message)
0000000000000000000000000000000000000000;;		// SendSnapshot sends out the given snapshot message to a remote peer.
0000000000000000000000000000000000000000;;		// The behavior of SendSnapshot is similar to Send.
0000000000000000000000000000000000000000;;		SendSnapshot(m snap.Message)
0000000000000000000000000000000000000000;;		// AddRemote adds a remote with given peer urls into the transport.
0000000000000000000000000000000000000000;;		// A remote helps newly joined member to catch up the progress of cluster,
0000000000000000000000000000000000000000;;		// and will not be used after that.
0000000000000000000000000000000000000000;;		// It is the caller's responsibility to ensure the urls are all valid,
0000000000000000000000000000000000000000;;		// or it panics.
0000000000000000000000000000000000000000;;		AddRemote(id types.ID, urls []string)
0000000000000000000000000000000000000000;;		// AddPeer adds a peer with given peer urls into the transport.
0000000000000000000000000000000000000000;;		// It is the caller's responsibility to ensure the urls are all valid,
0000000000000000000000000000000000000000;;		// or it panics.
0000000000000000000000000000000000000000;;		// Peer urls are used to connect to the remote peer.
0000000000000000000000000000000000000000;;		AddPeer(id types.ID, urls []string)
0000000000000000000000000000000000000000;;		// RemovePeer removes the peer with given id.
0000000000000000000000000000000000000000;;		RemovePeer(id types.ID)
0000000000000000000000000000000000000000;;		// RemoveAllPeers removes all the existing peers in the transport.
0000000000000000000000000000000000000000;;		RemoveAllPeers()
0000000000000000000000000000000000000000;;		// UpdatePeer updates the peer urls of the peer with the given id.
0000000000000000000000000000000000000000;;		// It is the caller's responsibility to ensure the urls are all valid,
0000000000000000000000000000000000000000;;		// or it panics.
0000000000000000000000000000000000000000;;		UpdatePeer(id types.ID, urls []string)
0000000000000000000000000000000000000000;;		// ActiveSince returns the time that the connection with the peer
0000000000000000000000000000000000000000;;		// of the given id becomes active.
0000000000000000000000000000000000000000;;		// If the connection is active since peer was added, it returns the adding time.
0000000000000000000000000000000000000000;;		// If the connection is currently inactive, it returns zero time.
0000000000000000000000000000000000000000;;		ActiveSince(id types.ID) time.Time
0000000000000000000000000000000000000000;;		// Stop closes the connections and stops the transporter.
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Transport implements Transporter interface. It provides the functionality
0000000000000000000000000000000000000000;;	// to send raft messages to peers, and receive raft messages from peers.
0000000000000000000000000000000000000000;;	// User should call Handler method to get a handler to serve requests
0000000000000000000000000000000000000000;;	// received from peerURLs.
0000000000000000000000000000000000000000;;	// User needs to call Start before calling other functions, and call
0000000000000000000000000000000000000000;;	// Stop when the Transport is no longer used.
0000000000000000000000000000000000000000;;	type Transport struct {
0000000000000000000000000000000000000000;;		DialTimeout time.Duration     // maximum duration before timing out dial of the request
0000000000000000000000000000000000000000;;		TLSInfo     transport.TLSInfo // TLS information used when creating connection
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ID          types.ID   // local member ID
0000000000000000000000000000000000000000;;		URLs        types.URLs // local peer URLs
0000000000000000000000000000000000000000;;		ClusterID   types.ID   // raft cluster ID for request validation
0000000000000000000000000000000000000000;;		Raft        Raft       // raft state machine, to which the Transport forwards received messages and reports status
0000000000000000000000000000000000000000;;		Snapshotter *snap.Snapshotter
0000000000000000000000000000000000000000;;		ServerStats *stats.ServerStats // used to record general transportation statistics
0000000000000000000000000000000000000000;;		// used to record transportation statistics with followers when
0000000000000000000000000000000000000000;;		// performing as leader in raft protocol
0000000000000000000000000000000000000000;;		LeaderStats *stats.LeaderStats
0000000000000000000000000000000000000000;;		// ErrorC is used to report detected critical errors, e.g.,
0000000000000000000000000000000000000000;;		// the member has been permanently removed from the cluster
0000000000000000000000000000000000000000;;		// When an error is received from ErrorC, user should stop raft state
0000000000000000000000000000000000000000;;		// machine and thus stop the Transport.
0000000000000000000000000000000000000000;;		ErrorC chan error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		streamRt   http.RoundTripper // roundTripper used by streams
0000000000000000000000000000000000000000;;		pipelineRt http.RoundTripper // roundTripper used by pipelines
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu      sync.RWMutex         // protect the remote and peer map
0000000000000000000000000000000000000000;;		remotes map[types.ID]*remote // remotes map that helps newly joined member to catch up
0000000000000000000000000000000000000000;;		peers   map[types.ID]Peer    // peers map
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prober probing.Prober
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) Start() error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		t.streamRt, err = newStreamRoundTripper(t.TLSInfo, t.DialTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.pipelineRt, err = NewRoundTripper(t.TLSInfo, t.DialTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.remotes = make(map[types.ID]*remote)
0000000000000000000000000000000000000000;;		t.peers = make(map[types.ID]Peer)
0000000000000000000000000000000000000000;;		t.prober = probing.NewProber(t.pipelineRt)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) Handler() http.Handler {
0000000000000000000000000000000000000000;;		pipelineHandler := newPipelineHandler(t, t.Raft, t.ClusterID)
0000000000000000000000000000000000000000;;		streamHandler := newStreamHandler(t, t, t.Raft, t.ID, t.ClusterID)
0000000000000000000000000000000000000000;;		snapHandler := newSnapshotHandler(t, t.Raft, t.Snapshotter, t.ClusterID)
0000000000000000000000000000000000000000;;		mux := http.NewServeMux()
0000000000000000000000000000000000000000;;		mux.Handle(RaftPrefix, pipelineHandler)
0000000000000000000000000000000000000000;;		mux.Handle(RaftStreamPrefix+"/", streamHandler)
0000000000000000000000000000000000000000;;		mux.Handle(RaftSnapshotPrefix, snapHandler)
0000000000000000000000000000000000000000;;		mux.Handle(ProbingPrefix, probing.NewHandler())
0000000000000000000000000000000000000000;;		return mux
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) Get(id types.ID) Peer {
0000000000000000000000000000000000000000;;		t.mu.RLock()
0000000000000000000000000000000000000000;;		defer t.mu.RUnlock()
0000000000000000000000000000000000000000;;		return t.peers[id]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) Send(msgs []raftpb.Message) {
0000000000000000000000000000000000000000;;		for _, m := range msgs {
0000000000000000000000000000000000000000;;			if m.To == 0 {
0000000000000000000000000000000000000000;;				// ignore intentionally dropped message
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			to := types.ID(m.To)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.mu.RLock()
0000000000000000000000000000000000000000;;			p, pok := t.peers[to]
0000000000000000000000000000000000000000;;			g, rok := t.remotes[to]
0000000000000000000000000000000000000000;;			t.mu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pok {
0000000000000000000000000000000000000000;;				if m.Type == raftpb.MsgApp {
0000000000000000000000000000000000000000;;					t.ServerStats.SendAppendReq(m.Size())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.send(m)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if rok {
0000000000000000000000000000000000000000;;				g.send(m)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			plog.Debugf("ignored message %s (sent to unknown peer %s)", m.Type, to)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) Stop() {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		for _, r := range t.remotes {
0000000000000000000000000000000000000000;;			r.stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, p := range t.peers {
0000000000000000000000000000000000000000;;			p.stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.prober.RemoveAll()
0000000000000000000000000000000000000000;;		if tr, ok := t.streamRt.(*http.Transport); ok {
0000000000000000000000000000000000000000;;			tr.CloseIdleConnections()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tr, ok := t.pipelineRt.(*http.Transport); ok {
0000000000000000000000000000000000000000;;			tr.CloseIdleConnections()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.peers = nil
0000000000000000000000000000000000000000;;		t.remotes = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CutPeer drops messages to the specified peer.
0000000000000000000000000000000000000000;;	func (t *Transport) CutPeer(id types.ID) {
0000000000000000000000000000000000000000;;		t.mu.RLock()
0000000000000000000000000000000000000000;;		p, pok := t.peers[id]
0000000000000000000000000000000000000000;;		g, gok := t.remotes[id]
0000000000000000000000000000000000000000;;		t.mu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pok {
0000000000000000000000000000000000000000;;			p.(Pausable).Pause()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gok {
0000000000000000000000000000000000000000;;			g.Pause()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MendPeer recovers the message dropping behavior of the given peer.
0000000000000000000000000000000000000000;;	func (t *Transport) MendPeer(id types.ID) {
0000000000000000000000000000000000000000;;		t.mu.RLock()
0000000000000000000000000000000000000000;;		p, pok := t.peers[id]
0000000000000000000000000000000000000000;;		g, gok := t.remotes[id]
0000000000000000000000000000000000000000;;		t.mu.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pok {
0000000000000000000000000000000000000000;;			p.(Pausable).Resume()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gok {
0000000000000000000000000000000000000000;;			g.Resume()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) AddRemote(id types.ID, us []string) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		if t.remotes == nil {
0000000000000000000000000000000000000000;;			// there's no clean way to shutdown the golang http server
0000000000000000000000000000000000000000;;			// (see: https://github.com/golang/go/issues/4674) before
0000000000000000000000000000000000000000;;			// stopping the transport; ignore any new connections.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := t.peers[id]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := t.remotes[id]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		urls, err := types.NewURLs(us)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("newURLs %+v should never fail: %+v", us, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.remotes[id] = startRemote(t, urls, id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) AddPeer(id types.ID, us []string) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.peers == nil {
0000000000000000000000000000000000000000;;			panic("transport stopped")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := t.peers[id]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		urls, err := types.NewURLs(us)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("newURLs %+v should never fail: %+v", us, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fs := t.LeaderStats.Follower(id.String())
0000000000000000000000000000000000000000;;		t.peers[id] = startPeer(t, urls, id, fs)
0000000000000000000000000000000000000000;;		addPeerToProber(t.prober, id.String(), us)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		plog.Infof("added peer %s", id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) RemovePeer(id types.ID) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		t.removePeer(id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) RemoveAllPeers() {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		for id := range t.peers {
0000000000000000000000000000000000000000;;			t.removePeer(id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// the caller of this function must have the peers mutex.
0000000000000000000000000000000000000000;;	func (t *Transport) removePeer(id types.ID) {
0000000000000000000000000000000000000000;;		if peer, ok := t.peers[id]; ok {
0000000000000000000000000000000000000000;;			peer.stop()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			plog.Panicf("unexpected removal of unknown peer '%d'", id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(t.peers, id)
0000000000000000000000000000000000000000;;		delete(t.LeaderStats.Followers, id.String())
0000000000000000000000000000000000000000;;		t.prober.Remove(id.String())
0000000000000000000000000000000000000000;;		plog.Infof("removed peer %s", id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) UpdatePeer(id types.ID, us []string) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		// TODO: return error or just panic?
0000000000000000000000000000000000000000;;		if _, ok := t.peers[id]; !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		urls, err := types.NewURLs(us)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			plog.Panicf("newURLs %+v should never fail: %+v", us, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.peers[id].update(urls)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.prober.Remove(id.String())
0000000000000000000000000000000000000000;;		addPeerToProber(t.prober, id.String(), us)
0000000000000000000000000000000000000000;;		plog.Infof("updated peer %s", id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) ActiveSince(id types.ID) time.Time {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		if p, ok := t.peers[id]; ok {
0000000000000000000000000000000000000000;;			return p.activeSince()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Time{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) SendSnapshot(m snap.Message) {
0000000000000000000000000000000000000000;;		t.mu.Lock()
0000000000000000000000000000000000000000;;		defer t.mu.Unlock()
0000000000000000000000000000000000000000;;		p := t.peers[types.ID(m.To)]
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			m.CloseWithError(errMemberNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.sendSnap(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pausable is a testing interface for pausing transport traffic.
0000000000000000000000000000000000000000;;	type Pausable interface {
0000000000000000000000000000000000000000;;		Pause()
0000000000000000000000000000000000000000;;		Resume()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) Pause() {
0000000000000000000000000000000000000000;;		for _, p := range t.peers {
0000000000000000000000000000000000000000;;			p.(Pausable).Pause()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transport) Resume() {
0000000000000000000000000000000000000000;;		for _, p := range t.peers {
0000000000000000000000000000000000000000;;			p.(Pausable).Resume()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nopTransporter struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNopTransporter() Transporter {
0000000000000000000000000000000000000000;;		return &nopTransporter{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *nopTransporter) Start() error                        { return nil }
0000000000000000000000000000000000000000;;	func (s *nopTransporter) Handler() http.Handler               { return nil }
0000000000000000000000000000000000000000;;	func (s *nopTransporter) Send(m []raftpb.Message)             {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) SendSnapshot(m snap.Message)         {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) AddRemote(id types.ID, us []string)  {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) AddPeer(id types.ID, us []string)    {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) RemovePeer(id types.ID)              {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) RemoveAllPeers()                     {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) UpdatePeer(id types.ID, us []string) {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) ActiveSince(id types.ID) time.Time   { return time.Time{} }
0000000000000000000000000000000000000000;;	func (s *nopTransporter) Stop()                               {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) Pause()                              {}
0000000000000000000000000000000000000000;;	func (s *nopTransporter) Resume()                             {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type snapTransporter struct {
0000000000000000000000000000000000000000;;		nopTransporter
0000000000000000000000000000000000000000;;		snapDoneC chan snap.Message
0000000000000000000000000000000000000000;;		snapDir   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSnapTransporter(snapDir string) (Transporter, <-chan snap.Message) {
0000000000000000000000000000000000000000;;		ch := make(chan snap.Message, 1)
0000000000000000000000000000000000000000;;		tr := &snapTransporter{snapDoneC: ch, snapDir: snapDir}
0000000000000000000000000000000000000000;;		return tr, ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *snapTransporter) SendSnapshot(m snap.Message) {
0000000000000000000000000000000000000000;;		ss := snap.New(s.snapDir)
0000000000000000000000000000000000000000;;		ss.SaveDBFrom(m.ReadCloser, m.Snapshot.Metadata.Index+1)
0000000000000000000000000000000000000000;;		m.CloseWithError(nil)
0000000000000000000000000000000000000000;;		s.snapDoneC <- m
0000000000000000000000000000000000000000;;	}
