0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/store/watcher.go[Godeps/_workspace/src/github.com/coreos/etcd/store/watcher.go][vendor/github.com/coreos/etcd/store/watcher.go];	
0000000000000000000000000000000000000000;;	package store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Watcher interface {
0000000000000000000000000000000000000000;;		EventChan() chan *Event
0000000000000000000000000000000000000000;;		StartIndex() uint64 // The EtcdIndex at which the Watcher was created
0000000000000000000000000000000000000000;;		Remove()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type watcher struct {
0000000000000000000000000000000000000000;;		eventChan  chan *Event
0000000000000000000000000000000000000000;;		stream     bool
0000000000000000000000000000000000000000;;		recursive  bool
0000000000000000000000000000000000000000;;		sinceIndex uint64
0000000000000000000000000000000000000000;;		startIndex uint64
0000000000000000000000000000000000000000;;		hub        *watcherHub
0000000000000000000000000000000000000000;;		removed    bool
0000000000000000000000000000000000000000;;		remove     func()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watcher) EventChan() chan *Event {
0000000000000000000000000000000000000000;;		return w.eventChan
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watcher) StartIndex() uint64 {
0000000000000000000000000000000000000000;;		return w.startIndex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notify function notifies the watcher. If the watcher interests in the given path,
0000000000000000000000000000000000000000;;	// the function will return true.
0000000000000000000000000000000000000000;;	func (w *watcher) notify(e *Event, originalPath bool, deleted bool) bool {
0000000000000000000000000000000000000000;;		// watcher is interested the path in three cases and under one condition
0000000000000000000000000000000000000000;;		// the condition is that the event happens after the watcher's sinceIndex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. the path at which the event happens is the path the watcher is watching at.
0000000000000000000000000000000000000000;;		// For example if the watcher is watching at "/foo" and the event happens at "/foo",
0000000000000000000000000000000000000000;;		// the watcher must be interested in that event.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. the watcher is a recursive watcher, it interests in the event happens after
0000000000000000000000000000000000000000;;		// its watching path. For example if watcher A watches at "/foo" and it is a recursive
0000000000000000000000000000000000000000;;		// one, it will interest in the event happens at "/foo/bar".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3. when we delete a directory, we need to force notify all the watchers who watches
0000000000000000000000000000000000000000;;		// at the file we need to delete.
0000000000000000000000000000000000000000;;		// For example a watcher is watching at "/foo/bar". And we deletes "/foo". The watcher
0000000000000000000000000000000000000000;;		// should get notified even if "/foo" is not the path it is watching.
0000000000000000000000000000000000000000;;		if (w.recursive || originalPath || deleted) && e.Index() >= w.sinceIndex {
0000000000000000000000000000000000000000;;			// We cannot block here if the eventChan capacity is full, otherwise
0000000000000000000000000000000000000000;;			// etcd will hang. eventChan capacity is full when the rate of
0000000000000000000000000000000000000000;;			// notifications are higher than our send rate.
0000000000000000000000000000000000000000;;			// If this happens, we close the channel.
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case w.eventChan <- e:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// We have missed a notification. Remove the watcher.
0000000000000000000000000000000000000000;;				// Removing the watcher also closes the eventChan.
0000000000000000000000000000000000000000;;				w.remove()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the watcher from watcherHub
0000000000000000000000000000000000000000;;	// The actual remove function is guaranteed to only be executed once
0000000000000000000000000000000000000000;;	func (w *watcher) Remove() {
0000000000000000000000000000000000000000;;		w.hub.mutex.Lock()
0000000000000000000000000000000000000000;;		defer w.hub.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(w.eventChan)
0000000000000000000000000000000000000000;;		if w.remove != nil {
0000000000000000000000000000000000000000;;			w.remove()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nopWatcher is a watcher that receives nothing, always blocking.
0000000000000000000000000000000000000000;;	type nopWatcher struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewNopWatcher() Watcher                 { return &nopWatcher{} }
0000000000000000000000000000000000000000;;	func (w *nopWatcher) EventChan() chan *Event { return nil }
0000000000000000000000000000000000000000;;	func (w *nopWatcher) StartIndex() uint64     { return 0 }
0000000000000000000000000000000000000000;;	func (w *nopWatcher) Remove()                {}
