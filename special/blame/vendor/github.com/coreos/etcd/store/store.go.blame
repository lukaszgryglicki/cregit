0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/store/store.go[Godeps/_workspace/src/github.com/coreos/etcd/store/store.go][vendor/github.com/coreos/etcd/store/store.go];	
0000000000000000000000000000000000000000;;	package store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdErr "github.com/coreos/etcd/error"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The default version to set when the store is first initialized.
0000000000000000000000000000000000000000;;	const defaultVersion = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var minExpireTime time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		minExpireTime, _ = time.Parse(time.RFC3339, "2000-01-01T00:00:00Z")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Store interface {
0000000000000000000000000000000000000000;;		Version() int
0000000000000000000000000000000000000000;;		Index() uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Get(nodePath string, recursive, sorted bool) (*Event, error)
0000000000000000000000000000000000000000;;		Set(nodePath string, dir bool, value string, expireOpts TTLOptionSet) (*Event, error)
0000000000000000000000000000000000000000;;		Update(nodePath string, newValue string, expireOpts TTLOptionSet) (*Event, error)
0000000000000000000000000000000000000000;;		Create(nodePath string, dir bool, value string, unique bool,
0000000000000000000000000000000000000000;;			expireOpts TTLOptionSet) (*Event, error)
0000000000000000000000000000000000000000;;		CompareAndSwap(nodePath string, prevValue string, prevIndex uint64,
0000000000000000000000000000000000000000;;			value string, expireOpts TTLOptionSet) (*Event, error)
0000000000000000000000000000000000000000;;		Delete(nodePath string, dir, recursive bool) (*Event, error)
0000000000000000000000000000000000000000;;		CompareAndDelete(nodePath string, prevValue string, prevIndex uint64) (*Event, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Watch(prefix string, recursive, stream bool, sinceIndex uint64) (Watcher, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Save() ([]byte, error)
0000000000000000000000000000000000000000;;		Recovery(state []byte) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Clone() Store
0000000000000000000000000000000000000000;;		SaveNoCopy() ([]byte, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		JsonStats() []byte
0000000000000000000000000000000000000000;;		DeleteExpiredKeys(cutoff time.Time)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HasTTLKeys() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TTLOptionSet struct {
0000000000000000000000000000000000000000;;		ExpireTime time.Time
0000000000000000000000000000000000000000;;		Refresh    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type store struct {
0000000000000000000000000000000000000000;;		Root           *node
0000000000000000000000000000000000000000;;		WatcherHub     *watcherHub
0000000000000000000000000000000000000000;;		CurrentIndex   uint64
0000000000000000000000000000000000000000;;		Stats          *Stats
0000000000000000000000000000000000000000;;		CurrentVersion int
0000000000000000000000000000000000000000;;		ttlKeyHeap     *ttlKeyHeap  // need to recovery manually
0000000000000000000000000000000000000000;;		worldLock      sync.RWMutex // stop the world lock
0000000000000000000000000000000000000000;;		clock          clockwork.Clock
0000000000000000000000000000000000000000;;		readonlySet    types.Set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a store where the given namespaces will be created as initial directories.
0000000000000000000000000000000000000000;;	func New(namespaces ...string) Store {
0000000000000000000000000000000000000000;;		s := newStore(namespaces...)
0000000000000000000000000000000000000000;;		s.clock = clockwork.NewRealClock()
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newStore(namespaces ...string) *store {
0000000000000000000000000000000000000000;;		s := new(store)
0000000000000000000000000000000000000000;;		s.CurrentVersion = defaultVersion
0000000000000000000000000000000000000000;;		s.Root = newDir(s, "/", s.CurrentIndex, nil, Permanent)
0000000000000000000000000000000000000000;;		for _, namespace := range namespaces {
0000000000000000000000000000000000000000;;			s.Root.Add(newDir(s, namespace, s.CurrentIndex, s.Root, Permanent))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.Stats = newStats()
0000000000000000000000000000000000000000;;		s.WatcherHub = newWatchHub(1000)
0000000000000000000000000000000000000000;;		s.ttlKeyHeap = newTtlKeyHeap()
0000000000000000000000000000000000000000;;		s.readonlySet = types.NewUnsafeSet(append(namespaces, "/")...)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version retrieves current version of the store.
0000000000000000000000000000000000000000;;	func (s *store) Version() int {
0000000000000000000000000000000000000000;;		return s.CurrentVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Index retrieves the current index of the store.
0000000000000000000000000000000000000000;;	func (s *store) Index() uint64 {
0000000000000000000000000000000000000000;;		s.worldLock.RLock()
0000000000000000000000000000000000000000;;		defer s.worldLock.RUnlock()
0000000000000000000000000000000000000000;;		return s.CurrentIndex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns a get event.
0000000000000000000000000000000000000000;;	// If recursive is true, it will return all the content under the node path.
0000000000000000000000000000000000000000;;	// If sorted is true, it will sort the content by keys.
0000000000000000000000000000000000000000;;	func (s *store) Get(nodePath string, recursive, sorted bool) (*Event, error) {
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.RLock()
0000000000000000000000000000000000000000;;		defer s.worldLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				s.Stats.Inc(GetSuccess)
0000000000000000000000000000000000000000;;				if recursive {
0000000000000000000000000000000000000000;;					reportReadSuccess(GetRecursive)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					reportReadSuccess(Get)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.Stats.Inc(GetFail)
0000000000000000000000000000000000000000;;			if recursive {
0000000000000000000000000000000000000000;;				reportReadFailure(GetRecursive)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				reportReadFailure(Get)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := s.internalGet(nodePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := newEvent(Get, nodePath, n.ModifiedIndex, n.CreatedIndex)
0000000000000000000000000000000000000000;;		e.EtcdIndex = s.CurrentIndex
0000000000000000000000000000000000000000;;		e.Node.loadInternalNode(n, recursive, sorted, s.clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates the node at nodePath. Create will help to create intermediate directories with no ttl.
0000000000000000000000000000000000000000;;	// If the node has already existed, create will fail.
0000000000000000000000000000000000000000;;	// If any node on the path is a file, create will fail.
0000000000000000000000000000000000000000;;	func (s *store) Create(nodePath string, dir bool, value string, unique bool, expireOpts TTLOptionSet) (*Event, error) {
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				s.Stats.Inc(CreateSuccess)
0000000000000000000000000000000000000000;;				reportWriteSuccess(Create)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.Stats.Inc(CreateFail)
0000000000000000000000000000000000000000;;			reportWriteFailure(Create)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e, err := s.internalCreate(nodePath, dir, value, unique, false, expireOpts.ExpireTime, Create)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e.EtcdIndex = s.CurrentIndex
0000000000000000000000000000000000000000;;		s.WatcherHub.notify(e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set creates or replace the node at nodePath.
0000000000000000000000000000000000000000;;	func (s *store) Set(nodePath string, dir bool, value string, expireOpts TTLOptionSet) (*Event, error) {
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				s.Stats.Inc(SetSuccess)
0000000000000000000000000000000000000000;;				reportWriteSuccess(Set)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.Stats.Inc(SetFail)
0000000000000000000000000000000000000000;;			reportWriteFailure(Set)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get prevNode value
0000000000000000000000000000000000000000;;		n, getErr := s.internalGet(nodePath)
0000000000000000000000000000000000000000;;		if getErr != nil && getErr.ErrorCode != etcdErr.EcodeKeyNotFound {
0000000000000000000000000000000000000000;;			err = getErr
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expireOpts.Refresh {
0000000000000000000000000000000000000000;;			if getErr != nil {
0000000000000000000000000000000000000000;;				err = getErr
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				value = n.Value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set new value
0000000000000000000000000000000000000000;;		e, err := s.internalCreate(nodePath, dir, value, false, true, expireOpts.ExpireTime, Set)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.EtcdIndex = s.CurrentIndex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Put prevNode into event
0000000000000000000000000000000000000000;;		if getErr == nil {
0000000000000000000000000000000000000000;;			prev := newEvent(Get, nodePath, n.ModifiedIndex, n.CreatedIndex)
0000000000000000000000000000000000000000;;			prev.Node.loadInternalNode(n, false, false, s.clock)
0000000000000000000000000000000000000000;;			e.PrevNode = prev.Node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !expireOpts.Refresh {
0000000000000000000000000000000000000000;;			s.WatcherHub.notify(e)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.SetRefresh()
0000000000000000000000000000000000000000;;			s.WatcherHub.add(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns user-readable cause of failed comparison
0000000000000000000000000000000000000000;;	func getCompareFailCause(n *node, which int, prevValue string, prevIndex uint64) string {
0000000000000000000000000000000000000000;;		switch which {
0000000000000000000000000000000000000000;;		case CompareIndexNotMatch:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("[%v != %v]", prevIndex, n.ModifiedIndex)
0000000000000000000000000000000000000000;;		case CompareValueNotMatch:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("[%v != %v]", prevValue, n.Value)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("[%v != %v] [%v != %v]", prevValue, n.Value, prevIndex, n.ModifiedIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) CompareAndSwap(nodePath string, prevValue string, prevIndex uint64,
0000000000000000000000000000000000000000;;		value string, expireOpts TTLOptionSet) (*Event, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				s.Stats.Inc(CompareAndSwapSuccess)
0000000000000000000000000000000000000000;;				reportWriteSuccess(CompareAndSwap)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.Stats.Inc(CompareAndSwapFail)
0000000000000000000000000000000000000000;;			reportWriteFailure(CompareAndSwap)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePath = path.Clean(path.Join("/", nodePath))
0000000000000000000000000000000000000000;;		// we do not allow the user to change "/"
0000000000000000000000000000000000000000;;		if s.readonlySet.Contains(nodePath) {
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := s.internalGet(nodePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.IsDir() { // can only compare and swap file
0000000000000000000000000000000000000000;;			err = etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, s.CurrentIndex)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If both of the prevValue and prevIndex are given, we will test both of them.
0000000000000000000000000000000000000000;;		// Command will be executed, only if both of the tests are successful.
0000000000000000000000000000000000000000;;		if ok, which := n.Compare(prevValue, prevIndex); !ok {
0000000000000000000000000000000000000000;;			cause := getCompareFailCause(n, which, prevValue, prevIndex)
0000000000000000000000000000000000000000;;			err = etcdErr.NewError(etcdErr.EcodeTestFailed, cause, s.CurrentIndex)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expireOpts.Refresh {
0000000000000000000000000000000000000000;;			value = n.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update etcd index
0000000000000000000000000000000000000000;;		s.CurrentIndex++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := newEvent(CompareAndSwap, nodePath, s.CurrentIndex, n.CreatedIndex)
0000000000000000000000000000000000000000;;		e.EtcdIndex = s.CurrentIndex
0000000000000000000000000000000000000000;;		e.PrevNode = n.Repr(false, false, s.clock)
0000000000000000000000000000000000000000;;		eNode := e.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if test succeed, write the value
0000000000000000000000000000000000000000;;		n.Write(value, s.CurrentIndex)
0000000000000000000000000000000000000000;;		n.UpdateTTL(expireOpts.ExpireTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copy the value for safety
0000000000000000000000000000000000000000;;		valueCopy := value
0000000000000000000000000000000000000000;;		eNode.Value = &valueCopy
0000000000000000000000000000000000000000;;		eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !expireOpts.Refresh {
0000000000000000000000000000000000000000;;			s.WatcherHub.notify(e)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.SetRefresh()
0000000000000000000000000000000000000000;;			s.WatcherHub.add(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete deletes the node at the given path.
0000000000000000000000000000000000000000;;	// If the node is a directory, recursive must be true to delete it.
0000000000000000000000000000000000000000;;	func (s *store) Delete(nodePath string, dir, recursive bool) (*Event, error) {
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				s.Stats.Inc(DeleteSuccess)
0000000000000000000000000000000000000000;;				reportWriteSuccess(Delete)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.Stats.Inc(DeleteFail)
0000000000000000000000000000000000000000;;			reportWriteFailure(Delete)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePath = path.Clean(path.Join("/", nodePath))
0000000000000000000000000000000000000000;;		// we do not allow the user to change "/"
0000000000000000000000000000000000000000;;		if s.readonlySet.Contains(nodePath) {
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// recursive implies dir
0000000000000000000000000000000000000000;;		if recursive {
0000000000000000000000000000000000000000;;			dir = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := s.internalGet(nodePath)
0000000000000000000000000000000000000000;;		if err != nil { // if the node does not exist, return error
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nextIndex := s.CurrentIndex + 1
0000000000000000000000000000000000000000;;		e := newEvent(Delete, nodePath, nextIndex, n.CreatedIndex)
0000000000000000000000000000000000000000;;		e.EtcdIndex = nextIndex
0000000000000000000000000000000000000000;;		e.PrevNode = n.Repr(false, false, s.clock)
0000000000000000000000000000000000000000;;		eNode := e.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n.IsDir() {
0000000000000000000000000000000000000000;;			eNode.Dir = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		callback := func(path string) { // notify function
0000000000000000000000000000000000000000;;			// notify the watchers with deleted set true
0000000000000000000000000000000000000000;;			s.WatcherHub.notifyWatchers(e, path, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = n.Remove(dir, recursive, callback)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update etcd index
0000000000000000000000000000000000000000;;		s.CurrentIndex++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.WatcherHub.notify(e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) CompareAndDelete(nodePath string, prevValue string, prevIndex uint64) (*Event, error) {
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				s.Stats.Inc(CompareAndDeleteSuccess)
0000000000000000000000000000000000000000;;				reportWriteSuccess(CompareAndDelete)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.Stats.Inc(CompareAndDeleteFail)
0000000000000000000000000000000000000000;;			reportWriteFailure(CompareAndDelete)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePath = path.Clean(path.Join("/", nodePath))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := s.internalGet(nodePath)
0000000000000000000000000000000000000000;;		if err != nil { // if the node does not exist, return error
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.IsDir() { // can only compare and delete file
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, s.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If both of the prevValue and prevIndex are given, we will test both of them.
0000000000000000000000000000000000000000;;		// Command will be executed, only if both of the tests are successful.
0000000000000000000000000000000000000000;;		if ok, which := n.Compare(prevValue, prevIndex); !ok {
0000000000000000000000000000000000000000;;			cause := getCompareFailCause(n, which, prevValue, prevIndex)
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeTestFailed, cause, s.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update etcd index
0000000000000000000000000000000000000000;;		s.CurrentIndex++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := newEvent(CompareAndDelete, nodePath, s.CurrentIndex, n.CreatedIndex)
0000000000000000000000000000000000000000;;		e.EtcdIndex = s.CurrentIndex
0000000000000000000000000000000000000000;;		e.PrevNode = n.Repr(false, false, s.clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		callback := func(path string) { // notify function
0000000000000000000000000000000000000000;;			// notify the watchers with deleted set true
0000000000000000000000000000000000000000;;			s.WatcherHub.notifyWatchers(e, path, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = n.Remove(false, false, callback)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.WatcherHub.notify(e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Watch(key string, recursive, stream bool, sinceIndex uint64) (Watcher, error) {
0000000000000000000000000000000000000000;;		s.worldLock.RLock()
0000000000000000000000000000000000000000;;		defer s.worldLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key = path.Clean(path.Join("/", key))
0000000000000000000000000000000000000000;;		if sinceIndex == 0 {
0000000000000000000000000000000000000000;;			sinceIndex = s.CurrentIndex + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// WatcherHub does not know about the current index, so we need to pass it in
0000000000000000000000000000000000000000;;		w, err := s.WatcherHub.watch(key, recursive, stream, sinceIndex, s.CurrentIndex)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// walk walks all the nodePath and apply the walkFunc on each directory
0000000000000000000000000000000000000000;;	func (s *store) walk(nodePath string, walkFunc func(prev *node, component string) (*node, *etcdErr.Error)) (*node, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		components := strings.Split(nodePath, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curr := s.Root
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 1; i < len(components); i++ {
0000000000000000000000000000000000000000;;			if len(components[i]) == 0 { // ignore empty string
0000000000000000000000000000000000000000;;				return curr, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			curr, err = walkFunc(curr, components[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return curr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update updates the value/ttl of the node.
0000000000000000000000000000000000000000;;	// If the node is a file, the value and the ttl can be updated.
0000000000000000000000000000000000000000;;	// If the node is a directory, only the ttl can be updated.
0000000000000000000000000000000000000000;;	func (s *store) Update(nodePath string, newValue string, expireOpts TTLOptionSet) (*Event, error) {
0000000000000000000000000000000000000000;;		var err *etcdErr.Error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				s.Stats.Inc(UpdateSuccess)
0000000000000000000000000000000000000000;;				reportWriteSuccess(Update)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.Stats.Inc(UpdateFail)
0000000000000000000000000000000000000000;;			reportWriteFailure(Update)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePath = path.Clean(path.Join("/", nodePath))
0000000000000000000000000000000000000000;;		// we do not allow the user to change "/"
0000000000000000000000000000000000000000;;		if s.readonlySet.Contains(nodePath) {
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", s.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currIndex, nextIndex := s.CurrentIndex, s.CurrentIndex+1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := s.internalGet(nodePath)
0000000000000000000000000000000000000000;;		if err != nil { // if the node does not exist, return error
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.IsDir() && len(newValue) != 0 {
0000000000000000000000000000000000000000;;			// if the node is a directory, we cannot update value to non-empty
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, currIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expireOpts.Refresh {
0000000000000000000000000000000000000000;;			newValue = n.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := newEvent(Update, nodePath, nextIndex, n.CreatedIndex)
0000000000000000000000000000000000000000;;		e.EtcdIndex = nextIndex
0000000000000000000000000000000000000000;;		e.PrevNode = n.Repr(false, false, s.clock)
0000000000000000000000000000000000000000;;		eNode := e.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.Write(newValue, nextIndex)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n.IsDir() {
0000000000000000000000000000000000000000;;			eNode.Dir = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// copy the value for safety
0000000000000000000000000000000000000000;;			newValueCopy := newValue
0000000000000000000000000000000000000000;;			eNode.Value = &newValueCopy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update ttl
0000000000000000000000000000000000000000;;		n.UpdateTTL(expireOpts.ExpireTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !expireOpts.Refresh {
0000000000000000000000000000000000000000;;			s.WatcherHub.notify(e)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.SetRefresh()
0000000000000000000000000000000000000000;;			s.WatcherHub.add(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.CurrentIndex = nextIndex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) internalCreate(nodePath string, dir bool, value string, unique, replace bool,
0000000000000000000000000000000000000000;;		expireTime time.Time, action string) (*Event, *etcdErr.Error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currIndex, nextIndex := s.CurrentIndex, s.CurrentIndex+1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if unique { // append unique item under the node path
0000000000000000000000000000000000000000;;			nodePath += "/" + fmt.Sprintf("%020s", strconv.FormatUint(nextIndex, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodePath = path.Clean(path.Join("/", nodePath))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we do not allow the user to change "/"
0000000000000000000000000000000000000000;;		if s.readonlySet.Contains(nodePath) {
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeRootROnly, "/", currIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume expire times that are way in the past are
0000000000000000000000000000000000000000;;		// This can occur when the time is serialized to JS
0000000000000000000000000000000000000000;;		if expireTime.Before(minExpireTime) {
0000000000000000000000000000000000000000;;			expireTime = Permanent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirName, nodeName := path.Split(nodePath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// walk through the nodePath, create dirs and get the last directory node
0000000000000000000000000000000000000000;;		d, err := s.walk(dirName, s.checkDir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			s.Stats.Inc(SetFail)
0000000000000000000000000000000000000000;;			reportWriteFailure(action)
0000000000000000000000000000000000000000;;			err.Index = currIndex
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := newEvent(action, nodePath, nextIndex, nextIndex)
0000000000000000000000000000000000000000;;		eNode := e.Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, _ := d.GetChild(nodeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// force will try to replace an existing file
0000000000000000000000000000000000000000;;		if n != nil {
0000000000000000000000000000000000000000;;			if replace {
0000000000000000000000000000000000000000;;				if n.IsDir() {
0000000000000000000000000000000000000000;;					return nil, etcdErr.NewError(etcdErr.EcodeNotFile, nodePath, currIndex)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.PrevNode = n.Repr(false, false, s.clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				n.Remove(false, false, nil)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, etcdErr.NewError(etcdErr.EcodeNodeExist, nodePath, currIndex)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dir { // create file
0000000000000000000000000000000000000000;;			// copy the value for safety
0000000000000000000000000000000000000000;;			valueCopy := value
0000000000000000000000000000000000000000;;			eNode.Value = &valueCopy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n = newKV(s, nodePath, value, nextIndex, d, expireTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		} else { // create directory
0000000000000000000000000000000000000000;;			eNode.Dir = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n = newDir(s, nodePath, nextIndex, d, expireTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we are sure d is a directory and does not have the children with name n.Name
0000000000000000000000000000000000000000;;		d.Add(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// node with TTL
0000000000000000000000000000000000000000;;		if !n.IsPermanent() {
0000000000000000000000000000000000000000;;			s.ttlKeyHeap.push(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			eNode.Expiration, eNode.TTL = n.expirationAndTTL(s.clock)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.CurrentIndex = nextIndex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InternalGet gets the node of the given nodePath.
0000000000000000000000000000000000000000;;	func (s *store) internalGet(nodePath string) (*node, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		nodePath = path.Clean(path.Join("/", nodePath))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		walkFunc := func(parent *node, name string) (*node, *etcdErr.Error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !parent.IsDir() {
0000000000000000000000000000000000000000;;				err := etcdErr.NewError(etcdErr.EcodeNotDir, parent.Path, s.CurrentIndex)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			child, ok := parent.Children[name]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				return child, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeKeyNotFound, path.Join(parent.Path, name), s.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := s.walk(nodePath, walkFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteExpiredKeys will delete all expired keys
0000000000000000000000000000000000000000;;	func (s *store) DeleteExpiredKeys(cutoff time.Time) {
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			node := s.ttlKeyHeap.top()
0000000000000000000000000000000000000000;;			if node == nil || node.ExpireTime.After(cutoff) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.CurrentIndex++
0000000000000000000000000000000000000000;;			e := newEvent(Expire, node.Path, s.CurrentIndex, node.CreatedIndex)
0000000000000000000000000000000000000000;;			e.EtcdIndex = s.CurrentIndex
0000000000000000000000000000000000000000;;			e.PrevNode = node.Repr(false, false, s.clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			callback := func(path string) { // notify function
0000000000000000000000000000000000000000;;				// notify the watchers with deleted set true
0000000000000000000000000000000000000000;;				s.WatcherHub.notifyWatchers(e, path, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.ttlKeyHeap.pop()
0000000000000000000000000000000000000000;;			node.Remove(true, true, callback)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			reportExpiredKey()
0000000000000000000000000000000000000000;;			s.Stats.Inc(ExpireCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.WatcherHub.notify(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkDir will check whether the component is a directory under parent node.
0000000000000000000000000000000000000000;;	// If it is a directory, this function will return the pointer to that node.
0000000000000000000000000000000000000000;;	// If it does not exist, this function will create a new directory and return the pointer to that node.
0000000000000000000000000000000000000000;;	// If it is a file, this function will return error.
0000000000000000000000000000000000000000;;	func (s *store) checkDir(parent *node, dirName string) (*node, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		node, ok := parent.Children[dirName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if node.IsDir() {
0000000000000000000000000000000000000000;;				return node, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeNotDir, node.Path, s.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := newDir(s, path.Join(parent.Path, dirName), s.CurrentIndex+1, parent, Permanent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parent.Children[dirName] = n
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Save saves the static state of the store system.
0000000000000000000000000000000000000000;;	// It will not be able to save the state of watchers.
0000000000000000000000000000000000000000;;	// It will not save the parent field of the node. Or there will
0000000000000000000000000000000000000000;;	// be cyclic dependencies issue for the json package.
0000000000000000000000000000000000000000;;	func (s *store) Save() ([]byte, error) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(s.Clone())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) SaveNoCopy() ([]byte, error) {
0000000000000000000000000000000000000000;;		b, err := json.Marshal(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) Clone() Store {
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clonedStore := newStore()
0000000000000000000000000000000000000000;;		clonedStore.CurrentIndex = s.CurrentIndex
0000000000000000000000000000000000000000;;		clonedStore.Root = s.Root.Clone()
0000000000000000000000000000000000000000;;		clonedStore.WatcherHub = s.WatcherHub.clone()
0000000000000000000000000000000000000000;;		clonedStore.Stats = s.Stats.clone()
0000000000000000000000000000000000000000;;		clonedStore.CurrentVersion = s.CurrentVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.worldLock.Unlock()
0000000000000000000000000000000000000000;;		return clonedStore
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recovery recovers the store system from a static state
0000000000000000000000000000000000000000;;	// It needs to recover the parent field of the nodes.
0000000000000000000000000000000000000000;;	// It needs to delete the expired nodes since the saved time and also
0000000000000000000000000000000000000000;;	// needs to create monitoring go routines.
0000000000000000000000000000000000000000;;	func (s *store) Recovery(state []byte) error {
0000000000000000000000000000000000000000;;		s.worldLock.Lock()
0000000000000000000000000000000000000000;;		defer s.worldLock.Unlock()
0000000000000000000000000000000000000000;;		err := json.Unmarshal(state, s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.ttlKeyHeap = newTtlKeyHeap()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Root.recoverAndclean()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) JsonStats() []byte {
0000000000000000000000000000000000000000;;		s.Stats.Watchers = uint64(s.WatcherHub.count)
0000000000000000000000000000000000000000;;		return s.Stats.toJson()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *store) HasTTLKeys() bool {
0000000000000000000000000000000000000000;;		s.worldLock.RLock()
0000000000000000000000000000000000000000;;		defer s.worldLock.RUnlock()
0000000000000000000000000000000000000000;;		return s.ttlKeyHeap.Len() != 0
0000000000000000000000000000000000000000;;	}
