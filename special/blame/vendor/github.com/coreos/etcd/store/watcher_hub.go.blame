0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/store/watcher_hub.go[Godeps/_workspace/src/github.com/coreos/etcd/store/watcher_hub.go][vendor/github.com/coreos/etcd/store/watcher_hub.go];	
0000000000000000000000000000000000000000;;	package store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdErr "github.com/coreos/etcd/error"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A watcherHub contains all subscribed watchers
0000000000000000000000000000000000000000;;	// watchers is a map with watched path as key and watcher as value
0000000000000000000000000000000000000000;;	// EventHistory keeps the old events for watcherHub. It is used to help
0000000000000000000000000000000000000000;;	// watcher to get a continuous event history. Or a watcher might miss the
0000000000000000000000000000000000000000;;	// event happens between the end of the first watch command and the start
0000000000000000000000000000000000000000;;	// of the second command.
0000000000000000000000000000000000000000;;	type watcherHub struct {
0000000000000000000000000000000000000000;;		// count must be the first element to keep 64-bit alignment for atomic
0000000000000000000000000000000000000000;;		// access
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		count int64 // current number of watchers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mutex        sync.Mutex
0000000000000000000000000000000000000000;;		watchers     map[string]*list.List
0000000000000000000000000000000000000000;;		EventHistory *EventHistory
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newWatchHub creates a watcherHub. The capacity determines how many events we will
0000000000000000000000000000000000000000;;	// keep in the eventHistory.
0000000000000000000000000000000000000000;;	// Typically, we only need to keep a small size of history[smaller than 20K].
0000000000000000000000000000000000000000;;	// Ideally, it should smaller than 20K/s[max throughput] * 2 * 50ms[RTT] = 2000
0000000000000000000000000000000000000000;;	func newWatchHub(capacity int) *watcherHub {
0000000000000000000000000000000000000000;;		return &watcherHub{
0000000000000000000000000000000000000000;;			watchers:     make(map[string]*list.List),
0000000000000000000000000000000000000000;;			EventHistory: newEventHistory(capacity),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch function returns a Watcher.
0000000000000000000000000000000000000000;;	// If recursive is true, the first change after index under key will be sent to the event channel of the watcher.
0000000000000000000000000000000000000000;;	// If recursive is false, the first change after index at key will be sent to the event channel of the watcher.
0000000000000000000000000000000000000000;;	// If index is zero, watch will start from the current index + 1.
0000000000000000000000000000000000000000;;	func (wh *watcherHub) watch(key string, recursive, stream bool, index, storeIndex uint64) (Watcher, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		reportWatchRequest()
0000000000000000000000000000000000000000;;		event, err := wh.EventHistory.scan(key, recursive, index)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err.Index = storeIndex
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := &watcher{
0000000000000000000000000000000000000000;;			eventChan:  make(chan *Event, 100), // use a buffered channel
0000000000000000000000000000000000000000;;			recursive:  recursive,
0000000000000000000000000000000000000000;;			stream:     stream,
0000000000000000000000000000000000000000;;			sinceIndex: index,
0000000000000000000000000000000000000000;;			startIndex: storeIndex,
0000000000000000000000000000000000000000;;			hub:        wh,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wh.mutex.Lock()
0000000000000000000000000000000000000000;;		defer wh.mutex.Unlock()
0000000000000000000000000000000000000000;;		// If the event exists in the known history, append the EtcdIndex and return immediately
0000000000000000000000000000000000000000;;		if event != nil {
0000000000000000000000000000000000000000;;			ne := event.Clone()
0000000000000000000000000000000000000000;;			ne.EtcdIndex = storeIndex
0000000000000000000000000000000000000000;;			w.eventChan <- ne
0000000000000000000000000000000000000000;;			return w, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, ok := wh.watchers[key]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var elem *list.Element
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok { // add the new watcher to the back of the list
0000000000000000000000000000000000000000;;			elem = l.PushBack(w)
0000000000000000000000000000000000000000;;		} else { // create a new list and add the new watcher
0000000000000000000000000000000000000000;;			l = list.New()
0000000000000000000000000000000000000000;;			elem = l.PushBack(w)
0000000000000000000000000000000000000000;;			wh.watchers[key] = l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.remove = func() {
0000000000000000000000000000000000000000;;			if w.removed { // avoid removing it twice
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.removed = true
0000000000000000000000000000000000000000;;			l.Remove(elem)
0000000000000000000000000000000000000000;;			atomic.AddInt64(&wh.count, -1)
0000000000000000000000000000000000000000;;			reportWatcherRemoved()
0000000000000000000000000000000000000000;;			if l.Len() == 0 {
0000000000000000000000000000000000000000;;				delete(wh.watchers, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		atomic.AddInt64(&wh.count, 1)
0000000000000000000000000000000000000000;;		reportWatcherAdded()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return w, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wh *watcherHub) add(e *Event) {
0000000000000000000000000000000000000000;;		e = wh.EventHistory.addEvent(e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notify function accepts an event and notify to the watchers.
0000000000000000000000000000000000000000;;	func (wh *watcherHub) notify(e *Event) {
0000000000000000000000000000000000000000;;		e = wh.EventHistory.addEvent(e) // add event into the eventHistory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		segments := strings.Split(e.Node.Key, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currPath := "/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// walk through all the segments of the path and notify the watchers
0000000000000000000000000000000000000000;;		// if the path is "/foo/bar", it will notify watchers with path "/",
0000000000000000000000000000000000000000;;		// "/foo" and "/foo/bar"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, segment := range segments {
0000000000000000000000000000000000000000;;			currPath = path.Join(currPath, segment)
0000000000000000000000000000000000000000;;			// notify the watchers who interests in the changes of current path
0000000000000000000000000000000000000000;;			wh.notifyWatchers(e, currPath, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (wh *watcherHub) notifyWatchers(e *Event, nodePath string, deleted bool) {
0000000000000000000000000000000000000000;;		wh.mutex.Lock()
0000000000000000000000000000000000000000;;		defer wh.mutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, ok := wh.watchers[nodePath]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			curr := l.Front()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for curr != nil {
0000000000000000000000000000000000000000;;				next := curr.Next() // save reference to the next one in the list
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				w, _ := curr.Value.(*watcher)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				originalPath := (e.Node.Key == nodePath)
0000000000000000000000000000000000000000;;				if (originalPath || !isHidden(nodePath, e.Node.Key)) && w.notify(e, originalPath, deleted) {
0000000000000000000000000000000000000000;;					if !w.stream { // do not remove the stream watcher
0000000000000000000000000000000000000000;;						// if we successfully notify a watcher
0000000000000000000000000000000000000000;;						// we need to remove the watcher from the list
0000000000000000000000000000000000000000;;						// and decrease the counter
0000000000000000000000000000000000000000;;						w.removed = true
0000000000000000000000000000000000000000;;						l.Remove(curr)
0000000000000000000000000000000000000000;;						atomic.AddInt64(&wh.count, -1)
0000000000000000000000000000000000000000;;						reportWatcherRemoved()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				curr = next // update current to the next element in the list
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.Len() == 0 {
0000000000000000000000000000000000000000;;				// if we have notified all watcher in the list
0000000000000000000000000000000000000000;;				// we can delete the list
0000000000000000000000000000000000000000;;				delete(wh.watchers, nodePath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clone function clones the watcherHub and return the cloned one.
0000000000000000000000000000000000000000;;	// only clone the static content. do not clone the current watchers.
0000000000000000000000000000000000000000;;	func (wh *watcherHub) clone() *watcherHub {
0000000000000000000000000000000000000000;;		clonedHistory := wh.EventHistory.clone()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &watcherHub{
0000000000000000000000000000000000000000;;			EventHistory: clonedHistory,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isHidden checks to see if key path is considered hidden to watch path i.e. the
0000000000000000000000000000000000000000;;	// last element is hidden or it's within a hidden directory
0000000000000000000000000000000000000000;;	func isHidden(watchPath, keyPath string) bool {
0000000000000000000000000000000000000000;;		// When deleting a directory, watchPath might be deeper than the actual keyPath
0000000000000000000000000000000000000000;;		// For example, when deleting /foo we also need to notify watchers on /foo/bar.
0000000000000000000000000000000000000000;;		if len(watchPath) > len(keyPath) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if watch path is just a "/", after path will start without "/"
0000000000000000000000000000000000000000;;		// add a "/" to deal with the special case when watchPath is "/"
0000000000000000000000000000000000000000;;		afterPath := path.Clean("/" + keyPath[len(watchPath):])
0000000000000000000000000000000000000000;;		return strings.Contains(afterPath, "/_")
0000000000000000000000000000000000000000;;	}
