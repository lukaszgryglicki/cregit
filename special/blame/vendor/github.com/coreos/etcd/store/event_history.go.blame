0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/store/event_history.go[Godeps/_workspace/src/github.com/coreos/etcd/store/event_history.go][vendor/github.com/coreos/etcd/store/event_history.go];	
0000000000000000000000000000000000000000;;	package store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdErr "github.com/coreos/etcd/error"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EventHistory struct {
0000000000000000000000000000000000000000;;		Queue      eventQueue
0000000000000000000000000000000000000000;;		StartIndex uint64
0000000000000000000000000000000000000000;;		LastIndex  uint64
0000000000000000000000000000000000000000;;		rwl        sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEventHistory(capacity int) *EventHistory {
0000000000000000000000000000000000000000;;		return &EventHistory{
0000000000000000000000000000000000000000;;			Queue: eventQueue{
0000000000000000000000000000000000000000;;				Capacity: capacity,
0000000000000000000000000000000000000000;;				Events:   make([]*Event, capacity),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addEvent function adds event into the eventHistory
0000000000000000000000000000000000000000;;	func (eh *EventHistory) addEvent(e *Event) *Event {
0000000000000000000000000000000000000000;;		eh.rwl.Lock()
0000000000000000000000000000000000000000;;		defer eh.rwl.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eh.Queue.insert(e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eh.LastIndex = e.Index()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eh.StartIndex = eh.Queue.Events[eh.Queue.Front].Index()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scan enumerates events from the index history and stops at the first point
0000000000000000000000000000000000000000;;	// where the key matches.
0000000000000000000000000000000000000000;;	func (eh *EventHistory) scan(key string, recursive bool, index uint64) (*Event, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		eh.rwl.RLock()
0000000000000000000000000000000000000000;;		defer eh.rwl.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// index should be after the event history's StartIndex
0000000000000000000000000000000000000000;;		if index < eh.StartIndex {
0000000000000000000000000000000000000000;;			return nil,
0000000000000000000000000000000000000000;;				etcdErr.NewError(etcdErr.EcodeEventIndexCleared,
0000000000000000000000000000000000000000;;					fmt.Sprintf("the requested history has been cleared [%v/%v]",
0000000000000000000000000000000000000000;;						eh.StartIndex, index), 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the index should come before the size of the queue minus the duplicate count
0000000000000000000000000000000000000000;;		if index > eh.LastIndex { // future index
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		offset := index - eh.StartIndex
0000000000000000000000000000000000000000;;		i := (eh.Queue.Front + int(offset)) % eh.Queue.Capacity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			e := eh.Queue.Events[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !e.Refresh {
0000000000000000000000000000000000000000;;				ok := (e.Node.Key == key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if recursive {
0000000000000000000000000000000000000000;;					// add tailing slash
0000000000000000000000000000000000000000;;					nkey := path.Clean(key)
0000000000000000000000000000000000000000;;					if nkey[len(nkey)-1] != '/' {
0000000000000000000000000000000000000000;;						nkey = nkey + "/"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ok = ok || strings.HasPrefix(e.Node.Key, nkey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if (e.Action == Delete || e.Action == Expire) && e.PrevNode != nil && e.PrevNode.Dir {
0000000000000000000000000000000000000000;;					ok = ok || strings.HasPrefix(key, e.PrevNode.Key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					return e, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i = (i + 1) % eh.Queue.Capacity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i == eh.Queue.Back {
0000000000000000000000000000000000000000;;				return nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clone will be protected by a stop-world lock
0000000000000000000000000000000000000000;;	// do not need to obtain internal lock
0000000000000000000000000000000000000000;;	func (eh *EventHistory) clone() *EventHistory {
0000000000000000000000000000000000000000;;		clonedQueue := eventQueue{
0000000000000000000000000000000000000000;;			Capacity: eh.Queue.Capacity,
0000000000000000000000000000000000000000;;			Events:   make([]*Event, eh.Queue.Capacity),
0000000000000000000000000000000000000000;;			Size:     eh.Queue.Size,
0000000000000000000000000000000000000000;;			Front:    eh.Queue.Front,
0000000000000000000000000000000000000000;;			Back:     eh.Queue.Back,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(clonedQueue.Events, eh.Queue.Events)
0000000000000000000000000000000000000000;;		return &EventHistory{
0000000000000000000000000000000000000000;;			StartIndex: eh.StartIndex,
0000000000000000000000000000000000000000;;			Queue:      clonedQueue,
0000000000000000000000000000000000000000;;			LastIndex:  eh.LastIndex,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
