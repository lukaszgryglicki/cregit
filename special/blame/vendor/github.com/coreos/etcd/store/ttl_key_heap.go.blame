0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/store/ttl_key_heap.go[Godeps/_workspace/src/github.com/coreos/etcd/store/ttl_key_heap.go][vendor/github.com/coreos/etcd/store/ttl_key_heap.go];	
0000000000000000000000000000000000000000;;	package store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/heap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An TTLKeyHeap is a min-heap of TTLKeys order by expiration time
0000000000000000000000000000000000000000;;	type ttlKeyHeap struct {
0000000000000000000000000000000000000000;;		array  []*node
0000000000000000000000000000000000000000;;		keyMap map[*node]int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTtlKeyHeap() *ttlKeyHeap {
0000000000000000000000000000000000000000;;		h := &ttlKeyHeap{keyMap: make(map[*node]int)}
0000000000000000000000000000000000000000;;		heap.Init(h)
0000000000000000000000000000000000000000;;		return h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h ttlKeyHeap) Len() int {
0000000000000000000000000000000000000000;;		return len(h.array)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h ttlKeyHeap) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return h.array[i].ExpireTime.Before(h.array[j].ExpireTime)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h ttlKeyHeap) Swap(i, j int) {
0000000000000000000000000000000000000000;;		// swap node
0000000000000000000000000000000000000000;;		h.array[i], h.array[j] = h.array[j], h.array[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// update map
0000000000000000000000000000000000000000;;		h.keyMap[h.array[i]] = i
0000000000000000000000000000000000000000;;		h.keyMap[h.array[j]] = j
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ttlKeyHeap) Push(x interface{}) {
0000000000000000000000000000000000000000;;		n, _ := x.(*node)
0000000000000000000000000000000000000000;;		h.keyMap[n] = len(h.array)
0000000000000000000000000000000000000000;;		h.array = append(h.array, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ttlKeyHeap) Pop() interface{} {
0000000000000000000000000000000000000000;;		old := h.array
0000000000000000000000000000000000000000;;		n := len(old)
0000000000000000000000000000000000000000;;		x := old[n-1]
0000000000000000000000000000000000000000;;		// Set slice element to nil, so GC can recycle the node.
0000000000000000000000000000000000000000;;		// This is due to golang GC doesn't support partial recycling:
0000000000000000000000000000000000000000;;		// https://github.com/golang/go/issues/9618
0000000000000000000000000000000000000000;;		old[n-1] = nil
0000000000000000000000000000000000000000;;		h.array = old[0 : n-1]
0000000000000000000000000000000000000000;;		delete(h.keyMap, x)
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ttlKeyHeap) top() *node {
0000000000000000000000000000000000000000;;		if h.Len() != 0 {
0000000000000000000000000000000000000000;;			return h.array[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ttlKeyHeap) pop() *node {
0000000000000000000000000000000000000000;;		x := heap.Pop(h)
0000000000000000000000000000000000000000;;		n, _ := x.(*node)
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ttlKeyHeap) push(x interface{}) {
0000000000000000000000000000000000000000;;		heap.Push(h, x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ttlKeyHeap) update(n *node) {
0000000000000000000000000000000000000000;;		index, ok := h.keyMap[n]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			heap.Remove(h, index)
0000000000000000000000000000000000000000;;			heap.Push(h, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *ttlKeyHeap) remove(n *node) {
0000000000000000000000000000000000000000;;		index, ok := h.keyMap[n]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			heap.Remove(h, index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
