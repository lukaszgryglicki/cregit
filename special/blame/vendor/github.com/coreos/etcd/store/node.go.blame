0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/store/node.go[Godeps/_workspace/src/github.com/coreos/etcd/store/node.go][vendor/github.com/coreos/etcd/store/node.go];	
0000000000000000000000000000000000000000;;	package store
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		etcdErr "github.com/coreos/etcd/error"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// explanations of Compare function result
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CompareMatch = iota
0000000000000000000000000000000000000000;;		CompareIndexNotMatch
0000000000000000000000000000000000000000;;		CompareValueNotMatch
0000000000000000000000000000000000000000;;		CompareNotMatch
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var Permanent time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// node is the basic element in the store system.
0000000000000000000000000000000000000000;;	// A key-value pair will have a string value
0000000000000000000000000000000000000000;;	// A directory will have a children map
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CreatedIndex  uint64
0000000000000000000000000000000000000000;;		ModifiedIndex uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Parent *node `json:"-"` // should not encode this field! avoid circular dependency.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ExpireTime time.Time
0000000000000000000000000000000000000000;;		Value      string           // for key-value pair
0000000000000000000000000000000000000000;;		Children   map[string]*node // for directory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A reference to the store this node is attached to.
0000000000000000000000000000000000000000;;		store *store
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newKV creates a Key-Value pair
0000000000000000000000000000000000000000;;	func newKV(store *store, nodePath string, value string, createdIndex uint64, parent *node, expireTime time.Time) *node {
0000000000000000000000000000000000000000;;		return &node{
0000000000000000000000000000000000000000;;			Path:          nodePath,
0000000000000000000000000000000000000000;;			CreatedIndex:  createdIndex,
0000000000000000000000000000000000000000;;			ModifiedIndex: createdIndex,
0000000000000000000000000000000000000000;;			Parent:        parent,
0000000000000000000000000000000000000000;;			store:         store,
0000000000000000000000000000000000000000;;			ExpireTime:    expireTime,
0000000000000000000000000000000000000000;;			Value:         value,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newDir creates a directory
0000000000000000000000000000000000000000;;	func newDir(store *store, nodePath string, createdIndex uint64, parent *node, expireTime time.Time) *node {
0000000000000000000000000000000000000000;;		return &node{
0000000000000000000000000000000000000000;;			Path:          nodePath,
0000000000000000000000000000000000000000;;			CreatedIndex:  createdIndex,
0000000000000000000000000000000000000000;;			ModifiedIndex: createdIndex,
0000000000000000000000000000000000000000;;			Parent:        parent,
0000000000000000000000000000000000000000;;			ExpireTime:    expireTime,
0000000000000000000000000000000000000000;;			Children:      make(map[string]*node),
0000000000000000000000000000000000000000;;			store:         store,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHidden function checks if the node is a hidden node. A hidden node
0000000000000000000000000000000000000000;;	// will begin with '_'
0000000000000000000000000000000000000000;;	// A hidden node will not be shown via get command under a directory
0000000000000000000000000000000000000000;;	// For example if we have /foo/_hidden and /foo/notHidden, get "/foo"
0000000000000000000000000000000000000000;;	// will only return /foo/notHidden
0000000000000000000000000000000000000000;;	func (n *node) IsHidden() bool {
0000000000000000000000000000000000000000;;		_, name := path.Split(n.Path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name[0] == '_'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPermanent function checks if the node is a permanent one.
0000000000000000000000000000000000000000;;	func (n *node) IsPermanent() bool {
0000000000000000000000000000000000000000;;		// we use a uninitialized time.Time to indicate the node is a
0000000000000000000000000000000000000000;;		// permanent one.
0000000000000000000000000000000000000000;;		// the uninitialized time.Time should equal zero.
0000000000000000000000000000000000000000;;		return n.ExpireTime.IsZero()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDir function checks whether the node is a directory.
0000000000000000000000000000000000000000;;	// If the node is a directory, the function will return true.
0000000000000000000000000000000000000000;;	// Otherwise the function will return false.
0000000000000000000000000000000000000000;;	func (n *node) IsDir() bool {
0000000000000000000000000000000000000000;;		return n.Children != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read function gets the value of the node.
0000000000000000000000000000000000000000;;	// If the receiver node is not a key-value pair, a "Not A File" error will be returned.
0000000000000000000000000000000000000000;;	func (n *node) Read() (string, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		if n.IsDir() {
0000000000000000000000000000000000000000;;			return "", etcdErr.NewError(etcdErr.EcodeNotFile, "", n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n.Value, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write function set the value of the node to the given value.
0000000000000000000000000000000000000000;;	// If the receiver node is a directory, a "Not A File" error will be returned.
0000000000000000000000000000000000000000;;	func (n *node) Write(value string, index uint64) *etcdErr.Error {
0000000000000000000000000000000000000000;;		if n.IsDir() {
0000000000000000000000000000000000000000;;			return etcdErr.NewError(etcdErr.EcodeNotFile, "", n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.Value = value
0000000000000000000000000000000000000000;;		n.ModifiedIndex = index
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) expirationAndTTL(clock clockwork.Clock) (*time.Time, int64) {
0000000000000000000000000000000000000000;;		if !n.IsPermanent() {
0000000000000000000000000000000000000000;;			/* compute ttl as:
0000000000000000000000000000000000000000;;			   ceiling( (expireTime - timeNow) / nanosecondsPerSecond )
0000000000000000000000000000000000000000;;			   which ranges from 1..n
0000000000000000000000000000000000000000;;			   rather than as:
0000000000000000000000000000000000000000;;			   ( (expireTime - timeNow) / nanosecondsPerSecond ) + 1
0000000000000000000000000000000000000000;;			   which ranges 1..n+1
0000000000000000000000000000000000000000;;			*/
0000000000000000000000000000000000000000;;			ttlN := n.ExpireTime.Sub(clock.Now())
0000000000000000000000000000000000000000;;			ttl := ttlN / time.Second
0000000000000000000000000000000000000000;;			if (ttlN % time.Second) > 0 {
0000000000000000000000000000000000000000;;				ttl++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t := n.ExpireTime.UTC()
0000000000000000000000000000000000000000;;			return &t, int64(ttl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List function return a slice of nodes under the receiver node.
0000000000000000000000000000000000000000;;	// If the receiver node is not a directory, a "Not A Directory" error will be returned.
0000000000000000000000000000000000000000;;	func (n *node) List() ([]*node, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		if !n.IsDir() {
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeNotDir, "", n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nodes := make([]*node, len(n.Children))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for _, node := range n.Children {
0000000000000000000000000000000000000000;;			nodes[i] = node
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetChild function returns the child node under the directory node.
0000000000000000000000000000000000000000;;	// On success, it returns the file node
0000000000000000000000000000000000000000;;	func (n *node) GetChild(name string) (*node, *etcdErr.Error) {
0000000000000000000000000000000000000000;;		if !n.IsDir() {
0000000000000000000000000000000000000000;;			return nil, etcdErr.NewError(etcdErr.EcodeNotDir, n.Path, n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		child, ok := n.Children[name]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return child, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add function adds a node to the receiver node.
0000000000000000000000000000000000000000;;	// If the receiver is not a directory, a "Not A Directory" error will be returned.
0000000000000000000000000000000000000000;;	// If there is an existing node with the same name under the directory, a "Already Exist"
0000000000000000000000000000000000000000;;	// error will be returned
0000000000000000000000000000000000000000;;	func (n *node) Add(child *node) *etcdErr.Error {
0000000000000000000000000000000000000000;;		if !n.IsDir() {
0000000000000000000000000000000000000000;;			return etcdErr.NewError(etcdErr.EcodeNotDir, "", n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, name := path.Split(child.Path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := n.Children[name]; ok {
0000000000000000000000000000000000000000;;			return etcdErr.NewError(etcdErr.EcodeNodeExist, "", n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.Children[name] = child
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove function remove the node.
0000000000000000000000000000000000000000;;	func (n *node) Remove(dir, recursive bool, callback func(path string)) *etcdErr.Error {
0000000000000000000000000000000000000000;;		if !n.IsDir() { // key-value pair
0000000000000000000000000000000000000000;;			_, name := path.Split(n.Path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// find its parent and remove the node from the map
0000000000000000000000000000000000000000;;			if n.Parent != nil && n.Parent.Children[name] == n {
0000000000000000000000000000000000000000;;				delete(n.Parent.Children, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if callback != nil {
0000000000000000000000000000000000000000;;				callback(n.Path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !n.IsPermanent() {
0000000000000000000000000000000000000000;;				n.store.ttlKeyHeap.remove(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dir {
0000000000000000000000000000000000000000;;			// cannot delete a directory without dir set to true
0000000000000000000000000000000000000000;;			return etcdErr.NewError(etcdErr.EcodeNotFile, n.Path, n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(n.Children) != 0 && !recursive {
0000000000000000000000000000000000000000;;			// cannot delete a directory if it is not empty and the operation
0000000000000000000000000000000000000000;;			// is not recursive
0000000000000000000000000000000000000000;;			return etcdErr.NewError(etcdErr.EcodeDirNotEmpty, n.Path, n.store.CurrentIndex)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, child := range n.Children { // delete all children
0000000000000000000000000000000000000000;;			child.Remove(true, true, callback)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// delete self
0000000000000000000000000000000000000000;;		_, name := path.Split(n.Path)
0000000000000000000000000000000000000000;;		if n.Parent != nil && n.Parent.Children[name] == n {
0000000000000000000000000000000000000000;;			delete(n.Parent.Children, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if callback != nil {
0000000000000000000000000000000000000000;;				callback(n.Path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !n.IsPermanent() {
0000000000000000000000000000000000000000;;				n.store.ttlKeyHeap.remove(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) Repr(recursive, sorted bool, clock clockwork.Clock) *NodeExtern {
0000000000000000000000000000000000000000;;		if n.IsDir() {
0000000000000000000000000000000000000000;;			node := &NodeExtern{
0000000000000000000000000000000000000000;;				Key:           n.Path,
0000000000000000000000000000000000000000;;				Dir:           true,
0000000000000000000000000000000000000000;;				ModifiedIndex: n.ModifiedIndex,
0000000000000000000000000000000000000000;;				CreatedIndex:  n.CreatedIndex,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			node.Expiration, node.TTL = n.expirationAndTTL(clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !recursive {
0000000000000000000000000000000000000000;;				return node
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			children, _ := n.List()
0000000000000000000000000000000000000000;;			node.Nodes = make(NodeExterns, len(children))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we do not use the index in the children slice directly
0000000000000000000000000000000000000000;;			// we need to skip the hidden one
0000000000000000000000000000000000000000;;			i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, child := range children {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if child.IsHidden() { // get will not list hidden node
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				node.Nodes[i] = child.Repr(recursive, sorted, clock)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// eliminate hidden nodes
0000000000000000000000000000000000000000;;			node.Nodes = node.Nodes[:i]
0000000000000000000000000000000000000000;;			if sorted {
0000000000000000000000000000000000000000;;				sort.Sort(node.Nodes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// since n.Value could be changed later, so we need to copy the value out
0000000000000000000000000000000000000000;;		value := n.Value
0000000000000000000000000000000000000000;;		node := &NodeExtern{
0000000000000000000000000000000000000000;;			Key:           n.Path,
0000000000000000000000000000000000000000;;			Value:         &value,
0000000000000000000000000000000000000000;;			ModifiedIndex: n.ModifiedIndex,
0000000000000000000000000000000000000000;;			CreatedIndex:  n.CreatedIndex,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		node.Expiration, node.TTL = n.expirationAndTTL(clock)
0000000000000000000000000000000000000000;;		return node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *node) UpdateTTL(expireTime time.Time) {
0000000000000000000000000000000000000000;;		if !n.IsPermanent() {
0000000000000000000000000000000000000000;;			if expireTime.IsZero() {
0000000000000000000000000000000000000000;;				// from ttl to permanent
0000000000000000000000000000000000000000;;				n.ExpireTime = expireTime
0000000000000000000000000000000000000000;;				// remove from ttl heap
0000000000000000000000000000000000000000;;				n.store.ttlKeyHeap.remove(n)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// update ttl
0000000000000000000000000000000000000000;;			n.ExpireTime = expireTime
0000000000000000000000000000000000000000;;			// update ttl heap
0000000000000000000000000000000000000000;;			n.store.ttlKeyHeap.update(n)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expireTime.IsZero() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// from permanent to ttl
0000000000000000000000000000000000000000;;		n.ExpireTime = expireTime
0000000000000000000000000000000000000000;;		// push into ttl heap
0000000000000000000000000000000000000000;;		n.store.ttlKeyHeap.push(n)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare function compares node index and value with provided ones.
0000000000000000000000000000000000000000;;	// second result value explains result and equals to one of Compare.. constants
0000000000000000000000000000000000000000;;	func (n *node) Compare(prevValue string, prevIndex uint64) (ok bool, which int) {
0000000000000000000000000000000000000000;;		indexMatch := (prevIndex == 0 || n.ModifiedIndex == prevIndex)
0000000000000000000000000000000000000000;;		valueMatch := (prevValue == "" || n.Value == prevValue)
0000000000000000000000000000000000000000;;		ok = valueMatch && indexMatch
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case valueMatch && indexMatch:
0000000000000000000000000000000000000000;;			which = CompareMatch
0000000000000000000000000000000000000000;;		case indexMatch && !valueMatch:
0000000000000000000000000000000000000000;;			which = CompareValueNotMatch
0000000000000000000000000000000000000000;;		case valueMatch && !indexMatch:
0000000000000000000000000000000000000000;;			which = CompareIndexNotMatch
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			which = CompareNotMatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clone function clone the node recursively and return the new node.
0000000000000000000000000000000000000000;;	// If the node is a directory, it will clone all the content under this directory.
0000000000000000000000000000000000000000;;	// If the node is a key-value pair, it will clone the pair.
0000000000000000000000000000000000000000;;	func (n *node) Clone() *node {
0000000000000000000000000000000000000000;;		if !n.IsDir() {
0000000000000000000000000000000000000000;;			newkv := newKV(n.store, n.Path, n.Value, n.CreatedIndex, n.Parent, n.ExpireTime)
0000000000000000000000000000000000000000;;			newkv.ModifiedIndex = n.ModifiedIndex
0000000000000000000000000000000000000000;;			return newkv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clone := newDir(n.store, n.Path, n.CreatedIndex, n.Parent, n.ExpireTime)
0000000000000000000000000000000000000000;;		clone.ModifiedIndex = n.ModifiedIndex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, child := range n.Children {
0000000000000000000000000000000000000000;;			clone.Children[key] = child.Clone()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return clone
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recoverAndclean function help to do recovery.
0000000000000000000000000000000000000000;;	// Two things need to be done: 1. recovery structure; 2. delete expired nodes
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the node is a directory, it will help recover children's parent pointer and recursively
0000000000000000000000000000000000000000;;	// call this function on its children.
0000000000000000000000000000000000000000;;	// We check the expire last since we need to recover the whole structure first and add all the
0000000000000000000000000000000000000000;;	// notifications into the event history.
0000000000000000000000000000000000000000;;	func (n *node) recoverAndclean() {
0000000000000000000000000000000000000000;;		if n.IsDir() {
0000000000000000000000000000000000000000;;			for _, child := range n.Children {
0000000000000000000000000000000000000000;;				child.Parent = n
0000000000000000000000000000000000000000;;				child.store = n.store
0000000000000000000000000000000000000000;;				child.recoverAndclean()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !n.ExpireTime.IsZero() {
0000000000000000000000000000000000000000;;			n.store.ttlKeyHeap.push(n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
