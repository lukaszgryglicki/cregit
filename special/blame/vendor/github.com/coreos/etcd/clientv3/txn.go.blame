0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
9b11e90c65f84c704d29a1c6a5867d26fdba23c5;Godeps/_workspace/src/github.com/coreos/etcd/clientv3/txn.go[Godeps/_workspace/src/github.com/coreos/etcd/clientv3/txn.go][vendor/github.com/coreos/etcd/clientv3/txn.go];	
0000000000000000000000000000000000000000;;	package clientv3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Txn is the interface that wraps mini-transactions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	 Tx.If(
0000000000000000000000000000000000000000;;	//	  Compare(Value(k1), ">", v1),
0000000000000000000000000000000000000000;;	//	  Compare(Version(k1), "=", 2)
0000000000000000000000000000000000000000;;	//	 ).Then(
0000000000000000000000000000000000000000;;	//	  OpPut(k2,v2), OpPut(k3,v3)
0000000000000000000000000000000000000000;;	//	 ).Else(
0000000000000000000000000000000000000000;;	//	  OpPut(k4,v4), OpPut(k5,v5)
0000000000000000000000000000000000000000;;	//	 ).Commit()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Txn interface {
0000000000000000000000000000000000000000;;		// If takes a list of comparison. If all comparisons passed in succeed,
0000000000000000000000000000000000000000;;		// the operations passed into Then() will be executed. Or the operations
0000000000000000000000000000000000000000;;		// passed into Else() will be executed.
0000000000000000000000000000000000000000;;		If(cs ...Cmp) Txn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Then takes a list of operations. The Ops list will be executed, if the
0000000000000000000000000000000000000000;;		// comparisons passed in If() succeed.
0000000000000000000000000000000000000000;;		Then(ops ...Op) Txn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Else takes a list of operations. The Ops list will be executed, if the
0000000000000000000000000000000000000000;;		// comparisons passed in If() fail.
0000000000000000000000000000000000000000;;		Else(ops ...Op) Txn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Commit tries to commit the transaction.
0000000000000000000000000000000000000000;;		Commit() (*TxnResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: add a Do for shortcut the txn without any condition?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type txn struct {
0000000000000000000000000000000000000000;;		kv  *kv
0000000000000000000000000000000000000000;;		ctx context.Context
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu    sync.Mutex
0000000000000000000000000000000000000000;;		cif   bool
0000000000000000000000000000000000000000;;		cthen bool
0000000000000000000000000000000000000000;;		celse bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isWrite bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cmps []*pb.Compare
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sus []*pb.RequestOp
0000000000000000000000000000000000000000;;		fas []*pb.RequestOp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (txn *txn) If(cs ...Cmp) Txn {
0000000000000000000000000000000000000000;;		txn.mu.Lock()
0000000000000000000000000000000000000000;;		defer txn.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if txn.cif {
0000000000000000000000000000000000000000;;			panic("cannot call If twice!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if txn.cthen {
0000000000000000000000000000000000000000;;			panic("cannot call If after Then!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if txn.celse {
0000000000000000000000000000000000000000;;			panic("cannot call If after Else!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		txn.cif = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range cs {
0000000000000000000000000000000000000000;;			txn.cmps = append(txn.cmps, (*pb.Compare)(&cs[i]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return txn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (txn *txn) Then(ops ...Op) Txn {
0000000000000000000000000000000000000000;;		txn.mu.Lock()
0000000000000000000000000000000000000000;;		defer txn.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if txn.cthen {
0000000000000000000000000000000000000000;;			panic("cannot call Then twice!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if txn.celse {
0000000000000000000000000000000000000000;;			panic("cannot call Then after Else!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		txn.cthen = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, op := range ops {
0000000000000000000000000000000000000000;;			txn.isWrite = txn.isWrite || op.isWrite()
0000000000000000000000000000000000000000;;			txn.sus = append(txn.sus, op.toRequestOp())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return txn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (txn *txn) Else(ops ...Op) Txn {
0000000000000000000000000000000000000000;;		txn.mu.Lock()
0000000000000000000000000000000000000000;;		defer txn.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if txn.celse {
0000000000000000000000000000000000000000;;			panic("cannot call Else twice!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		txn.celse = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, op := range ops {
0000000000000000000000000000000000000000;;			txn.isWrite = txn.isWrite || op.isWrite()
0000000000000000000000000000000000000000;;			txn.fas = append(txn.fas, op.toRequestOp())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return txn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (txn *txn) Commit() (*TxnResponse, error) {
0000000000000000000000000000000000000000;;		txn.mu.Lock()
0000000000000000000000000000000000000000;;		defer txn.mu.Unlock()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resp, err := txn.commit()
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHaltErr(txn.ctx, err) {
0000000000000000000000000000000000000000;;				return nil, toErr(txn.ctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if txn.isWrite {
0000000000000000000000000000000000000000;;				return nil, toErr(txn.ctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (txn *txn) commit() (*TxnResponse, error) {
0000000000000000000000000000000000000000;;		r := &pb.TxnRequest{Compare: txn.cmps, Success: txn.sus, Failure: txn.fas}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var opts []grpc.CallOption
0000000000000000000000000000000000000000;;		if !txn.isWrite {
0000000000000000000000000000000000000000;;			opts = []grpc.CallOption{grpc.FailFast(false)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, err := txn.kv.remote.Txn(txn.ctx, r, opts...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*TxnResponse)(resp), nil
0000000000000000000000000000000000000000;;	}
