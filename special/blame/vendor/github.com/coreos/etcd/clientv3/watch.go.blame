0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
9b11e90c65f84c704d29a1c6a5867d26fdba23c5;Godeps/_workspace/src/github.com/coreos/etcd/clientv3/watch.go[Godeps/_workspace/src/github.com/coreos/etcd/clientv3/watch.go][vendor/github.com/coreos/etcd/clientv3/watch.go];	
0000000000000000000000000000000000000000;;	package clientv3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v3rpc "github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		mvccpb "github.com/coreos/etcd/mvcc/mvccpb"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EventTypeDelete = mvccpb.DELETE
0000000000000000000000000000000000000000;;		EventTypePut    = mvccpb.PUT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closeSendErrTimeout = 250 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Event mvccpb.Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WatchChan <-chan WatchResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Watcher interface {
0000000000000000000000000000000000000000;;		// Watch watches on a key or prefix. The watched events will be returned
0000000000000000000000000000000000000000;;		// through the returned channel.
0000000000000000000000000000000000000000;;		// If the watch is slow or the required rev is compacted, the watch request
0000000000000000000000000000000000000000;;		// might be canceled from the server-side and the chan will be closed.
0000000000000000000000000000000000000000;;		// 'opts' can be: 'WithRev' and/or 'WithPrefix'.
0000000000000000000000000000000000000000;;		Watch(ctx context.Context, key string, opts ...OpOption) WatchChan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close closes the watcher and cancels all watch requests.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WatchResponse struct {
0000000000000000000000000000000000000000;;		Header pb.ResponseHeader
0000000000000000000000000000000000000000;;		Events []*Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CompactRevision is the minimum revision the watcher may receive.
0000000000000000000000000000000000000000;;		CompactRevision int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Canceled is used to indicate watch failure.
0000000000000000000000000000000000000000;;		// If the watch failed and the stream was about to close, before the channel is closed,
0000000000000000000000000000000000000000;;		// the channel sends a final response that has Canceled set to true with a non-nil Err().
0000000000000000000000000000000000000000;;		Canceled bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Created is used to indicate the creation of the watcher.
0000000000000000000000000000000000000000;;		Created bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closeErr error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsCreate returns true if the event tells that the key is newly created.
0000000000000000000000000000000000000000;;	func (e *Event) IsCreate() bool {
0000000000000000000000000000000000000000;;		return e.Type == EventTypePut && e.Kv.CreateRevision == e.Kv.ModRevision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsModify returns true if the event tells that a new value is put on existing key.
0000000000000000000000000000000000000000;;	func (e *Event) IsModify() bool {
0000000000000000000000000000000000000000;;		return e.Type == EventTypePut && e.Kv.CreateRevision != e.Kv.ModRevision
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Err is the error value if this WatchResponse holds an error.
0000000000000000000000000000000000000000;;	func (wr *WatchResponse) Err() error {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case wr.closeErr != nil:
0000000000000000000000000000000000000000;;			return v3rpc.Error(wr.closeErr)
0000000000000000000000000000000000000000;;		case wr.CompactRevision != 0:
0000000000000000000000000000000000000000;;			return v3rpc.ErrCompacted
0000000000000000000000000000000000000000;;		case wr.Canceled:
0000000000000000000000000000000000000000;;			return v3rpc.ErrFutureRev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsProgressNotify returns true if the WatchResponse is progress notification.
0000000000000000000000000000000000000000;;	func (wr *WatchResponse) IsProgressNotify() bool {
0000000000000000000000000000000000000000;;		return len(wr.Events) == 0 && !wr.Canceled && !wr.Created && wr.CompactRevision == 0 && wr.Header.Revision != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watcher implements the Watcher interface
0000000000000000000000000000000000000000;;	type watcher struct {
0000000000000000000000000000000000000000;;		remote pb.WatchClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects the grpc streams map
0000000000000000000000000000000000000000;;		mu sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// streams holds all the active grpc streams keyed by ctx value.
0000000000000000000000000000000000000000;;		streams map[string]*watchGrpcStream
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchGrpcStream tracks all watch resources attached to a single grpc stream.
0000000000000000000000000000000000000000;;	type watchGrpcStream struct {
0000000000000000000000000000000000000000;;		owner  *watcher
0000000000000000000000000000000000000000;;		remote pb.WatchClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ctx controls internal remote.Watch requests
0000000000000000000000000000000000000000;;		ctx context.Context
0000000000000000000000000000000000000000;;		// ctxKey is the key used when looking up this stream's context
0000000000000000000000000000000000000000;;		ctxKey string
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// substreams holds all active watchers on this grpc stream
0000000000000000000000000000000000000000;;		substreams map[int64]*watcherStream
0000000000000000000000000000000000000000;;		// resuming holds all resuming watchers on this grpc stream
0000000000000000000000000000000000000000;;		resuming []*watcherStream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reqc sends a watch request from Watch() to the main goroutine
0000000000000000000000000000000000000000;;		reqc chan *watchRequest
0000000000000000000000000000000000000000;;		// respc receives data from the watch client
0000000000000000000000000000000000000000;;		respc chan *pb.WatchResponse
0000000000000000000000000000000000000000;;		// donec closes to broadcast shutdown
0000000000000000000000000000000000000000;;		donec chan struct{}
0000000000000000000000000000000000000000;;		// errc transmits errors from grpc Recv to the watch stream reconn logic
0000000000000000000000000000000000000000;;		errc chan error
0000000000000000000000000000000000000000;;		// closingc gets the watcherStream of closing watchers
0000000000000000000000000000000000000000;;		closingc chan *watcherStream
0000000000000000000000000000000000000000;;		// wg is Done when all substream goroutines have exited
0000000000000000000000000000000000000000;;		wg sync.WaitGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// resumec closes to signal that all substreams should begin resuming
0000000000000000000000000000000000000000;;		resumec chan struct{}
0000000000000000000000000000000000000000;;		// closeErr is the error that closed the watch stream
0000000000000000000000000000000000000000;;		closeErr error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watchRequest is issued by the subscriber to start a new watcher
0000000000000000000000000000000000000000;;	type watchRequest struct {
0000000000000000000000000000000000000000;;		ctx context.Context
0000000000000000000000000000000000000000;;		key string
0000000000000000000000000000000000000000;;		end string
0000000000000000000000000000000000000000;;		rev int64
0000000000000000000000000000000000000000;;		// send created notification event if this field is true
0000000000000000000000000000000000000000;;		createdNotify bool
0000000000000000000000000000000000000000;;		// progressNotify is for progress updates
0000000000000000000000000000000000000000;;		progressNotify bool
0000000000000000000000000000000000000000;;		// filters is the list of events to filter out
0000000000000000000000000000000000000000;;		filters []pb.WatchCreateRequest_FilterType
0000000000000000000000000000000000000000;;		// get the previous key-value pair before the event happens
0000000000000000000000000000000000000000;;		prevKV bool
0000000000000000000000000000000000000000;;		// retc receives a chan WatchResponse once the watcher is established
0000000000000000000000000000000000000000;;		retc chan chan WatchResponse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// watcherStream represents a registered watcher
0000000000000000000000000000000000000000;;	type watcherStream struct {
0000000000000000000000000000000000000000;;		// initReq is the request that initiated this request
0000000000000000000000000000000000000000;;		initReq watchRequest
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// outc publishes watch responses to subscriber
0000000000000000000000000000000000000000;;		outc chan WatchResponse
0000000000000000000000000000000000000000;;		// recvc buffers watch responses before publishing
0000000000000000000000000000000000000000;;		recvc chan *WatchResponse
0000000000000000000000000000000000000000;;		// donec closes when the watcherStream goroutine stops.
0000000000000000000000000000000000000000;;		donec chan struct{}
0000000000000000000000000000000000000000;;		// closing is set to true when stream should be scheduled to shutdown.
0000000000000000000000000000000000000000;;		closing bool
0000000000000000000000000000000000000000;;		// id is the registered watch id on the grpc stream
0000000000000000000000000000000000000000;;		id int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// buf holds all events received from etcd but not yet consumed by the client
0000000000000000000000000000000000000000;;		buf []*WatchResponse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewWatcher(c *Client) Watcher {
0000000000000000000000000000000000000000;;		return NewWatchFromWatchClient(pb.NewWatchClient(c.conn))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewWatchFromWatchClient(wc pb.WatchClient) Watcher {
0000000000000000000000000000000000000000;;		return &watcher{
0000000000000000000000000000000000000000;;			remote:  wc,
0000000000000000000000000000000000000000;;			streams: make(map[string]*watchGrpcStream),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// never closes
0000000000000000000000000000000000000000;;	var valCtxCh = make(chan struct{})
0000000000000000000000000000000000000000;;	var zeroTime = time.Unix(0, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ctx with only the values; never Done
0000000000000000000000000000000000000000;;	type valCtx struct{ context.Context }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vc *valCtx) Deadline() (time.Time, bool) { return zeroTime, false }
0000000000000000000000000000000000000000;;	func (vc *valCtx) Done() <-chan struct{}       { return valCtxCh }
0000000000000000000000000000000000000000;;	func (vc *valCtx) Err() error                  { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watcher) newWatcherGrpcStream(inctx context.Context) *watchGrpcStream {
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(&valCtx{inctx})
0000000000000000000000000000000000000000;;		wgs := &watchGrpcStream{
0000000000000000000000000000000000000000;;			owner:      w,
0000000000000000000000000000000000000000;;			remote:     w.remote,
0000000000000000000000000000000000000000;;			ctx:        ctx,
0000000000000000000000000000000000000000;;			ctxKey:     fmt.Sprintf("%v", inctx),
0000000000000000000000000000000000000000;;			cancel:     cancel,
0000000000000000000000000000000000000000;;			substreams: make(map[int64]*watcherStream),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			respc:    make(chan *pb.WatchResponse),
0000000000000000000000000000000000000000;;			reqc:     make(chan *watchRequest),
0000000000000000000000000000000000000000;;			donec:    make(chan struct{}),
0000000000000000000000000000000000000000;;			errc:     make(chan error, 1),
0000000000000000000000000000000000000000;;			closingc: make(chan *watcherStream),
0000000000000000000000000000000000000000;;			resumec:  make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go wgs.run()
0000000000000000000000000000000000000000;;		return wgs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watch posts a watch request to run() and waits for a new watcher channel
0000000000000000000000000000000000000000;;	func (w *watcher) Watch(ctx context.Context, key string, opts ...OpOption) WatchChan {
0000000000000000000000000000000000000000;;		ow := opWatch(key, opts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var filters []pb.WatchCreateRequest_FilterType
0000000000000000000000000000000000000000;;		if ow.filterPut {
0000000000000000000000000000000000000000;;			filters = append(filters, pb.WatchCreateRequest_NOPUT)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ow.filterDelete {
0000000000000000000000000000000000000000;;			filters = append(filters, pb.WatchCreateRequest_NODELETE)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wr := &watchRequest{
0000000000000000000000000000000000000000;;			ctx:            ctx,
0000000000000000000000000000000000000000;;			createdNotify:  ow.createdNotify,
0000000000000000000000000000000000000000;;			key:            string(ow.key),
0000000000000000000000000000000000000000;;			end:            string(ow.end),
0000000000000000000000000000000000000000;;			rev:            ow.rev,
0000000000000000000000000000000000000000;;			progressNotify: ow.progressNotify,
0000000000000000000000000000000000000000;;			filters:        filters,
0000000000000000000000000000000000000000;;			prevKV:         ow.prevKV,
0000000000000000000000000000000000000000;;			retc:           make(chan chan WatchResponse, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok := false
0000000000000000000000000000000000000000;;		ctxKey := fmt.Sprintf("%v", ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find or allocate appropriate grpc watch stream
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		if w.streams == nil {
0000000000000000000000000000000000000000;;			// closed
0000000000000000000000000000000000000000;;			w.mu.Unlock()
0000000000000000000000000000000000000000;;			ch := make(chan WatchResponse)
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;			return ch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wgs := w.streams[ctxKey]
0000000000000000000000000000000000000000;;		if wgs == nil {
0000000000000000000000000000000000000000;;			wgs = w.newWatcherGrpcStream(ctx)
0000000000000000000000000000000000000000;;			w.streams[ctxKey] = wgs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		donec := wgs.donec
0000000000000000000000000000000000000000;;		reqc := wgs.reqc
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// couldn't create channel; return closed channel
0000000000000000000000000000000000000000;;		closeCh := make(chan WatchResponse, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// submit request
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case reqc <- wr:
0000000000000000000000000000000000000000;;			ok = true
0000000000000000000000000000000000000000;;		case <-wr.ctx.Done():
0000000000000000000000000000000000000000;;		case <-donec:
0000000000000000000000000000000000000000;;			if wgs.closeErr != nil {
0000000000000000000000000000000000000000;;				closeCh <- WatchResponse{closeErr: wgs.closeErr}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// retry; may have dropped stream from no ctxs
0000000000000000000000000000000000000000;;			return w.Watch(ctx, key, opts...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// receive channel
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case ret := <-wr.retc:
0000000000000000000000000000000000000000;;				return ret
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;			case <-donec:
0000000000000000000000000000000000000000;;				if wgs.closeErr != nil {
0000000000000000000000000000000000000000;;					closeCh <- WatchResponse{closeErr: wgs.closeErr}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// retry; may have dropped stream from no ctxs
0000000000000000000000000000000000000000;;				return w.Watch(ctx, key, opts...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(closeCh)
0000000000000000000000000000000000000000;;		return closeCh
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watcher) Close() (err error) {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		streams := w.streams
0000000000000000000000000000000000000000;;		w.streams = nil
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;		for _, wgs := range streams {
0000000000000000000000000000000000000000;;			if werr := wgs.Close(); werr != nil {
0000000000000000000000000000000000000000;;				err = werr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) Close() (err error) {
0000000000000000000000000000000000000000;;		w.cancel()
0000000000000000000000000000000000000000;;		<-w.donec
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case err = <-w.errc:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return toErr(w.ctx, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watcher) closeStream(wgs *watchGrpcStream) {
0000000000000000000000000000000000000000;;		w.mu.Lock()
0000000000000000000000000000000000000000;;		close(wgs.donec)
0000000000000000000000000000000000000000;;		wgs.cancel()
0000000000000000000000000000000000000000;;		if w.streams != nil {
0000000000000000000000000000000000000000;;			delete(w.streams, wgs.ctxKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) addSubstream(resp *pb.WatchResponse, ws *watcherStream) {
0000000000000000000000000000000000000000;;		if resp.WatchId == -1 {
0000000000000000000000000000000000000000;;			// failed; no channel
0000000000000000000000000000000000000000;;			close(ws.recvc)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ws.id = resp.WatchId
0000000000000000000000000000000000000000;;		w.substreams[ws.id] = ws
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) sendCloseSubstream(ws *watcherStream, resp *WatchResponse) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case ws.outc <- *resp:
0000000000000000000000000000000000000000;;		case <-ws.initReq.ctx.Done():
0000000000000000000000000000000000000000;;		case <-time.After(closeSendErrTimeout):
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(ws.outc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) closeSubstream(ws *watcherStream) {
0000000000000000000000000000000000000000;;		// send channel response in case stream was never established
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case ws.initReq.retc <- ws.outc:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// close subscriber's channel
0000000000000000000000000000000000000000;;		if closeErr := w.closeErr; closeErr != nil && ws.initReq.ctx.Err() == nil {
0000000000000000000000000000000000000000;;			go w.sendCloseSubstream(ws, &WatchResponse{closeErr: w.closeErr})
0000000000000000000000000000000000000000;;		} else if ws.outc != nil {
0000000000000000000000000000000000000000;;			close(ws.outc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ws.id != -1 {
0000000000000000000000000000000000000000;;			delete(w.substreams, ws.id)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range w.resuming {
0000000000000000000000000000000000000000;;			if w.resuming[i] == ws {
0000000000000000000000000000000000000000;;				w.resuming[i] = nil
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// run is the root of the goroutines for managing a watcher client
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) run() {
0000000000000000000000000000000000000000;;		var wc pb.Watch_WatchClient
0000000000000000000000000000000000000000;;		var closeErr error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// substreams marked to close but goroutine still running; needed for
0000000000000000000000000000000000000000;;		// avoiding double-closing recvc on grpc stream teardown
0000000000000000000000000000000000000000;;		closing := make(map[*watcherStream]struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			w.closeErr = closeErr
0000000000000000000000000000000000000000;;			// shutdown substreams and resuming substreams
0000000000000000000000000000000000000000;;			for _, ws := range w.substreams {
0000000000000000000000000000000000000000;;				if _, ok := closing[ws]; !ok {
0000000000000000000000000000000000000000;;					close(ws.recvc)
0000000000000000000000000000000000000000;;					closing[ws] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ws := range w.resuming {
0000000000000000000000000000000000000000;;				if _, ok := closing[ws]; ws != nil && !ok {
0000000000000000000000000000000000000000;;					close(ws.recvc)
0000000000000000000000000000000000000000;;					closing[ws] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.joinSubstreams()
0000000000000000000000000000000000000000;;			for range closing {
0000000000000000000000000000000000000000;;				w.closeSubstream(<-w.closingc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.wg.Wait()
0000000000000000000000000000000000000000;;			w.owner.closeStream(w)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start a stream with the etcd grpc server
0000000000000000000000000000000000000000;;		if wc, closeErr = w.newWatchClient(); closeErr != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cancelSet := make(map[int64]struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			// Watch() requested
0000000000000000000000000000000000000000;;			case wreq := <-w.reqc:
0000000000000000000000000000000000000000;;				outc := make(chan WatchResponse, 1)
0000000000000000000000000000000000000000;;				ws := &watcherStream{
0000000000000000000000000000000000000000;;					initReq: *wreq,
0000000000000000000000000000000000000000;;					id:      -1,
0000000000000000000000000000000000000000;;					outc:    outc,
0000000000000000000000000000000000000000;;					// unbufffered so resumes won't cause repeat events
0000000000000000000000000000000000000000;;					recvc: make(chan *WatchResponse),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ws.donec = make(chan struct{})
0000000000000000000000000000000000000000;;				w.wg.Add(1)
0000000000000000000000000000000000000000;;				go w.serveSubstream(ws, w.resumec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// queue up for watcher creation/resume
0000000000000000000000000000000000000000;;				w.resuming = append(w.resuming, ws)
0000000000000000000000000000000000000000;;				if len(w.resuming) == 1 {
0000000000000000000000000000000000000000;;					// head of resume queue, can register a new watcher
0000000000000000000000000000000000000000;;					wc.Send(ws.initReq.toPB())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			// New events from the watch client
0000000000000000000000000000000000000000;;			case pbresp := <-w.respc:
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case pbresp.Created:
0000000000000000000000000000000000000000;;					// response to head of queue creation
0000000000000000000000000000000000000000;;					if ws := w.resuming[0]; ws != nil {
0000000000000000000000000000000000000000;;						w.addSubstream(pbresp, ws)
0000000000000000000000000000000000000000;;						w.dispatchEvent(pbresp)
0000000000000000000000000000000000000000;;						w.resuming[0] = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if ws := w.nextResume(); ws != nil {
0000000000000000000000000000000000000000;;						wc.Send(ws.initReq.toPB())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case pbresp.Canceled:
0000000000000000000000000000000000000000;;					delete(cancelSet, pbresp.WatchId)
0000000000000000000000000000000000000000;;					if ws, ok := w.substreams[pbresp.WatchId]; ok {
0000000000000000000000000000000000000000;;						// signal to stream goroutine to update closingc
0000000000000000000000000000000000000000;;						close(ws.recvc)
0000000000000000000000000000000000000000;;						closing[ws] = struct{}{}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// dispatch to appropriate watch stream
0000000000000000000000000000000000000000;;					if ok := w.dispatchEvent(pbresp); ok {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// watch response on unexpected watch id; cancel id
0000000000000000000000000000000000000000;;					if _, ok := cancelSet[pbresp.WatchId]; ok {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					cancelSet[pbresp.WatchId] = struct{}{}
0000000000000000000000000000000000000000;;					cr := &pb.WatchRequest_CancelRequest{
0000000000000000000000000000000000000000;;						CancelRequest: &pb.WatchCancelRequest{
0000000000000000000000000000000000000000;;							WatchId: pbresp.WatchId,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					req := &pb.WatchRequest{RequestUnion: cr}
0000000000000000000000000000000000000000;;					wc.Send(req)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			// watch client failed to recv; spawn another if possible
0000000000000000000000000000000000000000;;			case err := <-w.errc:
0000000000000000000000000000000000000000;;				if isHaltErr(w.ctx, err) || toErr(w.ctx, err) == v3rpc.ErrNoLeader {
0000000000000000000000000000000000000000;;					closeErr = err
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if wc, closeErr = w.newWatchClient(); closeErr != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ws := w.nextResume(); ws != nil {
0000000000000000000000000000000000000000;;					wc.Send(ws.initReq.toPB())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cancelSet = make(map[int64]struct{})
0000000000000000000000000000000000000000;;			case <-w.ctx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case ws := <-w.closingc:
0000000000000000000000000000000000000000;;				w.closeSubstream(ws)
0000000000000000000000000000000000000000;;				delete(closing, ws)
0000000000000000000000000000000000000000;;				if len(w.substreams)+len(w.resuming) == 0 {
0000000000000000000000000000000000000000;;					// no more watchers on this stream, shutdown
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextResume chooses the next resuming to register with the grpc stream. Abandoned
0000000000000000000000000000000000000000;;	// streams are marked as nil in the queue since the head must wait for its inflight registration.
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) nextResume() *watcherStream {
0000000000000000000000000000000000000000;;		for len(w.resuming) != 0 {
0000000000000000000000000000000000000000;;			if w.resuming[0] != nil {
0000000000000000000000000000000000000000;;				return w.resuming[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.resuming = w.resuming[1:len(w.resuming)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dispatchEvent sends a WatchResponse to the appropriate watcher stream
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) dispatchEvent(pbresp *pb.WatchResponse) bool {
0000000000000000000000000000000000000000;;		ws, ok := w.substreams[pbresp.WatchId]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		events := make([]*Event, len(pbresp.Events))
0000000000000000000000000000000000000000;;		for i, ev := range pbresp.Events {
0000000000000000000000000000000000000000;;			events[i] = (*Event)(ev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wr := &WatchResponse{
0000000000000000000000000000000000000000;;			Header:          *pbresp.Header,
0000000000000000000000000000000000000000;;			Events:          events,
0000000000000000000000000000000000000000;;			CompactRevision: pbresp.CompactRevision,
0000000000000000000000000000000000000000;;			Created:         pbresp.Created,
0000000000000000000000000000000000000000;;			Canceled:        pbresp.Canceled,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case ws.recvc <- wr:
0000000000000000000000000000000000000000;;		case <-ws.donec:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveWatchClient forwards messages from the grpc stream to run()
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) serveWatchClient(wc pb.Watch_WatchClient) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resp, err := wc.Recv()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case w.errc <- err:
0000000000000000000000000000000000000000;;				case <-w.donec:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case w.respc <- resp:
0000000000000000000000000000000000000000;;			case <-w.donec:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveSubstream forwards watch responses from run() to the subscriber
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) serveSubstream(ws *watcherStream, resumec chan struct{}) {
0000000000000000000000000000000000000000;;		if ws.closing {
0000000000000000000000000000000000000000;;			panic("created substream goroutine but substream is closing")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// nextRev is the minimum expected next revision
0000000000000000000000000000000000000000;;		nextRev := ws.initReq.rev
0000000000000000000000000000000000000000;;		resuming := false
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if !resuming {
0000000000000000000000000000000000000000;;				ws.closing = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			close(ws.donec)
0000000000000000000000000000000000000000;;			if !resuming {
0000000000000000000000000000000000000000;;				w.closingc <- ws
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.wg.Done()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		emptyWr := &WatchResponse{}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			curWr := emptyWr
0000000000000000000000000000000000000000;;			outc := ws.outc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(ws.buf) > 0 {
0000000000000000000000000000000000000000;;				curWr = ws.buf[0]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				outc = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case outc <- *curWr:
0000000000000000000000000000000000000000;;				if ws.buf[0].Err() != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ws.buf[0] = nil
0000000000000000000000000000000000000000;;				ws.buf = ws.buf[1:]
0000000000000000000000000000000000000000;;			case wr, ok := <-ws.recvc:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					// shutdown from closeSubstream
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if wr.Created {
0000000000000000000000000000000000000000;;					if ws.initReq.retc != nil {
0000000000000000000000000000000000000000;;						ws.initReq.retc <- ws.outc
0000000000000000000000000000000000000000;;						// to prevent next write from taking the slot in buffered channel
0000000000000000000000000000000000000000;;						// and posting duplicate create events
0000000000000000000000000000000000000000;;						ws.initReq.retc = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// send first creation event only if requested
0000000000000000000000000000000000000000;;						if ws.initReq.createdNotify {
0000000000000000000000000000000000000000;;							ws.outc <- *wr
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nextRev = wr.Header.Revision
0000000000000000000000000000000000000000;;				if len(wr.Events) > 0 {
0000000000000000000000000000000000000000;;					nextRev = wr.Events[len(wr.Events)-1].Kv.ModRevision + 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ws.initReq.rev = nextRev
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// created event is already sent above,
0000000000000000000000000000000000000000;;				// watcher should not post duplicate events
0000000000000000000000000000000000000000;;				if wr.Created {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO pause channel if buffer gets too large
0000000000000000000000000000000000000000;;				ws.buf = append(ws.buf, wr)
0000000000000000000000000000000000000000;;			case <-w.ctx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-ws.initReq.ctx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-resumec:
0000000000000000000000000000000000000000;;				resuming = true
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// lazily send cancel message if events on missing id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) newWatchClient() (pb.Watch_WatchClient, error) {
0000000000000000000000000000000000000000;;		// mark all substreams as resuming
0000000000000000000000000000000000000000;;		close(w.resumec)
0000000000000000000000000000000000000000;;		w.resumec = make(chan struct{})
0000000000000000000000000000000000000000;;		w.joinSubstreams()
0000000000000000000000000000000000000000;;		for _, ws := range w.substreams {
0000000000000000000000000000000000000000;;			ws.id = -1
0000000000000000000000000000000000000000;;			w.resuming = append(w.resuming, ws)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// strip out nils, if any
0000000000000000000000000000000000000000;;		var resuming []*watcherStream
0000000000000000000000000000000000000000;;		for _, ws := range w.resuming {
0000000000000000000000000000000000000000;;			if ws != nil {
0000000000000000000000000000000000000000;;				resuming = append(resuming, ws)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.resuming = resuming
0000000000000000000000000000000000000000;;		w.substreams = make(map[int64]*watcherStream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// connect to grpc stream while accepting watcher cancelation
0000000000000000000000000000000000000000;;		stopc := make(chan struct{})
0000000000000000000000000000000000000000;;		donec := w.waitCancelSubstreams(stopc)
0000000000000000000000000000000000000000;;		wc, err := w.openWatchClient()
0000000000000000000000000000000000000000;;		close(stopc)
0000000000000000000000000000000000000000;;		<-donec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// serve all non-closing streams, even if there's a client error
0000000000000000000000000000000000000000;;		// so that the teardown path can shutdown the streams as expected.
0000000000000000000000000000000000000000;;		for _, ws := range w.resuming {
0000000000000000000000000000000000000000;;			if ws.closing {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ws.donec = make(chan struct{})
0000000000000000000000000000000000000000;;			w.wg.Add(1)
0000000000000000000000000000000000000000;;			go w.serveSubstream(ws, w.resumec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, v3rpc.Error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// receive data from new grpc stream
0000000000000000000000000000000000000000;;		go w.serveWatchClient(wc)
0000000000000000000000000000000000000000;;		return wc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) waitCancelSubstreams(stopc <-chan struct{}) <-chan struct{} {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(len(w.resuming))
0000000000000000000000000000000000000000;;		donec := make(chan struct{})
0000000000000000000000000000000000000000;;		for i := range w.resuming {
0000000000000000000000000000000000000000;;			go func(ws *watcherStream) {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				if ws.closing {
0000000000000000000000000000000000000000;;					if ws.initReq.ctx.Err() != nil && ws.outc != nil {
0000000000000000000000000000000000000000;;						close(ws.outc)
0000000000000000000000000000000000000000;;						ws.outc = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-ws.initReq.ctx.Done():
0000000000000000000000000000000000000000;;					// closed ws will be removed from resuming
0000000000000000000000000000000000000000;;					ws.closing = true
0000000000000000000000000000000000000000;;					close(ws.outc)
0000000000000000000000000000000000000000;;					ws.outc = nil
0000000000000000000000000000000000000000;;					go func() { w.closingc <- ws }()
0000000000000000000000000000000000000000;;				case <-stopc:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}(w.resuming[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			defer close(donec)
0000000000000000000000000000000000000000;;			wg.Wait()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return donec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// joinSubstream waits for all substream goroutines to complete
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) joinSubstreams() {
0000000000000000000000000000000000000000;;		for _, ws := range w.substreams {
0000000000000000000000000000000000000000;;			<-ws.donec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ws := range w.resuming {
0000000000000000000000000000000000000000;;			if ws != nil {
0000000000000000000000000000000000000000;;				<-ws.donec
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// openWatchClient retries opening a watchclient until retryConnection fails
0000000000000000000000000000000000000000;;	func (w *watchGrpcStream) openWatchClient() (ws pb.Watch_WatchClient, err error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-w.ctx.Done():
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					return nil, w.ctx.Err()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ws, err = w.remote.Watch(w.ctx, grpc.FailFast(false)); ws != nil && err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHaltErr(w.ctx, err) {
0000000000000000000000000000000000000000;;				return nil, v3rpc.Error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ws, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toPB converts an internal watch request structure to its protobuf messagefunc (wr *watchRequest)
0000000000000000000000000000000000000000;;	func (wr *watchRequest) toPB() *pb.WatchRequest {
0000000000000000000000000000000000000000;;		req := &pb.WatchCreateRequest{
0000000000000000000000000000000000000000;;			StartRevision:  wr.rev,
0000000000000000000000000000000000000000;;			Key:            []byte(wr.key),
0000000000000000000000000000000000000000;;			RangeEnd:       []byte(wr.end),
0000000000000000000000000000000000000000;;			ProgressNotify: wr.progressNotify,
0000000000000000000000000000000000000000;;			Filters:        wr.filters,
0000000000000000000000000000000000000000;;			PrevKv:         wr.prevKV,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr := &pb.WatchRequest_CreateRequest{CreateRequest: req}
0000000000000000000000000000000000000000;;		return &pb.WatchRequest{RequestUnion: cr}
0000000000000000000000000000000000000000;;	}
