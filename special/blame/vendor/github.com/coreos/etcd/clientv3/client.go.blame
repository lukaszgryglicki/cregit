0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
9b11e90c65f84c704d29a1c6a5867d26fdba23c5;Godeps/_workspace/src/github.com/coreos/etcd/clientv3/client.go[Godeps/_workspace/src/github.com/coreos/etcd/clientv3/client.go][vendor/github.com/coreos/etcd/clientv3/client.go];	
0000000000000000000000000000000000000000;;	package clientv3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		prometheus "github.com/grpc-ecosystem/go-grpc-prometheus"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/credentials"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrNoAvailableEndpoints = errors.New("etcdclient: no available endpoints")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client provides and manages an etcd v3 client session.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		Cluster
0000000000000000000000000000000000000000;;		KV
0000000000000000000000000000000000000000;;		Lease
0000000000000000000000000000000000000000;;		Watcher
0000000000000000000000000000000000000000;;		Auth
0000000000000000000000000000000000000000;;		Maintenance
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn             *grpc.ClientConn
0000000000000000000000000000000000000000;;		cfg              Config
0000000000000000000000000000000000000000;;		creds            *credentials.TransportCredentials
0000000000000000000000000000000000000000;;		balancer         *simpleBalancer
0000000000000000000000000000000000000000;;		retryWrapper     retryRpcFunc
0000000000000000000000000000000000000000;;		retryAuthWrapper retryRpcFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx    context.Context
0000000000000000000000000000000000000000;;		cancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Username is a username for authentication
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;		// Password is a password for authentication
0000000000000000000000000000000000000000;;		Password string
0000000000000000000000000000000000000000;;		// tokenCred is an instance of WithPerRPCCredentials()'s argument
0000000000000000000000000000000000000000;;		tokenCred *authTokenCredential
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new etcdv3 client from a given configuration.
0000000000000000000000000000000000000000;;	func New(cfg Config) (*Client, error) {
0000000000000000000000000000000000000000;;		if len(cfg.Endpoints) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrNoAvailableEndpoints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newClient(&cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromURL creates a new etcdv3 client from a URL.
0000000000000000000000000000000000000000;;	func NewFromURL(url string) (*Client, error) {
0000000000000000000000000000000000000000;;		return New(Config{Endpoints: []string{url}})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFromConfigFile creates a new etcdv3 client from a configuration file.
0000000000000000000000000000000000000000;;	func NewFromConfigFile(path string) (*Client, error) {
0000000000000000000000000000000000000000;;		cfg, err := configFromFile(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return New(*cfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close shuts down the client's etcd connections.
0000000000000000000000000000000000000000;;	func (c *Client) Close() error {
0000000000000000000000000000000000000000;;		c.cancel()
0000000000000000000000000000000000000000;;		c.Watcher.Close()
0000000000000000000000000000000000000000;;		c.Lease.Close()
0000000000000000000000000000000000000000;;		return toErr(c.ctx, c.conn.Close())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ctx is a context for "out of band" messages (e.g., for sending
0000000000000000000000000000000000000000;;	// "clean up" message when another context is canceled). It is
0000000000000000000000000000000000000000;;	// canceled on client Close().
0000000000000000000000000000000000000000;;	func (c *Client) Ctx() context.Context { return c.ctx }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoints lists the registered endpoints for the client.
0000000000000000000000000000000000000000;;	func (c *Client) Endpoints() (eps []string) {
0000000000000000000000000000000000000000;;		// copy the slice; protect original endpoints from being changed
0000000000000000000000000000000000000000;;		eps = make([]string, len(c.cfg.Endpoints))
0000000000000000000000000000000000000000;;		copy(eps, c.cfg.Endpoints)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEndpoints updates client's endpoints.
0000000000000000000000000000000000000000;;	func (c *Client) SetEndpoints(eps ...string) {
0000000000000000000000000000000000000000;;		c.cfg.Endpoints = eps
0000000000000000000000000000000000000000;;		c.balancer.updateAddrs(eps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sync synchronizes client's endpoints with the known endpoints from the etcd membership.
0000000000000000000000000000000000000000;;	func (c *Client) Sync(ctx context.Context) error {
0000000000000000000000000000000000000000;;		mresp, err := c.MemberList(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var eps []string
0000000000000000000000000000000000000000;;		for _, m := range mresp.Members {
0000000000000000000000000000000000000000;;			eps = append(eps, m.ClientURLs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.SetEndpoints(eps...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) autoSync() {
0000000000000000000000000000000000000000;;		if c.cfg.AutoSyncInterval == time.Duration(0) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-c.ctx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-time.After(c.cfg.AutoSyncInterval):
0000000000000000000000000000000000000000;;				ctx, _ := context.WithTimeout(c.ctx, 5*time.Second)
0000000000000000000000000000000000000000;;				if err := c.Sync(ctx); err != nil && err != c.ctx.Err() {
0000000000000000000000000000000000000000;;					logger.Println("Auto sync endpoints failed:", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authTokenCredential struct {
0000000000000000000000000000000000000000;;		token   string
0000000000000000000000000000000000000000;;		tokenMu *sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cred authTokenCredential) RequireTransportSecurity() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cred authTokenCredential) GetRequestMetadata(ctx context.Context, s ...string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		cred.tokenMu.RLock()
0000000000000000000000000000000000000000;;		defer cred.tokenMu.RUnlock()
0000000000000000000000000000000000000000;;		return map[string]string{
0000000000000000000000000000000000000000;;			"token": cred.token,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseEndpoint(endpoint string) (proto string, host string, scheme string) {
0000000000000000000000000000000000000000;;		proto = "tcp"
0000000000000000000000000000000000000000;;		host = endpoint
0000000000000000000000000000000000000000;;		url, uerr := url.Parse(endpoint)
0000000000000000000000000000000000000000;;		if uerr != nil || !strings.Contains(endpoint, "://") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		scheme = url.Scheme
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// strip scheme:// prefix since grpc dials by host
0000000000000000000000000000000000000000;;		host = url.Host
0000000000000000000000000000000000000000;;		switch url.Scheme {
0000000000000000000000000000000000000000;;		case "http", "https":
0000000000000000000000000000000000000000;;		case "unix":
0000000000000000000000000000000000000000;;			proto = "unix"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			proto, host = "", ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) processCreds(scheme string) (creds *credentials.TransportCredentials) {
0000000000000000000000000000000000000000;;		creds = c.creds
0000000000000000000000000000000000000000;;		switch scheme {
0000000000000000000000000000000000000000;;		case "unix":
0000000000000000000000000000000000000000;;		case "http":
0000000000000000000000000000000000000000;;			creds = nil
0000000000000000000000000000000000000000;;		case "https":
0000000000000000000000000000000000000000;;			if creds != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsconfig := &tls.Config{}
0000000000000000000000000000000000000000;;			emptyCreds := credentials.NewTLS(tlsconfig)
0000000000000000000000000000000000000000;;			creds = &emptyCreds
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			creds = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dialSetupOpts gives the dial opts prior to any authentication
0000000000000000000000000000000000000000;;	func (c *Client) dialSetupOpts(endpoint string, dopts ...grpc.DialOption) (opts []grpc.DialOption) {
0000000000000000000000000000000000000000;;		if c.cfg.DialTimeout > 0 {
0000000000000000000000000000000000000000;;			opts = []grpc.DialOption{grpc.WithTimeout(c.cfg.DialTimeout)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts = append(opts, dopts...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f := func(host string, t time.Duration) (net.Conn, error) {
0000000000000000000000000000000000000000;;			proto, host, _ := parseEndpoint(c.balancer.getEndpoint(host))
0000000000000000000000000000000000000000;;			if proto == "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unknown scheme for %q", host)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-c.ctx.Done():
0000000000000000000000000000000000000000;;				return nil, c.ctx.Err()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dialer := &net.Dialer{Timeout: t}
0000000000000000000000000000000000000000;;			return dialer.DialContext(c.ctx, proto, host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		opts = append(opts, grpc.WithDialer(f))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		creds := c.creds
0000000000000000000000000000000000000000;;		if _, _, scheme := parseEndpoint(endpoint); len(scheme) != 0 {
0000000000000000000000000000000000000000;;			creds = c.processCreds(scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if creds != nil {
0000000000000000000000000000000000000000;;			opts = append(opts, grpc.WithTransportCredentials(*creds))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			opts = append(opts, grpc.WithInsecure())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return opts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial connects to a single endpoint using the client's config.
0000000000000000000000000000000000000000;;	func (c *Client) Dial(endpoint string) (*grpc.ClientConn, error) {
0000000000000000000000000000000000000000;;		return c.dial(endpoint)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) getToken(ctx context.Context) error {
0000000000000000000000000000000000000000;;		var err error // return last error in a case of fail
0000000000000000000000000000000000000000;;		var auth *authenticator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(c.cfg.Endpoints); i++ {
0000000000000000000000000000000000000000;;			endpoint := c.cfg.Endpoints[i]
0000000000000000000000000000000000000000;;			host := getHost(endpoint)
0000000000000000000000000000000000000000;;			// use dial options without dopts to avoid reusing the client balancer
0000000000000000000000000000000000000000;;			auth, err = newAuthenticator(host, c.dialSetupOpts(endpoint))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer auth.close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var resp *AuthenticateResponse
0000000000000000000000000000000000000000;;			resp, err = auth.authenticate(ctx, c.Username, c.Password)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.tokenCred.tokenMu.Lock()
0000000000000000000000000000000000000000;;			c.tokenCred.token = resp.Token
0000000000000000000000000000000000000000;;			c.tokenCred.tokenMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) dial(endpoint string, dopts ...grpc.DialOption) (*grpc.ClientConn, error) {
0000000000000000000000000000000000000000;;		opts := c.dialSetupOpts(endpoint, dopts...)
0000000000000000000000000000000000000000;;		host := getHost(endpoint)
0000000000000000000000000000000000000000;;		if c.Username != "" && c.Password != "" {
0000000000000000000000000000000000000000;;			c.tokenCred = &authTokenCredential{
0000000000000000000000000000000000000000;;				tokenMu: &sync.RWMutex{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := c.getToken(context.TODO())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			opts = append(opts, grpc.WithPerRPCCredentials(c.tokenCred))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add metrics options
0000000000000000000000000000000000000000;;		opts = append(opts, grpc.WithUnaryInterceptor(prometheus.UnaryClientInterceptor))
0000000000000000000000000000000000000000;;		opts = append(opts, grpc.WithStreamInterceptor(prometheus.StreamClientInterceptor))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := grpc.Dial(host, opts...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithRequireLeader requires client requests to only succeed
0000000000000000000000000000000000000000;;	// when the cluster has a leader.
0000000000000000000000000000000000000000;;	func WithRequireLeader(ctx context.Context) context.Context {
0000000000000000000000000000000000000000;;		md := metadata.Pairs(rpctypes.MetadataRequireLeaderKey, rpctypes.MetadataHasLeader)
0000000000000000000000000000000000000000;;		return metadata.NewContext(ctx, md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newClient(cfg *Config) (*Client, error) {
0000000000000000000000000000000000000000;;		if cfg == nil {
0000000000000000000000000000000000000000;;			cfg = &Config{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var creds *credentials.TransportCredentials
0000000000000000000000000000000000000000;;		if cfg.TLS != nil {
0000000000000000000000000000000000000000;;			c := credentials.NewTLS(cfg.TLS)
0000000000000000000000000000000000000000;;			creds = &c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// use a temporary skeleton client to bootstrap first connection
0000000000000000000000000000000000000000;;		ctx, cancel := context.WithCancel(context.TODO())
0000000000000000000000000000000000000000;;		client := &Client{
0000000000000000000000000000000000000000;;			conn:   nil,
0000000000000000000000000000000000000000;;			cfg:    *cfg,
0000000000000000000000000000000000000000;;			creds:  creds,
0000000000000000000000000000000000000000;;			ctx:    ctx,
0000000000000000000000000000000000000000;;			cancel: cancel,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Username != "" && cfg.Password != "" {
0000000000000000000000000000000000000000;;			client.Username = cfg.Username
0000000000000000000000000000000000000000;;			client.Password = cfg.Password
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.balancer = newSimpleBalancer(cfg.Endpoints)
0000000000000000000000000000000000000000;;		conn, err := client.dial(cfg.Endpoints[0], grpc.WithBalancer(client.balancer))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client.conn = conn
0000000000000000000000000000000000000000;;		client.retryWrapper = client.newRetryWrapper()
0000000000000000000000000000000000000000;;		client.retryAuthWrapper = client.newAuthRetryWrapper()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// wait for a connection
0000000000000000000000000000000000000000;;		if cfg.DialTimeout > 0 {
0000000000000000000000000000000000000000;;			hasConn := false
0000000000000000000000000000000000000000;;			waitc := time.After(cfg.DialTimeout)
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-client.balancer.readyc:
0000000000000000000000000000000000000000;;				hasConn = true
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;			case <-waitc:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !hasConn {
0000000000000000000000000000000000000000;;				client.cancel()
0000000000000000000000000000000000000000;;				conn.Close()
0000000000000000000000000000000000000000;;				return nil, grpc.ErrClientConnTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.Cluster = NewCluster(client)
0000000000000000000000000000000000000000;;		client.KV = NewKV(client)
0000000000000000000000000000000000000000;;		client.Lease = NewLease(client)
0000000000000000000000000000000000000000;;		client.Watcher = NewWatcher(client)
0000000000000000000000000000000000000000;;		client.Auth = NewAuth(client)
0000000000000000000000000000000000000000;;		client.Maintenance = NewMaintenance(client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go client.autoSync()
0000000000000000000000000000000000000000;;		return client, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActiveConnection returns the current in-use connection
0000000000000000000000000000000000000000;;	func (c *Client) ActiveConnection() *grpc.ClientConn { return c.conn }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isHaltErr returns true if the given error and context indicate no forward
0000000000000000000000000000000000000000;;	// progress can be made, even after reconnecting.
0000000000000000000000000000000000000000;;	func isHaltErr(ctx context.Context, err error) bool {
0000000000000000000000000000000000000000;;		if ctx != nil && ctx.Err() != nil {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		code := grpc.Code(err)
0000000000000000000000000000000000000000;;		// Unavailable codes mean the system will be right back.
0000000000000000000000000000000000000000;;		// (e.g., can't connect, lost leader)
0000000000000000000000000000000000000000;;		// Treat Internal codes as if something failed, leaving the
0000000000000000000000000000000000000000;;		// system in an inconsistent state, but retrying could make progress.
0000000000000000000000000000000000000000;;		// (e.g., failed in middle of send, corrupted frame)
0000000000000000000000000000000000000000;;		// TODO: are permanent Internal errors possible from grpc?
0000000000000000000000000000000000000000;;		return code != codes.Unavailable && code != codes.Internal
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toErr(ctx context.Context, err error) error {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = rpctypes.Error(err)
0000000000000000000000000000000000000000;;		if _, ok := err.(rpctypes.EtcdError); ok {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		code := grpc.Code(err)
0000000000000000000000000000000000000000;;		switch code {
0000000000000000000000000000000000000000;;		case codes.DeadlineExceeded:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case codes.Canceled:
0000000000000000000000000000000000000000;;			if ctx.Err() != nil {
0000000000000000000000000000000000000000;;				err = ctx.Err()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case codes.Unavailable:
0000000000000000000000000000000000000000;;			err = ErrNoAvailableEndpoints
0000000000000000000000000000000000000000;;		case codes.FailedPrecondition:
0000000000000000000000000000000000000000;;			err = grpc.ErrClientConnClosing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
