0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
9b11e90c65f84c704d29a1c6a5867d26fdba23c5;Godeps/_workspace/src/github.com/coreos/etcd/clientv3/maintenance.go[Godeps/_workspace/src/github.com/coreos/etcd/clientv3/maintenance.go][vendor/github.com/coreos/etcd/clientv3/maintenance.go];	
0000000000000000000000000000000000000000;;	package clientv3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type (
0000000000000000000000000000000000000000;;		DefragmentResponse pb.DefragmentResponse
0000000000000000000000000000000000000000;;		AlarmResponse      pb.AlarmResponse
0000000000000000000000000000000000000000;;		AlarmMember        pb.AlarmMember
0000000000000000000000000000000000000000;;		StatusResponse     pb.StatusResponse
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Maintenance interface {
0000000000000000000000000000000000000000;;		// AlarmList gets all active alarms.
0000000000000000000000000000000000000000;;		AlarmList(ctx context.Context) (*AlarmResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AlarmDisarm disarms a given alarm.
0000000000000000000000000000000000000000;;		AlarmDisarm(ctx context.Context, m *AlarmMember) (*AlarmResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Defragment defragments storage backend of the etcd member with given endpoint.
0000000000000000000000000000000000000000;;		// Defragment is only needed when deleting a large number of keys and want to reclaim
0000000000000000000000000000000000000000;;		// the resources.
0000000000000000000000000000000000000000;;		// Defragment is an expensive operation. User should avoid defragmenting multiple members
0000000000000000000000000000000000000000;;		// at the same time.
0000000000000000000000000000000000000000;;		// To defragment multiple members in the cluster, user need to call defragment multiple
0000000000000000000000000000000000000000;;		// times with different endpoints.
0000000000000000000000000000000000000000;;		Defragment(ctx context.Context, endpoint string) (*DefragmentResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status gets the status of the endpoint.
0000000000000000000000000000000000000000;;		Status(ctx context.Context, endpoint string) (*StatusResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Snapshot provides a reader for a snapshot of a backend.
0000000000000000000000000000000000000000;;		Snapshot(ctx context.Context) (io.ReadCloser, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type maintenance struct {
0000000000000000000000000000000000000000;;		c      *Client
0000000000000000000000000000000000000000;;		remote pb.MaintenanceClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMaintenance(c *Client) Maintenance {
0000000000000000000000000000000000000000;;		return &maintenance{c: c, remote: pb.NewMaintenanceClient(c.conn)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *maintenance) AlarmList(ctx context.Context) (*AlarmResponse, error) {
0000000000000000000000000000000000000000;;		req := &pb.AlarmRequest{
0000000000000000000000000000000000000000;;			Action:   pb.AlarmRequest_GET,
0000000000000000000000000000000000000000;;			MemberID: 0,                 // all
0000000000000000000000000000000000000000;;			Alarm:    pb.AlarmType_NONE, // all
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resp, err := m.remote.Alarm(ctx, req, grpc.FailFast(false))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return (*AlarmResponse)(resp), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHaltErr(ctx, err) {
0000000000000000000000000000000000000000;;				return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *maintenance) AlarmDisarm(ctx context.Context, am *AlarmMember) (*AlarmResponse, error) {
0000000000000000000000000000000000000000;;		req := &pb.AlarmRequest{
0000000000000000000000000000000000000000;;			Action:   pb.AlarmRequest_DEACTIVATE,
0000000000000000000000000000000000000000;;			MemberID: am.MemberID,
0000000000000000000000000000000000000000;;			Alarm:    am.Alarm,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if req.MemberID == 0 && req.Alarm == pb.AlarmType_NONE {
0000000000000000000000000000000000000000;;			ar, err := m.AlarmList(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret := AlarmResponse{}
0000000000000000000000000000000000000000;;			for _, am := range ar.Alarms {
0000000000000000000000000000000000000000;;				dresp, derr := m.AlarmDisarm(ctx, (*AlarmMember)(am))
0000000000000000000000000000000000000000;;				if derr != nil {
0000000000000000000000000000000000000000;;					return nil, toErr(ctx, derr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ret.Alarms = append(ret.Alarms, dresp.Alarms...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &ret, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := m.remote.Alarm(ctx, req, grpc.FailFast(false))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return (*AlarmResponse)(resp), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *maintenance) Defragment(ctx context.Context, endpoint string) (*DefragmentResponse, error) {
0000000000000000000000000000000000000000;;		conn, err := m.c.Dial(endpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;		remote := pb.NewMaintenanceClient(conn)
0000000000000000000000000000000000000000;;		resp, err := remote.Defragment(ctx, &pb.DefragmentRequest{}, grpc.FailFast(false))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*DefragmentResponse)(resp), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *maintenance) Status(ctx context.Context, endpoint string) (*StatusResponse, error) {
0000000000000000000000000000000000000000;;		conn, err := m.c.Dial(endpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer conn.Close()
0000000000000000000000000000000000000000;;		remote := pb.NewMaintenanceClient(conn)
0000000000000000000000000000000000000000;;		resp, err := remote.Status(ctx, &pb.StatusRequest{}, grpc.FailFast(false))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (*StatusResponse)(resp), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *maintenance) Snapshot(ctx context.Context) (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		ss, err := m.remote.Snapshot(ctx, &pb.SnapshotRequest{}, grpc.FailFast(false))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pr, pw := io.Pipe()
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				resp, err := ss.Recv()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					pw.CloseWithError(err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if resp == nil && err == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, werr := pw.Write(resp.Blob); werr != nil {
0000000000000000000000000000000000000000;;					pw.CloseWithError(werr)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pw.Close()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return pr, nil
0000000000000000000000000000000000000000;;	}
