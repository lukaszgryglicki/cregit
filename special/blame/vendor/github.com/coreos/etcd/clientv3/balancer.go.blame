0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	package clientv3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrNoAddrAvilable is returned by Get() when the balancer does not have
0000000000000000000000000000000000000000;;	// any active connection to endpoints at the time.
0000000000000000000000000000000000000000;;	// This error is returned only when opts.BlockingWait is true.
0000000000000000000000000000000000000000;;	var ErrNoAddrAvilable = grpc.Errorf(codes.Unavailable, "there is no address available")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// simpleBalancer does the bare minimum to expose multiple eps
0000000000000000000000000000000000000000;;	// to the grpc reconnection code path
0000000000000000000000000000000000000000;;	type simpleBalancer struct {
0000000000000000000000000000000000000000;;		// addrs are the client's endpoints for grpc
0000000000000000000000000000000000000000;;		addrs []grpc.Address
0000000000000000000000000000000000000000;;		// notifyCh notifies grpc of the set of addresses for connecting
0000000000000000000000000000000000000000;;		notifyCh chan []grpc.Address
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readyc closes once the first connection is up
0000000000000000000000000000000000000000;;		readyc    chan struct{}
0000000000000000000000000000000000000000;;		readyOnce sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// mu protects upEps, pinAddr, and connectingAddr
0000000000000000000000000000000000000000;;		mu sync.RWMutex
0000000000000000000000000000000000000000;;		// upEps holds the current endpoints that have an active connection
0000000000000000000000000000000000000000;;		upEps map[string]struct{}
0000000000000000000000000000000000000000;;		// upc closes when upEps transitions from empty to non-zero or the balancer closes.
0000000000000000000000000000000000000000;;		upc chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// grpc issues TLS cert checks using the string passed into dial so
0000000000000000000000000000000000000000;;		// that string must be the host. To recover the full scheme://host URL,
0000000000000000000000000000000000000000;;		// have a map from hosts to the original endpoint.
0000000000000000000000000000000000000000;;		host2ep map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pinAddr is the currently pinned address; set to the empty string on
0000000000000000000000000000000000000000;;		// intialization and shutdown.
0000000000000000000000000000000000000000;;		pinAddr string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		closed bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSimpleBalancer(eps []string) *simpleBalancer {
0000000000000000000000000000000000000000;;		notifyCh := make(chan []grpc.Address, 1)
0000000000000000000000000000000000000000;;		addrs := make([]grpc.Address, len(eps))
0000000000000000000000000000000000000000;;		for i := range eps {
0000000000000000000000000000000000000000;;			addrs[i].Addr = getHost(eps[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		notifyCh <- addrs
0000000000000000000000000000000000000000;;		sb := &simpleBalancer{
0000000000000000000000000000000000000000;;			addrs:    addrs,
0000000000000000000000000000000000000000;;			notifyCh: notifyCh,
0000000000000000000000000000000000000000;;			readyc:   make(chan struct{}),
0000000000000000000000000000000000000000;;			upEps:    make(map[string]struct{}),
0000000000000000000000000000000000000000;;			upc:      make(chan struct{}),
0000000000000000000000000000000000000000;;			host2ep:  getHost2ep(eps),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sb
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) Start(target string, config grpc.BalancerConfig) error { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) ConnectNotify() <-chan struct{} {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		return b.upc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) getEndpoint(host string) string {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		return b.host2ep[host]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getHost2ep(eps []string) map[string]string {
0000000000000000000000000000000000000000;;		hm := make(map[string]string, len(eps))
0000000000000000000000000000000000000000;;		for i := range eps {
0000000000000000000000000000000000000000;;			_, host, _ := parseEndpoint(eps[i])
0000000000000000000000000000000000000000;;			hm[host] = eps[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) updateAddrs(eps []string) {
0000000000000000000000000000000000000000;;		np := getHost2ep(eps)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match := len(np) == len(b.host2ep)
0000000000000000000000000000000000000000;;		for k, v := range np {
0000000000000000000000000000000000000000;;			if b.host2ep[k] != v {
0000000000000000000000000000000000000000;;				match = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if match {
0000000000000000000000000000000000000000;;			// same endpoints, so no need to update address
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.host2ep = np
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addrs := make([]grpc.Address, 0, len(eps))
0000000000000000000000000000000000000000;;		for i := range eps {
0000000000000000000000000000000000000000;;			addrs = append(addrs, grpc.Address{Addr: getHost(eps[i])})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.addrs = addrs
0000000000000000000000000000000000000000;;		b.notifyCh <- addrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) Up(addr grpc.Address) func(error) {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gRPC might call Up after it called Close. We add this check
0000000000000000000000000000000000000000;;		// to "fix" it up at application layer. Or our simplerBalancer
0000000000000000000000000000000000000000;;		// might panic since b.upc is closed.
0000000000000000000000000000000000000000;;		if b.closed {
0000000000000000000000000000000000000000;;			return func(err error) {}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(b.upEps) == 0 {
0000000000000000000000000000000000000000;;			// notify waiting Get()s and pin first connected address
0000000000000000000000000000000000000000;;			close(b.upc)
0000000000000000000000000000000000000000;;			b.pinAddr = addr.Addr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.upEps[addr.Addr] = struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// notify client that a connection is up
0000000000000000000000000000000000000000;;		b.readyOnce.Do(func() { close(b.readyc) })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return func(err error) {
0000000000000000000000000000000000000000;;			b.mu.Lock()
0000000000000000000000000000000000000000;;			delete(b.upEps, addr.Addr)
0000000000000000000000000000000000000000;;			if len(b.upEps) == 0 && b.pinAddr != "" {
0000000000000000000000000000000000000000;;				b.upc = make(chan struct{})
0000000000000000000000000000000000000000;;			} else if b.pinAddr == addr.Addr {
0000000000000000000000000000000000000000;;				// choose new random up endpoint
0000000000000000000000000000000000000000;;				for k := range b.upEps {
0000000000000000000000000000000000000000;;					b.pinAddr = k
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) Get(ctx context.Context, opts grpc.BalancerGetOptions) (grpc.Address, func(), error) {
0000000000000000000000000000000000000000;;		var addr string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If opts.BlockingWait is false (for fail-fast RPCs), it should return
0000000000000000000000000000000000000000;;		// an address it has notified via Notify immediately instead of blocking.
0000000000000000000000000000000000000000;;		if !opts.BlockingWait {
0000000000000000000000000000000000000000;;			b.mu.RLock()
0000000000000000000000000000000000000000;;			closed := b.closed
0000000000000000000000000000000000000000;;			addr = b.pinAddr
0000000000000000000000000000000000000000;;			upEps := len(b.upEps)
0000000000000000000000000000000000000000;;			b.mu.RUnlock()
0000000000000000000000000000000000000000;;			if closed {
0000000000000000000000000000000000000000;;				return grpc.Address{Addr: ""}, nil, grpc.ErrClientConnClosing
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if upEps == 0 {
0000000000000000000000000000000000000000;;				return grpc.Address{Addr: ""}, nil, ErrNoAddrAvilable
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return grpc.Address{Addr: addr}, func() {}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b.mu.RLock()
0000000000000000000000000000000000000000;;			ch := b.upc
0000000000000000000000000000000000000000;;			b.mu.RUnlock()
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ch:
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return grpc.Address{Addr: ""}, nil, ctx.Err()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.mu.RLock()
0000000000000000000000000000000000000000;;			addr = b.pinAddr
0000000000000000000000000000000000000000;;			upEps := len(b.upEps)
0000000000000000000000000000000000000000;;			b.mu.RUnlock()
0000000000000000000000000000000000000000;;			if addr == "" {
0000000000000000000000000000000000000000;;				return grpc.Address{Addr: ""}, nil, grpc.ErrClientConnClosing
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if upEps > 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return grpc.Address{Addr: addr}, func() {}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) Notify() <-chan []grpc.Address { return b.notifyCh }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *simpleBalancer) Close() error {
0000000000000000000000000000000000000000;;		b.mu.Lock()
0000000000000000000000000000000000000000;;		defer b.mu.Unlock()
0000000000000000000000000000000000000000;;		// In case gRPC calls close twice. TODO: remove the checking
0000000000000000000000000000000000000000;;		// when we are sure that gRPC wont call close twice.
0000000000000000000000000000000000000000;;		if b.closed {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.closed = true
0000000000000000000000000000000000000000;;		close(b.notifyCh)
0000000000000000000000000000000000000000;;		// terminate all waiting Get()s
0000000000000000000000000000000000000000;;		b.pinAddr = ""
0000000000000000000000000000000000000000;;		if len(b.upEps) == 0 {
0000000000000000000000000000000000000000;;			close(b.upc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getHost(ep string) string {
0000000000000000000000000000000000000000;;		url, uerr := url.Parse(ep)
0000000000000000000000000000000000000000;;		if uerr != nil || !strings.Contains(ep, "://") {
0000000000000000000000000000000000000000;;			return ep
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return url.Host
0000000000000000000000000000000000000000;;	}
