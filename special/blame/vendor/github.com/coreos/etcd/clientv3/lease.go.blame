0000000000000000000000000000000000000000;;	// Copyright 2016 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
9b11e90c65f84c704d29a1c6a5867d26fdba23c5;Godeps/_workspace/src/github.com/coreos/etcd/clientv3/lease.go[Godeps/_workspace/src/github.com/coreos/etcd/clientv3/lease.go][vendor/github.com/coreos/etcd/clientv3/lease.go];	
0000000000000000000000000000000000000000;;	package clientv3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/etcdserver/api/v3rpc/rpctypes"
0000000000000000000000000000000000000000;;		pb "github.com/coreos/etcd/etcdserver/etcdserverpb"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type (
0000000000000000000000000000000000000000;;		LeaseRevokeResponse pb.LeaseRevokeResponse
0000000000000000000000000000000000000000;;		LeaseID             int64
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeaseGrantResponse is used to convert the protobuf grant response.
0000000000000000000000000000000000000000;;	type LeaseGrantResponse struct {
0000000000000000000000000000000000000000;;		*pb.ResponseHeader
0000000000000000000000000000000000000000;;		ID    LeaseID
0000000000000000000000000000000000000000;;		TTL   int64
0000000000000000000000000000000000000000;;		Error string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeaseKeepAliveResponse is used to convert the protobuf keepalive response.
0000000000000000000000000000000000000000;;	type LeaseKeepAliveResponse struct {
0000000000000000000000000000000000000000;;		*pb.ResponseHeader
0000000000000000000000000000000000000000;;		ID  LeaseID
0000000000000000000000000000000000000000;;		TTL int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeaseTimeToLiveResponse is used to convert the protobuf lease timetolive response.
0000000000000000000000000000000000000000;;	type LeaseTimeToLiveResponse struct {
0000000000000000000000000000000000000000;;		*pb.ResponseHeader
0000000000000000000000000000000000000000;;		ID LeaseID `json:"id"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTL is the remaining TTL in seconds for the lease; the lease will expire in under TTL+1 seconds.
0000000000000000000000000000000000000000;;		TTL int64 `json:"ttl"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GrantedTTL is the initial granted time in seconds upon lease creation/renewal.
0000000000000000000000000000000000000000;;		GrantedTTL int64 `json:"granted-ttl"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Keys is the list of keys attached to this lease.
0000000000000000000000000000000000000000;;		Keys [][]byte `json:"keys"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// defaultTTL is the assumed lease TTL used for the first keepalive
0000000000000000000000000000000000000000;;		// deadline before the actual TTL is known to the client.
0000000000000000000000000000000000000000;;		defaultTTL = 5 * time.Second
0000000000000000000000000000000000000000;;		// a small buffer to store unsent lease responses.
0000000000000000000000000000000000000000;;		leaseResponseChSize = 16
0000000000000000000000000000000000000000;;		// NoLease is a lease ID for the absence of a lease.
0000000000000000000000000000000000000000;;		NoLease LeaseID = 0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrKeepAliveHalted is returned if client keep alive loop halts with an unexpected error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This usually means that automatic lease renewal via KeepAlive is broken, but KeepAliveOnce will still work as expected.
0000000000000000000000000000000000000000;;	type ErrKeepAliveHalted struct {
0000000000000000000000000000000000000000;;		Reason error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e ErrKeepAliveHalted) Error() string {
0000000000000000000000000000000000000000;;		s := "etcdclient: leases keep alive halted"
0000000000000000000000000000000000000000;;		if e.Reason != nil {
0000000000000000000000000000000000000000;;			s += ": " + e.Reason.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Lease interface {
0000000000000000000000000000000000000000;;		// Grant creates a new lease.
0000000000000000000000000000000000000000;;		Grant(ctx context.Context, ttl int64) (*LeaseGrantResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Revoke revokes the given lease.
0000000000000000000000000000000000000000;;		Revoke(ctx context.Context, id LeaseID) (*LeaseRevokeResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TimeToLive retrieves the lease information of the given lease ID.
0000000000000000000000000000000000000000;;		TimeToLive(ctx context.Context, id LeaseID, opts ...LeaseOption) (*LeaseTimeToLiveResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeepAlive keeps the given lease alive forever.
0000000000000000000000000000000000000000;;		KeepAlive(ctx context.Context, id LeaseID) (<-chan *LeaseKeepAliveResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeepAliveOnce renews the lease once. In most of the cases, Keepalive
0000000000000000000000000000000000000000;;		// should be used instead of KeepAliveOnce.
0000000000000000000000000000000000000000;;		KeepAliveOnce(ctx context.Context, id LeaseID) (*LeaseKeepAliveResponse, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close releases all resources Lease keeps for efficient communication
0000000000000000000000000000000000000000;;		// with the etcd server.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lessor struct {
0000000000000000000000000000000000000000;;		mu sync.Mutex // guards all fields
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// donec is closed and loopErr is set when recvKeepAliveLoop stops
0000000000000000000000000000000000000000;;		donec   chan struct{}
0000000000000000000000000000000000000000;;		loopErr error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		remote pb.LeaseClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream       pb.Lease_LeaseKeepAliveClient
0000000000000000000000000000000000000000;;		streamCancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stopCtx    context.Context
0000000000000000000000000000000000000000;;		stopCancel context.CancelFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keepAlives map[LeaseID]*keepAlive
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// firstKeepAliveTimeout is the timeout for the first keepalive request
0000000000000000000000000000000000000000;;		// before the actual TTL is known to the lease client
0000000000000000000000000000000000000000;;		firstKeepAliveTimeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keepAlive multiplexes a keepalive for a lease over multiple channels
0000000000000000000000000000000000000000;;	type keepAlive struct {
0000000000000000000000000000000000000000;;		chs  []chan<- *LeaseKeepAliveResponse
0000000000000000000000000000000000000000;;		ctxs []context.Context
0000000000000000000000000000000000000000;;		// deadline is the time the keep alive channels close if no response
0000000000000000000000000000000000000000;;		deadline time.Time
0000000000000000000000000000000000000000;;		// nextKeepAlive is when to send the next keep alive message
0000000000000000000000000000000000000000;;		nextKeepAlive time.Time
0000000000000000000000000000000000000000;;		// donec is closed on lease revoke, expiration, or cancel.
0000000000000000000000000000000000000000;;		donec chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewLease(c *Client) Lease {
0000000000000000000000000000000000000000;;		l := &lessor{
0000000000000000000000000000000000000000;;			donec:                 make(chan struct{}),
0000000000000000000000000000000000000000;;			keepAlives:            make(map[LeaseID]*keepAlive),
0000000000000000000000000000000000000000;;			remote:                RetryLeaseClient(c),
0000000000000000000000000000000000000000;;			firstKeepAliveTimeout: c.cfg.DialTimeout + time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.firstKeepAliveTimeout == time.Second {
0000000000000000000000000000000000000000;;			l.firstKeepAliveTimeout = defaultTTL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.stopCtx, l.stopCancel = context.WithCancel(context.Background())
0000000000000000000000000000000000000000;;		go l.recvKeepAliveLoop()
0000000000000000000000000000000000000000;;		go l.deadlineLoop()
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) Grant(ctx context.Context, ttl int64) (*LeaseGrantResponse, error) {
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		done := cancelWhenStop(cancel, l.stopCtx.Done())
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r := &pb.LeaseGrantRequest{TTL: ttl}
0000000000000000000000000000000000000000;;			resp, err := l.remote.LeaseGrant(cctx, r)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				gresp := &LeaseGrantResponse{
0000000000000000000000000000000000000000;;					ResponseHeader: resp.GetHeader(),
0000000000000000000000000000000000000000;;					ID:             LeaseID(resp.ID),
0000000000000000000000000000000000000000;;					TTL:            resp.TTL,
0000000000000000000000000000000000000000;;					Error:          resp.Error,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return gresp, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHaltErr(cctx, err) {
0000000000000000000000000000000000000000;;				return nil, toErr(cctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) Revoke(ctx context.Context, id LeaseID) (*LeaseRevokeResponse, error) {
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		done := cancelWhenStop(cancel, l.stopCtx.Done())
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r := &pb.LeaseRevokeRequest{ID: int64(id)}
0000000000000000000000000000000000000000;;			resp, err := l.remote.LeaseRevoke(cctx, r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return (*LeaseRevokeResponse)(resp), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHaltErr(ctx, err) {
0000000000000000000000000000000000000000;;				return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) TimeToLive(ctx context.Context, id LeaseID, opts ...LeaseOption) (*LeaseTimeToLiveResponse, error) {
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		done := cancelWhenStop(cancel, l.stopCtx.Done())
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			r := toLeaseTimeToLiveRequest(id, opts...)
0000000000000000000000000000000000000000;;			resp, err := l.remote.LeaseTimeToLive(cctx, r, grpc.FailFast(false))
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				gresp := &LeaseTimeToLiveResponse{
0000000000000000000000000000000000000000;;					ResponseHeader: resp.GetHeader(),
0000000000000000000000000000000000000000;;					ID:             LeaseID(resp.ID),
0000000000000000000000000000000000000000;;					TTL:            resp.TTL,
0000000000000000000000000000000000000000;;					GrantedTTL:     resp.GrantedTTL,
0000000000000000000000000000000000000000;;					Keys:           resp.Keys,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return gresp, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHaltErr(cctx, err) {
0000000000000000000000000000000000000000;;				return nil, toErr(cctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) KeepAlive(ctx context.Context, id LeaseID) (<-chan *LeaseKeepAliveResponse, error) {
0000000000000000000000000000000000000000;;		ch := make(chan *LeaseKeepAliveResponse, leaseResponseChSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		// ensure that recvKeepAliveLoop is still running
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-l.donec:
0000000000000000000000000000000000000000;;			err := l.loopErr
0000000000000000000000000000000000000000;;			l.mu.Unlock()
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;			return ch, ErrKeepAliveHalted{Reason: err}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ka, ok := l.keepAlives[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// create fresh keep alive
0000000000000000000000000000000000000000;;			ka = &keepAlive{
0000000000000000000000000000000000000000;;				chs:           []chan<- *LeaseKeepAliveResponse{ch},
0000000000000000000000000000000000000000;;				ctxs:          []context.Context{ctx},
0000000000000000000000000000000000000000;;				deadline:      time.Now().Add(l.firstKeepAliveTimeout),
0000000000000000000000000000000000000000;;				nextKeepAlive: time.Now(),
0000000000000000000000000000000000000000;;				donec:         make(chan struct{}),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.keepAlives[id] = ka
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// add channel and context to existing keep alive
0000000000000000000000000000000000000000;;			ka.ctxs = append(ka.ctxs, ctx)
0000000000000000000000000000000000000000;;			ka.chs = append(ka.chs, ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go l.keepAliveCtxCloser(id, ctx, ka.donec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) KeepAliveOnce(ctx context.Context, id LeaseID) (*LeaseKeepAliveResponse, error) {
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		done := cancelWhenStop(cancel, l.stopCtx.Done())
0000000000000000000000000000000000000000;;		defer close(done)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resp, err := l.keepAliveOnce(cctx, id)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				if resp.TTL == 0 {
0000000000000000000000000000000000000000;;					err = rpctypes.ErrLeaseNotFound
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return resp, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isHaltErr(ctx, err) {
0000000000000000000000000000000000000000;;				return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) Close() error {
0000000000000000000000000000000000000000;;		l.stopCancel()
0000000000000000000000000000000000000000;;		<-l.donec
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) keepAliveCtxCloser(id LeaseID, ctx context.Context, donec <-chan struct{}) {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-donec:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case <-l.donec:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		defer l.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ka, ok := l.keepAlives[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// close channel and remove context if still associated with keep alive
0000000000000000000000000000000000000000;;		for i, c := range ka.ctxs {
0000000000000000000000000000000000000000;;			if c == ctx {
0000000000000000000000000000000000000000;;				close(ka.chs[i])
0000000000000000000000000000000000000000;;				ka.ctxs = append(ka.ctxs[:i], ka.ctxs[i+1:]...)
0000000000000000000000000000000000000000;;				ka.chs = append(ka.chs[:i], ka.chs[i+1:]...)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// remove if no one more listeners
0000000000000000000000000000000000000000;;		if len(ka.chs) == 0 {
0000000000000000000000000000000000000000;;			delete(l.keepAlives, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) keepAliveOnce(ctx context.Context, id LeaseID) (*LeaseKeepAliveResponse, error) {
0000000000000000000000000000000000000000;;		cctx, cancel := context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		defer cancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream, err := l.remote.LeaseKeepAlive(cctx, grpc.FailFast(false))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = stream.Send(&pb.LeaseKeepAliveRequest{ID: int64(id)})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, rerr := stream.Recv()
0000000000000000000000000000000000000000;;		if rerr != nil {
0000000000000000000000000000000000000000;;			return nil, toErr(ctx, rerr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		karesp := &LeaseKeepAliveResponse{
0000000000000000000000000000000000000000;;			ResponseHeader: resp.GetHeader(),
0000000000000000000000000000000000000000;;			ID:             LeaseID(resp.ID),
0000000000000000000000000000000000000000;;			TTL:            resp.TTL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return karesp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *lessor) recvKeepAliveLoop() (gerr error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			l.mu.Lock()
0000000000000000000000000000000000000000;;			close(l.donec)
0000000000000000000000000000000000000000;;			l.loopErr = gerr
0000000000000000000000000000000000000000;;			for _, ka := range l.keepAlives {
0000000000000000000000000000000000000000;;				ka.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.keepAlives = make(map[LeaseID]*keepAlive)
0000000000000000000000000000000000000000;;			l.mu.Unlock()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stream, serr := l.resetRecv()
0000000000000000000000000000000000000000;;		for serr == nil {
0000000000000000000000000000000000000000;;			resp, err := stream.Recv()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if isHaltErr(l.stopCtx, err) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stream, serr = l.resetRecv()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.recvKeepAlive(resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return serr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resetRecv opens a new lease stream and starts sending LeaseKeepAliveRequests
0000000000000000000000000000000000000000;;	func (l *lessor) resetRecv() (pb.Lease_LeaseKeepAliveClient, error) {
0000000000000000000000000000000000000000;;		sctx, cancel := context.WithCancel(l.stopCtx)
0000000000000000000000000000000000000000;;		stream, err := l.remote.LeaseKeepAlive(sctx, grpc.FailFast(false))
0000000000000000000000000000000000000000;;		if err = toErr(sctx, err); err != nil {
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		defer l.mu.Unlock()
0000000000000000000000000000000000000000;;		if l.stream != nil && l.streamCancel != nil {
0000000000000000000000000000000000000000;;			l.stream.CloseSend()
0000000000000000000000000000000000000000;;			l.streamCancel()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.streamCancel = cancel
0000000000000000000000000000000000000000;;		l.stream = stream
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go l.sendKeepAliveLoop(stream)
0000000000000000000000000000000000000000;;		return stream, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recvKeepAlive updates a lease based on its LeaseKeepAliveResponse
0000000000000000000000000000000000000000;;	func (l *lessor) recvKeepAlive(resp *pb.LeaseKeepAliveResponse) {
0000000000000000000000000000000000000000;;		karesp := &LeaseKeepAliveResponse{
0000000000000000000000000000000000000000;;			ResponseHeader: resp.GetHeader(),
0000000000000000000000000000000000000000;;			ID:             LeaseID(resp.ID),
0000000000000000000000000000000000000000;;			TTL:            resp.TTL,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.mu.Lock()
0000000000000000000000000000000000000000;;		defer l.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ka, ok := l.keepAlives[karesp.ID]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if karesp.TTL <= 0 {
0000000000000000000000000000000000000000;;			// lease expired; close all keep alive channels
0000000000000000000000000000000000000000;;			delete(l.keepAlives, karesp.ID)
0000000000000000000000000000000000000000;;			ka.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// send update to all channels
0000000000000000000000000000000000000000;;		nextKeepAlive := time.Now().Add((time.Duration(karesp.TTL) * time.Second) / 3.0)
0000000000000000000000000000000000000000;;		ka.deadline = time.Now().Add(time.Duration(karesp.TTL) * time.Second)
0000000000000000000000000000000000000000;;		for _, ch := range ka.chs {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case ch <- karesp:
0000000000000000000000000000000000000000;;				ka.nextKeepAlive = nextKeepAlive
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deadlineLoop reaps any keep alive channels that have not received a response
0000000000000000000000000000000000000000;;	// within the lease TTL
0000000000000000000000000000000000000000;;	func (l *lessor) deadlineLoop() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(time.Second):
0000000000000000000000000000000000000000;;			case <-l.donec:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			l.mu.Lock()
0000000000000000000000000000000000000000;;			for id, ka := range l.keepAlives {
0000000000000000000000000000000000000000;;				if ka.deadline.Before(now) {
0000000000000000000000000000000000000000;;					// waited too long for response; lease may be expired
0000000000000000000000000000000000000000;;					ka.Close()
0000000000000000000000000000000000000000;;					delete(l.keepAlives, id)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.mu.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sendKeepAliveLoop sends LeaseKeepAliveRequests for the lifetime of a lease stream
0000000000000000000000000000000000000000;;	func (l *lessor) sendKeepAliveLoop(stream pb.Lease_LeaseKeepAliveClient) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-time.After(500 * time.Millisecond):
0000000000000000000000000000000000000000;;			case <-stream.Context().Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-l.donec:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-l.stopCtx.Done():
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var tosend []LeaseID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			l.mu.Lock()
0000000000000000000000000000000000000000;;			for id, ka := range l.keepAlives {
0000000000000000000000000000000000000000;;				if ka.nextKeepAlive.Before(now) {
0000000000000000000000000000000000000000;;					tosend = append(tosend, id)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, id := range tosend {
0000000000000000000000000000000000000000;;				r := &pb.LeaseKeepAliveRequest{ID: int64(id)}
0000000000000000000000000000000000000000;;				if err := stream.Send(r); err != nil {
0000000000000000000000000000000000000000;;					// TODO do something with this error?
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ka *keepAlive) Close() {
0000000000000000000000000000000000000000;;		close(ka.donec)
0000000000000000000000000000000000000000;;		for _, ch := range ka.chs {
0000000000000000000000000000000000000000;;			close(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cancelWhenStop calls cancel when the given stopc fires. It returns a done chan. done
0000000000000000000000000000000000000000;;	// should be closed when the work is finished. When done fires, cancelWhenStop will release
0000000000000000000000000000000000000000;;	// its internal resource.
0000000000000000000000000000000000000000;;	func cancelWhenStop(cancel context.CancelFunc, stopc <-chan struct{}) chan<- struct{} {
0000000000000000000000000000000000000000;;		done := make(chan struct{}, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-stopc:
0000000000000000000000000000000000000000;;			case <-done:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cancel()
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return done
0000000000000000000000000000000000000000;;	}
