0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/client/client.go[Godeps/_workspace/src/github.com/coreos/etcd/client/client.go][vendor/github.com/coreos/etcd/client/client.go];	
0000000000000000000000000000000000000000;;	package client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrNoEndpoints           = errors.New("client: no endpoints available")
0000000000000000000000000000000000000000;;		ErrTooManyRedirects      = errors.New("client: too many redirects")
0000000000000000000000000000000000000000;;		ErrClusterUnavailable    = errors.New("client: etcd cluster is unavailable or misconfigured")
0000000000000000000000000000000000000000;;		ErrNoLeaderEndpoint      = errors.New("client: no leader endpoint available")
0000000000000000000000000000000000000000;;		errTooManyRedirectChecks = errors.New("client: too many redirect checks")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// oneShotCtxValue is set on a context using WithValue(&oneShotValue) so
0000000000000000000000000000000000000000;;		// that Do() will not retry a request
0000000000000000000000000000000000000000;;		oneShotCtxValue interface{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DefaultRequestTimeout = 5 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DefaultTransport CancelableTransport = &http.Transport{
0000000000000000000000000000000000000000;;		Proxy: http.ProxyFromEnvironment,
0000000000000000000000000000000000000000;;		Dial: (&net.Dialer{
0000000000000000000000000000000000000000;;			Timeout:   30 * time.Second,
0000000000000000000000000000000000000000;;			KeepAlive: 30 * time.Second,
0000000000000000000000000000000000000000;;		}).Dial,
0000000000000000000000000000000000000000;;		TLSHandshakeTimeout: 10 * time.Second,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EndpointSelectionMode int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// EndpointSelectionRandom is the default value of the 'SelectionMode'.
0000000000000000000000000000000000000000;;		// As the name implies, the client object will pick a node from the members
0000000000000000000000000000000000000000;;		// of the cluster in a random fashion. If the cluster has three members, A, B,
0000000000000000000000000000000000000000;;		// and C, the client picks any node from its three members as its request
0000000000000000000000000000000000000000;;		// destination.
0000000000000000000000000000000000000000;;		EndpointSelectionRandom EndpointSelectionMode = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If 'SelectionMode' is set to 'EndpointSelectionPrioritizeLeader',
0000000000000000000000000000000000000000;;		// requests are sent directly to the cluster leader. This reduces
0000000000000000000000000000000000000000;;		// forwarding roundtrips compared to making requests to etcd followers
0000000000000000000000000000000000000000;;		// who then forward them to the cluster leader. In the event of a leader
0000000000000000000000000000000000000000;;		// failure, however, clients configured this way cannot prioritize among
0000000000000000000000000000000000000000;;		// the remaining etcd followers. Therefore, when a client sets 'SelectionMode'
0000000000000000000000000000000000000000;;		// to 'EndpointSelectionPrioritizeLeader', it must use 'client.AutoSync()' to
0000000000000000000000000000000000000000;;		// maintain its knowledge of current cluster state.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This mode should be used with Client.AutoSync().
0000000000000000000000000000000000000000;;		EndpointSelectionPrioritizeLeader
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// Endpoints defines a set of URLs (schemes, hosts and ports only)
0000000000000000000000000000000000000000;;		// that can be used to communicate with a logical etcd cluster. For
0000000000000000000000000000000000000000;;		// example, a three-node cluster could be provided like so:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	Endpoints: []string{
0000000000000000000000000000000000000000;;		//		"http://node1.example.com:2379",
0000000000000000000000000000000000000000;;		//		"http://node2.example.com:2379",
0000000000000000000000000000000000000000;;		//		"http://node3.example.com:2379",
0000000000000000000000000000000000000000;;		//	}
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If multiple endpoints are provided, the Client will attempt to
0000000000000000000000000000000000000000;;		// use them all in the event that one or more of them are unusable.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If Client.Sync is ever called, the Client may cache an alternate
0000000000000000000000000000000000000000;;		// set of endpoints to continue operation.
0000000000000000000000000000000000000000;;		Endpoints []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Transport is used by the Client to drive HTTP requests. If not
0000000000000000000000000000000000000000;;		// provided, DefaultTransport will be used.
0000000000000000000000000000000000000000;;		Transport CancelableTransport
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CheckRedirect specifies the policy for handling HTTP redirects.
0000000000000000000000000000000000000000;;		// If CheckRedirect is not nil, the Client calls it before
0000000000000000000000000000000000000000;;		// following an HTTP redirect. The sole argument is the number of
0000000000000000000000000000000000000000;;		// requests that have already been made. If CheckRedirect returns
0000000000000000000000000000000000000000;;		// an error, Client.Do will not make any further requests and return
0000000000000000000000000000000000000000;;		// the error back it to the caller.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If CheckRedirect is nil, the Client uses its default policy,
0000000000000000000000000000000000000000;;		// which is to stop after 10 consecutive requests.
0000000000000000000000000000000000000000;;		CheckRedirect CheckRedirectFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Username specifies the user credential to add as an authorization header
0000000000000000000000000000000000000000;;		Username string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Password is the password for the specified user to add as an authorization header
0000000000000000000000000000000000000000;;		// to the request.
0000000000000000000000000000000000000000;;		Password string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HeaderTimeoutPerRequest specifies the time limit to wait for response
0000000000000000000000000000000000000000;;		// header in a single request made by the Client. The timeout includes
0000000000000000000000000000000000000000;;		// connection time, any redirects, and header wait time.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// For non-watch GET request, server returns the response body immediately.
0000000000000000000000000000000000000000;;		// For PUT/POST/DELETE request, server will attempt to commit request
0000000000000000000000000000000000000000;;		// before responding, which is expected to take `100ms + 2 * RTT`.
0000000000000000000000000000000000000000;;		// For watch request, server returns the header immediately to notify Client
0000000000000000000000000000000000000000;;		// watch start. But if server is behind some kind of proxy, the response
0000000000000000000000000000000000000000;;		// header may be cached at proxy, and Client cannot rely on this behavior.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Especially, wait request will ignore this timeout.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// One API call may send multiple requests to different etcd servers until it
0000000000000000000000000000000000000000;;		// succeeds. Use context of the API to specify the overall timeout.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A HeaderTimeoutPerRequest of zero means no timeout.
0000000000000000000000000000000000000000;;		HeaderTimeoutPerRequest time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SelectionMode is an EndpointSelectionMode enum that specifies the
0000000000000000000000000000000000000000;;		// policy for choosing the etcd cluster node to which requests are sent.
0000000000000000000000000000000000000000;;		SelectionMode EndpointSelectionMode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cfg *Config) transport() CancelableTransport {
0000000000000000000000000000000000000000;;		if cfg.Transport == nil {
0000000000000000000000000000000000000000;;			return DefaultTransport
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg.Transport
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cfg *Config) checkRedirect() CheckRedirectFunc {
0000000000000000000000000000000000000000;;		if cfg.CheckRedirect == nil {
0000000000000000000000000000000000000000;;			return DefaultCheckRedirect
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cfg.CheckRedirect
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CancelableTransport mimics net/http.Transport, but requires that
0000000000000000000000000000000000000000;;	// the object also support request cancellation.
0000000000000000000000000000000000000000;;	type CancelableTransport interface {
0000000000000000000000000000000000000000;;		http.RoundTripper
0000000000000000000000000000000000000000;;		CancelRequest(req *http.Request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CheckRedirectFunc func(via int) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultCheckRedirect follows up to 10 redirects, but no more.
0000000000000000000000000000000000000000;;	var DefaultCheckRedirect CheckRedirectFunc = func(via int) error {
0000000000000000000000000000000000000000;;		if via > 10 {
0000000000000000000000000000000000000000;;			return ErrTooManyRedirects
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Client interface {
0000000000000000000000000000000000000000;;		// Sync updates the internal cache of the etcd cluster's membership.
0000000000000000000000000000000000000000;;		Sync(context.Context) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AutoSync periodically calls Sync() every given interval.
0000000000000000000000000000000000000000;;		// The recommended sync interval is 10 seconds to 1 minute, which does
0000000000000000000000000000000000000000;;		// not bring too much overhead to server and makes client catch up the
0000000000000000000000000000000000000000;;		// cluster change in time.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The example to use it:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//  for {
0000000000000000000000000000000000000000;;		//      err := client.AutoSync(ctx, 10*time.Second)
0000000000000000000000000000000000000000;;		//      if err == context.DeadlineExceeded || err == context.Canceled {
0000000000000000000000000000000000000000;;		//          break
0000000000000000000000000000000000000000;;		//      }
0000000000000000000000000000000000000000;;		//      log.Print(err)
0000000000000000000000000000000000000000;;		//  }
0000000000000000000000000000000000000000;;		AutoSync(context.Context, time.Duration) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Endpoints returns a copy of the current set of API endpoints used
0000000000000000000000000000000000000000;;		// by Client to resolve HTTP requests. If Sync has ever been called,
0000000000000000000000000000000000000000;;		// this may differ from the initial Endpoints provided in the Config.
0000000000000000000000000000000000000000;;		Endpoints() []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetEndpoints sets the set of API endpoints used by Client to resolve
0000000000000000000000000000000000000000;;		// HTTP requests. If the given endpoints are not valid, an error will be
0000000000000000000000000000000000000000;;		// returned
0000000000000000000000000000000000000000;;		SetEndpoints(eps []string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		httpClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(cfg Config) (Client, error) {
0000000000000000000000000000000000000000;;		c := &httpClusterClient{
0000000000000000000000000000000000000000;;			clientFactory: newHTTPClientFactory(cfg.transport(), cfg.checkRedirect(), cfg.HeaderTimeoutPerRequest),
0000000000000000000000000000000000000000;;			rand:          rand.New(rand.NewSource(int64(time.Now().Nanosecond()))),
0000000000000000000000000000000000000000;;			selectionMode: cfg.SelectionMode,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cfg.Username != "" {
0000000000000000000000000000000000000000;;			c.credentials = &credentials{
0000000000000000000000000000000000000000;;				username: cfg.Username,
0000000000000000000000000000000000000000;;				password: cfg.Password,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.SetEndpoints(cfg.Endpoints); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpClient interface {
0000000000000000000000000000000000000000;;		Do(context.Context, httpAction) (*http.Response, []byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newHTTPClientFactory(tr CancelableTransport, cr CheckRedirectFunc, headerTimeout time.Duration) httpClientFactory {
0000000000000000000000000000000000000000;;		return func(ep url.URL) httpClient {
0000000000000000000000000000000000000000;;			return &redirectFollowingHTTPClient{
0000000000000000000000000000000000000000;;				checkRedirect: cr,
0000000000000000000000000000000000000000;;				client: &simpleHTTPClient{
0000000000000000000000000000000000000000;;					transport:     tr,
0000000000000000000000000000000000000000;;					endpoint:      ep,
0000000000000000000000000000000000000000;;					headerTimeout: headerTimeout,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type credentials struct {
0000000000000000000000000000000000000000;;		username string
0000000000000000000000000000000000000000;;		password string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpClientFactory func(url.URL) httpClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpAction interface {
0000000000000000000000000000000000000000;;		HTTPRequest(url.URL) *http.Request
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpClusterClient struct {
0000000000000000000000000000000000000000;;		clientFactory httpClientFactory
0000000000000000000000000000000000000000;;		endpoints     []url.URL
0000000000000000000000000000000000000000;;		pinned        int
0000000000000000000000000000000000000000;;		credentials   *credentials
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		rand          *rand.Rand
0000000000000000000000000000000000000000;;		selectionMode EndpointSelectionMode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *httpClusterClient) getLeaderEndpoint(ctx context.Context, eps []url.URL) (string, error) {
0000000000000000000000000000000000000000;;		ceps := make([]url.URL, len(eps))
0000000000000000000000000000000000000000;;		copy(ceps, eps)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// To perform a lookup on the new endpoint list without using the current
0000000000000000000000000000000000000000;;		// client, we'll copy it
0000000000000000000000000000000000000000;;		clientCopy := &httpClusterClient{
0000000000000000000000000000000000000000;;			clientFactory: c.clientFactory,
0000000000000000000000000000000000000000;;			credentials:   c.credentials,
0000000000000000000000000000000000000000;;			rand:          c.rand,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pinned:    0,
0000000000000000000000000000000000000000;;			endpoints: ceps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mAPI := NewMembersAPI(clientCopy)
0000000000000000000000000000000000000000;;		leader, err := mAPI.Leader(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(leader.ClientURLs) == 0 {
0000000000000000000000000000000000000000;;			return "", ErrNoLeaderEndpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return leader.ClientURLs[0], nil // TODO: how to handle multiple client URLs?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *httpClusterClient) parseEndpoints(eps []string) ([]url.URL, error) {
0000000000000000000000000000000000000000;;		if len(eps) == 0 {
0000000000000000000000000000000000000000;;			return []url.URL{}, ErrNoEndpoints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		neps := make([]url.URL, len(eps))
0000000000000000000000000000000000000000;;		for i, ep := range eps {
0000000000000000000000000000000000000000;;			u, err := url.Parse(ep)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return []url.URL{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			neps[i] = *u
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return neps, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *httpClusterClient) SetEndpoints(eps []string) error {
0000000000000000000000000000000000000000;;		neps, err := c.parseEndpoints(eps)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.endpoints = shuffleEndpoints(c.rand, neps)
0000000000000000000000000000000000000000;;		// We're not doing anything for PrioritizeLeader here. This is
0000000000000000000000000000000000000000;;		// due to not having a context meaning we can't call getLeaderEndpoint
0000000000000000000000000000000000000000;;		// However, if you're using PrioritizeLeader, you've already been told
0000000000000000000000000000000000000000;;		// to regularly call sync, where we do have a ctx, and can figure the
0000000000000000000000000000000000000000;;		// leader. PrioritizeLeader is also quite a loose guarantee, so deal
0000000000000000000000000000000000000000;;		// with it
0000000000000000000000000000000000000000;;		c.pinned = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *httpClusterClient) Do(ctx context.Context, act httpAction) (*http.Response, []byte, error) {
0000000000000000000000000000000000000000;;		action := act
0000000000000000000000000000000000000000;;		c.RLock()
0000000000000000000000000000000000000000;;		leps := len(c.endpoints)
0000000000000000000000000000000000000000;;		eps := make([]url.URL, leps)
0000000000000000000000000000000000000000;;		n := copy(eps, c.endpoints)
0000000000000000000000000000000000000000;;		pinned := c.pinned
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.credentials != nil {
0000000000000000000000000000000000000000;;			action = &authedAction{
0000000000000000000000000000000000000000;;				act:         act,
0000000000000000000000000000000000000000;;				credentials: *c.credentials,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if leps == 0 {
0000000000000000000000000000000000000000;;			return nil, nil, ErrNoEndpoints
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if leps != n {
0000000000000000000000000000000000000000;;			return nil, nil, errors.New("unable to pick endpoint: copy failed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp *http.Response
0000000000000000000000000000000000000000;;		var body []byte
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		cerr := &ClusterError{}
0000000000000000000000000000000000000000;;		isOneShot := ctx.Value(&oneShotCtxValue) != nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := pinned; i < leps+pinned; i++ {
0000000000000000000000000000000000000000;;			k := i % leps
0000000000000000000000000000000000000000;;			hc := c.clientFactory(eps[k])
0000000000000000000000000000000000000000;;			resp, body, err = hc.Do(ctx, action)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				cerr.Errors = append(cerr.Errors, err)
0000000000000000000000000000000000000000;;				if err == ctx.Err() {
0000000000000000000000000000000000000000;;					return nil, nil, ctx.Err()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err == context.Canceled || err == context.DeadlineExceeded {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isOneShot {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode/100 == 5 {
0000000000000000000000000000000000000000;;				switch resp.StatusCode {
0000000000000000000000000000000000000000;;				case http.StatusInternalServerError, http.StatusServiceUnavailable:
0000000000000000000000000000000000000000;;					// TODO: make sure this is a no leader response
0000000000000000000000000000000000000000;;					cerr.Errors = append(cerr.Errors, fmt.Errorf("client: etcd member %s has no leader", eps[k].String()))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					cerr.Errors = append(cerr.Errors, fmt.Errorf("client: etcd member %s returns server error [%s]", eps[k].String(), http.StatusText(resp.StatusCode)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isOneShot {
0000000000000000000000000000000000000000;;					return nil, nil, cerr.Errors[0]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if k != pinned {
0000000000000000000000000000000000000000;;				c.Lock()
0000000000000000000000000000000000000000;;				c.pinned = k
0000000000000000000000000000000000000000;;				c.Unlock()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, body, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil, cerr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *httpClusterClient) Endpoints() []string {
0000000000000000000000000000000000000000;;		c.RLock()
0000000000000000000000000000000000000000;;		defer c.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		eps := make([]string, len(c.endpoints))
0000000000000000000000000000000000000000;;		for i, ep := range c.endpoints {
0000000000000000000000000000000000000000;;			eps[i] = ep.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return eps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *httpClusterClient) Sync(ctx context.Context) error {
0000000000000000000000000000000000000000;;		mAPI := NewMembersAPI(c)
0000000000000000000000000000000000000000;;		ms, err := mAPI.List(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var eps []string
0000000000000000000000000000000000000000;;		for _, m := range ms {
0000000000000000000000000000000000000000;;			eps = append(eps, m.ClientURLs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		neps, err := c.parseEndpoints(eps)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		npin := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c.selectionMode {
0000000000000000000000000000000000000000;;		case EndpointSelectionRandom:
0000000000000000000000000000000000000000;;			c.RLock()
0000000000000000000000000000000000000000;;			eq := endpointsEqual(c.endpoints, neps)
0000000000000000000000000000000000000000;;			c.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if eq {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// When items in the endpoint list changes, we choose a new pin
0000000000000000000000000000000000000000;;			neps = shuffleEndpoints(c.rand, neps)
0000000000000000000000000000000000000000;;		case EndpointSelectionPrioritizeLeader:
0000000000000000000000000000000000000000;;			nle, err := c.getLeaderEndpoint(ctx, neps)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return ErrNoLeaderEndpoint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, n := range neps {
0000000000000000000000000000000000000000;;				if n.String() == nle {
0000000000000000000000000000000000000000;;					npin = i
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid endpoint selection mode: %d", c.selectionMode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		c.endpoints = neps
0000000000000000000000000000000000000000;;		c.pinned = npin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *httpClusterClient) AutoSync(ctx context.Context, interval time.Duration) error {
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(interval)
0000000000000000000000000000000000000000;;		defer ticker.Stop()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			err := c.Sync(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return ctx.Err()
0000000000000000000000000000000000000000;;			case <-ticker.C:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type roundTripResponse struct {
0000000000000000000000000000000000000000;;		resp *http.Response
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleHTTPClient struct {
0000000000000000000000000000000000000000;;		transport     CancelableTransport
0000000000000000000000000000000000000000;;		endpoint      url.URL
0000000000000000000000000000000000000000;;		headerTimeout time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *simpleHTTPClient) Do(ctx context.Context, act httpAction) (*http.Response, []byte, error) {
0000000000000000000000000000000000000000;;		req := act.HTTPRequest(c.endpoint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := printcURL(req); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isWait := false
0000000000000000000000000000000000000000;;		if req != nil && req.URL != nil {
0000000000000000000000000000000000000000;;			ws := req.URL.Query().Get("wait")
0000000000000000000000000000000000000000;;			if len(ws) != 0 {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				isWait, err = strconv.ParseBool(ws)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("wrong wait value %s (%v for %+v)", ws, err, req)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hctx context.Context
0000000000000000000000000000000000000000;;		var hcancel context.CancelFunc
0000000000000000000000000000000000000000;;		if !isWait && c.headerTimeout > 0 {
0000000000000000000000000000000000000000;;			hctx, hcancel = context.WithTimeout(ctx, c.headerTimeout)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			hctx, hcancel = context.WithCancel(ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer hcancel()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqcancel := requestCanceler(c.transport, req)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rtchan := make(chan roundTripResponse, 1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			resp, err := c.transport.RoundTrip(req)
0000000000000000000000000000000000000000;;			rtchan <- roundTripResponse{resp: resp, err: err}
0000000000000000000000000000000000000000;;			close(rtchan)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp *http.Response
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case rtresp := <-rtchan:
0000000000000000000000000000000000000000;;			resp, err = rtresp.resp, rtresp.err
0000000000000000000000000000000000000000;;		case <-hctx.Done():
0000000000000000000000000000000000000000;;			// cancel and wait for request to actually exit before continuing
0000000000000000000000000000000000000000;;			reqcancel()
0000000000000000000000000000000000000000;;			rtresp := <-rtchan
0000000000000000000000000000000000000000;;			resp = rtresp.resp
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case ctx.Err() != nil:
0000000000000000000000000000000000000000;;				err = ctx.Err()
0000000000000000000000000000000000000000;;			case hctx.Err() != nil:
0000000000000000000000000000000000000000;;				err = fmt.Errorf("client: endpoint %s exceeded header timeout", c.endpoint.String())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("failed to get error from context")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// always check for resp nil-ness to deal with possible
0000000000000000000000000000000000000000;;		// race conditions between channels above
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if resp != nil {
0000000000000000000000000000000000000000;;				resp.Body.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var body []byte
0000000000000000000000000000000000000000;;		done := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			body, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			done <- struct{}{}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-ctx.Done():
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;			<-done
0000000000000000000000000000000000000000;;			return nil, nil, ctx.Err()
0000000000000000000000000000000000000000;;		case <-done:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp, body, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type authedAction struct {
0000000000000000000000000000000000000000;;		act         httpAction
0000000000000000000000000000000000000000;;		credentials credentials
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *authedAction) HTTPRequest(url url.URL) *http.Request {
0000000000000000000000000000000000000000;;		r := a.act.HTTPRequest(url)
0000000000000000000000000000000000000000;;		r.SetBasicAuth(a.credentials.username, a.credentials.password)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type redirectFollowingHTTPClient struct {
0000000000000000000000000000000000000000;;		client        httpClient
0000000000000000000000000000000000000000;;		checkRedirect CheckRedirectFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *redirectFollowingHTTPClient) Do(ctx context.Context, act httpAction) (*http.Response, []byte, error) {
0000000000000000000000000000000000000000;;		next := act
0000000000000000000000000000000000000000;;		for i := 0; i < 100; i++ {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				if err := r.checkRedirect(i); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp, body, err := r.client.Do(ctx, next)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if resp.StatusCode/100 == 3 {
0000000000000000000000000000000000000000;;				hdr := resp.Header.Get("Location")
0000000000000000000000000000000000000000;;				if hdr == "" {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("Location header not set")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				loc, err := url.Parse(hdr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, fmt.Errorf("Location header not valid URL: %s", hdr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				next = &redirectedHTTPAction{
0000000000000000000000000000000000000000;;					action:   act,
0000000000000000000000000000000000000000;;					location: *loc,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return resp, body, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil, errTooManyRedirectChecks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type redirectedHTTPAction struct {
0000000000000000000000000000000000000000;;		action   httpAction
0000000000000000000000000000000000000000;;		location url.URL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *redirectedHTTPAction) HTTPRequest(ep url.URL) *http.Request {
0000000000000000000000000000000000000000;;		orig := r.action.HTTPRequest(ep)
0000000000000000000000000000000000000000;;		orig.URL = &r.location
0000000000000000000000000000000000000000;;		return orig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func shuffleEndpoints(r *rand.Rand, eps []url.URL) []url.URL {
0000000000000000000000000000000000000000;;		p := r.Perm(len(eps))
0000000000000000000000000000000000000000;;		neps := make([]url.URL, len(eps))
0000000000000000000000000000000000000000;;		for i, k := range p {
0000000000000000000000000000000000000000;;			neps[i] = eps[k]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return neps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func endpointsEqual(left, right []url.URL) bool {
0000000000000000000000000000000000000000;;		if len(left) != len(right) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sLeft := make([]string, len(left))
0000000000000000000000000000000000000000;;		sRight := make([]string, len(right))
0000000000000000000000000000000000000000;;		for i, l := range left {
0000000000000000000000000000000000000000;;			sLeft[i] = l.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, r := range right {
0000000000000000000000000000000000000000;;			sRight[i] = r.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(sLeft)
0000000000000000000000000000000000000000;;		sort.Strings(sRight)
0000000000000000000000000000000000000000;;		for i := range sLeft {
0000000000000000000000000000000000000000;;			if sLeft[i] != sRight[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
