0000000000000000000000000000000000000000;;	# etcd/client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	etcd/client is the Go client library for etcd.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![GoDoc](https://godoc.org/github.com/coreos/etcd/client?status.png)](https://godoc.org/github.com/coreos/etcd/client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	etcd uses `cmd/vendor` directory to store external dependencies, which are
0000000000000000000000000000000000000000;;	to be compiled into etcd release binaries. `client` can be imported without
0000000000000000000000000000000000000000;;	vendoring. For full compatibility, it is recommended to vendor builds using
0000000000000000000000000000000000000000;;	etcd's vendored packages, using tools like godep, as in
0000000000000000000000000000000000000000;;	[vendor directories](https://golang.org/cmd/go/#hdr-Vendor_Directories).
0000000000000000000000000000000000000000;;	For more detail, please read [Go vendor design](https://golang.org/s/go15vendor).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Install
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```bash
0000000000000000000000000000000000000000;;	go get github.com/coreos/etcd/client
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/client"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		cfg := client.Config{
0000000000000000000000000000000000000000;;			Endpoints:               []string{"http://127.0.0.1:2379"},
0000000000000000000000000000000000000000;;			Transport:               client.DefaultTransport,
0000000000000000000000000000000000000000;;			// set timeout per request to fail fast when the target endpoint is unavailable
0000000000000000000000000000000000000000;;			HeaderTimeoutPerRequest: time.Second,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, err := client.New(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		kapi := client.NewKeysAPI(c)
0000000000000000000000000000000000000000;;		// set "/foo" key with "bar" value
0000000000000000000000000000000000000000;;		log.Print("Setting '/foo' key with 'bar' value")
0000000000000000000000000000000000000000;;		resp, err := kapi.Set(context.Background(), "/foo", "bar", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// print common key info
0000000000000000000000000000000000000000;;			log.Printf("Set is done. Metadata is %q\n", resp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// get "/foo" key's value
0000000000000000000000000000000000000000;;		log.Print("Getting '/foo' key value")
0000000000000000000000000000000000000000;;		resp, err = kapi.Get(context.Background(), "/foo", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// print common key info
0000000000000000000000000000000000000000;;			log.Printf("Get is done. Metadata is %q\n", resp)
0000000000000000000000000000000000000000;;			// print value
0000000000000000000000000000000000000000;;			log.Printf("%q key has %q value\n", resp.Node.Key, resp.Node.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Error Handling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	etcd client might return three types of errors.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- context error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Each API call has its first parameter as `context`. A context can be canceled or have an attached deadline. If the context is canceled or reaches its deadline, the responding context error will be returned no matter what internal errors the API call has already encountered.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- cluster error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Each API call tries to send request to the cluster endpoints one by one until it successfully gets a response. If a requests to an endpoint fails, due to exceeding per request timeout or connection issues, the error will be added into a list of errors. If all possible endpoints fail, a cluster error that includes all encountered errors will be returned.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- response error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If the response gets from the cluster is invalid, a plain string error will be returned. For example, it might be a invalid JSON error.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here is the example code to handle client errors:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	cfg := client.Config{Endpoints: []string{"http://etcd1:2379","http://etcd2:2379","http://etcd3:2379"}}
0000000000000000000000000000000000000000;;	c, err := client.New(cfg)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		log.Fatal(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	kapi := client.NewKeysAPI(c)
0000000000000000000000000000000000000000;;	resp, err := kapi.Set(ctx, "test", "bar", nil)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		if err == context.Canceled {
0000000000000000000000000000000000000000;;			// ctx is canceled by another routine
0000000000000000000000000000000000000000;;		} else if err == context.DeadlineExceeded {
0000000000000000000000000000000000000000;;			// ctx is attached with a deadline and it exceeded
0000000000000000000000000000000000000000;;		} else if cerr, ok := err.(*client.ClusterError); ok {
0000000000000000000000000000000000000000;;			// process (cerr.Errors)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// bad cluster endpoints, which are not etcd servers
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Caveat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. etcd/client prefers to use the same endpoint as long as the endpoint continues to work well. This saves socket resources, and improves efficiency for both client and server side. This preference doesn't remove consistency from the data consumed by the client because data replicated to each etcd member has already passed through the consensus process.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	2. etcd/client does round-robin rotation on other available endpoints if the preferred endpoint isn't functioning properly. For example, if the member that etcd/client connects to is hard killed, etcd/client will fail on the first attempt with the killed member, and succeed on the second attempt with another member. If it fails to talk to all available endpoints, it will return all errors happened.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	3. Default etcd/client cannot handle the case that the remote server is SIGSTOPed now. TCP keepalive mechanism doesn't help in this scenario because operating system may still send TCP keep-alive packets. Over time we'd like to improve this functionality, but solving this issue isn't high priority because a real-life case in which a server is stopped, but the connection is kept alive, hasn't been brought to our attention.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	4. etcd/client cannot detect whether a member is healthy with watches and non-quorum read requests. If the member is isolated from the cluster, etcd/client may retrieve outdated data. Instead, users can either issue quorum read requests or monitor the /health endpoint for member health information.
