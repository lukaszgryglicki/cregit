0000000000000000000000000000000000000000;;	// Copyright 2015 The etcd Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/coreos/etcd/client/keys.go[Godeps/_workspace/src/github.com/coreos/etcd/client/keys.go][vendor/github.com/coreos/etcd/client/keys.go];	
0000000000000000000000000000000000000000;;	package client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:generate codecgen -d 1819 -r "Node|Response|Nodes" -o keys.generated.go keys.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/etcd/pkg/pathutil"
0000000000000000000000000000000000000000;;		"github.com/ugorji/go/codec"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ErrorCodeKeyNotFound  = 100
0000000000000000000000000000000000000000;;		ErrorCodeTestFailed   = 101
0000000000000000000000000000000000000000;;		ErrorCodeNotFile      = 102
0000000000000000000000000000000000000000;;		ErrorCodeNotDir       = 104
0000000000000000000000000000000000000000;;		ErrorCodeNodeExist    = 105
0000000000000000000000000000000000000000;;		ErrorCodeRootROnly    = 107
0000000000000000000000000000000000000000;;		ErrorCodeDirNotEmpty  = 108
0000000000000000000000000000000000000000;;		ErrorCodeUnauthorized = 110
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrorCodePrevValueRequired = 201
0000000000000000000000000000000000000000;;		ErrorCodeTTLNaN            = 202
0000000000000000000000000000000000000000;;		ErrorCodeIndexNaN          = 203
0000000000000000000000000000000000000000;;		ErrorCodeInvalidField      = 209
0000000000000000000000000000000000000000;;		ErrorCodeInvalidForm       = 210
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrorCodeRaftInternal = 300
0000000000000000000000000000000000000000;;		ErrorCodeLeaderElect  = 301
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ErrorCodeWatcherCleared    = 400
0000000000000000000000000000000000000000;;		ErrorCodeEventIndexCleared = 401
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Code    int    `json:"errorCode"`
0000000000000000000000000000000000000000;;		Message string `json:"message"`
0000000000000000000000000000000000000000;;		Cause   string `json:"cause"`
0000000000000000000000000000000000000000;;		Index   uint64 `json:"index"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e Error) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v: %v (%v) [%v]", e.Code, e.Message, e.Cause, e.Index)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrInvalidJSON = errors.New("client: response is invalid json. The endpoint is probably not valid etcd cluster endpoint.")
0000000000000000000000000000000000000000;;		ErrEmptyBody   = errors.New("client: response body is empty")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrevExistType is used to define an existence condition when setting
0000000000000000000000000000000000000000;;	// or deleting Nodes.
0000000000000000000000000000000000000000;;	type PrevExistType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		PrevIgnore  = PrevExistType("")
0000000000000000000000000000000000000000;;		PrevExist   = PrevExistType("true")
0000000000000000000000000000000000000000;;		PrevNoExist = PrevExistType("false")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		defaultV2KeysPrefix = "/v2/keys"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKeysAPI builds a KeysAPI that interacts with etcd's key-value
0000000000000000000000000000000000000000;;	// API over HTTP.
0000000000000000000000000000000000000000;;	func NewKeysAPI(c Client) KeysAPI {
0000000000000000000000000000000000000000;;		return NewKeysAPIWithPrefix(c, defaultV2KeysPrefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKeysAPIWithPrefix acts like NewKeysAPI, but allows the caller
0000000000000000000000000000000000000000;;	// to provide a custom base URL path. This should only be used in
0000000000000000000000000000000000000000;;	// very rare cases.
0000000000000000000000000000000000000000;;	func NewKeysAPIWithPrefix(c Client, p string) KeysAPI {
0000000000000000000000000000000000000000;;		return &httpKeysAPI{
0000000000000000000000000000000000000000;;			client: c,
0000000000000000000000000000000000000000;;			prefix: p,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KeysAPI interface {
0000000000000000000000000000000000000000;;		// Get retrieves a set of Nodes from etcd
0000000000000000000000000000000000000000;;		Get(ctx context.Context, key string, opts *GetOptions) (*Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set assigns a new value to a Node identified by a given key. The caller
0000000000000000000000000000000000000000;;		// may define a set of conditions in the SetOptions. If SetOptions.Dir=true
0000000000000000000000000000000000000000;;		// then value is ignored.
0000000000000000000000000000000000000000;;		Set(ctx context.Context, key, value string, opts *SetOptions) (*Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete removes a Node identified by the given key, optionally destroying
0000000000000000000000000000000000000000;;		// all of its children as well. The caller may define a set of required
0000000000000000000000000000000000000000;;		// conditions in an DeleteOptions object.
0000000000000000000000000000000000000000;;		Delete(ctx context.Context, key string, opts *DeleteOptions) (*Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create is an alias for Set w/ PrevExist=false
0000000000000000000000000000000000000000;;		Create(ctx context.Context, key, value string) (*Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreateInOrder is used to atomically create in-order keys within the given directory.
0000000000000000000000000000000000000000;;		CreateInOrder(ctx context.Context, dir, value string, opts *CreateInOrderOptions) (*Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update is an alias for Set w/ PrevExist=true
0000000000000000000000000000000000000000;;		Update(ctx context.Context, key, value string) (*Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Watcher builds a new Watcher targeted at a specific Node identified
0000000000000000000000000000000000000000;;		// by the given key. The Watcher may be configured at creation time
0000000000000000000000000000000000000000;;		// through a WatcherOptions object. The returned Watcher is designed
0000000000000000000000000000000000000000;;		// to emit events that happen to a Node, and optionally to its children.
0000000000000000000000000000000000000000;;		Watcher(key string, opts *WatcherOptions) Watcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type WatcherOptions struct {
0000000000000000000000000000000000000000;;		// AfterIndex defines the index after-which the Watcher should
0000000000000000000000000000000000000000;;		// start emitting events. For example, if a value of 5 is
0000000000000000000000000000000000000000;;		// provided, the first event will have an index >= 6.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Setting AfterIndex to 0 (default) means that the Watcher
0000000000000000000000000000000000000000;;		// should start watching for events starting at the current
0000000000000000000000000000000000000000;;		// index, whatever that may be.
0000000000000000000000000000000000000000;;		AfterIndex uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursive specifies whether or not the Watcher should emit
0000000000000000000000000000000000000000;;		// events that occur in children of the given keyspace. If set
0000000000000000000000000000000000000000;;		// to false (default), events will be limited to those that
0000000000000000000000000000000000000000;;		// occur for the exact key.
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateInOrderOptions struct {
0000000000000000000000000000000000000000;;		// TTL defines a period of time after-which the Node should
0000000000000000000000000000000000000000;;		// expire and no longer exist. Values <= 0 are ignored. Given
0000000000000000000000000000000000000000;;		// that the zero-value is ignored, TTL cannot be used to set
0000000000000000000000000000000000000000;;		// a TTL of 0.
0000000000000000000000000000000000000000;;		TTL time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SetOptions struct {
0000000000000000000000000000000000000000;;		// PrevValue specifies what the current value of the Node must
0000000000000000000000000000000000000000;;		// be in order for the Set operation to succeed.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Leaving this field empty means that the caller wishes to
0000000000000000000000000000000000000000;;		// ignore the current value of the Node. This cannot be used
0000000000000000000000000000000000000000;;		// to compare the Node's current value to an empty string.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// PrevValue is ignored if Dir=true
0000000000000000000000000000000000000000;;		PrevValue string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrevIndex indicates what the current ModifiedIndex of the
0000000000000000000000000000000000000000;;		// Node must be in order for the Set operation to succeed.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If PrevIndex is set to 0 (default), no comparison is made.
0000000000000000000000000000000000000000;;		PrevIndex uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrevExist specifies whether the Node must currently exist
0000000000000000000000000000000000000000;;		// (PrevExist) or not (PrevNoExist). If the caller does not
0000000000000000000000000000000000000000;;		// care about existence, set PrevExist to PrevIgnore, or simply
0000000000000000000000000000000000000000;;		// leave it unset.
0000000000000000000000000000000000000000;;		PrevExist PrevExistType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTL defines a period of time after-which the Node should
0000000000000000000000000000000000000000;;		// expire and no longer exist. Values <= 0 are ignored. Given
0000000000000000000000000000000000000000;;		// that the zero-value is ignored, TTL cannot be used to set
0000000000000000000000000000000000000000;;		// a TTL of 0.
0000000000000000000000000000000000000000;;		TTL time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Refresh set to true means a TTL value can be updated
0000000000000000000000000000000000000000;;		// without firing a watch or changing the node value. A
0000000000000000000000000000000000000000;;		// value must not be provided when refreshing a key.
0000000000000000000000000000000000000000;;		Refresh bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dir specifies whether or not this Node should be created as a directory.
0000000000000000000000000000000000000000;;		Dir bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoValueOnSuccess specifies whether the response contains the current value of the Node.
0000000000000000000000000000000000000000;;		// If set, the response will only contain the current value when the request fails.
0000000000000000000000000000000000000000;;		NoValueOnSuccess bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GetOptions struct {
0000000000000000000000000000000000000000;;		// Recursive defines whether or not all children of the Node
0000000000000000000000000000000000000000;;		// should be returned.
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort instructs the server whether or not to sort the Nodes.
0000000000000000000000000000000000000000;;		// If true, the Nodes are sorted alphabetically by key in
0000000000000000000000000000000000000000;;		// ascending order (A to z). If false (default), the Nodes will
0000000000000000000000000000000000000000;;		// not be sorted and the ordering used should not be considered
0000000000000000000000000000000000000000;;		// predictable.
0000000000000000000000000000000000000000;;		Sort bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Quorum specifies whether it gets the latest committed value that
0000000000000000000000000000000000000000;;		// has been applied in quorum of members, which ensures external
0000000000000000000000000000000000000000;;		// consistency (or linearizability).
0000000000000000000000000000000000000000;;		Quorum bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DeleteOptions struct {
0000000000000000000000000000000000000000;;		// PrevValue specifies what the current value of the Node must
0000000000000000000000000000000000000000;;		// be in order for the Delete operation to succeed.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Leaving this field empty means that the caller wishes to
0000000000000000000000000000000000000000;;		// ignore the current value of the Node. This cannot be used
0000000000000000000000000000000000000000;;		// to compare the Node's current value to an empty string.
0000000000000000000000000000000000000000;;		PrevValue string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrevIndex indicates what the current ModifiedIndex of the
0000000000000000000000000000000000000000;;		// Node must be in order for the Delete operation to succeed.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If PrevIndex is set to 0 (default), no comparison is made.
0000000000000000000000000000000000000000;;		PrevIndex uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursive defines whether or not all children of the Node
0000000000000000000000000000000000000000;;		// should be deleted. If set to true, all children of the Node
0000000000000000000000000000000000000000;;		// identified by the given key will be deleted. If left unset
0000000000000000000000000000000000000000;;		// or explicitly set to false, only a single Node will be
0000000000000000000000000000000000000000;;		// deleted.
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dir specifies whether or not this Node should be removed as a directory.
0000000000000000000000000000000000000000;;		Dir bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Watcher interface {
0000000000000000000000000000000000000000;;		// Next blocks until an etcd event occurs, then returns a Response
0000000000000000000000000000000000000000;;		// representing that event. The behavior of Next depends on the
0000000000000000000000000000000000000000;;		// WatcherOptions used to construct the Watcher. Next is designed to
0000000000000000000000000000000000000000;;		// be called repeatedly, each time blocking until a subsequent event
0000000000000000000000000000000000000000;;		// is available.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the provided context is cancelled, Next will return a non-nil
0000000000000000000000000000000000000000;;		// error. Any other failures encountered while waiting for the next
0000000000000000000000000000000000000000;;		// event (connection issues, deserialization failures, etc) will
0000000000000000000000000000000000000000;;		// also result in a non-nil error.
0000000000000000000000000000000000000000;;		Next(context.Context) (*Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Response struct {
0000000000000000000000000000000000000000;;		// Action is the name of the operation that occurred. Possible values
0000000000000000000000000000000000000000;;		// include get, set, delete, update, create, compareAndSwap,
0000000000000000000000000000000000000000;;		// compareAndDelete and expire.
0000000000000000000000000000000000000000;;		Action string `json:"action"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Node represents the state of the relevant etcd Node.
0000000000000000000000000000000000000000;;		Node *Node `json:"node"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PrevNode represents the previous state of the Node. PrevNode is non-nil
0000000000000000000000000000000000000000;;		// only if the Node existed before the action occurred and the action
0000000000000000000000000000000000000000;;		// caused a change to the Node.
0000000000000000000000000000000000000000;;		PrevNode *Node `json:"prevNode"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Index holds the cluster-level index at the time the Response was generated.
0000000000000000000000000000000000000000;;		// This index is not tied to the Node(s) contained in this Response.
0000000000000000000000000000000000000000;;		Index uint64 `json:"-"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ClusterID holds the cluster-level ID reported by the server.  This
0000000000000000000000000000000000000000;;		// should be different for different etcd clusters.
0000000000000000000000000000000000000000;;		ClusterID string `json:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Node struct {
0000000000000000000000000000000000000000;;		// Key represents the unique location of this Node (e.g. "/foo/bar").
0000000000000000000000000000000000000000;;		Key string `json:"key"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dir reports whether node describes a directory.
0000000000000000000000000000000000000000;;		Dir bool `json:"dir,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Value is the current data stored on this Node. If this Node
0000000000000000000000000000000000000000;;		// is a directory, Value will be empty.
0000000000000000000000000000000000000000;;		Value string `json:"value"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nodes holds the children of this Node, only if this Node is a directory.
0000000000000000000000000000000000000000;;		// This slice of will be arbitrarily deep (children, grandchildren, great-
0000000000000000000000000000000000000000;;		// grandchildren, etc.) if a recursive Get or Watch request were made.
0000000000000000000000000000000000000000;;		Nodes Nodes `json:"nodes"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CreatedIndex is the etcd index at-which this Node was created.
0000000000000000000000000000000000000000;;		CreatedIndex uint64 `json:"createdIndex"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ModifiedIndex is the etcd index at-which this Node was last modified.
0000000000000000000000000000000000000000;;		ModifiedIndex uint64 `json:"modifiedIndex"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Expiration is the server side expiration time of the key.
0000000000000000000000000000000000000000;;		Expiration *time.Time `json:"expiration,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TTL is the time to live of the key in second.
0000000000000000000000000000000000000000;;		TTL int64 `json:"ttl,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Node) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("{Key: %s, CreatedIndex: %d, ModifiedIndex: %d, TTL: %d}", n.Key, n.CreatedIndex, n.ModifiedIndex, n.TTL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TTLDuration returns the Node's TTL as a time.Duration object
0000000000000000000000000000000000000000;;	func (n *Node) TTLDuration() time.Duration {
0000000000000000000000000000000000000000;;		return time.Duration(n.TTL) * time.Second
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Nodes []*Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// interfaces for sorting
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ns Nodes) Len() int           { return len(ns) }
0000000000000000000000000000000000000000;;	func (ns Nodes) Less(i, j int) bool { return ns[i].Key < ns[j].Key }
0000000000000000000000000000000000000000;;	func (ns Nodes) Swap(i, j int)      { ns[i], ns[j] = ns[j], ns[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpKeysAPI struct {
0000000000000000000000000000000000000000;;		client httpClient
0000000000000000000000000000000000000000;;		prefix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *httpKeysAPI) Set(ctx context.Context, key, val string, opts *SetOptions) (*Response, error) {
0000000000000000000000000000000000000000;;		act := &setAction{
0000000000000000000000000000000000000000;;			Prefix: k.prefix,
0000000000000000000000000000000000000000;;			Key:    key,
0000000000000000000000000000000000000000;;			Value:  val,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts != nil {
0000000000000000000000000000000000000000;;			act.PrevValue = opts.PrevValue
0000000000000000000000000000000000000000;;			act.PrevIndex = opts.PrevIndex
0000000000000000000000000000000000000000;;			act.PrevExist = opts.PrevExist
0000000000000000000000000000000000000000;;			act.TTL = opts.TTL
0000000000000000000000000000000000000000;;			act.Refresh = opts.Refresh
0000000000000000000000000000000000000000;;			act.Dir = opts.Dir
0000000000000000000000000000000000000000;;			act.NoValueOnSuccess = opts.NoValueOnSuccess
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doCtx := ctx
0000000000000000000000000000000000000000;;		if act.PrevExist == PrevNoExist {
0000000000000000000000000000000000000000;;			doCtx = context.WithValue(doCtx, &oneShotCtxValue, &oneShotCtxValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		resp, body, err := k.client.Do(doCtx, act)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmarshalHTTPResponse(resp.StatusCode, resp.Header, body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *httpKeysAPI) Create(ctx context.Context, key, val string) (*Response, error) {
0000000000000000000000000000000000000000;;		return k.Set(ctx, key, val, &SetOptions{PrevExist: PrevNoExist})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *httpKeysAPI) CreateInOrder(ctx context.Context, dir, val string, opts *CreateInOrderOptions) (*Response, error) {
0000000000000000000000000000000000000000;;		act := &createInOrderAction{
0000000000000000000000000000000000000000;;			Prefix: k.prefix,
0000000000000000000000000000000000000000;;			Dir:    dir,
0000000000000000000000000000000000000000;;			Value:  val,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts != nil {
0000000000000000000000000000000000000000;;			act.TTL = opts.TTL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, body, err := k.client.Do(ctx, act)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmarshalHTTPResponse(resp.StatusCode, resp.Header, body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *httpKeysAPI) Update(ctx context.Context, key, val string) (*Response, error) {
0000000000000000000000000000000000000000;;		return k.Set(ctx, key, val, &SetOptions{PrevExist: PrevExist})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *httpKeysAPI) Delete(ctx context.Context, key string, opts *DeleteOptions) (*Response, error) {
0000000000000000000000000000000000000000;;		act := &deleteAction{
0000000000000000000000000000000000000000;;			Prefix: k.prefix,
0000000000000000000000000000000000000000;;			Key:    key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts != nil {
0000000000000000000000000000000000000000;;			act.PrevValue = opts.PrevValue
0000000000000000000000000000000000000000;;			act.PrevIndex = opts.PrevIndex
0000000000000000000000000000000000000000;;			act.Dir = opts.Dir
0000000000000000000000000000000000000000;;			act.Recursive = opts.Recursive
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doCtx := context.WithValue(ctx, &oneShotCtxValue, &oneShotCtxValue)
0000000000000000000000000000000000000000;;		resp, body, err := k.client.Do(doCtx, act)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmarshalHTTPResponse(resp.StatusCode, resp.Header, body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *httpKeysAPI) Get(ctx context.Context, key string, opts *GetOptions) (*Response, error) {
0000000000000000000000000000000000000000;;		act := &getAction{
0000000000000000000000000000000000000000;;			Prefix: k.prefix,
0000000000000000000000000000000000000000;;			Key:    key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts != nil {
0000000000000000000000000000000000000000;;			act.Recursive = opts.Recursive
0000000000000000000000000000000000000000;;			act.Sorted = opts.Sort
0000000000000000000000000000000000000000;;			act.Quorum = opts.Quorum
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, body, err := k.client.Do(ctx, act)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return unmarshalHTTPResponse(resp.StatusCode, resp.Header, body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *httpKeysAPI) Watcher(key string, opts *WatcherOptions) Watcher {
0000000000000000000000000000000000000000;;		act := waitAction{
0000000000000000000000000000000000000000;;			Prefix: k.prefix,
0000000000000000000000000000000000000000;;			Key:    key,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts != nil {
0000000000000000000000000000000000000000;;			act.Recursive = opts.Recursive
0000000000000000000000000000000000000000;;			if opts.AfterIndex > 0 {
0000000000000000000000000000000000000000;;				act.WaitIndex = opts.AfterIndex + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &httpWatcher{
0000000000000000000000000000000000000000;;			client:   k.client,
0000000000000000000000000000000000000000;;			nextWait: act,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpWatcher struct {
0000000000000000000000000000000000000000;;		client   httpClient
0000000000000000000000000000000000000000;;		nextWait waitAction
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (hw *httpWatcher) Next(ctx context.Context) (*Response, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			httpresp, body, err := hw.client.Do(ctx, &hw.nextWait)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp, err := unmarshalHTTPResponse(httpresp.StatusCode, httpresp.Header, body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == ErrEmptyBody {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hw.nextWait.WaitIndex = resp.Node.ModifiedIndex + 1
0000000000000000000000000000000000000000;;			return resp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// v2KeysURL forms a URL representing the location of a key.
0000000000000000000000000000000000000000;;	// The endpoint argument represents the base URL of an etcd
0000000000000000000000000000000000000000;;	// server. The prefix is the path needed to route from the
0000000000000000000000000000000000000000;;	// provided endpoint's path to the root of the keys API
0000000000000000000000000000000000000000;;	// (typically "/v2/keys").
0000000000000000000000000000000000000000;;	func v2KeysURL(ep url.URL, prefix, key string) *url.URL {
0000000000000000000000000000000000000000;;		// We concatenate all parts together manually. We cannot use
0000000000000000000000000000000000000000;;		// path.Join because it does not reserve trailing slash.
0000000000000000000000000000000000000000;;		// We call CanonicalURLPath to further cleanup the path.
0000000000000000000000000000000000000000;;		if prefix != "" && prefix[0] != '/' {
0000000000000000000000000000000000000000;;			prefix = "/" + prefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if key != "" && key[0] != '/' {
0000000000000000000000000000000000000000;;			key = "/" + key
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ep.Path = pathutil.CanonicalURLPath(ep.Path + prefix + key)
0000000000000000000000000000000000000000;;		return &ep
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type getAction struct {
0000000000000000000000000000000000000000;;		Prefix    string
0000000000000000000000000000000000000000;;		Key       string
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;		Sorted    bool
0000000000000000000000000000000000000000;;		Quorum    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *getAction) HTTPRequest(ep url.URL) *http.Request {
0000000000000000000000000000000000000000;;		u := v2KeysURL(ep, g.Prefix, g.Key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := u.Query()
0000000000000000000000000000000000000000;;		params.Set("recursive", strconv.FormatBool(g.Recursive))
0000000000000000000000000000000000000000;;		params.Set("sorted", strconv.FormatBool(g.Sorted))
0000000000000000000000000000000000000000;;		params.Set("quorum", strconv.FormatBool(g.Quorum))
0000000000000000000000000000000000000000;;		u.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest("GET", u.String(), nil)
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type waitAction struct {
0000000000000000000000000000000000000000;;		Prefix    string
0000000000000000000000000000000000000000;;		Key       string
0000000000000000000000000000000000000000;;		WaitIndex uint64
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *waitAction) HTTPRequest(ep url.URL) *http.Request {
0000000000000000000000000000000000000000;;		u := v2KeysURL(ep, w.Prefix, w.Key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := u.Query()
0000000000000000000000000000000000000000;;		params.Set("wait", "true")
0000000000000000000000000000000000000000;;		params.Set("waitIndex", strconv.FormatUint(w.WaitIndex, 10))
0000000000000000000000000000000000000000;;		params.Set("recursive", strconv.FormatBool(w.Recursive))
0000000000000000000000000000000000000000;;		u.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest("GET", u.String(), nil)
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setAction struct {
0000000000000000000000000000000000000000;;		Prefix           string
0000000000000000000000000000000000000000;;		Key              string
0000000000000000000000000000000000000000;;		Value            string
0000000000000000000000000000000000000000;;		PrevValue        string
0000000000000000000000000000000000000000;;		PrevIndex        uint64
0000000000000000000000000000000000000000;;		PrevExist        PrevExistType
0000000000000000000000000000000000000000;;		TTL              time.Duration
0000000000000000000000000000000000000000;;		Refresh          bool
0000000000000000000000000000000000000000;;		Dir              bool
0000000000000000000000000000000000000000;;		NoValueOnSuccess bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *setAction) HTTPRequest(ep url.URL) *http.Request {
0000000000000000000000000000000000000000;;		u := v2KeysURL(ep, a.Prefix, a.Key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := u.Query()
0000000000000000000000000000000000000000;;		form := url.Values{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we're either creating a directory or setting a key
0000000000000000000000000000000000000000;;		if a.Dir {
0000000000000000000000000000000000000000;;			params.Set("dir", strconv.FormatBool(a.Dir))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// These options are only valid for setting a key
0000000000000000000000000000000000000000;;			if a.PrevValue != "" {
0000000000000000000000000000000000000000;;				params.Set("prevValue", a.PrevValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			form.Add("value", a.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Options which apply to both setting a key and creating a dir
0000000000000000000000000000000000000000;;		if a.PrevIndex != 0 {
0000000000000000000000000000000000000000;;			params.Set("prevIndex", strconv.FormatUint(a.PrevIndex, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.PrevExist != PrevIgnore {
0000000000000000000000000000000000000000;;			params.Set("prevExist", string(a.PrevExist))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.TTL > 0 {
0000000000000000000000000000000000000000;;			form.Add("ttl", strconv.FormatUint(uint64(a.TTL.Seconds()), 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if a.Refresh {
0000000000000000000000000000000000000000;;			form.Add("refresh", "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.NoValueOnSuccess {
0000000000000000000000000000000000000000;;			params.Set("noValueOnSuccess", strconv.FormatBool(a.NoValueOnSuccess))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;		body := strings.NewReader(form.Encode())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest("PUT", u.String(), body)
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deleteAction struct {
0000000000000000000000000000000000000000;;		Prefix    string
0000000000000000000000000000000000000000;;		Key       string
0000000000000000000000000000000000000000;;		PrevValue string
0000000000000000000000000000000000000000;;		PrevIndex uint64
0000000000000000000000000000000000000000;;		Dir       bool
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *deleteAction) HTTPRequest(ep url.URL) *http.Request {
0000000000000000000000000000000000000000;;		u := v2KeysURL(ep, a.Prefix, a.Key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := u.Query()
0000000000000000000000000000000000000000;;		if a.PrevValue != "" {
0000000000000000000000000000000000000000;;			params.Set("prevValue", a.PrevValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.PrevIndex != 0 {
0000000000000000000000000000000000000000;;			params.Set("prevIndex", strconv.FormatUint(a.PrevIndex, 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.Dir {
0000000000000000000000000000000000000000;;			params.Set("dir", "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a.Recursive {
0000000000000000000000000000000000000000;;			params.Set("recursive", "true")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.RawQuery = params.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest("DELETE", u.String(), nil)
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type createInOrderAction struct {
0000000000000000000000000000000000000000;;		Prefix string
0000000000000000000000000000000000000000;;		Dir    string
0000000000000000000000000000000000000000;;		Value  string
0000000000000000000000000000000000000000;;		TTL    time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *createInOrderAction) HTTPRequest(ep url.URL) *http.Request {
0000000000000000000000000000000000000000;;		u := v2KeysURL(ep, a.Prefix, a.Dir)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		form := url.Values{}
0000000000000000000000000000000000000000;;		form.Add("value", a.Value)
0000000000000000000000000000000000000000;;		if a.TTL > 0 {
0000000000000000000000000000000000000000;;			form.Add("ttl", strconv.FormatUint(uint64(a.TTL.Seconds()), 10))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body := strings.NewReader(form.Encode())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, _ := http.NewRequest("POST", u.String(), body)
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
0000000000000000000000000000000000000000;;		return req
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalHTTPResponse(code int, header http.Header, body []byte) (res *Response, err error) {
0000000000000000000000000000000000000000;;		switch code {
0000000000000000000000000000000000000000;;		case http.StatusOK, http.StatusCreated:
0000000000000000000000000000000000000000;;			if len(body) == 0 {
0000000000000000000000000000000000000000;;				return nil, ErrEmptyBody
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res, err = unmarshalSuccessfulKeysResponse(header, body)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = unmarshalFailedKeysResponse(body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalSuccessfulKeysResponse(header http.Header, body []byte) (*Response, error) {
0000000000000000000000000000000000000000;;		var res Response
0000000000000000000000000000000000000000;;		err := codec.NewDecoderBytes(body, new(codec.JsonHandle)).Decode(&res)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, ErrInvalidJSON
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if header.Get("X-Etcd-Index") != "" {
0000000000000000000000000000000000000000;;			res.Index, err = strconv.ParseUint(header.Get("X-Etcd-Index"), 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.ClusterID = header.Get("X-Etcd-Cluster-ID")
0000000000000000000000000000000000000000;;		return &res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalFailedKeysResponse(body []byte) error {
0000000000000000000000000000000000000000;;		var etcdErr Error
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(body, &etcdErr); err != nil {
0000000000000000000000000000000000000000;;			return ErrInvalidJSON
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return etcdErr
0000000000000000000000000000000000000000;;	}
