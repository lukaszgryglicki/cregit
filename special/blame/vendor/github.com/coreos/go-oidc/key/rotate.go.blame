0000000000000000000000000000000000000000;;	package key
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/key/rotate.go[Godeps/_workspace/src/github.com/coreos/go-oidc/key/rotate.go][vendor/github.com/coreos/go-oidc/key/rotate.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ptime "github.com/coreos/pkg/timeutil"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrorPrivateKeysExpired = errors.New("private keys have expired")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPrivateKeyRotator(repo PrivateKeySetRepo, ttl time.Duration) *PrivateKeyRotator {
0000000000000000000000000000000000000000;;		return &PrivateKeyRotator{
0000000000000000000000000000000000000000;;			repo: repo,
0000000000000000000000000000000000000000;;			ttl:  ttl,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keep:        2,
0000000000000000000000000000000000000000;;			generateKey: GeneratePrivateKey,
0000000000000000000000000000000000000000;;			clock:       clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PrivateKeyRotator struct {
0000000000000000000000000000000000000000;;		repo        PrivateKeySetRepo
0000000000000000000000000000000000000000;;		generateKey GeneratePrivateKeyFunc
0000000000000000000000000000000000000000;;		clock       clockwork.Clock
0000000000000000000000000000000000000000;;		keep        int
0000000000000000000000000000000000000000;;		ttl         time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PrivateKeyRotator) expiresAt() time.Time {
0000000000000000000000000000000000000000;;		return r.clock.Now().UTC().Add(r.ttl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PrivateKeyRotator) Healthy() error {
0000000000000000000000000000000000000000;;		pks, err := r.privateKeySet()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.clock.Now().After(pks.ExpiresAt()) {
0000000000000000000000000000000000000000;;			return ErrorPrivateKeysExpired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PrivateKeyRotator) privateKeySet() (*PrivateKeySet, error) {
0000000000000000000000000000000000000000;;		ks, err := r.repo.Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pks, ok := ks.(*PrivateKeySet)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("unable to cast to PrivateKeySet")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pks, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PrivateKeyRotator) nextRotation() (time.Duration, error) {
0000000000000000000000000000000000000000;;		pks, err := r.privateKeySet()
0000000000000000000000000000000000000000;;		if err == ErrorNoKeys {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := r.clock.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ideally, we want to rotate after half the TTL has elapsed.
0000000000000000000000000000000000000000;;		idealRotationTime := pks.ExpiresAt().Add(-r.ttl / 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we are past the ideal rotation time, rotate immediatly.
0000000000000000000000000000000000000000;;		return max(0, idealRotationTime.Sub(now)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func max(a, b time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		if a > b {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PrivateKeyRotator) Run() chan struct{} {
0000000000000000000000000000000000000000;;		attempt := func() {
0000000000000000000000000000000000000000;;			k, err := r.generateKey()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				log.Printf("go-oidc: failed generating signing key: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			exp := r.expiresAt()
0000000000000000000000000000000000000000;;			if err := rotatePrivateKeys(r.repo, k, r.keep, exp); err != nil {
0000000000000000000000000000000000000000;;				log.Printf("go-oidc: key rotation failed: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				var nextRotation time.Duration
0000000000000000000000000000000000000000;;				var sleep time.Duration
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					if nextRotation, err = r.nextRotation(); err == nil {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					sleep = ptime.ExpBackoff(sleep, time.Minute)
0000000000000000000000000000000000000000;;					log.Printf("go-oidc: error getting nextRotation, retrying in %v: %v", sleep, err)
0000000000000000000000000000000000000000;;					time.Sleep(sleep)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-r.clock.After(nextRotation):
0000000000000000000000000000000000000000;;					attempt()
0000000000000000000000000000000000000000;;				case <-stop:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rotatePrivateKeys(repo PrivateKeySetRepo, k *PrivateKey, keep int, exp time.Time) error {
0000000000000000000000000000000000000000;;		ks, err := repo.Get()
0000000000000000000000000000000000000000;;		if err != nil && err != ErrorNoKeys {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var keys []*PrivateKey
0000000000000000000000000000000000000000;;		if ks != nil {
0000000000000000000000000000000000000000;;			pks, ok := ks.(*PrivateKeySet)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return errors.New("unable to cast to PrivateKeySet")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keys = pks.Keys()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys = append([]*PrivateKey{k}, keys...)
0000000000000000000000000000000000000000;;		if l := len(keys); l > keep {
0000000000000000000000000000000000000000;;			keys = keys[0:keep]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nks := PrivateKeySet{
0000000000000000000000000000000000000000;;			keys:        keys,
0000000000000000000000000000000000000000;;			ActiveKeyID: k.ID(),
0000000000000000000000000000000000000000;;			expiresAt:   exp,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return repo.Set(KeySet(&nks))
0000000000000000000000000000000000000000;;	}
