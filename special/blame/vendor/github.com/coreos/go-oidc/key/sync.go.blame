0000000000000000000000000000000000000000;;	package key
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/key/sync.go[Godeps/_workspace/src/github.com/coreos/go-oidc/key/sync.go][vendor/github.com/coreos/go-oidc/key/sync.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/timeutil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewKeySetSyncer(r ReadableKeySetRepo, w WritableKeySetRepo) *KeySetSyncer {
0000000000000000000000000000000000000000;;		return &KeySetSyncer{
0000000000000000000000000000000000000000;;			readable: r,
0000000000000000000000000000000000000000;;			writable: w,
0000000000000000000000000000000000000000;;			clock:    clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KeySetSyncer struct {
0000000000000000000000000000000000000000;;		readable ReadableKeySetRepo
0000000000000000000000000000000000000000;;		writable WritableKeySetRepo
0000000000000000000000000000000000000000;;		clock    clockwork.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *KeySetSyncer) Run() chan struct{} {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			var failing bool
0000000000000000000000000000000000000000;;			var next time.Duration
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				exp, err := syncKeySet(s.readable, s.writable, s.clock)
0000000000000000000000000000000000000000;;				if err != nil || exp == 0 {
0000000000000000000000000000000000000000;;					if !failing {
0000000000000000000000000000000000000000;;						failing = true
0000000000000000000000000000000000000000;;						next = time.Second
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						next = timeutil.ExpBackoff(next, time.Minute)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if exp == 0 {
0000000000000000000000000000000000000000;;						log.Printf("Synced to already expired key set, retrying in %v: %v", next, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						log.Printf("Failed syncing key set, retrying in %v: %v", next, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					failing = false
0000000000000000000000000000000000000000;;					next = exp / 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-s.clock.After(next):
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case <-stop:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Sync(r ReadableKeySetRepo, w WritableKeySetRepo) (time.Duration, error) {
0000000000000000000000000000000000000000;;		return syncKeySet(r, w, clockwork.NewRealClock())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// syncKeySet copies the keyset from r to the KeySet at w and returns the duration in which the KeySet will expire.
0000000000000000000000000000000000000000;;	// If keyset has already expired, returns a zero duration.
0000000000000000000000000000000000000000;;	func syncKeySet(r ReadableKeySetRepo, w WritableKeySetRepo, clock clockwork.Clock) (exp time.Duration, err error) {
0000000000000000000000000000000000000000;;		var ks KeySet
0000000000000000000000000000000000000000;;		ks, err = r.Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ks == nil {
0000000000000000000000000000000000000000;;			err = errors.New("no source KeySet")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = w.Set(ks); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := clock.Now()
0000000000000000000000000000000000000000;;		if ks.ExpiresAt().After(now) {
0000000000000000000000000000000000000000;;			exp = ks.ExpiresAt().Sub(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
