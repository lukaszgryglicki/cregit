0000000000000000000000000000000000000000;;	package oauth2
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/oauth2/oauth2.go[Godeps/_workspace/src/github.com/coreos/go-oidc/oauth2/oauth2.go][vendor/github.com/coreos/go-oidc/oauth2/oauth2.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"mime"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		phttp "github.com/coreos/go-oidc/http"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResponseTypesEqual compares two response_type values. If either
0000000000000000000000000000000000000000;;	// contains a space, it is treated as an unordered list. For example,
0000000000000000000000000000000000000000;;	// comparing "code id_token" and "id_token code" would evaluate to true.
0000000000000000000000000000000000000000;;	func ResponseTypesEqual(r1, r2 string) bool {
0000000000000000000000000000000000000000;;		if !strings.Contains(r1, " ") || !strings.Contains(r2, " ") {
0000000000000000000000000000000000000000;;			// fast route, no split needed
0000000000000000000000000000000000000000;;			return r1 == r2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// split, sort, and compare
0000000000000000000000000000000000000000;;		r1Fields := strings.Fields(r1)
0000000000000000000000000000000000000000;;		r2Fields := strings.Fields(r2)
0000000000000000000000000000000000000000;;		if len(r1Fields) != len(r2Fields) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(r1Fields)
0000000000000000000000000000000000000000;;		sort.Strings(r2Fields)
0000000000000000000000000000000000000000;;		for i, r1Field := range r1Fields {
0000000000000000000000000000000000000000;;			if r1Field != r2Fields[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// OAuth2.0 response types registered by OIDC.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See: https://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#RegistryContents
0000000000000000000000000000000000000000;;		ResponseTypeCode             = "code"
0000000000000000000000000000000000000000;;		ResponseTypeCodeIDToken      = "code id_token"
0000000000000000000000000000000000000000;;		ResponseTypeCodeIDTokenToken = "code id_token token"
0000000000000000000000000000000000000000;;		ResponseTypeIDToken          = "id_token"
0000000000000000000000000000000000000000;;		ResponseTypeIDTokenToken     = "id_token token"
0000000000000000000000000000000000000000;;		ResponseTypeToken            = "token"
0000000000000000000000000000000000000000;;		ResponseTypeNone             = "none"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		GrantTypeAuthCode     = "authorization_code"
0000000000000000000000000000000000000000;;		GrantTypeClientCreds  = "client_credentials"
0000000000000000000000000000000000000000;;		GrantTypeUserCreds    = "password"
0000000000000000000000000000000000000000;;		GrantTypeImplicit     = "implicit"
0000000000000000000000000000000000000000;;		GrantTypeRefreshToken = "refresh_token"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AuthMethodClientSecretPost  = "client_secret_post"
0000000000000000000000000000000000000000;;		AuthMethodClientSecretBasic = "client_secret_basic"
0000000000000000000000000000000000000000;;		AuthMethodClientSecretJWT   = "client_secret_jwt"
0000000000000000000000000000000000000000;;		AuthMethodPrivateKeyJWT     = "private_key_jwt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		Credentials ClientCredentials
0000000000000000000000000000000000000000;;		Scope       []string
0000000000000000000000000000000000000000;;		RedirectURL string
0000000000000000000000000000000000000000;;		AuthURL     string
0000000000000000000000000000000000000000;;		TokenURL    string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be one of the AuthMethodXXX methods above. Right now, only
0000000000000000000000000000000000000000;;		// AuthMethodClientSecretPost and AuthMethodClientSecretBasic are supported.
0000000000000000000000000000000000000000;;		AuthMethod string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		hc          phttp.Client
0000000000000000000000000000000000000000;;		creds       ClientCredentials
0000000000000000000000000000000000000000;;		scope       []string
0000000000000000000000000000000000000000;;		authURL     *url.URL
0000000000000000000000000000000000000000;;		redirectURL *url.URL
0000000000000000000000000000000000000000;;		tokenURL    *url.URL
0000000000000000000000000000000000000000;;		authMethod  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientCredentials struct {
0000000000000000000000000000000000000000;;		ID     string
0000000000000000000000000000000000000000;;		Secret string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClient(hc phttp.Client, cfg Config) (c *Client, err error) {
0000000000000000000000000000000000000000;;		if len(cfg.Credentials.ID) == 0 {
0000000000000000000000000000000000000000;;			err = errors.New("missing client id")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cfg.Credentials.Secret) == 0 {
0000000000000000000000000000000000000000;;			err = errors.New("missing client secret")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.AuthMethod == "" {
0000000000000000000000000000000000000000;;			cfg.AuthMethod = AuthMethodClientSecretBasic
0000000000000000000000000000000000000000;;		} else if cfg.AuthMethod != AuthMethodClientSecretPost && cfg.AuthMethod != AuthMethodClientSecretBasic {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("auth method %q is not supported", cfg.AuthMethod)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		au, err := phttp.ParseNonEmptyURL(cfg.AuthURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tu, err := phttp.ParseNonEmptyURL(cfg.TokenURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow empty redirect URL in the case where the client
0000000000000000000000000000000000000000;;		// only needs to verify a given token.
0000000000000000000000000000000000000000;;		ru, err := url.Parse(cfg.RedirectURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c = &Client{
0000000000000000000000000000000000000000;;			creds:       cfg.Credentials,
0000000000000000000000000000000000000000;;			scope:       cfg.Scope,
0000000000000000000000000000000000000000;;			redirectURL: ru,
0000000000000000000000000000000000000000;;			authURL:     au,
0000000000000000000000000000000000000000;;			tokenURL:    tu,
0000000000000000000000000000000000000000;;			hc:          hc,
0000000000000000000000000000000000000000;;			authMethod:  cfg.AuthMethod,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the embedded HTTP client
0000000000000000000000000000000000000000;;	func (c *Client) HttpClient() phttp.Client {
0000000000000000000000000000000000000000;;		return c.hc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate the url for initial redirect to oauth provider.
0000000000000000000000000000000000000000;;	func (c *Client) AuthCodeURL(state, accessType, prompt string) string {
0000000000000000000000000000000000000000;;		v := c.commonURLValues()
0000000000000000000000000000000000000000;;		v.Set("state", state)
0000000000000000000000000000000000000000;;		if strings.ToLower(accessType) == "offline" {
0000000000000000000000000000000000000000;;			v.Set("access_type", "offline")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if prompt != "" {
0000000000000000000000000000000000000000;;			v.Set("prompt", prompt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v.Set("response_type", "code")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q := v.Encode()
0000000000000000000000000000000000000000;;		u := *c.authURL
0000000000000000000000000000000000000000;;		if u.RawQuery == "" {
0000000000000000000000000000000000000000;;			u.RawQuery = q
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			u.RawQuery += "&" + q
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) commonURLValues() url.Values {
0000000000000000000000000000000000000000;;		return url.Values{
0000000000000000000000000000000000000000;;			"redirect_uri": {c.redirectURL.String()},
0000000000000000000000000000000000000000;;			"scope":        {strings.Join(c.scope, " ")},
0000000000000000000000000000000000000000;;			"client_id":    {c.creds.ID},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) newAuthenticatedRequest(urlToken string, values url.Values) (*http.Request, error) {
0000000000000000000000000000000000000000;;		var req *http.Request
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch c.authMethod {
0000000000000000000000000000000000000000;;		case AuthMethodClientSecretPost:
0000000000000000000000000000000000000000;;			values.Set("client_secret", c.creds.Secret)
0000000000000000000000000000000000000000;;			req, err = http.NewRequest("POST", urlToken, strings.NewReader(values.Encode()))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case AuthMethodClientSecretBasic:
0000000000000000000000000000000000000000;;			req, err = http.NewRequest("POST", urlToken, strings.NewReader(values.Encode()))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encodedID := url.QueryEscape(c.creds.ID)
0000000000000000000000000000000000000000;;			encodedSecret := url.QueryEscape(c.creds.Secret)
0000000000000000000000000000000000000000;;			req.SetBasicAuth(encodedID, encodedSecret)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("misconfigured client: auth method not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
0000000000000000000000000000000000000000;;		return req, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientCredsToken posts the client id and secret to obtain a token scoped to the OAuth2 client via the "client_credentials" grant type.
0000000000000000000000000000000000000000;;	// May not be supported by all OAuth2 servers.
0000000000000000000000000000000000000000;;	func (c *Client) ClientCredsToken(scope []string) (result TokenResponse, err error) {
0000000000000000000000000000000000000000;;		v := url.Values{
0000000000000000000000000000000000000000;;			"scope":      {strings.Join(scope, " ")},
0000000000000000000000000000000000000000;;			"grant_type": {GrantTypeClientCreds},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := c.newAuthenticatedRequest(c.tokenURL.String(), v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.hc.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseTokenResponse(resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UserCredsToken posts the username and password to obtain a token scoped to the OAuth2 client via the "password" grant_type
0000000000000000000000000000000000000000;;	// May not be supported by all OAuth2 servers.
0000000000000000000000000000000000000000;;	func (c *Client) UserCredsToken(username, password string) (result TokenResponse, err error) {
0000000000000000000000000000000000000000;;		v := url.Values{
0000000000000000000000000000000000000000;;			"scope":      {strings.Join(c.scope, " ")},
0000000000000000000000000000000000000000;;			"grant_type": {GrantTypeUserCreds},
0000000000000000000000000000000000000000;;			"username":   {username},
0000000000000000000000000000000000000000;;			"password":   {password},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := c.newAuthenticatedRequest(c.tokenURL.String(), v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.hc.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseTokenResponse(resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestToken requests a token from the Token Endpoint with the specified grantType.
0000000000000000000000000000000000000000;;	// If 'grantType' == GrantTypeAuthCode, then 'value' should be the authorization code.
0000000000000000000000000000000000000000;;	// If 'grantType' == GrantTypeRefreshToken, then 'value' should be the refresh token.
0000000000000000000000000000000000000000;;	func (c *Client) RequestToken(grantType, value string) (result TokenResponse, err error) {
0000000000000000000000000000000000000000;;		v := c.commonURLValues()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.Set("grant_type", grantType)
0000000000000000000000000000000000000000;;		v.Set("client_secret", c.creds.Secret)
0000000000000000000000000000000000000000;;		switch grantType {
0000000000000000000000000000000000000000;;		case GrantTypeAuthCode:
0000000000000000000000000000000000000000;;			v.Set("code", value)
0000000000000000000000000000000000000000;;		case GrantTypeRefreshToken:
0000000000000000000000000000000000000000;;			v.Set("refresh_token", value)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("unsupported grant_type: %v", grantType)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := c.newAuthenticatedRequest(c.tokenURL.String(), v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.hc.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseTokenResponse(resp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseTokenResponse(resp *http.Response) (result TokenResponse, err error) {
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		badStatusCode := resp.StatusCode < 200 || resp.StatusCode > 299
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contentType, _, err := mime.ParseMediaType(resp.Header.Get("Content-Type"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result = TokenResponse{
0000000000000000000000000000000000000000;;			RawBody: body,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newError := func(typ, desc, state string) error {
0000000000000000000000000000000000000000;;			if typ == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unrecognized error %s", body)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &Error{typ, desc, state}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if contentType == "application/x-www-form-urlencoded" || contentType == "text/plain" {
0000000000000000000000000000000000000000;;			var vals url.Values
0000000000000000000000000000000000000000;;			vals, err = url.ParseQuery(string(body))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if error := vals.Get("error"); error != "" || badStatusCode {
0000000000000000000000000000000000000000;;				err = newError(error, vals.Get("error_description"), vals.Get("state"))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e := vals.Get("expires_in")
0000000000000000000000000000000000000000;;			if e == "" {
0000000000000000000000000000000000000000;;				e = vals.Get("expires")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e != "" {
0000000000000000000000000000000000000000;;				result.Expires, err = strconv.Atoi(e)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.AccessToken = vals.Get("access_token")
0000000000000000000000000000000000000000;;			result.TokenType = vals.Get("token_type")
0000000000000000000000000000000000000000;;			result.IDToken = vals.Get("id_token")
0000000000000000000000000000000000000000;;			result.RefreshToken = vals.Get("refresh_token")
0000000000000000000000000000000000000000;;			result.Scope = vals.Get("scope")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var r struct {
0000000000000000000000000000000000000000;;				AccessToken  string      `json:"access_token"`
0000000000000000000000000000000000000000;;				TokenType    string      `json:"token_type"`
0000000000000000000000000000000000000000;;				IDToken      string      `json:"id_token"`
0000000000000000000000000000000000000000;;				RefreshToken string      `json:"refresh_token"`
0000000000000000000000000000000000000000;;				Scope        string      `json:"scope"`
0000000000000000000000000000000000000000;;				State        string      `json:"state"`
0000000000000000000000000000000000000000;;				ExpiresIn    json.Number `json:"expires_in"` // Azure AD returns string
0000000000000000000000000000000000000000;;				Expires      int         `json:"expires"`
0000000000000000000000000000000000000000;;				Error        string      `json:"error"`
0000000000000000000000000000000000000000;;				Desc         string      `json:"error_description"`
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = json.Unmarshal(body, &r); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.Error != "" || badStatusCode {
0000000000000000000000000000000000000000;;				err = newError(r.Error, r.Desc, r.State)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.AccessToken = r.AccessToken
0000000000000000000000000000000000000000;;			result.TokenType = r.TokenType
0000000000000000000000000000000000000000;;			result.IDToken = r.IDToken
0000000000000000000000000000000000000000;;			result.RefreshToken = r.RefreshToken
0000000000000000000000000000000000000000;;			result.Scope = r.Scope
0000000000000000000000000000000000000000;;			if expiresIn, err := r.ExpiresIn.Int64(); err != nil {
0000000000000000000000000000000000000000;;				result.Expires = r.Expires
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				result.Expires = int(expiresIn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TokenResponse struct {
0000000000000000000000000000000000000000;;		AccessToken  string
0000000000000000000000000000000000000000;;		TokenType    string
0000000000000000000000000000000000000000;;		Expires      int
0000000000000000000000000000000000000000;;		IDToken      string
0000000000000000000000000000000000000000;;		RefreshToken string // OPTIONAL.
0000000000000000000000000000000000000000;;		Scope        string // OPTIONAL, if identical to the scope requested by the client, otherwise, REQUIRED.
0000000000000000000000000000000000000000;;		RawBody      []byte // In case callers need some other non-standard info from the token response
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AuthCodeRequest struct {
0000000000000000000000000000000000000000;;		ResponseType string
0000000000000000000000000000000000000000;;		ClientID     string
0000000000000000000000000000000000000000;;		RedirectURL  *url.URL
0000000000000000000000000000000000000000;;		Scope        []string
0000000000000000000000000000000000000000;;		State        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseAuthCodeRequest(q url.Values) (AuthCodeRequest, error) {
0000000000000000000000000000000000000000;;		acr := AuthCodeRequest{
0000000000000000000000000000000000000000;;			ResponseType: q.Get("response_type"),
0000000000000000000000000000000000000000;;			ClientID:     q.Get("client_id"),
0000000000000000000000000000000000000000;;			State:        q.Get("state"),
0000000000000000000000000000000000000000;;			Scope:        make([]string, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		qs := strings.TrimSpace(q.Get("scope"))
0000000000000000000000000000000000000000;;		if qs != "" {
0000000000000000000000000000000000000000;;			acr.Scope = strings.Split(qs, " ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := func() error {
0000000000000000000000000000000000000000;;			if acr.ClientID == "" {
0000000000000000000000000000000000000000;;				return NewError(ErrorInvalidRequest)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			redirectURL := q.Get("redirect_uri")
0000000000000000000000000000000000000000;;			if redirectURL != "" {
0000000000000000000000000000000000000000;;				ru, err := url.Parse(redirectURL)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return NewError(ErrorInvalidRequest)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				acr.RedirectURL = ru
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return acr, err
0000000000000000000000000000000000000000;;	}
