0000000000000000000000000000000000000000;;	package http
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/http/http.go[Godeps/_workspace/src/github.com/coreos/go-oidc/http/http.go][vendor/github.com/coreos/go-oidc/http/http.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WriteError(w http.ResponseWriter, code int, msg string) {
0000000000000000000000000000000000000000;;		e := struct {
0000000000000000000000000000000000000000;;			Error string `json:"error"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Error: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := json.Marshal(e)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Printf("go-oidc: failed to marshal %#v: %v", e, err)
0000000000000000000000000000000000000000;;			code = http.StatusInternalServerError
0000000000000000000000000000000000000000;;			b = []byte(`{"error":"server_error"}`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.WriteHeader(code)
0000000000000000000000000000000000000000;;		w.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BasicAuth parses a username and password from the request's
0000000000000000000000000000000000000000;;	// Authorization header. This was pulled from golang master:
0000000000000000000000000000000000000000;;	// https://codereview.appspot.com/76540043
0000000000000000000000000000000000000000;;	func BasicAuth(r *http.Request) (username, password string, ok bool) {
0000000000000000000000000000000000000000;;		auth := r.Header.Get("Authorization")
0000000000000000000000000000000000000000;;		if auth == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(auth, "Basic ") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, err := base64.StdEncoding.DecodeString(strings.TrimPrefix(auth, "Basic "))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cs := string(c)
0000000000000000000000000000000000000000;;		s := strings.IndexByte(cs, ':')
0000000000000000000000000000000000000000;;		if s < 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cs[:s], cs[s+1:], true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cacheControlMaxAge(hdr string) (time.Duration, bool, error) {
0000000000000000000000000000000000000000;;		for _, field := range strings.Split(hdr, ",") {
0000000000000000000000000000000000000000;;			parts := strings.SplitN(strings.TrimSpace(field), "=", 2)
0000000000000000000000000000000000000000;;			k := strings.ToLower(strings.TrimSpace(parts[0]))
0000000000000000000000000000000000000000;;			if k != "max-age" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(parts) == 1 {
0000000000000000000000000000000000000000;;				return 0, false, errors.New("max-age has no value")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v := strings.TrimSpace(parts[1])
0000000000000000000000000000000000000000;;			if v == "" {
0000000000000000000000000000000000000000;;				return 0, false, errors.New("max-age has empty value")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			age, err := strconv.Atoi(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if age <= 0 {
0000000000000000000000000000000000000000;;				return 0, false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return time.Duration(age) * time.Second, true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0, false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expires(date, expires string) (time.Duration, bool, error) {
0000000000000000000000000000000000000000;;		if date == "" || expires == "" {
0000000000000000000000000000000000000000;;			return 0, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		te, err := time.Parse(time.RFC1123, expires)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		td, err := time.Parse(time.RFC1123, date)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ttl := te.Sub(td)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// headers indicate data already expired, caller should not
0000000000000000000000000000000000000000;;		// have to care about this case
0000000000000000000000000000000000000000;;		if ttl <= 0 {
0000000000000000000000000000000000000000;;			return 0, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ttl, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Cacheable(hdr http.Header) (time.Duration, bool, error) {
0000000000000000000000000000000000000000;;		ttl, ok, err := cacheControlMaxAge(hdr.Get("Cache-Control"))
0000000000000000000000000000000000000000;;		if err != nil || ok {
0000000000000000000000000000000000000000;;			return ttl, ok, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expires(hdr.Get("Date"), hdr.Get("Expires"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeQuery appends additional query values to an existing URL.
0000000000000000000000000000000000000000;;	func MergeQuery(u url.URL, q url.Values) url.URL {
0000000000000000000000000000000000000000;;		uv := u.Query()
0000000000000000000000000000000000000000;;		for k, vs := range q {
0000000000000000000000000000000000000000;;			for _, v := range vs {
0000000000000000000000000000000000000000;;				uv.Add(k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.RawQuery = uv.Encode()
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewResourceLocation appends a resource id to the end of the requested URL path.
0000000000000000000000000000000000000000;;	func NewResourceLocation(reqURL *url.URL, id string) string {
0000000000000000000000000000000000000000;;		var u url.URL
0000000000000000000000000000000000000000;;		u = *reqURL
0000000000000000000000000000000000000000;;		u.Path = path.Join(u.Path, id)
0000000000000000000000000000000000000000;;		u.RawQuery = ""
0000000000000000000000000000000000000000;;		u.Fragment = ""
0000000000000000000000000000000000000000;;		return u.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyRequest returns a clone of the provided *http.Request.
0000000000000000000000000000000000000000;;	// The returned object is a shallow copy of the struct and a
0000000000000000000000000000000000000000;;	// deep copy of its Header field.
0000000000000000000000000000000000000000;;	func CopyRequest(r *http.Request) *http.Request {
0000000000000000000000000000000000000000;;		r2 := *r
0000000000000000000000000000000000000000;;		r2.Header = make(http.Header)
0000000000000000000000000000000000000000;;		for k, s := range r.Header {
0000000000000000000000000000000000000000;;			r2.Header[k] = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &r2
0000000000000000000000000000000000000000;;	}
