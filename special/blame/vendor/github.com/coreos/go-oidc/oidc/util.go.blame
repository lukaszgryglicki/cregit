0000000000000000000000000000000000000000;;	package oidc
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/util.go[Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/util.go][vendor/github.com/coreos/go-oidc/oidc/util.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/jose"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequestTokenExtractor funcs extract a raw encoded token from a request.
0000000000000000000000000000000000000000;;	type RequestTokenExtractor func(r *http.Request) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractBearerToken is a RequestTokenExtractor which extracts a bearer token from a request's
0000000000000000000000000000000000000000;;	// Authorization header.
0000000000000000000000000000000000000000;;	func ExtractBearerToken(r *http.Request) (string, error) {
0000000000000000000000000000000000000000;;		ah := r.Header.Get("Authorization")
0000000000000000000000000000000000000000;;		if ah == "" {
0000000000000000000000000000000000000000;;			return "", errors.New("missing Authorization header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ah) <= 6 || strings.ToUpper(ah[0:6]) != "BEARER" {
0000000000000000000000000000000000000000;;			return "", errors.New("should be a bearer token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val := ah[7:]
0000000000000000000000000000000000000000;;		if len(val) == 0 {
0000000000000000000000000000000000000000;;			return "", errors.New("bearer token is empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return val, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CookieTokenExtractor returns a RequestTokenExtractor which extracts a token from the named cookie in a request.
0000000000000000000000000000000000000000;;	func CookieTokenExtractor(cookieName string) RequestTokenExtractor {
0000000000000000000000000000000000000000;;		return func(r *http.Request) (string, error) {
0000000000000000000000000000000000000000;;			ck, err := r.Cookie(cookieName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("token cookie not found in request: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ck.Value == "" {
0000000000000000000000000000000000000000;;				return "", errors.New("token cookie found but is empty")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ck.Value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClaims(iss, sub string, aud interface{}, iat, exp time.Time) jose.Claims {
0000000000000000000000000000000000000000;;		return jose.Claims{
0000000000000000000000000000000000000000;;			// required
0000000000000000000000000000000000000000;;			"iss": iss,
0000000000000000000000000000000000000000;;			"sub": sub,
0000000000000000000000000000000000000000;;			"aud": aud,
0000000000000000000000000000000000000000;;			"iat": iat.Unix(),
0000000000000000000000000000000000000000;;			"exp": exp.Unix(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GenClientID(hostport string) (string, error) {
0000000000000000000000000000000000000000;;		b, err := randBytes(32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var host string
0000000000000000000000000000000000000000;;		if strings.Contains(hostport, ":") {
0000000000000000000000000000000000000000;;			host, _, err = net.SplitHostPort(hostport)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			host = hostport
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s@%s", base64.URLEncoding.EncodeToString(b), host), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func randBytes(n int) ([]byte, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, n)
0000000000000000000000000000000000000000;;		got, err := rand.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if n != got {
0000000000000000000000000000000000000000;;			return nil, errors.New("unable to generate enough random data")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// urlEqual checks two urls for equality using only the host and path portions.
0000000000000000000000000000000000000000;;	func urlEqual(url1, url2 string) bool {
0000000000000000000000000000000000000000;;		u1, err := url.Parse(url1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u2, err := url.Parse(url2)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.ToLower(u1.Host+u1.Path) == strings.ToLower(u2.Host+u2.Path)
0000000000000000000000000000000000000000;;	}
