0000000000000000000000000000000000000000;;	package oidc
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/provider.go[Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/provider.go][vendor/github.com/coreos/go-oidc/oidc/provider.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/timeutil"
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		phttp "github.com/coreos/go-oidc/http"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/oauth2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Subject Identifier types defined by the OIDC spec. Specifies if the provider
0000000000000000000000000000000000000000;;		// should provide the same sub claim value to all clients (public) or a unique
0000000000000000000000000000000000000000;;		// value for each client (pairwise).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See: http://openid.net/specs/openid-connect-core-1_0.html#SubjectIDTypes
0000000000000000000000000000000000000000;;		SubjectTypePublic   = "public"
0000000000000000000000000000000000000000;;		SubjectTypePairwise = "pairwise"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Default values for omitted provider config fields.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Use ProviderConfig's Defaults method to fill a provider config with these values.
0000000000000000000000000000000000000000;;		DefaultGrantTypesSupported               = []string{oauth2.GrantTypeAuthCode, oauth2.GrantTypeImplicit}
0000000000000000000000000000000000000000;;		DefaultResponseModesSupported            = []string{"query", "fragment"}
0000000000000000000000000000000000000000;;		DefaultTokenEndpointAuthMethodsSupported = []string{oauth2.AuthMethodClientSecretBasic}
0000000000000000000000000000000000000000;;		DefaultClaimTypesSupported               = []string{"normal"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MaximumProviderConfigSyncInterval = 24 * time.Hour
0000000000000000000000000000000000000000;;		MinimumProviderConfigSyncInterval = time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		discoveryConfigPath = "/.well-known/openid-configuration"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// internally configurable for tests
0000000000000000000000000000000000000000;;	var minimumProviderConfigSyncInterval = MinimumProviderConfigSyncInterval
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Ensure ProviderConfig satisfies these interfaces.
0000000000000000000000000000000000000000;;		_ json.Marshaler   = &ProviderConfig{}
0000000000000000000000000000000000000000;;		_ json.Unmarshaler = &ProviderConfig{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProviderConfig represents the OpenID Provider Metadata specifying what
0000000000000000000000000000000000000000;;	// configurations a provider supports.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata
0000000000000000000000000000000000000000;;	type ProviderConfig struct {
0000000000000000000000000000000000000000;;		Issuer               *url.URL // Required
0000000000000000000000000000000000000000;;		AuthEndpoint         *url.URL // Required
0000000000000000000000000000000000000000;;		TokenEndpoint        *url.URL // Required if grant types other than "implicit" are supported
0000000000000000000000000000000000000000;;		UserInfoEndpoint     *url.URL
0000000000000000000000000000000000000000;;		KeysEndpoint         *url.URL // Required
0000000000000000000000000000000000000000;;		RegistrationEndpoint *url.URL
0000000000000000000000000000000000000000;;		EndSessionEndpoint   *url.URL
0000000000000000000000000000000000000000;;		CheckSessionIFrame   *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Servers MAY choose not to advertise some supported scope values even when this
0000000000000000000000000000000000000000;;		// parameter is used, although those defined in OpenID Core SHOULD be listed, if supported.
0000000000000000000000000000000000000000;;		ScopesSupported []string
0000000000000000000000000000000000000000;;		// OAuth2.0 response types supported.
0000000000000000000000000000000000000000;;		ResponseTypesSupported []string // Required
0000000000000000000000000000000000000000;;		// OAuth2.0 response modes supported.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If omitted, defaults to DefaultResponseModesSupported.
0000000000000000000000000000000000000000;;		ResponseModesSupported []string
0000000000000000000000000000000000000000;;		// OAuth2.0 grant types supported.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If omitted, defaults to DefaultGrantTypesSupported.
0000000000000000000000000000000000000000;;		GrantTypesSupported []string
0000000000000000000000000000000000000000;;		ACRValuesSupported  []string
0000000000000000000000000000000000000000;;		// SubjectTypesSupported specifies strategies for providing values for the sub claim.
0000000000000000000000000000000000000000;;		SubjectTypesSupported []string // Required
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// JWA signing and encryption algorith values supported for ID tokens.
0000000000000000000000000000000000000000;;		IDTokenSigningAlgValues    []string // Required
0000000000000000000000000000000000000000;;		IDTokenEncryptionAlgValues []string
0000000000000000000000000000000000000000;;		IDTokenEncryptionEncValues []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// JWA signing and encryption algorith values supported for user info responses.
0000000000000000000000000000000000000000;;		UserInfoSigningAlgValues    []string
0000000000000000000000000000000000000000;;		UserInfoEncryptionAlgValues []string
0000000000000000000000000000000000000000;;		UserInfoEncryptionEncValues []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// JWA signing and encryption algorith values supported for request objects.
0000000000000000000000000000000000000000;;		ReqObjSigningAlgValues    []string
0000000000000000000000000000000000000000;;		ReqObjEncryptionAlgValues []string
0000000000000000000000000000000000000000;;		ReqObjEncryptionEncValues []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TokenEndpointAuthMethodsSupported          []string
0000000000000000000000000000000000000000;;		TokenEndpointAuthSigningAlgValuesSupported []string
0000000000000000000000000000000000000000;;		DisplayValuesSupported                     []string
0000000000000000000000000000000000000000;;		ClaimTypesSupported                        []string
0000000000000000000000000000000000000000;;		ClaimsSupported                            []string
0000000000000000000000000000000000000000;;		ServiceDocs                                *url.URL
0000000000000000000000000000000000000000;;		ClaimsLocalsSupported                      []string
0000000000000000000000000000000000000000;;		UILocalsSupported                          []string
0000000000000000000000000000000000000000;;		ClaimsParameterSupported                   bool
0000000000000000000000000000000000000000;;		RequestParameterSupported                  bool
0000000000000000000000000000000000000000;;		RequestURIParamaterSupported               bool
0000000000000000000000000000000000000000;;		RequireRequestURIRegistration              bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Policy         *url.URL
0000000000000000000000000000000000000000;;		TermsOfService *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Not part of the OpenID Provider Metadata
0000000000000000000000000000000000000000;;		ExpiresAt time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Defaults returns a shallow copy of ProviderConfig with default
0000000000000000000000000000000000000000;;	// values replacing omitted fields.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     var cfg oidc.ProviderConfig
0000000000000000000000000000000000000000;;	//     // Fill provider config with default values for omitted fields.
0000000000000000000000000000000000000000;;	//     cfg = cfg.Defaults()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (p ProviderConfig) Defaults() ProviderConfig {
0000000000000000000000000000000000000000;;		setDefault := func(val *[]string, defaultVal []string) {
0000000000000000000000000000000000000000;;			if len(*val) == 0 {
0000000000000000000000000000000000000000;;				*val = defaultVal
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setDefault(&p.GrantTypesSupported, DefaultGrantTypesSupported)
0000000000000000000000000000000000000000;;		setDefault(&p.ResponseModesSupported, DefaultResponseModesSupported)
0000000000000000000000000000000000000000;;		setDefault(&p.TokenEndpointAuthMethodsSupported, DefaultTokenEndpointAuthMethodsSupported)
0000000000000000000000000000000000000000;;		setDefault(&p.ClaimTypesSupported, DefaultClaimTypesSupported)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ProviderConfig) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		e := p.toEncodableStruct()
0000000000000000000000000000000000000000;;		return json.Marshal(&e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ProviderConfig) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var e encodableProviderConfig
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &e); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		conf, err := e.toStruct()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := conf.Valid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*p = conf
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encodableProviderConfig struct {
0000000000000000000000000000000000000000;;		Issuer               string `json:"issuer"`
0000000000000000000000000000000000000000;;		AuthEndpoint         string `json:"authorization_endpoint"`
0000000000000000000000000000000000000000;;		TokenEndpoint        string `json:"token_endpoint"`
0000000000000000000000000000000000000000;;		UserInfoEndpoint     string `json:"userinfo_endpoint,omitempty"`
0000000000000000000000000000000000000000;;		KeysEndpoint         string `json:"jwks_uri"`
0000000000000000000000000000000000000000;;		RegistrationEndpoint string `json:"registration_endpoint,omitempty"`
0000000000000000000000000000000000000000;;		EndSessionEndpoint   string `json:"end_session_endpoint,omitempty"`
0000000000000000000000000000000000000000;;		CheckSessionIFrame   string `json:"check_session_iframe,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use 'omitempty' for all slices as per OIDC spec:
0000000000000000000000000000000000000000;;		// "Claims that return multiple values are represented as JSON arrays.
0000000000000000000000000000000000000000;;		// Claims with zero elements MUST be omitted from the response."
0000000000000000000000000000000000000000;;		// http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationResponse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ScopesSupported        []string `json:"scopes_supported,omitempty"`
0000000000000000000000000000000000000000;;		ResponseTypesSupported []string `json:"response_types_supported,omitempty"`
0000000000000000000000000000000000000000;;		ResponseModesSupported []string `json:"response_modes_supported,omitempty"`
0000000000000000000000000000000000000000;;		GrantTypesSupported    []string `json:"grant_types_supported,omitempty"`
0000000000000000000000000000000000000000;;		ACRValuesSupported     []string `json:"acr_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		SubjectTypesSupported  []string `json:"subject_types_supported,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		IDTokenSigningAlgValues     []string `json:"id_token_signing_alg_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		IDTokenEncryptionAlgValues  []string `json:"id_token_encryption_alg_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		IDTokenEncryptionEncValues  []string `json:"id_token_encryption_enc_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		UserInfoSigningAlgValues    []string `json:"userinfo_signing_alg_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		UserInfoEncryptionAlgValues []string `json:"userinfo_encryption_alg_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		UserInfoEncryptionEncValues []string `json:"userinfo_encryption_enc_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		ReqObjSigningAlgValues      []string `json:"request_object_signing_alg_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		ReqObjEncryptionAlgValues   []string `json:"request_object_encryption_alg_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		ReqObjEncryptionEncValues   []string `json:"request_object_encryption_enc_values_supported,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TokenEndpointAuthMethodsSupported          []string `json:"token_endpoint_auth_methods_supported,omitempty"`
0000000000000000000000000000000000000000;;		TokenEndpointAuthSigningAlgValuesSupported []string `json:"token_endpoint_auth_signing_alg_values_supported,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DisplayValuesSupported        []string `json:"display_values_supported,omitempty"`
0000000000000000000000000000000000000000;;		ClaimTypesSupported           []string `json:"claim_types_supported,omitempty"`
0000000000000000000000000000000000000000;;		ClaimsSupported               []string `json:"claims_supported,omitempty"`
0000000000000000000000000000000000000000;;		ServiceDocs                   string   `json:"service_documentation,omitempty"`
0000000000000000000000000000000000000000;;		ClaimsLocalsSupported         []string `json:"claims_locales_supported,omitempty"`
0000000000000000000000000000000000000000;;		UILocalsSupported             []string `json:"ui_locales_supported,omitempty"`
0000000000000000000000000000000000000000;;		ClaimsParameterSupported      bool     `json:"claims_parameter_supported,omitempty"`
0000000000000000000000000000000000000000;;		RequestParameterSupported     bool     `json:"request_parameter_supported,omitempty"`
0000000000000000000000000000000000000000;;		RequestURIParamaterSupported  bool     `json:"request_uri_parameter_supported,omitempty"`
0000000000000000000000000000000000000000;;		RequireRequestURIRegistration bool     `json:"require_request_uri_registration,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Policy         string `json:"op_policy_uri,omitempty"`
0000000000000000000000000000000000000000;;		TermsOfService string `json:"op_tos_uri,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cfg ProviderConfig) toEncodableStruct() encodableProviderConfig {
0000000000000000000000000000000000000000;;		return encodableProviderConfig{
0000000000000000000000000000000000000000;;			Issuer:                                     uriToString(cfg.Issuer),
0000000000000000000000000000000000000000;;			AuthEndpoint:                               uriToString(cfg.AuthEndpoint),
0000000000000000000000000000000000000000;;			TokenEndpoint:                              uriToString(cfg.TokenEndpoint),
0000000000000000000000000000000000000000;;			UserInfoEndpoint:                           uriToString(cfg.UserInfoEndpoint),
0000000000000000000000000000000000000000;;			KeysEndpoint:                               uriToString(cfg.KeysEndpoint),
0000000000000000000000000000000000000000;;			RegistrationEndpoint:                       uriToString(cfg.RegistrationEndpoint),
0000000000000000000000000000000000000000;;			EndSessionEndpoint:                         uriToString(cfg.EndSessionEndpoint),
0000000000000000000000000000000000000000;;			CheckSessionIFrame:                         uriToString(cfg.CheckSessionIFrame),
0000000000000000000000000000000000000000;;			ScopesSupported:                            cfg.ScopesSupported,
0000000000000000000000000000000000000000;;			ResponseTypesSupported:                     cfg.ResponseTypesSupported,
0000000000000000000000000000000000000000;;			ResponseModesSupported:                     cfg.ResponseModesSupported,
0000000000000000000000000000000000000000;;			GrantTypesSupported:                        cfg.GrantTypesSupported,
0000000000000000000000000000000000000000;;			ACRValuesSupported:                         cfg.ACRValuesSupported,
0000000000000000000000000000000000000000;;			SubjectTypesSupported:                      cfg.SubjectTypesSupported,
0000000000000000000000000000000000000000;;			IDTokenSigningAlgValues:                    cfg.IDTokenSigningAlgValues,
0000000000000000000000000000000000000000;;			IDTokenEncryptionAlgValues:                 cfg.IDTokenEncryptionAlgValues,
0000000000000000000000000000000000000000;;			IDTokenEncryptionEncValues:                 cfg.IDTokenEncryptionEncValues,
0000000000000000000000000000000000000000;;			UserInfoSigningAlgValues:                   cfg.UserInfoSigningAlgValues,
0000000000000000000000000000000000000000;;			UserInfoEncryptionAlgValues:                cfg.UserInfoEncryptionAlgValues,
0000000000000000000000000000000000000000;;			UserInfoEncryptionEncValues:                cfg.UserInfoEncryptionEncValues,
0000000000000000000000000000000000000000;;			ReqObjSigningAlgValues:                     cfg.ReqObjSigningAlgValues,
0000000000000000000000000000000000000000;;			ReqObjEncryptionAlgValues:                  cfg.ReqObjEncryptionAlgValues,
0000000000000000000000000000000000000000;;			ReqObjEncryptionEncValues:                  cfg.ReqObjEncryptionEncValues,
0000000000000000000000000000000000000000;;			TokenEndpointAuthMethodsSupported:          cfg.TokenEndpointAuthMethodsSupported,
0000000000000000000000000000000000000000;;			TokenEndpointAuthSigningAlgValuesSupported: cfg.TokenEndpointAuthSigningAlgValuesSupported,
0000000000000000000000000000000000000000;;			DisplayValuesSupported:                     cfg.DisplayValuesSupported,
0000000000000000000000000000000000000000;;			ClaimTypesSupported:                        cfg.ClaimTypesSupported,
0000000000000000000000000000000000000000;;			ClaimsSupported:                            cfg.ClaimsSupported,
0000000000000000000000000000000000000000;;			ServiceDocs:                                uriToString(cfg.ServiceDocs),
0000000000000000000000000000000000000000;;			ClaimsLocalsSupported:                      cfg.ClaimsLocalsSupported,
0000000000000000000000000000000000000000;;			UILocalsSupported:                          cfg.UILocalsSupported,
0000000000000000000000000000000000000000;;			ClaimsParameterSupported:                   cfg.ClaimsParameterSupported,
0000000000000000000000000000000000000000;;			RequestParameterSupported:                  cfg.RequestParameterSupported,
0000000000000000000000000000000000000000;;			RequestURIParamaterSupported:               cfg.RequestURIParamaterSupported,
0000000000000000000000000000000000000000;;			RequireRequestURIRegistration:              cfg.RequireRequestURIRegistration,
0000000000000000000000000000000000000000;;			Policy:         uriToString(cfg.Policy),
0000000000000000000000000000000000000000;;			TermsOfService: uriToString(cfg.TermsOfService),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e encodableProviderConfig) toStruct() (ProviderConfig, error) {
0000000000000000000000000000000000000000;;		p := stickyErrParser{}
0000000000000000000000000000000000000000;;		conf := ProviderConfig{
0000000000000000000000000000000000000000;;			Issuer:                                     p.parseURI(e.Issuer, "issuer"),
0000000000000000000000000000000000000000;;			AuthEndpoint:                               p.parseURI(e.AuthEndpoint, "authorization_endpoint"),
0000000000000000000000000000000000000000;;			TokenEndpoint:                              p.parseURI(e.TokenEndpoint, "token_endpoint"),
0000000000000000000000000000000000000000;;			UserInfoEndpoint:                           p.parseURI(e.UserInfoEndpoint, "userinfo_endpoint"),
0000000000000000000000000000000000000000;;			KeysEndpoint:                               p.parseURI(e.KeysEndpoint, "jwks_uri"),
0000000000000000000000000000000000000000;;			RegistrationEndpoint:                       p.parseURI(e.RegistrationEndpoint, "registration_endpoint"),
0000000000000000000000000000000000000000;;			EndSessionEndpoint:                         p.parseURI(e.EndSessionEndpoint, "end_session_endpoint"),
0000000000000000000000000000000000000000;;			CheckSessionIFrame:                         p.parseURI(e.CheckSessionIFrame, "check_session_iframe"),
0000000000000000000000000000000000000000;;			ScopesSupported:                            e.ScopesSupported,
0000000000000000000000000000000000000000;;			ResponseTypesSupported:                     e.ResponseTypesSupported,
0000000000000000000000000000000000000000;;			ResponseModesSupported:                     e.ResponseModesSupported,
0000000000000000000000000000000000000000;;			GrantTypesSupported:                        e.GrantTypesSupported,
0000000000000000000000000000000000000000;;			ACRValuesSupported:                         e.ACRValuesSupported,
0000000000000000000000000000000000000000;;			SubjectTypesSupported:                      e.SubjectTypesSupported,
0000000000000000000000000000000000000000;;			IDTokenSigningAlgValues:                    e.IDTokenSigningAlgValues,
0000000000000000000000000000000000000000;;			IDTokenEncryptionAlgValues:                 e.IDTokenEncryptionAlgValues,
0000000000000000000000000000000000000000;;			IDTokenEncryptionEncValues:                 e.IDTokenEncryptionEncValues,
0000000000000000000000000000000000000000;;			UserInfoSigningAlgValues:                   e.UserInfoSigningAlgValues,
0000000000000000000000000000000000000000;;			UserInfoEncryptionAlgValues:                e.UserInfoEncryptionAlgValues,
0000000000000000000000000000000000000000;;			UserInfoEncryptionEncValues:                e.UserInfoEncryptionEncValues,
0000000000000000000000000000000000000000;;			ReqObjSigningAlgValues:                     e.ReqObjSigningAlgValues,
0000000000000000000000000000000000000000;;			ReqObjEncryptionAlgValues:                  e.ReqObjEncryptionAlgValues,
0000000000000000000000000000000000000000;;			ReqObjEncryptionEncValues:                  e.ReqObjEncryptionEncValues,
0000000000000000000000000000000000000000;;			TokenEndpointAuthMethodsSupported:          e.TokenEndpointAuthMethodsSupported,
0000000000000000000000000000000000000000;;			TokenEndpointAuthSigningAlgValuesSupported: e.TokenEndpointAuthSigningAlgValuesSupported,
0000000000000000000000000000000000000000;;			DisplayValuesSupported:                     e.DisplayValuesSupported,
0000000000000000000000000000000000000000;;			ClaimTypesSupported:                        e.ClaimTypesSupported,
0000000000000000000000000000000000000000;;			ClaimsSupported:                            e.ClaimsSupported,
0000000000000000000000000000000000000000;;			ServiceDocs:                                p.parseURI(e.ServiceDocs, "service_documentation"),
0000000000000000000000000000000000000000;;			ClaimsLocalsSupported:                      e.ClaimsLocalsSupported,
0000000000000000000000000000000000000000;;			UILocalsSupported:                          e.UILocalsSupported,
0000000000000000000000000000000000000000;;			ClaimsParameterSupported:                   e.ClaimsParameterSupported,
0000000000000000000000000000000000000000;;			RequestParameterSupported:                  e.RequestParameterSupported,
0000000000000000000000000000000000000000;;			RequestURIParamaterSupported:               e.RequestURIParamaterSupported,
0000000000000000000000000000000000000000;;			RequireRequestURIRegistration:              e.RequireRequestURIRegistration,
0000000000000000000000000000000000000000;;			Policy:         p.parseURI(e.Policy, "op_policy-uri"),
0000000000000000000000000000000000000000;;			TermsOfService: p.parseURI(e.TermsOfService, "op_tos_uri"),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.firstErr != nil {
0000000000000000000000000000000000000000;;			return ProviderConfig{}, p.firstErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Empty returns if a ProviderConfig holds no information.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This case generally indicates a ProviderConfigGetter has experienced an error
0000000000000000000000000000000000000000;;	// and has nothing to report.
0000000000000000000000000000000000000000;;	func (p ProviderConfig) Empty() bool {
0000000000000000000000000000000000000000;;		return p.Issuer == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func contains(sli []string, ele string) bool {
0000000000000000000000000000000000000000;;		for _, s := range sli {
0000000000000000000000000000000000000000;;			if s == ele {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid determines if a ProviderConfig conforms with the OIDC specification.
0000000000000000000000000000000000000000;;	// If Valid returns successfully it guarantees required field are non-nil and
0000000000000000000000000000000000000000;;	// URLs are well formed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Valid is called by UnmarshalJSON.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE(ericchiang): For development purposes Valid does not mandate 'https' for
0000000000000000000000000000000000000000;;	// URLs fields where the OIDC spec requires it. This may change in future releases
0000000000000000000000000000000000000000;;	// of this package. See: https://github.com/coreos/go-oidc/issues/34
0000000000000000000000000000000000000000;;	func (p ProviderConfig) Valid() error {
0000000000000000000000000000000000000000;;		grantTypes := p.GrantTypesSupported
0000000000000000000000000000000000000000;;		if len(grantTypes) == 0 {
0000000000000000000000000000000000000000;;			grantTypes = DefaultGrantTypesSupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		implicitOnly := true
0000000000000000000000000000000000000000;;		for _, grantType := range grantTypes {
0000000000000000000000000000000000000000;;			if grantType != oauth2.GrantTypeImplicit {
0000000000000000000000000000000000000000;;				implicitOnly = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(p.SubjectTypesSupported) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("missing required field subject_types_supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.IDTokenSigningAlgValues) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("missing required field id_token_signing_alg_values_supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(p.ScopesSupported) != 0 && !contains(p.ScopesSupported, "openid") {
0000000000000000000000000000000000000000;;			return errors.New("scoped_supported must be unspecified or include 'openid'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !contains(p.IDTokenSigningAlgValues, "RS256") {
0000000000000000000000000000000000000000;;			return errors.New("id_token_signing_alg_values_supported must include 'RS256'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uris := []struct {
0000000000000000000000000000000000000000;;			val      *url.URL
0000000000000000000000000000000000000000;;			name     string
0000000000000000000000000000000000000000;;			required bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{p.Issuer, "issuer", true},
0000000000000000000000000000000000000000;;			{p.AuthEndpoint, "authorization_endpoint", true},
0000000000000000000000000000000000000000;;			{p.TokenEndpoint, "token_endpoint", !implicitOnly},
0000000000000000000000000000000000000000;;			{p.UserInfoEndpoint, "userinfo_endpoint", false},
0000000000000000000000000000000000000000;;			{p.KeysEndpoint, "jwks_uri", true},
0000000000000000000000000000000000000000;;			{p.RegistrationEndpoint, "registration_endpoint", false},
0000000000000000000000000000000000000000;;			{p.EndSessionEndpoint, "end_session_endpoint", false},
0000000000000000000000000000000000000000;;			{p.CheckSessionIFrame, "check_session_iframe", false},
0000000000000000000000000000000000000000;;			{p.ServiceDocs, "service_documentation", false},
0000000000000000000000000000000000000000;;			{p.Policy, "op_policy_uri", false},
0000000000000000000000000000000000000000;;			{p.TermsOfService, "op_tos_uri", false},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, uri := range uris {
0000000000000000000000000000000000000000;;			if uri.val == nil {
0000000000000000000000000000000000000000;;				if !uri.required {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("empty value for required uri field %s", uri.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if uri.val.Host == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("no host for uri field %s", uri.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if uri.val.Scheme != "http" && uri.val.Scheme != "https" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("uri field %s schemeis not http or https", uri.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Supports determines if provider supports a client given their respective metadata.
0000000000000000000000000000000000000000;;	func (p ProviderConfig) Supports(c ClientMetadata) error {
0000000000000000000000000000000000000000;;		if err := p.Valid(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid provider config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := c.Valid(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid client config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill default values for omitted fields
0000000000000000000000000000000000000000;;		c = c.Defaults()
0000000000000000000000000000000000000000;;		p = p.Defaults()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do the supported values list the requested one?
0000000000000000000000000000000000000000;;		supports := []struct {
0000000000000000000000000000000000000000;;			supported []string
0000000000000000000000000000000000000000;;			requested string
0000000000000000000000000000000000000000;;			name      string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{p.IDTokenSigningAlgValues, c.IDTokenResponseOptions.SigningAlg, "id_token_signed_response_alg"},
0000000000000000000000000000000000000000;;			{p.IDTokenEncryptionAlgValues, c.IDTokenResponseOptions.EncryptionAlg, "id_token_encryption_response_alg"},
0000000000000000000000000000000000000000;;			{p.IDTokenEncryptionEncValues, c.IDTokenResponseOptions.EncryptionEnc, "id_token_encryption_response_enc"},
0000000000000000000000000000000000000000;;			{p.UserInfoSigningAlgValues, c.UserInfoResponseOptions.SigningAlg, "userinfo_signed_response_alg"},
0000000000000000000000000000000000000000;;			{p.UserInfoEncryptionAlgValues, c.UserInfoResponseOptions.EncryptionAlg, "userinfo_encryption_response_alg"},
0000000000000000000000000000000000000000;;			{p.UserInfoEncryptionEncValues, c.UserInfoResponseOptions.EncryptionEnc, "userinfo_encryption_response_enc"},
0000000000000000000000000000000000000000;;			{p.ReqObjSigningAlgValues, c.RequestObjectOptions.SigningAlg, "request_object_signing_alg"},
0000000000000000000000000000000000000000;;			{p.ReqObjEncryptionAlgValues, c.RequestObjectOptions.EncryptionAlg, "request_object_encryption_alg"},
0000000000000000000000000000000000000000;;			{p.ReqObjEncryptionEncValues, c.RequestObjectOptions.EncryptionEnc, "request_object_encryption_enc"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, field := range supports {
0000000000000000000000000000000000000000;;			if field.requested == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !contains(field.supported, field.requested) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("provider does not support requested value for field %s", field.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stringsEqual := func(s1, s2 string) bool { return s1 == s2 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For lists, are the list of requested values a subset of the supported ones?
0000000000000000000000000000000000000000;;		supportsAll := []struct {
0000000000000000000000000000000000000000;;			supported []string
0000000000000000000000000000000000000000;;			requested []string
0000000000000000000000000000000000000000;;			name      string
0000000000000000000000000000000000000000;;			// OAuth2.0 response_type can be space separated lists where order doesn't matter.
0000000000000000000000000000000000000000;;			// For example "id_token token" is the same as "token id_token"
0000000000000000000000000000000000000000;;			// Support a custom compare method.
0000000000000000000000000000000000000000;;			comp func(s1, s2 string) bool
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{p.GrantTypesSupported, c.GrantTypes, "grant_types", stringsEqual},
0000000000000000000000000000000000000000;;			{p.ResponseTypesSupported, c.ResponseTypes, "response_type", oauth2.ResponseTypesEqual},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, field := range supportsAll {
0000000000000000000000000000000000000000;;		requestLoop:
0000000000000000000000000000000000000000;;			for _, req := range field.requested {
0000000000000000000000000000000000000000;;				for _, sup := range field.supported {
0000000000000000000000000000000000000000;;					if field.comp(req, sup) {
0000000000000000000000000000000000000000;;						continue requestLoop
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt.Errorf("provider does not support requested value for field %s", field.name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(ericchiang): Are there more checks we feel comfortable with begin strict about?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p ProviderConfig) SupportsGrantType(grantType string) bool {
0000000000000000000000000000000000000000;;		var supported []string
0000000000000000000000000000000000000000;;		if len(p.GrantTypesSupported) == 0 {
0000000000000000000000000000000000000000;;			supported = DefaultGrantTypesSupported
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			supported = p.GrantTypesSupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, t := range supported {
0000000000000000000000000000000000000000;;			if t == grantType {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ProviderConfigGetter interface {
0000000000000000000000000000000000000000;;		Get() (ProviderConfig, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ProviderConfigSetter interface {
0000000000000000000000000000000000000000;;		Set(ProviderConfig) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ProviderConfigSyncer struct {
0000000000000000000000000000000000000000;;		from  ProviderConfigGetter
0000000000000000000000000000000000000000;;		to    ProviderConfigSetter
0000000000000000000000000000000000000000;;		clock clockwork.Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		initialSyncDone bool
0000000000000000000000000000000000000000;;		initialSyncWait sync.WaitGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewProviderConfigSyncer(from ProviderConfigGetter, to ProviderConfigSetter) *ProviderConfigSyncer {
0000000000000000000000000000000000000000;;		return &ProviderConfigSyncer{
0000000000000000000000000000000000000000;;			from:  from,
0000000000000000000000000000000000000000;;			to:    to,
0000000000000000000000000000000000000000;;			clock: clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ProviderConfigSyncer) Run() chan struct{} {
0000000000000000000000000000000000000000;;		stop := make(chan struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var next pcsStepper
0000000000000000000000000000000000000000;;		next = &pcsStepNext{aft: time.Duration(0)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.initialSyncWait.Add(1)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-s.clock.After(next.after()):
0000000000000000000000000000000000000000;;					next = next.step(s.sync)
0000000000000000000000000000000000000000;;				case <-stop:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ProviderConfigSyncer) WaitUntilInitialSync() {
0000000000000000000000000000000000000000;;		s.initialSyncWait.Wait()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *ProviderConfigSyncer) sync() (time.Duration, error) {
0000000000000000000000000000000000000000;;		cfg, err := s.from.Get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = s.to.Set(cfg); err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("error setting provider config: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.initialSyncDone {
0000000000000000000000000000000000000000;;			s.initialSyncWait.Done()
0000000000000000000000000000000000000000;;			s.initialSyncDone = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nextSyncAfter(cfg.ExpiresAt, s.clock), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pcsStepFunc func() (time.Duration, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pcsStepper interface {
0000000000000000000000000000000000000000;;		after() time.Duration
0000000000000000000000000000000000000000;;		step(pcsStepFunc) pcsStepper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pcsStepNext struct {
0000000000000000000000000000000000000000;;		aft time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *pcsStepNext) after() time.Duration {
0000000000000000000000000000000000000000;;		return n.aft
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *pcsStepNext) step(fn pcsStepFunc) (next pcsStepper) {
0000000000000000000000000000000000000000;;		ttl, err := fn()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			next = &pcsStepNext{aft: ttl}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			next = &pcsStepRetry{aft: time.Second}
0000000000000000000000000000000000000000;;			log.Printf("go-oidc: provider config sync failed, retrying in %v: %v", next.after(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pcsStepRetry struct {
0000000000000000000000000000000000000000;;		aft time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *pcsStepRetry) after() time.Duration {
0000000000000000000000000000000000000000;;		return r.aft
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *pcsStepRetry) step(fn pcsStepFunc) (next pcsStepper) {
0000000000000000000000000000000000000000;;		ttl, err := fn()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			next = &pcsStepNext{aft: ttl}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			next = &pcsStepRetry{aft: timeutil.ExpBackoff(r.aft, time.Minute)}
0000000000000000000000000000000000000000;;			log.Printf("go-oidc: provider config sync failed, retrying in %v: %v", next.after(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextSyncAfter(exp time.Time, clock clockwork.Clock) time.Duration {
0000000000000000000000000000000000000000;;		if exp.IsZero() {
0000000000000000000000000000000000000000;;			return MaximumProviderConfigSyncInterval
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := exp.Sub(clock.Now()) / 2
0000000000000000000000000000000000000000;;		if t > MaximumProviderConfigSyncInterval {
0000000000000000000000000000000000000000;;			t = MaximumProviderConfigSyncInterval
0000000000000000000000000000000000000000;;		} else if t < minimumProviderConfigSyncInterval {
0000000000000000000000000000000000000000;;			t = minimumProviderConfigSyncInterval
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type httpProviderConfigGetter struct {
0000000000000000000000000000000000000000;;		hc        phttp.Client
0000000000000000000000000000000000000000;;		issuerURL string
0000000000000000000000000000000000000000;;		clock     clockwork.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHTTPProviderConfigGetter(hc phttp.Client, issuerURL string) *httpProviderConfigGetter {
0000000000000000000000000000000000000000;;		return &httpProviderConfigGetter{
0000000000000000000000000000000000000000;;			hc:        hc,
0000000000000000000000000000000000000000;;			issuerURL: issuerURL,
0000000000000000000000000000000000000000;;			clock:     clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *httpProviderConfigGetter) Get() (cfg ProviderConfig, err error) {
0000000000000000000000000000000000000000;;		// If the Issuer value contains a path component, any terminating / MUST be removed before
0000000000000000000000000000000000000000;;		// appending /.well-known/openid-configuration.
0000000000000000000000000000000000000000;;		// https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationRequest
0000000000000000000000000000000000000000;;		discoveryURL := strings.TrimSuffix(r.issuerURL, "/") + discoveryConfigPath
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", discoveryURL, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := r.hc.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = json.NewDecoder(resp.Body).Decode(&cfg); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ttl time.Duration
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		ttl, ok, err = phttp.Cacheable(resp.Header)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if ok {
0000000000000000000000000000000000000000;;			cfg.ExpiresAt = r.clock.Now().UTC().Add(ttl)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The issuer value returned MUST be identical to the Issuer URL that was directly used to retrieve the configuration information.
0000000000000000000000000000000000000000;;		// http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationValidation
0000000000000000000000000000000000000000;;		if !urlEqual(cfg.Issuer.String(), r.issuerURL) {
0000000000000000000000000000000000000000;;			err = fmt.Errorf(`"issuer" in config (%v) does not match provided issuer URL (%v)`, cfg.Issuer, r.issuerURL)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FetchProviderConfig(hc phttp.Client, issuerURL string) (ProviderConfig, error) {
0000000000000000000000000000000000000000;;		if hc == nil {
0000000000000000000000000000000000000000;;			hc = http.DefaultClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g := NewHTTPProviderConfigGetter(hc, issuerURL)
0000000000000000000000000000000000000000;;		return g.Get()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WaitForProviderConfig(hc phttp.Client, issuerURL string) (pcfg ProviderConfig) {
0000000000000000000000000000000000000000;;		return waitForProviderConfig(hc, issuerURL, clockwork.NewRealClock())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitForProviderConfig(hc phttp.Client, issuerURL string, clock clockwork.Clock) (pcfg ProviderConfig) {
0000000000000000000000000000000000000000;;		var sleep time.Duration
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			pcfg, err = FetchProviderConfig(hc, issuerURL)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sleep = timeutil.ExpBackoff(sleep, time.Minute)
0000000000000000000000000000000000000000;;			fmt.Printf("Failed fetching provider config, trying again in %v: %v\n", sleep, err)
0000000000000000000000000000000000000000;;			time.Sleep(sleep)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
