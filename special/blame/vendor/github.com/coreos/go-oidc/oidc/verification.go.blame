0000000000000000000000000000000000000000;;	package oidc
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/verification.go[Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/verification.go][vendor/github.com/coreos/go-oidc/oidc/verification.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/jonboulle/clockwork"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/jose"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/key"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VerifySignature(jwt jose.JWT, keys []key.PublicKey) (bool, error) {
0000000000000000000000000000000000000000;;		jwtBytes := []byte(jwt.Data())
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			v, err := k.Verifier()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.Verify(jwt.Signature, jwtBytes) == nil {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// containsString returns true if the given string(needle) is found
0000000000000000000000000000000000000000;;	// in the string array(haystack).
0000000000000000000000000000000000000000;;	func containsString(needle string, haystack []string) bool {
0000000000000000000000000000000000000000;;		for _, v := range haystack {
0000000000000000000000000000000000000000;;			if v == needle {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify claims in accordance with OIDC spec
0000000000000000000000000000000000000000;;	// http://openid.net/specs/openid-connect-basic-1_0.html#IDTokenValidation
0000000000000000000000000000000000000000;;	func VerifyClaims(jwt jose.JWT, issuer, clientID string) error {
0000000000000000000000000000000000000000;;		now := time.Now().UTC()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		claims, err := jwt.Claims()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ident, err := IdentityFromClaims(claims)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ident.ExpiresAt.Before(now) {
0000000000000000000000000000000000000000;;			return errors.New("token is expired")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// iss REQUIRED. Issuer Identifier for the Issuer of the response.
0000000000000000000000000000000000000000;;		// The iss value is a case sensitive URL using the https scheme that contains scheme,
0000000000000000000000000000000000000000;;		// host, and optionally, port number and path components and no query or fragment components.
0000000000000000000000000000000000000000;;		if iss, exists := claims["iss"].(string); exists {
0000000000000000000000000000000000000000;;			if !urlEqual(iss, issuer) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid claim value: 'iss'. expected=%s, found=%s.", issuer, iss)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return errors.New("missing claim: 'iss'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// iat REQUIRED. Time at which the JWT was issued.
0000000000000000000000000000000000000000;;		// Its value is a JSON number representing the number of seconds from 1970-01-01T0:0:0Z
0000000000000000000000000000000000000000;;		// as measured in UTC until the date/time.
0000000000000000000000000000000000000000;;		if _, exists := claims["iat"].(float64); !exists {
0000000000000000000000000000000000000000;;			return errors.New("missing claim: 'iat'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// aud REQUIRED. Audience(s) that this ID Token is intended for.
0000000000000000000000000000000000000000;;		// It MUST contain the OAuth 2.0 client_id of the Relying Party as an audience value.
0000000000000000000000000000000000000000;;		// It MAY also contain identifiers for other audiences. In the general case, the aud
0000000000000000000000000000000000000000;;		// value is an array of case sensitive strings. In the common special case when there
0000000000000000000000000000000000000000;;		// is one audience, the aud value MAY be a single case sensitive string.
0000000000000000000000000000000000000000;;		if aud, ok, err := claims.StringClaim("aud"); err == nil && ok {
0000000000000000000000000000000000000000;;			if aud != clientID {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid claims, 'aud' claim and 'client_id' do not match, aud=%s, client_id=%s", aud, clientID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if aud, ok, err := claims.StringsClaim("aud"); err == nil && ok {
0000000000000000000000000000000000000000;;			if !containsString(clientID, aud) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid claims, cannot find 'client_id' in 'aud' claim, aud=%v, client_id=%s", aud, clientID)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return errors.New("invalid claim value: 'aud' is required, and should be either string or string array")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyClientClaims verifies all the required claims are valid for a "client credentials" JWT.
0000000000000000000000000000000000000000;;	// Returns the client ID if valid, or an error if invalid.
0000000000000000000000000000000000000000;;	func VerifyClientClaims(jwt jose.JWT, issuer string) (string, error) {
0000000000000000000000000000000000000000;;		claims, err := jwt.Claims()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to parse JWT claims: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iss, ok, err := claims.StringClaim("iss")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to parse 'iss' claim: %v", err)
0000000000000000000000000000000000000000;;		} else if !ok {
0000000000000000000000000000000000000000;;			return "", errors.New("missing required 'iss' claim")
0000000000000000000000000000000000000000;;		} else if !urlEqual(iss, issuer) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("'iss' claim does not match expected issuer, iss=%s", iss)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sub, ok, err := claims.StringClaim("sub")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to parse 'sub' claim: %v", err)
0000000000000000000000000000000000000000;;		} else if !ok {
0000000000000000000000000000000000000000;;			return "", errors.New("missing required 'sub' claim")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if aud, ok, err := claims.StringClaim("aud"); err == nil && ok {
0000000000000000000000000000000000000000;;			if aud != sub {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("invalid claims, 'aud' claim and 'sub' claim do not match, aud=%s, sub=%s", aud, sub)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if aud, ok, err := claims.StringsClaim("aud"); err == nil && ok {
0000000000000000000000000000000000000000;;			if !containsString(sub, aud) {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("invalid claims, cannot find 'sud' in 'aud' claim, aud=%v, sub=%s", aud, sub)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "", errors.New("invalid claim value: 'aud' is required, and should be either string or string array")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now().UTC()
0000000000000000000000000000000000000000;;		exp, ok, err := claims.TimeClaim("exp")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to parse 'exp' claim: %v", err)
0000000000000000000000000000000000000000;;		} else if !ok {
0000000000000000000000000000000000000000;;			return "", errors.New("missing required 'exp' claim")
0000000000000000000000000000000000000000;;		} else if exp.Before(now) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("token already expired at: %v", exp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sub, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JWTVerifier struct {
0000000000000000000000000000000000000000;;		issuer   string
0000000000000000000000000000000000000000;;		clientID string
0000000000000000000000000000000000000000;;		syncFunc func() error
0000000000000000000000000000000000000000;;		keysFunc func() []key.PublicKey
0000000000000000000000000000000000000000;;		clock    clockwork.Clock
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewJWTVerifier(issuer, clientID string, syncFunc func() error, keysFunc func() []key.PublicKey) JWTVerifier {
0000000000000000000000000000000000000000;;		return JWTVerifier{
0000000000000000000000000000000000000000;;			issuer:   issuer,
0000000000000000000000000000000000000000;;			clientID: clientID,
0000000000000000000000000000000000000000;;			syncFunc: syncFunc,
0000000000000000000000000000000000000000;;			keysFunc: keysFunc,
0000000000000000000000000000000000000000;;			clock:    clockwork.NewRealClock(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *JWTVerifier) Verify(jwt jose.JWT) error {
0000000000000000000000000000000000000000;;		// Verify claims before verifying the signature. This is an optimization to throw out
0000000000000000000000000000000000000000;;		// tokens we know are invalid without undergoing an expensive signature check and
0000000000000000000000000000000000000000;;		// possibly a re-sync event.
0000000000000000000000000000000000000000;;		if err := VerifyClaims(jwt, v.issuer, v.clientID); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("oidc: JWT claims invalid: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err := VerifySignature(jwt, v.keysFunc())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("oidc: JWT signature verification failed: %v", err)
0000000000000000000000000000000000000000;;		} else if ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = v.syncFunc(); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("oidc: failed syncing KeySet: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, err = VerifySignature(jwt, v.keysFunc())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("oidc: JWT signature verification failed: %v", err)
0000000000000000000000000000000000000000;;		} else if !ok {
0000000000000000000000000000000000000000;;			return errors.New("oidc: unable to verify JWT signature: no matching keys")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
