0000000000000000000000000000000000000000;;	package oidc
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/client.go[Godeps/_workspace/src/github.com/coreos/go-oidc/oidc/client.go][vendor/github.com/coreos/go-oidc/oidc/client.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/mail"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		phttp "github.com/coreos/go-oidc/http"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/jose"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/key"
0000000000000000000000000000000000000000;;		"github.com/coreos/go-oidc/oauth2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// amount of time that must pass after the last key sync
0000000000000000000000000000000000000000;;		// completes before another attempt may begin
0000000000000000000000000000000000000000;;		keySyncWindow = 5 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		DefaultScope = []string{"openid", "email", "profile"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		supportedAuthMethods = map[string]struct{}{
0000000000000000000000000000000000000000;;			oauth2.AuthMethodClientSecretBasic: struct{}{},
0000000000000000000000000000000000000000;;			oauth2.AuthMethodClientSecretPost:  struct{}{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientCredentials oauth2.ClientCredentials
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientIdentity struct {
0000000000000000000000000000000000000000;;		Credentials ClientCredentials
0000000000000000000000000000000000000000;;		Metadata    ClientMetadata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JWAOptions struct {
0000000000000000000000000000000000000000;;		// SigningAlg specifies an JWA alg for signing JWTs.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Specifying this field implies different actions depending on the context. It may
0000000000000000000000000000000000000000;;		// require objects be serialized and signed as a JWT instead of plain JSON, or
0000000000000000000000000000000000000000;;		// require an existing JWT object use the specified alg.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See: http://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata
0000000000000000000000000000000000000000;;		SigningAlg string
0000000000000000000000000000000000000000;;		// EncryptionAlg, if provided, specifies that the returned or sent object be stored
0000000000000000000000000000000000000000;;		// (or nested) within a JWT object and encrypted with the provided JWA alg.
0000000000000000000000000000000000000000;;		EncryptionAlg string
0000000000000000000000000000000000000000;;		// EncryptionEnc specifies the JWA enc algorithm to use with EncryptionAlg. If
0000000000000000000000000000000000000000;;		// EncryptionAlg is provided and EncryptionEnc is omitted, this field defaults
0000000000000000000000000000000000000000;;		// to A128CBC-HS256.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If EncryptionEnc is provided EncryptionAlg must also be specified.
0000000000000000000000000000000000000000;;		EncryptionEnc string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (opt JWAOptions) valid() error {
0000000000000000000000000000000000000000;;		if opt.EncryptionEnc != "" && opt.EncryptionAlg == "" {
0000000000000000000000000000000000000000;;			return errors.New("encryption encoding provided with no encryption algorithm")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (opt JWAOptions) defaults() JWAOptions {
0000000000000000000000000000000000000000;;		if opt.EncryptionAlg != "" && opt.EncryptionEnc == "" {
0000000000000000000000000000000000000000;;			opt.EncryptionEnc = jose.EncA128CBCHS256
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return opt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Ensure ClientMetadata satisfies these interfaces.
0000000000000000000000000000000000000000;;		_ json.Marshaler   = &ClientMetadata{}
0000000000000000000000000000000000000000;;		_ json.Unmarshaler = &ClientMetadata{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientMetadata holds metadata that the authorization server associates
0000000000000000000000000000000000000000;;	// with a client identifier. The fields range from human-facing display
0000000000000000000000000000000000000000;;	// strings such as client name, to items that impact the security of the
0000000000000000000000000000000000000000;;	// protocol, such as the list of valid redirect URIs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO: support language specific claim representations
0000000000000000000000000000000000000000;;	// http://openid.net/specs/openid-connect-registration-1_0.html#LanguagesAndScripts
0000000000000000000000000000000000000000;;	type ClientMetadata struct {
0000000000000000000000000000000000000000;;		RedirectURIs []url.URL // Required
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A list of OAuth 2.0 "response_type" values that the client wishes to restrict
0000000000000000000000000000000000000000;;		// itself to. Either "code", "token", or another registered extension.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If omitted, only "code" will be used.
0000000000000000000000000000000000000000;;		ResponseTypes []string
0000000000000000000000000000000000000000;;		// A list of OAuth 2.0 grant types the client wishes to restrict itself to.
0000000000000000000000000000000000000000;;		// The grant type values used by OIDC are "authorization_code", "implicit",
0000000000000000000000000000000000000000;;		// and "refresh_token".
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If ommitted, only "authorization_code" will be used.
0000000000000000000000000000000000000000;;		GrantTypes []string
0000000000000000000000000000000000000000;;		// "native" or "web". If omitted, "web".
0000000000000000000000000000000000000000;;		ApplicationType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of email addresses.
0000000000000000000000000000000000000000;;		Contacts []mail.Address
0000000000000000000000000000000000000000;;		// Name of client to be presented to the end-user.
0000000000000000000000000000000000000000;;		ClientName string
0000000000000000000000000000000000000000;;		// URL that references a logo for the Client application.
0000000000000000000000000000000000000000;;		LogoURI *url.URL
0000000000000000000000000000000000000000;;		// URL of the home page of the Client.
0000000000000000000000000000000000000000;;		ClientURI *url.URL
0000000000000000000000000000000000000000;;		// Profile data policies and terms of use to be provided to the end user.
0000000000000000000000000000000000000000;;		PolicyURI         *url.URL
0000000000000000000000000000000000000000;;		TermsOfServiceURI *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// URL to or the value of the client's JSON Web Key Set document.
0000000000000000000000000000000000000000;;		JWKSURI *url.URL
0000000000000000000000000000000000000000;;		JWKS    *jose.JWKSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// URL referencing a flie with a single JSON array of redirect URIs.
0000000000000000000000000000000000000000;;		SectorIdentifierURI *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SubjectType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Options to restrict the JWS alg and enc values used for server responses and requests.
0000000000000000000000000000000000000000;;		IDTokenResponseOptions  JWAOptions
0000000000000000000000000000000000000000;;		UserInfoResponseOptions JWAOptions
0000000000000000000000000000000000000000;;		RequestObjectOptions    JWAOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Client requested authorization method and signing options for the token endpoint.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Defaults to "client_secret_basic"
0000000000000000000000000000000000000000;;		TokenEndpointAuthMethod     string
0000000000000000000000000000000000000000;;		TokenEndpointAuthSigningAlg string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultMaxAge specifies the maximum amount of time in seconds before an authorized
0000000000000000000000000000000000000000;;		// user must reauthroize.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If 0, no limitation is placed on the maximum.
0000000000000000000000000000000000000000;;		DefaultMaxAge int64
0000000000000000000000000000000000000000;;		// RequireAuthTime specifies if the auth_time claim in the ID token is required.
0000000000000000000000000000000000000000;;		RequireAuthTime bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default Authentication Context Class Reference values for authentication requests.
0000000000000000000000000000000000000000;;		DefaultACRValues []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// URI that a third party can use to initiate a login by the relaying party.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// See: http://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin
0000000000000000000000000000000000000000;;		InitiateLoginURI *url.URL
0000000000000000000000000000000000000000;;		// Pre-registered request_uri values that may be cached by the server.
0000000000000000000000000000000000000000;;		RequestURIs []url.URL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Defaults returns a shallow copy of ClientMetadata with default
0000000000000000000000000000000000000000;;	// values replacing omitted fields.
0000000000000000000000000000000000000000;;	func (m ClientMetadata) Defaults() ClientMetadata {
0000000000000000000000000000000000000000;;		if len(m.ResponseTypes) == 0 {
0000000000000000000000000000000000000000;;			m.ResponseTypes = []string{oauth2.ResponseTypeCode}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(m.GrantTypes) == 0 {
0000000000000000000000000000000000000000;;			m.GrantTypes = []string{oauth2.GrantTypeAuthCode}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.ApplicationType == "" {
0000000000000000000000000000000000000000;;			m.ApplicationType = "web"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.TokenEndpointAuthMethod == "" {
0000000000000000000000000000000000000000;;			m.TokenEndpointAuthMethod = oauth2.AuthMethodClientSecretBasic
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.IDTokenResponseOptions = m.IDTokenResponseOptions.defaults()
0000000000000000000000000000000000000000;;		m.UserInfoResponseOptions = m.UserInfoResponseOptions.defaults()
0000000000000000000000000000000000000000;;		m.RequestObjectOptions = m.RequestObjectOptions.defaults()
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ClientMetadata) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		e := m.toEncodableStruct()
0000000000000000000000000000000000000000;;		return json.Marshal(&e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ClientMetadata) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var e encodableClientMetadata
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &e); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		meta, err := e.toStruct()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := meta.Valid(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*m = meta
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encodableClientMetadata struct {
0000000000000000000000000000000000000000;;		RedirectURIs                 []string     `json:"redirect_uris"` // Required
0000000000000000000000000000000000000000;;		ResponseTypes                []string     `json:"response_types,omitempty"`
0000000000000000000000000000000000000000;;		GrantTypes                   []string     `json:"grant_types,omitempty"`
0000000000000000000000000000000000000000;;		ApplicationType              string       `json:"application_type,omitempty"`
0000000000000000000000000000000000000000;;		Contacts                     []string     `json:"contacts,omitempty"`
0000000000000000000000000000000000000000;;		ClientName                   string       `json:"client_name,omitempty"`
0000000000000000000000000000000000000000;;		LogoURI                      string       `json:"logo_uri,omitempty"`
0000000000000000000000000000000000000000;;		ClientURI                    string       `json:"client_uri,omitempty"`
0000000000000000000000000000000000000000;;		PolicyURI                    string       `json:"policy_uri,omitempty"`
0000000000000000000000000000000000000000;;		TermsOfServiceURI            string       `json:"tos_uri,omitempty"`
0000000000000000000000000000000000000000;;		JWKSURI                      string       `json:"jwks_uri,omitempty"`
0000000000000000000000000000000000000000;;		JWKS                         *jose.JWKSet `json:"jwks,omitempty"`
0000000000000000000000000000000000000000;;		SectorIdentifierURI          string       `json:"sector_identifier_uri,omitempty"`
0000000000000000000000000000000000000000;;		SubjectType                  string       `json:"subject_type,omitempty"`
0000000000000000000000000000000000000000;;		IDTokenSignedResponseAlg     string       `json:"id_token_signed_response_alg,omitempty"`
0000000000000000000000000000000000000000;;		IDTokenEncryptedResponseAlg  string       `json:"id_token_encrypted_response_alg,omitempty"`
0000000000000000000000000000000000000000;;		IDTokenEncryptedResponseEnc  string       `json:"id_token_encrypted_response_enc,omitempty"`
0000000000000000000000000000000000000000;;		UserInfoSignedResponseAlg    string       `json:"userinfo_signed_response_alg,omitempty"`
0000000000000000000000000000000000000000;;		UserInfoEncryptedResponseAlg string       `json:"userinfo_encrypted_response_alg,omitempty"`
0000000000000000000000000000000000000000;;		UserInfoEncryptedResponseEnc string       `json:"userinfo_encrypted_response_enc,omitempty"`
0000000000000000000000000000000000000000;;		RequestObjectSigningAlg      string       `json:"request_object_signing_alg,omitempty"`
0000000000000000000000000000000000000000;;		RequestObjectEncryptionAlg   string       `json:"request_object_encryption_alg,omitempty"`
0000000000000000000000000000000000000000;;		RequestObjectEncryptionEnc   string       `json:"request_object_encryption_enc,omitempty"`
0000000000000000000000000000000000000000;;		TokenEndpointAuthMethod      string       `json:"token_endpoint_auth_method,omitempty"`
0000000000000000000000000000000000000000;;		TokenEndpointAuthSigningAlg  string       `json:"token_endpoint_auth_signing_alg,omitempty"`
0000000000000000000000000000000000000000;;		DefaultMaxAge                int64        `json:"default_max_age,omitempty"`
0000000000000000000000000000000000000000;;		RequireAuthTime              bool         `json:"require_auth_time,omitempty"`
0000000000000000000000000000000000000000;;		DefaultACRValues             []string     `json:"default_acr_values,omitempty"`
0000000000000000000000000000000000000000;;		InitiateLoginURI             string       `json:"initiate_login_uri,omitempty"`
0000000000000000000000000000000000000000;;		RequestURIs                  []string     `json:"request_uris,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *encodableClientMetadata) toStruct() (ClientMetadata, error) {
0000000000000000000000000000000000000000;;		p := stickyErrParser{}
0000000000000000000000000000000000000000;;		m := ClientMetadata{
0000000000000000000000000000000000000000;;			RedirectURIs:                p.parseURIs(c.RedirectURIs, "redirect_uris"),
0000000000000000000000000000000000000000;;			ResponseTypes:               c.ResponseTypes,
0000000000000000000000000000000000000000;;			GrantTypes:                  c.GrantTypes,
0000000000000000000000000000000000000000;;			ApplicationType:             c.ApplicationType,
0000000000000000000000000000000000000000;;			Contacts:                    p.parseEmails(c.Contacts, "contacts"),
0000000000000000000000000000000000000000;;			ClientName:                  c.ClientName,
0000000000000000000000000000000000000000;;			LogoURI:                     p.parseURI(c.LogoURI, "logo_uri"),
0000000000000000000000000000000000000000;;			ClientURI:                   p.parseURI(c.ClientURI, "client_uri"),
0000000000000000000000000000000000000000;;			PolicyURI:                   p.parseURI(c.PolicyURI, "policy_uri"),
0000000000000000000000000000000000000000;;			TermsOfServiceURI:           p.parseURI(c.TermsOfServiceURI, "tos_uri"),
0000000000000000000000000000000000000000;;			JWKSURI:                     p.parseURI(c.JWKSURI, "jwks_uri"),
0000000000000000000000000000000000000000;;			JWKS:                        c.JWKS,
0000000000000000000000000000000000000000;;			SectorIdentifierURI:         p.parseURI(c.SectorIdentifierURI, "sector_identifier_uri"),
0000000000000000000000000000000000000000;;			SubjectType:                 c.SubjectType,
0000000000000000000000000000000000000000;;			TokenEndpointAuthMethod:     c.TokenEndpointAuthMethod,
0000000000000000000000000000000000000000;;			TokenEndpointAuthSigningAlg: c.TokenEndpointAuthSigningAlg,
0000000000000000000000000000000000000000;;			DefaultMaxAge:               c.DefaultMaxAge,
0000000000000000000000000000000000000000;;			RequireAuthTime:             c.RequireAuthTime,
0000000000000000000000000000000000000000;;			DefaultACRValues:            c.DefaultACRValues,
0000000000000000000000000000000000000000;;			InitiateLoginURI:            p.parseURI(c.InitiateLoginURI, "initiate_login_uri"),
0000000000000000000000000000000000000000;;			RequestURIs:                 p.parseURIs(c.RequestURIs, "request_uris"),
0000000000000000000000000000000000000000;;			IDTokenResponseOptions: JWAOptions{
0000000000000000000000000000000000000000;;				c.IDTokenSignedResponseAlg,
0000000000000000000000000000000000000000;;				c.IDTokenEncryptedResponseAlg,
0000000000000000000000000000000000000000;;				c.IDTokenEncryptedResponseEnc,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			UserInfoResponseOptions: JWAOptions{
0000000000000000000000000000000000000000;;				c.UserInfoSignedResponseAlg,
0000000000000000000000000000000000000000;;				c.UserInfoEncryptedResponseAlg,
0000000000000000000000000000000000000000;;				c.UserInfoEncryptedResponseEnc,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RequestObjectOptions: JWAOptions{
0000000000000000000000000000000000000000;;				c.RequestObjectSigningAlg,
0000000000000000000000000000000000000000;;				c.RequestObjectEncryptionAlg,
0000000000000000000000000000000000000000;;				c.RequestObjectEncryptionEnc,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.firstErr != nil {
0000000000000000000000000000000000000000;;			return ClientMetadata{}, p.firstErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stickyErrParser parses URIs and email addresses. Once it encounters
0000000000000000000000000000000000000000;;	// a parse error, subsequent calls become no-op.
0000000000000000000000000000000000000000;;	type stickyErrParser struct {
0000000000000000000000000000000000000000;;		firstErr error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *stickyErrParser) parseURI(s, field string) *url.URL {
0000000000000000000000000000000000000000;;		if p.firstErr != nil || s == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u, err := url.Parse(s)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			if u.Host == "" {
0000000000000000000000000000000000000000;;				err = errors.New("no host in URI")
0000000000000000000000000000000000000000;;			} else if u.Scheme != "http" && u.Scheme != "https" {
0000000000000000000000000000000000000000;;				err = errors.New("invalid URI scheme")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.firstErr = fmt.Errorf("failed to parse %s: %v", field, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *stickyErrParser) parseURIs(s []string, field string) []url.URL {
0000000000000000000000000000000000000000;;		if p.firstErr != nil || len(s) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uris := make([]url.URL, len(s))
0000000000000000000000000000000000000000;;		for i, val := range s {
0000000000000000000000000000000000000000;;			if val == "" {
0000000000000000000000000000000000000000;;				p.firstErr = fmt.Errorf("invalid URI in field %s", field)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u := p.parseURI(val, field); u != nil {
0000000000000000000000000000000000000000;;				uris[i] = *u
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uris
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *stickyErrParser) parseEmails(s []string, field string) []mail.Address {
0000000000000000000000000000000000000000;;		if p.firstErr != nil || len(s) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addrs := make([]mail.Address, len(s))
0000000000000000000000000000000000000000;;		for i, addr := range s {
0000000000000000000000000000000000000000;;			if addr == "" {
0000000000000000000000000000000000000000;;				p.firstErr = fmt.Errorf("invalid email in field %s", field)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a, err := mail.ParseAddress(addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				p.firstErr = fmt.Errorf("invalid email in field %s: %v", field, err)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addrs[i] = *a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addrs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *ClientMetadata) toEncodableStruct() encodableClientMetadata {
0000000000000000000000000000000000000000;;		return encodableClientMetadata{
0000000000000000000000000000000000000000;;			RedirectURIs:                 urisToStrings(m.RedirectURIs),
0000000000000000000000000000000000000000;;			ResponseTypes:                m.ResponseTypes,
0000000000000000000000000000000000000000;;			GrantTypes:                   m.GrantTypes,
0000000000000000000000000000000000000000;;			ApplicationType:              m.ApplicationType,
0000000000000000000000000000000000000000;;			Contacts:                     emailsToStrings(m.Contacts),
0000000000000000000000000000000000000000;;			ClientName:                   m.ClientName,
0000000000000000000000000000000000000000;;			LogoURI:                      uriToString(m.LogoURI),
0000000000000000000000000000000000000000;;			ClientURI:                    uriToString(m.ClientURI),
0000000000000000000000000000000000000000;;			PolicyURI:                    uriToString(m.PolicyURI),
0000000000000000000000000000000000000000;;			TermsOfServiceURI:            uriToString(m.TermsOfServiceURI),
0000000000000000000000000000000000000000;;			JWKSURI:                      uriToString(m.JWKSURI),
0000000000000000000000000000000000000000;;			JWKS:                         m.JWKS,
0000000000000000000000000000000000000000;;			SectorIdentifierURI:          uriToString(m.SectorIdentifierURI),
0000000000000000000000000000000000000000;;			SubjectType:                  m.SubjectType,
0000000000000000000000000000000000000000;;			IDTokenSignedResponseAlg:     m.IDTokenResponseOptions.SigningAlg,
0000000000000000000000000000000000000000;;			IDTokenEncryptedResponseAlg:  m.IDTokenResponseOptions.EncryptionAlg,
0000000000000000000000000000000000000000;;			IDTokenEncryptedResponseEnc:  m.IDTokenResponseOptions.EncryptionEnc,
0000000000000000000000000000000000000000;;			UserInfoSignedResponseAlg:    m.UserInfoResponseOptions.SigningAlg,
0000000000000000000000000000000000000000;;			UserInfoEncryptedResponseAlg: m.UserInfoResponseOptions.EncryptionAlg,
0000000000000000000000000000000000000000;;			UserInfoEncryptedResponseEnc: m.UserInfoResponseOptions.EncryptionEnc,
0000000000000000000000000000000000000000;;			RequestObjectSigningAlg:      m.RequestObjectOptions.SigningAlg,
0000000000000000000000000000000000000000;;			RequestObjectEncryptionAlg:   m.RequestObjectOptions.EncryptionAlg,
0000000000000000000000000000000000000000;;			RequestObjectEncryptionEnc:   m.RequestObjectOptions.EncryptionEnc,
0000000000000000000000000000000000000000;;			TokenEndpointAuthMethod:      m.TokenEndpointAuthMethod,
0000000000000000000000000000000000000000;;			TokenEndpointAuthSigningAlg:  m.TokenEndpointAuthSigningAlg,
0000000000000000000000000000000000000000;;			DefaultMaxAge:                m.DefaultMaxAge,
0000000000000000000000000000000000000000;;			RequireAuthTime:              m.RequireAuthTime,
0000000000000000000000000000000000000000;;			DefaultACRValues:             m.DefaultACRValues,
0000000000000000000000000000000000000000;;			InitiateLoginURI:             uriToString(m.InitiateLoginURI),
0000000000000000000000000000000000000000;;			RequestURIs:                  urisToStrings(m.RequestURIs),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func uriToString(u *url.URL) string {
0000000000000000000000000000000000000000;;		if u == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func urisToStrings(urls []url.URL) []string {
0000000000000000000000000000000000000000;;		if len(urls) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sli := make([]string, len(urls))
0000000000000000000000000000000000000000;;		for i, u := range urls {
0000000000000000000000000000000000000000;;			sli[i] = u.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sli
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func emailsToStrings(addrs []mail.Address) []string {
0000000000000000000000000000000000000000;;		if len(addrs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sli := make([]string, len(addrs))
0000000000000000000000000000000000000000;;		for i, addr := range addrs {
0000000000000000000000000000000000000000;;			sli[i] = addr.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sli
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid determines if a ClientMetadata conforms with the OIDC specification.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Valid is called by UnmarshalJSON.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE(ericchiang): For development purposes Valid does not mandate 'https' for
0000000000000000000000000000000000000000;;	// URLs fields where the OIDC spec requires it. This may change in future releases
0000000000000000000000000000000000000000;;	// of this package. See: https://github.com/coreos/go-oidc/issues/34
0000000000000000000000000000000000000000;;	func (m *ClientMetadata) Valid() error {
0000000000000000000000000000000000000000;;		if len(m.RedirectURIs) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("zero redirect URLs")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		validURI := func(u *url.URL, fieldName string) error {
0000000000000000000000000000000000000000;;			if u.Host == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("no host for uri field %s", fieldName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u.Scheme != "http" && u.Scheme != "https" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("uri field %s scheme is not http or https", fieldName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uris := []struct {
0000000000000000000000000000000000000000;;			val  *url.URL
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{m.LogoURI, "logo_uri"},
0000000000000000000000000000000000000000;;			{m.ClientURI, "client_uri"},
0000000000000000000000000000000000000000;;			{m.PolicyURI, "policy_uri"},
0000000000000000000000000000000000000000;;			{m.TermsOfServiceURI, "tos_uri"},
0000000000000000000000000000000000000000;;			{m.JWKSURI, "jwks_uri"},
0000000000000000000000000000000000000000;;			{m.SectorIdentifierURI, "sector_identifier_uri"},
0000000000000000000000000000000000000000;;			{m.InitiateLoginURI, "initiate_login_uri"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, uri := range uris {
0000000000000000000000000000000000000000;;			if uri.val == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := validURI(uri.val, uri.name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uriLists := []struct {
0000000000000000000000000000000000000000;;			vals []url.URL
0000000000000000000000000000000000000000;;			name string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{m.RedirectURIs, "redirect_uris"},
0000000000000000000000000000000000000000;;			{m.RequestURIs, "request_uris"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, list := range uriLists {
0000000000000000000000000000000000000000;;			for _, uri := range list.vals {
0000000000000000000000000000000000000000;;				if err := validURI(&uri, list.name); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := []struct {
0000000000000000000000000000000000000000;;			option JWAOptions
0000000000000000000000000000000000000000;;			name   string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{m.IDTokenResponseOptions, "id_token response"},
0000000000000000000000000000000000000000;;			{m.UserInfoResponseOptions, "userinfo response"},
0000000000000000000000000000000000000000;;			{m.RequestObjectOptions, "request_object"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			if err := option.option.valid(); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("invalid JWA values for %s: %v", option.name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientRegistrationResponse struct {
0000000000000000000000000000000000000000;;		ClientID                string // Required
0000000000000000000000000000000000000000;;		ClientSecret            string
0000000000000000000000000000000000000000;;		RegistrationAccessToken string
0000000000000000000000000000000000000000;;		RegistrationClientURI   string
0000000000000000000000000000000000000000;;		// If IsZero is true, unspecified.
0000000000000000000000000000000000000000;;		ClientIDIssuedAt time.Time
0000000000000000000000000000000000000000;;		// Time at which the client_secret will expire.
0000000000000000000000000000000000000000;;		// If IsZero is true, it will not expire.
0000000000000000000000000000000000000000;;		ClientSecretExpiresAt time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ClientMetadata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encodableClientRegistrationResponse struct {
0000000000000000000000000000000000000000;;		ClientID                string `json:"client_id"` // Required
0000000000000000000000000000000000000000;;		ClientSecret            string `json:"client_secret,omitempty"`
0000000000000000000000000000000000000000;;		RegistrationAccessToken string `json:"registration_access_token,omitempty"`
0000000000000000000000000000000000000000;;		RegistrationClientURI   string `json:"registration_client_uri,omitempty"`
0000000000000000000000000000000000000000;;		ClientIDIssuedAt        int64  `json:"client_id_issued_at,omitempty"`
0000000000000000000000000000000000000000;;		// Time at which the client_secret will expire, in seconds since the epoch.
0000000000000000000000000000000000000000;;		// If 0 it will not expire.
0000000000000000000000000000000000000000;;		ClientSecretExpiresAt int64 `json:"client_secret_expires_at"` // Required
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encodableClientMetadata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unixToSec(t time.Time) int64 {
0000000000000000000000000000000000000000;;		if t.IsZero() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.Unix()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClientRegistrationResponse) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		e := encodableClientRegistrationResponse{
0000000000000000000000000000000000000000;;			ClientID:                c.ClientID,
0000000000000000000000000000000000000000;;			ClientSecret:            c.ClientSecret,
0000000000000000000000000000000000000000;;			RegistrationAccessToken: c.RegistrationAccessToken,
0000000000000000000000000000000000000000;;			RegistrationClientURI:   c.RegistrationClientURI,
0000000000000000000000000000000000000000;;			ClientIDIssuedAt:        unixToSec(c.ClientIDIssuedAt),
0000000000000000000000000000000000000000;;			ClientSecretExpiresAt:   unixToSec(c.ClientSecretExpiresAt),
0000000000000000000000000000000000000000;;			encodableClientMetadata: c.ClientMetadata.toEncodableStruct(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(&e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func secToUnix(sec int64) time.Time {
0000000000000000000000000000000000000000;;		if sec == 0 {
0000000000000000000000000000000000000000;;			return time.Time{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Unix(sec, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *ClientRegistrationResponse) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var e encodableClientRegistrationResponse
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &e); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.ClientID == "" {
0000000000000000000000000000000000000000;;			return errors.New("no client_id in client registration response")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metadata, err := e.encodableClientMetadata.toStruct()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*c = ClientRegistrationResponse{
0000000000000000000000000000000000000000;;			ClientID:                e.ClientID,
0000000000000000000000000000000000000000;;			ClientSecret:            e.ClientSecret,
0000000000000000000000000000000000000000;;			RegistrationAccessToken: e.RegistrationAccessToken,
0000000000000000000000000000000000000000;;			RegistrationClientURI:   e.RegistrationClientURI,
0000000000000000000000000000000000000000;;			ClientIDIssuedAt:        secToUnix(e.ClientIDIssuedAt),
0000000000000000000000000000000000000000;;			ClientSecretExpiresAt:   secToUnix(e.ClientSecretExpiresAt),
0000000000000000000000000000000000000000;;			ClientMetadata:          metadata,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ClientConfig struct {
0000000000000000000000000000000000000000;;		HTTPClient     phttp.Client
0000000000000000000000000000000000000000;;		Credentials    ClientCredentials
0000000000000000000000000000000000000000;;		Scope          []string
0000000000000000000000000000000000000000;;		RedirectURL    string
0000000000000000000000000000000000000000;;		ProviderConfig ProviderConfig
0000000000000000000000000000000000000000;;		KeySet         key.PublicKeySet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClient(cfg ClientConfig) (*Client, error) {
0000000000000000000000000000000000000000;;		// Allow empty redirect URL in the case where the client
0000000000000000000000000000000000000000;;		// only needs to verify a given token.
0000000000000000000000000000000000000000;;		ru, err := url.Parse(cfg.RedirectURL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid redirect URL: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := Client{
0000000000000000000000000000000000000000;;			credentials:    cfg.Credentials,
0000000000000000000000000000000000000000;;			httpClient:     cfg.HTTPClient,
0000000000000000000000000000000000000000;;			scope:          cfg.Scope,
0000000000000000000000000000000000000000;;			redirectURL:    ru.String(),
0000000000000000000000000000000000000000;;			providerConfig: newProviderConfigRepo(cfg.ProviderConfig),
0000000000000000000000000000000000000000;;			keySet:         cfg.KeySet,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.httpClient == nil {
0000000000000000000000000000000000000000;;			c.httpClient = http.DefaultClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.scope == nil {
0000000000000000000000000000000000000000;;			c.scope = make([]string, len(DefaultScope))
0000000000000000000000000000000000000000;;			copy(c.scope, DefaultScope)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		httpClient     phttp.Client
0000000000000000000000000000000000000000;;		providerConfig *providerConfigRepo
0000000000000000000000000000000000000000;;		credentials    ClientCredentials
0000000000000000000000000000000000000000;;		redirectURL    string
0000000000000000000000000000000000000000;;		scope          []string
0000000000000000000000000000000000000000;;		keySet         key.PublicKeySet
0000000000000000000000000000000000000000;;		providerSyncer *ProviderConfigSyncer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keySetSyncMutex sync.RWMutex
0000000000000000000000000000000000000000;;		lastKeySetSync  time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) Healthy() error {
0000000000000000000000000000000000000000;;		now := time.Now().UTC()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := c.providerConfig.Get()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cfg.Empty() {
0000000000000000000000000000000000000000;;			return errors.New("oidc client provider config empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cfg.ExpiresAt.IsZero() && cfg.ExpiresAt.Before(now) {
0000000000000000000000000000000000000000;;			return errors.New("oidc client provider config expired")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) OAuthClient() (*oauth2.Client, error) {
0000000000000000000000000000000000000000;;		cfg := c.providerConfig.Get()
0000000000000000000000000000000000000000;;		authMethod, err := chooseAuthMethod(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ocfg := oauth2.Config{
0000000000000000000000000000000000000000;;			Credentials: oauth2.ClientCredentials(c.credentials),
0000000000000000000000000000000000000000;;			RedirectURL: c.redirectURL,
0000000000000000000000000000000000000000;;			AuthURL:     cfg.AuthEndpoint.String(),
0000000000000000000000000000000000000000;;			TokenURL:    cfg.TokenEndpoint.String(),
0000000000000000000000000000000000000000;;			Scope:       c.scope,
0000000000000000000000000000000000000000;;			AuthMethod:  authMethod,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return oauth2.NewClient(c.httpClient, ocfg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func chooseAuthMethod(cfg ProviderConfig) (string, error) {
0000000000000000000000000000000000000000;;		if len(cfg.TokenEndpointAuthMethodsSupported) == 0 {
0000000000000000000000000000000000000000;;			return oauth2.AuthMethodClientSecretBasic, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, authMethod := range cfg.TokenEndpointAuthMethodsSupported {
0000000000000000000000000000000000000000;;			if _, ok := supportedAuthMethods[authMethod]; ok {
0000000000000000000000000000000000000000;;				return authMethod, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", errors.New("no supported auth methods")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SyncProviderConfig starts the provider config syncer
0000000000000000000000000000000000000000;;	func (c *Client) SyncProviderConfig(discoveryURL string) chan struct{} {
0000000000000000000000000000000000000000;;		r := NewHTTPProviderConfigGetter(c.httpClient, discoveryURL)
0000000000000000000000000000000000000000;;		s := NewProviderConfigSyncer(r, c.providerConfig)
0000000000000000000000000000000000000000;;		stop := s.Run()
0000000000000000000000000000000000000000;;		s.WaitUntilInitialSync()
0000000000000000000000000000000000000000;;		return stop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) maybeSyncKeys() error {
0000000000000000000000000000000000000000;;		tooSoon := func() bool {
0000000000000000000000000000000000000000;;			return time.Now().UTC().Before(c.lastKeySetSync.Add(keySyncWindow))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ignore request to sync keys if a sync operation has been
0000000000000000000000000000000000000000;;		// attempted too recently
0000000000000000000000000000000000000000;;		if tooSoon() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.keySetSyncMutex.Lock()
0000000000000000000000000000000000000000;;		defer c.keySetSyncMutex.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check again, as another goroutine may have been holding
0000000000000000000000000000000000000000;;		// the lock while updating the keys
0000000000000000000000000000000000000000;;		if tooSoon() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := c.providerConfig.Get()
0000000000000000000000000000000000000000;;		r := NewRemotePublicKeyRepo(c.httpClient, cfg.KeysEndpoint.String())
0000000000000000000000000000000000000000;;		w := &clientKeyRepo{client: c}
0000000000000000000000000000000000000000;;		_, err := key.Sync(r, w)
0000000000000000000000000000000000000000;;		c.lastKeySetSync = time.Now().UTC()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientKeyRepo struct {
0000000000000000000000000000000000000000;;		client *Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *clientKeyRepo) Set(ks key.KeySet) error {
0000000000000000000000000000000000000000;;		pks, ok := ks.(*key.PublicKeySet)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("unable to cast to PublicKey")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.client.keySet = *pks
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) ClientCredsToken(scope []string) (jose.JWT, error) {
0000000000000000000000000000000000000000;;		cfg := c.providerConfig.Get()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !cfg.SupportsGrantType(oauth2.GrantTypeClientCreds) {
0000000000000000000000000000000000000000;;			return jose.JWT{}, fmt.Errorf("%v grant type is not supported", oauth2.GrantTypeClientCreds)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oac, err := c.OAuthClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, err := oac.ClientCredsToken(scope)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jwt, err := jose.ParseJWT(t.IDToken)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jwt, c.VerifyJWT(jwt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExchangeAuthCode exchanges an OAuth2 auth code for an OIDC JWT ID token.
0000000000000000000000000000000000000000;;	func (c *Client) ExchangeAuthCode(code string) (jose.JWT, error) {
0000000000000000000000000000000000000000;;		oac, err := c.OAuthClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, err := oac.RequestToken(oauth2.GrantTypeAuthCode, code)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jwt, err := jose.ParseJWT(t.IDToken)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jwt, c.VerifyJWT(jwt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RefreshToken uses a refresh token to exchange for a new OIDC JWT ID Token.
0000000000000000000000000000000000000000;;	func (c *Client) RefreshToken(refreshToken string) (jose.JWT, error) {
0000000000000000000000000000000000000000;;		oac, err := c.OAuthClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, err := oac.RequestToken(oauth2.GrantTypeRefreshToken, refreshToken)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jwt, err := jose.ParseJWT(t.IDToken)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return jose.JWT{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jwt, c.VerifyJWT(jwt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) VerifyJWT(jwt jose.JWT) error {
0000000000000000000000000000000000000000;;		var keysFunc func() []key.PublicKey
0000000000000000000000000000000000000000;;		if kID, ok := jwt.KeyID(); ok {
0000000000000000000000000000000000000000;;			keysFunc = c.keysFuncWithID(kID)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			keysFunc = c.keysFuncAll()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := NewJWTVerifier(
0000000000000000000000000000000000000000;;			c.providerConfig.Get().Issuer.String(),
0000000000000000000000000000000000000000;;			c.credentials.ID,
0000000000000000000000000000000000000000;;			c.maybeSyncKeys, keysFunc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v.Verify(jwt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keysFuncWithID returns a function that retrieves at most unexpired
0000000000000000000000000000000000000000;;	// public key from the Client that matches the provided ID
0000000000000000000000000000000000000000;;	func (c *Client) keysFuncWithID(kID string) func() []key.PublicKey {
0000000000000000000000000000000000000000;;		return func() []key.PublicKey {
0000000000000000000000000000000000000000;;			c.keySetSyncMutex.RLock()
0000000000000000000000000000000000000000;;			defer c.keySetSyncMutex.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.keySet.ExpiresAt().Before(time.Now()) {
0000000000000000000000000000000000000000;;				return []key.PublicKey{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			k := c.keySet.Key(kID)
0000000000000000000000000000000000000000;;			if k == nil {
0000000000000000000000000000000000000000;;				return []key.PublicKey{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return []key.PublicKey{*k}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keysFuncAll returns a function that retrieves all unexpired public
0000000000000000000000000000000000000000;;	// keys from the Client
0000000000000000000000000000000000000000;;	func (c *Client) keysFuncAll() func() []key.PublicKey {
0000000000000000000000000000000000000000;;		return func() []key.PublicKey {
0000000000000000000000000000000000000000;;			c.keySetSyncMutex.RLock()
0000000000000000000000000000000000000000;;			defer c.keySetSyncMutex.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.keySet.ExpiresAt().Before(time.Now()) {
0000000000000000000000000000000000000000;;				return []key.PublicKey{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return c.keySet.Keys()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type providerConfigRepo struct {
0000000000000000000000000000000000000000;;		mu     sync.RWMutex
0000000000000000000000000000000000000000;;		config ProviderConfig // do not access directly, use Get()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newProviderConfigRepo(pc ProviderConfig) *providerConfigRepo {
0000000000000000000000000000000000000000;;		return &providerConfigRepo{sync.RWMutex{}, pc}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns an error to implement ProviderConfigSetter
0000000000000000000000000000000000000000;;	func (r *providerConfigRepo) Set(cfg ProviderConfig) error {
0000000000000000000000000000000000000000;;		r.mu.Lock()
0000000000000000000000000000000000000000;;		defer r.mu.Unlock()
0000000000000000000000000000000000000000;;		r.config = cfg
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *providerConfigRepo) Get() ProviderConfig {
0000000000000000000000000000000000000000;;		r.mu.RLock()
0000000000000000000000000000000000000000;;		defer r.mu.RUnlock()
0000000000000000000000000000000000000000;;		return r.config
0000000000000000000000000000000000000000;;	}
