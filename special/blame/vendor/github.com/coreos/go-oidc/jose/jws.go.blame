0000000000000000000000000000000000000000;;	package jose
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/jose/jws.go[Godeps/_workspace/src/github.com/coreos/go-oidc/jose/jws.go][vendor/github.com/coreos/go-oidc/jose/jws.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JWS struct {
0000000000000000000000000000000000000000;;		RawHeader  string
0000000000000000000000000000000000000000;;		Header     JOSEHeader
0000000000000000000000000000000000000000;;		RawPayload string
0000000000000000000000000000000000000000;;		Payload    []byte
0000000000000000000000000000000000000000;;		Signature  []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Given a raw encoded JWS token parses it and verifies the structure.
0000000000000000000000000000000000000000;;	func ParseJWS(raw string) (JWS, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(raw, ".")
0000000000000000000000000000000000000000;;		if len(parts) != 3 {
0000000000000000000000000000000000000000;;			return JWS{}, fmt.Errorf("malformed JWS, only %d segments", len(parts))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawSig := parts[2]
0000000000000000000000000000000000000000;;		jws := JWS{
0000000000000000000000000000000000000000;;			RawHeader:  parts[0],
0000000000000000000000000000000000000000;;			RawPayload: parts[1],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header, err := decodeHeader(jws.RawHeader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return JWS{}, fmt.Errorf("malformed JWS, unable to decode header, %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = header.Validate(); err != nil {
0000000000000000000000000000000000000000;;			return JWS{}, fmt.Errorf("malformed JWS, %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jws.Header = header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload, err := decodeSegment(jws.RawPayload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return JWS{}, fmt.Errorf("malformed JWS, unable to decode payload: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jws.Payload = payload
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sig, err := decodeSegment(rawSig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return JWS{}, fmt.Errorf("malformed JWS, unable to decode signature: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jws.Signature = sig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jws, nil
0000000000000000000000000000000000000000;;	}
