0000000000000000000000000000000000000000;;	package jose
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/go-oidc/jose/jwk.go[Godeps/_workspace/src/github.com/coreos/go-oidc/jose/jwk.go][vendor/github.com/coreos/go-oidc/jose/jwk.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSON Web Key
0000000000000000000000000000000000000000;;	// https://tools.ietf.org/html/draft-ietf-jose-json-web-key-36#page-5
0000000000000000000000000000000000000000;;	type JWK struct {
0000000000000000000000000000000000000000;;		ID       string
0000000000000000000000000000000000000000;;		Type     string
0000000000000000000000000000000000000000;;		Alg      string
0000000000000000000000000000000000000000;;		Use      string
0000000000000000000000000000000000000000;;		Exponent int
0000000000000000000000000000000000000000;;		Modulus  *big.Int
0000000000000000000000000000000000000000;;		Secret   []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jwkJSON struct {
0000000000000000000000000000000000000000;;		ID       string `json:"kid"`
0000000000000000000000000000000000000000;;		Type     string `json:"kty"`
0000000000000000000000000000000000000000;;		Alg      string `json:"alg"`
0000000000000000000000000000000000000000;;		Use      string `json:"use"`
0000000000000000000000000000000000000000;;		Exponent string `json:"e"`
0000000000000000000000000000000000000000;;		Modulus  string `json:"n"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *JWK) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		t := jwkJSON{
0000000000000000000000000000000000000000;;			ID:       j.ID,
0000000000000000000000000000000000000000;;			Type:     j.Type,
0000000000000000000000000000000000000000;;			Alg:      j.Alg,
0000000000000000000000000000000000000000;;			Use:      j.Use,
0000000000000000000000000000000000000000;;			Exponent: encodeExponent(j.Exponent),
0000000000000000000000000000000000000000;;			Modulus:  encodeModulus(j.Modulus),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(&t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (j *JWK) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var t jwkJSON
0000000000000000000000000000000000000000;;		err := json.Unmarshal(data, &t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e, err := decodeExponent(t.Exponent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := decodeModulus(t.Modulus)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j.ID = t.ID
0000000000000000000000000000000000000000;;		j.Type = t.Type
0000000000000000000000000000000000000000;;		j.Alg = t.Alg
0000000000000000000000000000000000000000;;		j.Use = t.Use
0000000000000000000000000000000000000000;;		j.Exponent = e
0000000000000000000000000000000000000000;;		j.Modulus = n
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JWKSet struct {
0000000000000000000000000000000000000000;;		Keys []JWK `json:"keys"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeExponent(e string) (int, error) {
0000000000000000000000000000000000000000;;		decE, err := decodeBase64URLPaddingOptional(e)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var eBytes []byte
0000000000000000000000000000000000000000;;		if len(decE) < 8 {
0000000000000000000000000000000000000000;;			eBytes = make([]byte, 8-len(decE), 8)
0000000000000000000000000000000000000000;;			eBytes = append(eBytes, decE...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			eBytes = decE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eReader := bytes.NewReader(eBytes)
0000000000000000000000000000000000000000;;		var E uint64
0000000000000000000000000000000000000000;;		err = binary.Read(eReader, binary.BigEndian, &E)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(E), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeExponent(e int) string {
0000000000000000000000000000000000000000;;		b := make([]byte, 8)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(b, uint64(e))
0000000000000000000000000000000000000000;;		var idx int
0000000000000000000000000000000000000000;;		for ; idx < 8; idx++ {
0000000000000000000000000000000000000000;;			if b[idx] != 0x0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return base64.RawURLEncoding.EncodeToString(b[idx:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Turns a URL encoded modulus of a key into a big int.
0000000000000000000000000000000000000000;;	func decodeModulus(n string) (*big.Int, error) {
0000000000000000000000000000000000000000;;		decN, err := decodeBase64URLPaddingOptional(n)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		N := big.NewInt(0)
0000000000000000000000000000000000000000;;		N.SetBytes(decN)
0000000000000000000000000000000000000000;;		return N, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeModulus(n *big.Int) string {
0000000000000000000000000000000000000000;;		return base64.RawURLEncoding.EncodeToString(n.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeBase64URLPaddingOptional decodes Base64 whether there is padding or not.
0000000000000000000000000000000000000000;;	// The stdlib version currently doesn't handle this.
0000000000000000000000000000000000000000;;	// We can get rid of this is if this bug:
0000000000000000000000000000000000000000;;	//   https://github.com/golang/go/issues/4237
0000000000000000000000000000000000000000;;	// ever closes.
0000000000000000000000000000000000000000;;	func decodeBase64URLPaddingOptional(e string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if m := len(e) % 4; m != 0 {
0000000000000000000000000000000000000000;;			e += strings.Repeat("=", 4-m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return base64.URLEncoding.DecodeString(e)
0000000000000000000000000000000000000000;;	}
