0000000000000000000000000000000000000000;;	package health
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/pkg/health/health.go[Godeps/_workspace/src/github.com/coreos/pkg/health/health.go][vendor/github.com/coreos/pkg/health/health.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"expvar"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/coreos/pkg/httputil"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checkables should return nil when the thing they are checking is healthy, and an error otherwise.
0000000000000000000000000000000000000000;;	type Checkable interface {
0000000000000000000000000000000000000000;;		Healthy() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checker provides a way to make an endpoint which can be probed for system health.
0000000000000000000000000000000000000000;;	type Checker struct {
0000000000000000000000000000000000000000;;		// Checks are the Checkables to be checked when probing.
0000000000000000000000000000000000000000;;		Checks []Checkable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unhealthyhandler is called when one or more of the checks are unhealthy.
0000000000000000000000000000000000000000;;		// If not provided DefaultUnhealthyHandler is called.
0000000000000000000000000000000000000000;;		UnhealthyHandler UnhealthyHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HealthyHandler is called when all checks are healthy.
0000000000000000000000000000000000000000;;		// If not provided, DefaultHealthyHandler is called.
0000000000000000000000000000000000000000;;		HealthyHandler http.HandlerFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Checker) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		unhealthyHandler := c.UnhealthyHandler
0000000000000000000000000000000000000000;;		if unhealthyHandler == nil {
0000000000000000000000000000000000000000;;			unhealthyHandler = DefaultUnhealthyHandler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		successHandler := c.HealthyHandler
0000000000000000000000000000000000000000;;		if successHandler == nil {
0000000000000000000000000000000000000000;;			successHandler = DefaultHealthyHandler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Method != "GET" {
0000000000000000000000000000000000000000;;			w.Header().Set("Allow", "GET")
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := Check(c.Checks); err != nil {
0000000000000000000000000000000000000000;;			unhealthyHandler(w, r, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		successHandler(w, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UnhealthyHandler func(w http.ResponseWriter, r *http.Request, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatusResponse struct {
0000000000000000000000000000000000000000;;		Status  string                 `json:"status"`
0000000000000000000000000000000000000000;;		Details *StatusResponseDetails `json:"details,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatusResponseDetails struct {
0000000000000000000000000000000000000000;;		Code    int    `json:"code,omitempty"`
0000000000000000000000000000000000000000;;		Message string `json:"message,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Check(checks []Checkable) (err error) {
0000000000000000000000000000000000000000;;		errs := []error{}
0000000000000000000000000000000000000000;;		for _, c := range checks {
0000000000000000000000000000000000000000;;			if e := c.Healthy(); e != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(errs) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			err = errs[0]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("multiple health check failure: %v", errs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultHealthyHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		err := httputil.WriteJSONResponse(w, http.StatusOK, StatusResponse{
0000000000000000000000000000000000000000;;			Status: "ok",
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// TODO(bobbyrullo): replace with logging from new logging pkg,
0000000000000000000000000000000000000000;;			// once it lands.
0000000000000000000000000000000000000000;;			log.Printf("Failed to write JSON response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultUnhealthyHandler(w http.ResponseWriter, r *http.Request, err error) {
0000000000000000000000000000000000000000;;		writeErr := httputil.WriteJSONResponse(w, http.StatusInternalServerError, StatusResponse{
0000000000000000000000000000000000000000;;			Status: "error",
0000000000000000000000000000000000000000;;			Details: &StatusResponseDetails{
0000000000000000000000000000000000000000;;				Code:    http.StatusInternalServerError,
0000000000000000000000000000000000000000;;				Message: err.Error(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if writeErr != nil {
0000000000000000000000000000000000000000;;			// TODO(bobbyrullo): replace with logging from new logging pkg,
0000000000000000000000000000000000000000;;			// once it lands.
0000000000000000000000000000000000000000;;			log.Printf("Failed to write JSON response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpvarHandler is copied from https://golang.org/src/expvar/expvar.go, where it's sadly unexported.
0000000000000000000000000000000000000000;;	func ExpvarHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json; charset=utf-8")
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "{\n")
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		expvar.Do(func(kv expvar.KeyValue) {
0000000000000000000000000000000000000000;;			if !first {
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, ",\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			first = false
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%q: %s", kv.Key, kv.Value)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "\n}\n")
0000000000000000000000000000000000000000;;	}
