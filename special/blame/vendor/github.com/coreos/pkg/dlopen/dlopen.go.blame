0000000000000000000000000000000000000000;;	// Copyright 2016 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
2e6b23087c07e0ca25a1986b378417fd0915b4d7;;	
0000000000000000000000000000000000000000;;	// Package dlopen provides some convenience functions to dlopen a library and
0000000000000000000000000000000000000000;;	// get its symbols.
0000000000000000000000000000000000000000;;	package dlopen
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// #cgo LDFLAGS: -ldl
0000000000000000000000000000000000000000;;	// #include <stdlib.h>
0000000000000000000000000000000000000000;;	// #include <dlfcn.h>
0000000000000000000000000000000000000000;;	import "C"
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ErrSoNotFound = errors.New("unable to open a handle to the library")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LibHandle represents an open handle to a library (.so)
0000000000000000000000000000000000000000;;	type LibHandle struct {
0000000000000000000000000000000000000000;;		Handle  unsafe.Pointer
0000000000000000000000000000000000000000;;		Libname string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetHandle tries to get a handle to a library (.so), attempting to access it
0000000000000000000000000000000000000000;;	// by the names specified in libs and returning the first that is successfully
0000000000000000000000000000000000000000;;	// opened. Callers are responsible for closing the handler. If no library can
0000000000000000000000000000000000000000;;	// be successfully opened, an error is returned.
0000000000000000000000000000000000000000;;	func GetHandle(libs []string) (*LibHandle, error) {
0000000000000000000000000000000000000000;;		for _, name := range libs {
0000000000000000000000000000000000000000;;			libname := C.CString(name)
0000000000000000000000000000000000000000;;			defer C.free(unsafe.Pointer(libname))
0000000000000000000000000000000000000000;;			handle := C.dlopen(libname, C.RTLD_LAZY)
0000000000000000000000000000000000000000;;			if handle != nil {
0000000000000000000000000000000000000000;;				h := &LibHandle{
0000000000000000000000000000000000000000;;					Handle:  handle,
0000000000000000000000000000000000000000;;					Libname: name,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return h, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, ErrSoNotFound
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSymbolPointer takes a symbol name and returns a pointer to the symbol.
0000000000000000000000000000000000000000;;	func (l *LibHandle) GetSymbolPointer(symbol string) (unsafe.Pointer, error) {
0000000000000000000000000000000000000000;;		sym := C.CString(symbol)
0000000000000000000000000000000000000000;;		defer C.free(unsafe.Pointer(sym))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		C.dlerror()
0000000000000000000000000000000000000000;;		p := C.dlsym(l.Handle, sym)
0000000000000000000000000000000000000000;;		e := C.dlerror()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error resolving symbol %q: %v", symbol, errors.New(C.GoString(e)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes a LibHandle.
0000000000000000000000000000000000000000;;	func (l *LibHandle) Close() error {
0000000000000000000000000000000000000000;;		C.dlerror()
0000000000000000000000000000000000000000;;		C.dlclose(l.Handle)
0000000000000000000000000000000000000000;;		e := C.dlerror()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error closing %v: %v", l.Libname, errors.New(C.GoString(e)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
