0000000000000000000000000000000000000000;;	// Copyright 2015 CoreOS, Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/coreos/pkg/capnslog/logmap.go[Godeps/_workspace/src/github.com/coreos/pkg/capnslog/logmap.go][vendor/github.com/coreos/pkg/capnslog/logmap.go];	
0000000000000000000000000000000000000000;;	package capnslog
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogLevel is the set of all log levels.
0000000000000000000000000000000000000000;;	type LogLevel int8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// CRITICAL is the lowest log level; only errors which will end the program will be propagated.
0000000000000000000000000000000000000000;;		CRITICAL LogLevel = iota - 1
0000000000000000000000000000000000000000;;		// ERROR is for errors that are not fatal but lead to troubling behavior.
0000000000000000000000000000000000000000;;		ERROR
0000000000000000000000000000000000000000;;		// WARNING is for errors which are not fatal and not errors, but are unusual. Often sourced from misconfigurations.
0000000000000000000000000000000000000000;;		WARNING
0000000000000000000000000000000000000000;;		// NOTICE is for normal but significant conditions.
0000000000000000000000000000000000000000;;		NOTICE
0000000000000000000000000000000000000000;;		// INFO is a log level for common, everyday log updates.
0000000000000000000000000000000000000000;;		INFO
0000000000000000000000000000000000000000;;		// DEBUG is the default hidden level for more verbose updates about internal processes.
0000000000000000000000000000000000000000;;		DEBUG
0000000000000000000000000000000000000000;;		// TRACE is for (potentially) call by call tracing of programs.
0000000000000000000000000000000000000000;;		TRACE
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Char returns a single-character representation of the log level.
0000000000000000000000000000000000000000;;	func (l LogLevel) Char() string {
0000000000000000000000000000000000000000;;		switch l {
0000000000000000000000000000000000000000;;		case CRITICAL:
0000000000000000000000000000000000000000;;			return "C"
0000000000000000000000000000000000000000;;		case ERROR:
0000000000000000000000000000000000000000;;			return "E"
0000000000000000000000000000000000000000;;		case WARNING:
0000000000000000000000000000000000000000;;			return "W"
0000000000000000000000000000000000000000;;		case NOTICE:
0000000000000000000000000000000000000000;;			return "N"
0000000000000000000000000000000000000000;;		case INFO:
0000000000000000000000000000000000000000;;			return "I"
0000000000000000000000000000000000000000;;		case DEBUG:
0000000000000000000000000000000000000000;;			return "D"
0000000000000000000000000000000000000000;;		case TRACE:
0000000000000000000000000000000000000000;;			return "T"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("Unhandled loglevel")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a multi-character representation of the log level.
0000000000000000000000000000000000000000;;	func (l LogLevel) String() string {
0000000000000000000000000000000000000000;;		switch l {
0000000000000000000000000000000000000000;;		case CRITICAL:
0000000000000000000000000000000000000000;;			return "CRITICAL"
0000000000000000000000000000000000000000;;		case ERROR:
0000000000000000000000000000000000000000;;			return "ERROR"
0000000000000000000000000000000000000000;;		case WARNING:
0000000000000000000000000000000000000000;;			return "WARNING"
0000000000000000000000000000000000000000;;		case NOTICE:
0000000000000000000000000000000000000000;;			return "NOTICE"
0000000000000000000000000000000000000000;;		case INFO:
0000000000000000000000000000000000000000;;			return "INFO"
0000000000000000000000000000000000000000;;		case DEBUG:
0000000000000000000000000000000000000000;;			return "DEBUG"
0000000000000000000000000000000000000000;;		case TRACE:
0000000000000000000000000000000000000000;;			return "TRACE"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("Unhandled loglevel")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update using the given string value. Fulfills the flag.Value interface.
0000000000000000000000000000000000000000;;	func (l *LogLevel) Set(s string) error {
0000000000000000000000000000000000000000;;		value, err := ParseLevel(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*l = value
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseLevel translates some potential loglevel strings into their corresponding levels.
0000000000000000000000000000000000000000;;	func ParseLevel(s string) (LogLevel, error) {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "CRITICAL", "C":
0000000000000000000000000000000000000000;;			return CRITICAL, nil
0000000000000000000000000000000000000000;;		case "ERROR", "0", "E":
0000000000000000000000000000000000000000;;			return ERROR, nil
0000000000000000000000000000000000000000;;		case "WARNING", "1", "W":
0000000000000000000000000000000000000000;;			return WARNING, nil
0000000000000000000000000000000000000000;;		case "NOTICE", "2", "N":
0000000000000000000000000000000000000000;;			return NOTICE, nil
0000000000000000000000000000000000000000;;		case "INFO", "3", "I":
0000000000000000000000000000000000000000;;			return INFO, nil
0000000000000000000000000000000000000000;;		case "DEBUG", "4", "D":
0000000000000000000000000000000000000000;;			return DEBUG, nil
0000000000000000000000000000000000000000;;		case "TRACE", "5", "T":
0000000000000000000000000000000000000000;;			return TRACE, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return CRITICAL, errors.New("couldn't parse log level " + s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RepoLogger map[string]*PackageLogger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type loggerStruct struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		repoMap   map[string]RepoLogger
0000000000000000000000000000000000000000;;		formatter Formatter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// logger is the global logger
0000000000000000000000000000000000000000;;	var logger = new(loggerStruct)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetGlobalLogLevel sets the log level for all packages in all repositories
0000000000000000000000000000000000000000;;	// registered with capnslog.
0000000000000000000000000000000000000000;;	func SetGlobalLogLevel(l LogLevel) {
0000000000000000000000000000000000000000;;		logger.Lock()
0000000000000000000000000000000000000000;;		defer logger.Unlock()
0000000000000000000000000000000000000000;;		for _, r := range logger.repoMap {
0000000000000000000000000000000000000000;;			r.setRepoLogLevelInternal(l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRepoLogger may return the handle to the repository's set of packages' loggers.
0000000000000000000000000000000000000000;;	func GetRepoLogger(repo string) (RepoLogger, error) {
0000000000000000000000000000000000000000;;		logger.Lock()
0000000000000000000000000000000000000000;;		defer logger.Unlock()
0000000000000000000000000000000000000000;;		r, ok := logger.repoMap[repo]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("no packages registered for repo " + repo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustRepoLogger returns the handle to the repository's packages' loggers.
0000000000000000000000000000000000000000;;	func MustRepoLogger(repo string) RepoLogger {
0000000000000000000000000000000000000000;;		r, err := GetRepoLogger(repo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetRepoLogLevel sets the log level for all packages in the repository.
0000000000000000000000000000000000000000;;	func (r RepoLogger) SetRepoLogLevel(l LogLevel) {
0000000000000000000000000000000000000000;;		logger.Lock()
0000000000000000000000000000000000000000;;		defer logger.Unlock()
0000000000000000000000000000000000000000;;		r.setRepoLogLevelInternal(l)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r RepoLogger) setRepoLogLevelInternal(l LogLevel) {
0000000000000000000000000000000000000000;;		for _, v := range r {
0000000000000000000000000000000000000000;;			v.level = l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseLogLevelConfig parses a comma-separated string of "package=loglevel", in
0000000000000000000000000000000000000000;;	// order, and returns a map of the results, for use in SetLogLevel.
0000000000000000000000000000000000000000;;	func (r RepoLogger) ParseLogLevelConfig(conf string) (map[string]LogLevel, error) {
0000000000000000000000000000000000000000;;		setlist := strings.Split(conf, ",")
0000000000000000000000000000000000000000;;		out := make(map[string]LogLevel)
0000000000000000000000000000000000000000;;		for _, setstring := range setlist {
0000000000000000000000000000000000000000;;			setting := strings.Split(setstring, "=")
0000000000000000000000000000000000000000;;			if len(setting) != 2 {
0000000000000000000000000000000000000000;;				return nil, errors.New("oddly structured `pkg=level` option: " + setstring)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l, err := ParseLevel(setting[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out[setting[0]] = l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLogLevel takes a map of package names within a repository to their desired
0000000000000000000000000000000000000000;;	// loglevel, and sets the levels appropriately. Unknown packages are ignored.
0000000000000000000000000000000000000000;;	// "*" is a special package name that corresponds to all packages, and will be
0000000000000000000000000000000000000000;;	// processed first.
0000000000000000000000000000000000000000;;	func (r RepoLogger) SetLogLevel(m map[string]LogLevel) {
0000000000000000000000000000000000000000;;		logger.Lock()
0000000000000000000000000000000000000000;;		defer logger.Unlock()
0000000000000000000000000000000000000000;;		if l, ok := m["*"]; ok {
0000000000000000000000000000000000000000;;			r.setRepoLogLevelInternal(l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			l, ok := r[k]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.level = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetFormatter sets the formatting function for all logs.
0000000000000000000000000000000000000000;;	func SetFormatter(f Formatter) {
0000000000000000000000000000000000000000;;		logger.Lock()
0000000000000000000000000000000000000000;;		defer logger.Unlock()
0000000000000000000000000000000000000000;;		logger.formatter = f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPackageLogger creates a package logger object.
0000000000000000000000000000000000000000;;	// This should be defined as a global var in your package, referencing your repo.
0000000000000000000000000000000000000000;;	func NewPackageLogger(repo string, pkg string) (p *PackageLogger) {
0000000000000000000000000000000000000000;;		logger.Lock()
0000000000000000000000000000000000000000;;		defer logger.Unlock()
0000000000000000000000000000000000000000;;		if logger.repoMap == nil {
0000000000000000000000000000000000000000;;			logger.repoMap = make(map[string]RepoLogger)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, rok := logger.repoMap[repo]
0000000000000000000000000000000000000000;;		if !rok {
0000000000000000000000000000000000000000;;			logger.repoMap[repo] = make(RepoLogger)
0000000000000000000000000000000000000000;;			r = logger.repoMap[repo]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, pok := r[pkg]
0000000000000000000000000000000000000000;;		if !pok {
0000000000000000000000000000000000000000;;			r[pkg] = &PackageLogger{
0000000000000000000000000000000000000000;;				pkg:   pkg,
0000000000000000000000000000000000000000;;				level: INFO,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p = r[pkg]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
