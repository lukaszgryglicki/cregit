0000000000000000000000000000000000000000;;	// Copyright (c) 2016 VMware, Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product is licensed to you under the Apache License, Version 2.0 (the "License").
0000000000000000000000000000000000000000;;	// You may not use this product except in compliance with the License.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product may include a number of subcomponents with separate copyright notices and
0000000000000000000000000000000000000000;;	// license terms. Your use of these subcomponents is subject to the terms and conditions
0000000000000000000000000000000000000000;;	// of the subcomponent's license, as noted in the LICENSE file.
0397bbe9e5e919442706b4face2f9b10553493d7;;	
0000000000000000000000000000000000000000;;	package photon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type restClient struct {
0000000000000000000000000000000000000000;;		httpClient                *http.Client
0000000000000000000000000000000000000000;;		logger                    *log.Logger
0000000000000000000000000000000000000000;;		Auth                      *AuthAPI
0000000000000000000000000000000000000000;;		UpdateAccessTokenCallback TokenCallback
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type request struct {
0000000000000000000000000000000000000000;;		Method      string
0000000000000000000000000000000000000000;;		URL         string
0000000000000000000000000000000000000000;;		ContentType string
0000000000000000000000000000000000000000;;		Body        io.Reader
0000000000000000000000000000000000000000;;		Tokens      *TokenOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type page struct {
0000000000000000000000000000000000000000;;		Items            []interface{} `json:"items"`
0000000000000000000000000000000000000000;;		NextPageLink     string        `json:"nextPageLink"`
0000000000000000000000000000000000000000;;		PreviousPageLink string        `json:"previousPageLink"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type documentList struct {
0000000000000000000000000000000000000000;;		Items []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bodyRewinder func() io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const appJson string = "application/json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Root URL specifies the API version.
0000000000000000000000000000000000000000;;	const rootUrl string = "/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From https://golang.org/src/mime/multipart/writer.go
0000000000000000000000000000000000000000;;	var quoteEscaper = strings.NewReplacer("\\", "\\\\", `"`, "\\\"")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) AppendSlice(origSlice []interface{}, dataToAppend []interface{}) []interface{} {
0000000000000000000000000000000000000000;;		origLen := len(origSlice)
0000000000000000000000000000000000000000;;		newLen := origLen + len(dataToAppend)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if newLen > cap(origSlice) {
0000000000000000000000000000000000000000;;			newSlice := make([]interface{}, (newLen+1)*2)
0000000000000000000000000000000000000000;;			copy(newSlice, origSlice)
0000000000000000000000000000000000000000;;			origSlice = newSlice
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		origSlice = origSlice[0:newLen]
0000000000000000000000000000000000000000;;		copy(origSlice[origLen:newLen], dataToAppend)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return origSlice
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) Get(url string, tokens *TokenOptions) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		req := request{"GET", url, "", nil, tokens}
0000000000000000000000000000000000000000;;		res, err = client.SendRequest(&req, nil)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) GetList(endpoint string, url string, tokens *TokenOptions) (result []byte, err error) {
0000000000000000000000000000000000000000;;		req := request{"GET", url, "", nil, tokens}
0000000000000000000000000000000000000000;;		res, err := client.SendRequest(&req, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err = getError(res)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(res.Body)
0000000000000000000000000000000000000000;;		decoder.UseNumber()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		page := &page{}
0000000000000000000000000000000000000000;;		err = decoder.Decode(page)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		documentList := &documentList{}
0000000000000000000000000000000000000000;;		documentList.Items = client.AppendSlice(documentList.Items, page.Items)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for page.NextPageLink != "" {
0000000000000000000000000000000000000000;;			req = request{"GET", endpoint + page.NextPageLink, "", nil, tokens}
0000000000000000000000000000000000000000;;			res, err = client.SendRequest(&req, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res, err = getError(res)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			decoder = json.NewDecoder(res.Body)
0000000000000000000000000000000000000000;;			decoder.UseNumber()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			page.NextPageLink = ""
0000000000000000000000000000000000000000;;			page.PreviousPageLink = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = decoder.Decode(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			documentList.Items = client.AppendSlice(documentList.Items, page.Items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result, err = json.Marshal(documentList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) Post(url string, contentType string, body io.ReadSeeker, tokens *TokenOptions) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		if contentType == "" {
0000000000000000000000000000000000000000;;			contentType = appJson
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := request{"POST", url, contentType, body, tokens}
0000000000000000000000000000000000000000;;		rewinder := func() io.Reader {
0000000000000000000000000000000000000000;;			body.Seek(0, 0)
0000000000000000000000000000000000000000;;			return body
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err = client.SendRequest(&req, rewinder)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) Patch(url string, contentType string, body io.ReadSeeker, tokens *TokenOptions) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		if contentType == "" {
0000000000000000000000000000000000000000;;			contentType = appJson
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := request{"PATCH", url, contentType, body, tokens}
0000000000000000000000000000000000000000;;		rewinder := func() io.Reader {
0000000000000000000000000000000000000000;;			body.Seek(0, 0)
0000000000000000000000000000000000000000;;			return body
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err = client.SendRequest(&req, rewinder)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) Put(url string, contentType string, body io.ReadSeeker, tokens *TokenOptions) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		if contentType == "" {
0000000000000000000000000000000000000000;;			contentType = appJson
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := request{"PUT", url, contentType, body, tokens}
0000000000000000000000000000000000000000;;		rewinder := func() io.Reader {
0000000000000000000000000000000000000000;;			body.Seek(0, 0)
0000000000000000000000000000000000000000;;			return body
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err = client.SendRequest(&req, rewinder)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) Delete(url string, tokens *TokenOptions) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		req := request{"DELETE", url, "", nil, tokens}
0000000000000000000000000000000000000000;;		res, err = client.SendRequest(&req, nil)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) SendRequest(req *request, bodyRewinder bodyRewinder) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		res, err = client.sendRequestHelper(req)
0000000000000000000000000000000000000000;;		// In most cases, we'll return immediately
0000000000000000000000000000000000000000;;		// If the operation succeeded, but we got a 401 response and if we're using
0000000000000000000000000000000000000000;;		// authentication, then we'll look into the body to see if the token expired
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if res.StatusCode != 401 {
0000000000000000000000000000000000000000;;			// It's not a 401, so the token didn't expire
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.Tokens == nil || req.Tokens.AccessToken == "" {
0000000000000000000000000000000000000000;;			// We don't have a token, so we can't renew the token, no need to proceed
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We're going to look in the body to see if it failed because the token expired
0000000000000000000000000000000000000000;;		// This means we need to read the body, but the functions that call us also
0000000000000000000000000000000000000000;;		// expect to read the body. So we read the body, then create a new reader
0000000000000000000000000000000000000000;;		// so they can read the body as normal.
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res.Body = ioutil.NopCloser(bytes.NewReader(body))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now see if we had an expired token or not
0000000000000000000000000000000000000000;;		var apiError ApiError
0000000000000000000000000000000000000000;;		err = json.Unmarshal(body, &apiError)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if apiError.Code != "ExpiredAuthToken" {
0000000000000000000000000000000000000000;;			return res, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We were told that the access token expired, so try to renew it.
0000000000000000000000000000000000000000;;		// Note that this looks recursive because GetTokensByRefreshToken() will
0000000000000000000000000000000000000000;;		// call the /auth API, and therefore SendRequest(). However, it calls
0000000000000000000000000000000000000000;;		// without a token, so we avoid having a loop
0000000000000000000000000000000000000000;;		newTokens, err := client.Auth.GetTokensByRefreshToken(req.Tokens.RefreshToken)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return res, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Tokens.AccessToken = newTokens.AccessToken
0000000000000000000000000000000000000000;;		if client.UpdateAccessTokenCallback != nil {
0000000000000000000000000000000000000000;;			client.UpdateAccessTokenCallback(newTokens.AccessToken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.Body != nil && bodyRewinder != nil {
0000000000000000000000000000000000000000;;			req.Body = bodyRewinder()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err = client.sendRequestHelper(req)
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) sendRequestHelper(req *request) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		r, err := http.NewRequest(req.Method, req.URL, req.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			client.logger.Printf("An error occured creating request %s on %s. Error: %s", req.Method, req.URL, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.ContentType != "" {
0000000000000000000000000000000000000000;;			r.Header.Add("Content-Type", req.ContentType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if req.Tokens != nil && req.Tokens.AccessToken != "" {
0000000000000000000000000000000000000000;;			r.Header.Add("Authorization", "Bearer "+req.Tokens.AccessToken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err = client.httpClient.Do(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			client.logger.Printf("An error occured when calling %s on %s. Error: %s", req.Method, req.URL, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.logger.Printf("[%s] %s - %s %s", res.Header.Get("request-id"), res.Status, req.Method, req.URL)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) MultipartUploadFile(url, filePath string, params map[string]string, tokens *TokenOptions) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(filePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		return client.MultipartUpload(url, file, filepath.Base(filePath), params, tokens)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) MultipartUpload(url string, reader io.ReadSeeker, filename string, params map[string]string, tokens *TokenOptions) (res *http.Response, err error) {
0000000000000000000000000000000000000000;;		boundary := client.randomBoundary()
0000000000000000000000000000000000000000;;		multiReader, contentType := client.createMultiReader(reader, filename, params, boundary)
0000000000000000000000000000000000000000;;		rewinder := func() io.Reader {
0000000000000000000000000000000000000000;;			reader.Seek(0, 0)
0000000000000000000000000000000000000000;;			multiReader, _ := client.createMultiReader(reader, filename, params, boundary)
0000000000000000000000000000000000000000;;			return multiReader
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		res, err = client.SendRequest(&request{"POST", url, contentType, multiReader, tokens}, rewinder)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *restClient) createMultiReader(reader io.ReadSeeker, filename string, params map[string]string, boundary string) (io.Reader, string) {
0000000000000000000000000000000000000000;;		// The mime/multipart package does not support streaming multipart data from disk,
0000000000000000000000000000000000000000;;		// at least not without complicated, problematic goroutines that simultaneously read/write into a buffer.
0000000000000000000000000000000000000000;;		// A much easier approach is to just construct the multipart request by hand, using io.MultiPart to
0000000000000000000000000000000000000000;;		// concatenate the parts of the request together into a single io.Reader.
0000000000000000000000000000000000000000;;		parts := []io.Reader{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a part for each key, val pair in params
0000000000000000000000000000000000000000;;		for k, v := range params {
0000000000000000000000000000000000000000;;			parts = append(parts, client.createFieldPart(k, v, boundary))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start := fmt.Sprintf("\r\n--%s\r\n", boundary)
0000000000000000000000000000000000000000;;		start += fmt.Sprintf("Content-Disposition: form-data; name=\"file\"; filename=\"%s\"\r\n", quoteEscaper.Replace(filename))
0000000000000000000000000000000000000000;;		start += fmt.Sprintf("Content-Type: application/octet-stream\r\n\r\n")
0000000000000000000000000000000000000000;;		end := fmt.Sprintf("\r\n--%s--", boundary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The request will consist of a reader to begin the request, a reader which points
0000000000000000000000000000000000000000;;		// to the file data on disk, and a reader containing the closing boundary of the request.
0000000000000000000000000000000000000000;;		parts = append(parts, strings.NewReader(start), reader, strings.NewReader(end))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contentType := fmt.Sprintf("multipart/form-data; boundary=%s", boundary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return io.MultiReader(parts...), contentType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From https://golang.org/src/mime/multipart/writer.go
0000000000000000000000000000000000000000;;	func (client *restClient) randomBoundary() string {
0000000000000000000000000000000000000000;;		var buf [30]byte
0000000000000000000000000000000000000000;;		_, err := io.ReadFull(rand.Reader, buf[:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%x", buf[:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a reader that encapsulates a single multipart form part
0000000000000000000000000000000000000000;;	func (client *restClient) createFieldPart(fieldname, value, boundary string) io.Reader {
0000000000000000000000000000000000000000;;		str := fmt.Sprintf("\r\n--%s\r\n", boundary)
0000000000000000000000000000000000000000;;		str += fmt.Sprintf("Content-Disposition: form-data; name=\"%s\"\r\n\r\n", quoteEscaper.Replace(fieldname))
0000000000000000000000000000000000000000;;		str += value
0000000000000000000000000000000000000000;;		return strings.NewReader(str)
0000000000000000000000000000000000000000;;	}
