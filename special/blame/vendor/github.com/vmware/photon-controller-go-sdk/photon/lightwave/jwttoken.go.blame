0000000000000000000000000000000000000000;;	package lightwave
0397bbe9e5e919442706b4face2f9b10553493d7;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JWTToken struct {
0000000000000000000000000000000000000000;;		TokenId    string   `json:"jti"`
0000000000000000000000000000000000000000;;		Algorithm  string   `json:"alg"`
0000000000000000000000000000000000000000;;		Subject    string   `json:"sub"`
0000000000000000000000000000000000000000;;		Audience   []string `json:"aud"`
0000000000000000000000000000000000000000;;		Groups     []string `json:"groups"`
0000000000000000000000000000000000000000;;		Issuer     string   `json:"iss"`
0000000000000000000000000000000000000000;;		IssuedAt   int64    `json:"iat"`
0000000000000000000000000000000000000000;;		Expires    int64    `json:"exp"`
0000000000000000000000000000000000000000;;		Scope      string   `json:"scope"`
0000000000000000000000000000000000000000;;		TokenType  string   `json:"token_type"`
0000000000000000000000000000000000000000;;		TokenClass string   `json:"token_class"`
0000000000000000000000000000000000000000;;		Tenant     string   `json:"tenant"`
0000000000000000000000000000000000000000;;		// It's possible to have more fields depending on how Lightwave defines the token.
0000000000000000000000000000000000000000;;		// This covers all the fields we currently have.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A JSON web token is a set of Base64 encoded strings separated by a period (.)
0000000000000000000000000000000000000000;;	// When decoded, it will either be JSON text or a signature
0000000000000000000000000000000000000000;;	// Here we decode the strings into a single token structure. We do not parse the signature.
0000000000000000000000000000000000000000;;	func ParseTokenDetails(token string) (jwtToken *JWTToken) {
0000000000000000000000000000000000000000;;		jwtToken = &JWTToken{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chunks := strings.Split(token, ".")
0000000000000000000000000000000000000000;;		for _, chunk := range chunks {
0000000000000000000000000000000000000000;;			json_string, err := base64.RawURLEncoding.DecodeString(chunk)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				// Ignore errors. We expect that the signature is not JSON,
0000000000000000000000000000000000000000;;				// so unmarshalling it will fail. That's fine. We'll extract
0000000000000000000000000000000000000000;;				// all the data we can.
0000000000000000000000000000000000000000;;				_ = json.Unmarshal(json_string, &jwtToken)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jwtToken
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A JSON web token is a set of Base64 encoded strings separated by a period (.)
0000000000000000000000000000000000000000;;	// When decoded, it will either be JSON text or a signature
0000000000000000000000000000000000000000;;	// Here we parse the full JSON text. We do not parse the signature.
0000000000000000000000000000000000000000;;	func ParseRawTokenDetails(token string) (jwtToken []string, err error) {
0000000000000000000000000000000000000000;;		chunks := strings.Split(token, ".")
0000000000000000000000000000000000000000;;		for _, chunk := range chunks {
0000000000000000000000000000000000000000;;			jsonString, err := base64.RawURLEncoding.DecodeString(chunk)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				jwtToken = append(jwtToken, string(jsonString))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return jwtToken, err
0000000000000000000000000000000000000000;;	}
