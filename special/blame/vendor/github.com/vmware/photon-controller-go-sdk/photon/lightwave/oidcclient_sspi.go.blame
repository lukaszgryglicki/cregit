0000000000000000000000000000000000000000;;	// Copyright (c) 2017 VMware, Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product is licensed to you under the Apache License, Version 2.0 (the "License").
0000000000000000000000000000000000000000;;	// You may not use this product except in compliance with the License.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product may include a number of subcomponents with separate copyright notices and
0000000000000000000000000000000000000000;;	// license terms. Your use of these subcomponents is subject to the terms and conditions
0000000000000000000000000000000000000000;;	// of the subcomponent's license, as noted in the LICENSE file.
df2e52f6d8f62c39f985d4ae6f4503dd137f6093;;	
0000000000000000000000000000000000000000;;	// +build windows
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package lightwave
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"github.com/vmware/photon-controller-go-sdk/SSPI"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const gssTicketGrantFormatString = "grant_type=urn:vmware:grant_type:gss_ticket&gss_ticket=%s&context_id=%s&scope=%s"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTokensFromWindowsLogInContext gets tokens based on Windows logged in context
0000000000000000000000000000000000000000;;	// Here is how it works:
0000000000000000000000000000000000000000;;	// 1. Get the SPN (Service Principal Name) in the format host/FQDN of lightwave. This is needed for SSPI/Kerberos protocol
0000000000000000000000000000000000000000;;	// 2. Call Windows API AcquireCredentialsHandle() using SSPI library. This will give the current users credential handle
0000000000000000000000000000000000000000;;	// 3. Using this handle call Windows API AcquireCredentialsHandle(). This will give you byte[]
0000000000000000000000000000000000000000;;	// 4. Encode this byte[] and send it to OIDC server over HTTP (using POST)
0000000000000000000000000000000000000000;;	// 5. OIDC server can send either of the following
0000000000000000000000000000000000000000;;	//    - Access tokens. In this case return access tokens to client
0000000000000000000000000000000000000000;;	//    - Error in the format: invalid_grant: gss_continue_needed:'context id':'token from server'
0000000000000000000000000000000000000000;;	// 6. In case you get error, parse it and get the token from server
0000000000000000000000000000000000000000;;	// 7. Feed this token to step 3 and repeat steps till you get the access tokens from server
0000000000000000000000000000000000000000;;	func (client *OIDCClient) GetTokensFromWindowsLogInContext() (tokens *OIDCTokenResponse, err error) {
0000000000000000000000000000000000000000;;		spn, err := client.buildSPN()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		auth, _ := SSPI.GetAuth("", "", spn, "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		userContext, err := auth.InitialBytes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In case of multiple req/res between client and server (as explained in above comment),
0000000000000000000000000000000000000000;;		// server needs to maintain the mapping of context id -> token
0000000000000000000000000000000000000000;;		// So we need to generate random string as a context id
0000000000000000000000000000000000000000;;		// If we use same context id for all the requests, results can be erroneous
0000000000000000000000000000000000000000;;		contextId := client.generateRandomString()
0000000000000000000000000000000000000000;;		body := fmt.Sprintf(gssTicketGrantFormatString, url.QueryEscape(base64.StdEncoding.EncodeToString(userContext)), contextId, client.Options.TokenScope)
0000000000000000000000000000000000000000;;		tokens, err = client.getToken(body)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// In case of error the response will be in format: invalid_grant: gss_continue_needed:'context id':'token from server'
0000000000000000000000000000000000000000;;			gssToken := client.validateAndExtractGSSResponse(err, contextId)
0000000000000000000000000000000000000000;;			if gssToken == "" {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			data, err := base64.StdEncoding.DecodeString(gssToken)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			userContext, err := auth.NextBytes(data)
0000000000000000000000000000000000000000;;			body := fmt.Sprintf(gssTicketGrantFormatString, url.QueryEscape(base64.StdEncoding.EncodeToString(userContext)), contextId, client.Options.TokenScope)
0000000000000000000000000000000000000000;;			tokens, err = client.getToken(body)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tokens, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the SPN (Service Principal Name) in the format host/FQDN of lightwave
0000000000000000000000000000000000000000;;	func (client *OIDCClient) buildSPN() (spn string, err error) {
0000000000000000000000000000000000000000;;		u, err := url.Parse(client.Endpoint)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, _, err := net.SplitHostPort(u.Host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr, err := net.LookupAddr(host)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s = strings.TrimSuffix(addr[0], ".")
0000000000000000000000000000000000000000;;		return "host/" + s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validateAndExtractGSSResponse parse the error from server and returns token from server
0000000000000000000000000000000000000000;;	// In case of error from the server, response will be in format: invalid_grant: gss_continue_needed:'context id':'token from server'
0000000000000000000000000000000000000000;;	// So, we check for the above format in error and then return the token from server
0000000000000000000000000000000000000000;;	// If error is not in above format, we return empty string
0000000000000000000000000000000000000000;;	func (client *OIDCClient) validateAndExtractGSSResponse(err error, contextId string) string {
0000000000000000000000000000000000000000;;		parts := strings.Split(err.Error(), ":")
0000000000000000000000000000000000000000;;		if !(len(parts) == 4 && strings.TrimSpace(parts[1]) == "gss_continue_needed" && parts[2] == contextId) {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return parts[3]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) generateRandomString() string {
0000000000000000000000000000000000000000;;		const length = 10
0000000000000000000000000000000000000000;;		const asciiA = 65
0000000000000000000000000000000000000000;;		const asciiZ = 90
0000000000000000000000000000000000000000;;		rand.Seed(time.Now().UTC().UnixNano())
0000000000000000000000000000000000000000;;		bytes := make([]byte, length)
0000000000000000000000000000000000000000;;		for i := 0; i < length; i++ {
0000000000000000000000000000000000000000;;			bytes[i] = byte(randInt(asciiA, asciiZ))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(bytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func randInt(min int, max int) int {
0000000000000000000000000000000000000000;;		return min + rand.Intn(max-min)
0000000000000000000000000000000000000000;;	}
