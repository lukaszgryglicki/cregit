0000000000000000000000000000000000000000;;	// Copyright (c) 2016 VMware, Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product is licensed to you under the Apache License, Version 2.0 (the "License").
0000000000000000000000000000000000000000;;	// You may not use this product except in compliance with the License.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product may include a number of subcomponents with separate copyright notices and
0000000000000000000000000000000000000000;;	// license terms. Your use of these subcomponents is subject to the terms and conditions
0000000000000000000000000000000000000000;;	// of the subcomponent's license, as noted in the LICENSE file.
0397bbe9e5e919442706b4face2f9b10553493d7;;	
0000000000000000000000000000000000000000;;	package lightwave
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const tokenScope string = "openid offline_access"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCClient struct {
0000000000000000000000000000000000000000;;		httpClient *http.Client
0000000000000000000000000000000000000000;;		logger     *log.Logger
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Endpoint string
0000000000000000000000000000000000000000;;		Options  *OIDCClientOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCClientOptions struct {
0000000000000000000000000000000000000000;;		// Whether or not to ignore any TLS errors when talking to photon,
0000000000000000000000000000000000000000;;		// false by default.
0000000000000000000000000000000000000000;;		IgnoreCertificate bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of root CA's to use for server validation
0000000000000000000000000000000000000000;;		// nil by default.
0000000000000000000000000000000000000000;;		RootCAs *x509.CertPool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The scope values to use when requesting tokens
0000000000000000000000000000000000000000;;		TokenScope string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewOIDCClient(endpoint string, options *OIDCClientOptions, logger *log.Logger) (c *OIDCClient) {
0000000000000000000000000000000000000000;;		if logger == nil {
0000000000000000000000000000000000000000;;			logger = log.New(ioutil.Discard, "", log.LstdFlags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options = buildOptions(options)
0000000000000000000000000000000000000000;;		tr := &http.Transport{
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;				InsecureSkipVerify: options.IgnoreCertificate,
0000000000000000000000000000000000000000;;				RootCAs:            options.RootCAs},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c = &OIDCClient{
0000000000000000000000000000000000000000;;			httpClient: &http.Client{Transport: tr},
0000000000000000000000000000000000000000;;			logger:     logger,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			Endpoint: strings.TrimRight(endpoint, "/"),
0000000000000000000000000000000000000000;;			Options:  options,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildOptions(options *OIDCClientOptions) (result *OIDCClientOptions) {
0000000000000000000000000000000000000000;;		result = &OIDCClientOptions{
0000000000000000000000000000000000000000;;			TokenScope: tokenScope,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.IgnoreCertificate = options.IgnoreCertificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.RootCAs != nil {
0000000000000000000000000000000000000000;;			result.RootCAs = options.RootCAs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.TokenScope != "" {
0000000000000000000000000000000000000000;;			result.TokenScope = options.TokenScope
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) buildUrl(path string) (url string) {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%s", client.Endpoint, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cert download helper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const certDownloadPath string = "/afd/vecs/ssl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lightWaveCert struct {
0000000000000000000000000000000000000000;;		Value string `json:"encoded"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) GetRootCerts() (certList []*x509.Certificate, err error) {
0000000000000000000000000000000000000000;;		// turn TLS verification off for
0000000000000000000000000000000000000000;;		originalTr := client.httpClient.Transport
0000000000000000000000000000000000000000;;		defer client.setTransport(originalTr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr := &http.Transport{
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;				InsecureSkipVerify: true,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		client.setTransport(tr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get the certs
0000000000000000000000000000000000000000;;		resp, err := client.httpClient.Get(client.buildUrl(certDownloadPath))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Unexpected error retrieving auth server certs: %v %s", resp.StatusCode, resp.Status)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse the certs
0000000000000000000000000000000000000000;;		certsData := &[]lightWaveCert{}
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(certsData)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		certList = make([]*x509.Certificate, len(*certsData))
0000000000000000000000000000000000000000;;		for idx, cert := range *certsData {
0000000000000000000000000000000000000000;;			block, _ := pem.Decode([]byte(cert.Value))
0000000000000000000000000000000000000000;;			if block == nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Unexpected response format: %v", certsData)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			decodedCert, err := x509.ParseCertificate(block.Bytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			certList[idx] = decodedCert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) setTransport(tr http.RoundTripper) {
0000000000000000000000000000000000000000;;		client.httpClient.Transport = tr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Toke request helpers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const tokenPath string = "/openidconnect/token"
0000000000000000000000000000000000000000;;	const passwordGrantFormatString = "grant_type=password&username=%s&password=%s&scope=%s"
0000000000000000000000000000000000000000;;	const refreshTokenGrantFormatString = "grant_type=refresh_token&refresh_token=%s"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCTokenResponse struct {
0000000000000000000000000000000000000000;;		AccessToken  string `json:"access_token"`
0000000000000000000000000000000000000000;;		ExpiresIn    int    `json:"expires_in"`
0000000000000000000000000000000000000000;;		RefreshToken string `json:"refresh_token,omitempty"`
0000000000000000000000000000000000000000;;		IdToken      string `json:"id_token"`
0000000000000000000000000000000000000000;;		TokenType    string `json:"token_type"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) GetTokenByPasswordGrant(username string, password string) (tokens *OIDCTokenResponse, err error) {
0000000000000000000000000000000000000000;;		username = url.QueryEscape(username)
0000000000000000000000000000000000000000;;		password = url.QueryEscape(password)
0000000000000000000000000000000000000000;;		body := fmt.Sprintf(passwordGrantFormatString, username, password, client.Options.TokenScope)
0000000000000000000000000000000000000000;;		return client.getToken(body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) GetTokenByRefreshTokenGrant(refreshToken string) (tokens *OIDCTokenResponse, err error) {
0000000000000000000000000000000000000000;;		body := fmt.Sprintf(refreshTokenGrantFormatString, refreshToken)
0000000000000000000000000000000000000000;;		return client.getToken(body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) getToken(body string) (tokens *OIDCTokenResponse, err error) {
0000000000000000000000000000000000000000;;		request, err := http.NewRequest("POST", client.buildUrl(tokenPath), strings.NewReader(body))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		request.Header.Add("Content-Type", "application/x-www-form-urlencoded")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.httpClient.Do(request)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = client.checkResponse(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokens = &OIDCTokenResponse{}
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(tokens)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OIDCError struct {
0000000000000000000000000000000000000000;;		Code    string `json:"error"`
0000000000000000000000000000000000000000;;		Message string `json:"error_description"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e OIDCError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v: %v", e.Code, e.Message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (client *OIDCClient) checkResponse(response *http.Response) (err error) {
0000000000000000000000000000000000000000;;		if response.StatusCode/100 == 2 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		respBody, readErr := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"Status: %v, Body: %v [%v]", response.Status, string(respBody[:]), readErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var oidcErr OIDCError
0000000000000000000000000000000000000000;;		err = json.Unmarshal(respBody, &oidcErr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"Status: %v, Body: %v [%v]", response.Status, string(respBody[:]), readErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return oidcErr
0000000000000000000000000000000000000000;;	}
