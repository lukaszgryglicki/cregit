0000000000000000000000000000000000000000;;	// Copyright (c) 2016 VMware, Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product is licensed to you under the Apache License, Version 2.0 (the "License").
0000000000000000000000000000000000000000;;	// You may not use this product except in compliance with the License.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product may include a number of subcomponents with separate copyright notices and
0000000000000000000000000000000000000000;;	// license terms. Your use of these subcomponents is subject to the terms and conditions
0000000000000000000000000000000000000000;;	// of the subcomponent's license, as noted in the LICENSE file.
0397bbe9e5e919442706b4face2f9b10553493d7;;	
0000000000000000000000000000000000000000;;	package photon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reads an error out of the HTTP response, or does nothing if
0000000000000000000000000000000000000000;;	// no error occured.
0000000000000000000000000000000000000000;;	func getError(res *http.Response) (*http.Response, error) {
0000000000000000000000000000000000000000;;		// Do nothing if the response is a successful 2xx
0000000000000000000000000000000000000000;;		if res.StatusCode/100 == 2 {
0000000000000000000000000000000000000000;;			return res, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var apiError ApiError
0000000000000000000000000000000000000000;;		// ReadAll is usually a bad practice, but here we need to read the response all
0000000000000000000000000000000000000000;;		// at once because we may attempt to use the data twice. It's preferable to use
0000000000000000000000000000000000000000;;		// methods that take io.Reader, e.g. json.NewDecoder
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(res.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(body, &apiError)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// If deserializing into ApiError fails, return a generic HttpError instead
0000000000000000000000000000000000000000;;			return nil, HttpError{res.StatusCode, string(body[:])}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		apiError.HttpStatusCode = res.StatusCode
0000000000000000000000000000000000000000;;		return nil, apiError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reads a task object out of the HTTP response. Takes an error argument
0000000000000000000000000000000000000000;;	// so that GetTask can easily wrap GetError. This function will do nothing
0000000000000000000000000000000000000000;;	// if e is not nil.
0000000000000000000000000000000000000000;;	// e.g. res, err := getTask(getError(someApi.Get()))
0000000000000000000000000000000000000000;;	func getTask(res *http.Response, e error) (*Task, error) {
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var task Task
0000000000000000000000000000000000000000;;		err := json.NewDecoder(res.Body).Decode(&task)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if task.State == "ERROR" {
0000000000000000000000000000000000000000;;			// Critical: return task as well, so that it can be examined
0000000000000000000000000000000000000000;;			// for error details.
0000000000000000000000000000000000000000;;			return &task, TaskError{task.ID, getFailedStep(&task)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &task, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts an options struct into a query string.
0000000000000000000000000000000000000000;;	// E.g. type Foo struct {A int; B int} might return "?a=5&b=10".
0000000000000000000000000000000000000000;;	// Will return an empty string if no options are set.
0000000000000000000000000000000000000000;;	func getQueryString(options interface{}) string {
0000000000000000000000000000000000000000;;		buffer := bytes.Buffer{}
0000000000000000000000000000000000000000;;		buffer.WriteString("?")
0000000000000000000000000000000000000000;;		strct := reflect.ValueOf(options).Elem()
0000000000000000000000000000000000000000;;		typ := strct.Type()
0000000000000000000000000000000000000000;;		for i := 0; i < strct.NumField(); i++ {
0000000000000000000000000000000000000000;;			field := strct.Field(i)
0000000000000000000000000000000000000000;;			value := fmt.Sprint(field.Interface())
0000000000000000000000000000000000000000;;			if value != "" {
0000000000000000000000000000000000000000;;				buffer.WriteString(typ.Field(i).Tag.Get("urlParam") + "=" + url.QueryEscape(value))
0000000000000000000000000000000000000000;;				if i < strct.NumField()-1 {
0000000000000000000000000000000000000000;;					buffer.WriteString("&")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		uri := buffer.String()
0000000000000000000000000000000000000000;;		if uri == "?" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uri
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sets security groups for a given entity (deployment/tenant/project)
0000000000000000000000000000000000000000;;	func setSecurityGroups(client *Client, entityUrl string, securityGroups *SecurityGroupsSpec) (task *Task, err error) {
0000000000000000000000000000000000000000;;		body, err := json.Marshal(securityGroups)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		url := entityUrl + "/set_security_groups"
0000000000000000000000000000000000000000;;		res, err := client.restClient.Post(
0000000000000000000000000000000000000000;;			url,
0000000000000000000000000000000000000000;;			"application/json",
0000000000000000000000000000000000000000;;			bytes.NewReader(body),
0000000000000000000000000000000000000000;;			client.options.TokenOptions)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer res.Body.Close()
0000000000000000000000000000000000000000;;		task, err = getTask(getError(res))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
