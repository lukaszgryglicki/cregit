0000000000000000000000000000000000000000;;	// Copyright (c) 2016 VMware, Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product is licensed to you under the Apache License, Version 2.0 (the "License").
0000000000000000000000000000000000000000;;	// You may not use this product except in compliance with the License.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This product may include a number of subcomponents with separate copyright notices and
0000000000000000000000000000000000000000;;	// license terms. Your use of these subcomponents is subject to the terms and conditions
0000000000000000000000000000000000000000;;	// of the subcomponent's license, as noted in the LICENSE file.
0397bbe9e5e919442706b4face2f9b10553493d7;;	
0000000000000000000000000000000000000000;;	package photon
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents stateless context needed to call photon APIs.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		options           ClientOptions
0000000000000000000000000000000000000000;;		restClient        *restClient
0000000000000000000000000000000000000000;;		logger            *log.Logger
0000000000000000000000000000000000000000;;		Endpoint          string
0000000000000000000000000000000000000000;;		Status            *StatusAPI
0000000000000000000000000000000000000000;;		Tenants           *TenantsAPI
0000000000000000000000000000000000000000;;		Tasks             *TasksAPI
0000000000000000000000000000000000000000;;		Projects          *ProjectsAPI
0000000000000000000000000000000000000000;;		Flavors           *FlavorsAPI
0000000000000000000000000000000000000000;;		Images            *ImagesAPI
0000000000000000000000000000000000000000;;		Disks             *DisksAPI
0000000000000000000000000000000000000000;;		VMs               *VmAPI
0000000000000000000000000000000000000000;;		Hosts             *HostsAPI
0000000000000000000000000000000000000000;;		Deployments       *DeploymentsAPI
0000000000000000000000000000000000000000;;		ResourceTickets   *ResourceTicketsAPI
0000000000000000000000000000000000000000;;		Networks          *NetworksAPI
0000000000000000000000000000000000000000;;		VirtualSubnets    *VirtualSubnetsAPI
0000000000000000000000000000000000000000;;		Services          *ServicesAPI
0000000000000000000000000000000000000000;;		Auth              *AuthAPI
0000000000000000000000000000000000000000;;		AvailabilityZones *AvailabilityZonesAPI
0000000000000000000000000000000000000000;;		Info              *InfoAPI
0000000000000000000000000000000000000000;;		Routers           *RoutersAPI
0000000000000000000000000000000000000000;;		Subnets           *SubnetsAPI
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents Tokens
0000000000000000000000000000000000000000;;	type TokenOptions struct {
0000000000000000000000000000000000000000;;		AccessToken  string `json:"access_token"`
0000000000000000000000000000000000000000;;		ExpiresIn    int    `json:"expires_in"`
0000000000000000000000000000000000000000;;		RefreshToken string `json:"refresh_token,omitempty"`
0000000000000000000000000000000000000000;;		IdToken      string `json:"id_token"`
0000000000000000000000000000000000000000;;		TokenType    string `json:"token_type"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TokenCallback func(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options for Client
0000000000000000000000000000000000000000;;	type ClientOptions struct {
0000000000000000000000000000000000000000;;		// When using the Tasks.Wait APIs, defines the duration of how long
0000000000000000000000000000000000000000;;		// the SDK should continue to poll the server. Default is 30 minutes.
0000000000000000000000000000000000000000;;		// TasksAPI.WaitTimeout() can be used to specify timeout on
0000000000000000000000000000000000000000;;		// individual calls.
0000000000000000000000000000000000000000;;		TaskPollTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether or not to ignore any TLS errors when talking to photon,
0000000000000000000000000000000000000000;;		// false by default.
0000000000000000000000000000000000000000;;		IgnoreCertificate bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List of root CA's to use for server validation
0000000000000000000000000000000000000000;;		// nil by default.
0000000000000000000000000000000000000000;;		RootCAs *x509.CertPool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For tasks APIs, defines the delay between each polling attempt.
0000000000000000000000000000000000000000;;		// Default is 100 milliseconds.
0000000000000000000000000000000000000000;;		TaskPollDelay time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For tasks APIs, defines the number of retries to make in the event
0000000000000000000000000000000000000000;;		// of an error. Default is 3.
0000000000000000000000000000000000000000;;		TaskRetryCount int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tokens for user authentication. Default is empty.
0000000000000000000000000000000000000000;;		TokenOptions *TokenOptions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// A function to be called if the access token was refreshed
0000000000000000000000000000000000000000;;		// The client can save the new access token for future API
0000000000000000000000000000000000000000;;		// calls so that it doesn't need to be refreshed again.
0000000000000000000000000000000000000000;;		UpdateAccessTokenCallback TokenCallback
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a new photon client with specified options. If options
0000000000000000000000000000000000000000;;	// is nil, default options will be used.
0000000000000000000000000000000000000000;;	func NewClient(endpoint string, options *ClientOptions, logger *log.Logger) (c *Client) {
0000000000000000000000000000000000000000;;		defaultOptions := &ClientOptions{
0000000000000000000000000000000000000000;;			TaskPollTimeout:   30 * time.Minute,
0000000000000000000000000000000000000000;;			TaskPollDelay:     100 * time.Millisecond,
0000000000000000000000000000000000000000;;			TaskRetryCount:    3,
0000000000000000000000000000000000000000;;			TokenOptions:      &TokenOptions{},
0000000000000000000000000000000000000000;;			IgnoreCertificate: false,
0000000000000000000000000000000000000000;;			RootCAs:           nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options != nil {
0000000000000000000000000000000000000000;;			if options.TaskPollTimeout != 0 {
0000000000000000000000000000000000000000;;				defaultOptions.TaskPollTimeout = options.TaskPollTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.TaskPollDelay != 0 {
0000000000000000000000000000000000000000;;				defaultOptions.TaskPollDelay = options.TaskPollDelay
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.TaskRetryCount != 0 {
0000000000000000000000000000000000000000;;				defaultOptions.TaskRetryCount = options.TaskRetryCount
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.TokenOptions != nil {
0000000000000000000000000000000000000000;;				defaultOptions.TokenOptions = options.TokenOptions
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.RootCAs != nil {
0000000000000000000000000000000000000000;;				defaultOptions.RootCAs = options.RootCAs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defaultOptions.IgnoreCertificate = options.IgnoreCertificate
0000000000000000000000000000000000000000;;			defaultOptions.UpdateAccessTokenCallback = options.UpdateAccessTokenCallback
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if logger == nil {
0000000000000000000000000000000000000000;;			logger = createPassThroughLogger()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tr := &http.Transport{
0000000000000000000000000000000000000000;;			TLSClientConfig: &tls.Config{
0000000000000000000000000000000000000000;;				InsecureSkipVerify: defaultOptions.IgnoreCertificate,
0000000000000000000000000000000000000000;;				RootCAs:            defaultOptions.RootCAs},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		endpoint = strings.TrimRight(endpoint, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenCallback := func(newToken string) {
0000000000000000000000000000000000000000;;			c.options.TokenOptions.AccessToken = newToken
0000000000000000000000000000000000000000;;			if c.options.UpdateAccessTokenCallback != nil {
0000000000000000000000000000000000000000;;				c.options.UpdateAccessTokenCallback(newToken)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		restClient := &restClient{
0000000000000000000000000000000000000000;;			httpClient: &http.Client{Transport: tr},
0000000000000000000000000000000000000000;;			logger:     logger,
0000000000000000000000000000000000000000;;			UpdateAccessTokenCallback: tokenCallback,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c = &Client{Endpoint: endpoint, restClient: restClient, logger: logger}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure a copy of options is made, rather than using a pointer
0000000000000000000000000000000000000000;;		// which may change out from underneath if misused by the caller.
0000000000000000000000000000000000000000;;		c.options = *defaultOptions
0000000000000000000000000000000000000000;;		c.Status = &StatusAPI{c}
0000000000000000000000000000000000000000;;		c.Tenants = &TenantsAPI{c}
0000000000000000000000000000000000000000;;		c.Tasks = &TasksAPI{c}
0000000000000000000000000000000000000000;;		c.Projects = &ProjectsAPI{c}
0000000000000000000000000000000000000000;;		c.Flavors = &FlavorsAPI{c}
0000000000000000000000000000000000000000;;		c.Images = &ImagesAPI{c}
0000000000000000000000000000000000000000;;		c.Disks = &DisksAPI{c}
0000000000000000000000000000000000000000;;		c.VMs = &VmAPI{c}
0000000000000000000000000000000000000000;;		c.Hosts = &HostsAPI{c}
0000000000000000000000000000000000000000;;		c.Deployments = &DeploymentsAPI{c}
0000000000000000000000000000000000000000;;		c.ResourceTickets = &ResourceTicketsAPI{c}
0000000000000000000000000000000000000000;;		c.Networks = &NetworksAPI{c}
0000000000000000000000000000000000000000;;		c.VirtualSubnets = &VirtualSubnetsAPI{c}
0000000000000000000000000000000000000000;;		c.Services = &ServicesAPI{c}
0000000000000000000000000000000000000000;;		c.Auth = &AuthAPI{c}
0000000000000000000000000000000000000000;;		c.AvailabilityZones = &AvailabilityZonesAPI{c}
0000000000000000000000000000000000000000;;		c.Info = &InfoAPI{c}
0000000000000000000000000000000000000000;;		c.Routers = &RoutersAPI{c}
0000000000000000000000000000000000000000;;		c.Subnets = &SubnetsAPI{c}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tell the restClient about the Auth API so it can request new
0000000000000000000000000000000000000000;;		// acces tokens when they expire
0000000000000000000000000000000000000000;;		restClient.Auth = c.Auth
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a new photon client with specified options and http.Client.
0000000000000000000000000000000000000000;;	// Useful for functional testing where http calls must be mocked out.
0000000000000000000000000000000000000000;;	// If options is nil, default options will be used.
0000000000000000000000000000000000000000;;	func NewTestClient(endpoint string, options *ClientOptions, httpClient *http.Client) (c *Client) {
0000000000000000000000000000000000000000;;		c = NewClient(endpoint, options, nil)
0000000000000000000000000000000000000000;;		c.restClient.httpClient = httpClient
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createPassThroughLogger() (l *log.Logger) {
0000000000000000000000000000000000000000;;		// ioutil.Discard makes all logging operation be a no-op.
0000000000000000000000000000000000000000;;		return log.New(ioutil.Discard, "", log.LstdFlags)
0000000000000000000000000000000000000000;;	}
