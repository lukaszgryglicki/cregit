0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014-2016 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/client.go[Godeps/_workspace/src/github.com/vmware/govmomi/client.go][vendor/github.com/vmware/govmomi/client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	This package is the root package of the govmomi library.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The library is structured as follows:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Package vim25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The minimal usable functionality is available through the vim25 package.
0000000000000000000000000000000000000000;;	It contains subpackages that contain generated types, managed objects, and all
0000000000000000000000000000000000000000;;	available methods. The vim25 package is entirely independent of the other
0000000000000000000000000000000000000000;;	packages in the govmomi tree -- it has no dependencies on its peers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The vim25 package itself contains a client structure that is
0000000000000000000000000000000000000000;;	passed around throughout the entire library. It abstracts a session and its
0000000000000000000000000000000000000000;;	immutable state. See the vim25 package for more information.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Package session
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The session package contains an abstraction for the session manager that allows
0000000000000000000000000000000000000000;;	a user to login and logout. It also provides access to the current session
0000000000000000000000000000000000000000;;	(i.e. to determine if the user is in fact logged in)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The object package contains wrappers for a selection of managed objects. The
0000000000000000000000000000000000000000;;	constructors of these objects all take a *vim25.Client, which they pass along
0000000000000000000000000000000000000000;;	to derived objects, if applicable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Package govc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The govc package contains the govc CLI. The code in this tree is not intended
0000000000000000000000000000000000000000;;	to be used as a library. Any functionality that govc contains that _could_ be
0000000000000000000000000000000000000000;;	used as a library function but isn't, _should_ live in a root level package.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Other packages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Other packages, such as "event", "guest", or "license", provide wrappers for
0000000000000000000000000000000000000000;;	the respective subsystems. They are typically not needed in normal workflows so
0000000000000000000000000000000000000000;;	are kept outside the object package.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package govmomi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/session"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		*vim25.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SessionManager *session.Manager
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient creates a new client from a URL. The client authenticates with the
0000000000000000000000000000000000000000;;	// server with username/password before returning if the URL contains user information.
0000000000000000000000000000000000000000;;	func NewClient(ctx context.Context, u *url.URL, insecure bool) (*Client, error) {
0000000000000000000000000000000000000000;;		soapClient := soap.NewClient(u, insecure)
0000000000000000000000000000000000000000;;		vimClient, err := vim25.NewClient(ctx, soapClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &Client{
0000000000000000000000000000000000000000;;			Client:         vimClient,
0000000000000000000000000000000000000000;;			SessionManager: session.NewManager(vimClient),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Only login if the URL contains user information.
0000000000000000000000000000000000000000;;		if u.User != nil {
0000000000000000000000000000000000000000;;			err = c.Login(ctx, u.User)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientWithCertificate creates a new client from a URL. The client authenticates with the
0000000000000000000000000000000000000000;;	// server with the certificate before returning if the URL contains user information.
0000000000000000000000000000000000000000;;	func NewClientWithCertificate(ctx context.Context, u *url.URL, insecure bool, cert tls.Certificate) (*Client, error) {
0000000000000000000000000000000000000000;;		soapClient := soap.NewClient(u, insecure)
0000000000000000000000000000000000000000;;		soapClient.SetCertificate(cert)
0000000000000000000000000000000000000000;;		vimClient, err := vim25.NewClient(ctx, soapClient)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &Client{
0000000000000000000000000000000000000000;;			Client:         vimClient,
0000000000000000000000000000000000000000;;			SessionManager: session.NewManager(vimClient),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.User != nil {
0000000000000000000000000000000000000000;;			err = c.LoginExtensionByCertificate(ctx, u.User.Username(), "")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Login dispatches to the SessionManager.
0000000000000000000000000000000000000000;;	func (c *Client) Login(ctx context.Context, u *url.Userinfo) error {
0000000000000000000000000000000000000000;;		return c.SessionManager.Login(ctx, u)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Login dispatches to the SessionManager.
0000000000000000000000000000000000000000;;	func (c *Client) LoginExtensionByCertificate(ctx context.Context, key string, locale string) error {
0000000000000000000000000000000000000000;;		return c.SessionManager.LoginExtensionByCertificate(ctx, key, locale)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Logout dispatches to the SessionManager.
0000000000000000000000000000000000000000;;	func (c *Client) Logout(ctx context.Context) error {
0000000000000000000000000000000000000000;;		// Close any idle connections after logging out.
0000000000000000000000000000000000000000;;		defer c.Client.CloseIdleConnections()
0000000000000000000000000000000000000000;;		return c.SessionManager.Logout(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PropertyCollector returns the session's default property collector.
0000000000000000000000000000000000000000;;	func (c *Client) PropertyCollector() *property.Collector {
0000000000000000000000000000000000000000;;		return property.DefaultCollector(c.Client)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveOne dispatches to the Retrieve function on the default property collector.
0000000000000000000000000000000000000000;;	func (c *Client) RetrieveOne(ctx context.Context, obj types.ManagedObjectReference, p []string, dst interface{}) error {
0000000000000000000000000000000000000000;;		return c.PropertyCollector().RetrieveOne(ctx, obj, p, dst)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieve dispatches to the Retrieve function on the default property collector.
0000000000000000000000000000000000000000;;	func (c *Client) Retrieve(ctx context.Context, objs []types.ManagedObjectReference, p []string, dst interface{}) error {
0000000000000000000000000000000000000000;;		return c.PropertyCollector().Retrieve(ctx, objs, p, dst)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait dispatches to property.Wait.
0000000000000000000000000000000000000000;;	func (c *Client) Wait(ctx context.Context, obj types.ManagedObjectReference, ps []string, f func([]types.PropertyChange) bool) error {
0000000000000000000000000000000000000000;;		return property.Wait(ctx, c.PropertyCollector(), obj, ps, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsVC returns true if we are connected to a vCenter
0000000000000000000000000000000000000000;;	func (c *Client) IsVC() bool {
0000000000000000000000000000000000000000;;		return c.Client.IsVC()
0000000000000000000000000000000000000000;;	}
