0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014-2016 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/list/lister.go[Godeps/_workspace/src/github.com/vmware/govmomi/list/lister.go][vendor/github.com/vmware/govmomi/list/lister.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package list
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Element struct {
0000000000000000000000000000000000000000;;		Path   string
0000000000000000000000000000000000000000;;		Object mo.Reference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e Element) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s @ %s", e.Object.Reference(), e.Path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ToElement(r mo.Reference, prefix string) Element {
0000000000000000000000000000000000000000;;		var name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Comments about types to be expected in folders copied from the
0000000000000000000000000000000000000000;;		// documentation of the Folder managed object:
0000000000000000000000000000000000000000;;		// http://pubs.vmware.com/vsphere-55/topic/com.vmware.wssdk.apiref.doc/vim.Folder.html
0000000000000000000000000000000000000000;;		switch m := r.(type) {
0000000000000000000000000000000000000000;;		case mo.Folder:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.StoragePod:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// { "vim.Datacenter" } - Identifies the root folder and its descendant
0000000000000000000000000000000000000000;;		// folders. Data center folders can contain child data center folders and
0000000000000000000000000000000000000000;;		// Datacenter managed objects. Datacenter objects contain virtual machine,
0000000000000000000000000000000000000000;;		// compute resource, network entity, and datastore folders.
0000000000000000000000000000000000000000;;		case mo.Datacenter:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// { "vim.Virtualmachine", "vim.VirtualApp" } - Identifies a virtual machine
0000000000000000000000000000000000000000;;		// folder. A virtual machine folder may contain child virtual machine
0000000000000000000000000000000000000000;;		// folders. It also can contain VirtualMachine managed objects, templates,
0000000000000000000000000000000000000000;;		// and VirtualApp managed objects.
0000000000000000000000000000000000000000;;		case mo.VirtualMachine:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.VirtualApp:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// { "vim.ComputeResource" } - Identifies a compute resource
0000000000000000000000000000000000000000;;		// folder, which contains child compute resource folders and ComputeResource
0000000000000000000000000000000000000000;;		// hierarchies.
0000000000000000000000000000000000000000;;		case mo.ComputeResource:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.ClusterComputeResource:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.HostSystem:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.ResourcePool:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// { "vim.Network" } - Identifies a network entity folder.
0000000000000000000000000000000000000000;;		// Network entity folders on a vCenter Server can contain Network,
0000000000000000000000000000000000000000;;		// DistributedVirtualSwitch, and DistributedVirtualPortgroup managed objects.
0000000000000000000000000000000000000000;;		// Network entity folders on an ESXi host can contain only Network objects.
0000000000000000000000000000000000000000;;		case mo.Network:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.OpaqueNetwork:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.DistributedVirtualSwitch:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.DistributedVirtualPortgroup:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;		case mo.VmwareDistributedVirtualSwitch:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// { "vim.Datastore" } - Identifies a datastore folder. Datastore folders can
0000000000000000000000000000000000000000;;		// contain child datastore folders and Datastore managed objects.
0000000000000000000000000000000000000000;;		case mo.Datastore:
0000000000000000000000000000000000000000;;			name = m.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("not implemented for type " + reflect.TypeOf(r).String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e := Element{
0000000000000000000000000000000000000000;;			Path:   path.Join(prefix, name),
0000000000000000000000000000000000000000;;			Object: r,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Lister struct {
0000000000000000000000000000000000000000;;		Collector *property.Collector
0000000000000000000000000000000000000000;;		Reference types.ManagedObjectReference
0000000000000000000000000000000000000000;;		Prefix    string
0000000000000000000000000000000000000000;;		All       bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) retrieveProperties(ctx context.Context, req types.RetrieveProperties, dst *[]interface{}) error {
0000000000000000000000000000000000000000;;		res, err := l.Collector.RetrieveProperties(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Instead of using mo.LoadRetrievePropertiesResponse, use a custom loop to
0000000000000000000000000000000000000000;;		// iterate over the results and ignore entries that have properties that
0000000000000000000000000000000000000000;;		// could not be retrieved (a non-empty `missingSet` property). Since the
0000000000000000000000000000000000000000;;		// returned objects are enumerated by vSphere in the first place, any object
0000000000000000000000000000000000000000;;		// that has a non-empty `missingSet` property is indicative of a race
0000000000000000000000000000000000000000;;		// condition in vSphere where the object was enumerated initially, but was
0000000000000000000000000000000000000000;;		// removed before its properties could be collected.
0000000000000000000000000000000000000000;;		for _, p := range res.Returnval {
0000000000000000000000000000000000000000;;			v, err := mo.ObjectContentToType(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Ignore fault if it is ManagedObjectNotFound
0000000000000000000000000000000000000000;;				if soap.IsVimFault(err) {
0000000000000000000000000000000000000000;;					switch soap.ToVimFault(err).(type) {
0000000000000000000000000000000000000000;;					case *types.ManagedObjectNotFound:
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			*dst = append(*dst, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) List(ctx context.Context) ([]Element, error) {
0000000000000000000000000000000000000000;;		switch l.Reference.Type {
0000000000000000000000000000000000000000;;		case "Folder", "StoragePod":
0000000000000000000000000000000000000000;;			return l.ListFolder(ctx)
0000000000000000000000000000000000000000;;		case "Datacenter":
0000000000000000000000000000000000000000;;			return l.ListDatacenter(ctx)
0000000000000000000000000000000000000000;;		case "ComputeResource", "ClusterComputeResource":
0000000000000000000000000000000000000000;;			// Treat ComputeResource and ClusterComputeResource as one and the same.
0000000000000000000000000000000000000000;;			// It doesn't matter from the perspective of the lister.
0000000000000000000000000000000000000000;;			return l.ListComputeResource(ctx)
0000000000000000000000000000000000000000;;		case "ResourcePool":
0000000000000000000000000000000000000000;;			return l.ListResourcePool(ctx)
0000000000000000000000000000000000000000;;		case "HostSystem":
0000000000000000000000000000000000000000;;			return l.ListHostSystem(ctx)
0000000000000000000000000000000000000000;;		case "VirtualApp":
0000000000000000000000000000000000000000;;			return l.ListVirtualApp(ctx)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot traverse type " + l.Reference.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) ListFolder(ctx context.Context) ([]Element, error) {
0000000000000000000000000000000000000000;;		spec := types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;			ObjectSet: []types.ObjectSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					Obj: l.Reference,
0000000000000000000000000000000000000000;;					SelectSet: []types.BaseSelectionSpec{
0000000000000000000000000000000000000000;;						&types.TraversalSpec{
0000000000000000000000000000000000000000;;							Path: "childEntity",
0000000000000000000000000000000000000000;;							Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;							Type: "Folder",
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					Skip: types.NewBool(true),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve all objects that we can deal with
0000000000000000000000000000000000000000;;		childTypes := []string{
0000000000000000000000000000000000000000;;			"Folder",
0000000000000000000000000000000000000000;;			"Datacenter",
0000000000000000000000000000000000000000;;			"VirtualApp",
0000000000000000000000000000000000000000;;			"VirtualMachine",
0000000000000000000000000000000000000000;;			"Network",
0000000000000000000000000000000000000000;;			"ComputeResource",
0000000000000000000000000000000000000000;;			"ClusterComputeResource",
0000000000000000000000000000000000000000;;			"Datastore",
0000000000000000000000000000000000000000;;			"DistributedVirtualSwitch",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, t := range childTypes {
0000000000000000000000000000000000000000;;			pspec := types.PropertySpec{
0000000000000000000000000000000000000000;;				Type: t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.All {
0000000000000000000000000000000000000000;;				pspec.All = types.NewBool(true)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pspec.PathSet = []string{"name"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Additional basic properties.
0000000000000000000000000000000000000000;;				switch t {
0000000000000000000000000000000000000000;;				case "Folder":
0000000000000000000000000000000000000000;;					pspec.PathSet = append(pspec.PathSet, "childType")
0000000000000000000000000000000000000000;;				case "ComputeResource", "ClusterComputeResource":
0000000000000000000000000000000000000000;;					// The ComputeResource and ClusterComputeResource are dereferenced in
0000000000000000000000000000000000000000;;					// the ResourcePoolFlag. Make sure they always have their resourcePool
0000000000000000000000000000000000000000;;					// field populated.
0000000000000000000000000000000000000000;;					pspec.PathSet = append(pspec.PathSet, "resourcePool")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			spec.PropSet = append(spec.PropSet, pspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{spec},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := l.retrieveProperties(ctx, req, &dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es := []Element{}
0000000000000000000000000000000000000000;;		for _, v := range dst {
0000000000000000000000000000000000000000;;			es = append(es, ToElement(v.(mo.Reference), l.Prefix))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return es, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) ListDatacenter(ctx context.Context) ([]Element, error) {
0000000000000000000000000000000000000000;;		ospec := types.ObjectSpec{
0000000000000000000000000000000000000000;;			Obj:  l.Reference,
0000000000000000000000000000000000000000;;			Skip: types.NewBool(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Include every datastore folder in the select set
0000000000000000000000000000000000000000;;		fields := []string{
0000000000000000000000000000000000000000;;			"vmFolder",
0000000000000000000000000000000000000000;;			"hostFolder",
0000000000000000000000000000000000000000;;			"datastoreFolder",
0000000000000000000000000000000000000000;;			"networkFolder",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range fields {
0000000000000000000000000000000000000000;;			tspec := types.TraversalSpec{
0000000000000000000000000000000000000000;;				Path: f,
0000000000000000000000000000000000000000;;				Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;				Type: "Datacenter",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ospec.SelectSet = append(ospec.SelectSet, &tspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pspec := types.PropertySpec{
0000000000000000000000000000000000000000;;			Type: "Folder",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.All {
0000000000000000000000000000000000000000;;			pspec.All = types.NewBool(true)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pspec.PathSet = []string{"name", "childType"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: []types.ObjectSpec{ospec},
0000000000000000000000000000000000000000;;					PropSet:   []types.PropertySpec{pspec},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := l.retrieveProperties(ctx, req, &dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es := []Element{}
0000000000000000000000000000000000000000;;		for _, v := range dst {
0000000000000000000000000000000000000000;;			es = append(es, ToElement(v.(mo.Reference), l.Prefix))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return es, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) ListComputeResource(ctx context.Context) ([]Element, error) {
0000000000000000000000000000000000000000;;		ospec := types.ObjectSpec{
0000000000000000000000000000000000000000;;			Obj:  l.Reference,
0000000000000000000000000000000000000000;;			Skip: types.NewBool(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fields := []string{
0000000000000000000000000000000000000000;;			"host",
0000000000000000000000000000000000000000;;			"resourcePool",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range fields {
0000000000000000000000000000000000000000;;			tspec := types.TraversalSpec{
0000000000000000000000000000000000000000;;				Path: f,
0000000000000000000000000000000000000000;;				Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;				Type: "ComputeResource",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ospec.SelectSet = append(ospec.SelectSet, &tspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		childTypes := []string{
0000000000000000000000000000000000000000;;			"HostSystem",
0000000000000000000000000000000000000000;;			"ResourcePool",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pspecs []types.PropertySpec
0000000000000000000000000000000000000000;;		for _, t := range childTypes {
0000000000000000000000000000000000000000;;			pspec := types.PropertySpec{
0000000000000000000000000000000000000000;;				Type: t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.All {
0000000000000000000000000000000000000000;;				pspec.All = types.NewBool(true)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pspec.PathSet = []string{"name"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pspecs = append(pspecs, pspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: []types.ObjectSpec{ospec},
0000000000000000000000000000000000000000;;					PropSet:   pspecs,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := l.retrieveProperties(ctx, req, &dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es := []Element{}
0000000000000000000000000000000000000000;;		for _, v := range dst {
0000000000000000000000000000000000000000;;			es = append(es, ToElement(v.(mo.Reference), l.Prefix))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return es, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) ListResourcePool(ctx context.Context) ([]Element, error) {
0000000000000000000000000000000000000000;;		ospec := types.ObjectSpec{
0000000000000000000000000000000000000000;;			Obj:  l.Reference,
0000000000000000000000000000000000000000;;			Skip: types.NewBool(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fields := []string{
0000000000000000000000000000000000000000;;			"resourcePool",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range fields {
0000000000000000000000000000000000000000;;			tspec := types.TraversalSpec{
0000000000000000000000000000000000000000;;				Path: f,
0000000000000000000000000000000000000000;;				Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;				Type: "ResourcePool",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ospec.SelectSet = append(ospec.SelectSet, &tspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		childTypes := []string{
0000000000000000000000000000000000000000;;			"ResourcePool",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pspecs []types.PropertySpec
0000000000000000000000000000000000000000;;		for _, t := range childTypes {
0000000000000000000000000000000000000000;;			pspec := types.PropertySpec{
0000000000000000000000000000000000000000;;				Type: t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.All {
0000000000000000000000000000000000000000;;				pspec.All = types.NewBool(true)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pspec.PathSet = []string{"name"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pspecs = append(pspecs, pspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: []types.ObjectSpec{ospec},
0000000000000000000000000000000000000000;;					PropSet:   pspecs,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := l.retrieveProperties(ctx, req, &dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es := []Element{}
0000000000000000000000000000000000000000;;		for _, v := range dst {
0000000000000000000000000000000000000000;;			es = append(es, ToElement(v.(mo.Reference), l.Prefix))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return es, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) ListHostSystem(ctx context.Context) ([]Element, error) {
0000000000000000000000000000000000000000;;		ospec := types.ObjectSpec{
0000000000000000000000000000000000000000;;			Obj:  l.Reference,
0000000000000000000000000000000000000000;;			Skip: types.NewBool(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fields := []string{
0000000000000000000000000000000000000000;;			"datastore",
0000000000000000000000000000000000000000;;			"network",
0000000000000000000000000000000000000000;;			"vm",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range fields {
0000000000000000000000000000000000000000;;			tspec := types.TraversalSpec{
0000000000000000000000000000000000000000;;				Path: f,
0000000000000000000000000000000000000000;;				Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;				Type: "HostSystem",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ospec.SelectSet = append(ospec.SelectSet, &tspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		childTypes := []string{
0000000000000000000000000000000000000000;;			"Datastore",
0000000000000000000000000000000000000000;;			"Network",
0000000000000000000000000000000000000000;;			"VirtualMachine",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pspecs []types.PropertySpec
0000000000000000000000000000000000000000;;		for _, t := range childTypes {
0000000000000000000000000000000000000000;;			pspec := types.PropertySpec{
0000000000000000000000000000000000000000;;				Type: t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.All {
0000000000000000000000000000000000000000;;				pspec.All = types.NewBool(true)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pspec.PathSet = []string{"name"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pspecs = append(pspecs, pspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: []types.ObjectSpec{ospec},
0000000000000000000000000000000000000000;;					PropSet:   pspecs,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := l.retrieveProperties(ctx, req, &dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es := []Element{}
0000000000000000000000000000000000000000;;		for _, v := range dst {
0000000000000000000000000000000000000000;;			es = append(es, ToElement(v.(mo.Reference), l.Prefix))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return es, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l Lister) ListVirtualApp(ctx context.Context) ([]Element, error) {
0000000000000000000000000000000000000000;;		ospec := types.ObjectSpec{
0000000000000000000000000000000000000000;;			Obj:  l.Reference,
0000000000000000000000000000000000000000;;			Skip: types.NewBool(true),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fields := []string{
0000000000000000000000000000000000000000;;			"resourcePool",
0000000000000000000000000000000000000000;;			"vm",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, f := range fields {
0000000000000000000000000000000000000000;;			tspec := types.TraversalSpec{
0000000000000000000000000000000000000000;;				Path: f,
0000000000000000000000000000000000000000;;				Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;				Type: "VirtualApp",
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ospec.SelectSet = append(ospec.SelectSet, &tspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		childTypes := []string{
0000000000000000000000000000000000000000;;			"ResourcePool",
0000000000000000000000000000000000000000;;			"VirtualMachine",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pspecs []types.PropertySpec
0000000000000000000000000000000000000000;;		for _, t := range childTypes {
0000000000000000000000000000000000000000;;			pspec := types.PropertySpec{
0000000000000000000000000000000000000000;;				Type: t,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.All {
0000000000000000000000000000000000000000;;				pspec.All = types.NewBool(true)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pspec.PathSet = []string{"name"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pspecs = append(pspecs, pspec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: []types.ObjectSpec{ospec},
0000000000000000000000000000000000000000;;					PropSet:   pspecs,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dst []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := l.retrieveProperties(ctx, req, &dst)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es := []Element{}
0000000000000000000000000000000000000000;;		for _, v := range dst {
0000000000000000000000000000000000000000;;			es = append(es, ToElement(v.(mo.Reference), l.Prefix))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return es, nil
0000000000000000000000000000000000000000;;	}
