0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/session/manager.go[Godeps/_workspace/src/github.com/vmware/govmomi/session/manager.go][vendor/github.com/vmware/govmomi/session/manager.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package session
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Locale defaults to "en_US" and can be overridden via this var or the GOVMOMI_LOCALE env var.
0000000000000000000000000000000000000000;;	// A value of "_" uses the server locale setting.
0000000000000000000000000000000000000000;;	var Locale = os.Getenv("GOVMOMI_LOCALE")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		if Locale == "_" {
0000000000000000000000000000000000000000;;			Locale = ""
0000000000000000000000000000000000000000;;		} else if Locale == "" {
0000000000000000000000000000000000000000;;			Locale = "en_US"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Manager struct {
0000000000000000000000000000000000000000;;		client      *vim25.Client
0000000000000000000000000000000000000000;;		userSession *types.UserSession
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewManager(client *vim25.Client) *Manager {
0000000000000000000000000000000000000000;;		m := Manager{
0000000000000000000000000000000000000000;;			client: client,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm Manager) Reference() types.ManagedObjectReference {
0000000000000000000000000000000000000000;;		return *sm.client.ServiceContent.SessionManager
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm *Manager) SetLocale(ctx context.Context, locale string) error {
0000000000000000000000000000000000000000;;		req := types.SetLocale{
0000000000000000000000000000000000000000;;			This:   sm.Reference(),
0000000000000000000000000000000000000000;;			Locale: locale,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.SetLocale(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm *Manager) Login(ctx context.Context, u *url.Userinfo) error {
0000000000000000000000000000000000000000;;		req := types.Login{
0000000000000000000000000000000000000000;;			This:   sm.Reference(),
0000000000000000000000000000000000000000;;			Locale: Locale,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u != nil {
0000000000000000000000000000000000000000;;			req.UserName = u.Username()
0000000000000000000000000000000000000000;;			if pw, ok := u.Password(); ok {
0000000000000000000000000000000000000000;;				req.Password = pw
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		login, err := methods.Login(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sm.userSession = &login.Returnval
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm *Manager) LoginExtensionByCertificate(ctx context.Context, key string, locale string) error {
0000000000000000000000000000000000000000;;		req := types.LoginExtensionByCertificate{
0000000000000000000000000000000000000000;;			This:         sm.Reference(),
0000000000000000000000000000000000000000;;			ExtensionKey: key,
0000000000000000000000000000000000000000;;			Locale:       locale,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		login, err := methods.LoginExtensionByCertificate(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sm.userSession = &login.Returnval
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm *Manager) Logout(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.Logout{
0000000000000000000000000000000000000000;;			This: sm.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.Logout(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sm.userSession = nil
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UserSession retrieves and returns the SessionManager's CurrentSession field.
0000000000000000000000000000000000000000;;	// Nil is returned if the session is not authenticated.
0000000000000000000000000000000000000000;;	func (sm *Manager) UserSession(ctx context.Context) (*types.UserSession, error) {
0000000000000000000000000000000000000000;;		var mgr mo.SessionManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc := property.DefaultCollector(sm.client)
0000000000000000000000000000000000000000;;		err := pc.RetrieveOne(ctx, sm.Reference(), []string{"currentSession"}, &mgr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// It's OK if we can't retrieve properties because we're not authenticated
0000000000000000000000000000000000000000;;			if f, ok := err.(types.HasFault); ok {
0000000000000000000000000000000000000000;;				switch f.Fault().(type) {
0000000000000000000000000000000000000000;;				case *types.NotAuthenticated:
0000000000000000000000000000000000000000;;					return nil, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mgr.CurrentSession, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm *Manager) TerminateSession(ctx context.Context, sessionId []string) error {
0000000000000000000000000000000000000000;;		req := types.TerminateSession{
0000000000000000000000000000000000000000;;			This:      sm.Reference(),
0000000000000000000000000000000000000000;;			SessionId: sessionId,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.TerminateSession(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SessionIsActive checks whether the session that was created at login is
0000000000000000000000000000000000000000;;	// still valid. This function only works against vCenter.
0000000000000000000000000000000000000000;;	func (sm *Manager) SessionIsActive(ctx context.Context) (bool, error) {
0000000000000000000000000000000000000000;;		if sm.userSession == nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.SessionIsActive{
0000000000000000000000000000000000000000;;			This:      sm.Reference(),
0000000000000000000000000000000000000000;;			SessionID: sm.userSession.Key,
0000000000000000000000000000000000000000;;			UserName:  sm.userSession.UserName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		active, err := methods.SessionIsActive(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return active.Returnval, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm *Manager) AcquireGenericServiceTicket(ctx context.Context, spec types.BaseSessionManagerServiceRequestSpec) (*types.SessionManagerGenericServiceTicket, error) {
0000000000000000000000000000000000000000;;		req := types.AcquireGenericServiceTicket{
0000000000000000000000000000000000000000;;			This: sm.Reference(),
0000000000000000000000000000000000000000;;			Spec: spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.AcquireGenericServiceTicket(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &res.Returnval, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sm *Manager) AcquireLocalTicket(ctx context.Context, userName string) (*types.SessionManagerLocalTicket, error) {
0000000000000000000000000000000000000000;;		req := types.AcquireLocalTicket{
0000000000000000000000000000000000000000;;			This:     sm.Reference(),
0000000000000000000000000000000000000000;;			UserName: userName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.AcquireLocalTicket(ctx, sm.client, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &res.Returnval, nil
0000000000000000000000000000000000000000;;	}
