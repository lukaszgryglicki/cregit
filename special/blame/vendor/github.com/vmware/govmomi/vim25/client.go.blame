0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015-2016 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/client.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/client.go][vendor/github.com/vmware/govmomi/vim25/client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package vim25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client is a tiny wrapper around the vim25/soap Client that stores session
0000000000000000000000000000000000000000;;	// specific state (i.e. state that only needs to be retrieved once after the
0000000000000000000000000000000000000000;;	// client has been created). This means the client can be reused after
0000000000000000000000000000000000000000;;	// serialization without performing additional requests for initialization.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		*soap.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ServiceContent types.ServiceContent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RoundTripper is a separate field such that the client's implementation of
0000000000000000000000000000000000000000;;		// the RoundTripper interface can be wrapped by separate implementations for
0000000000000000000000000000000000000000;;		// extra functionality (for example, reauthentication on session timeout).
0000000000000000000000000000000000000000;;		RoundTripper soap.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient creates and returns a new client wirh the ServiceContent field
0000000000000000000000000000000000000000;;	// filled in.
0000000000000000000000000000000000000000;;	func NewClient(ctx context.Context, rt soap.RoundTripper) (*Client, error) {
0000000000000000000000000000000000000000;;		serviceContent, err := methods.GetServiceContent(ctx, rt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := Client{
0000000000000000000000000000000000000000;;			ServiceContent: serviceContent,
0000000000000000000000000000000000000000;;			RoundTripper:   rt,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set client if it happens to be a soap.Client
0000000000000000000000000000000000000000;;		if sc, ok := rt.(*soap.Client); ok {
0000000000000000000000000000000000000000;;			c.Client = sc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RoundTrip dispatches to the RoundTripper field.
0000000000000000000000000000000000000000;;	func (c *Client) RoundTrip(ctx context.Context, req, res soap.HasFault) error {
0000000000000000000000000000000000000000;;		return c.RoundTripper.RoundTrip(ctx, req, res)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type marshaledClient struct {
0000000000000000000000000000000000000000;;		SoapClient     *soap.Client
0000000000000000000000000000000000000000;;		ServiceContent types.ServiceContent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		m := marshaledClient{
0000000000000000000000000000000000000000;;			SoapClient:     c.Client,
0000000000000000000000000000000000000000;;			ServiceContent: c.ServiceContent,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var m marshaledClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.Unmarshal(b, &m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*c = Client{
0000000000000000000000000000000000000000;;			Client:         m.SoapClient,
0000000000000000000000000000000000000000;;			ServiceContent: m.ServiceContent,
0000000000000000000000000000000000000000;;			RoundTripper:   m.SoapClient,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid returns whether or not the client is valid and ready for use.
0000000000000000000000000000000000000000;;	// This should be called after unmarshalling the client.
0000000000000000000000000000000000000000;;	func (c *Client) Valid() bool {
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.Client == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use arbitrary pointer field in the service content.
0000000000000000000000000000000000000000;;		// Doesn't matter which one, as long as it is populated by default.
0000000000000000000000000000000000000000;;		if c.ServiceContent.SessionManager == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsVC returns true if we are connected to a vCenter
0000000000000000000000000000000000000000;;	func (c *Client) IsVC() bool {
0000000000000000000000000000000000000000;;		return c.ServiceContent.About.ApiType == "VirtualCenter"
0000000000000000000000000000000000000000;;	}
