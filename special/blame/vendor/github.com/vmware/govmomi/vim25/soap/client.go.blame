0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/soap/client.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/soap/client.go][vendor/github.com/vmware/govmomi/vim25/soap/client.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package soap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/http/cookiejar"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/progress"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/xml"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HasFault interface {
0000000000000000000000000000000000000000;;		Fault() *Fault
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoundTripper interface {
0000000000000000000000000000000000000000;;		RoundTrip(ctx context.Context, req, res HasFault) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultVimNamespace  = "urn:vim25"
0000000000000000000000000000000000000000;;		DefaultVimVersion    = "6.5"
0000000000000000000000000000000000000000;;		DefaultMinVimVersion = "5.5"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type header struct {
0000000000000000000000000000000000000000;;		Cookie string `xml:"vcSessionCookie,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		http.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u *url.URL
0000000000000000000000000000000000000000;;		k bool // Named after curl's -k flag
0000000000000000000000000000000000000000;;		d *debugContainer
0000000000000000000000000000000000000000;;		t *http.Transport
0000000000000000000000000000000000000000;;		p *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostsMu sync.Mutex
0000000000000000000000000000000000000000;;		hosts   map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Namespace string // Vim namespace
0000000000000000000000000000000000000000;;		Version   string // Vim version
0000000000000000000000000000000000000000;;		UserAgent string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header *header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var schemeMatch = regexp.MustCompile(`^\w+://`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseURL is wrapper around url.Parse, where Scheme defaults to "https" and Path defaults to "/sdk"
0000000000000000000000000000000000000000;;	func ParseURL(s string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var u *url.URL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s != "" {
0000000000000000000000000000000000000000;;			// Default the scheme to https
0000000000000000000000000000000000000000;;			if !schemeMatch.MatchString(s) {
0000000000000000000000000000000000000000;;				s = "https://" + s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			u, err = url.Parse(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Default the path to /sdk
0000000000000000000000000000000000000000;;			if u.Path == "" {
0000000000000000000000000000000000000000;;				u.Path = "/sdk"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if u.User == nil {
0000000000000000000000000000000000000000;;				u.User = url.UserPassword("", "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewClient(u *url.URL, insecure bool) *Client {
0000000000000000000000000000000000000000;;		c := Client{
0000000000000000000000000000000000000000;;			u: u,
0000000000000000000000000000000000000000;;			k: insecure,
0000000000000000000000000000000000000000;;			d: newDebug(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize http.RoundTripper on client, so we can customize it below
0000000000000000000000000000000000000000;;		if t, ok := http.DefaultTransport.(*http.Transport); ok {
0000000000000000000000000000000000000000;;			c.t = &http.Transport{
0000000000000000000000000000000000000000;;				Proxy:                 t.Proxy,
0000000000000000000000000000000000000000;;				DialContext:           t.DialContext,
0000000000000000000000000000000000000000;;				MaxIdleConns:          t.MaxIdleConns,
0000000000000000000000000000000000000000;;				IdleConnTimeout:       t.IdleConnTimeout,
0000000000000000000000000000000000000000;;				TLSHandshakeTimeout:   t.TLSHandshakeTimeout,
0000000000000000000000000000000000000000;;				ExpectContinueTimeout: t.ExpectContinueTimeout,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.t = new(http.Transport)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.hosts = make(map[string]string)
0000000000000000000000000000000000000000;;		c.t.TLSClientConfig = &tls.Config{InsecureSkipVerify: c.k}
0000000000000000000000000000000000000000;;		// Don't bother setting DialTLS if InsecureSkipVerify=true
0000000000000000000000000000000000000000;;		if !c.k {
0000000000000000000000000000000000000000;;			c.t.DialTLS = c.dialTLS
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Client.Transport = c.t
0000000000000000000000000000000000000000;;		c.Client.Jar, _ = cookiejar.New(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove user information from a copy of the URL
0000000000000000000000000000000000000000;;		c.u = c.URL()
0000000000000000000000000000000000000000;;		c.u.User = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Namespace = DefaultVimNamespace
0000000000000000000000000000000000000000;;		c.Version = DefaultVimVersion
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServiceClient creates a NewClient with the given URL.Path and namespace.
0000000000000000000000000000000000000000;;	func (c *Client) NewServiceClient(path string, namespace string) *Client {
0000000000000000000000000000000000000000;;		u := c.URL()
0000000000000000000000000000000000000000;;		u.Path = path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client := NewClient(u, c.k)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client.Namespace = namespace
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy the cookies
0000000000000000000000000000000000000000;;		client.Client.Jar.SetCookies(u, c.Client.Jar.Cookies(u))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set SOAP Header cookie
0000000000000000000000000000000000000000;;		for _, cookie := range client.Jar.Cookies(u) {
0000000000000000000000000000000000000000;;			if cookie.Name == "vmware_soap_session" {
0000000000000000000000000000000000000000;;				client.header = &header{
0000000000000000000000000000000000000000;;					Cookie: cookie.Value,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetRootCAs defines the set of root certificate authorities
0000000000000000000000000000000000000000;;	// that clients use when verifying server certificates.
0000000000000000000000000000000000000000;;	// By default TLS uses the host's root CA set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: http.Client.Transport.TLSClientConfig.RootCAs
0000000000000000000000000000000000000000;;	func (c *Client) SetRootCAs(file string) error {
0000000000000000000000000000000000000000;;		pool := x509.NewCertPool()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, name := range filepath.SplitList(file) {
0000000000000000000000000000000000000000;;			pem, err := ioutil.ReadFile(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pool.AppendCertsFromPEM(pem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.t.TLSClientConfig.RootCAs = pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add default https port if missing
0000000000000000000000000000000000000000;;	func hostAddr(addr string) string {
0000000000000000000000000000000000000000;;		_, port := splitHostPort(addr)
0000000000000000000000000000000000000000;;		if port == "" {
0000000000000000000000000000000000000000;;			return addr + ":443"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return addr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetThumbprint sets the known certificate thumbprint for the given host.
0000000000000000000000000000000000000000;;	// A custom DialTLS function is used to support thumbprint based verification.
0000000000000000000000000000000000000000;;	// We first try tls.Dial with the default tls.Config, only falling back to thumbprint verification
0000000000000000000000000000000000000000;;	// if it fails with an x509.UnknownAuthorityError or x509.HostnameError
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: http.Client.Transport.DialTLS
0000000000000000000000000000000000000000;;	func (c *Client) SetThumbprint(host string, thumbprint string) {
0000000000000000000000000000000000000000;;		host = hostAddr(host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.hostsMu.Lock()
0000000000000000000000000000000000000000;;		if thumbprint == "" {
0000000000000000000000000000000000000000;;			delete(c.hosts, host)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.hosts[host] = thumbprint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.hostsMu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Thumbprint returns the certificate thumbprint for the given host if known to this client.
0000000000000000000000000000000000000000;;	func (c *Client) Thumbprint(host string) string {
0000000000000000000000000000000000000000;;		host = hostAddr(host)
0000000000000000000000000000000000000000;;		c.hostsMu.Lock()
0000000000000000000000000000000000000000;;		defer c.hostsMu.Unlock()
0000000000000000000000000000000000000000;;		return c.hosts[host]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadThumbprints from file with the give name.
0000000000000000000000000000000000000000;;	// If name is empty or name does not exist this function will return nil.
0000000000000000000000000000000000000000;;	func (c *Client) LoadThumbprints(file string) error {
0000000000000000000000000000000000000000;;		if file == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, name := range filepath.SplitList(file) {
0000000000000000000000000000000000000000;;			err := c.loadThumbprints(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) loadThumbprints(name string) error {
0000000000000000000000000000000000000000;;		f, err := os.Open(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			e := strings.SplitN(scanner.Text(), " ", 2)
0000000000000000000000000000000000000000;;			if len(e) != 2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.SetThumbprint(e[0], e[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ = f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return scanner.Err()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ThumbprintSHA1 returns the thumbprint of the given cert in the same format used by the SDK and Client.SetThumbprint.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: SSLVerifyFault.Thumbprint, SessionManagerGenericServiceTicket.Thumbprint, HostConnectSpec.SslThumbprint
0000000000000000000000000000000000000000;;	func ThumbprintSHA1(cert *x509.Certificate) string {
0000000000000000000000000000000000000000;;		sum := sha1.Sum(cert.Raw)
0000000000000000000000000000000000000000;;		hex := make([]string, len(sum))
0000000000000000000000000000000000000000;;		for i, b := range sum {
0000000000000000000000000000000000000000;;			hex[i] = fmt.Sprintf("%02X", b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(hex, ":")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) dialTLS(network string, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		// Would be nice if there was a tls.Config.Verify func,
0000000000000000000000000000000000000000;;		// see tls.clientHandshakeState.doFullHandshake
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := tls.Dial(network, addr, c.t.TLSClientConfig)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return conn, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch err.(type) {
0000000000000000000000000000000000000000;;		case x509.UnknownAuthorityError:
0000000000000000000000000000000000000000;;		case x509.HostnameError:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		thumbprint := c.Thumbprint(addr)
0000000000000000000000000000000000000000;;		if thumbprint == "" {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := &tls.Config{InsecureSkipVerify: true}
0000000000000000000000000000000000000000;;		conn, err = tls.Dial(network, addr, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert := conn.ConnectionState().PeerCertificates[0]
0000000000000000000000000000000000000000;;		peer := ThumbprintSHA1(cert)
0000000000000000000000000000000000000000;;		if thumbprint != peer {
0000000000000000000000000000000000000000;;			_ = conn.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Host %q thumbprint does not match %q", addr, thumbprint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitHostPort is similar to net.SplitHostPort,
0000000000000000000000000000000000000000;;	// but rather than return error if there isn't a ':port',
0000000000000000000000000000000000000000;;	// return an empty string for the port.
0000000000000000000000000000000000000000;;	func splitHostPort(host string) (string, string) {
0000000000000000000000000000000000000000;;		ix := strings.LastIndex(host, ":")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ix <= strings.LastIndex(host, "]") {
0000000000000000000000000000000000000000;;			return host, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := host[:ix]
0000000000000000000000000000000000000000;;		port := host[ix+1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name, port
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const sdkTunnel = "sdkTunnel:8089"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) SetCertificate(cert tls.Certificate) {
0000000000000000000000000000000000000000;;		t := c.Client.Transport.(*http.Transport)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extension certificate
0000000000000000000000000000000000000000;;		t.TLSClientConfig.Certificates = []tls.Certificate{cert}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Proxy to vCenter host on port 80
0000000000000000000000000000000000000000;;		host, _ := splitHostPort(c.u.Host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Should be no reason to change the default port other than testing
0000000000000000000000000000000000000000;;		key := "GOVMOMI_TUNNEL_PROXY_PORT"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		port := c.URL().Query().Get(key)
0000000000000000000000000000000000000000;;		if port == "" {
0000000000000000000000000000000000000000;;			port = os.Getenv(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if port != "" {
0000000000000000000000000000000000000000;;			host += ":" + port
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.p = &url.URL{
0000000000000000000000000000000000000000;;			Scheme: "http",
0000000000000000000000000000000000000000;;			Host:   host,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Proxy = func(r *http.Request) (*url.URL, error) {
0000000000000000000000000000000000000000;;			// Only sdk requests should be proxied
0000000000000000000000000000000000000000;;			if r.URL.Path == "/sdk" {
0000000000000000000000000000000000000000;;				return c.p, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return http.ProxyFromEnvironment(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rewrite url Host to use the sdk tunnel, required for a certificate request.
0000000000000000000000000000000000000000;;		c.u.Host = sdkTunnel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) URL() *url.URL {
0000000000000000000000000000000000000000;;		urlCopy := *c.u
0000000000000000000000000000000000000000;;		return &urlCopy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type marshaledClient struct {
0000000000000000000000000000000000000000;;		Cookies  []*http.Cookie
0000000000000000000000000000000000000000;;		URL      *url.URL
0000000000000000000000000000000000000000;;		Insecure bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		m := marshaledClient{
0000000000000000000000000000000000000000;;			Cookies:  c.Jar.Cookies(c.u),
0000000000000000000000000000000000000000;;			URL:      c.u,
0000000000000000000000000000000000000000;;			Insecure: c.k,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var m marshaledClient
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.Unmarshal(b, &m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*c = *NewClient(m.URL, m.Insecure)
0000000000000000000000000000000000000000;;		c.Jar.SetCookies(m.URL, m.Cookies)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) do(ctx context.Context, req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if nil == ctx || nil == ctx.Done() { // ctx.Done() is for ctx
0000000000000000000000000000000000000000;;			return c.Client.Do(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.Client.Do(req.WithContext(ctx))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) RoundTrip(ctx context.Context, reqBody, resBody HasFault) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqEnv := Envelope{Body: reqBody}
0000000000000000000000000000000000000000;;		resEnv := Envelope{Body: resBody}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqEnv.Header = c.header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create debugging context for this round trip
0000000000000000000000000000000000000000;;		d := c.d.newRoundTrip()
0000000000000000000000000000000000000000;;		if d.enabled() {
0000000000000000000000000000000000000000;;			defer d.done()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := xml.Marshal(reqEnv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawReqBody := io.MultiReader(strings.NewReader(xml.Header), bytes.NewReader(b))
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("POST", c.u.String(), rawReqBody)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.Header.Set(`Content-Type`, `text/xml; charset="utf-8"`)
0000000000000000000000000000000000000000;;		soapAction := fmt.Sprintf("%s/%s", c.Namespace, c.Version)
0000000000000000000000000000000000000000;;		req.Header.Set(`SOAPAction`, soapAction)
0000000000000000000000000000000000000000;;		if c.UserAgent != "" {
0000000000000000000000000000000000000000;;			req.Header.Set(`User-Agent`, c.UserAgent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.enabled() {
0000000000000000000000000000000000000000;;			d.debugRequest(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tstart := time.Now()
0000000000000000000000000000000000000000;;		res, err := c.do(ctx, req)
0000000000000000000000000000000000000000;;		tstop := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.enabled() {
0000000000000000000000000000000000000000;;			d.logf("%6dms (%T)", tstop.Sub(tstart)/time.Millisecond, resBody)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.enabled() {
0000000000000000000000000000000000000000;;			d.debugResponse(res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close response regardless of what happens next
0000000000000000000000000000000000000000;;		defer res.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch res.StatusCode {
0000000000000000000000000000000000000000;;		case http.StatusOK:
0000000000000000000000000000000000000000;;			// OK
0000000000000000000000000000000000000000;;		case http.StatusInternalServerError:
0000000000000000000000000000000000000000;;			// Error, but typically includes a body explaining the error
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New(res.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := xml.NewDecoder(res.Body)
0000000000000000000000000000000000000000;;		dec.TypeFunc = types.TypeFunc()
0000000000000000000000000000000000000000;;		err = dec.Decode(&resEnv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f := resBody.Fault(); f != nil {
0000000000000000000000000000000000000000;;			return WrapSoapFault(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) CloseIdleConnections() {
0000000000000000000000000000000000000000;;		c.t.CloseIdleConnections()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseURL wraps url.Parse to rewrite the URL.Host field
0000000000000000000000000000000000000000;;	// In the case of VM guest uploads or NFC lease URLs, a Host
0000000000000000000000000000000000000000;;	// field with a value of "*" is rewritten to the Client's URL.Host.
0000000000000000000000000000000000000000;;	func (c *Client) ParseURL(urlStr string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		u, err := url.Parse(urlStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, _ := splitHostPort(u.Host)
0000000000000000000000000000000000000000;;		if host == "*" {
0000000000000000000000000000000000000000;;			// Also use Client's port, to support port forwarding
0000000000000000000000000000000000000000;;			u.Host = c.URL().Host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Upload struct {
0000000000000000000000000000000000000000;;		Type          string
0000000000000000000000000000000000000000;;		Method        string
0000000000000000000000000000000000000000;;		ContentLength int64
0000000000000000000000000000000000000000;;		Headers       map[string]string
0000000000000000000000000000000000000000;;		Ticket        *http.Cookie
0000000000000000000000000000000000000000;;		Progress      progress.Sinker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DefaultUpload = Upload{
0000000000000000000000000000000000000000;;		Type:   "application/octet-stream",
0000000000000000000000000000000000000000;;		Method: "PUT",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Upload PUTs the local file to the given URL
0000000000000000000000000000000000000000;;	func (c *Client) Upload(f io.Reader, u *url.URL, param *Upload) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if param.Progress != nil {
0000000000000000000000000000000000000000;;			pr := progress.NewReader(param.Progress, f, param.ContentLength)
0000000000000000000000000000000000000000;;			f = pr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Mark progress reader as done when returning from this function.
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				pr.Done(err)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(param.Method, u.String(), f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.ContentLength = param.ContentLength
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", param.Type)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range param.Headers {
0000000000000000000000000000000000000000;;			req.Header.Add(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if param.Ticket != nil {
0000000000000000000000000000000000000000;;			req.AddCookie(param.Ticket)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := c.Client.Do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch res.StatusCode {
0000000000000000000000000000000000000000;;		case http.StatusOK:
0000000000000000000000000000000000000000;;		case http.StatusCreated:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = errors.New(res.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UploadFile PUTs the local file to the given URL
0000000000000000000000000000000000000000;;	func (c *Client) UploadFile(file string, u *url.URL, param *Upload) error {
0000000000000000000000000000000000000000;;		if param == nil {
0000000000000000000000000000000000000000;;			p := DefaultUpload // Copy since we set ContentLength
0000000000000000000000000000000000000000;;			param = &p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, err := os.Stat(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		param.ContentLength = s.Size()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.Upload(f, u, param)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Download struct {
0000000000000000000000000000000000000000;;		Method   string
0000000000000000000000000000000000000000;;		Headers  map[string]string
0000000000000000000000000000000000000000;;		Ticket   *http.Cookie
0000000000000000000000000000000000000000;;		Progress progress.Sinker
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var DefaultDownload = Download{
0000000000000000000000000000000000000000;;		Method: "GET",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DownloadRequest wraps http.Client.Do, returning the http.Response without checking its StatusCode
0000000000000000000000000000000000000000;;	func (c *Client) DownloadRequest(u *url.URL, param *Download) (*http.Response, error) {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(param.Method, u.String(), nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range param.Headers {
0000000000000000000000000000000000000000;;			req.Header.Add(k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if param.Ticket != nil {
0000000000000000000000000000000000000000;;			req.AddCookie(param.Ticket)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.Client.Do(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Download GETs the remote file from the given URL
0000000000000000000000000000000000000000;;	func (c *Client) Download(u *url.URL, param *Download) (io.ReadCloser, int64, error) {
0000000000000000000000000000000000000000;;		res, err := c.DownloadRequest(u, param)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch res.StatusCode {
0000000000000000000000000000000000000000;;		case http.StatusOK:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = errors.New(res.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.Body, res.ContentLength, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DownloadFile GETs the given URL to a local file
0000000000000000000000000000000000000000;;	func (c *Client) DownloadFile(file string, u *url.URL, param *Download) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if param == nil {
0000000000000000000000000000000000000000;;			param = &DefaultDownload
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc, contentLength, err := c.Download(u, param)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer rc.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r io.Reader = rc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fh, err := os.Create(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer fh.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if param.Progress != nil {
0000000000000000000000000000000000000000;;			pr := progress.NewReader(param.Progress, r, contentLength)
0000000000000000000000000000000000000000;;			r = pr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Mark progress reader as done when returning from this function.
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				pr.Done(err)
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = io.Copy(fh, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assign error before returning so that it gets picked up by the deferred
0000000000000000000000000000000000000000;;		// function marking the progress reader as done.
0000000000000000000000000000000000000000;;		err = fh.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
