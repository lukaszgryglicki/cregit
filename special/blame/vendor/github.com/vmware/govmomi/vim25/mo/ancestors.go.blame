0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/mo/ancestors.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/mo/ancestors.go][vendor/github.com/vmware/govmomi/vim25/mo/ancestors.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ancestors returns the entire ancestry tree of a specified managed object.
0000000000000000000000000000000000000000;;	// The return value includes the root node and the specified object itself.
0000000000000000000000000000000000000000;;	func Ancestors(ctx context.Context, rt soap.RoundTripper, pc, obj types.ManagedObjectReference) ([]ManagedEntity, error) {
0000000000000000000000000000000000000000;;		ospec := types.ObjectSpec{
0000000000000000000000000000000000000000;;			Obj: obj,
0000000000000000000000000000000000000000;;			SelectSet: []types.BaseSelectionSpec{
0000000000000000000000000000000000000000;;				&types.TraversalSpec{
0000000000000000000000000000000000000000;;					SelectionSpec: types.SelectionSpec{Name: "traverseParent"},
0000000000000000000000000000000000000000;;					Type:          "ManagedEntity",
0000000000000000000000000000000000000000;;					Path:          "parent",
0000000000000000000000000000000000000000;;					Skip:          types.NewBool(false),
0000000000000000000000000000000000000000;;					SelectSet: []types.BaseSelectionSpec{
0000000000000000000000000000000000000000;;						&types.SelectionSpec{Name: "traverseParent"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				&types.TraversalSpec{
0000000000000000000000000000000000000000;;					SelectionSpec: types.SelectionSpec{},
0000000000000000000000000000000000000000;;					Type:          "VirtualMachine",
0000000000000000000000000000000000000000;;					Path:          "parentVApp",
0000000000000000000000000000000000000000;;					Skip:          types.NewBool(false),
0000000000000000000000000000000000000000;;					SelectSet: []types.BaseSelectionSpec{
0000000000000000000000000000000000000000;;						&types.SelectionSpec{Name: "traverseParent"},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pspec := []types.PropertySpec{
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    "ManagedEntity",
0000000000000000000000000000000000000000;;				PathSet: []string{"name", "parent"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			{
0000000000000000000000000000000000000000;;				Type:    "VirtualMachine",
0000000000000000000000000000000000000000;;				PathSet: []string{"parentVApp"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			This: pc,
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: []types.ObjectSpec{ospec},
0000000000000000000000000000000000000000;;					PropSet:   pspec,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ifaces []interface{}
0000000000000000000000000000000000000000;;		err := RetrievePropertiesForRequest(ctx, rt, req, &ifaces)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out []ManagedEntity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build ancestry tree by iteratively finding a new child.
0000000000000000000000000000000000000000;;		for len(out) < len(ifaces) {
0000000000000000000000000000000000000000;;			var find types.ManagedObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(out) > 0 {
0000000000000000000000000000000000000000;;				find = out[len(out)-1].Self
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Find entity we're looking for given the last entity in the current tree.
0000000000000000000000000000000000000000;;			for _, iface := range ifaces {
0000000000000000000000000000000000000000;;				me := iface.(IsManagedEntity).GetManagedEntity()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if me.Name == "" {
0000000000000000000000000000000000000000;;					// The types below have their own 'Name' field, so ManagedEntity.Name (me.Name) is empty.
0000000000000000000000000000000000000000;;					// We only hit this case when the 'obj' param is one of these types.
0000000000000000000000000000000000000000;;					// In most cases, 'obj' is a Folder so Name isn't collected in this call.
0000000000000000000000000000000000000000;;					switch x := iface.(type) {
0000000000000000000000000000000000000000;;					case Network:
0000000000000000000000000000000000000000;;						me.Name = x.Name
0000000000000000000000000000000000000000;;					case DistributedVirtualSwitch:
0000000000000000000000000000000000000000;;						me.Name = x.Name
0000000000000000000000000000000000000000;;					case DistributedVirtualPortgroup:
0000000000000000000000000000000000000000;;						me.Name = x.Name
0000000000000000000000000000000000000000;;					case OpaqueNetwork:
0000000000000000000000000000000000000000;;						me.Name = x.Name
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// ManagedEntity always has a Name, if we hit this point we missed a case above.
0000000000000000000000000000000000000000;;						panic(fmt.Sprintf("%#v Name is empty", me.Reference()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if me.Parent == nil {
0000000000000000000000000000000000000000;;					// Special case for VirtualMachine within VirtualApp,
0000000000000000000000000000000000000000;;					// unlikely to hit this other than via Finder.Element()
0000000000000000000000000000000000000000;;					switch x := iface.(type) {
0000000000000000000000000000000000000000;;					case VirtualMachine:
0000000000000000000000000000000000000000;;						me.Parent = x.ParentVApp
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if me.Parent == nil {
0000000000000000000000000000000000000000;;					out = append(out, me)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if *me.Parent == find {
0000000000000000000000000000000000000000;;					out = append(out, me)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
