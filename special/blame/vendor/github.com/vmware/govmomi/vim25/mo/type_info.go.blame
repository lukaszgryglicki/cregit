0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/mo/type_info.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/mo/type_info.go][vendor/github.com/vmware/govmomi/vim25/mo/type_info.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type typeInfo struct {
0000000000000000000000000000000000000000;;		typ reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Field indices of "Self" field.
0000000000000000000000000000000000000000;;		self []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map property names to field indices.
0000000000000000000000000000000000000000;;		props map[string][]int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeInfoLock sync.RWMutex
0000000000000000000000000000000000000000;;	var typeInfoMap = make(map[string]*typeInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func typeInfoForType(tname string) *typeInfo {
0000000000000000000000000000000000000000;;		typeInfoLock.RLock()
0000000000000000000000000000000000000000;;		ti, ok := typeInfoMap[tname]
0000000000000000000000000000000000000000;;		typeInfoLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return ti
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create new typeInfo for type.
0000000000000000000000000000000000000000;;		if typ, ok := t[tname]; !ok {
0000000000000000000000000000000000000000;;			panic("unknown type: " + tname)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Multiple routines may race to set it, but the result is the same.
0000000000000000000000000000000000000000;;			typeInfoLock.Lock()
0000000000000000000000000000000000000000;;			ti = newTypeInfo(typ)
0000000000000000000000000000000000000000;;			typeInfoMap[tname] = ti
0000000000000000000000000000000000000000;;			typeInfoLock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ti
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTypeInfo(typ reflect.Type) *typeInfo {
0000000000000000000000000000000000000000;;		t := typeInfo{
0000000000000000000000000000000000000000;;			typ:   typ,
0000000000000000000000000000000000000000;;			props: make(map[string][]int),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.build(typ, "", []int{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var managedObjectRefType = reflect.TypeOf((*types.ManagedObjectReference)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildName(fn string, f reflect.StructField) string {
0000000000000000000000000000000000000000;;		if fn != "" {
0000000000000000000000000000000000000000;;			fn += "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		motag := f.Tag.Get("mo")
0000000000000000000000000000000000000000;;		if motag != "" {
0000000000000000000000000000000000000000;;			return fn + motag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xmltag := f.Tag.Get("xml")
0000000000000000000000000000000000000000;;		if xmltag != "" {
0000000000000000000000000000000000000000;;			tokens := strings.Split(xmltag, ",")
0000000000000000000000000000000000000000;;			if tokens[0] != "" {
0000000000000000000000000000000000000000;;				return fn + tokens[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *typeInfo) build(typ reflect.Type, fn string, fi []int) {
0000000000000000000000000000000000000000;;		if typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			typ = typ.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if typ.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			panic("need struct")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < typ.NumField(); i++ {
0000000000000000000000000000000000000000;;			f := typ.Field(i)
0000000000000000000000000000000000000000;;			ftyp := f.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Copy field indices so they can be passed along.
0000000000000000000000000000000000000000;;			fic := make([]int, len(fi)+1)
0000000000000000000000000000000000000000;;			copy(fic, fi)
0000000000000000000000000000000000000000;;			fic[len(fi)] = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Recurse into embedded field.
0000000000000000000000000000000000000000;;			if f.Anonymous {
0000000000000000000000000000000000000000;;				t.build(ftyp, fn, fic)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Top level type has a "Self" field.
0000000000000000000000000000000000000000;;			if f.Name == "Self" && ftyp == managedObjectRefType {
0000000000000000000000000000000000000000;;				t.self = fic
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fnc := buildName(fn, f)
0000000000000000000000000000000000000000;;			if fnc == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t.props[fnc] = fic
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Dereference pointer.
0000000000000000000000000000000000000000;;			if ftyp.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				ftyp = ftyp.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Slices are not addressable by `foo.bar.qux`.
0000000000000000000000000000000000000000;;			if ftyp.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Skip the managed reference type.
0000000000000000000000000000000000000000;;			if ftyp == managedObjectRefType {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Recurse into structs.
0000000000000000000000000000000000000000;;			if ftyp.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;				t.build(ftyp, fnc, fic)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignValue assignes a value 'pv' to the struct pointed to by 'val', given a
0000000000000000000000000000000000000000;;	// slice of field indices. It recurses into the struct until it finds the field
0000000000000000000000000000000000000000;;	// specified by the indices. It creates new values for pointer types where
0000000000000000000000000000000000000000;;	// needed.
0000000000000000000000000000000000000000;;	func assignValue(val reflect.Value, fi []int, pv reflect.Value) {
0000000000000000000000000000000000000000;;		// Create new value if necessary.
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if val.IsNil() {
0000000000000000000000000000000000000000;;				val.Set(reflect.New(val.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rv := val.Field(fi[0])
0000000000000000000000000000000000000000;;		fi = fi[1:]
0000000000000000000000000000000000000000;;		if len(fi) == 0 {
0000000000000000000000000000000000000000;;			rt := rv.Type()
0000000000000000000000000000000000000000;;			pt := pv.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If type is a pointer, create new instance of type.
0000000000000000000000000000000000000000;;			if rt.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				rv.Set(reflect.New(rt.Elem()))
0000000000000000000000000000000000000000;;				rv = rv.Elem()
0000000000000000000000000000000000000000;;				rt = rv.Type()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If type is an interface, check if pv implements it.
0000000000000000000000000000000000000000;;			if rt.Kind() == reflect.Interface && !pt.Implements(rt) {
0000000000000000000000000000000000000000;;				// Check if pointer to pv implements it.
0000000000000000000000000000000000000000;;				if reflect.PtrTo(pt).Implements(rt) {
0000000000000000000000000000000000000000;;					npv := reflect.New(pt)
0000000000000000000000000000000000000000;;					npv.Elem().Set(pv)
0000000000000000000000000000000000000000;;					pv = npv
0000000000000000000000000000000000000000;;					pt = pv.Type()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					panic(fmt.Sprintf("type %s doesn't implement %s", pt.Name(), rt.Name()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pt.AssignableTo(rt) {
0000000000000000000000000000000000000000;;				rv.Set(pv)
0000000000000000000000000000000000000000;;			} else if rt.ConvertibleTo(pt) {
0000000000000000000000000000000000000000;;				rv.Set(pv.Convert(rt))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("cannot assign %s (%s) to %s (%s)", rt.Name(), rt.Kind(), pt.Name(), pt.Kind()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		assignValue(rv, fi, pv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var arrayOfRegexp = regexp.MustCompile("ArrayOf(.*)$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func anyTypeToValue(t interface{}) reflect.Value {
0000000000000000000000000000000000000000;;		rt := reflect.TypeOf(t)
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dereference if ArrayOfXYZ type
0000000000000000000000000000000000000000;;		m := arrayOfRegexp.FindStringSubmatch(rt.Name())
0000000000000000000000000000000000000000;;		if len(m) > 0 {
0000000000000000000000000000000000000000;;			// ArrayOfXYZ type has single field named XYZ
0000000000000000000000000000000000000000;;			rv = rv.FieldByName(m[1])
0000000000000000000000000000000000000000;;			if !rv.IsValid() {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("expected %s type to have field %s", m[0], m[1]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadObjectFromContent loads properties from the 'PropSet' field in the
0000000000000000000000000000000000000000;;	// specified ObjectContent value into the value it represents, which is
0000000000000000000000000000000000000000;;	// returned as a reflect.Value.
0000000000000000000000000000000000000000;;	func (t *typeInfo) LoadFromObjectContent(o types.ObjectContent) (reflect.Value, error) {
0000000000000000000000000000000000000000;;		v := reflect.New(t.typ)
0000000000000000000000000000000000000000;;		assignValue(v, t.self, reflect.ValueOf(o.Obj))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range o.PropSet {
0000000000000000000000000000000000000000;;			rv, ok := t.props[p.Name]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			assignValue(v, rv, anyTypeToValue(p.Val))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
