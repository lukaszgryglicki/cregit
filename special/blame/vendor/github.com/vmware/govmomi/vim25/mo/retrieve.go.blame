0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/mo/retrieve.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/mo/retrieve.go][vendor/github.com/vmware/govmomi/vim25/mo/retrieve.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ignoreMissingProperty(ref types.ManagedObjectReference, p types.MissingProperty) bool {
0000000000000000000000000000000000000000;;		switch ref.Type {
0000000000000000000000000000000000000000;;		case "VirtualMachine":
0000000000000000000000000000000000000000;;			switch p.Path {
0000000000000000000000000000000000000000;;			case "environmentBrowser":
0000000000000000000000000000000000000000;;				// See https://github.com/vmware/govmomi/pull/242
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			case "alarmActionsEnabled":
0000000000000000000000000000000000000000;;				// Seen with vApp child VM
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectContentToType loads an ObjectContent value into the value it
0000000000000000000000000000000000000000;;	// represents. If the ObjectContent value has a non-empty 'MissingSet' field,
0000000000000000000000000000000000000000;;	// it returns the first fault it finds there as error. If the 'MissingSet'
0000000000000000000000000000000000000000;;	// field is empty, it returns a pointer to a reflect.Value. It handles contain
0000000000000000000000000000000000000000;;	// nested properties, such as 'guest.ipAddress' or 'config.hardware'.
0000000000000000000000000000000000000000;;	func ObjectContentToType(o types.ObjectContent) (interface{}, error) {
0000000000000000000000000000000000000000;;		// Expect no properties in the missing set
0000000000000000000000000000000000000000;;		for _, p := range o.MissingSet {
0000000000000000000000000000000000000000;;			if ignoreMissingProperty(o.Obj, p) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, soap.WrapVimFault(p.Fault.Fault)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti := typeInfoForType(o.Obj.Type)
0000000000000000000000000000000000000000;;		v, err := ti.LoadFromObjectContent(o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v.Elem().Interface(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadRetrievePropertiesResponse converts the response of a call to
0000000000000000000000000000000000000000;;	// RetrieveProperties to one or more managed objects.
0000000000000000000000000000000000000000;;	func LoadRetrievePropertiesResponse(res *types.RetrievePropertiesResponse, dst interface{}) error {
0000000000000000000000000000000000000000;;		rt := reflect.TypeOf(dst)
0000000000000000000000000000000000000000;;		if rt == nil || rt.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			panic("need pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(dst).Elem()
0000000000000000000000000000000000000000;;		if !rv.CanSet() {
0000000000000000000000000000000000000000;;			panic("cannot set dst")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isSlice := false
0000000000000000000000000000000000000000;;		switch rt.Elem().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			isSlice = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unexpected type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isSlice {
0000000000000000000000000000000000000000;;			for _, p := range res.Returnval {
0000000000000000000000000000000000000000;;				v, err := ObjectContentToType(p)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				vt := reflect.TypeOf(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !rv.Type().AssignableTo(vt) {
0000000000000000000000000000000000000000;;					// For example: dst is []ManagedEntity, res is []HostSystem
0000000000000000000000000000000000000000;;					if field, ok := vt.FieldByName(rt.Elem().Elem().Name()); ok && field.Anonymous {
0000000000000000000000000000000000000000;;						rv.Set(reflect.Append(rv, reflect.ValueOf(v).FieldByIndex(field.Index)))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rv.Set(reflect.Append(rv, reflect.ValueOf(v)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			switch len(res.Returnval) {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				v, err := ObjectContentToType(res.Returnval[0])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				vt := reflect.TypeOf(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !rv.Type().AssignableTo(vt) {
0000000000000000000000000000000000000000;;					// For example: dst is ComputeResource, res is ClusterComputeResource
0000000000000000000000000000000000000000;;					if field, ok := vt.FieldByName(rt.Elem().Name()); ok && field.Anonymous {
0000000000000000000000000000000000000000;;						rv.Set(reflect.ValueOf(v).FieldByIndex(field.Index))
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rv.Set(reflect.ValueOf(v))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// If dst is not a slice, expect to receive 0 or 1 results
0000000000000000000000000000000000000000;;				panic("more than 1 result")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrievePropertiesForRequest calls the RetrieveProperties method with the
0000000000000000000000000000000000000000;;	// specified request and decodes the response struct into the value pointed to
0000000000000000000000000000000000000000;;	// by dst.
0000000000000000000000000000000000000000;;	func RetrievePropertiesForRequest(ctx context.Context, r soap.RoundTripper, req types.RetrieveProperties, dst interface{}) error {
0000000000000000000000000000000000000000;;		res, err := methods.RetrieveProperties(ctx, r, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return LoadRetrievePropertiesResponse(res, dst)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveProperties retrieves the properties of the managed object specified
0000000000000000000000000000000000000000;;	// as obj and decodes the response struct into the value pointed to by dst.
0000000000000000000000000000000000000000;;	func RetrieveProperties(ctx context.Context, r soap.RoundTripper, pc, obj types.ManagedObjectReference, dst interface{}) error {
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			This: pc,
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: []types.ObjectSpec{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							Obj:  obj,
0000000000000000000000000000000000000000;;							Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;					PropSet: []types.PropertySpec{
0000000000000000000000000000000000000000;;						{
0000000000000000000000000000000000000000;;							All:  types.NewBool(true),
0000000000000000000000000000000000000000;;							Type: obj.Type,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return RetrievePropertiesForRequest(ctx, r, req, dst)
0000000000000000000000000000000000000000;;	}
