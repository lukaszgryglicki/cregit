0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/extras.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/extras.go][vendor/github.com/vmware/govmomi/vim25/xml/extras.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package xml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var xmlSchemaInstance = Name{Space: "http://www.w3.org/2001/XMLSchema-instance", Local: "type"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var xsiType = Name{Space: "xsi", Local: "type"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var stringToTypeMap = map[string]reflect.Type{
0000000000000000000000000000000000000000;;		"xsd:boolean":       reflect.TypeOf((*bool)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:byte":          reflect.TypeOf((*int8)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:short":         reflect.TypeOf((*int16)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:int":           reflect.TypeOf((*int32)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:long":          reflect.TypeOf((*int64)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:unsignedByte":  reflect.TypeOf((*uint8)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:unsignedShort": reflect.TypeOf((*uint16)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:unsignedInt":   reflect.TypeOf((*uint32)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:unsignedLong":  reflect.TypeOf((*uint64)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:float":         reflect.TypeOf((*float32)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:double":        reflect.TypeOf((*float64)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:string":        reflect.TypeOf((*string)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:dateTime":      reflect.TypeOf((*time.Time)(nil)).Elem(),
0000000000000000000000000000000000000000;;		"xsd:base64Binary":  reflect.TypeOf((*[]byte)(nil)).Elem(),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a reflect.Type for the specified type. Nil if unknown.
0000000000000000000000000000000000000000;;	func stringToType(s string) reflect.Type {
0000000000000000000000000000000000000000;;		return stringToTypeMap[s]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a string for the specified reflect.Type. Panic if unknown.
0000000000000000000000000000000000000000;;	func typeToString(typ reflect.Type) string {
0000000000000000000000000000000000000000;;		switch typ.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return "xsd:boolean"
0000000000000000000000000000000000000000;;		case reflect.Int8:
0000000000000000000000000000000000000000;;			return "xsd:byte"
0000000000000000000000000000000000000000;;		case reflect.Int16:
0000000000000000000000000000000000000000;;			return "xsd:short"
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			return "xsd:int"
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int64:
0000000000000000000000000000000000000000;;			return "xsd:long"
0000000000000000000000000000000000000000;;		case reflect.Uint8:
0000000000000000000000000000000000000000;;			return "xsd:unsignedByte"
0000000000000000000000000000000000000000;;		case reflect.Uint16:
0000000000000000000000000000000000000000;;			return "xsd:unsignedShort"
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			return "xsd:unsignedInt"
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint64:
0000000000000000000000000000000000000000;;			return "xsd:unsignedLong"
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			return "xsd:float"
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			return "xsd:double"
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			name := typ.Name()
0000000000000000000000000000000000000000;;			if name == "string" {
0000000000000000000000000000000000000000;;				return "xsd:string"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if typ == stringToTypeMap["xsd:dateTime"] {
0000000000000000000000000000000000000000;;				return "xsd:dateTime"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Expect any other struct to be handled...
0000000000000000000000000000000000000000;;			return typ.Name()
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if typ.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				return "xsd:base64Binary"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			if typ.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				return "xsd:base64Binary"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		panic("don't know what to do for type: " + typ.String())
0000000000000000000000000000000000000000;;	}
