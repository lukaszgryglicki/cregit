0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/xml.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/xml.go][vendor/github.com/vmware/govmomi/vim25/xml/xml.go];	
0000000000000000000000000000000000000000;;	// Package xml implements a simple XML 1.0 parser that
0000000000000000000000000000000000000000;;	// understands XML name spaces.
0000000000000000000000000000000000000000;;	package xml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// References:
0000000000000000000000000000000000000000;;	//    Annotated XML spec: http://www.xml.com/axml/testaxml.htm
0000000000000000000000000000000000000000;;	//    XML name spaces: http://www.w3.org/TR/REC-xml-names/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(rsc):
0000000000000000000000000000000000000000;;	//	Test error handling.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SyntaxError represents a syntax error in the XML input stream.
0000000000000000000000000000000000000000;;	type SyntaxError struct {
0000000000000000000000000000000000000000;;		Msg  string
0000000000000000000000000000000000000000;;		Line int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *SyntaxError) Error() string {
0000000000000000000000000000000000000000;;		return "XML syntax error on line " + strconv.Itoa(e.Line) + ": " + e.Msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Name represents an XML name (Local) annotated
0000000000000000000000000000000000000000;;	// with a name space identifier (Space).
0000000000000000000000000000000000000000;;	// In tokens returned by Decoder.Token, the Space identifier
0000000000000000000000000000000000000000;;	// is given as a canonical URL, not the short prefix used
0000000000000000000000000000000000000000;;	// in the document being parsed.
0000000000000000000000000000000000000000;;	type Name struct {
0000000000000000000000000000000000000000;;		Space, Local string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Attr represents an attribute in an XML element (Name=Value).
0000000000000000000000000000000000000000;;	type Attr struct {
0000000000000000000000000000000000000000;;		Name  Name
0000000000000000000000000000000000000000;;		Value string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Token is an interface holding one of the token types:
0000000000000000000000000000000000000000;;	// StartElement, EndElement, CharData, Comment, ProcInst, or Directive.
0000000000000000000000000000000000000000;;	type Token interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A StartElement represents an XML start element.
0000000000000000000000000000000000000000;;	type StartElement struct {
0000000000000000000000000000000000000000;;		Name Name
0000000000000000000000000000000000000000;;		Attr []Attr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e StartElement) Copy() StartElement {
0000000000000000000000000000000000000000;;		attrs := make([]Attr, len(e.Attr))
0000000000000000000000000000000000000000;;		copy(attrs, e.Attr)
0000000000000000000000000000000000000000;;		e.Attr = attrs
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// End returns the corresponding XML end element.
0000000000000000000000000000000000000000;;	func (e StartElement) End() EndElement {
0000000000000000000000000000000000000000;;		return EndElement{e.Name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An EndElement represents an XML end element.
0000000000000000000000000000000000000000;;	type EndElement struct {
0000000000000000000000000000000000000000;;		Name Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A CharData represents XML character data (raw text),
0000000000000000000000000000000000000000;;	// in which XML escape sequences have been replaced by
0000000000000000000000000000000000000000;;	// the characters they represent.
0000000000000000000000000000000000000000;;	type CharData []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeCopy(b []byte) []byte {
0000000000000000000000000000000000000000;;		b1 := make([]byte, len(b))
0000000000000000000000000000000000000000;;		copy(b1, b)
0000000000000000000000000000000000000000;;		return b1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CharData) Copy() CharData { return CharData(makeCopy(c)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Comment represents an XML comment of the form <!--comment-->.
0000000000000000000000000000000000000000;;	// The bytes do not include the <!-- and --> comment markers.
0000000000000000000000000000000000000000;;	type Comment []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c Comment) Copy() Comment { return Comment(makeCopy(c)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ProcInst represents an XML processing instruction of the form <?target inst?>
0000000000000000000000000000000000000000;;	type ProcInst struct {
0000000000000000000000000000000000000000;;		Target string
0000000000000000000000000000000000000000;;		Inst   []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p ProcInst) Copy() ProcInst {
0000000000000000000000000000000000000000;;		p.Inst = makeCopy(p.Inst)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Directive represents an XML directive of the form <!text>.
0000000000000000000000000000000000000000;;	// The bytes do not include the <! and > markers.
0000000000000000000000000000000000000000;;	type Directive []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Directive) Copy() Directive { return Directive(makeCopy(d)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyToken returns a copy of a Token.
0000000000000000000000000000000000000000;;	func CopyToken(t Token) Token {
0000000000000000000000000000000000000000;;		switch v := t.(type) {
0000000000000000000000000000000000000000;;		case CharData:
0000000000000000000000000000000000000000;;			return v.Copy()
0000000000000000000000000000000000000000;;		case Comment:
0000000000000000000000000000000000000000;;			return v.Copy()
0000000000000000000000000000000000000000;;		case Directive:
0000000000000000000000000000000000000000;;			return v.Copy()
0000000000000000000000000000000000000000;;		case ProcInst:
0000000000000000000000000000000000000000;;			return v.Copy()
0000000000000000000000000000000000000000;;		case StartElement:
0000000000000000000000000000000000000000;;			return v.Copy()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Decoder represents an XML parser reading a particular input stream.
0000000000000000000000000000000000000000;;	// The parser assumes that its input is encoded in UTF-8.
0000000000000000000000000000000000000000;;	type Decoder struct {
0000000000000000000000000000000000000000;;		// Strict defaults to true, enforcing the requirements
0000000000000000000000000000000000000000;;		// of the XML specification.
0000000000000000000000000000000000000000;;		// If set to false, the parser allows input containing common
0000000000000000000000000000000000000000;;		// mistakes:
0000000000000000000000000000000000000000;;		//	* If an element is missing an end tag, the parser invents
0000000000000000000000000000000000000000;;		//	  end tags as necessary to keep the return values from Token
0000000000000000000000000000000000000000;;		//	  properly balanced.
0000000000000000000000000000000000000000;;		//	* In attribute values and character data, unknown or malformed
0000000000000000000000000000000000000000;;		//	  character entities (sequences beginning with &) are left alone.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Setting:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//	d.Strict = false;
0000000000000000000000000000000000000000;;		//	d.AutoClose = HTMLAutoClose;
0000000000000000000000000000000000000000;;		//	d.Entity = HTMLEntity
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// creates a parser that can handle typical HTML.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Strict mode does not enforce the requirements of the XML name spaces TR.
0000000000000000000000000000000000000000;;		// In particular it does not reject name space tags using undefined prefixes.
0000000000000000000000000000000000000000;;		// Such tags are recorded with the unknown prefix as the name space URL.
0000000000000000000000000000000000000000;;		Strict bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When Strict == false, AutoClose indicates a set of elements to
0000000000000000000000000000000000000000;;		// consider closed immediately after they are opened, regardless
0000000000000000000000000000000000000000;;		// of whether an end element is present.
0000000000000000000000000000000000000000;;		AutoClose []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Entity can be used to map non-standard entity names to string replacements.
0000000000000000000000000000000000000000;;		// The parser behaves as if these standard mappings are present in the map,
0000000000000000000000000000000000000000;;		// regardless of the actual map content:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//	"lt": "<",
0000000000000000000000000000000000000000;;		//	"gt": ">",
0000000000000000000000000000000000000000;;		//	"amp": "&",
0000000000000000000000000000000000000000;;		//	"apos": "'",
0000000000000000000000000000000000000000;;		//	"quot": `"`,
0000000000000000000000000000000000000000;;		Entity map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CharsetReader, if non-nil, defines a function to generate
0000000000000000000000000000000000000000;;		// charset-conversion readers, converting from the provided
0000000000000000000000000000000000000000;;		// non-UTF-8 charset into UTF-8. If CharsetReader is nil or
0000000000000000000000000000000000000000;;		// returns an error, parsing stops with an error. One of the
0000000000000000000000000000000000000000;;		// the CharsetReader's result values must be non-nil.
0000000000000000000000000000000000000000;;		CharsetReader func(charset string, input io.Reader) (io.Reader, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultSpace sets the default name space used for unadorned tags,
0000000000000000000000000000000000000000;;		// as if the entire XML stream were wrapped in an element containing
0000000000000000000000000000000000000000;;		// the attribute xmlns="DefaultSpace".
0000000000000000000000000000000000000000;;		DefaultSpace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TypeFunc is used to map type names to actual types.
0000000000000000000000000000000000000000;;		TypeFunc func(string) (reflect.Type, bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r              io.ByteReader
0000000000000000000000000000000000000000;;		buf            bytes.Buffer
0000000000000000000000000000000000000000;;		saved          *bytes.Buffer
0000000000000000000000000000000000000000;;		stk            *stack
0000000000000000000000000000000000000000;;		free           *stack
0000000000000000000000000000000000000000;;		needClose      bool
0000000000000000000000000000000000000000;;		toClose        Name
0000000000000000000000000000000000000000;;		nextToken      Token
0000000000000000000000000000000000000000;;		nextByte       int
0000000000000000000000000000000000000000;;		ns             map[string]string
0000000000000000000000000000000000000000;;		err            error
0000000000000000000000000000000000000000;;		line           int
0000000000000000000000000000000000000000;;		unmarshalDepth int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder creates a new XML parser reading from r.
0000000000000000000000000000000000000000;;	// If r does not implement io.ByteReader, NewDecoder will
0000000000000000000000000000000000000000;;	// do its own buffering.
0000000000000000000000000000000000000000;;	func NewDecoder(r io.Reader) *Decoder {
0000000000000000000000000000000000000000;;		d := &Decoder{
0000000000000000000000000000000000000000;;			ns:       make(map[string]string),
0000000000000000000000000000000000000000;;			nextByte: -1,
0000000000000000000000000000000000000000;;			line:     1,
0000000000000000000000000000000000000000;;			Strict:   true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.switchToReader(r)
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token returns the next XML token in the input stream.
0000000000000000000000000000000000000000;;	// At the end of the input stream, Token returns nil, io.EOF.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Slices of bytes in the returned token data refer to the
0000000000000000000000000000000000000000;;	// parser's internal buffer and remain valid only until the next
0000000000000000000000000000000000000000;;	// call to Token.  To acquire a copy of the bytes, call CopyToken
0000000000000000000000000000000000000000;;	// or the token's Copy method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Token expands self-closing elements such as <br/>
0000000000000000000000000000000000000000;;	// into separate start and end elements returned by successive calls.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Token guarantees that the StartElement and EndElement
0000000000000000000000000000000000000000;;	// tokens it returns are properly nested and matched:
0000000000000000000000000000000000000000;;	// if Token encounters an unexpected end element,
0000000000000000000000000000000000000000;;	// it will return an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Token implements XML name spaces as described by
0000000000000000000000000000000000000000;;	// http://www.w3.org/TR/REC-xml-names/.  Each of the
0000000000000000000000000000000000000000;;	// Name structures contained in the Token has the Space
0000000000000000000000000000000000000000;;	// set to the URL identifying its name space when known.
0000000000000000000000000000000000000000;;	// If Token encounters an unrecognized name space prefix,
0000000000000000000000000000000000000000;;	// it uses the prefix as the Space rather than report an error.
0000000000000000000000000000000000000000;;	func (d *Decoder) Token() (t Token, err error) {
0000000000000000000000000000000000000000;;		if d.stk != nil && d.stk.kind == stkEOF {
0000000000000000000000000000000000000000;;			err = io.EOF
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.nextToken != nil {
0000000000000000000000000000000000000000;;			t = d.nextToken
0000000000000000000000000000000000000000;;			d.nextToken = nil
0000000000000000000000000000000000000000;;		} else if t, err = d.rawToken(); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !d.Strict {
0000000000000000000000000000000000000000;;			if t1, ok := d.autoClose(t); ok {
0000000000000000000000000000000000000000;;				d.nextToken = t
0000000000000000000000000000000000000000;;				t = t1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t1 := t.(type) {
0000000000000000000000000000000000000000;;		case StartElement:
0000000000000000000000000000000000000000;;			// In XML name spaces, the translations listed in the
0000000000000000000000000000000000000000;;			// attributes apply to the element name and
0000000000000000000000000000000000000000;;			// to the other attribute names, so process
0000000000000000000000000000000000000000;;			// the translations first.
0000000000000000000000000000000000000000;;			for _, a := range t1.Attr {
0000000000000000000000000000000000000000;;				if a.Name.Space == "xmlns" {
0000000000000000000000000000000000000000;;					v, ok := d.ns[a.Name.Local]
0000000000000000000000000000000000000000;;					d.pushNs(a.Name.Local, v, ok)
0000000000000000000000000000000000000000;;					d.ns[a.Name.Local] = a.Value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if a.Name.Space == "" && a.Name.Local == "xmlns" {
0000000000000000000000000000000000000000;;					// Default space for untagged names
0000000000000000000000000000000000000000;;					v, ok := d.ns[""]
0000000000000000000000000000000000000000;;					d.pushNs("", v, ok)
0000000000000000000000000000000000000000;;					d.ns[""] = a.Value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			d.translate(&t1.Name, true)
0000000000000000000000000000000000000000;;			for i := range t1.Attr {
0000000000000000000000000000000000000000;;				d.translate(&t1.Attr[i].Name, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.pushElement(t1.Name)
0000000000000000000000000000000000000000;;			t = t1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case EndElement:
0000000000000000000000000000000000000000;;			d.translate(&t1.Name, true)
0000000000000000000000000000000000000000;;			if !d.popElement(&t1) {
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = t1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const xmlURL = "http://www.w3.org/XML/1998/namespace"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Apply name space translation to name n.
0000000000000000000000000000000000000000;;	// The default name space (for Space=="")
0000000000000000000000000000000000000000;;	// applies only to element names, not to attribute names.
0000000000000000000000000000000000000000;;	func (d *Decoder) translate(n *Name, isElementName bool) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case n.Space == "xmlns":
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case n.Space == "" && !isElementName:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case n.Space == "xml":
0000000000000000000000000000000000000000;;			n.Space = xmlURL
0000000000000000000000000000000000000000;;		case n.Space == "" && n.Local == "xmlns":
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := d.ns[n.Space]; ok {
0000000000000000000000000000000000000000;;			n.Space = v
0000000000000000000000000000000000000000;;		} else if n.Space == "" {
0000000000000000000000000000000000000000;;			n.Space = d.DefaultSpace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) switchToReader(r io.Reader) {
0000000000000000000000000000000000000000;;		// Get efficient byte at a time reader.
0000000000000000000000000000000000000000;;		// Assume that if reader has its own
0000000000000000000000000000000000000000;;		// ReadByte, it's efficient enough.
0000000000000000000000000000000000000000;;		// Otherwise, use bufio.
0000000000000000000000000000000000000000;;		if rb, ok := r.(io.ByteReader); ok {
0000000000000000000000000000000000000000;;			d.r = rb
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.r = bufio.NewReader(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parsing state - stack holds old name space translations
0000000000000000000000000000000000000000;;	// and the current set of open elements.  The translations to pop when
0000000000000000000000000000000000000000;;	// ending a given tag are *below* it on the stack, which is
0000000000000000000000000000000000000000;;	// more work but forced on us by XML.
0000000000000000000000000000000000000000;;	type stack struct {
0000000000000000000000000000000000000000;;		next *stack
0000000000000000000000000000000000000000;;		kind int
0000000000000000000000000000000000000000;;		name Name
0000000000000000000000000000000000000000;;		ok   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		stkStart = iota
0000000000000000000000000000000000000000;;		stkNs
0000000000000000000000000000000000000000;;		stkEOF
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) push(kind int) *stack {
0000000000000000000000000000000000000000;;		s := d.free
0000000000000000000000000000000000000000;;		if s != nil {
0000000000000000000000000000000000000000;;			d.free = s.next
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s = new(stack)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.next = d.stk
0000000000000000000000000000000000000000;;		s.kind = kind
0000000000000000000000000000000000000000;;		d.stk = s
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) pop() *stack {
0000000000000000000000000000000000000000;;		s := d.stk
0000000000000000000000000000000000000000;;		if s != nil {
0000000000000000000000000000000000000000;;			d.stk = s.next
0000000000000000000000000000000000000000;;			s.next = d.free
0000000000000000000000000000000000000000;;			d.free = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Record that after the current element is finished
0000000000000000000000000000000000000000;;	// (that element is already pushed on the stack)
0000000000000000000000000000000000000000;;	// Token should return EOF until popEOF is called.
0000000000000000000000000000000000000000;;	func (d *Decoder) pushEOF() {
0000000000000000000000000000000000000000;;		// Walk down stack to find Start.
0000000000000000000000000000000000000000;;		// It might not be the top, because there might be stkNs
0000000000000000000000000000000000000000;;		// entries above it.
0000000000000000000000000000000000000000;;		start := d.stk
0000000000000000000000000000000000000000;;		for start.kind != stkStart {
0000000000000000000000000000000000000000;;			start = start.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The stkNs entries below a start are associated with that
0000000000000000000000000000000000000000;;		// element too; skip over them.
0000000000000000000000000000000000000000;;		for start.next != nil && start.next.kind == stkNs {
0000000000000000000000000000000000000000;;			start = start.next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := d.free
0000000000000000000000000000000000000000;;		if s != nil {
0000000000000000000000000000000000000000;;			d.free = s.next
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s = new(stack)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.kind = stkEOF
0000000000000000000000000000000000000000;;		s.next = start.next
0000000000000000000000000000000000000000;;		start.next = s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Undo a pushEOF.
0000000000000000000000000000000000000000;;	// The element must have been finished, so the EOF should be at the top of the stack.
0000000000000000000000000000000000000000;;	func (d *Decoder) popEOF() bool {
0000000000000000000000000000000000000000;;		if d.stk == nil || d.stk.kind != stkEOF {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.pop()
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Record that we are starting an element with the given name.
0000000000000000000000000000000000000000;;	func (d *Decoder) pushElement(name Name) {
0000000000000000000000000000000000000000;;		s := d.push(stkStart)
0000000000000000000000000000000000000000;;		s.name = name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Record that we are changing the value of ns[local].
0000000000000000000000000000000000000000;;	// The old value is url, ok.
0000000000000000000000000000000000000000;;	func (d *Decoder) pushNs(local string, url string, ok bool) {
0000000000000000000000000000000000000000;;		s := d.push(stkNs)
0000000000000000000000000000000000000000;;		s.name.Local = local
0000000000000000000000000000000000000000;;		s.name.Space = url
0000000000000000000000000000000000000000;;		s.ok = ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a SyntaxError with the current line number.
0000000000000000000000000000000000000000;;	func (d *Decoder) syntaxError(msg string) error {
0000000000000000000000000000000000000000;;		return &SyntaxError{Msg: msg, Line: d.line}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Record that we are ending an element with the given name.
0000000000000000000000000000000000000000;;	// The name must match the record at the top of the stack,
0000000000000000000000000000000000000000;;	// which must be a pushElement record.
0000000000000000000000000000000000000000;;	// After popping the element, apply any undo records from
0000000000000000000000000000000000000000;;	// the stack to restore the name translations that existed
0000000000000000000000000000000000000000;;	// before we saw this element.
0000000000000000000000000000000000000000;;	func (d *Decoder) popElement(t *EndElement) bool {
0000000000000000000000000000000000000000;;		s := d.pop()
0000000000000000000000000000000000000000;;		name := t.Name
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case s == nil || s.kind != stkStart:
0000000000000000000000000000000000000000;;			d.err = d.syntaxError("unexpected end element </" + name.Local + ">")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case s.name.Local != name.Local:
0000000000000000000000000000000000000000;;			if !d.Strict {
0000000000000000000000000000000000000000;;				d.needClose = true
0000000000000000000000000000000000000000;;				d.toClose = t.Name
0000000000000000000000000000000000000000;;				t.Name = s.name
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.err = d.syntaxError("element <" + s.name.Local + "> closed by </" + name.Local + ">")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case s.name.Space != name.Space:
0000000000000000000000000000000000000000;;			d.err = d.syntaxError("element <" + s.name.Local + "> in space " + s.name.Space +
0000000000000000000000000000000000000000;;				"closed by </" + name.Local + "> in space " + name.Space)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pop stack until a Start or EOF is on the top, undoing the
0000000000000000000000000000000000000000;;		// translations that were associated with the element we just closed.
0000000000000000000000000000000000000000;;		for d.stk != nil && d.stk.kind != stkStart && d.stk.kind != stkEOF {
0000000000000000000000000000000000000000;;			s := d.pop()
0000000000000000000000000000000000000000;;			if s.ok {
0000000000000000000000000000000000000000;;				d.ns[s.name.Local] = s.name.Space
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				delete(d.ns, s.name.Local)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If the top element on the stack is autoclosing and
0000000000000000000000000000000000000000;;	// t is not the end tag, invent the end tag.
0000000000000000000000000000000000000000;;	func (d *Decoder) autoClose(t Token) (Token, bool) {
0000000000000000000000000000000000000000;;		if d.stk == nil || d.stk.kind != stkStart {
0000000000000000000000000000000000000000;;			return nil, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := strings.ToLower(d.stk.name.Local)
0000000000000000000000000000000000000000;;		for _, s := range d.AutoClose {
0000000000000000000000000000000000000000;;			if strings.ToLower(s) == name {
0000000000000000000000000000000000000000;;				// This one should be auto closed if t doesn't close it.
0000000000000000000000000000000000000000;;				et, ok := t.(EndElement)
0000000000000000000000000000000000000000;;				if !ok || et.Name.Local != name {
0000000000000000000000000000000000000000;;					return EndElement{d.stk.name}, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errRawToken = errors.New("xml: cannot use RawToken from UnmarshalXML method")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RawToken is like Token but does not verify that
0000000000000000000000000000000000000000;;	// start and end elements match and does not translate
0000000000000000000000000000000000000000;;	// name space prefixes to their corresponding URLs.
0000000000000000000000000000000000000000;;	func (d *Decoder) RawToken() (Token, error) {
0000000000000000000000000000000000000000;;		if d.unmarshalDepth > 0 {
0000000000000000000000000000000000000000;;			return nil, errRawToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.rawToken()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) rawToken() (Token, error) {
0000000000000000000000000000000000000000;;		if d.err != nil {
0000000000000000000000000000000000000000;;			return nil, d.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.needClose {
0000000000000000000000000000000000000000;;			// The last element we read was self-closing and
0000000000000000000000000000000000000000;;			// we returned just the StartElement half.
0000000000000000000000000000000000000000;;			// Return the EndElement half now.
0000000000000000000000000000000000000000;;			d.needClose = false
0000000000000000000000000000000000000000;;			return EndElement{d.toClose}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, ok := d.getc()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, d.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b != '<' {
0000000000000000000000000000000000000000;;			// Text section.
0000000000000000000000000000000000000000;;			d.ungetc(b)
0000000000000000000000000000000000000000;;			data := d.text(-1, false)
0000000000000000000000000000000000000000;;			if data == nil {
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return CharData(data), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;			return nil, d.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch b {
0000000000000000000000000000000000000000;;		case '/':
0000000000000000000000000000000000000000;;			// </: End element
0000000000000000000000000000000000000000;;			var name Name
0000000000000000000000000000000000000000;;			if name, ok = d.nsname(); !ok {
0000000000000000000000000000000000000000;;				if d.err == nil {
0000000000000000000000000000000000000000;;					d.err = d.syntaxError("expected element name after </")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.space()
0000000000000000000000000000000000000000;;			if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b != '>' {
0000000000000000000000000000000000000000;;				d.err = d.syntaxError("invalid characters between </" + name.Local + " and >")
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return EndElement{name}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case '?':
0000000000000000000000000000000000000000;;			// <?: Processing instruction.
0000000000000000000000000000000000000000;;			// TODO(rsc): Should parse the <?xml declaration to make sure the version is 1.0.
0000000000000000000000000000000000000000;;			var target string
0000000000000000000000000000000000000000;;			if target, ok = d.name(); !ok {
0000000000000000000000000000000000000000;;				if d.err == nil {
0000000000000000000000000000000000000000;;					d.err = d.syntaxError("expected target name after <?")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.space()
0000000000000000000000000000000000000000;;			d.buf.Reset()
0000000000000000000000000000000000000000;;			var b0 byte
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;				if b0 == '?' && b == '>' {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b0 = b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data := d.buf.Bytes()
0000000000000000000000000000000000000000;;			data = data[0 : len(data)-2] // chop ?>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if target == "xml" {
0000000000000000000000000000000000000000;;				enc := procInstEncoding(string(data))
0000000000000000000000000000000000000000;;				if enc != "" && enc != "utf-8" && enc != "UTF-8" {
0000000000000000000000000000000000000000;;					if d.CharsetReader == nil {
0000000000000000000000000000000000000000;;						d.err = fmt.Errorf("xml: encoding %q declared but Decoder.CharsetReader is nil", enc)
0000000000000000000000000000000000000000;;						return nil, d.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					newr, err := d.CharsetReader(enc, d.r.(io.Reader))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						d.err = fmt.Errorf("xml: opening charset %q: %v", enc, err)
0000000000000000000000000000000000000000;;						return nil, d.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if newr == nil {
0000000000000000000000000000000000000000;;						panic("CharsetReader returned a nil Reader for charset " + enc)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					d.switchToReader(newr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ProcInst{target, data}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case '!':
0000000000000000000000000000000000000000;;			// <!: Maybe comment, maybe CDATA.
0000000000000000000000000000000000000000;;			if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch b {
0000000000000000000000000000000000000000;;			case '-': // <!-
0000000000000000000000000000000000000000;;				// Probably <!-- for a comment.
0000000000000000000000000000000000000000;;				if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b != '-' {
0000000000000000000000000000000000000000;;					d.err = d.syntaxError("invalid sequence <!- not part of <!--")
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Look for terminator.
0000000000000000000000000000000000000000;;				d.buf.Reset()
0000000000000000000000000000000000000000;;				var b0, b1 byte
0000000000000000000000000000000000000000;;				for {
0000000000000000000000000000000000000000;;					if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;						return nil, d.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;					if b0 == '-' && b1 == '-' && b == '>' {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					b0, b1 = b1, b
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				data := d.buf.Bytes()
0000000000000000000000000000000000000000;;				data = data[0 : len(data)-3] // chop -->
0000000000000000000000000000000000000000;;				return Comment(data), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '[': // <![
0000000000000000000000000000000000000000;;				// Probably <![CDATA[.
0000000000000000000000000000000000000000;;				for i := 0; i < 6; i++ {
0000000000000000000000000000000000000000;;					if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;						return nil, d.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if b != "CDATA["[i] {
0000000000000000000000000000000000000000;;						d.err = d.syntaxError("invalid <![ sequence")
0000000000000000000000000000000000000000;;						return nil, d.err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Have <![CDATA[.  Read text until ]]>.
0000000000000000000000000000000000000000;;				data := d.text(-1, true)
0000000000000000000000000000000000000000;;				if data == nil {
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return CharData(data), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Probably a directive: <!DOCTYPE ...>, <!ENTITY ...>, etc.
0000000000000000000000000000000000000000;;			// We don't care, but accumulate for caller. Quoted angle
0000000000000000000000000000000000000000;;			// brackets do not count for nesting.
0000000000000000000000000000000000000000;;			d.buf.Reset()
0000000000000000000000000000000000000000;;			d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;			inquote := uint8(0)
0000000000000000000000000000000000000000;;			depth := 0
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if inquote == 0 && b == '>' && depth == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			HandleB:
0000000000000000000000000000000000000000;;				d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case b == inquote:
0000000000000000000000000000000000000000;;					inquote = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case inquote != 0:
0000000000000000000000000000000000000000;;					// in quotes, no special action
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case b == '\'' || b == '"':
0000000000000000000000000000000000000000;;					inquote = b
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case b == '>' && inquote == 0:
0000000000000000000000000000000000000000;;					depth--
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case b == '<' && inquote == 0:
0000000000000000000000000000000000000000;;					// Look for <!-- to begin comment.
0000000000000000000000000000000000000000;;					s := "!--"
0000000000000000000000000000000000000000;;					for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;						if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;							return nil, d.err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if b != s[i] {
0000000000000000000000000000000000000000;;							for j := 0; j < i; j++ {
0000000000000000000000000000000000000000;;								d.buf.WriteByte(s[j])
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							depth++
0000000000000000000000000000000000000000;;							goto HandleB
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Remove < that was written above.
0000000000000000000000000000000000000000;;					d.buf.Truncate(d.buf.Len() - 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Look for terminator.
0000000000000000000000000000000000000000;;					var b0, b1 byte
0000000000000000000000000000000000000000;;					for {
0000000000000000000000000000000000000000;;						if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;							return nil, d.err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if b0 == '-' && b1 == '-' && b == '>' {
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						b0, b1 = b1, b
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return Directive(d.buf.Bytes()), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Must be an open element like <a href="foo">
0000000000000000000000000000000000000000;;		d.ungetc(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			name  Name
0000000000000000000000000000000000000000;;			empty bool
0000000000000000000000000000000000000000;;			attr  []Attr
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if name, ok = d.nsname(); !ok {
0000000000000000000000000000000000000000;;			if d.err == nil {
0000000000000000000000000000000000000000;;				d.err = d.syntaxError("expected element name after <")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, d.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attr = make([]Attr, 0, 4)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			d.space()
0000000000000000000000000000000000000000;;			if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b == '/' {
0000000000000000000000000000000000000000;;				empty = true
0000000000000000000000000000000000000000;;				if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b != '>' {
0000000000000000000000000000000000000000;;					d.err = d.syntaxError("expected /> in element")
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b == '>' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.ungetc(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n := len(attr)
0000000000000000000000000000000000000000;;			if n >= cap(attr) {
0000000000000000000000000000000000000000;;				nattr := make([]Attr, n, 2*cap(attr))
0000000000000000000000000000000000000000;;				copy(nattr, attr)
0000000000000000000000000000000000000000;;				attr = nattr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attr = attr[0 : n+1]
0000000000000000000000000000000000000000;;			a := &attr[n]
0000000000000000000000000000000000000000;;			if a.Name, ok = d.nsname(); !ok {
0000000000000000000000000000000000000000;;				if d.err == nil {
0000000000000000000000000000000000000000;;					d.err = d.syntaxError("expected attribute name in element")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.space()
0000000000000000000000000000000000000000;;			if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;				return nil, d.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b != '=' {
0000000000000000000000000000000000000000;;				if d.Strict {
0000000000000000000000000000000000000000;;					d.err = d.syntaxError("attribute name without = in element")
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.ungetc(b)
0000000000000000000000000000000000000000;;					a.Value = a.Name.Local
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.space()
0000000000000000000000000000000000000000;;				data := d.attrval()
0000000000000000000000000000000000000000;;				if data == nil {
0000000000000000000000000000000000000000;;					return nil, d.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				a.Value = string(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if empty {
0000000000000000000000000000000000000000;;			d.needClose = true
0000000000000000000000000000000000000000;;			d.toClose = name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return StartElement{name, attr}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) attrval() []byte {
0000000000000000000000000000000000000000;;		b, ok := d.mustgetc()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Handle quoted attribute values
0000000000000000000000000000000000000000;;		if b == '"' || b == '\'' {
0000000000000000000000000000000000000000;;			return d.text(int(b), false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Handle unquoted attribute values for strict parsers
0000000000000000000000000000000000000000;;		if d.Strict {
0000000000000000000000000000000000000000;;			d.err = d.syntaxError("unquoted or missing attribute value in element")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Handle unquoted attribute values for unstrict parsers
0000000000000000000000000000000000000000;;		d.ungetc(b)
0000000000000000000000000000000000000000;;		d.buf.Reset()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b, ok = d.mustgetc()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// http://www.w3.org/TR/REC-html40/intro/sgmltut.html#h-3.2.2
0000000000000000000000000000000000000000;;			if 'a' <= b && b <= 'z' || 'A' <= b && b <= 'Z' ||
0000000000000000000000000000000000000000;;				'0' <= b && b <= '9' || b == '_' || b == ':' || b == '-' {
0000000000000000000000000000000000000000;;				d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.ungetc(b)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.buf.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Skip spaces if any
0000000000000000000000000000000000000000;;	func (d *Decoder) space() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b, ok := d.getc()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch b {
0000000000000000000000000000000000000000;;			case ' ', '\r', '\n', '\t':
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				d.ungetc(b)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read a single byte.
0000000000000000000000000000000000000000;;	// If there is no byte to read, return ok==false
0000000000000000000000000000000000000000;;	// and leave the error in d.err.
0000000000000000000000000000000000000000;;	// Maintain line number.
0000000000000000000000000000000000000000;;	func (d *Decoder) getc() (b byte, ok bool) {
0000000000000000000000000000000000000000;;		if d.err != nil {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.nextByte >= 0 {
0000000000000000000000000000000000000000;;			b = byte(d.nextByte)
0000000000000000000000000000000000000000;;			d.nextByte = -1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			b, d.err = d.r.ReadByte()
0000000000000000000000000000000000000000;;			if d.err != nil {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if d.saved != nil {
0000000000000000000000000000000000000000;;				d.saved.WriteByte(b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b == '\n' {
0000000000000000000000000000000000000000;;			d.line++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return saved offset.
0000000000000000000000000000000000000000;;	// If we did ungetc (nextByte >= 0), have to back up one.
0000000000000000000000000000000000000000;;	func (d *Decoder) savedOffset() int {
0000000000000000000000000000000000000000;;		n := d.saved.Len()
0000000000000000000000000000000000000000;;		if d.nextByte >= 0 {
0000000000000000000000000000000000000000;;			n--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Must read a single byte.
0000000000000000000000000000000000000000;;	// If there is no byte to read,
0000000000000000000000000000000000000000;;	// set d.err to SyntaxError("unexpected EOF")
0000000000000000000000000000000000000000;;	// and return ok==false
0000000000000000000000000000000000000000;;	func (d *Decoder) mustgetc() (b byte, ok bool) {
0000000000000000000000000000000000000000;;		if b, ok = d.getc(); !ok {
0000000000000000000000000000000000000000;;			if d.err == io.EOF {
0000000000000000000000000000000000000000;;				d.err = d.syntaxError("unexpected EOF")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unread a single byte.
0000000000000000000000000000000000000000;;	func (d *Decoder) ungetc(b byte) {
0000000000000000000000000000000000000000;;		if b == '\n' {
0000000000000000000000000000000000000000;;			d.line--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.nextByte = int(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var entity = map[string]int{
0000000000000000000000000000000000000000;;		"lt":   '<',
0000000000000000000000000000000000000000;;		"gt":   '>',
0000000000000000000000000000000000000000;;		"amp":  '&',
0000000000000000000000000000000000000000;;		"apos": '\'',
0000000000000000000000000000000000000000;;		"quot": '"',
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read plain text section (XML calls it character data).
0000000000000000000000000000000000000000;;	// If quote >= 0, we are in a quoted string and need to find the matching quote.
0000000000000000000000000000000000000000;;	// If cdata == true, we are in a <![CDATA[ section and need to find ]]>.
0000000000000000000000000000000000000000;;	// On failure return nil and leave the error in d.err.
0000000000000000000000000000000000000000;;	func (d *Decoder) text(quote int, cdata bool) []byte {
0000000000000000000000000000000000000000;;		var b0, b1 byte
0000000000000000000000000000000000000000;;		var trunc int
0000000000000000000000000000000000000000;;		d.buf.Reset()
0000000000000000000000000000000000000000;;	Input:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			b, ok := d.getc()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if cdata {
0000000000000000000000000000000000000000;;					if d.err == io.EOF {
0000000000000000000000000000000000000000;;						d.err = d.syntaxError("unexpected EOF in CDATA section")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break Input
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// <![CDATA[ section ends with ]]>.
0000000000000000000000000000000000000000;;			// It is an error for ]]> to appear in ordinary text.
0000000000000000000000000000000000000000;;			if b0 == ']' && b1 == ']' && b == '>' {
0000000000000000000000000000000000000000;;				if cdata {
0000000000000000000000000000000000000000;;					trunc = 2
0000000000000000000000000000000000000000;;					break Input
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.err = d.syntaxError("unescaped ]]> not in CDATA section")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Stop reading text if we see a <.
0000000000000000000000000000000000000000;;			if b == '<' && !cdata {
0000000000000000000000000000000000000000;;				if quote >= 0 {
0000000000000000000000000000000000000000;;					d.err = d.syntaxError("unescaped < inside quoted string")
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.ungetc('<')
0000000000000000000000000000000000000000;;				break Input
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if quote >= 0 && b == byte(quote) {
0000000000000000000000000000000000000000;;				break Input
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b == '&' && !cdata {
0000000000000000000000000000000000000000;;				// Read escaped character expression up to semicolon.
0000000000000000000000000000000000000000;;				// XML in all its glory allows a document to define and use
0000000000000000000000000000000000000000;;				// its own character names with <!ENTITY ...> directives.
0000000000000000000000000000000000000000;;				// Parsers are required to recognize lt, gt, amp, apos, and quot
0000000000000000000000000000000000000000;;				// even if they have not been declared.
0000000000000000000000000000000000000000;;				before := d.buf.Len()
0000000000000000000000000000000000000000;;				d.buf.WriteByte('&')
0000000000000000000000000000000000000000;;				var ok bool
0000000000000000000000000000000000000000;;				var text string
0000000000000000000000000000000000000000;;				var haveText bool
0000000000000000000000000000000000000000;;				if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b == '#' {
0000000000000000000000000000000000000000;;					d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;					if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					base := 10
0000000000000000000000000000000000000000;;					if b == 'x' {
0000000000000000000000000000000000000000;;						base = 16
0000000000000000000000000000000000000000;;						d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;						if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					start := d.buf.Len()
0000000000000000000000000000000000000000;;					for '0' <= b && b <= '9' ||
0000000000000000000000000000000000000000;;						base == 16 && 'a' <= b && b <= 'f' ||
0000000000000000000000000000000000000000;;						base == 16 && 'A' <= b && b <= 'F' {
0000000000000000000000000000000000000000;;						d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;						if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if b != ';' {
0000000000000000000000000000000000000000;;						d.ungetc(b)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						s := string(d.buf.Bytes()[start:])
0000000000000000000000000000000000000000;;						d.buf.WriteByte(';')
0000000000000000000000000000000000000000;;						n, err := strconv.ParseUint(s, base, 64)
0000000000000000000000000000000000000000;;						if err == nil && n <= unicode.MaxRune {
0000000000000000000000000000000000000000;;							text = string(n)
0000000000000000000000000000000000000000;;							haveText = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.ungetc(b)
0000000000000000000000000000000000000000;;					if !d.readName() {
0000000000000000000000000000000000000000;;						if d.err != nil {
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						ok = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if b != ';' {
0000000000000000000000000000000000000000;;						d.ungetc(b)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						name := d.buf.Bytes()[before+1:]
0000000000000000000000000000000000000000;;						d.buf.WriteByte(';')
0000000000000000000000000000000000000000;;						if isName(name) {
0000000000000000000000000000000000000000;;							s := string(name)
0000000000000000000000000000000000000000;;							if r, ok := entity[s]; ok {
0000000000000000000000000000000000000000;;								text = string(r)
0000000000000000000000000000000000000000;;								haveText = true
0000000000000000000000000000000000000000;;							} else if d.Entity != nil {
0000000000000000000000000000000000000000;;								text, haveText = d.Entity[s]
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if haveText {
0000000000000000000000000000000000000000;;					d.buf.Truncate(before)
0000000000000000000000000000000000000000;;					d.buf.Write([]byte(text))
0000000000000000000000000000000000000000;;					b0, b1 = 0, 0
0000000000000000000000000000000000000000;;					continue Input
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !d.Strict {
0000000000000000000000000000000000000000;;					b0, b1 = 0, 0
0000000000000000000000000000000000000000;;					continue Input
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ent := string(d.buf.Bytes()[before:])
0000000000000000000000000000000000000000;;				if ent[len(ent)-1] != ';' {
0000000000000000000000000000000000000000;;					ent += " (no semicolon)"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.err = d.syntaxError("invalid character entity " + ent)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We must rewrite unescaped \r and \r\n into \n.
0000000000000000000000000000000000000000;;			if b == '\r' {
0000000000000000000000000000000000000000;;				d.buf.WriteByte('\n')
0000000000000000000000000000000000000000;;			} else if b1 == '\r' && b == '\n' {
0000000000000000000000000000000000000000;;				// Skip \r\n--we already wrote \n.
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b0, b1 = b1, b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := d.buf.Bytes()
0000000000000000000000000000000000000000;;		data = data[0 : len(data)-trunc]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inspect each rune for being a disallowed character.
0000000000000000000000000000000000000000;;		buf := data
0000000000000000000000000000000000000000;;		for len(buf) > 0 {
0000000000000000000000000000000000000000;;			r, size := utf8.DecodeRune(buf)
0000000000000000000000000000000000000000;;			if r == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;				d.err = d.syntaxError("invalid UTF-8")
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = buf[size:]
0000000000000000000000000000000000000000;;			if !isInCharacterRange(r) {
0000000000000000000000000000000000000000;;				d.err = d.syntaxError(fmt.Sprintf("illegal character code %U", r))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decide whether the given rune is in the XML Character Range, per
0000000000000000000000000000000000000000;;	// the Char production of http://www.xml.com/axml/testaxml.htm,
0000000000000000000000000000000000000000;;	// Section 2.2 Characters.
0000000000000000000000000000000000000000;;	func isInCharacterRange(r rune) (inrange bool) {
0000000000000000000000000000000000000000;;		return r == 0x09 ||
0000000000000000000000000000000000000000;;			r == 0x0A ||
0000000000000000000000000000000000000000;;			r == 0x0D ||
0000000000000000000000000000000000000000;;			r >= 0x20 && r <= 0xDF77 ||
0000000000000000000000000000000000000000;;			r >= 0xE000 && r <= 0xFFFD ||
0000000000000000000000000000000000000000;;			r >= 0x10000 && r <= 0x10FFFF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get name space name: name with a : stuck in the middle.
0000000000000000000000000000000000000000;;	// The part before the : is the name space identifier.
0000000000000000000000000000000000000000;;	func (d *Decoder) nsname() (name Name, ok bool) {
0000000000000000000000000000000000000000;;		s, ok := d.name()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := strings.Index(s, ":")
0000000000000000000000000000000000000000;;		if i < 0 {
0000000000000000000000000000000000000000;;			name.Local = s
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			name.Space = s[0:i]
0000000000000000000000000000000000000000;;			name.Local = s[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get name: /first(first|second)*/
0000000000000000000000000000000000000000;;	// Do not set d.err if the name is missing (unless unexpected EOF is received):
0000000000000000000000000000000000000000;;	// let the caller provide better context.
0000000000000000000000000000000000000000;;	func (d *Decoder) name() (s string, ok bool) {
0000000000000000000000000000000000000000;;		d.buf.Reset()
0000000000000000000000000000000000000000;;		if !d.readName() {
0000000000000000000000000000000000000000;;			return "", false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now we check the characters.
0000000000000000000000000000000000000000;;		s = d.buf.String()
0000000000000000000000000000000000000000;;		if !isName([]byte(s)) {
0000000000000000000000000000000000000000;;			d.err = d.syntaxError("invalid XML name: " + s)
0000000000000000000000000000000000000000;;			return "", false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read a name and append its bytes to d.buf.
0000000000000000000000000000000000000000;;	// The name is delimited by any single-byte character not valid in names.
0000000000000000000000000000000000000000;;	// All multi-byte characters are accepted; the caller must check their validity.
0000000000000000000000000000000000000000;;	func (d *Decoder) readName() (ok bool) {
0000000000000000000000000000000000000000;;		var b byte
0000000000000000000000000000000000000000;;		if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b < utf8.RuneSelf && !isNameByte(b) {
0000000000000000000000000000000000000000;;			d.ungetc(b)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if b, ok = d.mustgetc(); !ok {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b < utf8.RuneSelf && !isNameByte(b) {
0000000000000000000000000000000000000000;;				d.ungetc(b)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.buf.WriteByte(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNameByte(c byte) bool {
0000000000000000000000000000000000000000;;		return 'A' <= c && c <= 'Z' ||
0000000000000000000000000000000000000000;;			'a' <= c && c <= 'z' ||
0000000000000000000000000000000000000000;;			'0' <= c && c <= '9' ||
0000000000000000000000000000000000000000;;			c == '_' || c == ':' || c == '.' || c == '-'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isName(s []byte) bool {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, n := utf8.DecodeRune(s)
0000000000000000000000000000000000000000;;		if c == utf8.RuneError && n == 1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !unicode.Is(first, c) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for n < len(s) {
0000000000000000000000000000000000000000;;			s = s[n:]
0000000000000000000000000000000000000000;;			c, n = utf8.DecodeRune(s)
0000000000000000000000000000000000000000;;			if c == utf8.RuneError && n == 1 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !unicode.Is(first, c) && !unicode.Is(second, c) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNameString(s string) bool {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c, n := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;		if c == utf8.RuneError && n == 1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !unicode.Is(first, c) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for n < len(s) {
0000000000000000000000000000000000000000;;			s = s[n:]
0000000000000000000000000000000000000000;;			c, n = utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;			if c == utf8.RuneError && n == 1 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !unicode.Is(first, c) && !unicode.Is(second, c) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These tables were generated by cut and paste from Appendix B of
0000000000000000000000000000000000000000;;	// the XML spec at http://www.xml.com/axml/testaxml.htm
0000000000000000000000000000000000000000;;	// and then reformatting.  First corresponds to (Letter | '_' | ':')
0000000000000000000000000000000000000000;;	// and second corresponds to NameChar.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var first = &unicode.RangeTable{
0000000000000000000000000000000000000000;;		R16: []unicode.Range16{
0000000000000000000000000000000000000000;;			{0x003A, 0x003A, 1},
0000000000000000000000000000000000000000;;			{0x0041, 0x005A, 1},
0000000000000000000000000000000000000000;;			{0x005F, 0x005F, 1},
0000000000000000000000000000000000000000;;			{0x0061, 0x007A, 1},
0000000000000000000000000000000000000000;;			{0x00C0, 0x00D6, 1},
0000000000000000000000000000000000000000;;			{0x00D8, 0x00F6, 1},
0000000000000000000000000000000000000000;;			{0x00F8, 0x00FF, 1},
0000000000000000000000000000000000000000;;			{0x0100, 0x0131, 1},
0000000000000000000000000000000000000000;;			{0x0134, 0x013E, 1},
0000000000000000000000000000000000000000;;			{0x0141, 0x0148, 1},
0000000000000000000000000000000000000000;;			{0x014A, 0x017E, 1},
0000000000000000000000000000000000000000;;			{0x0180, 0x01C3, 1},
0000000000000000000000000000000000000000;;			{0x01CD, 0x01F0, 1},
0000000000000000000000000000000000000000;;			{0x01F4, 0x01F5, 1},
0000000000000000000000000000000000000000;;			{0x01FA, 0x0217, 1},
0000000000000000000000000000000000000000;;			{0x0250, 0x02A8, 1},
0000000000000000000000000000000000000000;;			{0x02BB, 0x02C1, 1},
0000000000000000000000000000000000000000;;			{0x0386, 0x0386, 1},
0000000000000000000000000000000000000000;;			{0x0388, 0x038A, 1},
0000000000000000000000000000000000000000;;			{0x038C, 0x038C, 1},
0000000000000000000000000000000000000000;;			{0x038E, 0x03A1, 1},
0000000000000000000000000000000000000000;;			{0x03A3, 0x03CE, 1},
0000000000000000000000000000000000000000;;			{0x03D0, 0x03D6, 1},
0000000000000000000000000000000000000000;;			{0x03DA, 0x03E0, 2},
0000000000000000000000000000000000000000;;			{0x03E2, 0x03F3, 1},
0000000000000000000000000000000000000000;;			{0x0401, 0x040C, 1},
0000000000000000000000000000000000000000;;			{0x040E, 0x044F, 1},
0000000000000000000000000000000000000000;;			{0x0451, 0x045C, 1},
0000000000000000000000000000000000000000;;			{0x045E, 0x0481, 1},
0000000000000000000000000000000000000000;;			{0x0490, 0x04C4, 1},
0000000000000000000000000000000000000000;;			{0x04C7, 0x04C8, 1},
0000000000000000000000000000000000000000;;			{0x04CB, 0x04CC, 1},
0000000000000000000000000000000000000000;;			{0x04D0, 0x04EB, 1},
0000000000000000000000000000000000000000;;			{0x04EE, 0x04F5, 1},
0000000000000000000000000000000000000000;;			{0x04F8, 0x04F9, 1},
0000000000000000000000000000000000000000;;			{0x0531, 0x0556, 1},
0000000000000000000000000000000000000000;;			{0x0559, 0x0559, 1},
0000000000000000000000000000000000000000;;			{0x0561, 0x0586, 1},
0000000000000000000000000000000000000000;;			{0x05D0, 0x05EA, 1},
0000000000000000000000000000000000000000;;			{0x05F0, 0x05F2, 1},
0000000000000000000000000000000000000000;;			{0x0621, 0x063A, 1},
0000000000000000000000000000000000000000;;			{0x0641, 0x064A, 1},
0000000000000000000000000000000000000000;;			{0x0671, 0x06B7, 1},
0000000000000000000000000000000000000000;;			{0x06BA, 0x06BE, 1},
0000000000000000000000000000000000000000;;			{0x06C0, 0x06CE, 1},
0000000000000000000000000000000000000000;;			{0x06D0, 0x06D3, 1},
0000000000000000000000000000000000000000;;			{0x06D5, 0x06D5, 1},
0000000000000000000000000000000000000000;;			{0x06E5, 0x06E6, 1},
0000000000000000000000000000000000000000;;			{0x0905, 0x0939, 1},
0000000000000000000000000000000000000000;;			{0x093D, 0x093D, 1},
0000000000000000000000000000000000000000;;			{0x0958, 0x0961, 1},
0000000000000000000000000000000000000000;;			{0x0985, 0x098C, 1},
0000000000000000000000000000000000000000;;			{0x098F, 0x0990, 1},
0000000000000000000000000000000000000000;;			{0x0993, 0x09A8, 1},
0000000000000000000000000000000000000000;;			{0x09AA, 0x09B0, 1},
0000000000000000000000000000000000000000;;			{0x09B2, 0x09B2, 1},
0000000000000000000000000000000000000000;;			{0x09B6, 0x09B9, 1},
0000000000000000000000000000000000000000;;			{0x09DC, 0x09DD, 1},
0000000000000000000000000000000000000000;;			{0x09DF, 0x09E1, 1},
0000000000000000000000000000000000000000;;			{0x09F0, 0x09F1, 1},
0000000000000000000000000000000000000000;;			{0x0A05, 0x0A0A, 1},
0000000000000000000000000000000000000000;;			{0x0A0F, 0x0A10, 1},
0000000000000000000000000000000000000000;;			{0x0A13, 0x0A28, 1},
0000000000000000000000000000000000000000;;			{0x0A2A, 0x0A30, 1},
0000000000000000000000000000000000000000;;			{0x0A32, 0x0A33, 1},
0000000000000000000000000000000000000000;;			{0x0A35, 0x0A36, 1},
0000000000000000000000000000000000000000;;			{0x0A38, 0x0A39, 1},
0000000000000000000000000000000000000000;;			{0x0A59, 0x0A5C, 1},
0000000000000000000000000000000000000000;;			{0x0A5E, 0x0A5E, 1},
0000000000000000000000000000000000000000;;			{0x0A72, 0x0A74, 1},
0000000000000000000000000000000000000000;;			{0x0A85, 0x0A8B, 1},
0000000000000000000000000000000000000000;;			{0x0A8D, 0x0A8D, 1},
0000000000000000000000000000000000000000;;			{0x0A8F, 0x0A91, 1},
0000000000000000000000000000000000000000;;			{0x0A93, 0x0AA8, 1},
0000000000000000000000000000000000000000;;			{0x0AAA, 0x0AB0, 1},
0000000000000000000000000000000000000000;;			{0x0AB2, 0x0AB3, 1},
0000000000000000000000000000000000000000;;			{0x0AB5, 0x0AB9, 1},
0000000000000000000000000000000000000000;;			{0x0ABD, 0x0AE0, 0x23},
0000000000000000000000000000000000000000;;			{0x0B05, 0x0B0C, 1},
0000000000000000000000000000000000000000;;			{0x0B0F, 0x0B10, 1},
0000000000000000000000000000000000000000;;			{0x0B13, 0x0B28, 1},
0000000000000000000000000000000000000000;;			{0x0B2A, 0x0B30, 1},
0000000000000000000000000000000000000000;;			{0x0B32, 0x0B33, 1},
0000000000000000000000000000000000000000;;			{0x0B36, 0x0B39, 1},
0000000000000000000000000000000000000000;;			{0x0B3D, 0x0B3D, 1},
0000000000000000000000000000000000000000;;			{0x0B5C, 0x0B5D, 1},
0000000000000000000000000000000000000000;;			{0x0B5F, 0x0B61, 1},
0000000000000000000000000000000000000000;;			{0x0B85, 0x0B8A, 1},
0000000000000000000000000000000000000000;;			{0x0B8E, 0x0B90, 1},
0000000000000000000000000000000000000000;;			{0x0B92, 0x0B95, 1},
0000000000000000000000000000000000000000;;			{0x0B99, 0x0B9A, 1},
0000000000000000000000000000000000000000;;			{0x0B9C, 0x0B9C, 1},
0000000000000000000000000000000000000000;;			{0x0B9E, 0x0B9F, 1},
0000000000000000000000000000000000000000;;			{0x0BA3, 0x0BA4, 1},
0000000000000000000000000000000000000000;;			{0x0BA8, 0x0BAA, 1},
0000000000000000000000000000000000000000;;			{0x0BAE, 0x0BB5, 1},
0000000000000000000000000000000000000000;;			{0x0BB7, 0x0BB9, 1},
0000000000000000000000000000000000000000;;			{0x0C05, 0x0C0C, 1},
0000000000000000000000000000000000000000;;			{0x0C0E, 0x0C10, 1},
0000000000000000000000000000000000000000;;			{0x0C12, 0x0C28, 1},
0000000000000000000000000000000000000000;;			{0x0C2A, 0x0C33, 1},
0000000000000000000000000000000000000000;;			{0x0C35, 0x0C39, 1},
0000000000000000000000000000000000000000;;			{0x0C60, 0x0C61, 1},
0000000000000000000000000000000000000000;;			{0x0C85, 0x0C8C, 1},
0000000000000000000000000000000000000000;;			{0x0C8E, 0x0C90, 1},
0000000000000000000000000000000000000000;;			{0x0C92, 0x0CA8, 1},
0000000000000000000000000000000000000000;;			{0x0CAA, 0x0CB3, 1},
0000000000000000000000000000000000000000;;			{0x0CB5, 0x0CB9, 1},
0000000000000000000000000000000000000000;;			{0x0CDE, 0x0CDE, 1},
0000000000000000000000000000000000000000;;			{0x0CE0, 0x0CE1, 1},
0000000000000000000000000000000000000000;;			{0x0D05, 0x0D0C, 1},
0000000000000000000000000000000000000000;;			{0x0D0E, 0x0D10, 1},
0000000000000000000000000000000000000000;;			{0x0D12, 0x0D28, 1},
0000000000000000000000000000000000000000;;			{0x0D2A, 0x0D39, 1},
0000000000000000000000000000000000000000;;			{0x0D60, 0x0D61, 1},
0000000000000000000000000000000000000000;;			{0x0E01, 0x0E2E, 1},
0000000000000000000000000000000000000000;;			{0x0E30, 0x0E30, 1},
0000000000000000000000000000000000000000;;			{0x0E32, 0x0E33, 1},
0000000000000000000000000000000000000000;;			{0x0E40, 0x0E45, 1},
0000000000000000000000000000000000000000;;			{0x0E81, 0x0E82, 1},
0000000000000000000000000000000000000000;;			{0x0E84, 0x0E84, 1},
0000000000000000000000000000000000000000;;			{0x0E87, 0x0E88, 1},
0000000000000000000000000000000000000000;;			{0x0E8A, 0x0E8D, 3},
0000000000000000000000000000000000000000;;			{0x0E94, 0x0E97, 1},
0000000000000000000000000000000000000000;;			{0x0E99, 0x0E9F, 1},
0000000000000000000000000000000000000000;;			{0x0EA1, 0x0EA3, 1},
0000000000000000000000000000000000000000;;			{0x0EA5, 0x0EA7, 2},
0000000000000000000000000000000000000000;;			{0x0EAA, 0x0EAB, 1},
0000000000000000000000000000000000000000;;			{0x0EAD, 0x0EAE, 1},
0000000000000000000000000000000000000000;;			{0x0EB0, 0x0EB0, 1},
0000000000000000000000000000000000000000;;			{0x0EB2, 0x0EB3, 1},
0000000000000000000000000000000000000000;;			{0x0EBD, 0x0EBD, 1},
0000000000000000000000000000000000000000;;			{0x0EC0, 0x0EC4, 1},
0000000000000000000000000000000000000000;;			{0x0F40, 0x0F47, 1},
0000000000000000000000000000000000000000;;			{0x0F49, 0x0F69, 1},
0000000000000000000000000000000000000000;;			{0x10A0, 0x10C5, 1},
0000000000000000000000000000000000000000;;			{0x10D0, 0x10F6, 1},
0000000000000000000000000000000000000000;;			{0x1100, 0x1100, 1},
0000000000000000000000000000000000000000;;			{0x1102, 0x1103, 1},
0000000000000000000000000000000000000000;;			{0x1105, 0x1107, 1},
0000000000000000000000000000000000000000;;			{0x1109, 0x1109, 1},
0000000000000000000000000000000000000000;;			{0x110B, 0x110C, 1},
0000000000000000000000000000000000000000;;			{0x110E, 0x1112, 1},
0000000000000000000000000000000000000000;;			{0x113C, 0x1140, 2},
0000000000000000000000000000000000000000;;			{0x114C, 0x1150, 2},
0000000000000000000000000000000000000000;;			{0x1154, 0x1155, 1},
0000000000000000000000000000000000000000;;			{0x1159, 0x1159, 1},
0000000000000000000000000000000000000000;;			{0x115F, 0x1161, 1},
0000000000000000000000000000000000000000;;			{0x1163, 0x1169, 2},
0000000000000000000000000000000000000000;;			{0x116D, 0x116E, 1},
0000000000000000000000000000000000000000;;			{0x1172, 0x1173, 1},
0000000000000000000000000000000000000000;;			{0x1175, 0x119E, 0x119E - 0x1175},
0000000000000000000000000000000000000000;;			{0x11A8, 0x11AB, 0x11AB - 0x11A8},
0000000000000000000000000000000000000000;;			{0x11AE, 0x11AF, 1},
0000000000000000000000000000000000000000;;			{0x11B7, 0x11B8, 1},
0000000000000000000000000000000000000000;;			{0x11BA, 0x11BA, 1},
0000000000000000000000000000000000000000;;			{0x11BC, 0x11C2, 1},
0000000000000000000000000000000000000000;;			{0x11EB, 0x11F0, 0x11F0 - 0x11EB},
0000000000000000000000000000000000000000;;			{0x11F9, 0x11F9, 1},
0000000000000000000000000000000000000000;;			{0x1E00, 0x1E9B, 1},
0000000000000000000000000000000000000000;;			{0x1EA0, 0x1EF9, 1},
0000000000000000000000000000000000000000;;			{0x1F00, 0x1F15, 1},
0000000000000000000000000000000000000000;;			{0x1F18, 0x1F1D, 1},
0000000000000000000000000000000000000000;;			{0x1F20, 0x1F45, 1},
0000000000000000000000000000000000000000;;			{0x1F48, 0x1F4D, 1},
0000000000000000000000000000000000000000;;			{0x1F50, 0x1F57, 1},
0000000000000000000000000000000000000000;;			{0x1F59, 0x1F5B, 0x1F5B - 0x1F59},
0000000000000000000000000000000000000000;;			{0x1F5D, 0x1F5D, 1},
0000000000000000000000000000000000000000;;			{0x1F5F, 0x1F7D, 1},
0000000000000000000000000000000000000000;;			{0x1F80, 0x1FB4, 1},
0000000000000000000000000000000000000000;;			{0x1FB6, 0x1FBC, 1},
0000000000000000000000000000000000000000;;			{0x1FBE, 0x1FBE, 1},
0000000000000000000000000000000000000000;;			{0x1FC2, 0x1FC4, 1},
0000000000000000000000000000000000000000;;			{0x1FC6, 0x1FCC, 1},
0000000000000000000000000000000000000000;;			{0x1FD0, 0x1FD3, 1},
0000000000000000000000000000000000000000;;			{0x1FD6, 0x1FDB, 1},
0000000000000000000000000000000000000000;;			{0x1FE0, 0x1FEC, 1},
0000000000000000000000000000000000000000;;			{0x1FF2, 0x1FF4, 1},
0000000000000000000000000000000000000000;;			{0x1FF6, 0x1FFC, 1},
0000000000000000000000000000000000000000;;			{0x2126, 0x2126, 1},
0000000000000000000000000000000000000000;;			{0x212A, 0x212B, 1},
0000000000000000000000000000000000000000;;			{0x212E, 0x212E, 1},
0000000000000000000000000000000000000000;;			{0x2180, 0x2182, 1},
0000000000000000000000000000000000000000;;			{0x3007, 0x3007, 1},
0000000000000000000000000000000000000000;;			{0x3021, 0x3029, 1},
0000000000000000000000000000000000000000;;			{0x3041, 0x3094, 1},
0000000000000000000000000000000000000000;;			{0x30A1, 0x30FA, 1},
0000000000000000000000000000000000000000;;			{0x3105, 0x312C, 1},
0000000000000000000000000000000000000000;;			{0x4E00, 0x9FA5, 1},
0000000000000000000000000000000000000000;;			{0xAC00, 0xD7A3, 1},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var second = &unicode.RangeTable{
0000000000000000000000000000000000000000;;		R16: []unicode.Range16{
0000000000000000000000000000000000000000;;			{0x002D, 0x002E, 1},
0000000000000000000000000000000000000000;;			{0x0030, 0x0039, 1},
0000000000000000000000000000000000000000;;			{0x00B7, 0x00B7, 1},
0000000000000000000000000000000000000000;;			{0x02D0, 0x02D1, 1},
0000000000000000000000000000000000000000;;			{0x0300, 0x0345, 1},
0000000000000000000000000000000000000000;;			{0x0360, 0x0361, 1},
0000000000000000000000000000000000000000;;			{0x0387, 0x0387, 1},
0000000000000000000000000000000000000000;;			{0x0483, 0x0486, 1},
0000000000000000000000000000000000000000;;			{0x0591, 0x05A1, 1},
0000000000000000000000000000000000000000;;			{0x05A3, 0x05B9, 1},
0000000000000000000000000000000000000000;;			{0x05BB, 0x05BD, 1},
0000000000000000000000000000000000000000;;			{0x05BF, 0x05BF, 1},
0000000000000000000000000000000000000000;;			{0x05C1, 0x05C2, 1},
0000000000000000000000000000000000000000;;			{0x05C4, 0x0640, 0x0640 - 0x05C4},
0000000000000000000000000000000000000000;;			{0x064B, 0x0652, 1},
0000000000000000000000000000000000000000;;			{0x0660, 0x0669, 1},
0000000000000000000000000000000000000000;;			{0x0670, 0x0670, 1},
0000000000000000000000000000000000000000;;			{0x06D6, 0x06DC, 1},
0000000000000000000000000000000000000000;;			{0x06DD, 0x06DF, 1},
0000000000000000000000000000000000000000;;			{0x06E0, 0x06E4, 1},
0000000000000000000000000000000000000000;;			{0x06E7, 0x06E8, 1},
0000000000000000000000000000000000000000;;			{0x06EA, 0x06ED, 1},
0000000000000000000000000000000000000000;;			{0x06F0, 0x06F9, 1},
0000000000000000000000000000000000000000;;			{0x0901, 0x0903, 1},
0000000000000000000000000000000000000000;;			{0x093C, 0x093C, 1},
0000000000000000000000000000000000000000;;			{0x093E, 0x094C, 1},
0000000000000000000000000000000000000000;;			{0x094D, 0x094D, 1},
0000000000000000000000000000000000000000;;			{0x0951, 0x0954, 1},
0000000000000000000000000000000000000000;;			{0x0962, 0x0963, 1},
0000000000000000000000000000000000000000;;			{0x0966, 0x096F, 1},
0000000000000000000000000000000000000000;;			{0x0981, 0x0983, 1},
0000000000000000000000000000000000000000;;			{0x09BC, 0x09BC, 1},
0000000000000000000000000000000000000000;;			{0x09BE, 0x09BF, 1},
0000000000000000000000000000000000000000;;			{0x09C0, 0x09C4, 1},
0000000000000000000000000000000000000000;;			{0x09C7, 0x09C8, 1},
0000000000000000000000000000000000000000;;			{0x09CB, 0x09CD, 1},
0000000000000000000000000000000000000000;;			{0x09D7, 0x09D7, 1},
0000000000000000000000000000000000000000;;			{0x09E2, 0x09E3, 1},
0000000000000000000000000000000000000000;;			{0x09E6, 0x09EF, 1},
0000000000000000000000000000000000000000;;			{0x0A02, 0x0A3C, 0x3A},
0000000000000000000000000000000000000000;;			{0x0A3E, 0x0A3F, 1},
0000000000000000000000000000000000000000;;			{0x0A40, 0x0A42, 1},
0000000000000000000000000000000000000000;;			{0x0A47, 0x0A48, 1},
0000000000000000000000000000000000000000;;			{0x0A4B, 0x0A4D, 1},
0000000000000000000000000000000000000000;;			{0x0A66, 0x0A6F, 1},
0000000000000000000000000000000000000000;;			{0x0A70, 0x0A71, 1},
0000000000000000000000000000000000000000;;			{0x0A81, 0x0A83, 1},
0000000000000000000000000000000000000000;;			{0x0ABC, 0x0ABC, 1},
0000000000000000000000000000000000000000;;			{0x0ABE, 0x0AC5, 1},
0000000000000000000000000000000000000000;;			{0x0AC7, 0x0AC9, 1},
0000000000000000000000000000000000000000;;			{0x0ACB, 0x0ACD, 1},
0000000000000000000000000000000000000000;;			{0x0AE6, 0x0AEF, 1},
0000000000000000000000000000000000000000;;			{0x0B01, 0x0B03, 1},
0000000000000000000000000000000000000000;;			{0x0B3C, 0x0B3C, 1},
0000000000000000000000000000000000000000;;			{0x0B3E, 0x0B43, 1},
0000000000000000000000000000000000000000;;			{0x0B47, 0x0B48, 1},
0000000000000000000000000000000000000000;;			{0x0B4B, 0x0B4D, 1},
0000000000000000000000000000000000000000;;			{0x0B56, 0x0B57, 1},
0000000000000000000000000000000000000000;;			{0x0B66, 0x0B6F, 1},
0000000000000000000000000000000000000000;;			{0x0B82, 0x0B83, 1},
0000000000000000000000000000000000000000;;			{0x0BBE, 0x0BC2, 1},
0000000000000000000000000000000000000000;;			{0x0BC6, 0x0BC8, 1},
0000000000000000000000000000000000000000;;			{0x0BCA, 0x0BCD, 1},
0000000000000000000000000000000000000000;;			{0x0BD7, 0x0BD7, 1},
0000000000000000000000000000000000000000;;			{0x0BE7, 0x0BEF, 1},
0000000000000000000000000000000000000000;;			{0x0C01, 0x0C03, 1},
0000000000000000000000000000000000000000;;			{0x0C3E, 0x0C44, 1},
0000000000000000000000000000000000000000;;			{0x0C46, 0x0C48, 1},
0000000000000000000000000000000000000000;;			{0x0C4A, 0x0C4D, 1},
0000000000000000000000000000000000000000;;			{0x0C55, 0x0C56, 1},
0000000000000000000000000000000000000000;;			{0x0C66, 0x0C6F, 1},
0000000000000000000000000000000000000000;;			{0x0C82, 0x0C83, 1},
0000000000000000000000000000000000000000;;			{0x0CBE, 0x0CC4, 1},
0000000000000000000000000000000000000000;;			{0x0CC6, 0x0CC8, 1},
0000000000000000000000000000000000000000;;			{0x0CCA, 0x0CCD, 1},
0000000000000000000000000000000000000000;;			{0x0CD5, 0x0CD6, 1},
0000000000000000000000000000000000000000;;			{0x0CE6, 0x0CEF, 1},
0000000000000000000000000000000000000000;;			{0x0D02, 0x0D03, 1},
0000000000000000000000000000000000000000;;			{0x0D3E, 0x0D43, 1},
0000000000000000000000000000000000000000;;			{0x0D46, 0x0D48, 1},
0000000000000000000000000000000000000000;;			{0x0D4A, 0x0D4D, 1},
0000000000000000000000000000000000000000;;			{0x0D57, 0x0D57, 1},
0000000000000000000000000000000000000000;;			{0x0D66, 0x0D6F, 1},
0000000000000000000000000000000000000000;;			{0x0E31, 0x0E31, 1},
0000000000000000000000000000000000000000;;			{0x0E34, 0x0E3A, 1},
0000000000000000000000000000000000000000;;			{0x0E46, 0x0E46, 1},
0000000000000000000000000000000000000000;;			{0x0E47, 0x0E4E, 1},
0000000000000000000000000000000000000000;;			{0x0E50, 0x0E59, 1},
0000000000000000000000000000000000000000;;			{0x0EB1, 0x0EB1, 1},
0000000000000000000000000000000000000000;;			{0x0EB4, 0x0EB9, 1},
0000000000000000000000000000000000000000;;			{0x0EBB, 0x0EBC, 1},
0000000000000000000000000000000000000000;;			{0x0EC6, 0x0EC6, 1},
0000000000000000000000000000000000000000;;			{0x0EC8, 0x0ECD, 1},
0000000000000000000000000000000000000000;;			{0x0ED0, 0x0ED9, 1},
0000000000000000000000000000000000000000;;			{0x0F18, 0x0F19, 1},
0000000000000000000000000000000000000000;;			{0x0F20, 0x0F29, 1},
0000000000000000000000000000000000000000;;			{0x0F35, 0x0F39, 2},
0000000000000000000000000000000000000000;;			{0x0F3E, 0x0F3F, 1},
0000000000000000000000000000000000000000;;			{0x0F71, 0x0F84, 1},
0000000000000000000000000000000000000000;;			{0x0F86, 0x0F8B, 1},
0000000000000000000000000000000000000000;;			{0x0F90, 0x0F95, 1},
0000000000000000000000000000000000000000;;			{0x0F97, 0x0F97, 1},
0000000000000000000000000000000000000000;;			{0x0F99, 0x0FAD, 1},
0000000000000000000000000000000000000000;;			{0x0FB1, 0x0FB7, 1},
0000000000000000000000000000000000000000;;			{0x0FB9, 0x0FB9, 1},
0000000000000000000000000000000000000000;;			{0x20D0, 0x20DC, 1},
0000000000000000000000000000000000000000;;			{0x20E1, 0x3005, 0x3005 - 0x20E1},
0000000000000000000000000000000000000000;;			{0x302A, 0x302F, 1},
0000000000000000000000000000000000000000;;			{0x3031, 0x3035, 1},
0000000000000000000000000000000000000000;;			{0x3099, 0x309A, 1},
0000000000000000000000000000000000000000;;			{0x309D, 0x309E, 1},
0000000000000000000000000000000000000000;;			{0x30FC, 0x30FE, 1},
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTMLEntity is an entity map containing translations for the
0000000000000000000000000000000000000000;;	// standard HTML entity characters.
0000000000000000000000000000000000000000;;	var HTMLEntity = htmlEntity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var htmlEntity = map[string]string{
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			hget http://www.w3.org/TR/html4/sgml/entities.html |
0000000000000000000000000000000000000000;;			ssam '
0000000000000000000000000000000000000000;;				,y /\&gt;/ x/\&lt;(.|\n)+/ s/\n/ /g
0000000000000000000000000000000000000000;;				,x v/^\&lt;!ENTITY/d
0000000000000000000000000000000000000000;;				,s/\&lt;!ENTITY ([^ ]+) .*U\+([0-9A-F][0-9A-F][0-9A-F][0-9A-F]) .+/	"\1": "\\u\2",/g
0000000000000000000000000000000000000000;;			'
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		"nbsp":     "\u00A0",
0000000000000000000000000000000000000000;;		"iexcl":    "\u00A1",
0000000000000000000000000000000000000000;;		"cent":     "\u00A2",
0000000000000000000000000000000000000000;;		"pound":    "\u00A3",
0000000000000000000000000000000000000000;;		"curren":   "\u00A4",
0000000000000000000000000000000000000000;;		"yen":      "\u00A5",
0000000000000000000000000000000000000000;;		"brvbar":   "\u00A6",
0000000000000000000000000000000000000000;;		"sect":     "\u00A7",
0000000000000000000000000000000000000000;;		"uml":      "\u00A8",
0000000000000000000000000000000000000000;;		"copy":     "\u00A9",
0000000000000000000000000000000000000000;;		"ordf":     "\u00AA",
0000000000000000000000000000000000000000;;		"laquo":    "\u00AB",
0000000000000000000000000000000000000000;;		"not":      "\u00AC",
0000000000000000000000000000000000000000;;		"shy":      "\u00AD",
0000000000000000000000000000000000000000;;		"reg":      "\u00AE",
0000000000000000000000000000000000000000;;		"macr":     "\u00AF",
0000000000000000000000000000000000000000;;		"deg":      "\u00B0",
0000000000000000000000000000000000000000;;		"plusmn":   "\u00B1",
0000000000000000000000000000000000000000;;		"sup2":     "\u00B2",
0000000000000000000000000000000000000000;;		"sup3":     "\u00B3",
0000000000000000000000000000000000000000;;		"acute":    "\u00B4",
0000000000000000000000000000000000000000;;		"micro":    "\u00B5",
0000000000000000000000000000000000000000;;		"para":     "\u00B6",
0000000000000000000000000000000000000000;;		"middot":   "\u00B7",
0000000000000000000000000000000000000000;;		"cedil":    "\u00B8",
0000000000000000000000000000000000000000;;		"sup1":     "\u00B9",
0000000000000000000000000000000000000000;;		"ordm":     "\u00BA",
0000000000000000000000000000000000000000;;		"raquo":    "\u00BB",
0000000000000000000000000000000000000000;;		"frac14":   "\u00BC",
0000000000000000000000000000000000000000;;		"frac12":   "\u00BD",
0000000000000000000000000000000000000000;;		"frac34":   "\u00BE",
0000000000000000000000000000000000000000;;		"iquest":   "\u00BF",
0000000000000000000000000000000000000000;;		"Agrave":   "\u00C0",
0000000000000000000000000000000000000000;;		"Aacute":   "\u00C1",
0000000000000000000000000000000000000000;;		"Acirc":    "\u00C2",
0000000000000000000000000000000000000000;;		"Atilde":   "\u00C3",
0000000000000000000000000000000000000000;;		"Auml":     "\u00C4",
0000000000000000000000000000000000000000;;		"Aring":    "\u00C5",
0000000000000000000000000000000000000000;;		"AElig":    "\u00C6",
0000000000000000000000000000000000000000;;		"Ccedil":   "\u00C7",
0000000000000000000000000000000000000000;;		"Egrave":   "\u00C8",
0000000000000000000000000000000000000000;;		"Eacute":   "\u00C9",
0000000000000000000000000000000000000000;;		"Ecirc":    "\u00CA",
0000000000000000000000000000000000000000;;		"Euml":     "\u00CB",
0000000000000000000000000000000000000000;;		"Igrave":   "\u00CC",
0000000000000000000000000000000000000000;;		"Iacute":   "\u00CD",
0000000000000000000000000000000000000000;;		"Icirc":    "\u00CE",
0000000000000000000000000000000000000000;;		"Iuml":     "\u00CF",
0000000000000000000000000000000000000000;;		"ETH":      "\u00D0",
0000000000000000000000000000000000000000;;		"Ntilde":   "\u00D1",
0000000000000000000000000000000000000000;;		"Ograve":   "\u00D2",
0000000000000000000000000000000000000000;;		"Oacute":   "\u00D3",
0000000000000000000000000000000000000000;;		"Ocirc":    "\u00D4",
0000000000000000000000000000000000000000;;		"Otilde":   "\u00D5",
0000000000000000000000000000000000000000;;		"Ouml":     "\u00D6",
0000000000000000000000000000000000000000;;		"times":    "\u00D7",
0000000000000000000000000000000000000000;;		"Oslash":   "\u00D8",
0000000000000000000000000000000000000000;;		"Ugrave":   "\u00D9",
0000000000000000000000000000000000000000;;		"Uacute":   "\u00DA",
0000000000000000000000000000000000000000;;		"Ucirc":    "\u00DB",
0000000000000000000000000000000000000000;;		"Uuml":     "\u00DC",
0000000000000000000000000000000000000000;;		"Yacute":   "\u00DD",
0000000000000000000000000000000000000000;;		"THORN":    "\u00DE",
0000000000000000000000000000000000000000;;		"szlig":    "\u00DF",
0000000000000000000000000000000000000000;;		"agrave":   "\u00E0",
0000000000000000000000000000000000000000;;		"aacute":   "\u00E1",
0000000000000000000000000000000000000000;;		"acirc":    "\u00E2",
0000000000000000000000000000000000000000;;		"atilde":   "\u00E3",
0000000000000000000000000000000000000000;;		"auml":     "\u00E4",
0000000000000000000000000000000000000000;;		"aring":    "\u00E5",
0000000000000000000000000000000000000000;;		"aelig":    "\u00E6",
0000000000000000000000000000000000000000;;		"ccedil":   "\u00E7",
0000000000000000000000000000000000000000;;		"egrave":   "\u00E8",
0000000000000000000000000000000000000000;;		"eacute":   "\u00E9",
0000000000000000000000000000000000000000;;		"ecirc":    "\u00EA",
0000000000000000000000000000000000000000;;		"euml":     "\u00EB",
0000000000000000000000000000000000000000;;		"igrave":   "\u00EC",
0000000000000000000000000000000000000000;;		"iacute":   "\u00ED",
0000000000000000000000000000000000000000;;		"icirc":    "\u00EE",
0000000000000000000000000000000000000000;;		"iuml":     "\u00EF",
0000000000000000000000000000000000000000;;		"eth":      "\u00F0",
0000000000000000000000000000000000000000;;		"ntilde":   "\u00F1",
0000000000000000000000000000000000000000;;		"ograve":   "\u00F2",
0000000000000000000000000000000000000000;;		"oacute":   "\u00F3",
0000000000000000000000000000000000000000;;		"ocirc":    "\u00F4",
0000000000000000000000000000000000000000;;		"otilde":   "\u00F5",
0000000000000000000000000000000000000000;;		"ouml":     "\u00F6",
0000000000000000000000000000000000000000;;		"divide":   "\u00F7",
0000000000000000000000000000000000000000;;		"oslash":   "\u00F8",
0000000000000000000000000000000000000000;;		"ugrave":   "\u00F9",
0000000000000000000000000000000000000000;;		"uacute":   "\u00FA",
0000000000000000000000000000000000000000;;		"ucirc":    "\u00FB",
0000000000000000000000000000000000000000;;		"uuml":     "\u00FC",
0000000000000000000000000000000000000000;;		"yacute":   "\u00FD",
0000000000000000000000000000000000000000;;		"thorn":    "\u00FE",
0000000000000000000000000000000000000000;;		"yuml":     "\u00FF",
0000000000000000000000000000000000000000;;		"fnof":     "\u0192",
0000000000000000000000000000000000000000;;		"Alpha":    "\u0391",
0000000000000000000000000000000000000000;;		"Beta":     "\u0392",
0000000000000000000000000000000000000000;;		"Gamma":    "\u0393",
0000000000000000000000000000000000000000;;		"Delta":    "\u0394",
0000000000000000000000000000000000000000;;		"Epsilon":  "\u0395",
0000000000000000000000000000000000000000;;		"Zeta":     "\u0396",
0000000000000000000000000000000000000000;;		"Eta":      "\u0397",
0000000000000000000000000000000000000000;;		"Theta":    "\u0398",
0000000000000000000000000000000000000000;;		"Iota":     "\u0399",
0000000000000000000000000000000000000000;;		"Kappa":    "\u039A",
0000000000000000000000000000000000000000;;		"Lambda":   "\u039B",
0000000000000000000000000000000000000000;;		"Mu":       "\u039C",
0000000000000000000000000000000000000000;;		"Nu":       "\u039D",
0000000000000000000000000000000000000000;;		"Xi":       "\u039E",
0000000000000000000000000000000000000000;;		"Omicron":  "\u039F",
0000000000000000000000000000000000000000;;		"Pi":       "\u03A0",
0000000000000000000000000000000000000000;;		"Rho":      "\u03A1",
0000000000000000000000000000000000000000;;		"Sigma":    "\u03A3",
0000000000000000000000000000000000000000;;		"Tau":      "\u03A4",
0000000000000000000000000000000000000000;;		"Upsilon":  "\u03A5",
0000000000000000000000000000000000000000;;		"Phi":      "\u03A6",
0000000000000000000000000000000000000000;;		"Chi":      "\u03A7",
0000000000000000000000000000000000000000;;		"Psi":      "\u03A8",
0000000000000000000000000000000000000000;;		"Omega":    "\u03A9",
0000000000000000000000000000000000000000;;		"alpha":    "\u03B1",
0000000000000000000000000000000000000000;;		"beta":     "\u03B2",
0000000000000000000000000000000000000000;;		"gamma":    "\u03B3",
0000000000000000000000000000000000000000;;		"delta":    "\u03B4",
0000000000000000000000000000000000000000;;		"epsilon":  "\u03B5",
0000000000000000000000000000000000000000;;		"zeta":     "\u03B6",
0000000000000000000000000000000000000000;;		"eta":      "\u03B7",
0000000000000000000000000000000000000000;;		"theta":    "\u03B8",
0000000000000000000000000000000000000000;;		"iota":     "\u03B9",
0000000000000000000000000000000000000000;;		"kappa":    "\u03BA",
0000000000000000000000000000000000000000;;		"lambda":   "\u03BB",
0000000000000000000000000000000000000000;;		"mu":       "\u03BC",
0000000000000000000000000000000000000000;;		"nu":       "\u03BD",
0000000000000000000000000000000000000000;;		"xi":       "\u03BE",
0000000000000000000000000000000000000000;;		"omicron":  "\u03BF",
0000000000000000000000000000000000000000;;		"pi":       "\u03C0",
0000000000000000000000000000000000000000;;		"rho":      "\u03C1",
0000000000000000000000000000000000000000;;		"sigmaf":   "\u03C2",
0000000000000000000000000000000000000000;;		"sigma":    "\u03C3",
0000000000000000000000000000000000000000;;		"tau":      "\u03C4",
0000000000000000000000000000000000000000;;		"upsilon":  "\u03C5",
0000000000000000000000000000000000000000;;		"phi":      "\u03C6",
0000000000000000000000000000000000000000;;		"chi":      "\u03C7",
0000000000000000000000000000000000000000;;		"psi":      "\u03C8",
0000000000000000000000000000000000000000;;		"omega":    "\u03C9",
0000000000000000000000000000000000000000;;		"thetasym": "\u03D1",
0000000000000000000000000000000000000000;;		"upsih":    "\u03D2",
0000000000000000000000000000000000000000;;		"piv":      "\u03D6",
0000000000000000000000000000000000000000;;		"bull":     "\u2022",
0000000000000000000000000000000000000000;;		"hellip":   "\u2026",
0000000000000000000000000000000000000000;;		"prime":    "\u2032",
0000000000000000000000000000000000000000;;		"Prime":    "\u2033",
0000000000000000000000000000000000000000;;		"oline":    "\u203E",
0000000000000000000000000000000000000000;;		"frasl":    "\u2044",
0000000000000000000000000000000000000000;;		"weierp":   "\u2118",
0000000000000000000000000000000000000000;;		"image":    "\u2111",
0000000000000000000000000000000000000000;;		"real":     "\u211C",
0000000000000000000000000000000000000000;;		"trade":    "\u2122",
0000000000000000000000000000000000000000;;		"alefsym":  "\u2135",
0000000000000000000000000000000000000000;;		"larr":     "\u2190",
0000000000000000000000000000000000000000;;		"uarr":     "\u2191",
0000000000000000000000000000000000000000;;		"rarr":     "\u2192",
0000000000000000000000000000000000000000;;		"darr":     "\u2193",
0000000000000000000000000000000000000000;;		"harr":     "\u2194",
0000000000000000000000000000000000000000;;		"crarr":    "\u21B5",
0000000000000000000000000000000000000000;;		"lArr":     "\u21D0",
0000000000000000000000000000000000000000;;		"uArr":     "\u21D1",
0000000000000000000000000000000000000000;;		"rArr":     "\u21D2",
0000000000000000000000000000000000000000;;		"dArr":     "\u21D3",
0000000000000000000000000000000000000000;;		"hArr":     "\u21D4",
0000000000000000000000000000000000000000;;		"forall":   "\u2200",
0000000000000000000000000000000000000000;;		"part":     "\u2202",
0000000000000000000000000000000000000000;;		"exist":    "\u2203",
0000000000000000000000000000000000000000;;		"empty":    "\u2205",
0000000000000000000000000000000000000000;;		"nabla":    "\u2207",
0000000000000000000000000000000000000000;;		"isin":     "\u2208",
0000000000000000000000000000000000000000;;		"notin":    "\u2209",
0000000000000000000000000000000000000000;;		"ni":       "\u220B",
0000000000000000000000000000000000000000;;		"prod":     "\u220F",
0000000000000000000000000000000000000000;;		"sum":      "\u2211",
0000000000000000000000000000000000000000;;		"minus":    "\u2212",
0000000000000000000000000000000000000000;;		"lowast":   "\u2217",
0000000000000000000000000000000000000000;;		"radic":    "\u221A",
0000000000000000000000000000000000000000;;		"prop":     "\u221D",
0000000000000000000000000000000000000000;;		"infin":    "\u221E",
0000000000000000000000000000000000000000;;		"ang":      "\u2220",
0000000000000000000000000000000000000000;;		"and":      "\u2227",
0000000000000000000000000000000000000000;;		"or":       "\u2228",
0000000000000000000000000000000000000000;;		"cap":      "\u2229",
0000000000000000000000000000000000000000;;		"cup":      "\u222A",
0000000000000000000000000000000000000000;;		"int":      "\u222B",
0000000000000000000000000000000000000000;;		"there4":   "\u2234",
0000000000000000000000000000000000000000;;		"sim":      "\u223C",
0000000000000000000000000000000000000000;;		"cong":     "\u2245",
0000000000000000000000000000000000000000;;		"asymp":    "\u2248",
0000000000000000000000000000000000000000;;		"ne":       "\u2260",
0000000000000000000000000000000000000000;;		"equiv":    "\u2261",
0000000000000000000000000000000000000000;;		"le":       "\u2264",
0000000000000000000000000000000000000000;;		"ge":       "\u2265",
0000000000000000000000000000000000000000;;		"sub":      "\u2282",
0000000000000000000000000000000000000000;;		"sup":      "\u2283",
0000000000000000000000000000000000000000;;		"nsub":     "\u2284",
0000000000000000000000000000000000000000;;		"sube":     "\u2286",
0000000000000000000000000000000000000000;;		"supe":     "\u2287",
0000000000000000000000000000000000000000;;		"oplus":    "\u2295",
0000000000000000000000000000000000000000;;		"otimes":   "\u2297",
0000000000000000000000000000000000000000;;		"perp":     "\u22A5",
0000000000000000000000000000000000000000;;		"sdot":     "\u22C5",
0000000000000000000000000000000000000000;;		"lceil":    "\u2308",
0000000000000000000000000000000000000000;;		"rceil":    "\u2309",
0000000000000000000000000000000000000000;;		"lfloor":   "\u230A",
0000000000000000000000000000000000000000;;		"rfloor":   "\u230B",
0000000000000000000000000000000000000000;;		"lang":     "\u2329",
0000000000000000000000000000000000000000;;		"rang":     "\u232A",
0000000000000000000000000000000000000000;;		"loz":      "\u25CA",
0000000000000000000000000000000000000000;;		"spades":   "\u2660",
0000000000000000000000000000000000000000;;		"clubs":    "\u2663",
0000000000000000000000000000000000000000;;		"hearts":   "\u2665",
0000000000000000000000000000000000000000;;		"diams":    "\u2666",
0000000000000000000000000000000000000000;;		"quot":     "\u0022",
0000000000000000000000000000000000000000;;		"amp":      "\u0026",
0000000000000000000000000000000000000000;;		"lt":       "\u003C",
0000000000000000000000000000000000000000;;		"gt":       "\u003E",
0000000000000000000000000000000000000000;;		"OElig":    "\u0152",
0000000000000000000000000000000000000000;;		"oelig":    "\u0153",
0000000000000000000000000000000000000000;;		"Scaron":   "\u0160",
0000000000000000000000000000000000000000;;		"scaron":   "\u0161",
0000000000000000000000000000000000000000;;		"Yuml":     "\u0178",
0000000000000000000000000000000000000000;;		"circ":     "\u02C6",
0000000000000000000000000000000000000000;;		"tilde":    "\u02DC",
0000000000000000000000000000000000000000;;		"ensp":     "\u2002",
0000000000000000000000000000000000000000;;		"emsp":     "\u2003",
0000000000000000000000000000000000000000;;		"thinsp":   "\u2009",
0000000000000000000000000000000000000000;;		"zwnj":     "\u200C",
0000000000000000000000000000000000000000;;		"zwj":      "\u200D",
0000000000000000000000000000000000000000;;		"lrm":      "\u200E",
0000000000000000000000000000000000000000;;		"rlm":      "\u200F",
0000000000000000000000000000000000000000;;		"ndash":    "\u2013",
0000000000000000000000000000000000000000;;		"mdash":    "\u2014",
0000000000000000000000000000000000000000;;		"lsquo":    "\u2018",
0000000000000000000000000000000000000000;;		"rsquo":    "\u2019",
0000000000000000000000000000000000000000;;		"sbquo":    "\u201A",
0000000000000000000000000000000000000000;;		"ldquo":    "\u201C",
0000000000000000000000000000000000000000;;		"rdquo":    "\u201D",
0000000000000000000000000000000000000000;;		"bdquo":    "\u201E",
0000000000000000000000000000000000000000;;		"dagger":   "\u2020",
0000000000000000000000000000000000000000;;		"Dagger":   "\u2021",
0000000000000000000000000000000000000000;;		"permil":   "\u2030",
0000000000000000000000000000000000000000;;		"lsaquo":   "\u2039",
0000000000000000000000000000000000000000;;		"rsaquo":   "\u203A",
0000000000000000000000000000000000000000;;		"euro":     "\u20AC",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTMLAutoClose is the set of HTML elements that
0000000000000000000000000000000000000000;;	// should be considered to close automatically.
0000000000000000000000000000000000000000;;	var HTMLAutoClose = htmlAutoClose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var htmlAutoClose = []string{
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			hget http://www.w3.org/TR/html4/loose.dtd |
0000000000000000000000000000000000000000;;			9 sed -n 's/<!ELEMENT ([^ ]*) +- O EMPTY.+/	"\1",/p' | tr A-Z a-z
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		"basefont",
0000000000000000000000000000000000000000;;		"br",
0000000000000000000000000000000000000000;;		"area",
0000000000000000000000000000000000000000;;		"link",
0000000000000000000000000000000000000000;;		"img",
0000000000000000000000000000000000000000;;		"param",
0000000000000000000000000000000000000000;;		"hr",
0000000000000000000000000000000000000000;;		"input",
0000000000000000000000000000000000000000;;		"col",
0000000000000000000000000000000000000000;;		"frame",
0000000000000000000000000000000000000000;;		"isindex",
0000000000000000000000000000000000000000;;		"base",
0000000000000000000000000000000000000000;;		"meta",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		esc_quot = []byte("&#34;") // shorter than "&quot;"
0000000000000000000000000000000000000000;;		esc_apos = []byte("&#39;") // shorter than "&apos;"
0000000000000000000000000000000000000000;;		esc_amp  = []byte("&amp;")
0000000000000000000000000000000000000000;;		esc_lt   = []byte("&lt;")
0000000000000000000000000000000000000000;;		esc_gt   = []byte("&gt;")
0000000000000000000000000000000000000000;;		esc_tab  = []byte("&#x9;")
0000000000000000000000000000000000000000;;		esc_nl   = []byte("&#xA;")
0000000000000000000000000000000000000000;;		esc_cr   = []byte("&#xD;")
0000000000000000000000000000000000000000;;		esc_fffd = []byte("\uFFFD") // Unicode replacement character
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapeText writes to w the properly escaped XML equivalent
0000000000000000000000000000000000000000;;	// of the plain text data s.
0000000000000000000000000000000000000000;;	func EscapeText(w io.Writer, s []byte) error {
0000000000000000000000000000000000000000;;		var esc []byte
0000000000000000000000000000000000000000;;		last := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); {
0000000000000000000000000000000000000000;;			r, width := utf8.DecodeRune(s[i:])
0000000000000000000000000000000000000000;;			i += width
0000000000000000000000000000000000000000;;			switch r {
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				esc = esc_quot
0000000000000000000000000000000000000000;;			case '\'':
0000000000000000000000000000000000000000;;				esc = esc_apos
0000000000000000000000000000000000000000;;			case '&':
0000000000000000000000000000000000000000;;				esc = esc_amp
0000000000000000000000000000000000000000;;			case '<':
0000000000000000000000000000000000000000;;				esc = esc_lt
0000000000000000000000000000000000000000;;			case '>':
0000000000000000000000000000000000000000;;				esc = esc_gt
0000000000000000000000000000000000000000;;			case '\t':
0000000000000000000000000000000000000000;;				esc = esc_tab
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				esc = esc_nl
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				esc = esc_cr
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if !isInCharacterRange(r) || (r == 0xFFFD && width == 1) {
0000000000000000000000000000000000000000;;					esc = esc_fffd
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := w.Write(s[last : i-width]); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err := w.Write(esc); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			last = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.Write(s[last:]); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EscapeString writes to p the properly escaped XML equivalent
0000000000000000000000000000000000000000;;	// of the plain text data s.
0000000000000000000000000000000000000000;;	func (p *printer) EscapeString(s string) {
0000000000000000000000000000000000000000;;		var esc []byte
0000000000000000000000000000000000000000;;		last := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); {
0000000000000000000000000000000000000000;;			r, width := utf8.DecodeRuneInString(s[i:])
0000000000000000000000000000000000000000;;			i += width
0000000000000000000000000000000000000000;;			switch r {
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				esc = esc_quot
0000000000000000000000000000000000000000;;			case '\'':
0000000000000000000000000000000000000000;;				esc = esc_apos
0000000000000000000000000000000000000000;;			case '&':
0000000000000000000000000000000000000000;;				esc = esc_amp
0000000000000000000000000000000000000000;;			case '<':
0000000000000000000000000000000000000000;;				esc = esc_lt
0000000000000000000000000000000000000000;;			case '>':
0000000000000000000000000000000000000000;;				esc = esc_gt
0000000000000000000000000000000000000000;;			case '\t':
0000000000000000000000000000000000000000;;				esc = esc_tab
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				esc = esc_nl
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				esc = esc_cr
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if !isInCharacterRange(r) || (r == 0xFFFD && width == 1) {
0000000000000000000000000000000000000000;;					esc = esc_fffd
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.WriteString(s[last : i-width])
0000000000000000000000000000000000000000;;			p.Write(esc)
0000000000000000000000000000000000000000;;			last = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.WriteString(s[last:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Escape is like EscapeText but omits the error return value.
0000000000000000000000000000000000000000;;	// It is provided for backwards compatibility with Go 1.0.
0000000000000000000000000000000000000000;;	// Code targeting Go 1.1 or later should use EscapeText.
0000000000000000000000000000000000000000;;	func Escape(w io.Writer, s []byte) {
0000000000000000000000000000000000000000;;		EscapeText(w, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// procInstEncoding parses the `encoding="..."` or `encoding='...'`
0000000000000000000000000000000000000000;;	// value out of the provided string, returning "" if not found.
0000000000000000000000000000000000000000;;	func procInstEncoding(s string) string {
0000000000000000000000000000000000000000;;		// TODO: this parsing is somewhat lame and not exact.
0000000000000000000000000000000000000000;;		// It works for all actual cases, though.
0000000000000000000000000000000000000000;;		idx := strings.Index(s, "encoding=")
0000000000000000000000000000000000000000;;		if idx == -1 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := s[idx+len("encoding="):]
0000000000000000000000000000000000000000;;		if v == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v[0] != '\'' && v[0] != '"' {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idx = strings.IndexRune(v[1:], rune(v[0]))
0000000000000000000000000000000000000000;;		if idx == -1 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v[1 : idx+1]
0000000000000000000000000000000000000000;;	}
