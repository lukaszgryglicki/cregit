0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/typeinfo.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/typeinfo.go][vendor/github.com/vmware/govmomi/vim25/xml/typeinfo.go];	
0000000000000000000000000000000000000000;;	package xml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeInfo holds details for the xml representation of a type.
0000000000000000000000000000000000000000;;	type typeInfo struct {
0000000000000000000000000000000000000000;;		xmlname *fieldInfo
0000000000000000000000000000000000000000;;		fields  []fieldInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fieldInfo holds details for the xml representation of a single field.
0000000000000000000000000000000000000000;;	type fieldInfo struct {
0000000000000000000000000000000000000000;;		idx     []int
0000000000000000000000000000000000000000;;		name    string
0000000000000000000000000000000000000000;;		xmlns   string
0000000000000000000000000000000000000000;;		flags   fieldFlags
0000000000000000000000000000000000000000;;		parents []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fieldFlags int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		fElement fieldFlags = 1 << iota
0000000000000000000000000000000000000000;;		fAttr
0000000000000000000000000000000000000000;;		fCharData
0000000000000000000000000000000000000000;;		fInnerXml
0000000000000000000000000000000000000000;;		fComment
0000000000000000000000000000000000000000;;		fAny
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fOmitEmpty
0000000000000000000000000000000000000000;;		fTypeAttr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fMode = fElement | fAttr | fCharData | fInnerXml | fComment | fAny
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var tinfoMap = make(map[reflect.Type]*typeInfo)
0000000000000000000000000000000000000000;;	var tinfoLock sync.RWMutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nameType = reflect.TypeOf(Name{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getTypeInfo returns the typeInfo structure with details necessary
0000000000000000000000000000000000000000;;	// for marshalling and unmarshalling typ.
0000000000000000000000000000000000000000;;	func getTypeInfo(typ reflect.Type) (*typeInfo, error) {
0000000000000000000000000000000000000000;;		tinfoLock.RLock()
0000000000000000000000000000000000000000;;		tinfo, ok := tinfoMap[typ]
0000000000000000000000000000000000000000;;		tinfoLock.RUnlock()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return tinfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tinfo = &typeInfo{}
0000000000000000000000000000000000000000;;		if typ.Kind() == reflect.Struct && typ != nameType {
0000000000000000000000000000000000000000;;			n := typ.NumField()
0000000000000000000000000000000000000000;;			for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;				f := typ.Field(i)
0000000000000000000000000000000000000000;;				if f.PkgPath != "" || f.Tag.Get("xml") == "-" {
0000000000000000000000000000000000000000;;					continue // Private field
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// For embedded structs, embed its fields.
0000000000000000000000000000000000000000;;				if f.Anonymous {
0000000000000000000000000000000000000000;;					t := f.Type
0000000000000000000000000000000000000000;;					if t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						t = t.Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if t.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;						inner, err := getTypeInfo(t)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if tinfo.xmlname == nil {
0000000000000000000000000000000000000000;;							tinfo.xmlname = inner.xmlname
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for _, finfo := range inner.fields {
0000000000000000000000000000000000000000;;							finfo.idx = append([]int{i}, finfo.idx...)
0000000000000000000000000000000000000000;;							if err := addFieldInfo(typ, tinfo, &finfo); err != nil {
0000000000000000000000000000000000000000;;								return nil, err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				finfo, err := structFieldInfo(typ, &f)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if f.Name == "XMLName" {
0000000000000000000000000000000000000000;;					tinfo.xmlname = finfo
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Add the field if it doesn't conflict with other fields.
0000000000000000000000000000000000000000;;				if err := addFieldInfo(typ, tinfo, finfo); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tinfoLock.Lock()
0000000000000000000000000000000000000000;;		tinfoMap[typ] = tinfo
0000000000000000000000000000000000000000;;		tinfoLock.Unlock()
0000000000000000000000000000000000000000;;		return tinfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// structFieldInfo builds and returns a fieldInfo for f.
0000000000000000000000000000000000000000;;	func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, error) {
0000000000000000000000000000000000000000;;		finfo := &fieldInfo{idx: f.Index}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split the tag from the xml namespace if necessary.
0000000000000000000000000000000000000000;;		tag := f.Tag.Get("xml")
0000000000000000000000000000000000000000;;		if i := strings.Index(tag, " "); i >= 0 {
0000000000000000000000000000000000000000;;			finfo.xmlns, tag = tag[:i], tag[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse flags.
0000000000000000000000000000000000000000;;		tokens := strings.Split(tag, ",")
0000000000000000000000000000000000000000;;		if len(tokens) == 1 {
0000000000000000000000000000000000000000;;			finfo.flags = fElement
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tag = tokens[0]
0000000000000000000000000000000000000000;;			for _, flag := range tokens[1:] {
0000000000000000000000000000000000000000;;				switch flag {
0000000000000000000000000000000000000000;;				case "attr":
0000000000000000000000000000000000000000;;					finfo.flags |= fAttr
0000000000000000000000000000000000000000;;				case "chardata":
0000000000000000000000000000000000000000;;					finfo.flags |= fCharData
0000000000000000000000000000000000000000;;				case "innerxml":
0000000000000000000000000000000000000000;;					finfo.flags |= fInnerXml
0000000000000000000000000000000000000000;;				case "comment":
0000000000000000000000000000000000000000;;					finfo.flags |= fComment
0000000000000000000000000000000000000000;;				case "any":
0000000000000000000000000000000000000000;;					finfo.flags |= fAny
0000000000000000000000000000000000000000;;				case "omitempty":
0000000000000000000000000000000000000000;;					finfo.flags |= fOmitEmpty
0000000000000000000000000000000000000000;;				case "typeattr":
0000000000000000000000000000000000000000;;					finfo.flags |= fTypeAttr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Validate the flags used.
0000000000000000000000000000000000000000;;			valid := true
0000000000000000000000000000000000000000;;			switch mode := finfo.flags & fMode; mode {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				finfo.flags |= fElement
0000000000000000000000000000000000000000;;			case fAttr, fCharData, fInnerXml, fComment, fAny:
0000000000000000000000000000000000000000;;				if f.Name == "XMLName" || tag != "" && mode != fAttr {
0000000000000000000000000000000000000000;;					valid = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// This will also catch multiple modes in a single field.
0000000000000000000000000000000000000000;;				valid = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if finfo.flags&fMode == fAny {
0000000000000000000000000000000000000000;;				finfo.flags |= fElement
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if finfo.flags&fOmitEmpty != 0 && finfo.flags&(fElement|fAttr) == 0 {
0000000000000000000000000000000000000000;;				valid = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !valid {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("xml: invalid tag in field %s of type %s: %q",
0000000000000000000000000000000000000000;;					f.Name, typ, f.Tag.Get("xml"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use of xmlns without a name is not allowed.
0000000000000000000000000000000000000000;;		if finfo.xmlns != "" && tag == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("xml: namespace without name in field %s of type %s: %q",
0000000000000000000000000000000000000000;;				f.Name, typ, f.Tag.Get("xml"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.Name == "XMLName" {
0000000000000000000000000000000000000000;;			// The XMLName field records the XML element name. Don't
0000000000000000000000000000000000000000;;			// process it as usual because its name should default to
0000000000000000000000000000000000000000;;			// empty rather than to the field name.
0000000000000000000000000000000000000000;;			finfo.name = tag
0000000000000000000000000000000000000000;;			return finfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tag == "" {
0000000000000000000000000000000000000000;;			// If the name part of the tag is completely empty, get
0000000000000000000000000000000000000000;;			// default from XMLName of underlying struct if feasible,
0000000000000000000000000000000000000000;;			// or field name otherwise.
0000000000000000000000000000000000000000;;			if xmlname := lookupXMLName(f.Type); xmlname != nil {
0000000000000000000000000000000000000000;;				finfo.xmlns, finfo.name = xmlname.xmlns, xmlname.name
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				finfo.name = f.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return finfo, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prepare field name and parents.
0000000000000000000000000000000000000000;;		parents := strings.Split(tag, ">")
0000000000000000000000000000000000000000;;		if parents[0] == "" {
0000000000000000000000000000000000000000;;			parents[0] = f.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parents[len(parents)-1] == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("xml: trailing '>' in field %s of type %s", f.Name, typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		finfo.name = parents[len(parents)-1]
0000000000000000000000000000000000000000;;		if len(parents) > 1 {
0000000000000000000000000000000000000000;;			if (finfo.flags & fElement) == 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("xml: %s chain not valid with %s flag", tag, strings.Join(tokens[1:], ","))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			finfo.parents = parents[:len(parents)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the field type has an XMLName field, the names must match
0000000000000000000000000000000000000000;;		// so that the behavior of both marshalling and unmarshalling
0000000000000000000000000000000000000000;;		// is straightforward and unambiguous.
0000000000000000000000000000000000000000;;		if finfo.flags&fElement != 0 {
0000000000000000000000000000000000000000;;			ftyp := f.Type
0000000000000000000000000000000000000000;;			xmlname := lookupXMLName(ftyp)
0000000000000000000000000000000000000000;;			if xmlname != nil && xmlname.name != finfo.name {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("xml: name %q in tag of %s.%s conflicts with name %q in %s.XMLName",
0000000000000000000000000000000000000000;;					finfo.name, typ, f.Name, xmlname.name, ftyp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return finfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// lookupXMLName returns the fieldInfo for typ's XMLName field
0000000000000000000000000000000000000000;;	// in case it exists and has a valid xml field tag, otherwise
0000000000000000000000000000000000000000;;	// it returns nil.
0000000000000000000000000000000000000000;;	func lookupXMLName(typ reflect.Type) (xmlname *fieldInfo) {
0000000000000000000000000000000000000000;;		for typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			typ = typ.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if typ.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, n := 0, typ.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;			f := typ.Field(i)
0000000000000000000000000000000000000000;;			if f.Name != "XMLName" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			finfo, err := structFieldInfo(typ, &f)
0000000000000000000000000000000000000000;;			if finfo.name != "" && err == nil {
0000000000000000000000000000000000000000;;				return finfo
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Also consider errors as a non-existent field tag
0000000000000000000000000000000000000000;;			// and let getTypeInfo itself report the error.
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func min(a, b int) int {
0000000000000000000000000000000000000000;;		if a <= b {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addFieldInfo adds finfo to tinfo.fields if there are no
0000000000000000000000000000000000000000;;	// conflicts, or if conflicts arise from previous fields that were
0000000000000000000000000000000000000000;;	// obtained from deeper embedded structures than finfo. In the latter
0000000000000000000000000000000000000000;;	// case, the conflicting entries are dropped.
0000000000000000000000000000000000000000;;	// A conflict occurs when the path (parent + name) to a field is
0000000000000000000000000000000000000000;;	// itself a prefix of another path, or when two paths match exactly.
0000000000000000000000000000000000000000;;	// It is okay for field paths to share a common, shorter prefix.
0000000000000000000000000000000000000000;;	func addFieldInfo(typ reflect.Type, tinfo *typeInfo, newf *fieldInfo) error {
0000000000000000000000000000000000000000;;		var conflicts []int
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		// First, figure all conflicts. Most working code will have none.
0000000000000000000000000000000000000000;;		for i := range tinfo.fields {
0000000000000000000000000000000000000000;;			oldf := &tinfo.fields[i]
0000000000000000000000000000000000000000;;			if oldf.flags&fMode != newf.flags&fMode {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if oldf.xmlns != "" && newf.xmlns != "" && oldf.xmlns != newf.xmlns {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			minl := min(len(newf.parents), len(oldf.parents))
0000000000000000000000000000000000000000;;			for p := 0; p < minl; p++ {
0000000000000000000000000000000000000000;;				if oldf.parents[p] != newf.parents[p] {
0000000000000000000000000000000000000000;;					continue Loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(oldf.parents) > len(newf.parents) {
0000000000000000000000000000000000000000;;				if oldf.parents[len(newf.parents)] == newf.name {
0000000000000000000000000000000000000000;;					conflicts = append(conflicts, i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(oldf.parents) < len(newf.parents) {
0000000000000000000000000000000000000000;;				if newf.parents[len(oldf.parents)] == oldf.name {
0000000000000000000000000000000000000000;;					conflicts = append(conflicts, i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if newf.name == oldf.name {
0000000000000000000000000000000000000000;;					conflicts = append(conflicts, i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Without conflicts, add the new field and return.
0000000000000000000000000000000000000000;;		if conflicts == nil {
0000000000000000000000000000000000000000;;			tinfo.fields = append(tinfo.fields, *newf)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If any conflict is shallower, ignore the new field.
0000000000000000000000000000000000000000;;		// This matches the Go field resolution on embedding.
0000000000000000000000000000000000000000;;		for _, i := range conflicts {
0000000000000000000000000000000000000000;;			if len(tinfo.fields[i].idx) < len(newf.idx) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, if any of them is at the same depth level, it's an error.
0000000000000000000000000000000000000000;;		for _, i := range conflicts {
0000000000000000000000000000000000000000;;			oldf := &tinfo.fields[i]
0000000000000000000000000000000000000000;;			if len(oldf.idx) == len(newf.idx) {
0000000000000000000000000000000000000000;;				f1 := typ.FieldByIndex(oldf.idx)
0000000000000000000000000000000000000000;;				f2 := typ.FieldByIndex(newf.idx)
0000000000000000000000000000000000000000;;				return &TagPathError{typ, f1.Name, f1.Tag.Get("xml"), f2.Name, f2.Tag.Get("xml")}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise, the new field is shallower, and thus takes precedence,
0000000000000000000000000000000000000000;;		// so drop the conflicting fields from tinfo and append the new one.
0000000000000000000000000000000000000000;;		for c := len(conflicts) - 1; c >= 0; c-- {
0000000000000000000000000000000000000000;;			i := conflicts[c]
0000000000000000000000000000000000000000;;			copy(tinfo.fields[i:], tinfo.fields[i+1:])
0000000000000000000000000000000000000000;;			tinfo.fields = tinfo.fields[:len(tinfo.fields)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tinfo.fields = append(tinfo.fields, *newf)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A TagPathError represents an error in the unmarshalling process
0000000000000000000000000000000000000000;;	// caused by the use of field tags with conflicting paths.
0000000000000000000000000000000000000000;;	type TagPathError struct {
0000000000000000000000000000000000000000;;		Struct       reflect.Type
0000000000000000000000000000000000000000;;		Field1, Tag1 string
0000000000000000000000000000000000000000;;		Field2, Tag2 string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *TagPathError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s field %q with tag %q conflicts with field %q with tag %q", e.Struct, e.Field1, e.Tag1, e.Field2, e.Tag2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// value returns v's field value corresponding to finfo.
0000000000000000000000000000000000000000;;	// It's equivalent to v.FieldByIndex(finfo.idx), but initializes
0000000000000000000000000000000000000000;;	// and dereferences pointers as necessary.
0000000000000000000000000000000000000000;;	func (finfo *fieldInfo) value(v reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		for i, x := range finfo.idx {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				t := v.Type()
0000000000000000000000000000000000000000;;				if t.Kind() == reflect.Ptr && t.Elem().Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;					if v.IsNil() {
0000000000000000000000000000000000000000;;						v.Set(reflect.New(v.Type().Elem()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v = v.Elem()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = v.Field(x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
