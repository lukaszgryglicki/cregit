0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/marshal.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/marshal.go][vendor/github.com/vmware/govmomi/vim25/xml/marshal.go];	
0000000000000000000000000000000000000000;;	package xml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// A generic XML header suitable for use with the output of Marshal.
0000000000000000000000000000000000000000;;		// This is not automatically added to any output of this package,
0000000000000000000000000000000000000000;;		// it is provided as a convenience.
0000000000000000000000000000000000000000;;		Header = `<?xml version="1.0" encoding="UTF-8"?>` + "\n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal returns the XML encoding of v.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Marshal handles an array or slice by marshalling each of the elements.
0000000000000000000000000000000000000000;;	// Marshal handles a pointer by marshalling the value it points at or, if the
0000000000000000000000000000000000000000;;	// pointer is nil, by writing nothing.  Marshal handles an interface value by
0000000000000000000000000000000000000000;;	// marshalling the value it contains or, if the interface value is nil, by
0000000000000000000000000000000000000000;;	// writing nothing.  Marshal handles all other data by writing one or more XML
0000000000000000000000000000000000000000;;	// elements containing the data.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The name for the XML elements is taken from, in order of preference:
0000000000000000000000000000000000000000;;	//     - the tag on the XMLName field, if the data is a struct
0000000000000000000000000000000000000000;;	//     - the value of the XMLName field of type xml.Name
0000000000000000000000000000000000000000;;	//     - the tag of the struct field used to obtain the data
0000000000000000000000000000000000000000;;	//     - the name of the struct field used to obtain the data
0000000000000000000000000000000000000000;;	//     - the name of the marshalled type
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The XML element for a struct contains marshalled elements for each of the
0000000000000000000000000000000000000000;;	// exported fields of the struct, with these exceptions:
0000000000000000000000000000000000000000;;	//     - the XMLName field, described above, is omitted.
0000000000000000000000000000000000000000;;	//     - a field with tag "-" is omitted.
0000000000000000000000000000000000000000;;	//     - a field with tag "name,attr" becomes an attribute with
0000000000000000000000000000000000000000;;	//       the given name in the XML element.
0000000000000000000000000000000000000000;;	//     - a field with tag ",attr" becomes an attribute with the
0000000000000000000000000000000000000000;;	//       field name in the XML element.
0000000000000000000000000000000000000000;;	//     - a field with tag ",chardata" is written as character data,
0000000000000000000000000000000000000000;;	//       not as an XML element.
0000000000000000000000000000000000000000;;	//     - a field with tag ",innerxml" is written verbatim, not subject
0000000000000000000000000000000000000000;;	//       to the usual marshalling procedure.
0000000000000000000000000000000000000000;;	//     - a field with tag ",comment" is written as an XML comment, not
0000000000000000000000000000000000000000;;	//       subject to the usual marshalling procedure. It must not contain
0000000000000000000000000000000000000000;;	//       the "--" string within it.
0000000000000000000000000000000000000000;;	//     - a field with a tag including the "omitempty" option is omitted
0000000000000000000000000000000000000000;;	//       if the field value is empty. The empty values are false, 0, any
0000000000000000000000000000000000000000;;	//       nil pointer or interface value, and any array, slice, map, or
0000000000000000000000000000000000000000;;	//       string of length zero.
0000000000000000000000000000000000000000;;	//     - an anonymous struct field is handled as if the fields of its
0000000000000000000000000000000000000000;;	//       value were part of the outer struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a field uses a tag "a>b>c", then the element c will be nested inside
0000000000000000000000000000000000000000;;	// parent elements a and b.  Fields that appear next to each other that name
0000000000000000000000000000000000000000;;	// the same parent will be enclosed in one XML element.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See MarshalIndent for an example.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Marshal will return an error if asked to marshal a channel, function, or map.
0000000000000000000000000000000000000000;;	func Marshal(v interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		if err := NewEncoder(&b).Encode(v); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshaler is the interface implemented by objects that can marshal
0000000000000000000000000000000000000000;;	// themselves into valid XML elements.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// MarshalXML encodes the receiver as zero or more XML elements.
0000000000000000000000000000000000000000;;	// By convention, arrays or slices are typically encoded as a sequence
0000000000000000000000000000000000000000;;	// of elements, one per entry.
0000000000000000000000000000000000000000;;	// Using start as the element tag is not required, but doing so
0000000000000000000000000000000000000000;;	// will enable Unmarshal to match the XML elements to the correct
0000000000000000000000000000000000000000;;	// struct field.
0000000000000000000000000000000000000000;;	// One common implementation strategy is to construct a separate
0000000000000000000000000000000000000000;;	// value with a layout corresponding to the desired XML and then
0000000000000000000000000000000000000000;;	// to encode it using e.EncodeElement.
0000000000000000000000000000000000000000;;	// Another common strategy is to use repeated calls to e.EncodeToken
0000000000000000000000000000000000000000;;	// to generate the XML output one token at a time.
0000000000000000000000000000000000000000;;	// The sequence of encoded tokens must make up zero or more valid
0000000000000000000000000000000000000000;;	// XML elements.
0000000000000000000000000000000000000000;;	type Marshaler interface {
0000000000000000000000000000000000000000;;		MarshalXML(e *Encoder, start StartElement) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalerAttr is the interface implemented by objects that can marshal
0000000000000000000000000000000000000000;;	// themselves into valid XML attributes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// MarshalXMLAttr returns an XML attribute with the encoded value of the receiver.
0000000000000000000000000000000000000000;;	// Using name as the attribute name is not required, but doing so
0000000000000000000000000000000000000000;;	// will enable Unmarshal to match the attribute to the correct
0000000000000000000000000000000000000000;;	// struct field.
0000000000000000000000000000000000000000;;	// If MarshalXMLAttr returns the zero attribute Attr{}, no attribute
0000000000000000000000000000000000000000;;	// will be generated in the output.
0000000000000000000000000000000000000000;;	// MarshalXMLAttr is used only for struct fields with the
0000000000000000000000000000000000000000;;	// "attr" option in the field tag.
0000000000000000000000000000000000000000;;	type MarshalerAttr interface {
0000000000000000000000000000000000000000;;		MarshalXMLAttr(name Name) (Attr, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalIndent works like Marshal, but each XML element begins on a new
0000000000000000000000000000000000000000;;	// indented line that starts with prefix and is followed by one or more
0000000000000000000000000000000000000000;;	// copies of indent according to the nesting depth.
0000000000000000000000000000000000000000;;	func MarshalIndent(v interface{}, prefix, indent string) ([]byte, error) {
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		enc := NewEncoder(&b)
0000000000000000000000000000000000000000;;		enc.Indent(prefix, indent)
0000000000000000000000000000000000000000;;		if err := enc.Encode(v); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Encoder writes XML data to an output stream.
0000000000000000000000000000000000000000;;	type Encoder struct {
0000000000000000000000000000000000000000;;		p printer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder returns a new encoder that writes to w.
0000000000000000000000000000000000000000;;	func NewEncoder(w io.Writer) *Encoder {
0000000000000000000000000000000000000000;;		e := &Encoder{printer{Writer: bufio.NewWriter(w)}}
0000000000000000000000000000000000000000;;		e.p.encoder = e
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Indent sets the encoder to generate XML in which each element
0000000000000000000000000000000000000000;;	// begins on a new indented line that starts with prefix and is followed by
0000000000000000000000000000000000000000;;	// one or more copies of indent according to the nesting depth.
0000000000000000000000000000000000000000;;	func (enc *Encoder) Indent(prefix, indent string) {
0000000000000000000000000000000000000000;;		enc.p.prefix = prefix
0000000000000000000000000000000000000000;;		enc.p.indent = indent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode writes the XML encoding of v to the stream.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the documentation for Marshal for details about the conversion
0000000000000000000000000000000000000000;;	// of Go values to XML.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Encode calls Flush before returning.
0000000000000000000000000000000000000000;;	func (enc *Encoder) Encode(v interface{}) error {
0000000000000000000000000000000000000000;;		err := enc.p.marshalValue(reflect.ValueOf(v), nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return enc.p.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeElement writes the XML encoding of v to the stream,
0000000000000000000000000000000000000000;;	// using start as the outermost tag in the encoding.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the documentation for Marshal for details about the conversion
0000000000000000000000000000000000000000;;	// of Go values to XML.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// EncodeElement calls Flush before returning.
0000000000000000000000000000000000000000;;	func (enc *Encoder) EncodeElement(v interface{}, start StartElement) error {
0000000000000000000000000000000000000000;;		err := enc.p.marshalValue(reflect.ValueOf(v), nil, &start)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return enc.p.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		endComment   = []byte("-->")
0000000000000000000000000000000000000000;;		endProcInst  = []byte("?>")
0000000000000000000000000000000000000000;;		endDirective = []byte(">")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeToken writes the given XML token to the stream.
0000000000000000000000000000000000000000;;	// It returns an error if StartElement and EndElement tokens are not properly matched.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// EncodeToken does not call Flush, because usually it is part of a larger operation
0000000000000000000000000000000000000000;;	// such as Encode or EncodeElement (or a custom Marshaler's MarshalXML invoked
0000000000000000000000000000000000000000;;	// during those), and those will call Flush when finished.
0000000000000000000000000000000000000000;;	// Callers that create an Encoder and then invoke EncodeToken directly, without
0000000000000000000000000000000000000000;;	// using Encode or EncodeElement, need to call Flush when finished to ensure
0000000000000000000000000000000000000000;;	// that the XML is written to the underlying writer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// EncodeToken allows writing a ProcInst with Target set to "xml" only as the first token
0000000000000000000000000000000000000000;;	// in the stream.
0000000000000000000000000000000000000000;;	func (enc *Encoder) EncodeToken(t Token) error {
0000000000000000000000000000000000000000;;		p := &enc.p
0000000000000000000000000000000000000000;;		switch t := t.(type) {
0000000000000000000000000000000000000000;;		case StartElement:
0000000000000000000000000000000000000000;;			if err := p.writeStart(&t); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EndElement:
0000000000000000000000000000000000000000;;			if err := p.writeEnd(t.Name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CharData:
0000000000000000000000000000000000000000;;			EscapeText(p, t)
0000000000000000000000000000000000000000;;		case Comment:
0000000000000000000000000000000000000000;;			if bytes.Contains(t, endComment) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("xml: EncodeToken of Comment containing --> marker")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.WriteString("<!--")
0000000000000000000000000000000000000000;;			p.Write(t)
0000000000000000000000000000000000000000;;			p.WriteString("-->")
0000000000000000000000000000000000000000;;			return p.cachedWriteError()
0000000000000000000000000000000000000000;;		case ProcInst:
0000000000000000000000000000000000000000;;			// First token to be encoded which is also a ProcInst with target of xml
0000000000000000000000000000000000000000;;			// is the xml declaration.  The only ProcInst where target of xml is allowed.
0000000000000000000000000000000000000000;;			if t.Target == "xml" && p.Buffered() != 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("xml: EncodeToken of ProcInst xml target only valid for xml declaration, first token encoded")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !isNameString(t.Target) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("xml: EncodeToken of ProcInst with invalid Target")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bytes.Contains(t.Inst, endProcInst) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("xml: EncodeToken of ProcInst containing ?> marker")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.WriteString("<?")
0000000000000000000000000000000000000000;;			p.WriteString(t.Target)
0000000000000000000000000000000000000000;;			if len(t.Inst) > 0 {
0000000000000000000000000000000000000000;;				p.WriteByte(' ')
0000000000000000000000000000000000000000;;				p.Write(t.Inst)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.WriteString("?>")
0000000000000000000000000000000000000000;;		case Directive:
0000000000000000000000000000000000000000;;			if bytes.Contains(t, endDirective) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("xml: EncodeToken of Directive containing > marker")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.WriteString("<!")
0000000000000000000000000000000000000000;;			p.Write(t)
0000000000000000000000000000000000000000;;			p.WriteString(">")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.cachedWriteError()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flush flushes any buffered XML to the underlying writer.
0000000000000000000000000000000000000000;;	// See the EncodeToken documentation for details about when it is necessary.
0000000000000000000000000000000000000000;;	func (enc *Encoder) Flush() error {
0000000000000000000000000000000000000000;;		return enc.p.Flush()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type printer struct {
0000000000000000000000000000000000000000;;		*bufio.Writer
0000000000000000000000000000000000000000;;		encoder    *Encoder
0000000000000000000000000000000000000000;;		seq        int
0000000000000000000000000000000000000000;;		indent     string
0000000000000000000000000000000000000000;;		prefix     string
0000000000000000000000000000000000000000;;		depth      int
0000000000000000000000000000000000000000;;		indentedIn bool
0000000000000000000000000000000000000000;;		putNewline bool
0000000000000000000000000000000000000000;;		attrNS     map[string]string // map prefix -> name space
0000000000000000000000000000000000000000;;		attrPrefix map[string]string // map name space -> prefix
0000000000000000000000000000000000000000;;		prefixes   []string
0000000000000000000000000000000000000000;;		tags       []Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createAttrPrefix finds the name space prefix attribute to use for the given name space,
0000000000000000000000000000000000000000;;	// defining a new prefix if necessary. It returns the prefix.
0000000000000000000000000000000000000000;;	func (p *printer) createAttrPrefix(url string) string {
0000000000000000000000000000000000000000;;		if prefix := p.attrPrefix[url]; prefix != "" {
0000000000000000000000000000000000000000;;			return prefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The "http://www.w3.org/XML/1998/namespace" name space is predefined as "xml"
0000000000000000000000000000000000000000;;		// and must be referred to that way.
0000000000000000000000000000000000000000;;		// (The "http://www.w3.org/2000/xmlns/" name space is also predefined as "xmlns",
0000000000000000000000000000000000000000;;		// but users should not be trying to use that one directly - that's our job.)
0000000000000000000000000000000000000000;;		if url == xmlURL {
0000000000000000000000000000000000000000;;			return "xml"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Need to define a new name space.
0000000000000000000000000000000000000000;;		if p.attrPrefix == nil {
0000000000000000000000000000000000000000;;			p.attrPrefix = make(map[string]string)
0000000000000000000000000000000000000000;;			p.attrNS = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pick a name. We try to use the final element of the path
0000000000000000000000000000000000000000;;		// but fall back to _.
0000000000000000000000000000000000000000;;		prefix := strings.TrimRight(url, "/")
0000000000000000000000000000000000000000;;		if i := strings.LastIndex(prefix, "/"); i >= 0 {
0000000000000000000000000000000000000000;;			prefix = prefix[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if prefix == "" || !isName([]byte(prefix)) || strings.Contains(prefix, ":") {
0000000000000000000000000000000000000000;;			prefix = "_"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(prefix, "xml") {
0000000000000000000000000000000000000000;;			// xmlanything is reserved.
0000000000000000000000000000000000000000;;			prefix = "_" + prefix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.attrNS[prefix] != "" {
0000000000000000000000000000000000000000;;			// Name is taken. Find a better one.
0000000000000000000000000000000000000000;;			for p.seq++; ; p.seq++ {
0000000000000000000000000000000000000000;;				if id := prefix + "_" + strconv.Itoa(p.seq); p.attrNS[id] == "" {
0000000000000000000000000000000000000000;;					prefix = id
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.attrPrefix[url] = prefix
0000000000000000000000000000000000000000;;		p.attrNS[prefix] = url
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.WriteString(`xmlns:`)
0000000000000000000000000000000000000000;;		p.WriteString(prefix)
0000000000000000000000000000000000000000;;		p.WriteString(`="`)
0000000000000000000000000000000000000000;;		EscapeText(p, []byte(url))
0000000000000000000000000000000000000000;;		p.WriteString(`" `)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.prefixes = append(p.prefixes, prefix)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return prefix
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deleteAttrPrefix removes an attribute name space prefix.
0000000000000000000000000000000000000000;;	func (p *printer) deleteAttrPrefix(prefix string) {
0000000000000000000000000000000000000000;;		delete(p.attrPrefix, p.attrNS[prefix])
0000000000000000000000000000000000000000;;		delete(p.attrNS, prefix)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *printer) markPrefix() {
0000000000000000000000000000000000000000;;		p.prefixes = append(p.prefixes, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *printer) popPrefix() {
0000000000000000000000000000000000000000;;		for len(p.prefixes) > 0 {
0000000000000000000000000000000000000000;;			prefix := p.prefixes[len(p.prefixes)-1]
0000000000000000000000000000000000000000;;			p.prefixes = p.prefixes[:len(p.prefixes)-1]
0000000000000000000000000000000000000000;;			if prefix == "" {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.deleteAttrPrefix(prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		marshalerType     = reflect.TypeOf((*Marshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		marshalerAttrType = reflect.TypeOf((*MarshalerAttr)(nil)).Elem()
0000000000000000000000000000000000000000;;		textMarshalerType = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// marshalValue writes one or more XML elements representing val.
0000000000000000000000000000000000000000;;	// If val was obtained from a struct field, finfo must have its details.
0000000000000000000000000000000000000000;;	func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo, startTemplate *StartElement) error {
0000000000000000000000000000000000000000;;		if startTemplate != nil && startTemplate.Name.Local == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("xml: EncodeElement of StartElement with missing name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !val.IsValid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if finfo != nil && finfo.flags&fOmitEmpty != 0 && isEmptyValue(val) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Drill into interfaces and pointers.
0000000000000000000000000000000000000000;;		// This can turn into an infinite loop given a cyclic chain,
0000000000000000000000000000000000000000;;		// but it matches the Go 1 behavior.
0000000000000000000000000000000000000000;;		for val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if val.IsNil() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kind := val.Kind()
0000000000000000000000000000000000000000;;		typ := val.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for marshaler.
0000000000000000000000000000000000000000;;		if val.CanInterface() && typ.Implements(marshalerType) {
0000000000000000000000000000000000000000;;			return p.marshalInterface(val.Interface().(Marshaler), defaultStart(typ, finfo, startTemplate))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val.CanAddr() {
0000000000000000000000000000000000000000;;			pv := val.Addr()
0000000000000000000000000000000000000000;;			if pv.CanInterface() && pv.Type().Implements(marshalerType) {
0000000000000000000000000000000000000000;;				return p.marshalInterface(pv.Interface().(Marshaler), defaultStart(pv.Type(), finfo, startTemplate))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for text marshaler.
0000000000000000000000000000000000000000;;		if val.CanInterface() && typ.Implements(textMarshalerType) {
0000000000000000000000000000000000000000;;			return p.marshalTextInterface(val.Interface().(encoding.TextMarshaler), defaultStart(typ, finfo, startTemplate))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val.CanAddr() {
0000000000000000000000000000000000000000;;			pv := val.Addr()
0000000000000000000000000000000000000000;;			if pv.CanInterface() && pv.Type().Implements(textMarshalerType) {
0000000000000000000000000000000000000000;;				return p.marshalTextInterface(pv.Interface().(encoding.TextMarshaler), defaultStart(pv.Type(), finfo, startTemplate))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Slices and arrays iterate over the elements. They do not have an enclosing tag.
0000000000000000000000000000000000000000;;		if (kind == reflect.Slice || kind == reflect.Array) && typ.Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;			for i, n := 0, val.Len(); i < n; i++ {
0000000000000000000000000000000000000000;;				if err := p.marshalValue(val.Index(i), finfo, startTemplate); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tinfo, err := getTypeInfo(typ)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create start element.
0000000000000000000000000000000000000000;;		// Precedence for the XML element name is:
0000000000000000000000000000000000000000;;		// 0. startTemplate
0000000000000000000000000000000000000000;;		// 1. XMLName field in underlying struct;
0000000000000000000000000000000000000000;;		// 2. field name/tag in the struct field; and
0000000000000000000000000000000000000000;;		// 3. type name
0000000000000000000000000000000000000000;;		var start StartElement
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if startTemplate != nil {
0000000000000000000000000000000000000000;;			start.Name = startTemplate.Name
0000000000000000000000000000000000000000;;			start.Attr = append(start.Attr, startTemplate.Attr...)
0000000000000000000000000000000000000000;;		} else if tinfo.xmlname != nil {
0000000000000000000000000000000000000000;;			xmlname := tinfo.xmlname
0000000000000000000000000000000000000000;;			if xmlname.name != "" {
0000000000000000000000000000000000000000;;				start.Name.Space, start.Name.Local = xmlname.xmlns, xmlname.name
0000000000000000000000000000000000000000;;			} else if v, ok := xmlname.value(val).Interface().(Name); ok && v.Local != "" {
0000000000000000000000000000000000000000;;				start.Name = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start.Name.Local == "" && finfo != nil {
0000000000000000000000000000000000000000;;			start.Name.Space, start.Name.Local = finfo.xmlns, finfo.name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start.Name.Local == "" {
0000000000000000000000000000000000000000;;			name := typ.Name()
0000000000000000000000000000000000000000;;			if name == "" {
0000000000000000000000000000000000000000;;				return &UnsupportedTypeError{typ}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			start.Name.Local = name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add type attribute if necessary
0000000000000000000000000000000000000000;;		if finfo != nil && finfo.flags&fTypeAttr != 0 {
0000000000000000000000000000000000000000;;			start.Attr = append(start.Attr, Attr{xmlSchemaInstance, typeToString(typ)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attributes
0000000000000000000000000000000000000000;;		for i := range tinfo.fields {
0000000000000000000000000000000000000000;;			finfo := &tinfo.fields[i]
0000000000000000000000000000000000000000;;			if finfo.flags&fAttr == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fv := finfo.value(val)
0000000000000000000000000000000000000000;;			name := Name{Space: finfo.xmlns, Local: finfo.name}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if finfo.flags&fOmitEmpty != 0 && isEmptyValue(fv) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fv.Kind() == reflect.Interface && fv.IsNil() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fv.CanInterface() && fv.Type().Implements(marshalerAttrType) {
0000000000000000000000000000000000000000;;				attr, err := fv.Interface().(MarshalerAttr).MarshalXMLAttr(name)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if attr.Name.Local != "" {
0000000000000000000000000000000000000000;;					start.Attr = append(start.Attr, attr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fv.CanAddr() {
0000000000000000000000000000000000000000;;				pv := fv.Addr()
0000000000000000000000000000000000000000;;				if pv.CanInterface() && pv.Type().Implements(marshalerAttrType) {
0000000000000000000000000000000000000000;;					attr, err := pv.Interface().(MarshalerAttr).MarshalXMLAttr(name)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if attr.Name.Local != "" {
0000000000000000000000000000000000000000;;						start.Attr = append(start.Attr, attr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fv.CanInterface() && fv.Type().Implements(textMarshalerType) {
0000000000000000000000000000000000000000;;				text, err := fv.Interface().(encoding.TextMarshaler).MarshalText()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				start.Attr = append(start.Attr, Attr{name, string(text)})
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if fv.CanAddr() {
0000000000000000000000000000000000000000;;				pv := fv.Addr()
0000000000000000000000000000000000000000;;				if pv.CanInterface() && pv.Type().Implements(textMarshalerType) {
0000000000000000000000000000000000000000;;					text, err := pv.Interface().(encoding.TextMarshaler).MarshalText()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					start.Attr = append(start.Attr, Attr{name, string(text)})
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Dereference or skip nil pointer, interface values.
0000000000000000000000000000000000000000;;			switch fv.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Ptr, reflect.Interface:
0000000000000000000000000000000000000000;;				if fv.IsNil() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fv = fv.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s, b, err := p.marshalSimple(fv.Type(), fv)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b != nil {
0000000000000000000000000000000000000000;;				s = string(b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			start.Attr = append(start.Attr, Attr{name, s})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := p.writeStart(&start); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			err = p.marshalStruct(tinfo, val)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s, b, err1 := p.marshalSimple(typ, val)
0000000000000000000000000000000000000000;;			if err1 != nil {
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			} else if b != nil {
0000000000000000000000000000000000000000;;				EscapeText(p, b)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.EscapeString(s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := p.writeEnd(start.Name); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.cachedWriteError()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultStart returns the default start element to use,
0000000000000000000000000000000000000000;;	// given the reflect type, field info, and start template.
0000000000000000000000000000000000000000;;	func defaultStart(typ reflect.Type, finfo *fieldInfo, startTemplate *StartElement) StartElement {
0000000000000000000000000000000000000000;;		var start StartElement
0000000000000000000000000000000000000000;;		// Precedence for the XML element name is as above,
0000000000000000000000000000000000000000;;		// except that we do not look inside structs for the first field.
0000000000000000000000000000000000000000;;		if startTemplate != nil {
0000000000000000000000000000000000000000;;			start.Name = startTemplate.Name
0000000000000000000000000000000000000000;;			start.Attr = append(start.Attr, startTemplate.Attr...)
0000000000000000000000000000000000000000;;		} else if finfo != nil && finfo.name != "" {
0000000000000000000000000000000000000000;;			start.Name.Local = finfo.name
0000000000000000000000000000000000000000;;			start.Name.Space = finfo.xmlns
0000000000000000000000000000000000000000;;		} else if typ.Name() != "" {
0000000000000000000000000000000000000000;;			start.Name.Local = typ.Name()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Must be a pointer to a named type,
0000000000000000000000000000000000000000;;			// since it has the Marshaler methods.
0000000000000000000000000000000000000000;;			start.Name.Local = typ.Elem().Name()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add type attribute if necessary
0000000000000000000000000000000000000000;;		if finfo != nil && finfo.flags&fTypeAttr != 0 {
0000000000000000000000000000000000000000;;			start.Attr = append(start.Attr, Attr{xmlSchemaInstance, typeToString(typ)})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return start
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// marshalInterface marshals a Marshaler interface value.
0000000000000000000000000000000000000000;;	func (p *printer) marshalInterface(val Marshaler, start StartElement) error {
0000000000000000000000000000000000000000;;		// Push a marker onto the tag stack so that MarshalXML
0000000000000000000000000000000000000000;;		// cannot close the XML tags that it did not open.
0000000000000000000000000000000000000000;;		p.tags = append(p.tags, Name{})
0000000000000000000000000000000000000000;;		n := len(p.tags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := val.MarshalXML(p.encoder, start)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure MarshalXML closed all its tags. p.tags[n-1] is the mark.
0000000000000000000000000000000000000000;;		if len(p.tags) > n {
0000000000000000000000000000000000000000;;			return fmt.Errorf("xml: %s.MarshalXML wrote invalid XML: <%s> not closed", receiverType(val), p.tags[len(p.tags)-1].Local)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.tags = p.tags[:n-1]
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// marshalTextInterface marshals a TextMarshaler interface value.
0000000000000000000000000000000000000000;;	func (p *printer) marshalTextInterface(val encoding.TextMarshaler, start StartElement) error {
0000000000000000000000000000000000000000;;		if err := p.writeStart(&start); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		text, err := val.MarshalText()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		EscapeText(p, text)
0000000000000000000000000000000000000000;;		return p.writeEnd(start.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeStart writes the given start element.
0000000000000000000000000000000000000000;;	func (p *printer) writeStart(start *StartElement) error {
0000000000000000000000000000000000000000;;		if start.Name.Local == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("xml: start tag with no name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.tags = append(p.tags, start.Name)
0000000000000000000000000000000000000000;;		p.markPrefix()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.writeIndent(1)
0000000000000000000000000000000000000000;;		p.WriteByte('<')
0000000000000000000000000000000000000000;;		p.WriteString(start.Name.Local)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if start.Name.Space != "" {
0000000000000000000000000000000000000000;;			p.WriteString(` xmlns="`)
0000000000000000000000000000000000000000;;			p.EscapeString(start.Name.Space)
0000000000000000000000000000000000000000;;			p.WriteByte('"')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attributes
0000000000000000000000000000000000000000;;		for _, attr := range start.Attr {
0000000000000000000000000000000000000000;;			name := attr.Name
0000000000000000000000000000000000000000;;			if name.Local == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.WriteByte(' ')
0000000000000000000000000000000000000000;;			if name.Space != "" {
0000000000000000000000000000000000000000;;				p.WriteString(p.createAttrPrefix(name.Space))
0000000000000000000000000000000000000000;;				p.WriteByte(':')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.WriteString(name.Local)
0000000000000000000000000000000000000000;;			p.WriteString(`="`)
0000000000000000000000000000000000000000;;			p.EscapeString(attr.Value)
0000000000000000000000000000000000000000;;			p.WriteByte('"')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.WriteByte('>')
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *printer) writeEnd(name Name) error {
0000000000000000000000000000000000000000;;		if name.Local == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("xml: end tag with no name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.tags) == 0 || p.tags[len(p.tags)-1].Local == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("xml: end tag </%s> without start tag", name.Local)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if top := p.tags[len(p.tags)-1]; top != name {
0000000000000000000000000000000000000000;;			if top.Local != name.Local {
0000000000000000000000000000000000000000;;				return fmt.Errorf("xml: end tag </%s> does not match start tag <%s>", name.Local, top.Local)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("xml: end tag </%s> in namespace %s does not match start tag <%s> in namespace %s", name.Local, name.Space, top.Local, top.Space)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.tags = p.tags[:len(p.tags)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.writeIndent(-1)
0000000000000000000000000000000000000000;;		p.WriteByte('<')
0000000000000000000000000000000000000000;;		p.WriteByte('/')
0000000000000000000000000000000000000000;;		p.WriteString(name.Local)
0000000000000000000000000000000000000000;;		p.WriteByte('>')
0000000000000000000000000000000000000000;;		p.popPrefix()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *printer) marshalSimple(typ reflect.Type, val reflect.Value) (string, []byte, error) {
0000000000000000000000000000000000000000;;		switch val.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return strconv.FormatInt(val.Int(), 10), nil, nil
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return strconv.FormatUint(val.Uint(), 10), nil, nil
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return strconv.FormatFloat(val.Float(), 'g', -1, val.Type().Bits()), nil, nil
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return val.String(), nil, nil
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return strconv.FormatBool(val.Bool()), nil, nil
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			if typ.Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// [...]byte
0000000000000000000000000000000000000000;;			var bytes []byte
0000000000000000000000000000000000000000;;			if val.CanAddr() {
0000000000000000000000000000000000000000;;				bytes = val.Slice(0, val.Len()).Bytes()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				bytes = make([]byte, val.Len())
0000000000000000000000000000000000000000;;				reflect.Copy(reflect.ValueOf(bytes), val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", bytes, nil
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if typ.Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// []byte
0000000000000000000000000000000000000000;;			return "", val.Bytes(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", nil, &UnsupportedTypeError{typ}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ddBytes = []byte("--")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {
0000000000000000000000000000000000000000;;		s := parentStack{p: p}
0000000000000000000000000000000000000000;;		for i := range tinfo.fields {
0000000000000000000000000000000000000000;;			finfo := &tinfo.fields[i]
0000000000000000000000000000000000000000;;			if finfo.flags&fAttr != 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vf := finfo.value(val)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Dereference or skip nil pointer, interface values.
0000000000000000000000000000000000000000;;			switch vf.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Ptr, reflect.Interface:
0000000000000000000000000000000000000000;;				if !vf.IsNil() {
0000000000000000000000000000000000000000;;					vf = vf.Elem()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch finfo.flags & fMode {
0000000000000000000000000000000000000000;;			case fCharData:
0000000000000000000000000000000000000000;;				if vf.CanInterface() && vf.Type().Implements(textMarshalerType) {
0000000000000000000000000000000000000000;;					data, err := vf.Interface().(encoding.TextMarshaler).MarshalText()
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					Escape(p, data)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if vf.CanAddr() {
0000000000000000000000000000000000000000;;					pv := vf.Addr()
0000000000000000000000000000000000000000;;					if pv.CanInterface() && pv.Type().Implements(textMarshalerType) {
0000000000000000000000000000000000000000;;						data, err := pv.Interface().(encoding.TextMarshaler).MarshalText()
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						Escape(p, data)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var scratch [64]byte
0000000000000000000000000000000000000000;;				switch vf.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;					Escape(p, strconv.AppendInt(scratch[:0], vf.Int(), 10))
0000000000000000000000000000000000000000;;				case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;					Escape(p, strconv.AppendUint(scratch[:0], vf.Uint(), 10))
0000000000000000000000000000000000000000;;				case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;					Escape(p, strconv.AppendFloat(scratch[:0], vf.Float(), 'g', -1, vf.Type().Bits()))
0000000000000000000000000000000000000000;;				case reflect.Bool:
0000000000000000000000000000000000000000;;					Escape(p, strconv.AppendBool(scratch[:0], vf.Bool()))
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					if err := EscapeText(p, []byte(vf.String())); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Slice:
0000000000000000000000000000000000000000;;					if elem, ok := vf.Interface().([]byte); ok {
0000000000000000000000000000000000000000;;						if err := EscapeText(p, elem); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case fComment:
0000000000000000000000000000000000000000;;				k := vf.Kind()
0000000000000000000000000000000000000000;;				if !(k == reflect.String || k == reflect.Slice && vf.Type().Elem().Kind() == reflect.Uint8) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("xml: bad type for comment field of %s", val.Type())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if vf.Len() == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.writeIndent(0)
0000000000000000000000000000000000000000;;				p.WriteString("<!--")
0000000000000000000000000000000000000000;;				dashDash := false
0000000000000000000000000000000000000000;;				dashLast := false
0000000000000000000000000000000000000000;;				switch k {
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					s := vf.String()
0000000000000000000000000000000000000000;;					dashDash = strings.Index(s, "--") >= 0
0000000000000000000000000000000000000000;;					dashLast = s[len(s)-1] == '-'
0000000000000000000000000000000000000000;;					if !dashDash {
0000000000000000000000000000000000000000;;						p.WriteString(s)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case reflect.Slice:
0000000000000000000000000000000000000000;;					b := vf.Bytes()
0000000000000000000000000000000000000000;;					dashDash = bytes.Index(b, ddBytes) >= 0
0000000000000000000000000000000000000000;;					dashLast = b[len(b)-1] == '-'
0000000000000000000000000000000000000000;;					if !dashDash {
0000000000000000000000000000000000000000;;						p.Write(b)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					panic("can't happen")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if dashDash {
0000000000000000000000000000000000000000;;					return fmt.Errorf(`xml: comments must not contain "--"`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if dashLast {
0000000000000000000000000000000000000000;;					// "--->" is invalid grammar. Make it "- -->"
0000000000000000000000000000000000000000;;					p.WriteByte(' ')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.WriteString("-->")
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case fInnerXml:
0000000000000000000000000000000000000000;;				iface := vf.Interface()
0000000000000000000000000000000000000000;;				switch raw := iface.(type) {
0000000000000000000000000000000000000000;;				case []byte:
0000000000000000000000000000000000000000;;					p.Write(raw)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case string:
0000000000000000000000000000000000000000;;					p.WriteString(raw)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case fElement, fElement | fAny:
0000000000000000000000000000000000000000;;				if err := s.trim(finfo.parents); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(finfo.parents) > len(s.stack) {
0000000000000000000000000000000000000000;;					if vf.Kind() != reflect.Ptr && vf.Kind() != reflect.Interface || !vf.IsNil() {
0000000000000000000000000000000000000000;;						if err := s.push(finfo.parents[len(s.stack):]); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := p.marshalValue(vf, finfo, nil); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.trim(nil)
0000000000000000000000000000000000000000;;		return p.cachedWriteError()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// return the bufio Writer's cached write error
0000000000000000000000000000000000000000;;	func (p *printer) cachedWriteError() error {
0000000000000000000000000000000000000000;;		_, err := p.Write(nil)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *printer) writeIndent(depthDelta int) {
0000000000000000000000000000000000000000;;		if len(p.prefix) == 0 && len(p.indent) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if depthDelta < 0 {
0000000000000000000000000000000000000000;;			p.depth--
0000000000000000000000000000000000000000;;			if p.indentedIn {
0000000000000000000000000000000000000000;;				p.indentedIn = false
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.indentedIn = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.putNewline {
0000000000000000000000000000000000000000;;			p.WriteByte('\n')
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.putNewline = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.prefix) > 0 {
0000000000000000000000000000000000000000;;			p.WriteString(p.prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.indent) > 0 {
0000000000000000000000000000000000000000;;			for i := 0; i < p.depth; i++ {
0000000000000000000000000000000000000000;;				p.WriteString(p.indent)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if depthDelta > 0 {
0000000000000000000000000000000000000000;;			p.depth++
0000000000000000000000000000000000000000;;			p.indentedIn = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parentStack struct {
0000000000000000000000000000000000000000;;		p     *printer
0000000000000000000000000000000000000000;;		stack []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// trim updates the XML context to match the longest common prefix of the stack
0000000000000000000000000000000000000000;;	// and the given parents.  A closing tag will be written for every parent
0000000000000000000000000000000000000000;;	// popped.  Passing a zero slice or nil will close all the elements.
0000000000000000000000000000000000000000;;	func (s *parentStack) trim(parents []string) error {
0000000000000000000000000000000000000000;;		split := 0
0000000000000000000000000000000000000000;;		for ; split < len(parents) && split < len(s.stack); split++ {
0000000000000000000000000000000000000000;;			if parents[split] != s.stack[split] {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := len(s.stack) - 1; i >= split; i-- {
0000000000000000000000000000000000000000;;			if err := s.p.writeEnd(Name{Local: s.stack[i]}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.stack = parents[:split]
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// push adds parent elements to the stack and writes open tags.
0000000000000000000000000000000000000000;;	func (s *parentStack) push(parents []string) error {
0000000000000000000000000000000000000000;;		for i := 0; i < len(parents); i++ {
0000000000000000000000000000000000000000;;			if err := s.p.writeStart(&StartElement{Name: Name{Local: parents[i]}}); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.stack = append(s.stack, parents...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A MarshalXMLError is returned when Marshal encounters a type
0000000000000000000000000000000000000000;;	// that cannot be converted into XML.
0000000000000000000000000000000000000000;;	type UnsupportedTypeError struct {
0000000000000000000000000000000000000000;;		Type reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *UnsupportedTypeError) Error() string {
0000000000000000000000000000000000000000;;		return "xml: unsupported type: " + e.Type.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEmptyValue(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
