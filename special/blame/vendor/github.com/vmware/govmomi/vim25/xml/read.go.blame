0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/read.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/xml/read.go][vendor/github.com/vmware/govmomi/vim25/xml/read.go];	
0000000000000000000000000000000000000000;;	package xml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BUG(rsc): Mapping between XML elements and data structures is inherently flawed:
0000000000000000000000000000000000000000;;	// an XML element is an order-dependent collection of anonymous
0000000000000000000000000000000000000000;;	// values, while a data structure is an order-independent collection
0000000000000000000000000000000000000000;;	// of named values.
0000000000000000000000000000000000000000;;	// See package json for a textual representation more suitable
0000000000000000000000000000000000000000;;	// to data structures.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal parses the XML-encoded data and stores the result in
0000000000000000000000000000000000000000;;	// the value pointed to by v, which must be an arbitrary struct,
0000000000000000000000000000000000000000;;	// slice, or string. Well-formed data that does not fit into v is
0000000000000000000000000000000000000000;;	// discarded.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Because Unmarshal uses the reflect package, it can only assign
0000000000000000000000000000000000000000;;	// to exported (upper case) fields.  Unmarshal uses a case-sensitive
0000000000000000000000000000000000000000;;	// comparison to match XML element names to tag values and struct
0000000000000000000000000000000000000000;;	// field names.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an XML element to a struct using the following rules.
0000000000000000000000000000000000000000;;	// In the rules, the tag of a field refers to the value associated with the
0000000000000000000000000000000000000000;;	// key 'xml' in the struct field's tag (see the example above).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the struct has a field of type []byte or string with tag
0000000000000000000000000000000000000000;;	//      ",innerxml", Unmarshal accumulates the raw XML nested inside the
0000000000000000000000000000000000000000;;	//      element in that field.  The rest of the rules still apply.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the struct has a field named XMLName of type xml.Name,
0000000000000000000000000000000000000000;;	//      Unmarshal records the element name in that field.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XMLName field has an associated tag of the form
0000000000000000000000000000000000000000;;	//      "name" or "namespace-URL name", the XML element must have
0000000000000000000000000000000000000000;;	//      the given name (and, optionally, name space) or else Unmarshal
0000000000000000000000000000000000000000;;	//      returns an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XML element has an attribute whose name matches a
0000000000000000000000000000000000000000;;	//      struct field name with an associated tag containing ",attr" or
0000000000000000000000000000000000000000;;	//      the explicit name in a struct field tag of the form "name,attr",
0000000000000000000000000000000000000000;;	//      Unmarshal records the attribute value in that field.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XML element contains character data, that data is
0000000000000000000000000000000000000000;;	//      accumulated in the first struct field that has tag ",chardata".
0000000000000000000000000000000000000000;;	//      The struct field may have type []byte or string.
0000000000000000000000000000000000000000;;	//      If there is no such field, the character data is discarded.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XML element contains comments, they are accumulated in
0000000000000000000000000000000000000000;;	//      the first struct field that has tag ",comment".  The struct
0000000000000000000000000000000000000000;;	//      field may have type []byte or string.  If there is no such
0000000000000000000000000000000000000000;;	//      field, the comments are discarded.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XML element contains a sub-element whose name matches
0000000000000000000000000000000000000000;;	//      the prefix of a tag formatted as "a" or "a>b>c", unmarshal
0000000000000000000000000000000000000000;;	//      will descend into the XML structure looking for elements with the
0000000000000000000000000000000000000000;;	//      given names, and will map the innermost elements to that struct
0000000000000000000000000000000000000000;;	//      field. A tag starting with ">" is equivalent to one starting
0000000000000000000000000000000000000000;;	//      with the field name followed by ">".
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XML element contains a sub-element whose name matches
0000000000000000000000000000000000000000;;	//      a struct field's XMLName tag and the struct field has no
0000000000000000000000000000000000000000;;	//      explicit name tag as per the previous rule, unmarshal maps
0000000000000000000000000000000000000000;;	//      the sub-element to that struct field.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XML element contains a sub-element whose name matches a
0000000000000000000000000000000000000000;;	//      field without any mode flags (",attr", ",chardata", etc), Unmarshal
0000000000000000000000000000000000000000;;	//      maps the sub-element to that struct field.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * If the XML element contains a sub-element that hasn't matched any
0000000000000000000000000000000000000000;;	//      of the above rules and the struct has a field with tag ",any",
0000000000000000000000000000000000000000;;	//      unmarshal maps the sub-element to that struct field.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * An anonymous struct field is handled as if the fields of its
0000000000000000000000000000000000000000;;	//      value were part of the outer struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   * A struct field with tag "-" is never unmarshalled into.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an XML element to a string or []byte by saving the
0000000000000000000000000000000000000000;;	// concatenation of that element's character data in the string or
0000000000000000000000000000000000000000;;	// []byte. The saved []byte is never nil.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an attribute value to a string or []byte by saving
0000000000000000000000000000000000000000;;	// the value in the string or slice.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an XML element to a slice by extending the length of
0000000000000000000000000000000000000000;;	// the slice and mapping the element to the newly created value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an XML element or attribute value to a bool by
0000000000000000000000000000000000000000;;	// setting it to the boolean value represented by the string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an XML element or attribute value to an integer or
0000000000000000000000000000000000000000;;	// floating-point field by setting the field to the result of
0000000000000000000000000000000000000000;;	// interpreting the string value in decimal.  There is no check for
0000000000000000000000000000000000000000;;	// overflow.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an XML element to an xml.Name by recording the
0000000000000000000000000000000000000000;;	// element name.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal maps an XML element to a pointer by setting the pointer
0000000000000000000000000000000000000000;;	// to a freshly allocated value and then mapping the element to that value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Unmarshal(data []byte, v interface{}) error {
0000000000000000000000000000000000000000;;		return NewDecoder(bytes.NewReader(data)).Decode(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode works like xml.Unmarshal, except it reads the decoder
0000000000000000000000000000000000000000;;	// stream to find the start element.
0000000000000000000000000000000000000000;;	func (d *Decoder) Decode(v interface{}) error {
0000000000000000000000000000000000000000;;		return d.DecodeElement(v, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeElement works like xml.Unmarshal except that it takes
0000000000000000000000000000000000000000;;	// a pointer to the start XML element to decode into v.
0000000000000000000000000000000000000000;;	// It is useful when a client reads some raw XML tokens itself
0000000000000000000000000000000000000000;;	// but also wants to defer to Unmarshal for some elements.
0000000000000000000000000000000000000000;;	func (d *Decoder) DecodeElement(v interface{}, start *StartElement) error {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(v)
0000000000000000000000000000000000000000;;		if val.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return errors.New("non-pointer passed to Unmarshal")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.unmarshal(val.Elem(), start)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An UnmarshalError represents an error in the unmarshalling process.
0000000000000000000000000000000000000000;;	type UnmarshalError string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e UnmarshalError) Error() string { return string(e) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshaler is the interface implemented by objects that can unmarshal
0000000000000000000000000000000000000000;;	// an XML element description of themselves.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// UnmarshalXML decodes a single XML element
0000000000000000000000000000000000000000;;	// beginning with the given start element.
0000000000000000000000000000000000000000;;	// If it returns an error, the outer call to Unmarshal stops and
0000000000000000000000000000000000000000;;	// returns that error.
0000000000000000000000000000000000000000;;	// UnmarshalXML must consume exactly one XML element.
0000000000000000000000000000000000000000;;	// One common implementation strategy is to unmarshal into
0000000000000000000000000000000000000000;;	// a separate value with a layout matching the expected XML
0000000000000000000000000000000000000000;;	// using d.DecodeElement,  and then to copy the data from
0000000000000000000000000000000000000000;;	// that value into the receiver.
0000000000000000000000000000000000000000;;	// Another common strategy is to use d.Token to process the
0000000000000000000000000000000000000000;;	// XML object one token at a time.
0000000000000000000000000000000000000000;;	// UnmarshalXML may not use d.RawToken.
0000000000000000000000000000000000000000;;	type Unmarshaler interface {
0000000000000000000000000000000000000000;;		UnmarshalXML(d *Decoder, start StartElement) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalerAttr is the interface implemented by objects that can unmarshal
0000000000000000000000000000000000000000;;	// an XML attribute description of themselves.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// UnmarshalXMLAttr decodes a single XML attribute.
0000000000000000000000000000000000000000;;	// If it returns an error, the outer call to Unmarshal stops and
0000000000000000000000000000000000000000;;	// returns that error.
0000000000000000000000000000000000000000;;	// UnmarshalXMLAttr is used only for struct fields with the
0000000000000000000000000000000000000000;;	// "attr" option in the field tag.
0000000000000000000000000000000000000000;;	type UnmarshalerAttr interface {
0000000000000000000000000000000000000000;;		UnmarshalXMLAttr(attr Attr) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// receiverType returns the receiver type to use in an expression like "%s.MethodName".
0000000000000000000000000000000000000000;;	func receiverType(val interface{}) string {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(val)
0000000000000000000000000000000000000000;;		if t.Name() != "" {
0000000000000000000000000000000000000000;;			return t.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "(" + t.String() + ")"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalInterface unmarshals a single XML element into val.
0000000000000000000000000000000000000000;;	// start is the opening tag of the element.
0000000000000000000000000000000000000000;;	func (p *Decoder) unmarshalInterface(val Unmarshaler, start *StartElement) error {
0000000000000000000000000000000000000000;;		// Record that decoder must stop at end tag corresponding to start.
0000000000000000000000000000000000000000;;		p.pushEOF()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.unmarshalDepth++
0000000000000000000000000000000000000000;;		err := val.UnmarshalXML(p, *start)
0000000000000000000000000000000000000000;;		p.unmarshalDepth--
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.popEOF()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !p.popEOF() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("xml: %s.UnmarshalXML did not consume entire <%s> element", receiverType(val), start.Name.Local)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalTextInterface unmarshals a single XML element into val.
0000000000000000000000000000000000000000;;	// The chardata contained in the element (but not its children)
0000000000000000000000000000000000000000;;	// is passed to the text unmarshaler.
0000000000000000000000000000000000000000;;	func (p *Decoder) unmarshalTextInterface(val encoding.TextUnmarshaler, start *StartElement) error {
0000000000000000000000000000000000000000;;		var buf []byte
0000000000000000000000000000000000000000;;		depth := 1
0000000000000000000000000000000000000000;;		for depth > 0 {
0000000000000000000000000000000000000000;;			t, err := p.Token()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := t.(type) {
0000000000000000000000000000000000000000;;			case CharData:
0000000000000000000000000000000000000000;;				if depth == 1 {
0000000000000000000000000000000000000000;;					buf = append(buf, t...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case StartElement:
0000000000000000000000000000000000000000;;				depth++
0000000000000000000000000000000000000000;;			case EndElement:
0000000000000000000000000000000000000000;;				depth--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val.UnmarshalText(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalAttr unmarshals a single XML attribute into val.
0000000000000000000000000000000000000000;;	func (p *Decoder) unmarshalAttr(val reflect.Value, attr Attr) error {
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if val.IsNil() {
0000000000000000000000000000000000000000;;				val.Set(reflect.New(val.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.CanInterface() && val.Type().Implements(unmarshalerAttrType) {
0000000000000000000000000000000000000000;;			// This is an unmarshaler with a non-pointer receiver,
0000000000000000000000000000000000000000;;			// so it's likely to be incorrect, but we do what we're told.
0000000000000000000000000000000000000000;;			return val.Interface().(UnmarshalerAttr).UnmarshalXMLAttr(attr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val.CanAddr() {
0000000000000000000000000000000000000000;;			pv := val.Addr()
0000000000000000000000000000000000000000;;			if pv.CanInterface() && pv.Type().Implements(unmarshalerAttrType) {
0000000000000000000000000000000000000000;;				return pv.Interface().(UnmarshalerAttr).UnmarshalXMLAttr(attr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Not an UnmarshalerAttr; try encoding.TextUnmarshaler.
0000000000000000000000000000000000000000;;		if val.CanInterface() && val.Type().Implements(textUnmarshalerType) {
0000000000000000000000000000000000000000;;			// This is an unmarshaler with a non-pointer receiver,
0000000000000000000000000000000000000000;;			// so it's likely to be incorrect, but we do what we're told.
0000000000000000000000000000000000000000;;			return val.Interface().(encoding.TextUnmarshaler).UnmarshalText([]byte(attr.Value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val.CanAddr() {
0000000000000000000000000000000000000000;;			pv := val.Addr()
0000000000000000000000000000000000000000;;			if pv.CanInterface() && pv.Type().Implements(textUnmarshalerType) {
0000000000000000000000000000000000000000;;				return pv.Interface().(encoding.TextUnmarshaler).UnmarshalText([]byte(attr.Value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copyValue(val, []byte(attr.Value))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		unmarshalerType     = reflect.TypeOf((*Unmarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		unmarshalerAttrType = reflect.TypeOf((*UnmarshalerAttr)(nil)).Elem()
0000000000000000000000000000000000000000;;		textUnmarshalerType = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find reflect.Type for an element's type attribute.
0000000000000000000000000000000000000000;;	func (p *Decoder) typeForElement(val reflect.Value, start *StartElement) reflect.Type {
0000000000000000000000000000000000000000;;		t := ""
0000000000000000000000000000000000000000;;		for i, a := range start.Attr {
0000000000000000000000000000000000000000;;			if a.Name == xmlSchemaInstance || a.Name == xsiType {
0000000000000000000000000000000000000000;;				t = a.Value
0000000000000000000000000000000000000000;;				// HACK: ensure xsi:type is last in the list to avoid using that value for
0000000000000000000000000000000000000000;;				// a "type" attribute, such as ManagedObjectReference.Type for example.
0000000000000000000000000000000000000000;;				// Note that xsi:type is already the last attribute in VC/ESX responses.
0000000000000000000000000000000000000000;;				// This is only an issue with govmomi simulator generated responses.
0000000000000000000000000000000000000000;;				// Proper fix will require finding a few needles in this xml package haystack.
0000000000000000000000000000000000000000;;				// Note: govmomi uses xmlSchemaInstance, other clients (e.g. rbvmomi) use xsiType.
0000000000000000000000000000000000000000;;				// They are the same thing to XML parsers, but not to this hack here.
0000000000000000000000000000000000000000;;				x := len(start.Attr) - 1
0000000000000000000000000000000000000000;;				if i != x {
0000000000000000000000000000000000000000;;					start.Attr[i] = start.Attr[x]
0000000000000000000000000000000000000000;;					start.Attr[x] = a
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t == "" {
0000000000000000000000000000000000000000;;			// No type attribute; fall back to looking up type by interface name.
0000000000000000000000000000000000000000;;			t = val.Type().Name()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maybe the type is a basic xsd:* type.
0000000000000000000000000000000000000000;;		typ := stringToType(t)
0000000000000000000000000000000000000000;;		if typ != nil {
0000000000000000000000000000000000000000;;			return typ
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maybe the type is a custom type.
0000000000000000000000000000000000000000;;		if p.TypeFunc != nil {
0000000000000000000000000000000000000000;;			if typ, ok := p.TypeFunc(t); ok {
0000000000000000000000000000000000000000;;				return typ
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal a single XML element into val.
0000000000000000000000000000000000000000;;	func (p *Decoder) unmarshal(val reflect.Value, start *StartElement) error {
0000000000000000000000000000000000000000;;		// Find start element if we need it.
0000000000000000000000000000000000000000;;		if start == nil {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				tok, err := p.Token()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if t, ok := tok.(StartElement); ok {
0000000000000000000000000000000000000000;;					start = &t
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try to figure out type for empty interface values.
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Interface && val.IsNil() {
0000000000000000000000000000000000000000;;			typ := p.typeForElement(val, start)
0000000000000000000000000000000000000000;;			if typ != nil {
0000000000000000000000000000000000000000;;				pval := reflect.New(typ).Elem()
0000000000000000000000000000000000000000;;				err := p.unmarshal(pval, start)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;					if typ.Implements(val.Type()) {
0000000000000000000000000000000000000000;;						val.Set(pval)
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					typ = reflect.PtrTo(typ)
0000000000000000000000000000000000000000;;					pval = pval.Addr()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				val.Set(pval)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Load value from interface, but only if the result will be
0000000000000000000000000000000000000000;;		// usefully addressable.
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Interface && !val.IsNil() {
0000000000000000000000000000000000000000;;			e := val.Elem()
0000000000000000000000000000000000000000;;			if e.Kind() == reflect.Ptr && !e.IsNil() {
0000000000000000000000000000000000000000;;				val = e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if val.IsNil() {
0000000000000000000000000000000000000000;;				val.Set(reflect.New(val.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.CanInterface() && val.Type().Implements(unmarshalerType) {
0000000000000000000000000000000000000000;;			// This is an unmarshaler with a non-pointer receiver,
0000000000000000000000000000000000000000;;			// so it's likely to be incorrect, but we do what we're told.
0000000000000000000000000000000000000000;;			return p.unmarshalInterface(val.Interface().(Unmarshaler), start)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.CanAddr() {
0000000000000000000000000000000000000000;;			pv := val.Addr()
0000000000000000000000000000000000000000;;			if pv.CanInterface() && pv.Type().Implements(unmarshalerType) {
0000000000000000000000000000000000000000;;				return p.unmarshalInterface(pv.Interface().(Unmarshaler), start)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.CanInterface() && val.Type().Implements(textUnmarshalerType) {
0000000000000000000000000000000000000000;;			return p.unmarshalTextInterface(val.Interface().(encoding.TextUnmarshaler), start)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.CanAddr() {
0000000000000000000000000000000000000000;;			pv := val.Addr()
0000000000000000000000000000000000000000;;			if pv.CanInterface() && pv.Type().Implements(textUnmarshalerType) {
0000000000000000000000000000000000000000;;				return p.unmarshalTextInterface(pv.Interface().(encoding.TextUnmarshaler), start)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			data         []byte
0000000000000000000000000000000000000000;;			saveData     reflect.Value
0000000000000000000000000000000000000000;;			comment      []byte
0000000000000000000000000000000000000000;;			saveComment  reflect.Value
0000000000000000000000000000000000000000;;			saveXML      reflect.Value
0000000000000000000000000000000000000000;;			saveXMLIndex int
0000000000000000000000000000000000000000;;			saveXMLData  []byte
0000000000000000000000000000000000000000;;			saveAny      reflect.Value
0000000000000000000000000000000000000000;;			sv           reflect.Value
0000000000000000000000000000000000000000;;			tinfo        *typeInfo
0000000000000000000000000000000000000000;;			err          error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v := val; v.Kind() {
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New("unknown type " + v.Type().String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// TODO: For now, simply ignore the field. In the near
0000000000000000000000000000000000000000;;			//       future we may choose to unmarshal the start
0000000000000000000000000000000000000000;;			//       element on it, if not nil.
0000000000000000000000000000000000000000;;			return p.Skip()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			typ := v.Type()
0000000000000000000000000000000000000000;;			if typ.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				// []byte
0000000000000000000000000000000000000000;;				saveData = v
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Slice of element values.
0000000000000000000000000000000000000000;;			// Grow slice.
0000000000000000000000000000000000000000;;			n := v.Len()
0000000000000000000000000000000000000000;;			if n >= v.Cap() {
0000000000000000000000000000000000000000;;				ncap := 2 * n
0000000000000000000000000000000000000000;;				if ncap < 4 {
0000000000000000000000000000000000000000;;					ncap = 4
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				new := reflect.MakeSlice(typ, n, ncap)
0000000000000000000000000000000000000000;;				reflect.Copy(new, v)
0000000000000000000000000000000000000000;;				v.Set(new)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.SetLen(n + 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Recur to read element into slice.
0000000000000000000000000000000000000000;;			if err := p.unmarshal(v.Index(n), start); err != nil {
0000000000000000000000000000000000000000;;				v.SetLen(n)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Bool, reflect.Float32, reflect.Float64, reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr, reflect.String:
0000000000000000000000000000000000000000;;			saveData = v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			typ := v.Type()
0000000000000000000000000000000000000000;;			if typ == nameType {
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(start.Name))
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sv = v
0000000000000000000000000000000000000000;;			tinfo, err = getTypeInfo(typ)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Validate and assign element name.
0000000000000000000000000000000000000000;;			if tinfo.xmlname != nil {
0000000000000000000000000000000000000000;;				finfo := tinfo.xmlname
0000000000000000000000000000000000000000;;				if finfo.name != "" && finfo.name != start.Name.Local {
0000000000000000000000000000000000000000;;					return UnmarshalError("expected element type <" + finfo.name + "> but have <" + start.Name.Local + ">")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if finfo.xmlns != "" && finfo.xmlns != start.Name.Space {
0000000000000000000000000000000000000000;;					e := "expected element <" + finfo.name + "> in name space " + finfo.xmlns + " but have "
0000000000000000000000000000000000000000;;					if start.Name.Space == "" {
0000000000000000000000000000000000000000;;						e += "no name space"
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						e += start.Name.Space
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return UnmarshalError(e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fv := finfo.value(sv)
0000000000000000000000000000000000000000;;				if _, ok := fv.Interface().(Name); ok {
0000000000000000000000000000000000000000;;					fv.Set(reflect.ValueOf(start.Name))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Assign attributes.
0000000000000000000000000000000000000000;;			// Also, determine whether we need to save character data or comments.
0000000000000000000000000000000000000000;;			for i := range tinfo.fields {
0000000000000000000000000000000000000000;;				finfo := &tinfo.fields[i]
0000000000000000000000000000000000000000;;				switch finfo.flags & fMode {
0000000000000000000000000000000000000000;;				case fAttr:
0000000000000000000000000000000000000000;;					strv := finfo.value(sv)
0000000000000000000000000000000000000000;;					// Look for attribute.
0000000000000000000000000000000000000000;;					for _, a := range start.Attr {
0000000000000000000000000000000000000000;;						if a.Name.Local == finfo.name && (finfo.xmlns == "" || finfo.xmlns == a.Name.Space) {
0000000000000000000000000000000000000000;;							if err := p.unmarshalAttr(strv, a); err != nil {
0000000000000000000000000000000000000000;;								return err
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case fCharData:
0000000000000000000000000000000000000000;;					if !saveData.IsValid() {
0000000000000000000000000000000000000000;;						saveData = finfo.value(sv)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case fComment:
0000000000000000000000000000000000000000;;					if !saveComment.IsValid() {
0000000000000000000000000000000000000000;;						saveComment = finfo.value(sv)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case fAny, fAny | fElement:
0000000000000000000000000000000000000000;;					if !saveAny.IsValid() {
0000000000000000000000000000000000000000;;						saveAny = finfo.value(sv)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case fInnerXml:
0000000000000000000000000000000000000000;;					if !saveXML.IsValid() {
0000000000000000000000000000000000000000;;						saveXML = finfo.value(sv)
0000000000000000000000000000000000000000;;						if p.saved == nil {
0000000000000000000000000000000000000000;;							saveXMLIndex = 0
0000000000000000000000000000000000000000;;							p.saved = new(bytes.Buffer)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							saveXMLIndex = p.savedOffset()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find end element.
0000000000000000000000000000000000000000;;		// Process sub-elements along the way.
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var savedOffset int
0000000000000000000000000000000000000000;;			if saveXML.IsValid() {
0000000000000000000000000000000000000000;;				savedOffset = p.savedOffset()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tok, err := p.Token()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := tok.(type) {
0000000000000000000000000000000000000000;;			case StartElement:
0000000000000000000000000000000000000000;;				consumed := false
0000000000000000000000000000000000000000;;				if sv.IsValid() {
0000000000000000000000000000000000000000;;					consumed, err = p.unmarshalPath(tinfo, sv, nil, &t)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !consumed && saveAny.IsValid() {
0000000000000000000000000000000000000000;;						consumed = true
0000000000000000000000000000000000000000;;						if err := p.unmarshal(saveAny, &t); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !consumed {
0000000000000000000000000000000000000000;;					if err := p.Skip(); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case EndElement:
0000000000000000000000000000000000000000;;				if saveXML.IsValid() {
0000000000000000000000000000000000000000;;					saveXMLData = p.saved.Bytes()[saveXMLIndex:savedOffset]
0000000000000000000000000000000000000000;;					if saveXMLIndex == 0 {
0000000000000000000000000000000000000000;;						p.saved = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case CharData:
0000000000000000000000000000000000000000;;				if saveData.IsValid() {
0000000000000000000000000000000000000000;;					data = append(data, t...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case Comment:
0000000000000000000000000000000000000000;;				if saveComment.IsValid() {
0000000000000000000000000000000000000000;;					comment = append(comment, t...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if saveData.IsValid() && saveData.CanInterface() && saveData.Type().Implements(textUnmarshalerType) {
0000000000000000000000000000000000000000;;			if err := saveData.Interface().(encoding.TextUnmarshaler).UnmarshalText(data); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			saveData = reflect.Value{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if saveData.IsValid() && saveData.CanAddr() {
0000000000000000000000000000000000000000;;			pv := saveData.Addr()
0000000000000000000000000000000000000000;;			if pv.CanInterface() && pv.Type().Implements(textUnmarshalerType) {
0000000000000000000000000000000000000000;;				if err := pv.Interface().(encoding.TextUnmarshaler).UnmarshalText(data); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				saveData = reflect.Value{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := copyValue(saveData, data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := saveComment; t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			t.SetString(string(comment))
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			t.Set(reflect.ValueOf(comment))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := saveXML; t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			t.SetString(string(saveXMLData))
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			t.Set(reflect.ValueOf(saveXMLData))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyValue(dst reflect.Value, src []byte) (err error) {
0000000000000000000000000000000000000000;;		dst0 := dst
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dst.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if dst.IsNil() {
0000000000000000000000000000000000000000;;				dst.Set(reflect.New(dst.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst = dst.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save accumulated data.
0000000000000000000000000000000000000000;;		switch dst.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Invalid:
0000000000000000000000000000000000000000;;			// Probably a comment.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New("cannot unmarshal into " + dst0.Type().String())
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			itmp, err := strconv.ParseInt(string(src), 10, dst.Type().Bits())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst.SetInt(itmp)
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			var utmp uint64
0000000000000000000000000000000000000000;;			if len(src) > 0 && src[0] == '-' {
0000000000000000000000000000000000000000;;				// Negative value for unsigned field.
0000000000000000000000000000000000000000;;				// Assume it was serialized following two's complement.
0000000000000000000000000000000000000000;;				itmp, err := strconv.ParseInt(string(src), 10, dst.Type().Bits())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Reinterpret value based on type width.
0000000000000000000000000000000000000000;;				switch dst.Type().Bits() {
0000000000000000000000000000000000000000;;				case 8:
0000000000000000000000000000000000000000;;					utmp = uint64(uint8(itmp))
0000000000000000000000000000000000000000;;				case 16:
0000000000000000000000000000000000000000;;					utmp = uint64(uint16(itmp))
0000000000000000000000000000000000000000;;				case 32:
0000000000000000000000000000000000000000;;					utmp = uint64(uint32(itmp))
0000000000000000000000000000000000000000;;				case 64:
0000000000000000000000000000000000000000;;					utmp = uint64(uint64(itmp))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				utmp, err = strconv.ParseUint(string(src), 10, dst.Type().Bits())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst.SetUint(utmp)
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			ftmp, err := strconv.ParseFloat(string(src), dst.Type().Bits())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst.SetFloat(ftmp)
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			value, err := strconv.ParseBool(strings.TrimSpace(string(src)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst.SetBool(value)
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			dst.SetString(string(src))
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if len(src) == 0 {
0000000000000000000000000000000000000000;;				// non-nil to flag presence
0000000000000000000000000000000000000000;;				src = []byte{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst.SetBytes(src)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unmarshalPath walks down an XML structure looking for wanted
0000000000000000000000000000000000000000;;	// paths, and calls unmarshal on them.
0000000000000000000000000000000000000000;;	// The consumed result tells whether XML elements have been consumed
0000000000000000000000000000000000000000;;	// from the Decoder until start's matching end element, or if it's
0000000000000000000000000000000000000000;;	// still untouched because start is uninteresting for sv's fields.
0000000000000000000000000000000000000000;;	func (p *Decoder) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement) (consumed bool, err error) {
0000000000000000000000000000000000000000;;		recurse := false
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for i := range tinfo.fields {
0000000000000000000000000000000000000000;;			finfo := &tinfo.fields[i]
0000000000000000000000000000000000000000;;			if finfo.flags&fElement == 0 || len(finfo.parents) < len(parents) || finfo.xmlns != "" && finfo.xmlns != start.Name.Space {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j := range parents {
0000000000000000000000000000000000000000;;				if parents[j] != finfo.parents[j] {
0000000000000000000000000000000000000000;;					continue Loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(finfo.parents) == len(parents) && finfo.name == start.Name.Local {
0000000000000000000000000000000000000000;;				// It's a perfect match, unmarshal the field.
0000000000000000000000000000000000000000;;				return true, p.unmarshal(finfo.value(sv), start)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(finfo.parents) > len(parents) && finfo.parents[len(parents)] == start.Name.Local {
0000000000000000000000000000000000000000;;				// It's a prefix for the field. Break and recurse
0000000000000000000000000000000000000000;;				// since it's not ok for one field path to be itself
0000000000000000000000000000000000000000;;				// the prefix for another field path.
0000000000000000000000000000000000000000;;				recurse = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// We can reuse the same slice as long as we
0000000000000000000000000000000000000000;;				// don't try to append to it.
0000000000000000000000000000000000000000;;				parents = finfo.parents[:len(parents)+1]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !recurse {
0000000000000000000000000000000000000000;;			// We have no business with this element.
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The element is not a perfect match for any field, but one
0000000000000000000000000000000000000000;;		// or more fields have the path to this element as a parent
0000000000000000000000000000000000000000;;		// prefix. Recurse and attempt to match these.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var tok Token
0000000000000000000000000000000000000000;;			tok, err = p.Token()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return true, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch t := tok.(type) {
0000000000000000000000000000000000000000;;			case StartElement:
0000000000000000000000000000000000000000;;				consumed2, err := p.unmarshalPath(tinfo, sv, parents, &t)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return true, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !consumed2 {
0000000000000000000000000000000000000000;;					if err := p.Skip(); err != nil {
0000000000000000000000000000000000000000;;						return true, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case EndElement:
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Skip reads tokens until it has consumed the end element
0000000000000000000000000000000000000000;;	// matching the most recent start element already consumed.
0000000000000000000000000000000000000000;;	// It recurs if it encounters a start element, so it can be used to
0000000000000000000000000000000000000000;;	// skip nested structures.
0000000000000000000000000000000000000000;;	// It returns nil if it finds an end element matching the start
0000000000000000000000000000000000000000;;	// element; otherwise it returns an error describing the problem.
0000000000000000000000000000000000000000;;	func (d *Decoder) Skip() error {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok, err := d.Token()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch tok.(type) {
0000000000000000000000000000000000000000;;			case StartElement:
0000000000000000000000000000000000000000;;				if err := d.Skip(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case EndElement:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
