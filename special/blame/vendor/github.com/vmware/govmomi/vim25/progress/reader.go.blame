0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014-2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/vim25/progress/reader.go[Godeps/_workspace/src/github.com/vmware/govmomi/vim25/progress/reader.go][vendor/github.com/vmware/govmomi/vim25/progress/reader.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package progress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type readerReport struct {
0000000000000000000000000000000000000000;;		t time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pos  int64
0000000000000000000000000000000000000000;;		size int64
0000000000000000000000000000000000000000;;		bps  *uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r readerReport) Percentage() float32 {
0000000000000000000000000000000000000000;;		return 100.0 * float32(r.pos) / float32(r.size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r readerReport) Detail() string {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			KiB = 1024
0000000000000000000000000000000000000000;;			MiB = 1024 * KiB
0000000000000000000000000000000000000000;;			GiB = 1024 * MiB
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use the reader's bps field, so this report returns an up-to-date number.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// For example: if there hasn't been progress for the last 5 seconds, the
0000000000000000000000000000000000000000;;		// most recent report should return "0B/s".
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		bps := atomic.LoadUint64(r.bps)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case bps >= GiB:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%.1fGiB/s", float32(bps)/float32(GiB))
0000000000000000000000000000000000000000;;		case bps >= MiB:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%.1fMiB/s", float32(bps)/float32(MiB))
0000000000000000000000000000000000000000;;		case bps >= KiB:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%.1fKiB/s", float32(bps)/float32(KiB))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%dB/s", bps)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p readerReport) Error() error {
0000000000000000000000000000000000000000;;		return p.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reader wraps an io.Reader and sends a progress report over a channel for
0000000000000000000000000000000000000000;;	// every read it handles.
0000000000000000000000000000000000000000;;	type reader struct {
0000000000000000000000000000000000000000;;		r io.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pos  int64
0000000000000000000000000000000000000000;;		size int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bps uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ch chan<- Report
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewReader(s Sinker, r io.Reader, size int64) *reader {
0000000000000000000000000000000000000000;;		pr := reader{
0000000000000000000000000000000000000000;;			r: r,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			size: size,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reports must be sent downstream and to the bps computation loop.
0000000000000000000000000000000000000000;;		pr.ch = Tee(s, newBpsLoop(&pr.bps)).Sink()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read calls the Read function on the underlying io.Reader. Additionally,
0000000000000000000000000000000000000000;;	// every read causes a progress report to be sent to the progress reader's
0000000000000000000000000000000000000000;;	// underlying channel.
0000000000000000000000000000000000000000;;	func (r *reader) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		n, err := r.r.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.pos += int64(n)
0000000000000000000000000000000000000000;;		q := readerReport{
0000000000000000000000000000000000000000;;			t:    time.Now(),
0000000000000000000000000000000000000000;;			pos:  r.pos,
0000000000000000000000000000000000000000;;			size: r.size,
0000000000000000000000000000000000000000;;			bps:  &r.bps,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.ch <- q
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Done marks the progress reader as done, optionally including an error in the
0000000000000000000000000000000000000000;;	// progress report. After sending it, the underlying channel is closed.
0000000000000000000000000000000000000000;;	func (r *reader) Done(err error) {
0000000000000000000000000000000000000000;;		q := readerReport{
0000000000000000000000000000000000000000;;			t:    time.Now(),
0000000000000000000000000000000000000000;;			pos:  r.pos,
0000000000000000000000000000000000000000;;			size: r.size,
0000000000000000000000000000000000000000;;			bps:  &r.bps,
0000000000000000000000000000000000000000;;			err:  err,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.ch <- q
0000000000000000000000000000000000000000;;		close(r.ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newBpsLoop returns a sink that monitors and stores throughput.
0000000000000000000000000000000000000000;;	func newBpsLoop(dst *uint64) SinkFunc {
0000000000000000000000000000000000000000;;		fn := func() chan<- Report {
0000000000000000000000000000000000000000;;			sink := make(chan Report)
0000000000000000000000000000000000000000;;			go bpsLoop(sink, dst)
0000000000000000000000000000000000000000;;			return sink
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bpsLoop(ch <-chan Report, dst *uint64) {
0000000000000000000000000000000000000000;;		l := list.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var tch <-chan time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Setup timer for front of list to become stale.
0000000000000000000000000000000000000000;;			if e := l.Front(); e != nil {
0000000000000000000000000000000000000000;;				dt := time.Second - time.Now().Sub(e.Value.(readerReport).t)
0000000000000000000000000000000000000000;;				tch = time.After(dt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case q, ok := <-ch:
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				l.PushBack(q)
0000000000000000000000000000000000000000;;			case <-tch:
0000000000000000000000000000000000000000;;				l.Remove(l.Front())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Compute new bps
0000000000000000000000000000000000000000;;			if l.Len() == 0 {
0000000000000000000000000000000000000000;;				atomic.StoreUint64(dst, 0)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				f := l.Front().Value.(readerReport)
0000000000000000000000000000000000000000;;				b := l.Back().Value.(readerReport)
0000000000000000000000000000000000000000;;				atomic.StoreUint64(dst, uint64(b.pos-f.pos))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
