0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2017 VMware, Inc. All Rights Reserved.
f6ad395f98e8f42c981d72ea247db1a4edb07eff;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package property
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter provides methods for matching against types.DynamicProperty
0000000000000000000000000000000000000000;;	type Filter map[string]types.AnyType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns the Filter map keys as a []string
0000000000000000000000000000000000000000;;	func (f Filter) Keys() []string {
0000000000000000000000000000000000000000;;		keys := make([]string, 0, len(f))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key := range f {
0000000000000000000000000000000000000000;;			keys = append(keys, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchProperty returns true if a Filter entry matches the given prop.
0000000000000000000000000000000000000000;;	func (f Filter) MatchProperty(prop types.DynamicProperty) bool {
0000000000000000000000000000000000000000;;		match, ok := f[prop.Name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if match == prop.Val {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ptype := reflect.TypeOf(prop.Val)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasPrefix(ptype.Name(), "ArrayOf") {
0000000000000000000000000000000000000000;;			pval := reflect.ValueOf(prop.Val).Field(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < pval.Len(); i++ {
0000000000000000000000000000000000000000;;				prop.Val = pval.Index(i).Interface()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if f.MatchProperty(prop) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if reflect.TypeOf(match) != ptype {
0000000000000000000000000000000000000000;;			s, ok := match.(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// convert if we can
0000000000000000000000000000000000000000;;			switch prop.Val.(type) {
0000000000000000000000000000000000000000;;			case bool:
0000000000000000000000000000000000000000;;				match, _ = strconv.ParseBool(s)
0000000000000000000000000000000000000000;;			case int16:
0000000000000000000000000000000000000000;;				x, _ := strconv.ParseInt(s, 10, 16)
0000000000000000000000000000000000000000;;				match = int16(x)
0000000000000000000000000000000000000000;;			case int32:
0000000000000000000000000000000000000000;;				x, _ := strconv.ParseInt(s, 10, 32)
0000000000000000000000000000000000000000;;				match = int32(x)
0000000000000000000000000000000000000000;;			case int64:
0000000000000000000000000000000000000000;;				match, _ = strconv.ParseInt(s, 10, 64)
0000000000000000000000000000000000000000;;			case float32:
0000000000000000000000000000000000000000;;				x, _ := strconv.ParseFloat(s, 32)
0000000000000000000000000000000000000000;;				match = float32(x)
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				match, _ = strconv.ParseFloat(s, 64)
0000000000000000000000000000000000000000;;			case fmt.Stringer:
0000000000000000000000000000000000000000;;				prop.Val = prop.Val.(fmt.Stringer).String()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if ptype.Kind() != reflect.String {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// An enum type we can convert to a string type
0000000000000000000000000000000000000000;;				prop.Val = reflect.ValueOf(prop.Val).String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch pval := prop.Val.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			m, _ := filepath.Match(match.(string), pval)
0000000000000000000000000000000000000000;;			return m
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return reflect.DeepEqual(match, pval)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchPropertyList returns true if all given props match the Filter.
0000000000000000000000000000000000000000;;	func (f Filter) MatchPropertyList(props []types.DynamicProperty) bool {
0000000000000000000000000000000000000000;;		for _, p := range props {
0000000000000000000000000000000000000000;;			if !f.MatchProperty(p) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatchObjectContent returns a list of ObjectContent.Obj where the ObjectContent.PropSet matches the Filter.
0000000000000000000000000000000000000000;;	func (f Filter) MatchObjectContent(objects []types.ObjectContent) []types.ManagedObjectReference {
0000000000000000000000000000000000000000;;		var refs []types.ManagedObjectReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, o := range objects {
0000000000000000000000000000000000000000;;			if f.MatchPropertyList(o.PropSet) {
0000000000000000000000000000000000000000;;				refs = append(refs, o.Obj)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return refs
0000000000000000000000000000000000000000;;	}
