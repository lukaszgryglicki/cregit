0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/property/collector.go[Godeps/_workspace/src/github.com/vmware/govmomi/property/collector.go][vendor/github.com/vmware/govmomi/property/collector.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package property
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Collector models the PropertyCollector managed object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information, see:
0000000000000000000000000000000000000000;;	// http://pubs.vmware.com/vsphere-55/index.jsp#com.vmware.wssdk.apiref.doc/vmodl.query.PropertyCollector.html
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Collector struct {
0000000000000000000000000000000000000000;;		roundTripper soap.RoundTripper
0000000000000000000000000000000000000000;;		reference    types.ManagedObjectReference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultCollector returns the session's default property collector.
0000000000000000000000000000000000000000;;	func DefaultCollector(c *vim25.Client) *Collector {
0000000000000000000000000000000000000000;;		p := Collector{
0000000000000000000000000000000000000000;;			roundTripper: c,
0000000000000000000000000000000000000000;;			reference:    c.ServiceContent.PropertyCollector,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Collector) Reference() types.ManagedObjectReference {
0000000000000000000000000000000000000000;;		return p.reference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates a new session-specific Collector that can be used to
0000000000000000000000000000000000000000;;	// retrieve property updates independent of any other Collector.
0000000000000000000000000000000000000000;;	func (p *Collector) Create(ctx context.Context) (*Collector, error) {
0000000000000000000000000000000000000000;;		req := types.CreatePropertyCollector{
0000000000000000000000000000000000000000;;			This: p.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreatePropertyCollector(ctx, p.roundTripper, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newp := Collector{
0000000000000000000000000000000000000000;;			roundTripper: p.roundTripper,
0000000000000000000000000000000000000000;;			reference:    res.Returnval,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &newp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Destroy destroys this Collector.
0000000000000000000000000000000000000000;;	func (p *Collector) Destroy(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.DestroyPropertyCollector{
0000000000000000000000000000000000000000;;			This: p.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.DestroyPropertyCollector(ctx, p.roundTripper, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.reference = types.ManagedObjectReference{}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Collector) CreateFilter(ctx context.Context, req types.CreateFilter) error {
0000000000000000000000000000000000000000;;		req.This = p.Reference()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.CreateFilter(ctx, p.roundTripper, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Collector) WaitForUpdates(ctx context.Context, v string) (*types.UpdateSet, error) {
0000000000000000000000000000000000000000;;		req := types.WaitForUpdatesEx{
0000000000000000000000000000000000000000;;			This:    p.Reference(),
0000000000000000000000000000000000000000;;			Version: v,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.WaitForUpdatesEx(ctx, p.roundTripper, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.Returnval, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Collector) RetrieveProperties(ctx context.Context, req types.RetrieveProperties) (*types.RetrievePropertiesResponse, error) {
0000000000000000000000000000000000000000;;		req.This = p.Reference()
0000000000000000000000000000000000000000;;		return methods.RetrieveProperties(ctx, p.roundTripper, &req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Retrieve loads properties for a slice of managed objects. The dst argument
0000000000000000000000000000000000000000;;	// must be a pointer to a []interface{}, which is populated with the instances
0000000000000000000000000000000000000000;;	// of the specified managed objects, with the relevant properties filled in. If
0000000000000000000000000000000000000000;;	// the properties slice is nil, all properties are loaded.
0000000000000000000000000000000000000000;;	func (p *Collector) Retrieve(ctx context.Context, objs []types.ManagedObjectReference, ps []string, dst interface{}) error {
0000000000000000000000000000000000000000;;		var propSpec *types.PropertySpec
0000000000000000000000000000000000000000;;		var objectSet []types.ObjectSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, obj := range objs {
0000000000000000000000000000000000000000;;			// Ensure that all object reference types are the same
0000000000000000000000000000000000000000;;			if propSpec == nil {
0000000000000000000000000000000000000000;;				propSpec = &types.PropertySpec{
0000000000000000000000000000000000000000;;					Type: obj.Type,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ps == nil {
0000000000000000000000000000000000000000;;					propSpec.All = types.NewBool(true)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					propSpec.PathSet = ps
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if obj.Type != propSpec.Type {
0000000000000000000000000000000000000000;;					return errors.New("object references must have the same type")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			objectSpec := types.ObjectSpec{
0000000000000000000000000000000000000000;;				Obj:  obj,
0000000000000000000000000000000000000000;;				Skip: types.NewBool(false),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			objectSet = append(objectSet, objectSpec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RetrieveProperties{
0000000000000000000000000000000000000000;;			SpecSet: []types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					ObjectSet: objectSet,
0000000000000000000000000000000000000000;;					PropSet:   []types.PropertySpec{*propSpec},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := p.RetrieveProperties(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d, ok := dst.(*[]types.ObjectContent); ok {
0000000000000000000000000000000000000000;;			*d = res.Returnval
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mo.LoadRetrievePropertiesResponse(res, dst)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveWithFilter populates dst as Retrieve does, but only for entities matching the given filter.
0000000000000000000000000000000000000000;;	func (p *Collector) RetrieveWithFilter(ctx context.Context, objs []types.ManagedObjectReference, ps []string, dst interface{}, filter Filter) error {
0000000000000000000000000000000000000000;;		if len(filter) == 0 {
0000000000000000000000000000000000000000;;			return p.Retrieve(ctx, objs, ps, dst)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var content []types.ObjectContent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := p.Retrieve(ctx, objs, filter.Keys(), &content)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		objs = filter.MatchObjectContent(content)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(objs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.Retrieve(ctx, objs, ps, dst)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RetrieveOne calls Retrieve with a single managed object reference.
0000000000000000000000000000000000000000;;	func (p *Collector) RetrieveOne(ctx context.Context, obj types.ManagedObjectReference, ps []string, dst interface{}) error {
0000000000000000000000000000000000000000;;		var objs = []types.ManagedObjectReference{obj}
0000000000000000000000000000000000000000;;		return p.Retrieve(ctx, objs, ps, dst)
0000000000000000000000000000000000000000;;	}
