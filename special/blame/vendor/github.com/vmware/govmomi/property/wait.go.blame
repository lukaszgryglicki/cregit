0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/property/wait.go[Godeps/_workspace/src/github.com/vmware/govmomi/property/wait.go][vendor/github.com/vmware/govmomi/property/wait.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package property
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait waits for any of the specified properties of the specified managed
0000000000000000000000000000000000000000;;	// object to change. It calls the specified function for every update it
0000000000000000000000000000000000000000;;	// receives. If this function returns false, it continues waiting for
0000000000000000000000000000000000000000;;	// subsequent updates. If this function returns true, it stops waiting and
0000000000000000000000000000000000000000;;	// returns.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To only receive updates for the specified managed object, the function
0000000000000000000000000000000000000000;;	// creates a new property collector and calls CreateFilter. A new property
0000000000000000000000000000000000000000;;	// collector is required because filters can only be added, not removed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The newly created collector is destroyed before this function returns (both
0000000000000000000000000000000000000000;;	// in case of success or error).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Wait(ctx context.Context, c *Collector, obj types.ManagedObjectReference, ps []string, f func([]types.PropertyChange) bool) error {
0000000000000000000000000000000000000000;;		p, err := c.Create(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attempt to destroy the collector using the background context, as the
0000000000000000000000000000000000000000;;		// specified context may have timed out or have been cancelled.
0000000000000000000000000000000000000000;;		defer p.Destroy(context.Background())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.CreateFilter{
0000000000000000000000000000000000000000;;			Spec: types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				ObjectSet: []types.ObjectSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Obj: obj,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PropSet: []types.PropertySpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						PathSet: ps,
0000000000000000000000000000000000000000;;						Type:    obj.Type,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ps) == 0 {
0000000000000000000000000000000000000000;;			req.Spec.PropSet[0].All = types.NewBool(true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = p.CreateFilter(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return waitLoop(ctx, p, func(_ types.ManagedObjectReference, pc []types.PropertyChange) bool {
0000000000000000000000000000000000000000;;			return f(pc)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForView waits for any of the specified properties of the managed
0000000000000000000000000000000000000000;;	// objects in the View to change. It calls the specified function for every update it
0000000000000000000000000000000000000000;;	// receives. If this function returns false, it continues waiting for
0000000000000000000000000000000000000000;;	// subsequent updates. If this function returns true, it stops waiting and
0000000000000000000000000000000000000000;;	// returns.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To only receive updates for the View's specified managed objects, the function
0000000000000000000000000000000000000000;;	// creates a new property collector and calls CreateFilter. A new property
0000000000000000000000000000000000000000;;	// collector is required because filters can only be added, not removed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The newly created collector is destroyed before this function returns (both
0000000000000000000000000000000000000000;;	// in case of success or error).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The code assumes that all objects in the View are the same type
0000000000000000000000000000000000000000;;	func WaitForView(ctx context.Context, c *Collector, view types.ManagedObjectReference, obj types.ManagedObjectReference, ps []string, f func(types.ManagedObjectReference, []types.PropertyChange) bool) error {
0000000000000000000000000000000000000000;;		p, err := c.Create(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attempt to destroy the collector using the background context, as the
0000000000000000000000000000000000000000;;		// specified context may have timed out or have been cancelled.
0000000000000000000000000000000000000000;;		defer p.Destroy(context.Background())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.CreateFilter{
0000000000000000000000000000000000000000;;			Spec: types.PropertyFilterSpec{
0000000000000000000000000000000000000000;;				ObjectSet: []types.ObjectSpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Obj: view,
0000000000000000000000000000000000000000;;						SelectSet: []types.BaseSelectionSpec{
0000000000000000000000000000000000000000;;							&types.TraversalSpec{
0000000000000000000000000000000000000000;;								SelectionSpec: types.SelectionSpec{
0000000000000000000000000000000000000000;;									Name: "traverseEntities",
0000000000000000000000000000000000000000;;								},
0000000000000000000000000000000000000000;;								Path: "view",
0000000000000000000000000000000000000000;;								Type: view.Type}},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				PropSet: []types.PropertySpec{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Type:    obj.Type,
0000000000000000000000000000000000000000;;						PathSet: ps,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = p.CreateFilter(ctx, req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return waitLoop(ctx, p, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func waitLoop(ctx context.Context, c *Collector, f func(types.ManagedObjectReference, []types.PropertyChange) bool) error {
0000000000000000000000000000000000000000;;		for version := ""; ; {
0000000000000000000000000000000000000000;;			res, err := c.WaitForUpdates(ctx, version)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Retry if the result came back empty
0000000000000000000000000000000000000000;;			if res == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			version = res.Version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, fs := range res.FilterSet {
0000000000000000000000000000000000000000;;				for _, os := range fs.ObjectSet {
0000000000000000000000000000000000000000;;					if f(os.Obj, os.ChangeSet) {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
