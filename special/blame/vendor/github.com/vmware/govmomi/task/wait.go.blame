0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/task/wait.go[Godeps/_workspace/src/github.com/vmware/govmomi/task/wait.go][vendor/github.com/vmware/govmomi/task/wait.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package task
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/progress"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type taskProgress struct {
0000000000000000000000000000000000000000;;		info *types.TaskInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t taskProgress) Percentage() float32 {
0000000000000000000000000000000000000000;;		return float32(t.info.Progress)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t taskProgress) Detail() string {
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t taskProgress) Error() error {
0000000000000000000000000000000000000000;;		if t.info.Error != nil {
0000000000000000000000000000000000000000;;			return Error{t.info.Error}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type taskCallback struct {
0000000000000000000000000000000000000000;;		ch   chan<- progress.Report
0000000000000000000000000000000000000000;;		info *types.TaskInfo
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *taskCallback) fn(pc []types.PropertyChange) bool {
0000000000000000000000000000000000000000;;		for _, c := range pc {
0000000000000000000000000000000000000000;;			if c.Name != "info" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.Op != types.PropertyChangeOpAssign {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if c.Val == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ti := c.Val.(types.TaskInfo)
0000000000000000000000000000000000000000;;			t.info = &ti
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// t.info could be nil if pc can't satify the rules above
0000000000000000000000000000000000000000;;		if t.info == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pr := taskProgress{t.info}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Store copy of error, so Wait() can return it as well.
0000000000000000000000000000000000000000;;		t.err = pr.Error()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t.info.State {
0000000000000000000000000000000000000000;;		case types.TaskInfoStateQueued, types.TaskInfoStateRunning:
0000000000000000000000000000000000000000;;			if t.ch != nil {
0000000000000000000000000000000000000000;;				// Don't care if this is dropped
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case t.ch <- pr:
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case types.TaskInfoStateSuccess, types.TaskInfoStateError:
0000000000000000000000000000000000000000;;			if t.ch != nil {
0000000000000000000000000000000000000000;;				// Last one must always be delivered
0000000000000000000000000000000000000000;;				t.ch <- pr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unknown state: " + t.info.State)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait waits for a task to finish with either success or failure. It does so
0000000000000000000000000000000000000000;;	// by waiting for the "info" property of task managed object to change. The
0000000000000000000000000000000000000000;;	// function returns when it finds the task in the "success" or "error" state.
0000000000000000000000000000000000000000;;	// In the former case, the return value is nil. In the latter case the return
0000000000000000000000000000000000000000;;	// value is an instance of this package's Error struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Any error returned while waiting for property changes causes the function to
0000000000000000000000000000000000000000;;	// return immediately and propagate the error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the progress.Sinker argument is specified, any progress updates for the
0000000000000000000000000000000000000000;;	// task are sent here. The completion percentage is passed through directly.
0000000000000000000000000000000000000000;;	// The detail for the progress update is set to an empty string. If the task
0000000000000000000000000000000000000000;;	// finishes in the error state, the error instance is passed through as well.
0000000000000000000000000000000000000000;;	// Note that this error is the same error that is returned by this function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Wait(ctx context.Context, ref types.ManagedObjectReference, pc *property.Collector, s progress.Sinker) (*types.TaskInfo, error) {
0000000000000000000000000000000000000000;;		cb := &taskCallback{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Include progress sink if specified
0000000000000000000000000000000000000000;;		if s != nil {
0000000000000000000000000000000000000000;;			cb.ch = s.Sink()
0000000000000000000000000000000000000000;;			defer close(cb.ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := property.Wait(ctx, pc, ref, []string{"info"}, cb.fn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cb.info, cb.err
0000000000000000000000000000000000000000;;	}
