0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2016 VMware, Inc. All Rights Reserved.
45473432028991b8b23cc5822fe045d9b6a279d6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DatastoreFile implements io.Reader, io.Seeker and io.Closer interfaces for datastore file access.
0000000000000000000000000000000000000000;;	type DatastoreFile struct {
0000000000000000000000000000000000000000;;		d    Datastore
0000000000000000000000000000000000000000;;		ctx  context.Context
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf    io.Reader
0000000000000000000000000000000000000000;;		body   io.ReadCloser
0000000000000000000000000000000000000000;;		length int64
0000000000000000000000000000000000000000;;		offset struct {
0000000000000000000000000000000000000000;;			read, seek int64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open opens the named file relative to the Datastore.
0000000000000000000000000000000000000000;;	func (d Datastore) Open(ctx context.Context, name string) (*DatastoreFile, error) {
0000000000000000000000000000000000000000;;		return &DatastoreFile{
0000000000000000000000000000000000000000;;			d:      d,
0000000000000000000000000000000000000000;;			name:   name,
0000000000000000000000000000000000000000;;			length: -1,
0000000000000000000000000000000000000000;;			ctx:    ctx,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads up to len(b) bytes from the DatastoreFile.
0000000000000000000000000000000000000000;;	func (f *DatastoreFile) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if f.offset.read != f.offset.seek {
0000000000000000000000000000000000000000;;			// A Seek() call changed the offset, we need to issue a new GET
0000000000000000000000000000000000000000;;			_ = f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.offset.read = f.offset.seek
0000000000000000000000000000000000000000;;		} else if f.buf != nil {
0000000000000000000000000000000000000000;;			// f.buf + f behaves like an io.MultiReader
0000000000000000000000000000000000000000;;			n, err := f.buf.Read(b)
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				f.buf = nil // buffer has been drained
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				return n, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		body, err := f.get()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := body.Read(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.offset.read += int64(n)
0000000000000000000000000000000000000000;;		f.offset.seek += int64(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the DatastoreFile.
0000000000000000000000000000000000000000;;	func (f *DatastoreFile) Close() error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.body != nil {
0000000000000000000000000000000000000000;;			err = f.body.Close()
0000000000000000000000000000000000000000;;			f.body = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.buf = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seek sets the offset for the next Read on the DatastoreFile.
0000000000000000000000000000000000000000;;	func (f *DatastoreFile) Seek(offset int64, whence int) (int64, error) {
0000000000000000000000000000000000000000;;		switch whence {
0000000000000000000000000000000000000000;;		case io.SeekStart:
0000000000000000000000000000000000000000;;		case io.SeekCurrent:
0000000000000000000000000000000000000000;;			offset += f.offset.seek
0000000000000000000000000000000000000000;;		case io.SeekEnd:
0000000000000000000000000000000000000000;;			if f.length < 0 {
0000000000000000000000000000000000000000;;				_, err := f.Stat()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			offset += f.length
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, errors.New("Seek: invalid whence")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allow negative SeekStart for initial Range request
0000000000000000000000000000000000000000;;		if offset < 0 {
0000000000000000000000000000000000000000;;			return 0, errors.New("Seek: invalid offset")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.offset.seek = offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return offset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fileStat struct {
0000000000000000000000000000000000000000;;		file   *DatastoreFile
0000000000000000000000000000000000000000;;		header http.Header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStat) Name() string {
0000000000000000000000000000000000000000;;		return path.Base(s.file.name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStat) Size() int64 {
0000000000000000000000000000000000000000;;		return s.file.length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStat) Mode() os.FileMode {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStat) ModTime() time.Time {
0000000000000000000000000000000000000000;;		return time.Now() // no Last-Modified
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStat) IsDir() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *fileStat) Sys() interface{} {
0000000000000000000000000000000000000000;;		return s.header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func statusError(res *http.Response) error {
0000000000000000000000000000000000000000;;		if res.StatusCode == http.StatusNotFound {
0000000000000000000000000000000000000000;;			return os.ErrNotExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.New(res.Status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stat returns the os.FileInfo interface describing file.
0000000000000000000000000000000000000000;;	func (f *DatastoreFile) Stat() (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		// TODO: consider using Datastore.Stat() instead
0000000000000000000000000000000000000000;;		u, p, err := f.d.downloadTicket(f.ctx, f.name, &soap.Download{Method: "HEAD"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := f.d.Client().DownloadRequest(u, p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if res.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return nil, statusError(res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.length = res.ContentLength
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &fileStat{f, res.Header}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *DatastoreFile) get() (io.Reader, error) {
0000000000000000000000000000000000000000;;		if f.body != nil {
0000000000000000000000000000000000000000;;			return f.body, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u, p, err := f.d.downloadTicket(f.ctx, f.name, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.offset.read != 0 {
0000000000000000000000000000000000000000;;			p.Headers = map[string]string{
0000000000000000000000000000000000000000;;				"Range": fmt.Sprintf("bytes=%d-", f.offset.read),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := f.d.Client().DownloadRequest(u, p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch res.StatusCode {
0000000000000000000000000000000000000000;;		case http.StatusOK:
0000000000000000000000000000000000000000;;			f.length = res.ContentLength
0000000000000000000000000000000000000000;;		case http.StatusPartialContent:
0000000000000000000000000000000000000000;;			var start, end int
0000000000000000000000000000000000000000;;			cr := res.Header.Get("Content-Range")
0000000000000000000000000000000000000000;;			_, err = fmt.Sscanf(cr, "bytes %d-%d/%d", &start, &end, &f.length)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				f.length = -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case http.StatusRequestedRangeNotSatisfiable:
0000000000000000000000000000000000000000;;			// ok: Read() will return io.EOF
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, statusError(res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.length < 0 {
0000000000000000000000000000000000000000;;			_ = res.Body.Close()
0000000000000000000000000000000000000000;;			return nil, errors.New("unable to determine file size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.body = res.Body
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.body, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lastIndexLines(s []byte, n *int) int64 {
0000000000000000000000000000000000000000;;		i := len(s) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i > 0 {
0000000000000000000000000000000000000000;;			o := bytes.LastIndexByte(s[:i], '\n')
0000000000000000000000000000000000000000;;			if o < 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i = o
0000000000000000000000000000000000000000;;			*n--
0000000000000000000000000000000000000000;;			if *n == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return int64(i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tail seeks to the position of the last N lines of the file.
0000000000000000000000000000000000000000;;	func (f *DatastoreFile) Tail(n int) error {
0000000000000000000000000000000000000000;;		// Read the file in reverse using bsize chunks
0000000000000000000000000000000000000000;;		const bsize = int64(1024 * 16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsize, err := f.Seek(0, io.SeekEnd)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chunk := int64(-1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(make([]byte, 0, bsize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var eof bool
0000000000000000000000000000000000000000;;			var pos int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nread := bsize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			offset := chunk * bsize
0000000000000000000000000000000000000000;;			remain := fsize + offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if remain < 0 {
0000000000000000000000000000000000000000;;				if pos, err = f.Seek(0, io.SeekStart); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nread = bsize + remain
0000000000000000000000000000000000000000;;				eof = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if pos, err = f.Seek(offset, io.SeekEnd); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err = io.CopyN(buf, f, nread); err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b := buf.Bytes()
0000000000000000000000000000000000000000;;			idx := lastIndexLines(b, &n) + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				if chunk == -1 {
0000000000000000000000000000000000000000;;					// We found all N lines in the last chunk of the file.
0000000000000000000000000000000000000000;;					// The seek offset is also now at the current end of file.
0000000000000000000000000000000000000000;;					// Save this buffer to avoid another GET request when Read() is called.
0000000000000000000000000000000000000000;;					buf.Next(int(idx))
0000000000000000000000000000000000000000;;					f.buf = buf
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if _, err = f.Seek(pos+idx, io.SeekStart); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if eof {
0000000000000000000000000000000000000000;;				if remain < 0 {
0000000000000000000000000000000000000000;;					// We found < N lines in the entire file, so seek to the start.
0000000000000000000000000000000000000000;;					_, _ = f.Seek(0, io.SeekStart)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			chunk--
0000000000000000000000000000000000000000;;			buf.Reset()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type followDatastoreFile struct {
0000000000000000000000000000000000000000;;		r *DatastoreFile
0000000000000000000000000000000000000000;;		c chan struct{}
0000000000000000000000000000000000000000;;		i time.Duration
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads up to len(b) bytes from the DatastoreFile being followed.
0000000000000000000000000000000000000000;;	// This method will block until data is read, an error other than io.EOF is returned or Close() is called.
0000000000000000000000000000000000000000;;	func (f *followDatastoreFile) Read(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		offset := f.r.offset.seek
0000000000000000000000000000000000000000;;		stop := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, err := f.r.Read(p)
0000000000000000000000000000000000000000;;			if err != nil && err == io.EOF {
0000000000000000000000000000000000000000;;				_ = f.r.Close() // GET request body has been drained.
0000000000000000000000000000000000000000;;				if stop {
0000000000000000000000000000000000000000;;					return n, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-f.c:
0000000000000000000000000000000000000000;;				// Wake up and stop polling once the body has been drained
0000000000000000000000000000000000000000;;				stop = true
0000000000000000000000000000000000000000;;			case <-time.After(f.i):
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info, serr := f.r.Stat()
0000000000000000000000000000000000000000;;			if serr != nil {
0000000000000000000000000000000000000000;;				// Return EOF rather than 404 if the file goes away
0000000000000000000000000000000000000000;;				if serr == os.ErrNotExist {
0000000000000000000000000000000000000000;;					_ = f.r.Close()
0000000000000000000000000000000000000000;;					return 0, io.EOF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return 0, serr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if info.Size() < offset {
0000000000000000000000000000000000000000;;				// assume file has be truncated
0000000000000000000000000000000000000000;;				offset, err = f.r.Seek(0, io.SeekStart)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close will stop Follow polling and close the underlying DatastoreFile.
0000000000000000000000000000000000000000;;	func (f *followDatastoreFile) Close() error {
0000000000000000000000000000000000000000;;		close(f.c)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Follow returns an io.ReadCloser to stream the file contents as data is appended.
0000000000000000000000000000000000000000;;	func (f *DatastoreFile) Follow(interval time.Duration) io.ReadCloser {
0000000000000000000000000000000000000000;;		return &followDatastoreFile{f, make(chan struct{}), interval}
0000000000000000000000000000000000000000;;	}
