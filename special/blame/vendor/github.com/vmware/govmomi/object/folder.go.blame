0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/object/folder.go[Godeps/_workspace/src/github.com/vmware/govmomi/object/folder.go][vendor/github.com/vmware/govmomi/object/folder.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Folder struct {
0000000000000000000000000000000000000000;;		Common
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFolder(c *vim25.Client, ref types.ManagedObjectReference) *Folder {
0000000000000000000000000000000000000000;;		return &Folder{
0000000000000000000000000000000000000000;;			Common: NewCommon(c, ref),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRootFolder(c *vim25.Client) *Folder {
0000000000000000000000000000000000000000;;		f := NewFolder(c, c.ServiceContent.RootFolder)
0000000000000000000000000000000000000000;;		f.InventoryPath = "/"
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) Children(ctx context.Context) ([]Reference, error) {
0000000000000000000000000000000000000000;;		var mf mo.Folder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := f.Properties(ctx, f.Reference(), []string{"childEntity"}, &mf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rs []Reference
0000000000000000000000000000000000000000;;		for _, e := range mf.ChildEntity {
0000000000000000000000000000000000000000;;			if r := NewReference(f.c, e); r != nil {
0000000000000000000000000000000000000000;;				rs = append(rs, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) CreateDatacenter(ctx context.Context, datacenter string) (*Datacenter, error) {
0000000000000000000000000000000000000000;;		req := types.CreateDatacenter{
0000000000000000000000000000000000000000;;			This: f.Reference(),
0000000000000000000000000000000000000000;;			Name: datacenter,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreateDatacenter(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Response will be nil if this is an ESX host that does not belong to a vCenter
0000000000000000000000000000000000000000;;		if res == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewDatacenter(f.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) CreateCluster(ctx context.Context, cluster string, spec types.ClusterConfigSpecEx) (*ClusterComputeResource, error) {
0000000000000000000000000000000000000000;;		req := types.CreateClusterEx{
0000000000000000000000000000000000000000;;			This: f.Reference(),
0000000000000000000000000000000000000000;;			Name: cluster,
0000000000000000000000000000000000000000;;			Spec: spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreateClusterEx(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Response will be nil if this is an ESX host that does not belong to a vCenter
0000000000000000000000000000000000000000;;		if res == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewClusterComputeResource(f.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) CreateFolder(ctx context.Context, name string) (*Folder, error) {
0000000000000000000000000000000000000000;;		req := types.CreateFolder{
0000000000000000000000000000000000000000;;			This: f.Reference(),
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreateFolder(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewFolder(f.c, res.Returnval), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) CreateStoragePod(ctx context.Context, name string) (*StoragePod, error) {
0000000000000000000000000000000000000000;;		req := types.CreateStoragePod{
0000000000000000000000000000000000000000;;			This: f.Reference(),
0000000000000000000000000000000000000000;;			Name: name,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreateStoragePod(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewStoragePod(f.c, res.Returnval), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) AddStandaloneHost(ctx context.Context, spec types.HostConnectSpec, addConnected bool, license *string, compResSpec *types.BaseComputeResourceConfigSpec) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.AddStandaloneHost_Task{
0000000000000000000000000000000000000000;;			This:         f.Reference(),
0000000000000000000000000000000000000000;;			Spec:         spec,
0000000000000000000000000000000000000000;;			AddConnected: addConnected,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if license != nil {
0000000000000000000000000000000000000000;;			req.License = *license
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if compResSpec != nil {
0000000000000000000000000000000000000000;;			req.CompResSpec = *compResSpec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.AddStandaloneHost_Task(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(f.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) CreateVM(ctx context.Context, config types.VirtualMachineConfigSpec, pool *ResourcePool, host *HostSystem) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.CreateVM_Task{
0000000000000000000000000000000000000000;;			This:   f.Reference(),
0000000000000000000000000000000000000000;;			Config: config,
0000000000000000000000000000000000000000;;			Pool:   pool.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if host != nil {
0000000000000000000000000000000000000000;;			ref := host.Reference()
0000000000000000000000000000000000000000;;			req.Host = &ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreateVM_Task(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(f.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) RegisterVM(ctx context.Context, path string, name string, asTemplate bool, pool *ResourcePool, host *HostSystem) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.RegisterVM_Task{
0000000000000000000000000000000000000000;;			This:       f.Reference(),
0000000000000000000000000000000000000000;;			Path:       path,
0000000000000000000000000000000000000000;;			AsTemplate: asTemplate,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			req.Name = name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if host != nil {
0000000000000000000000000000000000000000;;			ref := host.Reference()
0000000000000000000000000000000000000000;;			req.Host = &ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pool != nil {
0000000000000000000000000000000000000000;;			ref := pool.Reference()
0000000000000000000000000000000000000000;;			req.Pool = &ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.RegisterVM_Task(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(f.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) CreateDVS(ctx context.Context, spec types.DVSCreateSpec) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.CreateDVS_Task{
0000000000000000000000000000000000000000;;			This: f.Reference(),
0000000000000000000000000000000000000000;;			Spec: spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreateDVS_Task(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(f.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f Folder) MoveInto(ctx context.Context, list []types.ManagedObjectReference) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.MoveIntoFolder_Task{
0000000000000000000000000000000000000000;;			This: f.Reference(),
0000000000000000000000000000000000000000;;			List: list,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.MoveIntoFolder_Task(ctx, f.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(f.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
