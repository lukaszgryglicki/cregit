0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2016 VMware, Inc. All Rights Reserved.
45473432028991b8b23cc5822fe045d9b6a279d6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostCertificateManager provides helper methods around the HostSystem.ConfigManager.CertificateManager
0000000000000000000000000000000000000000;;	type HostCertificateManager struct {
0000000000000000000000000000000000000000;;		Common
0000000000000000000000000000000000000000;;		Host *HostSystem
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHostCertificateManager creates a new HostCertificateManager helper
0000000000000000000000000000000000000000;;	func NewHostCertificateManager(c *vim25.Client, ref types.ManagedObjectReference, host types.ManagedObjectReference) *HostCertificateManager {
0000000000000000000000000000000000000000;;		return &HostCertificateManager{
0000000000000000000000000000000000000000;;			Common: NewCommon(c, ref),
0000000000000000000000000000000000000000;;			Host:   NewHostSystem(c, host),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertificateInfo wraps the host CertificateManager certificateInfo property with the HostCertificateInfo helper.
0000000000000000000000000000000000000000;;	// The ThumbprintSHA1 field is set to HostSystem.Summary.Config.SslThumbprint if the host system is managed by a vCenter.
0000000000000000000000000000000000000000;;	func (m HostCertificateManager) CertificateInfo(ctx context.Context) (*HostCertificateInfo, error) {
0000000000000000000000000000000000000000;;		var hs mo.HostSystem
0000000000000000000000000000000000000000;;		var cm mo.HostCertificateManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc := property.DefaultCollector(m.Client())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pc.RetrieveOne(ctx, m.Reference(), []string{"certificateInfo"}, &cm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_ = pc.RetrieveOne(ctx, m.Host.Reference(), []string{"summary.config.sslThumbprint"}, &hs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &HostCertificateInfo{
0000000000000000000000000000000000000000;;			HostCertificateManagerCertificateInfo: cm.CertificateInfo,
0000000000000000000000000000000000000000;;			ThumbprintSHA1:                        hs.Summary.Config.SslThumbprint,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateCertificateSigningRequest requests the host system to generate a certificate-signing request (CSR) for itself.
0000000000000000000000000000000000000000;;	// The CSR is then typically provided to a Certificate Authority to sign and issue the SSL certificate for the host system.
0000000000000000000000000000000000000000;;	// Use InstallServerCertificate to import this certificate.
0000000000000000000000000000000000000000;;	func (m HostCertificateManager) GenerateCertificateSigningRequest(ctx context.Context, useIPAddressAsCommonName bool) (string, error) {
0000000000000000000000000000000000000000;;		req := types.GenerateCertificateSigningRequest{
0000000000000000000000000000000000000000;;			This: m.Reference(),
0000000000000000000000000000000000000000;;			UseIpAddressAsCommonName: useIPAddressAsCommonName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.GenerateCertificateSigningRequest(ctx, m.Client(), &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.Returnval, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateCertificateSigningRequestByDn requests the host system to generate a certificate-signing request (CSR) for itself.
0000000000000000000000000000000000000000;;	// Alternative version similar to GenerateCertificateSigningRequest but takes a Distinguished Name (DN) as a parameter.
0000000000000000000000000000000000000000;;	func (m HostCertificateManager) GenerateCertificateSigningRequestByDn(ctx context.Context, distinguishedName string) (string, error) {
0000000000000000000000000000000000000000;;		req := types.GenerateCertificateSigningRequestByDn{
0000000000000000000000000000000000000000;;			This:              m.Reference(),
0000000000000000000000000000000000000000;;			DistinguishedName: distinguishedName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.GenerateCertificateSigningRequestByDn(ctx, m.Client(), &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.Returnval, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InstallServerCertificate imports the given SSL certificate to the host system.
0000000000000000000000000000000000000000;;	func (m HostCertificateManager) InstallServerCertificate(ctx context.Context, cert string) error {
0000000000000000000000000000000000000000;;		req := types.InstallServerCertificate{
0000000000000000000000000000000000000000;;			This: m.Reference(),
0000000000000000000000000000000000000000;;			Cert: cert,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.InstallServerCertificate(ctx, m.Client(), &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NotifyAffectedService is internal, not exposing as we don't have a use case other than with InstallServerCertificate
0000000000000000000000000000000000000000;;		// Without this call, hostd needs to be restarted to use the updated certificate
0000000000000000000000000000000000000000;;		// Note: using Refresh as it has the same struct/signature, we just need to use different xml name tags
0000000000000000000000000000000000000000;;		body := struct {
0000000000000000000000000000000000000000;;			Req *types.Refresh         `xml:"urn:vim25 NotifyAffectedServices,omitempty"`
0000000000000000000000000000000000000000;;			Res *types.RefreshResponse `xml:"urn:vim25 NotifyAffectedServicesResponse,omitempty"`
0000000000000000000000000000000000000000;;			methods.RefreshBody
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Req: &types.Refresh{This: m.Reference()},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.Client().RoundTrip(ctx, &body, &body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListCACertificateRevocationLists returns the SSL CRLs of Certificate Authorities that are trusted by the host system.
0000000000000000000000000000000000000000;;	func (m HostCertificateManager) ListCACertificateRevocationLists(ctx context.Context) ([]string, error) {
0000000000000000000000000000000000000000;;		req := types.ListCACertificateRevocationLists{
0000000000000000000000000000000000000000;;			This: m.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.ListCACertificateRevocationLists(ctx, m.Client(), &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.Returnval, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListCACertificates returns the SSL certificates of Certificate Authorities that are trusted by the host system.
0000000000000000000000000000000000000000;;	func (m HostCertificateManager) ListCACertificates(ctx context.Context) ([]string, error) {
0000000000000000000000000000000000000000;;		req := types.ListCACertificates{
0000000000000000000000000000000000000000;;			This: m.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.ListCACertificates(ctx, m.Client(), &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.Returnval, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceCACertificatesAndCRLs replaces the trusted CA certificates and CRL used by the host system.
0000000000000000000000000000000000000000;;	// These determine whether the server can verify the identity of an external entity.
0000000000000000000000000000000000000000;;	func (m HostCertificateManager) ReplaceCACertificatesAndCRLs(ctx context.Context, caCert []string, caCrl []string) error {
0000000000000000000000000000000000000000;;		req := types.ReplaceCACertificatesAndCRLs{
0000000000000000000000000000000000000000;;			This:   m.Reference(),
0000000000000000000000000000000000000000;;			CaCert: caCert,
0000000000000000000000000000000000000000;;			CaCrl:  caCrl,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.ReplaceCACertificatesAndCRLs(ctx, m.Client(), &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
