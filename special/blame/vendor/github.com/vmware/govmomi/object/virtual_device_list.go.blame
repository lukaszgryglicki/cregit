0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/object/virtual_device_list.go[Godeps/_workspace/src/github.com/vmware/govmomi/object/virtual_device_list.go][vendor/github.com/vmware/govmomi/object/virtual_device_list.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type values for use in BootOrder
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DeviceTypeCdrom    = "cdrom"
0000000000000000000000000000000000000000;;		DeviceTypeDisk     = "disk"
0000000000000000000000000000000000000000;;		DeviceTypeEthernet = "ethernet"
0000000000000000000000000000000000000000;;		DeviceTypeFloppy   = "floppy"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VirtualDeviceList provides helper methods for working with a list of virtual devices.
0000000000000000000000000000000000000000;;	type VirtualDeviceList []types.BaseVirtualDevice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SCSIControllerTypes are used for adding a new SCSI controller to a VM.
0000000000000000000000000000000000000000;;	func SCSIControllerTypes() VirtualDeviceList {
0000000000000000000000000000000000000000;;		// Return a mutable list of SCSI controller types, initialized with defaults.
0000000000000000000000000000000000000000;;		return VirtualDeviceList([]types.BaseVirtualDevice{
0000000000000000000000000000000000000000;;			&types.VirtualLsiLogicController{},
0000000000000000000000000000000000000000;;			&types.VirtualBusLogicController{},
0000000000000000000000000000000000000000;;			&types.ParaVirtualSCSIController{},
0000000000000000000000000000000000000000;;			&types.VirtualLsiLogicSASController{},
0000000000000000000000000000000000000000;;		}).Select(func(device types.BaseVirtualDevice) bool {
0000000000000000000000000000000000000000;;			c := device.(types.BaseVirtualSCSIController).GetVirtualSCSIController()
0000000000000000000000000000000000000000;;			c.SharedBus = types.VirtualSCSISharingNoSharing
0000000000000000000000000000000000000000;;			c.BusNumber = -1
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EthernetCardTypes are used for adding a new ethernet card to a VM.
0000000000000000000000000000000000000000;;	func EthernetCardTypes() VirtualDeviceList {
0000000000000000000000000000000000000000;;		return VirtualDeviceList([]types.BaseVirtualDevice{
0000000000000000000000000000000000000000;;			&types.VirtualE1000{},
0000000000000000000000000000000000000000;;			&types.VirtualE1000e{},
0000000000000000000000000000000000000000;;			&types.VirtualVmxnet3{},
0000000000000000000000000000000000000000;;		}).Select(func(device types.BaseVirtualDevice) bool {
0000000000000000000000000000000000000000;;			c := device.(types.BaseVirtualEthernetCard).GetVirtualEthernetCard()
0000000000000000000000000000000000000000;;			c.GetVirtualDevice().Key = -1
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Select returns a new list containing all elements of the list for which the given func returns true.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) Select(f func(device types.BaseVirtualDevice) bool) VirtualDeviceList {
0000000000000000000000000000000000000000;;		var found VirtualDeviceList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, device := range l {
0000000000000000000000000000000000000000;;			if f(device) {
0000000000000000000000000000000000000000;;				found = append(found, device)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectByType returns a new list with devices that are equal to or extend the given type.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) SelectByType(deviceType types.BaseVirtualDevice) VirtualDeviceList {
0000000000000000000000000000000000000000;;		dtype := reflect.TypeOf(deviceType)
0000000000000000000000000000000000000000;;		if dtype == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dname := dtype.Elem().Name()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l.Select(func(device types.BaseVirtualDevice) bool {
0000000000000000000000000000000000000000;;			t := reflect.TypeOf(device)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t == dtype {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, ok := t.Elem().FieldByName(dname)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectByBackingInfo returns a new list with devices matching the given backing info.
0000000000000000000000000000000000000000;;	// If the value of backing is nil, any device with a backing of the same type will be returned.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) SelectByBackingInfo(backing types.BaseVirtualDeviceBackingInfo) VirtualDeviceList {
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(backing)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l.Select(func(device types.BaseVirtualDevice) bool {
0000000000000000000000000000000000000000;;			db := device.GetVirtualDevice().Backing
0000000000000000000000000000000000000000;;			if db == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if reflect.TypeOf(db) != t {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if reflect.ValueOf(backing).IsNil() {
0000000000000000000000000000000000000000;;				// selecting by backing type
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch a := db.(type) {
0000000000000000000000000000000000000000;;			case *types.VirtualEthernetCardNetworkBackingInfo:
0000000000000000000000000000000000000000;;				b := backing.(*types.VirtualEthernetCardNetworkBackingInfo)
0000000000000000000000000000000000000000;;				return a.DeviceName == b.DeviceName
0000000000000000000000000000000000000000;;			case *types.VirtualEthernetCardDistributedVirtualPortBackingInfo:
0000000000000000000000000000000000000000;;				b := backing.(*types.VirtualEthernetCardDistributedVirtualPortBackingInfo)
0000000000000000000000000000000000000000;;				return a.Port.SwitchUuid == b.Port.SwitchUuid &&
0000000000000000000000000000000000000000;;					a.Port.PortgroupKey == b.Port.PortgroupKey
0000000000000000000000000000000000000000;;			case *types.VirtualDiskFlatVer2BackingInfo:
0000000000000000000000000000000000000000;;				b := backing.(*types.VirtualDiskFlatVer2BackingInfo)
0000000000000000000000000000000000000000;;				if a.Parent != nil && b.Parent != nil {
0000000000000000000000000000000000000000;;					return a.Parent.FileName == b.Parent.FileName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return a.FileName == b.FileName
0000000000000000000000000000000000000000;;			case *types.VirtualSerialPortURIBackingInfo:
0000000000000000000000000000000000000000;;				b := backing.(*types.VirtualSerialPortURIBackingInfo)
0000000000000000000000000000000000000000;;				return a.ServiceURI == b.ServiceURI
0000000000000000000000000000000000000000;;			case types.BaseVirtualDeviceFileBackingInfo:
0000000000000000000000000000000000000000;;				b := backing.(types.BaseVirtualDeviceFileBackingInfo)
0000000000000000000000000000000000000000;;				return a.GetVirtualDeviceFileBackingInfo().FileName == b.GetVirtualDeviceFileBackingInfo().FileName
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find returns the device matching the given name.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) Find(name string) types.BaseVirtualDevice {
0000000000000000000000000000000000000000;;		for _, device := range l {
0000000000000000000000000000000000000000;;			if l.Name(device) == name {
0000000000000000000000000000000000000000;;				return device
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindByKey returns the device matching the given key.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindByKey(key int32) types.BaseVirtualDevice {
0000000000000000000000000000000000000000;;		for _, device := range l {
0000000000000000000000000000000000000000;;			if device.GetVirtualDevice().Key == key {
0000000000000000000000000000000000000000;;				return device
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindIDEController will find the named IDE controller if given, otherwise will pick an available controller.
0000000000000000000000000000000000000000;;	// An error is returned if the named controller is not found or not an IDE controller.  Or, if name is not
0000000000000000000000000000000000000000;;	// given and no available controller can be found.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindIDEController(name string) (*types.VirtualIDEController, error) {
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			d := l.Find(name)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("device '%s' not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c, ok := d.(*types.VirtualIDEController); ok {
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not an IDE controller", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.PickController((*types.VirtualIDEController)(nil))
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("no available IDE controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.(*types.VirtualIDEController), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateIDEController creates a new IDE controller.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateIDEController() (types.BaseVirtualDevice, error) {
0000000000000000000000000000000000000000;;		ide := &types.VirtualIDEController{}
0000000000000000000000000000000000000000;;		ide.Key = l.NewKey()
0000000000000000000000000000000000000000;;		return ide, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindSCSIController will find the named SCSI controller if given, otherwise will pick an available controller.
0000000000000000000000000000000000000000;;	// An error is returned if the named controller is not found or not an SCSI controller.  Or, if name is not
0000000000000000000000000000000000000000;;	// given and no available controller can be found.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindSCSIController(name string) (*types.VirtualSCSIController, error) {
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			d := l.Find(name)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("device '%s' not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c, ok := d.(types.BaseVirtualSCSIController); ok {
0000000000000000000000000000000000000000;;				return c.GetVirtualSCSIController(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not an SCSI controller", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.PickController((*types.VirtualSCSIController)(nil))
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("no available SCSI controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.(types.BaseVirtualSCSIController).GetVirtualSCSIController(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSCSIController creates a new SCSI controller of type name if given, otherwise defaults to lsilogic.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateSCSIController(name string) (types.BaseVirtualDevice, error) {
0000000000000000000000000000000000000000;;		ctypes := SCSIControllerTypes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name == "scsi" || name == "" {
0000000000000000000000000000000000000000;;			name = ctypes.Type(ctypes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found := ctypes.Select(func(device types.BaseVirtualDevice) bool {
0000000000000000000000000000000000000000;;			return l.Type(device) == name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(found) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown SCSI controller type '%s'", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, ok := found[0].(types.BaseVirtualSCSIController)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid SCSI controller type '%s'", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scsi := c.GetVirtualSCSIController()
0000000000000000000000000000000000000000;;		scsi.BusNumber = l.newSCSIBusNumber()
0000000000000000000000000000000000000000;;		scsi.Key = l.NewKey()
0000000000000000000000000000000000000000;;		scsi.ScsiCtlrUnitNumber = 7
0000000000000000000000000000000000000000;;		return c.(types.BaseVirtualDevice), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var scsiBusNumbers = []int{0, 1, 2, 3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newSCSIBusNumber returns the bus number to use for adding a new SCSI bus device.
0000000000000000000000000000000000000000;;	// -1 is returned if there are no bus numbers available.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) newSCSIBusNumber() int32 {
0000000000000000000000000000000000000000;;		var used []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, d := range l.SelectByType((*types.VirtualSCSIController)(nil)) {
0000000000000000000000000000000000000000;;			num := d.(types.BaseVirtualSCSIController).GetVirtualSCSIController().BusNumber
0000000000000000000000000000000000000000;;			if num >= 0 {
0000000000000000000000000000000000000000;;				used = append(used, int(num))
0000000000000000000000000000000000000000;;			} // else caller is creating a new vm using SCSIControllerTypes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Ints(used)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, n := range scsiBusNumbers {
0000000000000000000000000000000000000000;;			if i == len(used) || n != used[i] {
0000000000000000000000000000000000000000;;				return int32(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindNVMEController will find the named NVME controller if given, otherwise will pick an available controller.
0000000000000000000000000000000000000000;;	// An error is returned if the named controller is not found or not an NVME controller.  Or, if name is not
0000000000000000000000000000000000000000;;	// given and no available controller can be found.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindNVMEController(name string) (*types.VirtualNVMEController, error) {
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			d := l.Find(name)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("device '%s' not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c, ok := d.(*types.VirtualNVMEController); ok {
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not an NVME controller", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.PickController((*types.VirtualNVMEController)(nil))
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("no available NVME controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.(*types.VirtualNVMEController), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateNVMEController creates a new NVMWE controller.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateNVMEController() (types.BaseVirtualDevice, error) {
0000000000000000000000000000000000000000;;		nvme := &types.VirtualNVMEController{}
0000000000000000000000000000000000000000;;		nvme.BusNumber = l.newNVMEBusNumber()
0000000000000000000000000000000000000000;;		nvme.Key = l.NewKey()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nvme, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nvmeBusNumbers = []int{0, 1, 2, 3}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newNVMEBusNumber returns the bus number to use for adding a new NVME bus device.
0000000000000000000000000000000000000000;;	// -1 is returned if there are no bus numbers available.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) newNVMEBusNumber() int32 {
0000000000000000000000000000000000000000;;		var used []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, d := range l.SelectByType((*types.VirtualNVMEController)(nil)) {
0000000000000000000000000000000000000000;;			num := d.(types.BaseVirtualController).GetVirtualController().BusNumber
0000000000000000000000000000000000000000;;			if num >= 0 {
0000000000000000000000000000000000000000;;				used = append(used, int(num))
0000000000000000000000000000000000000000;;			} // else caller is creating a new vm using NVMEControllerTypes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Ints(used)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, n := range nvmeBusNumbers {
0000000000000000000000000000000000000000;;			if i == len(used) || n != used[i] {
0000000000000000000000000000000000000000;;				return int32(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindDiskController will find an existing ide or scsi disk controller.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindDiskController(name string) (types.BaseVirtualController, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case name == "ide":
0000000000000000000000000000000000000000;;			return l.FindIDEController("")
0000000000000000000000000000000000000000;;		case name == "scsi" || name == "":
0000000000000000000000000000000000000000;;			return l.FindSCSIController("")
0000000000000000000000000000000000000000;;		case name == "nvme":
0000000000000000000000000000000000000000;;			return l.FindNVMEController("")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if c, ok := l.Find(name).(types.BaseVirtualController); ok {
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not a valid controller", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PickController returns a controller of the given type(s).
0000000000000000000000000000000000000000;;	// If no controllers are found or have no available slots, then nil is returned.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) PickController(kind types.BaseVirtualController) types.BaseVirtualController {
0000000000000000000000000000000000000000;;		l = l.SelectByType(kind.(types.BaseVirtualDevice)).Select(func(device types.BaseVirtualDevice) bool {
0000000000000000000000000000000000000000;;			num := len(device.(types.BaseVirtualController).GetVirtualController().Device)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch device.(type) {
0000000000000000000000000000000000000000;;			case types.BaseVirtualSCSIController:
0000000000000000000000000000000000000000;;				return num < 15
0000000000000000000000000000000000000000;;			case *types.VirtualIDEController:
0000000000000000000000000000000000000000;;				return num < 2
0000000000000000000000000000000000000000;;			case *types.VirtualNVMEController:
0000000000000000000000000000000000000000;;				return num < 8
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(l) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l[0].(types.BaseVirtualController)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newUnitNumber returns the unit number to use for attaching a new device to the given controller.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) newUnitNumber(c types.BaseVirtualController) int32 {
0000000000000000000000000000000000000000;;		units := make([]bool, 30)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch sc := c.(type) {
0000000000000000000000000000000000000000;;		case types.BaseVirtualSCSIController:
0000000000000000000000000000000000000000;;			//  The SCSI controller sits on its own bus
0000000000000000000000000000000000000000;;			units[sc.GetVirtualSCSIController().ScsiCtlrUnitNumber] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := c.GetVirtualController().Key
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, device := range l {
0000000000000000000000000000000000000000;;			d := device.GetVirtualDevice()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if d.ControllerKey == key && d.UnitNumber != nil {
0000000000000000000000000000000000000000;;				units[int(*d.UnitNumber)] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for unit, used := range units {
0000000000000000000000000000000000000000;;			if !used {
0000000000000000000000000000000000000000;;				return int32(unit)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewKey returns the key to use for adding a new device to the device list.
0000000000000000000000000000000000000000;;	// The device list we're working with here may not be complete (e.g. when
0000000000000000000000000000000000000000;;	// we're only adding new devices), so any positive keys could conflict with device keys
0000000000000000000000000000000000000000;;	// that are already in use. To avoid this type of conflict, we can use negative keys
0000000000000000000000000000000000000000;;	// here, which will be resolved to positive keys by vSphere as the reconfiguration is done.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) NewKey() int32 {
0000000000000000000000000000000000000000;;		var key int32 = -200
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, device := range l {
0000000000000000000000000000000000000000;;			d := device.GetVirtualDevice()
0000000000000000000000000000000000000000;;			if d.Key < key {
0000000000000000000000000000000000000000;;				key = d.Key
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return key - 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssignController assigns a device to a controller.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) AssignController(device types.BaseVirtualDevice, c types.BaseVirtualController) {
0000000000000000000000000000000000000000;;		d := device.GetVirtualDevice()
0000000000000000000000000000000000000000;;		d.ControllerKey = c.GetVirtualController().Key
0000000000000000000000000000000000000000;;		d.UnitNumber = new(int32)
0000000000000000000000000000000000000000;;		*d.UnitNumber = l.newUnitNumber(c)
0000000000000000000000000000000000000000;;		if d.Key == 0 {
0000000000000000000000000000000000000000;;			d.Key = -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateDisk creates a new VirtualDisk device which can be added to a VM.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateDisk(c types.BaseVirtualController, ds types.ManagedObjectReference, name string) *types.VirtualDisk {
0000000000000000000000000000000000000000;;		// If name is not specified, one will be chosen for you.
0000000000000000000000000000000000000000;;		// But if when given, make sure it ends in .vmdk, otherwise it will be treated as a directory.
0000000000000000000000000000000000000000;;		if len(name) > 0 && filepath.Ext(name) != ".vmdk" {
0000000000000000000000000000000000000000;;			name += ".vmdk"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		device := &types.VirtualDisk{
0000000000000000000000000000000000000000;;			VirtualDevice: types.VirtualDevice{
0000000000000000000000000000000000000000;;				Backing: &types.VirtualDiskFlatVer2BackingInfo{
0000000000000000000000000000000000000000;;					DiskMode:        string(types.VirtualDiskModePersistent),
0000000000000000000000000000000000000000;;					ThinProvisioned: types.NewBool(true),
0000000000000000000000000000000000000000;;					VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
0000000000000000000000000000000000000000;;						FileName:  name,
0000000000000000000000000000000000000000;;						Datastore: &ds,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.AssignController(device, c)
0000000000000000000000000000000000000000;;		return device
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChildDisk creates a new VirtualDisk device, linked to the given parent disk, which can be added to a VM.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) ChildDisk(parent *types.VirtualDisk) *types.VirtualDisk {
0000000000000000000000000000000000000000;;		disk := *parent
0000000000000000000000000000000000000000;;		backing := disk.Backing.(*types.VirtualDiskFlatVer2BackingInfo)
0000000000000000000000000000000000000000;;		p := new(DatastorePath)
0000000000000000000000000000000000000000;;		p.FromString(backing.FileName)
0000000000000000000000000000000000000000;;		p.Path = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use specified disk as parent backing to a new disk.
0000000000000000000000000000000000000000;;		disk.Backing = &types.VirtualDiskFlatVer2BackingInfo{
0000000000000000000000000000000000000000;;			VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
0000000000000000000000000000000000000000;;				FileName:  p.String(),
0000000000000000000000000000000000000000;;				Datastore: backing.Datastore,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Parent:          backing,
0000000000000000000000000000000000000000;;			DiskMode:        backing.DiskMode,
0000000000000000000000000000000000000000;;			ThinProvisioned: backing.ThinProvisioned,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &disk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) connectivity(device types.BaseVirtualDevice, v bool) error {
0000000000000000000000000000000000000000;;		c := device.GetVirtualDevice().Connectable
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s is not connectable", l.Name(device))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Connected = v
0000000000000000000000000000000000000000;;		c.StartConnected = v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Connect changes the device to connected, returns an error if the device is not connectable.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) Connect(device types.BaseVirtualDevice) error {
0000000000000000000000000000000000000000;;		return l.connectivity(device, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Disconnect changes the device to disconnected, returns an error if the device is not connectable.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) Disconnect(device types.BaseVirtualDevice) error {
0000000000000000000000000000000000000000;;		return l.connectivity(device, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindCdrom finds a cdrom device with the given name, defaulting to the first cdrom device if any.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindCdrom(name string) (*types.VirtualCdrom, error) {
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			d := l.Find(name)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("device '%s' not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c, ok := d.(*types.VirtualCdrom); ok {
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not a cdrom device", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.SelectByType((*types.VirtualCdrom)(nil))
0000000000000000000000000000000000000000;;		if len(c) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("no cdrom device found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c[0].(*types.VirtualCdrom), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateCdrom creates a new VirtualCdrom device which can be added to a VM.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateCdrom(c *types.VirtualIDEController) (*types.VirtualCdrom, error) {
0000000000000000000000000000000000000000;;		device := &types.VirtualCdrom{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.AssignController(device, c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.setDefaultCdromBacking(device)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		device.Connectable = &types.VirtualDeviceConnectInfo{
0000000000000000000000000000000000000000;;			AllowGuestControl: true,
0000000000000000000000000000000000000000;;			Connected:         true,
0000000000000000000000000000000000000000;;			StartConnected:    true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return device, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertIso changes the cdrom device backing to use the given iso file.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) InsertIso(device *types.VirtualCdrom, iso string) *types.VirtualCdrom {
0000000000000000000000000000000000000000;;		device.Backing = &types.VirtualCdromIsoBackingInfo{
0000000000000000000000000000000000000000;;			VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
0000000000000000000000000000000000000000;;				FileName: iso,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return device
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EjectIso removes the iso file based backing and replaces with the default cdrom backing.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) EjectIso(device *types.VirtualCdrom) *types.VirtualCdrom {
0000000000000000000000000000000000000000;;		l.setDefaultCdromBacking(device)
0000000000000000000000000000000000000000;;		return device
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) setDefaultCdromBacking(device *types.VirtualCdrom) {
0000000000000000000000000000000000000000;;		device.Backing = &types.VirtualCdromAtapiBackingInfo{
0000000000000000000000000000000000000000;;			VirtualDeviceDeviceBackingInfo: types.VirtualDeviceDeviceBackingInfo{
0000000000000000000000000000000000000000;;				DeviceName:    fmt.Sprintf("%s-%d-%d", DeviceTypeCdrom, device.ControllerKey, device.UnitNumber),
0000000000000000000000000000000000000000;;				UseAutoDetect: types.NewBool(false),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindFloppy finds a floppy device with the given name, defaulting to the first floppy device if any.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindFloppy(name string) (*types.VirtualFloppy, error) {
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			d := l.Find(name)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("device '%s' not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c, ok := d.(*types.VirtualFloppy); ok {
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not a floppy device", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.SelectByType((*types.VirtualFloppy)(nil))
0000000000000000000000000000000000000000;;		if len(c) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("no floppy device found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c[0].(*types.VirtualFloppy), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateFloppy creates a new VirtualFloppy device which can be added to a VM.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateFloppy() (*types.VirtualFloppy, error) {
0000000000000000000000000000000000000000;;		device := &types.VirtualFloppy{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.PickController((*types.VirtualSIOController)(nil))
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("no available SIO controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.AssignController(device, c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.setDefaultFloppyBacking(device)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		device.Connectable = &types.VirtualDeviceConnectInfo{
0000000000000000000000000000000000000000;;			AllowGuestControl: true,
0000000000000000000000000000000000000000;;			Connected:         true,
0000000000000000000000000000000000000000;;			StartConnected:    true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return device, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InsertImg changes the floppy device backing to use the given img file.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) InsertImg(device *types.VirtualFloppy, img string) *types.VirtualFloppy {
0000000000000000000000000000000000000000;;		device.Backing = &types.VirtualFloppyImageBackingInfo{
0000000000000000000000000000000000000000;;			VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
0000000000000000000000000000000000000000;;				FileName: img,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return device
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EjectImg removes the img file based backing and replaces with the default floppy backing.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) EjectImg(device *types.VirtualFloppy) *types.VirtualFloppy {
0000000000000000000000000000000000000000;;		l.setDefaultFloppyBacking(device)
0000000000000000000000000000000000000000;;		return device
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) setDefaultFloppyBacking(device *types.VirtualFloppy) {
0000000000000000000000000000000000000000;;		device.Backing = &types.VirtualFloppyDeviceBackingInfo{
0000000000000000000000000000000000000000;;			VirtualDeviceDeviceBackingInfo: types.VirtualDeviceDeviceBackingInfo{
0000000000000000000000000000000000000000;;				DeviceName:    fmt.Sprintf("%s-%d", DeviceTypeFloppy, device.UnitNumber),
0000000000000000000000000000000000000000;;				UseAutoDetect: types.NewBool(false),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FindSerialPort finds a serial port device with the given name, defaulting to the first serial port device if any.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) FindSerialPort(name string) (*types.VirtualSerialPort, error) {
0000000000000000000000000000000000000000;;		if name != "" {
0000000000000000000000000000000000000000;;			d := l.Find(name)
0000000000000000000000000000000000000000;;			if d == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("device '%s' not found", name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c, ok := d.(*types.VirtualSerialPort); ok {
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s is not a serial port device", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.SelectByType((*types.VirtualSerialPort)(nil))
0000000000000000000000000000000000000000;;		if len(c) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("no serial port device found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c[0].(*types.VirtualSerialPort), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSerialPort creates a new VirtualSerialPort device which can be added to a VM.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateSerialPort() (*types.VirtualSerialPort, error) {
0000000000000000000000000000000000000000;;		device := &types.VirtualSerialPort{
0000000000000000000000000000000000000000;;			YieldOnPoll: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := l.PickController((*types.VirtualSIOController)(nil))
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("no available SIO controller")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.AssignController(device, c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.setDefaultSerialPortBacking(device)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return device, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConnectSerialPort connects a serial port to a server or client uri.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) ConnectSerialPort(device *types.VirtualSerialPort, uri string, client bool, proxyuri string) *types.VirtualSerialPort {
0000000000000000000000000000000000000000;;		if strings.HasPrefix(uri, "[") {
0000000000000000000000000000000000000000;;			device.Backing = &types.VirtualSerialPortFileBackingInfo{
0000000000000000000000000000000000000000;;				VirtualDeviceFileBackingInfo: types.VirtualDeviceFileBackingInfo{
0000000000000000000000000000000000000000;;					FileName: uri,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return device
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		direction := types.VirtualDeviceURIBackingOptionDirectionServer
0000000000000000000000000000000000000000;;		if client {
0000000000000000000000000000000000000000;;			direction = types.VirtualDeviceURIBackingOptionDirectionClient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		device.Backing = &types.VirtualSerialPortURIBackingInfo{
0000000000000000000000000000000000000000;;			VirtualDeviceURIBackingInfo: types.VirtualDeviceURIBackingInfo{
0000000000000000000000000000000000000000;;				Direction:  string(direction),
0000000000000000000000000000000000000000;;				ServiceURI: uri,
0000000000000000000000000000000000000000;;				ProxyURI:   proxyuri,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return device
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DisconnectSerialPort disconnects the serial port backing.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) DisconnectSerialPort(device *types.VirtualSerialPort) *types.VirtualSerialPort {
0000000000000000000000000000000000000000;;		l.setDefaultSerialPortBacking(device)
0000000000000000000000000000000000000000;;		return device
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) setDefaultSerialPortBacking(device *types.VirtualSerialPort) {
0000000000000000000000000000000000000000;;		device.Backing = &types.VirtualSerialPortURIBackingInfo{
0000000000000000000000000000000000000000;;			VirtualDeviceURIBackingInfo: types.VirtualDeviceURIBackingInfo{
0000000000000000000000000000000000000000;;				Direction:  "client",
0000000000000000000000000000000000000000;;				ServiceURI: "localhost:0",
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateEthernetCard creates a new VirtualEthernetCard of the given name name and initialized with the given backing.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) CreateEthernetCard(name string, backing types.BaseVirtualDeviceBackingInfo) (types.BaseVirtualDevice, error) {
0000000000000000000000000000000000000000;;		ctypes := EthernetCardTypes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			name = ctypes.deviceName(ctypes[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		found := ctypes.Select(func(device types.BaseVirtualDevice) bool {
0000000000000000000000000000000000000000;;			return l.deviceName(device) == name
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(found) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown ethernet card type '%s'", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c, ok := found[0].(types.BaseVirtualEthernetCard)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid ethernet card type '%s'", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.GetVirtualEthernetCard().Backing = backing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c.(types.BaseVirtualDevice), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrimaryMacAddress returns the MacAddress field of the primary VirtualEthernetCard
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) PrimaryMacAddress() string {
0000000000000000000000000000000000000000;;		eth0 := l.Find("ethernet-0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if eth0 == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return eth0.(types.BaseVirtualEthernetCard).GetVirtualEthernetCard().MacAddress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convert a BaseVirtualDevice to a BaseVirtualMachineBootOptionsBootableDevice
0000000000000000000000000000000000000000;;	var bootableDevices = map[string]func(device types.BaseVirtualDevice) types.BaseVirtualMachineBootOptionsBootableDevice{
0000000000000000000000000000000000000000;;		DeviceTypeCdrom: func(types.BaseVirtualDevice) types.BaseVirtualMachineBootOptionsBootableDevice {
0000000000000000000000000000000000000000;;			return &types.VirtualMachineBootOptionsBootableCdromDevice{}
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		DeviceTypeDisk: func(d types.BaseVirtualDevice) types.BaseVirtualMachineBootOptionsBootableDevice {
0000000000000000000000000000000000000000;;			return &types.VirtualMachineBootOptionsBootableDiskDevice{
0000000000000000000000000000000000000000;;				DeviceKey: d.GetVirtualDevice().Key,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		DeviceTypeEthernet: func(d types.BaseVirtualDevice) types.BaseVirtualMachineBootOptionsBootableDevice {
0000000000000000000000000000000000000000;;			return &types.VirtualMachineBootOptionsBootableEthernetDevice{
0000000000000000000000000000000000000000;;				DeviceKey: d.GetVirtualDevice().Key,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		DeviceTypeFloppy: func(types.BaseVirtualDevice) types.BaseVirtualMachineBootOptionsBootableDevice {
0000000000000000000000000000000000000000;;			return &types.VirtualMachineBootOptionsBootableFloppyDevice{}
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BootOrder returns a list of devices which can be used to set boot order via VirtualMachine.SetBootOptions.
0000000000000000000000000000000000000000;;	// The order can any of "ethernet", "cdrom", "floppy" or "disk" or by specific device name.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) BootOrder(order []string) []types.BaseVirtualMachineBootOptionsBootableDevice {
0000000000000000000000000000000000000000;;		var devices []types.BaseVirtualMachineBootOptionsBootableDevice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, name := range order {
0000000000000000000000000000000000000000;;			if kind, ok := bootableDevices[name]; ok {
0000000000000000000000000000000000000000;;				for _, device := range l {
0000000000000000000000000000000000000000;;					if l.Type(device) == name {
0000000000000000000000000000000000000000;;						devices = append(devices, kind(device))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if d := l.Find(name); d != nil {
0000000000000000000000000000000000000000;;				if kind, ok := bootableDevices[l.Type(d)]; ok {
0000000000000000000000000000000000000000;;					devices = append(devices, kind(d))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return devices
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SelectBootOrder returns an ordered list of devices matching the given bootable device order
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) SelectBootOrder(order []types.BaseVirtualMachineBootOptionsBootableDevice) VirtualDeviceList {
0000000000000000000000000000000000000000;;		var devices VirtualDeviceList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, bd := range order {
0000000000000000000000000000000000000000;;			for _, device := range l {
0000000000000000000000000000000000000000;;				if kind, ok := bootableDevices[l.Type(device)]; ok {
0000000000000000000000000000000000000000;;					if reflect.DeepEqual(kind(device), bd) {
0000000000000000000000000000000000000000;;						devices = append(devices, device)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return devices
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeName returns the vmodl type name of the device
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) TypeName(device types.BaseVirtualDevice) string {
0000000000000000000000000000000000000000;;		dtype := reflect.TypeOf(device)
0000000000000000000000000000000000000000;;		if dtype == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dtype.Elem().Name()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var deviceNameRegexp = regexp.MustCompile(`(?:Virtual)?(?:Machine)?(\w+?)(?:Card|Device|Controller)?$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) deviceName(device types.BaseVirtualDevice) string {
0000000000000000000000000000000000000000;;		name := "device"
0000000000000000000000000000000000000000;;		typeName := l.TypeName(device)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := deviceNameRegexp.FindStringSubmatch(typeName)
0000000000000000000000000000000000000000;;		if len(m) == 2 {
0000000000000000000000000000000000000000;;			name = strings.ToLower(m[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns a human-readable name for the given device
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) Type(device types.BaseVirtualDevice) string {
0000000000000000000000000000000000000000;;		switch device.(type) {
0000000000000000000000000000000000000000;;		case types.BaseVirtualEthernetCard:
0000000000000000000000000000000000000000;;			return DeviceTypeEthernet
0000000000000000000000000000000000000000;;		case *types.ParaVirtualSCSIController:
0000000000000000000000000000000000000000;;			return "pvscsi"
0000000000000000000000000000000000000000;;		case *types.VirtualLsiLogicSASController:
0000000000000000000000000000000000000000;;			return "lsilogic-sas"
0000000000000000000000000000000000000000;;		case *types.VirtualNVMEController:
0000000000000000000000000000000000000000;;			return "nvme"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return l.deviceName(device)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns a stable, human-readable name for the given device
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) Name(device types.BaseVirtualDevice) string {
0000000000000000000000000000000000000000;;		var key string
0000000000000000000000000000000000000000;;		var UnitNumber int32
0000000000000000000000000000000000000000;;		d := device.GetVirtualDevice()
0000000000000000000000000000000000000000;;		if d.UnitNumber != nil {
0000000000000000000000000000000000000000;;			UnitNumber = *d.UnitNumber
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dtype := l.Type(device)
0000000000000000000000000000000000000000;;		switch dtype {
0000000000000000000000000000000000000000;;		case DeviceTypeEthernet:
0000000000000000000000000000000000000000;;			key = fmt.Sprintf("%d", UnitNumber-7)
0000000000000000000000000000000000000000;;		case DeviceTypeDisk:
0000000000000000000000000000000000000000;;			key = fmt.Sprintf("%d-%d", d.ControllerKey, UnitNumber)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			key = fmt.Sprintf("%d", d.Key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s-%s", dtype, key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfigSpec creates a virtual machine configuration spec for
0000000000000000000000000000000000000000;;	// the specified operation, for the list of devices in the device list.
0000000000000000000000000000000000000000;;	func (l VirtualDeviceList) ConfigSpec(op types.VirtualDeviceConfigSpecOperation) ([]types.BaseVirtualDeviceConfigSpec, error) {
0000000000000000000000000000000000000000;;		var fop types.VirtualDeviceConfigSpecFileOperation
0000000000000000000000000000000000000000;;		switch op {
0000000000000000000000000000000000000000;;		case types.VirtualDeviceConfigSpecOperationAdd:
0000000000000000000000000000000000000000;;			fop = types.VirtualDeviceConfigSpecFileOperationCreate
0000000000000000000000000000000000000000;;		case types.VirtualDeviceConfigSpecOperationEdit:
0000000000000000000000000000000000000000;;			fop = types.VirtualDeviceConfigSpecFileOperationReplace
0000000000000000000000000000000000000000;;		case types.VirtualDeviceConfigSpecOperationRemove:
0000000000000000000000000000000000000000;;			fop = types.VirtualDeviceConfigSpecFileOperationDestroy
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unknown op")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res []types.BaseVirtualDeviceConfigSpec
0000000000000000000000000000000000000000;;		for _, device := range l {
0000000000000000000000000000000000000000;;			config := &types.VirtualDeviceConfigSpec{
0000000000000000000000000000000000000000;;				Device:    device,
0000000000000000000000000000000000000000;;				Operation: op,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if disk, ok := device.(*types.VirtualDisk); ok {
0000000000000000000000000000000000000000;;				config.FileOperation = fop
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Special case to attach an existing disk
0000000000000000000000000000000000000000;;				if op == types.VirtualDeviceConfigSpecOperationAdd && disk.CapacityInKB == 0 {
0000000000000000000000000000000000000000;;					childDisk := false
0000000000000000000000000000000000000000;;					if b, ok := disk.Backing.(*types.VirtualDiskFlatVer2BackingInfo); ok {
0000000000000000000000000000000000000000;;						childDisk = b.Parent != nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !childDisk {
0000000000000000000000000000000000000000;;						// Existing disk, clear file operation
0000000000000000000000000000000000000000;;						config.FileOperation = ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			res = append(res, config)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
