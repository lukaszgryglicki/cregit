0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2016 VMware, Inc. All Rights Reserved.
45473432028991b8b23cc5822fe045d9b6a279d6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/tabwriter"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostCertificateInfo provides helpers for types.HostCertificateManagerCertificateInfo
0000000000000000000000000000000000000000;;	type HostCertificateInfo struct {
0000000000000000000000000000000000000000;;		types.HostCertificateManagerCertificateInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ThumbprintSHA1   string
0000000000000000000000000000000000000000;;		ThumbprintSHA256 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Err         error
0000000000000000000000000000000000000000;;		Certificate *x509.Certificate `json:"-"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subjectName *pkix.Name
0000000000000000000000000000000000000000;;		issuerName  *pkix.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromCertificate converts x509.Certificate to HostCertificateInfo
0000000000000000000000000000000000000000;;	func (info *HostCertificateInfo) FromCertificate(cert *x509.Certificate) *HostCertificateInfo {
0000000000000000000000000000000000000000;;		info.Certificate = cert
0000000000000000000000000000000000000000;;		info.subjectName = &cert.Subject
0000000000000000000000000000000000000000;;		info.issuerName = &cert.Issuer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info.Issuer = info.fromName(info.issuerName)
0000000000000000000000000000000000000000;;		info.NotBefore = &cert.NotBefore
0000000000000000000000000000000000000000;;		info.NotAfter = &cert.NotAfter
0000000000000000000000000000000000000000;;		info.Subject = info.fromName(info.subjectName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info.ThumbprintSHA1 = soap.ThumbprintSHA1(cert)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SHA-256 for info purposes only, API fields all use SHA-1
0000000000000000000000000000000000000000;;		sum := sha256.Sum256(cert.Raw)
0000000000000000000000000000000000000000;;		hex := make([]string, len(sum))
0000000000000000000000000000000000000000;;		for i, b := range sum {
0000000000000000000000000000000000000000;;			hex[i] = fmt.Sprintf("%02X", b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		info.ThumbprintSHA256 = strings.Join(hex, ":")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if info.Status == "" {
0000000000000000000000000000000000000000;;			info.Status = string(types.HostCertificateManagerCertificateInfoCertificateStatusUnknown)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromURL connects to the given URL.Host via tls.Dial with the given tls.Config and populates the HostCertificateInfo
0000000000000000000000000000000000000000;;	// via tls.ConnectionState.  If the certificate was verified with the given tls.Config, the Err field will be nil.
0000000000000000000000000000000000000000;;	// Otherwise, Err will be set to the x509.UnknownAuthorityError or x509.HostnameError.
0000000000000000000000000000000000000000;;	// If tls.Dial returns an error of any other type, that error is returned.
0000000000000000000000000000000000000000;;	func (info *HostCertificateInfo) FromURL(u *url.URL, config *tls.Config) error {
0000000000000000000000000000000000000000;;		addr := u.Host
0000000000000000000000000000000000000000;;		if !(strings.LastIndex(addr, ":") > strings.LastIndex(addr, "]")) {
0000000000000000000000000000000000000000;;			addr += ":443"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, err := tls.Dial("tcp", addr, config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			switch err.(type) {
0000000000000000000000000000000000000000;;			case x509.UnknownAuthorityError:
0000000000000000000000000000000000000000;;			case x509.HostnameError:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info.Err = err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			conn, err = tls.Dial("tcp", addr, &tls.Config{InsecureSkipVerify: true})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			info.Status = string(types.HostCertificateManagerCertificateInfoCertificateStatusGood)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		state := conn.ConnectionState()
0000000000000000000000000000000000000000;;		_ = conn.Close()
0000000000000000000000000000000000000000;;		info.FromCertificate(state.PeerCertificates[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var emailAddressOID = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 9, 1}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info *HostCertificateInfo) fromName(name *pkix.Name) string {
0000000000000000000000000000000000000000;;		var attrs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oids := map[string]string{
0000000000000000000000000000000000000000;;			emailAddressOID.String(): "emailAddress",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, attr := range name.Names {
0000000000000000000000000000000000000000;;			if key, ok := oids[attr.Type.String()]; ok {
0000000000000000000000000000000000000000;;				attrs = append(attrs, fmt.Sprintf("%s=%s", key, attr.Value))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrs = append(attrs, fmt.Sprintf("CN=%s", name.CommonName))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		add := func(key string, vals []string) {
0000000000000000000000000000000000000000;;			for _, val := range vals {
0000000000000000000000000000000000000000;;				attrs = append(attrs, fmt.Sprintf("%s=%s", key, val))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		elts := []struct {
0000000000000000000000000000000000000000;;			key string
0000000000000000000000000000000000000000;;			val []string
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			{"OU", name.OrganizationalUnit},
0000000000000000000000000000000000000000;;			{"O", name.Organization},
0000000000000000000000000000000000000000;;			{"L", name.Locality},
0000000000000000000000000000000000000000;;			{"ST", name.Province},
0000000000000000000000000000000000000000;;			{"C", name.Country},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, elt := range elts {
0000000000000000000000000000000000000000;;			add(elt.key, elt.val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(attrs, ",")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (info *HostCertificateInfo) toName(s string) *pkix.Name {
0000000000000000000000000000000000000000;;		var name pkix.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pair := range strings.Split(s, ",") {
0000000000000000000000000000000000000000;;			attr := strings.SplitN(pair, "=", 2)
0000000000000000000000000000000000000000;;			if len(attr) != 2 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v := attr[1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch strings.ToLower(attr[0]) {
0000000000000000000000000000000000000000;;			case "cn":
0000000000000000000000000000000000000000;;				name.CommonName = v
0000000000000000000000000000000000000000;;			case "ou":
0000000000000000000000000000000000000000;;				name.OrganizationalUnit = append(name.OrganizationalUnit, v)
0000000000000000000000000000000000000000;;			case "o":
0000000000000000000000000000000000000000;;				name.Organization = append(name.Organization, v)
0000000000000000000000000000000000000000;;			case "l":
0000000000000000000000000000000000000000;;				name.Locality = append(name.Locality, v)
0000000000000000000000000000000000000000;;			case "st":
0000000000000000000000000000000000000000;;				name.Province = append(name.Province, v)
0000000000000000000000000000000000000000;;			case "c":
0000000000000000000000000000000000000000;;				name.Country = append(name.Country, v)
0000000000000000000000000000000000000000;;			case "emailaddress":
0000000000000000000000000000000000000000;;				name.Names = append(name.Names, pkix.AttributeTypeAndValue{Type: emailAddressOID, Value: v})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SubjectName parses Subject into a pkix.Name
0000000000000000000000000000000000000000;;	func (info *HostCertificateInfo) SubjectName() *pkix.Name {
0000000000000000000000000000000000000000;;		if info.subjectName != nil {
0000000000000000000000000000000000000000;;			return info.subjectName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return info.toName(info.Subject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IssuerName parses Issuer into a pkix.Name
0000000000000000000000000000000000000000;;	func (info *HostCertificateInfo) IssuerName() *pkix.Name {
0000000000000000000000000000000000000000;;		if info.issuerName != nil {
0000000000000000000000000000000000000000;;			return info.issuerName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return info.toName(info.Issuer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write outputs info similar to the Chrome Certificate Viewer.
0000000000000000000000000000000000000000;;	func (info *HostCertificateInfo) Write(w io.Writer) error {
0000000000000000000000000000000000000000;;		tw := tabwriter.NewWriter(w, 2, 0, 2, ' ', 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := func(val string) string {
0000000000000000000000000000000000000000;;			if val != "" {
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "<Not Part Of Certificate>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ss := func(val []string) string {
0000000000000000000000000000000000000000;;			return s(strings.Join(val, ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := func(n *pkix.Name) {
0000000000000000000000000000000000000000;;			fmt.Fprintf(tw, "  Common Name (CN):\t%s\n", s(n.CommonName))
0000000000000000000000000000000000000000;;			fmt.Fprintf(tw, "  Organization (O):\t%s\n", ss(n.Organization))
0000000000000000000000000000000000000000;;			fmt.Fprintf(tw, "  Organizational Unit (OU):\t%s\n", ss(n.OrganizationalUnit))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := info.Status
0000000000000000000000000000000000000000;;		if info.Err != nil {
0000000000000000000000000000000000000000;;			status = fmt.Sprintf("ERROR %s", info.Err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmt.Fprintf(tw, "Certificate Status:\t%s\n", status)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(tw, "Issued To:\t")
0000000000000000000000000000000000000000;;		name(info.SubjectName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(tw, "Issued By:\t")
0000000000000000000000000000000000000000;;		name(info.IssuerName())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintln(tw, "Validity Period:\t")
0000000000000000000000000000000000000000;;		fmt.Fprintf(tw, "  Issued On:\t%s\n", info.NotBefore)
0000000000000000000000000000000000000000;;		fmt.Fprintf(tw, "  Expires On:\t%s\n", info.NotAfter)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if info.ThumbprintSHA1 != "" {
0000000000000000000000000000000000000000;;			fmt.Fprintln(tw, "Thumbprints:\t")
0000000000000000000000000000000000000000;;			if info.ThumbprintSHA256 != "" {
0000000000000000000000000000000000000000;;				fmt.Fprintf(tw, "  SHA-256 Thumbprint:\t%s\n", info.ThumbprintSHA256)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(tw, "  SHA-1 Thumbprint:\t%s\n", info.ThumbprintSHA1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tw.Flush()
0000000000000000000000000000000000000000;;	}
