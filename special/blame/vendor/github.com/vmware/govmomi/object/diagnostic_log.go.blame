0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
45473432028991b8b23cc5822fe045d9b6a279d6;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DiagnosticLog wraps DiagnosticManager.BrowseLog
0000000000000000000000000000000000000000;;	type DiagnosticLog struct {
0000000000000000000000000000000000000000;;		m DiagnosticManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Key  string
0000000000000000000000000000000000000000;;		Host *HostSystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Start int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seek to log position starting at the last nlines of the log
0000000000000000000000000000000000000000;;	func (l *DiagnosticLog) Seek(ctx context.Context, nlines int32) error {
0000000000000000000000000000000000000000;;		h, err := l.m.BrowseLog(ctx, l.Host, l.Key, math.MaxInt32, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.Start = h.LineEnd - nlines
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy log starting from l.Start to the given io.Writer
0000000000000000000000000000000000000000;;	// Returns on error or when end of log is reached.
0000000000000000000000000000000000000000;;	func (l *DiagnosticLog) Copy(ctx context.Context, w io.Writer) (int, error) {
0000000000000000000000000000000000000000;;		const max = 500 // VC max == 500, ESX max == 1000
0000000000000000000000000000000000000000;;		written := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			h, err := l.m.BrowseLog(ctx, l.Host, l.Key, l.Start, max)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, line := range h.LineText {
0000000000000000000000000000000000000000;;				n, err := fmt.Fprintln(w, line)
0000000000000000000000000000000000000000;;				written += n
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return written, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			l.Start += int32(len(h.LineText))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.Start >= h.LineEnd {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return written, nil
0000000000000000000000000000000000000000;;	}
