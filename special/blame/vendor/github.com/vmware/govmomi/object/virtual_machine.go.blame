0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/object/virtual_machine.go[Godeps/_workspace/src/github.com/vmware/govmomi/object/virtual_machine.go][vendor/github.com/vmware/govmomi/object/virtual_machine.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		PropRuntimePowerState = "summary.runtime.powerState"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type VirtualMachine struct {
0000000000000000000000000000000000000000;;		Common
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewVirtualMachine(c *vim25.Client, ref types.ManagedObjectReference) *VirtualMachine {
0000000000000000000000000000000000000000;;		return &VirtualMachine{
0000000000000000000000000000000000000000;;			Common: NewCommon(c, ref),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) PowerState(ctx context.Context) (types.VirtualMachinePowerState, error) {
0000000000000000000000000000000000000000;;		var o mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{PropRuntimePowerState}, &o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.Summary.Runtime.PowerState, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) PowerOn(ctx context.Context) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.PowerOnVM_Task{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.PowerOnVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) PowerOff(ctx context.Context) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.PowerOffVM_Task{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.PowerOffVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Reset(ctx context.Context) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.ResetVM_Task{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.ResetVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Suspend(ctx context.Context) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.SuspendVM_Task{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.SuspendVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) ShutdownGuest(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.ShutdownGuest{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.ShutdownGuest(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) RebootGuest(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.RebootGuest{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.RebootGuest(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Destroy(ctx context.Context) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.Destroy_Task{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.Destroy_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Clone(ctx context.Context, folder *Folder, name string, config types.VirtualMachineCloneSpec) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.CloneVM_Task{
0000000000000000000000000000000000000000;;			This:   v.Reference(),
0000000000000000000000000000000000000000;;			Folder: folder.Reference(),
0000000000000000000000000000000000000000;;			Name:   name,
0000000000000000000000000000000000000000;;			Spec:   config,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CloneVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Customize(ctx context.Context, spec types.CustomizationSpec) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.CustomizeVM_Task{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;			Spec: spec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CustomizeVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Relocate(ctx context.Context, config types.VirtualMachineRelocateSpec, priority types.VirtualMachineMovePriority) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.RelocateVM_Task{
0000000000000000000000000000000000000000;;			This:     v.Reference(),
0000000000000000000000000000000000000000;;			Spec:     config,
0000000000000000000000000000000000000000;;			Priority: priority,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.RelocateVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Reconfigure(ctx context.Context, config types.VirtualMachineConfigSpec) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.ReconfigVM_Task{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;			Spec: config,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.ReconfigVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) WaitForIP(ctx context.Context) (string, error) {
0000000000000000000000000000000000000000;;		var ip string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := property.DefaultCollector(v.c)
0000000000000000000000000000000000000000;;		err := property.Wait(ctx, p, v.Reference(), []string{"guest.ipAddress"}, func(pc []types.PropertyChange) bool {
0000000000000000000000000000000000000000;;			for _, c := range pc {
0000000000000000000000000000000000000000;;				if c.Name != "guest.ipAddress" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.Op != types.PropertyChangeOpAssign {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.Val == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ip = c.Val.(string)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ip, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitForNetIP waits for the VM guest.net property to report an IP address for all VM NICs.
0000000000000000000000000000000000000000;;	// Only consider IPv4 addresses if the v4 param is true.
0000000000000000000000000000000000000000;;	// By default, wait for all NICs to get an IP address, unless 1 or more device is given.
0000000000000000000000000000000000000000;;	// A device can be specified by the MAC address or the device name, e.g. "ethernet-0".
0000000000000000000000000000000000000000;;	// Returns a map with MAC address as the key and IP address list as the value.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) WaitForNetIP(ctx context.Context, v4 bool, device ...string) (map[string][]string, error) {
0000000000000000000000000000000000000000;;		macs := make(map[string][]string)
0000000000000000000000000000000000000000;;		eths := make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := property.DefaultCollector(v.c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait for all NICs to have a MacAddress, which may not be generated yet.
0000000000000000000000000000000000000000;;		err := property.Wait(ctx, p, v.Reference(), []string{"config.hardware.device"}, func(pc []types.PropertyChange) bool {
0000000000000000000000000000000000000000;;			for _, c := range pc {
0000000000000000000000000000000000000000;;				if c.Op != types.PropertyChangeOpAssign {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				devices := VirtualDeviceList(c.Val.(types.ArrayOfVirtualDevice).VirtualDevice)
0000000000000000000000000000000000000000;;				for _, d := range devices {
0000000000000000000000000000000000000000;;					if nic, ok := d.(types.BaseVirtualEthernetCard); ok {
0000000000000000000000000000000000000000;;						mac := nic.GetVirtualEthernetCard().MacAddress
0000000000000000000000000000000000000000;;						if mac == "" {
0000000000000000000000000000000000000000;;							return false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						macs[mac] = nil
0000000000000000000000000000000000000000;;						eths[devices.Name(d)] = mac
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(device) != 0 {
0000000000000000000000000000000000000000;;			// Only wait for specific NIC(s)
0000000000000000000000000000000000000000;;			macs = make(map[string][]string)
0000000000000000000000000000000000000000;;			for _, mac := range device {
0000000000000000000000000000000000000000;;				if eth, ok := eths[mac]; ok {
0000000000000000000000000000000000000000;;					mac = eth // device name, e.g. "ethernet-0"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				macs[mac] = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = property.Wait(ctx, p, v.Reference(), []string{"guest.net"}, func(pc []types.PropertyChange) bool {
0000000000000000000000000000000000000000;;			for _, c := range pc {
0000000000000000000000000000000000000000;;				if c.Op != types.PropertyChangeOpAssign {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nics := c.Val.(types.ArrayOfGuestNicInfo).GuestNicInfo
0000000000000000000000000000000000000000;;				for _, nic := range nics {
0000000000000000000000000000000000000000;;					mac := nic.MacAddress
0000000000000000000000000000000000000000;;					if mac == "" || nic.IpConfig == nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, ip := range nic.IpConfig.IpAddress {
0000000000000000000000000000000000000000;;						if _, ok := macs[mac]; !ok {
0000000000000000000000000000000000000000;;							continue // Ignore any that don't correspond to a VM device
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if v4 && net.ParseIP(ip.IpAddress).To4() == nil {
0000000000000000000000000000000000000000;;							continue // Ignore non IPv4 address
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						macs[mac] = append(macs[mac], ip.IpAddress)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, ips := range macs {
0000000000000000000000000000000000000000;;				if len(ips) == 0 {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return macs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Device returns the VirtualMachine's config.hardware.device property.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Device(ctx context.Context) (VirtualDeviceList, error) {
0000000000000000000000000000000000000000;;		var o mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{"config.hardware.device", "summary.runtime.connectionState"}, &o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Quoting the SDK doc:
0000000000000000000000000000000000000000;;		//   The virtual machine configuration is not guaranteed to be available.
0000000000000000000000000000000000000000;;		//   For example, the configuration information would be unavailable if the server
0000000000000000000000000000000000000000;;		//   is unable to access the virtual machine files on disk, and is often also unavailable
0000000000000000000000000000000000000000;;		//   during the initial phases of virtual machine creation.
0000000000000000000000000000000000000000;;		if o.Config == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%s Config is not available, connectionState=%s",
0000000000000000000000000000000000000000;;				v.Reference(), o.Summary.Runtime.ConnectionState)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return VirtualDeviceList(o.Config.Hardware.Device), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) HostSystem(ctx context.Context) (*HostSystem, error) {
0000000000000000000000000000000000000000;;		var o mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{"summary.runtime.host"}, &o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host := o.Summary.Runtime.Host
0000000000000000000000000000000000000000;;		if host == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("VM doesn't have a HostSystem")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewHostSystem(v.c, *host), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) ResourcePool(ctx context.Context) (*ResourcePool, error) {
0000000000000000000000000000000000000000;;		var o mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{"resourcePool"}, &o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rp := o.ResourcePool
0000000000000000000000000000000000000000;;		if rp == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("VM doesn't have a resourcePool")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewResourcePool(v.c, *rp), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) configureDevice(ctx context.Context, op types.VirtualDeviceConfigSpecOperation, fop types.VirtualDeviceConfigSpecFileOperation, devices ...types.BaseVirtualDevice) error {
0000000000000000000000000000000000000000;;		spec := types.VirtualMachineConfigSpec{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, device := range devices {
0000000000000000000000000000000000000000;;			config := &types.VirtualDeviceConfigSpec{
0000000000000000000000000000000000000000;;				Device:    device,
0000000000000000000000000000000000000000;;				Operation: op,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if disk, ok := device.(*types.VirtualDisk); ok {
0000000000000000000000000000000000000000;;				config.FileOperation = fop
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Special case to attach an existing disk
0000000000000000000000000000000000000000;;				if op == types.VirtualDeviceConfigSpecOperationAdd && disk.CapacityInKB == 0 {
0000000000000000000000000000000000000000;;					childDisk := false
0000000000000000000000000000000000000000;;					if b, ok := disk.Backing.(*types.VirtualDiskFlatVer2BackingInfo); ok {
0000000000000000000000000000000000000000;;						childDisk = b.Parent != nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !childDisk {
0000000000000000000000000000000000000000;;						config.FileOperation = "" // existing disk
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			spec.DeviceChange = append(spec.DeviceChange, config)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := v.Reconfigure(ctx, spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return task.Wait(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddDevice adds the given devices to the VirtualMachine
0000000000000000000000000000000000000000;;	func (v VirtualMachine) AddDevice(ctx context.Context, device ...types.BaseVirtualDevice) error {
0000000000000000000000000000000000000000;;		return v.configureDevice(ctx, types.VirtualDeviceConfigSpecOperationAdd, types.VirtualDeviceConfigSpecFileOperationCreate, device...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EditDevice edits the given (existing) devices on the VirtualMachine
0000000000000000000000000000000000000000;;	func (v VirtualMachine) EditDevice(ctx context.Context, device ...types.BaseVirtualDevice) error {
0000000000000000000000000000000000000000;;		return v.configureDevice(ctx, types.VirtualDeviceConfigSpecOperationEdit, types.VirtualDeviceConfigSpecFileOperationReplace, device...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveDevice removes the given devices on the VirtualMachine
0000000000000000000000000000000000000000;;	func (v VirtualMachine) RemoveDevice(ctx context.Context, keepFiles bool, device ...types.BaseVirtualDevice) error {
0000000000000000000000000000000000000000;;		fop := types.VirtualDeviceConfigSpecFileOperationDestroy
0000000000000000000000000000000000000000;;		if keepFiles {
0000000000000000000000000000000000000000;;			fop = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.configureDevice(ctx, types.VirtualDeviceConfigSpecOperationRemove, fop, device...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BootOptions returns the VirtualMachine's config.bootOptions property.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) BootOptions(ctx context.Context) (*types.VirtualMachineBootOptions, error) {
0000000000000000000000000000000000000000;;		var o mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{"config.bootOptions"}, &o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.Config.BootOptions, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBootOptions reconfigures the VirtualMachine with the given options.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) SetBootOptions(ctx context.Context, options *types.VirtualMachineBootOptions) error {
0000000000000000000000000000000000000000;;		spec := types.VirtualMachineConfigSpec{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.BootOptions = options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := v.Reconfigure(ctx, spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return task.Wait(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Answer answers a pending question.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Answer(ctx context.Context, id, answer string) error {
0000000000000000000000000000000000000000;;		req := types.AnswerVM{
0000000000000000000000000000000000000000;;			This:         v.Reference(),
0000000000000000000000000000000000000000;;			QuestionId:   id,
0000000000000000000000000000000000000000;;			AnswerChoice: answer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.AnswerVM(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateSnapshot creates a new snapshot of a virtual machine.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) CreateSnapshot(ctx context.Context, name string, description string, memory bool, quiesce bool) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.CreateSnapshot_Task{
0000000000000000000000000000000000000000;;			This:        v.Reference(),
0000000000000000000000000000000000000000;;			Name:        name,
0000000000000000000000000000000000000000;;			Description: description,
0000000000000000000000000000000000000000;;			Memory:      memory,
0000000000000000000000000000000000000000;;			Quiesce:     quiesce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.CreateSnapshot_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveAllSnapshot removes all snapshots of a virtual machine
0000000000000000000000000000000000000000;;	func (v VirtualMachine) RemoveAllSnapshot(ctx context.Context, consolidate *bool) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.RemoveAllSnapshots_Task{
0000000000000000000000000000000000000000;;			This:        v.Reference(),
0000000000000000000000000000000000000000;;			Consolidate: consolidate,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.RemoveAllSnapshots_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type snapshotMap map[string][]Reference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m snapshotMap) add(parent string, tree []types.VirtualMachineSnapshotTree) {
0000000000000000000000000000000000000000;;		for i, st := range tree {
0000000000000000000000000000000000000000;;			sname := st.Name
0000000000000000000000000000000000000000;;			names := []string{sname, st.Snapshot.Value}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if parent != "" {
0000000000000000000000000000000000000000;;				sname = path.Join(parent, sname)
0000000000000000000000000000000000000000;;				// Add full path as an option to resolve duplicate names
0000000000000000000000000000000000000000;;				names = append(names, sname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, name := range names {
0000000000000000000000000000000000000000;;				m[name] = append(m[name], &tree[i].Snapshot)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			m.add(sname, st.ChildSnapshotList)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findSnapshot supports snapshot lookup by name, where name can be:
0000000000000000000000000000000000000000;;	// 1) snapshot ManagedObjectReference.Value (unique)
0000000000000000000000000000000000000000;;	// 2) snapshot name (may not be unique)
0000000000000000000000000000000000000000;;	// 3) snapshot tree path (may not be unique)
0000000000000000000000000000000000000000;;	func (v VirtualMachine) findSnapshot(ctx context.Context, name string) (Reference, error) {
0000000000000000000000000000000000000000;;		var o mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{"snapshot"}, &o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.Snapshot == nil || len(o.Snapshot.RootSnapshotList) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("No snapshots for this VM")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := make(snapshotMap)
0000000000000000000000000000000000000000;;		m.add("", o.Snapshot.RootSnapshotList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := m[name]
0000000000000000000000000000000000000000;;		switch len(s) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("snapshot %q not found", name)
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return s[0], nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("%q resolves to %d snapshots", name, len(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveSnapshot removes a named snapshot
0000000000000000000000000000000000000000;;	func (v VirtualMachine) RemoveSnapshot(ctx context.Context, name string, removeChildren bool, consolidate *bool) (*Task, error) {
0000000000000000000000000000000000000000;;		snapshot, err := v.findSnapshot(ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RemoveSnapshot_Task{
0000000000000000000000000000000000000000;;			This:           snapshot.Reference(),
0000000000000000000000000000000000000000;;			RemoveChildren: removeChildren,
0000000000000000000000000000000000000000;;			Consolidate:    consolidate,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.RemoveSnapshot_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RevertToCurrentSnapshot reverts to the current snapshot
0000000000000000000000000000000000000000;;	func (v VirtualMachine) RevertToCurrentSnapshot(ctx context.Context, suppressPowerOn bool) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.RevertToCurrentSnapshot_Task{
0000000000000000000000000000000000000000;;			This:            v.Reference(),
0000000000000000000000000000000000000000;;			SuppressPowerOn: types.NewBool(suppressPowerOn),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.RevertToCurrentSnapshot_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RevertToSnapshot reverts to a named snapshot
0000000000000000000000000000000000000000;;	func (v VirtualMachine) RevertToSnapshot(ctx context.Context, name string, suppressPowerOn bool) (*Task, error) {
0000000000000000000000000000000000000000;;		snapshot, err := v.findSnapshot(ctx, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.RevertToSnapshot_Task{
0000000000000000000000000000000000000000;;			This:            snapshot.Reference(),
0000000000000000000000000000000000000000;;			SuppressPowerOn: types.NewBool(suppressPowerOn),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.RevertToSnapshot_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsToolsRunning returns true if VMware Tools is currently running in the guest OS, and false otherwise.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) IsToolsRunning(ctx context.Context) (bool, error) {
0000000000000000000000000000000000000000;;		var o mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{"guest.toolsRunningStatus"}, &o)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.Guest.ToolsRunningStatus == string(types.VirtualMachineToolsRunningStatusGuestToolsRunning), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for the VirtualMachine to change to the desired power state.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) WaitForPowerState(ctx context.Context, state types.VirtualMachinePowerState) error {
0000000000000000000000000000000000000000;;		p := property.DefaultCollector(v.c)
0000000000000000000000000000000000000000;;		err := property.Wait(ctx, p, v.Reference(), []string{PropRuntimePowerState}, func(pc []types.PropertyChange) bool {
0000000000000000000000000000000000000000;;			for _, c := range pc {
0000000000000000000000000000000000000000;;				if c.Name != PropRuntimePowerState {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.Val == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ps := c.Val.(types.VirtualMachinePowerState)
0000000000000000000000000000000000000000;;				if ps == state {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) MarkAsTemplate(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.MarkAsTemplate{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.MarkAsTemplate(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) MarkAsVirtualMachine(ctx context.Context, pool ResourcePool, host *HostSystem) error {
0000000000000000000000000000000000000000;;		req := types.MarkAsVirtualMachine{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;			Pool: pool.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if host != nil {
0000000000000000000000000000000000000000;;			ref := host.Reference()
0000000000000000000000000000000000000000;;			req.Host = &ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.MarkAsVirtualMachine(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Migrate(ctx context.Context, pool *ResourcePool, host *HostSystem, priority types.VirtualMachineMovePriority, state types.VirtualMachinePowerState) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.MigrateVM_Task{
0000000000000000000000000000000000000000;;			This:     v.Reference(),
0000000000000000000000000000000000000000;;			Priority: priority,
0000000000000000000000000000000000000000;;			State:    state,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if pool != nil {
0000000000000000000000000000000000000000;;			ref := pool.Reference()
0000000000000000000000000000000000000000;;			req.Pool = &ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if host != nil {
0000000000000000000000000000000000000000;;			ref := host.Reference()
0000000000000000000000000000000000000000;;			req.Host = &ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.MigrateVM_Task(ctx, v.c, &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) Unregister(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.UnregisterVM{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.UnregisterVM(ctx, v.Client(), &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryEnvironmentBrowser is a helper to get the environmentBrowser property.
0000000000000000000000000000000000000000;;	func (v VirtualMachine) QueryConfigTarget(ctx context.Context) (*types.ConfigTarget, error) {
0000000000000000000000000000000000000000;;		var vm mo.VirtualMachine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := v.Properties(ctx, v.Reference(), []string{"environmentBrowser"}, &vm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req := types.QueryConfigTarget{
0000000000000000000000000000000000000000;;			This: vm.EnvironmentBrowser,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.QueryConfigTarget(ctx, v.Client(), &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.Returnval, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) MountToolsInstaller(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.MountToolsInstaller{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.MountToolsInstaller(ctx, v.Client(), &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) UnmountToolsInstaller(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.UnmountToolsInstaller{
0000000000000000000000000000000000000000;;			This: v.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.UnmountToolsInstaller(ctx, v.Client(), &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v VirtualMachine) UpgradeTools(ctx context.Context, options string) (*Task, error) {
0000000000000000000000000000000000000000;;		req := types.UpgradeTools_Task{
0000000000000000000000000000000000000000;;			This:             v.Reference(),
0000000000000000000000000000000000000000;;			InstallerOptions: options,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := methods.UpgradeTools_Task(ctx, v.Client(), &req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewTask(v.c, res.Returnval), nil
0000000000000000000000000000000000000000;;	}
