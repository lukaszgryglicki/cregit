0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2017 VMware, Inc. All Rights Reserved.
f6ad395f98e8f42c981d72ea247db1a4edb07eff;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DatastoreFileManager combines FileManager and VirtualDiskManager to manage files on a Datastore
0000000000000000000000000000000000000000;;	type DatastoreFileManager struct {
0000000000000000000000000000000000000000;;		Datacenter         *Datacenter
0000000000000000000000000000000000000000;;		Datastore          *Datastore
0000000000000000000000000000000000000000;;		FileManager        *FileManager
0000000000000000000000000000000000000000;;		VirtualDiskManager *VirtualDiskManager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Force bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFileManager creates a new instance of DatastoreFileManager
0000000000000000000000000000000000000000;;	func (d Datastore) NewFileManager(dc *Datacenter, force bool) *DatastoreFileManager {
0000000000000000000000000000000000000000;;		c := d.Client()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := &DatastoreFileManager{
0000000000000000000000000000000000000000;;			Datacenter:         dc,
0000000000000000000000000000000000000000;;			Datastore:          &d,
0000000000000000000000000000000000000000;;			FileManager:        NewFileManager(c),
0000000000000000000000000000000000000000;;			VirtualDiskManager: NewVirtualDiskManager(c),
0000000000000000000000000000000000000000;;			Force:              force,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete dispatches to the appropriate Delete method based on file name extension
0000000000000000000000000000000000000000;;	func (m *DatastoreFileManager) Delete(ctx context.Context, name string) error {
0000000000000000000000000000000000000000;;		switch path.Ext(name) {
0000000000000000000000000000000000000000;;		case ".vmdk":
0000000000000000000000000000000000000000;;			return m.DeleteVirtualDisk(ctx, name)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return m.DeleteFile(ctx, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteFile calls FileManager.DeleteDatastoreFile
0000000000000000000000000000000000000000;;	func (m *DatastoreFileManager) DeleteFile(ctx context.Context, name string) error {
0000000000000000000000000000000000000000;;		p := m.Path(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := m.FileManager.DeleteDatastoreFile(ctx, p.String(), m.Datacenter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return task.Wait(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteVirtualDisk calls VirtualDiskManager.DeleteVirtualDisk
0000000000000000000000000000000000000000;;	// Regardless of the Datastore type, DeleteVirtualDisk will fail if 'ddb.deletable=false',
0000000000000000000000000000000000000000;;	// so if Force=true this method attempts to set 'ddb.deletable=true' before starting the delete task.
0000000000000000000000000000000000000000;;	func (m *DatastoreFileManager) DeleteVirtualDisk(ctx context.Context, name string) error {
0000000000000000000000000000000000000000;;		p := m.Path(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var merr error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.Force {
0000000000000000000000000000000000000000;;			merr = m.markDiskAsDeletable(ctx, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		task, err := m.VirtualDiskManager.DeleteVirtualDisk(ctx, p.String(), m.Datacenter)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Printf("markDiskAsDeletable(%s): %s", p, merr)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return task.Wait(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path converts path name to a DatastorePath
0000000000000000000000000000000000000000;;	func (m *DatastoreFileManager) Path(name string) *DatastorePath {
0000000000000000000000000000000000000000;;		var p DatastorePath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !p.FromString(name) {
0000000000000000000000000000000000000000;;			p.Path = name
0000000000000000000000000000000000000000;;			p.Datastore = m.Datastore.Name()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *DatastoreFileManager) markDiskAsDeletable(ctx context.Context, path *DatastorePath) error {
0000000000000000000000000000000000000000;;		r, _, err := m.Datastore.Download(ctx, path.Path, &soap.DefaultDownload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer r.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasFlag := false
0000000000000000000000000000000000000000;;		buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := bufio.NewScanner(&io.LimitedReader{R: r, N: 2048}) // should be only a few hundred bytes, limit to be sure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for s.Scan() {
0000000000000000000000000000000000000000;;			line := s.Text()
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "ddb.deletable") {
0000000000000000000000000000000000000000;;				hasFlag = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fmt.Fprintln(buf, line)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := s.Err(); err != nil {
0000000000000000000000000000000000000000;;			return err // any error other than EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !hasFlag {
0000000000000000000000000000000000000000;;			return nil // already deletable, so leave as-is
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rewrite the .vmdk with ddb.deletable flag removed (the default is true)
0000000000000000000000000000000000000000;;		return m.Datastore.Upload(ctx, buf, path.Path, &soap.DefaultUpload)
0000000000000000000000000000000000000000;;	}
