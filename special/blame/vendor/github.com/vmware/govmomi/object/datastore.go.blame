0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015-2016 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/object/datastore.go[Godeps/_workspace/src/github.com/vmware/govmomi/object/datastore.go][vendor/github.com/vmware/govmomi/object/datastore.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/session"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/soap"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DatastoreNoSuchDirectoryError is returned when a directory could not be found.
0000000000000000000000000000000000000000;;	type DatastoreNoSuchDirectoryError struct {
0000000000000000000000000000000000000000;;		verb    string
0000000000000000000000000000000000000000;;		subject string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e DatastoreNoSuchDirectoryError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("cannot %s '%s': No such directory", e.verb, e.subject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DatastoreNoSuchFileError is returned when a file could not be found.
0000000000000000000000000000000000000000;;	type DatastoreNoSuchFileError struct {
0000000000000000000000000000000000000000;;		verb    string
0000000000000000000000000000000000000000;;		subject string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e DatastoreNoSuchFileError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("cannot %s '%s': No such file", e.verb, e.subject)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Datastore struct {
0000000000000000000000000000000000000000;;		Common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DatacenterPath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewDatastore(c *vim25.Client, ref types.ManagedObjectReference) *Datastore {
0000000000000000000000000000000000000000;;		return &Datastore{
0000000000000000000000000000000000000000;;			Common: NewCommon(c, ref),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Datastore) Path(path string) string {
0000000000000000000000000000000000000000;;		return (&DatastorePath{
0000000000000000000000000000000000000000;;			Datastore: d.Name(),
0000000000000000000000000000000000000000;;			Path:      path,
0000000000000000000000000000000000000000;;		}).String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewURL constructs a url.URL with the given file path for datastore access over HTTP.
0000000000000000000000000000000000000000;;	func (d Datastore) NewURL(path string) *url.URL {
0000000000000000000000000000000000000000;;		u := d.c.URL()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &url.URL{
0000000000000000000000000000000000000000;;			Scheme: u.Scheme,
0000000000000000000000000000000000000000;;			Host:   u.Host,
0000000000000000000000000000000000000000;;			Path:   fmt.Sprintf("/folder/%s", path),
0000000000000000000000000000000000000000;;			RawQuery: url.Values{
0000000000000000000000000000000000000000;;				"dcPath": []string{d.DatacenterPath},
0000000000000000000000000000000000000000;;				"dsName": []string{d.Name()},
0000000000000000000000000000000000000000;;			}.Encode(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URL is deprecated, use NewURL instead.
0000000000000000000000000000000000000000;;	func (d Datastore) URL(ctx context.Context, dc *Datacenter, path string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		return d.NewURL(path), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Datastore) Browser(ctx context.Context) (*HostDatastoreBrowser, error) {
0000000000000000000000000000000000000000;;		var do mo.Datastore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := d.Properties(ctx, d.Reference(), []string{"browser"}, &do)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewHostDatastoreBrowser(d.c, do.Browser), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Datastore) useServiceTicket() bool {
0000000000000000000000000000000000000000;;		// If connected to workstation, service ticketing not supported
0000000000000000000000000000000000000000;;		// If connected to ESX, service ticketing not needed
0000000000000000000000000000000000000000;;		if !d.c.IsVC() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := "GOVMOMI_USE_SERVICE_TICKET"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val := d.c.URL().Query().Get(key)
0000000000000000000000000000000000000000;;		if val == "" {
0000000000000000000000000000000000000000;;			val = os.Getenv(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val == "1" || val == "true" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Datastore) useServiceTicketHostName(name string) bool {
0000000000000000000000000000000000000000;;		// No need if talking directly to ESX.
0000000000000000000000000000000000000000;;		if !d.c.IsVC() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If version happens to be < 5.1
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the HostSystem is using DHCP on a network without dynamic DNS,
0000000000000000000000000000000000000000;;		// HostSystem.Config.Network.DnsConfig.HostName is set to "localhost" by default.
0000000000000000000000000000000000000000;;		// This resolves to "localhost.localdomain" by default via /etc/hosts on ESX.
0000000000000000000000000000000000000000;;		// In that case, we will stick with the HostSystem.Name which is the IP address that
0000000000000000000000000000000000000000;;		// was used to connect the host to VC.
0000000000000000000000000000000000000000;;		if name == "localhost.localdomain" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Still possible to have HostName that don't resolve via DNS,
0000000000000000000000000000000000000000;;		// so we default to false.
0000000000000000000000000000000000000000;;		key := "GOVMOMI_USE_SERVICE_TICKET_HOSTNAME"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val := d.c.URL().Query().Get(key)
0000000000000000000000000000000000000000;;		if val == "" {
0000000000000000000000000000000000000000;;			val = os.Getenv(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val == "1" || val == "true" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type datastoreServiceTicketHostKey struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostContext returns a Context where the given host will be used for datastore HTTP access
0000000000000000000000000000000000000000;;	// via the ServiceTicket method.
0000000000000000000000000000000000000000;;	func (d Datastore) HostContext(ctx context.Context, host *HostSystem) context.Context {
0000000000000000000000000000000000000000;;		return context.WithValue(ctx, datastoreServiceTicketHostKey{}, host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceTicket obtains a ticket via AcquireGenericServiceTicket and returns it an http.Cookie with the url.URL
0000000000000000000000000000000000000000;;	// that can be used along with the ticket cookie to access the given path.  An host is chosen at random unless the
0000000000000000000000000000000000000000;;	// the given Context was created with a specific host via the HostContext method.
0000000000000000000000000000000000000000;;	func (d Datastore) ServiceTicket(ctx context.Context, path string, method string) (*url.URL, *http.Cookie, error) {
0000000000000000000000000000000000000000;;		u := d.NewURL(path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		host, ok := ctx.Value(datastoreServiceTicketHostKey{}).(*HostSystem)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			if !d.useServiceTicket() {
0000000000000000000000000000000000000000;;				return u, nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hosts, err := d.AttachedHosts(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(hosts) == 0 {
0000000000000000000000000000000000000000;;				// Fallback to letting vCenter choose a host
0000000000000000000000000000000000000000;;				return u, nil, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Pick a random attached host
0000000000000000000000000000000000000000;;			host = hosts[rand.Intn(len(hosts))]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ips, err := host.ManagementIPs(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ips) > 0 {
0000000000000000000000000000000000000000;;			// prefer a ManagementIP
0000000000000000000000000000000000000000;;			u.Host = ips[0].String()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// fallback to inventory name
0000000000000000000000000000000000000000;;			u.Host, err = host.ObjectName(ctx)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VC datacenter path will not be valid against ESX
0000000000000000000000000000000000000000;;		q := u.Query()
0000000000000000000000000000000000000000;;		delete(q, "dcPath")
0000000000000000000000000000000000000000;;		u.RawQuery = q.Encode()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec := types.SessionManagerHttpServiceRequestSpec{
0000000000000000000000000000000000000000;;			Url: u.String(),
0000000000000000000000000000000000000000;;			// See SessionManagerHttpServiceRequestSpecMethod enum
0000000000000000000000000000000000000000;;			Method: fmt.Sprintf("http%s%s", method[0:1], strings.ToLower(method[1:])),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sm := session.NewManager(d.Client())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ticket, err := sm.AcquireGenericServiceTicket(ctx, &spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cookie := &http.Cookie{
0000000000000000000000000000000000000000;;			Name:  "vmware_cgi_ticket",
0000000000000000000000000000000000000000;;			Value: ticket.Id,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.useServiceTicketHostName(ticket.HostName) {
0000000000000000000000000000000000000000;;			u.Host = ticket.HostName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.Client().SetThumbprint(u.Host, ticket.SslThumbprint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u, cookie, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Datastore) uploadTicket(ctx context.Context, path string, param *soap.Upload) (*url.URL, *soap.Upload, error) {
0000000000000000000000000000000000000000;;		p := soap.DefaultUpload
0000000000000000000000000000000000000000;;		if param != nil {
0000000000000000000000000000000000000000;;			p = *param // copy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u, ticket, err := d.ServiceTicket(ctx, path, p.Method)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.Ticket = ticket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u, &p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Datastore) downloadTicket(ctx context.Context, path string, param *soap.Download) (*url.URL, *soap.Download, error) {
0000000000000000000000000000000000000000;;		p := soap.DefaultDownload
0000000000000000000000000000000000000000;;		if param != nil {
0000000000000000000000000000000000000000;;			p = *param // copy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u, ticket, err := d.ServiceTicket(ctx, path, p.Method)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.Ticket = ticket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return u, &p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Upload via soap.Upload with an http service ticket
0000000000000000000000000000000000000000;;	func (d Datastore) Upload(ctx context.Context, f io.Reader, path string, param *soap.Upload) error {
0000000000000000000000000000000000000000;;		u, p, err := d.uploadTicket(ctx, path, param)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.Client().Upload(f, u, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UploadFile via soap.Upload with an http service ticket
0000000000000000000000000000000000000000;;	func (d Datastore) UploadFile(ctx context.Context, file string, path string, param *soap.Upload) error {
0000000000000000000000000000000000000000;;		u, p, err := d.uploadTicket(ctx, path, param)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.Client().UploadFile(file, u, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Download via soap.Download with an http service ticket
0000000000000000000000000000000000000000;;	func (d Datastore) Download(ctx context.Context, path string, param *soap.Download) (io.ReadCloser, int64, error) {
0000000000000000000000000000000000000000;;		u, p, err := d.downloadTicket(ctx, path, param)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.Client().Download(u, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DownloadFile via soap.Download with an http service ticket
0000000000000000000000000000000000000000;;	func (d Datastore) DownloadFile(ctx context.Context, path string, file string, param *soap.Download) error {
0000000000000000000000000000000000000000;;		u, p, err := d.downloadTicket(ctx, path, param)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.Client().DownloadFile(file, u, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachedHosts returns hosts that have this Datastore attached, accessible and writable.
0000000000000000000000000000000000000000;;	func (d Datastore) AttachedHosts(ctx context.Context) ([]*HostSystem, error) {
0000000000000000000000000000000000000000;;		var ds mo.Datastore
0000000000000000000000000000000000000000;;		var hosts []*HostSystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pc := property.DefaultCollector(d.Client())
0000000000000000000000000000000000000000;;		err := pc.RetrieveOne(ctx, d.Reference(), []string{"host"}, &ds)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mounts := make(map[types.ManagedObjectReference]types.DatastoreHostMount)
0000000000000000000000000000000000000000;;		var refs []types.ManagedObjectReference
0000000000000000000000000000000000000000;;		for _, host := range ds.Host {
0000000000000000000000000000000000000000;;			refs = append(refs, host.Key)
0000000000000000000000000000000000000000;;			mounts[host.Key] = host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hs []mo.HostSystem
0000000000000000000000000000000000000000;;		err = pc.Retrieve(ctx, refs, []string{"runtime.connectionState", "runtime.powerState"}, &hs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, host := range hs {
0000000000000000000000000000000000000000;;			if host.Runtime.ConnectionState == types.HostSystemConnectionStateConnected &&
0000000000000000000000000000000000000000;;				host.Runtime.PowerState == types.HostSystemPowerStatePoweredOn {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				mount := mounts[host.Reference()]
0000000000000000000000000000000000000000;;				info := mount.MountInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if *info.Mounted && *info.Accessible && info.AccessMode == string(types.HostMountModeReadWrite) {
0000000000000000000000000000000000000000;;					hosts = append(hosts, NewHostSystem(d.Client(), mount.Key))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hosts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttachedClusterHosts returns hosts that have this Datastore attached, accessible and writable and are members of the given cluster.
0000000000000000000000000000000000000000;;	func (d Datastore) AttachedClusterHosts(ctx context.Context, cluster *ComputeResource) ([]*HostSystem, error) {
0000000000000000000000000000000000000000;;		var hosts []*HostSystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clusterHosts, err := cluster.Hosts(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attachedHosts, err := d.AttachedHosts(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refs := make(map[types.ManagedObjectReference]bool)
0000000000000000000000000000000000000000;;		for _, host := range attachedHosts {
0000000000000000000000000000000000000000;;			refs[host.Reference()] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, host := range clusterHosts {
0000000000000000000000000000000000000000;;			if refs[host.Reference()] {
0000000000000000000000000000000000000000;;				hosts = append(hosts, host)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hosts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Datastore) Stat(ctx context.Context, file string) (types.BaseFileInfo, error) {
0000000000000000000000000000000000000000;;		b, err := d.Browser(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec := types.HostDatastoreBrowserSearchSpec{
0000000000000000000000000000000000000000;;			Details: &types.FileQueryFlags{
0000000000000000000000000000000000000000;;				FileType:     true,
0000000000000000000000000000000000000000;;				FileSize:     true,
0000000000000000000000000000000000000000;;				Modification: true,
0000000000000000000000000000000000000000;;				FileOwner:    types.NewBool(true),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			MatchPattern: []string{path.Base(file)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dsPath := d.Path(path.Dir(file))
0000000000000000000000000000000000000000;;		task, err := b.SearchDatastore(ctx, dsPath, &spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := task.WaitForResult(ctx, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if info == nil || info.Error != nil {
0000000000000000000000000000000000000000;;				_, ok := info.Error.Fault.(*types.FileNotFound)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					// FileNotFound means the base path doesn't exist.
0000000000000000000000000000000000000000;;					return nil, DatastoreNoSuchDirectoryError{"stat", dsPath}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := info.Result.(types.HostDatastoreBrowserSearchResults)
0000000000000000000000000000000000000000;;		if len(res.File) == 0 {
0000000000000000000000000000000000000000;;			// File doesn't exist
0000000000000000000000000000000000000000;;			return nil, DatastoreNoSuchFileError{"stat", d.Path(file)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res.File[0], nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type returns the type of file system volume.
0000000000000000000000000000000000000000;;	func (d Datastore) Type(ctx context.Context) (types.HostFileSystemVolumeFileSystemType, error) {
0000000000000000000000000000000000000000;;		var mds mo.Datastore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := d.Properties(ctx, d.Reference(), []string{"summary.type"}, &mds); err != nil {
0000000000000000000000000000000000000000;;			return types.HostFileSystemVolumeFileSystemType(""), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return types.HostFileSystemVolumeFileSystemType(mds.Summary.Type), nil
0000000000000000000000000000000000000000;;	}
