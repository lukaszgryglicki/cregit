0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2015 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/object/host_firewall_system.go[Godeps/_workspace/src/github.com/vmware/govmomi/object/host_firewall_system.go][vendor/github.com/vmware/govmomi/object/host_firewall_system.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package object
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/methods"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HostFirewallSystem struct {
0000000000000000000000000000000000000000;;		Common
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewHostFirewallSystem(c *vim25.Client, ref types.ManagedObjectReference) *HostFirewallSystem {
0000000000000000000000000000000000000000;;		return &HostFirewallSystem{
0000000000000000000000000000000000000000;;			Common: NewCommon(c, ref),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s HostFirewallSystem) DisableRuleset(ctx context.Context, id string) error {
0000000000000000000000000000000000000000;;		req := types.DisableRuleset{
0000000000000000000000000000000000000000;;			This: s.Reference(),
0000000000000000000000000000000000000000;;			Id:   id,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.DisableRuleset(ctx, s.c, &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s HostFirewallSystem) EnableRuleset(ctx context.Context, id string) error {
0000000000000000000000000000000000000000;;		req := types.EnableRuleset{
0000000000000000000000000000000000000000;;			This: s.Reference(),
0000000000000000000000000000000000000000;;			Id:   id,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.EnableRuleset(ctx, s.c, &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s HostFirewallSystem) Refresh(ctx context.Context) error {
0000000000000000000000000000000000000000;;		req := types.RefreshFirewall{
0000000000000000000000000000000000000000;;			This: s.Reference(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err := methods.RefreshFirewall(ctx, s.c, &req)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s HostFirewallSystem) Info(ctx context.Context) (*types.HostFirewallInfo, error) {
0000000000000000000000000000000000000000;;		var fs mo.HostFirewallSystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := s.Properties(ctx, s.Reference(), []string{"firewallInfo"}, &fs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fs.FirewallInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostFirewallRulesetList provides helpers for a slice of types.HostFirewallRuleset
0000000000000000000000000000000000000000;;	type HostFirewallRulesetList []types.HostFirewallRuleset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByRule returns a HostFirewallRulesetList where Direction, PortType and Protocol are equal and Port is within range
0000000000000000000000000000000000000000;;	func (l HostFirewallRulesetList) ByRule(rule types.HostFirewallRule) HostFirewallRulesetList {
0000000000000000000000000000000000000000;;		var matches HostFirewallRulesetList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rs := range l {
0000000000000000000000000000000000000000;;			for _, r := range rs.Rule {
0000000000000000000000000000000000000000;;				if r.PortType != rule.PortType ||
0000000000000000000000000000000000000000;;					r.Protocol != rule.Protocol ||
0000000000000000000000000000000000000000;;					r.Direction != rule.Direction {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if r.EndPort == 0 && rule.Port == r.Port ||
0000000000000000000000000000000000000000;;					rule.Port >= r.Port && rule.Port <= r.EndPort {
0000000000000000000000000000000000000000;;					matches = append(matches, rs)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnabledByRule returns a HostFirewallRulesetList with Match(rule) applied and filtered via Enabled()
0000000000000000000000000000000000000000;;	// if enabled param is true, otherwise filtered via Disabled().
0000000000000000000000000000000000000000;;	// An error is returned if the resulting list is empty.
0000000000000000000000000000000000000000;;	func (l HostFirewallRulesetList) EnabledByRule(rule types.HostFirewallRule, enabled bool) (HostFirewallRulesetList, error) {
0000000000000000000000000000000000000000;;		var matched, skipped HostFirewallRulesetList
0000000000000000000000000000000000000000;;		var matchedKind, skippedKind string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l = l.ByRule(rule)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if enabled {
0000000000000000000000000000000000000000;;			matched = l.Enabled()
0000000000000000000000000000000000000000;;			matchedKind = "enabled"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			skipped = l.Disabled()
0000000000000000000000000000000000000000;;			skippedKind = "disabled"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			matched = l.Disabled()
0000000000000000000000000000000000000000;;			matchedKind = "disabled"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			skipped = l.Enabled()
0000000000000000000000000000000000000000;;			skippedKind = "enabled"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(matched) == 0 {
0000000000000000000000000000000000000000;;			msg := fmt.Sprintf("%d %s firewall rulesets match %s %s %s %d, %d %s rulesets match",
0000000000000000000000000000000000000000;;				len(matched), matchedKind,
0000000000000000000000000000000000000000;;				rule.Direction, rule.Protocol, rule.PortType, rule.Port,
0000000000000000000000000000000000000000;;				len(skipped), skippedKind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(skipped) != 0 {
0000000000000000000000000000000000000000;;				msg += fmt.Sprintf(": %s", strings.Join(skipped.Keys(), ", "))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, errors.New(msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matched, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enabled returns a HostFirewallRulesetList with enabled rules
0000000000000000000000000000000000000000;;	func (l HostFirewallRulesetList) Enabled() HostFirewallRulesetList {
0000000000000000000000000000000000000000;;		var matches HostFirewallRulesetList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rs := range l {
0000000000000000000000000000000000000000;;			if rs.Enabled {
0000000000000000000000000000000000000000;;				matches = append(matches, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Disabled returns a HostFirewallRulesetList with disabled rules
0000000000000000000000000000000000000000;;	func (l HostFirewallRulesetList) Disabled() HostFirewallRulesetList {
0000000000000000000000000000000000000000;;		var matches HostFirewallRulesetList
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rs := range l {
0000000000000000000000000000000000000000;;			if !rs.Enabled {
0000000000000000000000000000000000000000;;				matches = append(matches, rs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matches
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns the HostFirewallRuleset.Key for each ruleset in the list
0000000000000000000000000000000000000000;;	func (l HostFirewallRulesetList) Keys() []string {
0000000000000000000000000000000000000000;;		var keys []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rs := range l {
0000000000000000000000000000000000000000;;			keys = append(keys, rs.Key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
