0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014-2017 VMware, Inc. All Rights Reserved.
7dd1f486ff5c2ccadc83b845ee9a4cebfa98c85d;Godeps/_workspace/src/github.com/vmware/govmomi/find/finder.go[Godeps/_workspace/src/github.com/vmware/govmomi/find/finder.go][vendor/github.com/vmware/govmomi/find/finder.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package find
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/list"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/object"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Finder struct {
0000000000000000000000000000000000000000;;		client  *vim25.Client
0000000000000000000000000000000000000000;;		r       recurser
0000000000000000000000000000000000000000;;		dc      *object.Datacenter
0000000000000000000000000000000000000000;;		si      *object.SearchIndex
0000000000000000000000000000000000000000;;		folders *object.DatacenterFolders
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFinder(client *vim25.Client, all bool) *Finder {
0000000000000000000000000000000000000000;;		f := &Finder{
0000000000000000000000000000000000000000;;			client: client,
0000000000000000000000000000000000000000;;			si:     object.NewSearchIndex(client),
0000000000000000000000000000000000000000;;			r: recurser{
0000000000000000000000000000000000000000;;				Collector: property.DefaultCollector(client),
0000000000000000000000000000000000000000;;				All:       all,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) SetDatacenter(dc *object.Datacenter) *Finder {
0000000000000000000000000000000000000000;;		f.dc = dc
0000000000000000000000000000000000000000;;		f.folders = nil
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findRoot makes it possible to use "find" mode with a different root path.
0000000000000000000000000000000000000000;;	// Example: ResourcePoolList("/dc1/host/cluster1/...")
0000000000000000000000000000000000000000;;	func (f *Finder) findRoot(ctx context.Context, root *list.Element, parts []string) bool {
0000000000000000000000000000000000000000;;		if len(parts) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ix := len(parts) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parts[ix] != "..." {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ix == 0 {
0000000000000000000000000000000000000000;;			return true // We already have the Object for root.Path
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lookup the Object for the new root.Path
0000000000000000000000000000000000000000;;		rootPath := path.Join(root.Path, path.Join(parts[:ix]...))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ref, err := f.si.FindByInventoryPath(ctx, rootPath)
0000000000000000000000000000000000000000;;		if err != nil || ref == nil {
0000000000000000000000000000000000000000;;			// If we get an error or fail to match, fall through to find() with the original root and path
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		root.Path = rootPath
0000000000000000000000000000000000000000;;		root.Object = ref
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) find(ctx context.Context, arg string, s *spec) ([]list.Element, error) {
0000000000000000000000000000000000000000;;		isPath := strings.Contains(arg, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		root := list.Element{
0000000000000000000000000000000000000000;;			Path:   "/",
0000000000000000000000000000000000000000;;			Object: object.NewRootFolder(f.client),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := list.ToParts(arg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parts) > 0 {
0000000000000000000000000000000000000000;;			switch parts[0] {
0000000000000000000000000000000000000000;;			case "..": // Not supported; many edge case, little value
0000000000000000000000000000000000000000;;				return nil, errors.New("cannot traverse up a tree")
0000000000000000000000000000000000000000;;			case ".": // Relative to whatever
0000000000000000000000000000000000000000;;				pivot, err := s.Relative(ctx)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				mes, err := mo.Ancestors(ctx, f.client, f.client.ServiceContent.PropertyCollector, pivot.Reference())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, me := range mes {
0000000000000000000000000000000000000000;;					// Skip root entity in building inventory path.
0000000000000000000000000000000000000000;;					if me.Parent == nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					root.Path = path.Join(root.Path, me.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				root.Object = pivot
0000000000000000000000000000000000000000;;				parts = parts[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.listMode(isPath) {
0000000000000000000000000000000000000000;;			if f.findRoot(ctx, &root, parts) {
0000000000000000000000000000000000000000;;				parts = []string{"*"}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return f.r.List(ctx, s, root, parts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.Parents = append(s.Parents, s.Nested...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.r.Find(ctx, s, root, parts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) datacenter() (*object.Datacenter, error) {
0000000000000000000000000000000000000000;;		if f.dc == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("please specify a datacenter")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.dc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// datacenterPath returns the absolute path to the Datacenter containing the given ref
0000000000000000000000000000000000000000;;	func (f *Finder) datacenterPath(ctx context.Context, ref types.ManagedObjectReference) (string, error) {
0000000000000000000000000000000000000000;;		mes, err := mo.Ancestors(ctx, f.client, f.client.ServiceContent.PropertyCollector, ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Chop leaves under the Datacenter
0000000000000000000000000000000000000000;;		for i := len(mes) - 1; i > 0; i-- {
0000000000000000000000000000000000000000;;			if mes[i].Self.Type == "Datacenter" {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mes = mes[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var p string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, me := range mes {
0000000000000000000000000000000000000000;;			// Skip root entity in building inventory path.
0000000000000000000000000000000000000000;;			if me.Parent == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p = p + "/" + me.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) dcFolders(ctx context.Context) (*object.DatacenterFolders, error) {
0000000000000000000000000000000000000000;;		if f.folders != nil {
0000000000000000000000000000000000000000;;			return f.folders, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dc, err := f.datacenter()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		folders, err := dc.Folders(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.folders = folders
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.folders, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) dcReference(_ context.Context) (object.Reference, error) {
0000000000000000000000000000000000000000;;		dc, err := f.datacenter()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) vmFolder(ctx context.Context) (object.Reference, error) {
0000000000000000000000000000000000000000;;		folders, err := f.dcFolders(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return folders.VmFolder, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) hostFolder(ctx context.Context) (object.Reference, error) {
0000000000000000000000000000000000000000;;		folders, err := f.dcFolders(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return folders.HostFolder, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) datastoreFolder(ctx context.Context) (object.Reference, error) {
0000000000000000000000000000000000000000;;		folders, err := f.dcFolders(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return folders.DatastoreFolder, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) networkFolder(ctx context.Context) (object.Reference, error) {
0000000000000000000000000000000000000000;;		folders, err := f.dcFolders(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return folders.NetworkFolder, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) rootFolder(_ context.Context) (object.Reference, error) {
0000000000000000000000000000000000000000;;		return object.NewRootFolder(f.client), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) managedObjectList(ctx context.Context, path string, tl bool, include []string) ([]list.Element, error) {
0000000000000000000000000000000000000000;;		fn := f.rootFolder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.dc != nil {
0000000000000000000000000000000000000000;;			fn = f.dcReference
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			path = "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: fn,
0000000000000000000000000000000000000000;;			Parents:  []string{"ComputeResource", "ClusterComputeResource", "HostSystem", "VirtualApp", "StoragePod"},
0000000000000000000000000000000000000000;;			Include:  include,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tl {
0000000000000000000000000000000000000000;;			s.Contents = true
0000000000000000000000000000000000000000;;			s.ListMode = types.NewBool(true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.find(ctx, path, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Element returns an Element for the given ManagedObjectReference
0000000000000000000000000000000000000000;;	// This method is only useful for looking up the InventoryPath of a ManagedObjectReference.
0000000000000000000000000000000000000000;;	func (f *Finder) Element(ctx context.Context, ref types.ManagedObjectReference) (*list.Element, error) {
0000000000000000000000000000000000000000;;		rl := func(_ context.Context) (object.Reference, error) {
0000000000000000000000000000000000000000;;			return ref, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: rl,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		e, err := f.find(ctx, "./", s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(e) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{ref.Type, ref.Value}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(e) > 1 {
0000000000000000000000000000000000000000;;			panic("ManagedObjectReference must be unique")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &e[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectReference converts the given ManagedObjectReference to a type from the object package via object.NewReference
0000000000000000000000000000000000000000;;	// with the object.Common.InventoryPath field set.
0000000000000000000000000000000000000000;;	func (f *Finder) ObjectReference(ctx context.Context, ref types.ManagedObjectReference) (object.Reference, error) {
0000000000000000000000000000000000000000;;		e, err := f.Element(ctx, ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := object.NewReference(f.client, ref)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type common interface {
0000000000000000000000000000000000000000;;			SetInventoryPath(string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.(common).SetInventoryPath(e.Path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.dc != nil {
0000000000000000000000000000000000000000;;			if ds, ok := r.(*object.Datastore); ok {
0000000000000000000000000000000000000000;;				ds.DatacenterPath = f.dc.InventoryPath
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ManagedObjectList(ctx context.Context, path string, include ...string) ([]list.Element, error) {
0000000000000000000000000000000000000000;;		return f.managedObjectList(ctx, path, false, include)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ManagedObjectListChildren(ctx context.Context, path string, include ...string) ([]list.Element, error) {
0000000000000000000000000000000000000000;;		return f.managedObjectList(ctx, path, true, include)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DatacenterList(ctx context.Context, path string) ([]*object.Datacenter, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.rootFolder,
0000000000000000000000000000000000000000;;			Include:  []string{"Datacenter"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dcs []*object.Datacenter
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			ref := e.Object.Reference()
0000000000000000000000000000000000000000;;			if ref.Type == "Datacenter" {
0000000000000000000000000000000000000000;;				dc := object.NewDatacenter(f.client, ref)
0000000000000000000000000000000000000000;;				dc.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				dcs = append(dcs, dc)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dcs) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"datacenter", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dcs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) Datacenter(ctx context.Context, path string) (*object.Datacenter, error) {
0000000000000000000000000000000000000000;;		dcs, err := f.DatacenterList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dcs) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"datacenter", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dcs[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultDatacenter(ctx context.Context) (*object.Datacenter, error) {
0000000000000000000000000000000000000000;;		dc, err := f.Datacenter(ctx, "*")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DatacenterOrDefault(ctx context.Context, path string) (*object.Datacenter, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			dc, err := f.Datacenter(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.DefaultDatacenter(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DatastoreList(ctx context.Context, path string) ([]*object.Datastore, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.datastoreFolder,
0000000000000000000000000000000000000000;;			Parents:  []string{"StoragePod"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dss []*object.Datastore
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			ref := e.Object.Reference()
0000000000000000000000000000000000000000;;			if ref.Type == "Datastore" {
0000000000000000000000000000000000000000;;				ds := object.NewDatastore(f.client, ref)
0000000000000000000000000000000000000000;;				ds.InventoryPath = e.Path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if f.dc == nil {
0000000000000000000000000000000000000000;;					// In this case SetDatacenter was not called and path is absolute
0000000000000000000000000000000000000000;;					ds.DatacenterPath, err = f.datacenterPath(ctx, ref)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ds.DatacenterPath = f.dc.InventoryPath
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dss = append(dss, ds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dss) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"datastore", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dss, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) Datastore(ctx context.Context, path string) (*object.Datastore, error) {
0000000000000000000000000000000000000000;;		dss, err := f.DatastoreList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dss) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"datastore", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dss[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultDatastore(ctx context.Context) (*object.Datastore, error) {
0000000000000000000000000000000000000000;;		ds, err := f.Datastore(ctx, "*")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ds, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DatastoreOrDefault(ctx context.Context, path string) (*object.Datastore, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			ds, err := f.Datastore(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ds, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.DefaultDatastore(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DatastoreClusterList(ctx context.Context, path string) ([]*object.StoragePod, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.datastoreFolder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var sps []*object.StoragePod
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			ref := e.Object.Reference()
0000000000000000000000000000000000000000;;			if ref.Type == "StoragePod" {
0000000000000000000000000000000000000000;;				sp := object.NewStoragePod(f.client, ref)
0000000000000000000000000000000000000000;;				sp.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				sps = append(sps, sp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(sps) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"datastore cluster", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sps, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DatastoreCluster(ctx context.Context, path string) (*object.StoragePod, error) {
0000000000000000000000000000000000000000;;		sps, err := f.DatastoreClusterList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(sps) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"datastore cluster", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sps[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultDatastoreCluster(ctx context.Context) (*object.StoragePod, error) {
0000000000000000000000000000000000000000;;		sp, err := f.DatastoreCluster(ctx, "*")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DatastoreClusterOrDefault(ctx context.Context, path string) (*object.StoragePod, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			sp, err := f.DatastoreCluster(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.DefaultDatastoreCluster(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ComputeResourceList(ctx context.Context, path string) ([]*object.ComputeResource, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.hostFolder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var crs []*object.ComputeResource
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			var cr *object.ComputeResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch o := e.Object.(type) {
0000000000000000000000000000000000000000;;			case mo.ComputeResource, mo.ClusterComputeResource:
0000000000000000000000000000000000000000;;				cr = object.NewComputeResource(f.client, o.Reference())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cr.InventoryPath = e.Path
0000000000000000000000000000000000000000;;			crs = append(crs, cr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(crs) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"compute resource", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return crs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ComputeResource(ctx context.Context, path string) (*object.ComputeResource, error) {
0000000000000000000000000000000000000000;;		crs, err := f.ComputeResourceList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(crs) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"compute resource", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return crs[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultComputeResource(ctx context.Context) (*object.ComputeResource, error) {
0000000000000000000000000000000000000000;;		cr, err := f.ComputeResource(ctx, "*")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ComputeResourceOrDefault(ctx context.Context, path string) (*object.ComputeResource, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			cr, err := f.ComputeResource(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cr, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.DefaultComputeResource(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ClusterComputeResourceList(ctx context.Context, path string) ([]*object.ClusterComputeResource, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.hostFolder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ccrs []*object.ClusterComputeResource
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			var ccr *object.ClusterComputeResource
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch o := e.Object.(type) {
0000000000000000000000000000000000000000;;			case mo.ClusterComputeResource:
0000000000000000000000000000000000000000;;				ccr = object.NewClusterComputeResource(f.client, o.Reference())
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ccr.InventoryPath = e.Path
0000000000000000000000000000000000000000;;			ccrs = append(ccrs, ccr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ccrs) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"cluster", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ccrs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ClusterComputeResource(ctx context.Context, path string) (*object.ClusterComputeResource, error) {
0000000000000000000000000000000000000000;;		ccrs, err := f.ClusterComputeResourceList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ccrs) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"cluster", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ccrs[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) HostSystemList(ctx context.Context, path string) ([]*object.HostSystem, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.hostFolder,
0000000000000000000000000000000000000000;;			Parents:  []string{"ComputeResource", "ClusterComputeResource"},
0000000000000000000000000000000000000000;;			Include:  []string{"HostSystem"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hss []*object.HostSystem
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			var hs *object.HostSystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch o := e.Object.(type) {
0000000000000000000000000000000000000000;;			case mo.HostSystem:
0000000000000000000000000000000000000000;;				hs = object.NewHostSystem(f.client, o.Reference())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				hs.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				hss = append(hss, hs)
0000000000000000000000000000000000000000;;			case mo.ComputeResource, mo.ClusterComputeResource:
0000000000000000000000000000000000000000;;				cr := object.NewComputeResource(f.client, o.Reference())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				cr.InventoryPath = e.Path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				hosts, err := cr.Hosts(ctx)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				hss = append(hss, hosts...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(hss) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"host", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hss, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) HostSystem(ctx context.Context, path string) (*object.HostSystem, error) {
0000000000000000000000000000000000000000;;		hss, err := f.HostSystemList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(hss) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"host", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hss[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultHostSystem(ctx context.Context) (*object.HostSystem, error) {
0000000000000000000000000000000000000000;;		hs, err := f.HostSystem(ctx, "*/*")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) HostSystemOrDefault(ctx context.Context, path string) (*object.HostSystem, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			hs, err := f.HostSystem(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return hs, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.DefaultHostSystem(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) NetworkList(ctx context.Context, path string) ([]object.NetworkReference, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.networkFolder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ns []object.NetworkReference
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			ref := e.Object.Reference()
0000000000000000000000000000000000000000;;			switch ref.Type {
0000000000000000000000000000000000000000;;			case "Network":
0000000000000000000000000000000000000000;;				r := object.NewNetwork(f.client, ref)
0000000000000000000000000000000000000000;;				r.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				ns = append(ns, r)
0000000000000000000000000000000000000000;;			case "OpaqueNetwork":
0000000000000000000000000000000000000000;;				r := object.NewOpaqueNetwork(f.client, ref)
0000000000000000000000000000000000000000;;				r.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				ns = append(ns, r)
0000000000000000000000000000000000000000;;			case "DistributedVirtualPortgroup":
0000000000000000000000000000000000000000;;				r := object.NewDistributedVirtualPortgroup(f.client, ref)
0000000000000000000000000000000000000000;;				r.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				ns = append(ns, r)
0000000000000000000000000000000000000000;;			case "DistributedVirtualSwitch", "VmwareDistributedVirtualSwitch":
0000000000000000000000000000000000000000;;				r := object.NewDistributedVirtualSwitch(f.client, ref)
0000000000000000000000000000000000000000;;				r.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				ns = append(ns, r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ns) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"network", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ns, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) Network(ctx context.Context, path string) (object.NetworkReference, error) {
0000000000000000000000000000000000000000;;		networks, err := f.NetworkList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(networks) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"network", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return networks[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultNetwork(ctx context.Context) (object.NetworkReference, error) {
0000000000000000000000000000000000000000;;		network, err := f.Network(ctx, "*")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return network, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) NetworkOrDefault(ctx context.Context, path string) (object.NetworkReference, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			network, err := f.Network(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return network, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.DefaultNetwork(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ResourcePoolList(ctx context.Context, path string) ([]*object.ResourcePool, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.hostFolder,
0000000000000000000000000000000000000000;;			Parents:  []string{"ComputeResource", "ClusterComputeResource", "VirtualApp"},
0000000000000000000000000000000000000000;;			Nested:   []string{"ResourcePool"},
0000000000000000000000000000000000000000;;			Contents: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rps []*object.ResourcePool
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			var rp *object.ResourcePool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch o := e.Object.(type) {
0000000000000000000000000000000000000000;;			case mo.ResourcePool:
0000000000000000000000000000000000000000;;				rp = object.NewResourcePool(f.client, o.Reference())
0000000000000000000000000000000000000000;;				rp.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				rps = append(rps, rp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rps) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"resource pool", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rps, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ResourcePool(ctx context.Context, path string) (*object.ResourcePool, error) {
0000000000000000000000000000000000000000;;		rps, err := f.ResourcePoolList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rps) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"resource pool", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rps[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultResourcePool(ctx context.Context) (*object.ResourcePool, error) {
0000000000000000000000000000000000000000;;		rp, err := f.ResourcePool(ctx, "*/Resources")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) ResourcePoolOrDefault(ctx context.Context, path string) (*object.ResourcePool, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			rp, err := f.ResourcePool(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rp, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f.DefaultResourcePool(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResourcePoolListAll combines ResourcePoolList and VirtualAppList
0000000000000000000000000000000000000000;;	// VirtualAppList is only called if ResourcePoolList does not find any pools with the given path.
0000000000000000000000000000000000000000;;	func (f *Finder) ResourcePoolListAll(ctx context.Context, path string) ([]*object.ResourcePool, error) {
0000000000000000000000000000000000000000;;		pools, err := f.ResourcePoolList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if _, ok := err.(*NotFoundError); !ok {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			vapps, _ := f.VirtualAppList(ctx, path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(vapps) == 0 {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, vapp := range vapps {
0000000000000000000000000000000000000000;;				pools = append(pools, vapp.ResourcePool)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pools, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) DefaultFolder(ctx context.Context) (*object.Folder, error) {
0000000000000000000000000000000000000000;;		ref, err := f.vmFolder(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, toDefaultError(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		folder := object.NewFolder(f.client, ref.Reference())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return folder, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) FolderOrDefault(ctx context.Context, path string) (*object.Folder, error) {
0000000000000000000000000000000000000000;;		if path != "" {
0000000000000000000000000000000000000000;;			folder, err := f.Folder(ctx, path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return folder, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.DefaultFolder(ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) VirtualMachineList(ctx context.Context, path string) ([]*object.VirtualMachine, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.vmFolder,
0000000000000000000000000000000000000000;;			Parents:  []string{"VirtualApp"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var vms []*object.VirtualMachine
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			switch o := e.Object.(type) {
0000000000000000000000000000000000000000;;			case mo.VirtualMachine:
0000000000000000000000000000000000000000;;				vm := object.NewVirtualMachine(f.client, o.Reference())
0000000000000000000000000000000000000000;;				vm.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				vms = append(vms, vm)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(vms) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"vm", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vms, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) VirtualMachine(ctx context.Context, path string) (*object.VirtualMachine, error) {
0000000000000000000000000000000000000000;;		vms, err := f.VirtualMachineList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(vms) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"vm", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vms[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) VirtualAppList(ctx context.Context, path string) ([]*object.VirtualApp, error) {
0000000000000000000000000000000000000000;;		s := &spec{
0000000000000000000000000000000000000000;;			Relative: f.vmFolder,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		es, err := f.find(ctx, path, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var apps []*object.VirtualApp
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			switch o := e.Object.(type) {
0000000000000000000000000000000000000000;;			case mo.VirtualApp:
0000000000000000000000000000000000000000;;				app := object.NewVirtualApp(f.client, o.Reference())
0000000000000000000000000000000000000000;;				app.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				apps = append(apps, app)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(apps) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"app", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return apps, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) VirtualApp(ctx context.Context, path string) (*object.VirtualApp, error) {
0000000000000000000000000000000000000000;;		apps, err := f.VirtualAppList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(apps) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"app", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return apps[0], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) FolderList(ctx context.Context, path string) ([]*object.Folder, error) {
0000000000000000000000000000000000000000;;		es, err := f.ManagedObjectList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var folders []*object.Folder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, e := range es {
0000000000000000000000000000000000000000;;			switch o := e.Object.(type) {
0000000000000000000000000000000000000000;;			case mo.Folder, mo.StoragePod:
0000000000000000000000000000000000000000;;				folder := object.NewFolder(f.client, o.Reference())
0000000000000000000000000000000000000000;;				folder.InventoryPath = e.Path
0000000000000000000000000000000000000000;;				folders = append(folders, folder)
0000000000000000000000000000000000000000;;			case *object.Folder:
0000000000000000000000000000000000000000;;				// RootFolder
0000000000000000000000000000000000000000;;				folders = append(folders, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(folders) == 0 {
0000000000000000000000000000000000000000;;			return nil, &NotFoundError{"folder", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return folders, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Finder) Folder(ctx context.Context, path string) (*object.Folder, error) {
0000000000000000000000000000000000000000;;		folders, err := f.FolderList(ctx, path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(folders) > 1 {
0000000000000000000000000000000000000000;;			return nil, &MultipleFoundError{"folder", path}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return folders[0], nil
0000000000000000000000000000000000000000;;	}
