0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright (c) 2014-2017 VMware, Inc. All Rights Reserved.
f6ad395f98e8f42c981d72ea247db1a4edb07eff;;	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package find
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"context"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/list"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/object"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/property"
0000000000000000000000000000000000000000;;		"github.com/vmware/govmomi/vim25/mo"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// spec is used to specify per-search configuration, independent of the Finder instance.
0000000000000000000000000000000000000000;;	type spec struct {
0000000000000000000000000000000000000000;;		// Relative returns the root object to resolve Relative paths (starts with ".")
0000000000000000000000000000000000000000;;		Relative func(ctx context.Context) (object.Reference, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ListMode can be used to optionally force "ls" behavior, rather than "find" behavior
0000000000000000000000000000000000000000;;		ListMode *bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Contents configures the Recurser to list the Contents of traversable leaf nodes.
0000000000000000000000000000000000000000;;		// This is typically set to true when used from the ls command, where listing
0000000000000000000000000000000000000000;;		// a folder means listing its Contents. This is typically set to false for
0000000000000000000000000000000000000000;;		// commands that take managed entities that are not folders as input.
0000000000000000000000000000000000000000;;		Contents bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parents specifies the types which can contain the child types being searched for.
0000000000000000000000000000000000000000;;		// for example, when searching for a HostSystem, parent types can be
0000000000000000000000000000000000000000;;		// "ComputeResource" or "ClusterComputeResource".
0000000000000000000000000000000000000000;;		Parents []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Include specifies which types to be included in the results, used only in "find" mode.
0000000000000000000000000000000000000000;;		Include []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nested should be set to types that can be Nested, used only in "find" mode.
0000000000000000000000000000000000000000;;		Nested []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ChildType avoids traversing into folders that can't contain the Include types, used only in "find" mode.
0000000000000000000000000000000000000000;;		ChildType []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *spec) traversable(o mo.Reference) bool {
0000000000000000000000000000000000000000;;		ref := o.Reference()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch ref.Type {
0000000000000000000000000000000000000000;;		case "Datacenter":
0000000000000000000000000000000000000000;;			if len(s.Include) == 1 && s.Include[0] == "Datacenter" {
0000000000000000000000000000000000000000;;				// No point in traversing deeper as Datacenters cannot be nested
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case "Folder":
0000000000000000000000000000000000000000;;			if f, ok := o.(mo.Folder); ok {
0000000000000000000000000000000000000000;;				// TODO: Not making use of this yet, but here we can optimize when searching the entire
0000000000000000000000000000000000000000;;				// inventory across Datacenters for specific types, for example: 'govc ls -t VirtualMachine /**'
0000000000000000000000000000000000000000;;				// should not traverse into a Datacenter's host, network or datatore folders.
0000000000000000000000000000000000000000;;				if !s.traversableChildType(f.ChildType) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, kind := range s.Parents {
0000000000000000000000000000000000000000;;			if kind == ref.Type {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *spec) traversableChildType(ctypes []string) bool {
0000000000000000000000000000000000000000;;		if len(s.ChildType) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, t := range ctypes {
0000000000000000000000000000000000000000;;			for _, c := range s.ChildType {
0000000000000000000000000000000000000000;;				if t == c {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *spec) wanted(e list.Element) bool {
0000000000000000000000000000000000000000;;		if len(s.Include) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := e.Object.Reference().Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, kind := range s.Include {
0000000000000000000000000000000000000000;;			if w == kind {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listMode is a global option to revert to the original Finder behavior,
0000000000000000000000000000000000000000;;	// disabling the newer "find" mode.
0000000000000000000000000000000000000000;;	var listMode = os.Getenv("GOVMOMI_FINDER_LIST_MODE") == "true"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *spec) listMode(isPath bool) bool {
0000000000000000000000000000000000000000;;		if listMode {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.ListMode != nil {
0000000000000000000000000000000000000000;;			return *s.ListMode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return isPath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type recurser struct {
0000000000000000000000000000000000000000;;		Collector *property.Collector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All configures the recurses to fetch complete objects for leaf nodes.
0000000000000000000000000000000000000000;;		All bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r recurser) List(ctx context.Context, s *spec, root list.Element, parts []string) ([]list.Element, error) {
0000000000000000000000000000000000000000;;		if len(parts) == 0 {
0000000000000000000000000000000000000000;;			// Include non-traversable leaf elements in result. For example, consider
0000000000000000000000000000000000000000;;			// the pattern "./vm/my-vm-*", where the pattern should match the VMs and
0000000000000000000000000000000000000000;;			// not try to traverse them.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Include traversable leaf elements in result, if the contents
0000000000000000000000000000000000000000;;			// field is set to false.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			if !s.Contents || !s.traversable(root.Object.Reference()) {
0000000000000000000000000000000000000000;;				return []list.Element{root}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k := list.Lister{
0000000000000000000000000000000000000000;;			Collector: r.Collector,
0000000000000000000000000000000000000000;;			Reference: root.Object.Reference(),
0000000000000000000000000000000000000000;;			Prefix:    root.Path,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.All && len(parts) < 2 {
0000000000000000000000000000000000000000;;			k.All = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in, err := k.List(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This folder is a leaf as far as the glob goes.
0000000000000000000000000000000000000000;;		if len(parts) == 0 {
0000000000000000000000000000000000000000;;			return in, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pattern := parts[0]
0000000000000000000000000000000000000000;;		parts = parts[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out []list.Element
0000000000000000000000000000000000000000;;		for _, e := range in {
0000000000000000000000000000000000000000;;			matched, err := path.Match(pattern, path.Base(e.Path))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !matched {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			nres, err := r.List(ctx, s, e, parts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out = append(out, nres...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r recurser) Find(ctx context.Context, s *spec, root list.Element, parts []string) ([]list.Element, error) {
0000000000000000000000000000000000000000;;		var out []list.Element
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parts) > 0 {
0000000000000000000000000000000000000000;;			pattern := parts[0]
0000000000000000000000000000000000000000;;			matched, err := path.Match(pattern, path.Base(root.Path))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if matched && s.wanted(root) {
0000000000000000000000000000000000000000;;				out = append(out, root)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !s.traversable(root.Object) {
0000000000000000000000000000000000000000;;			return out, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k := list.Lister{
0000000000000000000000000000000000000000;;			Collector: r.Collector,
0000000000000000000000000000000000000000;;			Reference: root.Object.Reference(),
0000000000000000000000000000000000000000;;			Prefix:    root.Path,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in, err := k.List(ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, e := range in {
0000000000000000000000000000000000000000;;			nres, err := r.Find(ctx, s, e, parts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out = append(out, nres...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
