0000000000000000000000000000000000000000;;	package semver
1f43719c213ccfaed6fd1444ddf5ced3e458064e;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wildcardType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		noneWildcard  wildcardType = iota
0000000000000000000000000000000000000000;;		majorWildcard wildcardType = 1
0000000000000000000000000000000000000000;;		minorWildcard wildcardType = 2
0000000000000000000000000000000000000000;;		patchWildcard wildcardType = 3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wildcardTypefromInt(i int) wildcardType {
0000000000000000000000000000000000000000;;		switch i {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return majorWildcard
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			return minorWildcard
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			return patchWildcard
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return noneWildcard
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type comparator func(Version, Version) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		compEQ comparator = func(v1 Version, v2 Version) bool {
0000000000000000000000000000000000000000;;			return v1.Compare(v2) == 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		compNE = func(v1 Version, v2 Version) bool {
0000000000000000000000000000000000000000;;			return v1.Compare(v2) != 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		compGT = func(v1 Version, v2 Version) bool {
0000000000000000000000000000000000000000;;			return v1.Compare(v2) == 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		compGE = func(v1 Version, v2 Version) bool {
0000000000000000000000000000000000000000;;			return v1.Compare(v2) >= 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		compLT = func(v1 Version, v2 Version) bool {
0000000000000000000000000000000000000000;;			return v1.Compare(v2) == -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		compLE = func(v1 Version, v2 Version) bool {
0000000000000000000000000000000000000000;;			return v1.Compare(v2) <= 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type versionRange struct {
0000000000000000000000000000000000000000;;		v Version
0000000000000000000000000000000000000000;;		c comparator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rangeFunc creates a Range from the given versionRange.
0000000000000000000000000000000000000000;;	func (vr *versionRange) rangeFunc() Range {
0000000000000000000000000000000000000000;;		return Range(func(v Version) bool {
0000000000000000000000000000000000000000;;			return vr.c(v, vr.v)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Range represents a range of versions.
0000000000000000000000000000000000000000;;	// A Range can be used to check if a Version satisfies it:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     range, err := semver.ParseRange(">1.0.0 <2.0.0")
0000000000000000000000000000000000000000;;	//     range(semver.MustParse("1.1.1") // returns true
0000000000000000000000000000000000000000;;	type Range func(Version) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OR combines the existing Range with another Range using logical OR.
0000000000000000000000000000000000000000;;	func (rf Range) OR(f Range) Range {
0000000000000000000000000000000000000000;;		return Range(func(v Version) bool {
0000000000000000000000000000000000000000;;			return rf(v) || f(v)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AND combines the existing Range with another Range using logical AND.
0000000000000000000000000000000000000000;;	func (rf Range) AND(f Range) Range {
0000000000000000000000000000000000000000;;		return Range(func(v Version) bool {
0000000000000000000000000000000000000000;;			return rf(v) && f(v)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseRange parses a range and returns a Range.
0000000000000000000000000000000000000000;;	// If the range could not be parsed an error is returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Valid ranges are:
0000000000000000000000000000000000000000;;	//   - "<1.0.0"
0000000000000000000000000000000000000000;;	//   - "<=1.0.0"
0000000000000000000000000000000000000000;;	//   - ">1.0.0"
0000000000000000000000000000000000000000;;	//   - ">=1.0.0"
0000000000000000000000000000000000000000;;	//   - "1.0.0", "=1.0.0", "==1.0.0"
0000000000000000000000000000000000000000;;	//   - "!1.0.0", "!=1.0.0"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A Range can consist of multiple ranges separated by space:
0000000000000000000000000000000000000000;;	// Ranges can be linked by logical AND:
0000000000000000000000000000000000000000;;	//   - ">1.0.0 <2.0.0" would match between both ranges, so "1.1.1" and "1.8.7" but not "1.0.0" or "2.0.0"
0000000000000000000000000000000000000000;;	//   - ">1.0.0 <3.0.0 !2.0.3-beta.2" would match every version between 1.0.0 and 3.0.0 except 2.0.3-beta.2
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Ranges can also be linked by logical OR:
0000000000000000000000000000000000000000;;	//   - "<2.0.0 || >=3.0.0" would match "1.x.x" and "3.x.x" but not "2.x.x"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// AND has a higher precedence than OR. It's not possible to use brackets.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Ranges can be combined by both AND and OR
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  - `>1.0.0 <2.0.0 || >3.0.0 !4.2.1` would match `1.2.3`, `1.9.9`, `3.1.1`, but not `4.2.1`, `2.1.1`
0000000000000000000000000000000000000000;;	func ParseRange(s string) (Range, error) {
0000000000000000000000000000000000000000;;		parts := splitAndTrim(s)
0000000000000000000000000000000000000000;;		orParts, err := splitORParts(parts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expandedParts, err := expandWildcardVersion(orParts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var orFn Range
0000000000000000000000000000000000000000;;		for _, p := range expandedParts {
0000000000000000000000000000000000000000;;			var andFn Range
0000000000000000000000000000000000000000;;			for _, ap := range p {
0000000000000000000000000000000000000000;;				opStr, vStr, err := splitComparatorVersion(ap)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				vr, err := buildVersionRange(opStr, vStr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Could not parse Range %q: %s", ap, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rf := vr.rangeFunc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Set function
0000000000000000000000000000000000000000;;				if andFn == nil {
0000000000000000000000000000000000000000;;					andFn = rf
0000000000000000000000000000000000000000;;				} else { // Combine with existing function
0000000000000000000000000000000000000000;;					andFn = andFn.AND(rf)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if orFn == nil {
0000000000000000000000000000000000000000;;				orFn = andFn
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				orFn = orFn.OR(andFn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return orFn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitORParts splits the already cleaned parts by '||'.
0000000000000000000000000000000000000000;;	// Checks for invalid positions of the operator and returns an
0000000000000000000000000000000000000000;;	// error if found.
0000000000000000000000000000000000000000;;	func splitORParts(parts []string) ([][]string, error) {
0000000000000000000000000000000000000000;;		var ORparts [][]string
0000000000000000000000000000000000000000;;		last := 0
0000000000000000000000000000000000000000;;		for i, p := range parts {
0000000000000000000000000000000000000000;;			if p == "||" {
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("First element in range is '||'")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ORparts = append(ORparts, parts[last:i])
0000000000000000000000000000000000000000;;				last = i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if last == len(parts) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Last element in range is '||'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ORparts = append(ORparts, parts[last:])
0000000000000000000000000000000000000000;;		return ORparts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildVersionRange takes a slice of 2: operator and version
0000000000000000000000000000000000000000;;	// and builds a versionRange, otherwise an error.
0000000000000000000000000000000000000000;;	func buildVersionRange(opStr, vStr string) (*versionRange, error) {
0000000000000000000000000000000000000000;;		c := parseComparator(opStr)
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Could not parse comparator %q in %q", opStr, strings.Join([]string{opStr, vStr}, ""))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := Parse(vStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Could not parse version %q in %q: %s", vStr, strings.Join([]string{opStr, vStr}, ""), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &versionRange{
0000000000000000000000000000000000000000;;			v: v,
0000000000000000000000000000000000000000;;			c: c,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inArray checks if a byte is contained in an array of bytes
0000000000000000000000000000000000000000;;	func inArray(s byte, list []byte) bool {
0000000000000000000000000000000000000000;;		for _, el := range list {
0000000000000000000000000000000000000000;;			if el == s {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitAndTrim splits a range string by spaces and cleans whitespaces
0000000000000000000000000000000000000000;;	func splitAndTrim(s string) (result []string) {
0000000000000000000000000000000000000000;;		last := 0
0000000000000000000000000000000000000000;;		var lastChar byte
0000000000000000000000000000000000000000;;		excludeFromSplit := []byte{'>', '<', '='}
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if s[i] == ' ' && !inArray(lastChar, excludeFromSplit) {
0000000000000000000000000000000000000000;;				if last < i-1 {
0000000000000000000000000000000000000000;;					result = append(result, s[last:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				last = i + 1
0000000000000000000000000000000000000000;;			} else if s[i] != ' ' {
0000000000000000000000000000000000000000;;				lastChar = s[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if last < len(s)-1 {
0000000000000000000000000000000000000000;;			result = append(result, s[last:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, v := range result {
0000000000000000000000000000000000000000;;			result[i] = strings.Replace(v, " ", "", -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parts := strings.Split(s, " ")
0000000000000000000000000000000000000000;;		// for _, x := range parts {
0000000000000000000000000000000000000000;;		// 	if s := strings.TrimSpace(x); len(s) != 0 {
0000000000000000000000000000000000000000;;		// 		result = append(result, s)
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitComparatorVersion splits the comparator from the version.
0000000000000000000000000000000000000000;;	// Input must be free of leading or trailing spaces.
0000000000000000000000000000000000000000;;	func splitComparatorVersion(s string) (string, string, error) {
0000000000000000000000000000000000000000;;		i := strings.IndexFunc(s, unicode.IsDigit)
0000000000000000000000000000000000000000;;		if i == -1 {
0000000000000000000000000000000000000000;;			return "", "", fmt.Errorf("Could not get version from string: %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(s[0:i]), s[i:], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getWildcardType will return the type of wildcard that the
0000000000000000000000000000000000000000;;	// passed version contains
0000000000000000000000000000000000000000;;	func getWildcardType(vStr string) wildcardType {
0000000000000000000000000000000000000000;;		parts := strings.Split(vStr, ".")
0000000000000000000000000000000000000000;;		nparts := len(parts)
0000000000000000000000000000000000000000;;		wildcard := parts[nparts-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		possibleWildcardType := wildcardTypefromInt(nparts)
0000000000000000000000000000000000000000;;		if wildcard == "x" {
0000000000000000000000000000000000000000;;			return possibleWildcardType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return noneWildcard
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createVersionFromWildcard will convert a wildcard version
0000000000000000000000000000000000000000;;	// into a regular version, replacing 'x's with '0's, handling
0000000000000000000000000000000000000000;;	// special cases like '1.x.x' and '1.x'
0000000000000000000000000000000000000000;;	func createVersionFromWildcard(vStr string) string {
0000000000000000000000000000000000000000;;		// handle 1.x.x
0000000000000000000000000000000000000000;;		vStr2 := strings.Replace(vStr, ".x.x", ".x", 1)
0000000000000000000000000000000000000000;;		vStr2 = strings.Replace(vStr2, ".x", ".0", 1)
0000000000000000000000000000000000000000;;		parts := strings.Split(vStr2, ".")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle 1.x
0000000000000000000000000000000000000000;;		if len(parts) == 2 {
0000000000000000000000000000000000000000;;			return vStr2 + ".0"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vStr2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// incrementMajorVersion will increment the major version
0000000000000000000000000000000000000000;;	// of the passed version
0000000000000000000000000000000000000000;;	func incrementMajorVersion(vStr string) (string, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(vStr, ".")
0000000000000000000000000000000000000000;;		i, err := strconv.Atoi(parts[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts[0] = strconv.Itoa(i + 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(parts, "."), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// incrementMajorVersion will increment the minor version
0000000000000000000000000000000000000000;;	// of the passed version
0000000000000000000000000000000000000000;;	func incrementMinorVersion(vStr string) (string, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(vStr, ".")
0000000000000000000000000000000000000000;;		i, err := strconv.Atoi(parts[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts[1] = strconv.Itoa(i + 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(parts, "."), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expandWildcardVersion will expand wildcards inside versions
0000000000000000000000000000000000000000;;	// following these rules:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * when dealing with patch wildcards:
0000000000000000000000000000000000000000;;	// >= 1.2.x    will become    >= 1.2.0
0000000000000000000000000000000000000000;;	// <= 1.2.x    will become    <  1.3.0
0000000000000000000000000000000000000000;;	// >  1.2.x    will become    >= 1.3.0
0000000000000000000000000000000000000000;;	// <  1.2.x    will become    <  1.2.0
0000000000000000000000000000000000000000;;	// != 1.2.x    will become    <  1.2.0 >= 1.3.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * when dealing with minor wildcards:
0000000000000000000000000000000000000000;;	// >= 1.x      will become    >= 1.0.0
0000000000000000000000000000000000000000;;	// <= 1.x      will become    <  2.0.0
0000000000000000000000000000000000000000;;	// >  1.x      will become    >= 2.0.0
0000000000000000000000000000000000000000;;	// <  1.0      will become    <  1.0.0
0000000000000000000000000000000000000000;;	// != 1.x      will become    <  1.0.0 >= 2.0.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * when dealing with wildcards without
0000000000000000000000000000000000000000;;	// version operator:
0000000000000000000000000000000000000000;;	// 1.2.x       will become    >= 1.2.0 < 1.3.0
0000000000000000000000000000000000000000;;	// 1.x         will become    >= 1.0.0 < 2.0.0
0000000000000000000000000000000000000000;;	func expandWildcardVersion(parts [][]string) ([][]string, error) {
0000000000000000000000000000000000000000;;		var expandedParts [][]string
0000000000000000000000000000000000000000;;		for _, p := range parts {
0000000000000000000000000000000000000000;;			var newParts []string
0000000000000000000000000000000000000000;;			for _, ap := range p {
0000000000000000000000000000000000000000;;				if strings.Index(ap, "x") != -1 {
0000000000000000000000000000000000000000;;					opStr, vStr, err := splitComparatorVersion(ap)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					versionWildcardType := getWildcardType(vStr)
0000000000000000000000000000000000000000;;					flatVersion := createVersionFromWildcard(vStr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var resultOperator string
0000000000000000000000000000000000000000;;					var shouldIncrementVersion bool
0000000000000000000000000000000000000000;;					switch opStr {
0000000000000000000000000000000000000000;;					case ">":
0000000000000000000000000000000000000000;;						resultOperator = ">="
0000000000000000000000000000000000000000;;						shouldIncrementVersion = true
0000000000000000000000000000000000000000;;					case ">=":
0000000000000000000000000000000000000000;;						resultOperator = ">="
0000000000000000000000000000000000000000;;					case "<":
0000000000000000000000000000000000000000;;						resultOperator = "<"
0000000000000000000000000000000000000000;;					case "<=":
0000000000000000000000000000000000000000;;						resultOperator = "<"
0000000000000000000000000000000000000000;;						shouldIncrementVersion = true
0000000000000000000000000000000000000000;;					case "", "=", "==":
0000000000000000000000000000000000000000;;						newParts = append(newParts, ">="+flatVersion)
0000000000000000000000000000000000000000;;						resultOperator = "<"
0000000000000000000000000000000000000000;;						shouldIncrementVersion = true
0000000000000000000000000000000000000000;;					case "!=", "!":
0000000000000000000000000000000000000000;;						newParts = append(newParts, "<"+flatVersion)
0000000000000000000000000000000000000000;;						resultOperator = ">="
0000000000000000000000000000000000000000;;						shouldIncrementVersion = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var resultVersion string
0000000000000000000000000000000000000000;;					if shouldIncrementVersion {
0000000000000000000000000000000000000000;;						switch versionWildcardType {
0000000000000000000000000000000000000000;;						case patchWildcard:
0000000000000000000000000000000000000000;;							resultVersion, _ = incrementMinorVersion(flatVersion)
0000000000000000000000000000000000000000;;						case minorWildcard:
0000000000000000000000000000000000000000;;							resultVersion, _ = incrementMajorVersion(flatVersion)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						resultVersion = flatVersion
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ap = resultOperator + resultVersion
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newParts = append(newParts, ap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			expandedParts = append(expandedParts, newParts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expandedParts, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseComparator(s string) comparator {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "==":
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case "=":
0000000000000000000000000000000000000000;;			return compEQ
0000000000000000000000000000000000000000;;		case ">":
0000000000000000000000000000000000000000;;			return compGT
0000000000000000000000000000000000000000;;		case ">=":
0000000000000000000000000000000000000000;;			return compGE
0000000000000000000000000000000000000000;;		case "<":
0000000000000000000000000000000000000000;;			return compLT
0000000000000000000000000000000000000000;;		case "<=":
0000000000000000000000000000000000000000;;			return compLE
0000000000000000000000000000000000000000;;		case "!":
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case "!=":
0000000000000000000000000000000000000000;;			return compNE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustParseRange is like ParseRange but panics if the range cannot be parsed.
0000000000000000000000000000000000000000;;	func MustParseRange(s string) Range {
0000000000000000000000000000000000000000;;		r, err := ParseRange(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(`semver: ParseRange(` + s + `): ` + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
