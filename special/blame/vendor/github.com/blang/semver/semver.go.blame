0000000000000000000000000000000000000000;;	package semver
9a8dd8e8e9c9f7d0ff29d2ab116ffccc9fc03c02;Godeps/_workspace/src/github.com/blang/semver/semver.go[Godeps/_workspace/src/github.com/blang/semver/semver.go][vendor/github.com/blang/semver/semver.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		numbers  string = "0123456789"
0000000000000000000000000000000000000000;;		alphas          = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-"
0000000000000000000000000000000000000000;;		alphanum        = alphas + numbers
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SpecVersion is the latest fully supported spec version of semver
0000000000000000000000000000000000000000;;	var SpecVersion = Version{
0000000000000000000000000000000000000000;;		Major: 2,
0000000000000000000000000000000000000000;;		Minor: 0,
0000000000000000000000000000000000000000;;		Patch: 0,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version represents a semver compatible version
0000000000000000000000000000000000000000;;	type Version struct {
0000000000000000000000000000000000000000;;		Major uint64
0000000000000000000000000000000000000000;;		Minor uint64
0000000000000000000000000000000000000000;;		Patch uint64
0000000000000000000000000000000000000000;;		Pre   []PRVersion
0000000000000000000000000000000000000000;;		Build []string //No Precendence
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version to string
0000000000000000000000000000000000000000;;	func (v Version) String() string {
0000000000000000000000000000000000000000;;		b := make([]byte, 0, 5)
0000000000000000000000000000000000000000;;		b = strconv.AppendUint(b, v.Major, 10)
0000000000000000000000000000000000000000;;		b = append(b, '.')
0000000000000000000000000000000000000000;;		b = strconv.AppendUint(b, v.Minor, 10)
0000000000000000000000000000000000000000;;		b = append(b, '.')
0000000000000000000000000000000000000000;;		b = strconv.AppendUint(b, v.Patch, 10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(v.Pre) > 0 {
0000000000000000000000000000000000000000;;			b = append(b, '-')
0000000000000000000000000000000000000000;;			b = append(b, v.Pre[0].String()...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, pre := range v.Pre[1:] {
0000000000000000000000000000000000000000;;				b = append(b, '.')
0000000000000000000000000000000000000000;;				b = append(b, pre.String()...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(v.Build) > 0 {
0000000000000000000000000000000000000000;;			b = append(b, '+')
0000000000000000000000000000000000000000;;			b = append(b, v.Build[0]...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, build := range v.Build[1:] {
0000000000000000000000000000000000000000;;				b = append(b, '.')
0000000000000000000000000000000000000000;;				b = append(b, build...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equals checks if v is equal to o.
0000000000000000000000000000000000000000;;	func (v Version) Equals(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EQ checks if v is equal to o.
0000000000000000000000000000000000000000;;	func (v Version) EQ(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NE checks if v is not equal to o.
0000000000000000000000000000000000000000;;	func (v Version) NE(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) != 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GT checks if v is greater than o.
0000000000000000000000000000000000000000;;	func (v Version) GT(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) == 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GTE checks if v is greater than or equal to o.
0000000000000000000000000000000000000000;;	func (v Version) GTE(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) >= 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GE checks if v is greater than or equal to o.
0000000000000000000000000000000000000000;;	func (v Version) GE(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) >= 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LT checks if v is less than o.
0000000000000000000000000000000000000000;;	func (v Version) LT(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) == -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LTE checks if v is less than or equal to o.
0000000000000000000000000000000000000000;;	func (v Version) LTE(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) <= 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LE checks if v is less than or equal to o.
0000000000000000000000000000000000000000;;	func (v Version) LE(o Version) bool {
0000000000000000000000000000000000000000;;		return (v.Compare(o) <= 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare compares Versions v to o:
0000000000000000000000000000000000000000;;	// -1 == v is less than o
0000000000000000000000000000000000000000;;	// 0 == v is equal to o
0000000000000000000000000000000000000000;;	// 1 == v is greater than o
0000000000000000000000000000000000000000;;	func (v Version) Compare(o Version) int {
0000000000000000000000000000000000000000;;		if v.Major != o.Major {
0000000000000000000000000000000000000000;;			if v.Major > o.Major {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Minor != o.Minor {
0000000000000000000000000000000000000000;;			if v.Minor > o.Minor {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Patch != o.Patch {
0000000000000000000000000000000000000000;;			if v.Patch > o.Patch {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Quick comparison if a version has no prerelease versions
0000000000000000000000000000000000000000;;		if len(v.Pre) == 0 && len(o.Pre) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		} else if len(v.Pre) == 0 && len(o.Pre) > 0 {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		} else if len(v.Pre) > 0 && len(o.Pre) == 0 {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for ; i < len(v.Pre) && i < len(o.Pre); i++ {
0000000000000000000000000000000000000000;;			if comp := v.Pre[i].Compare(o.Pre[i]); comp == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if comp == 1 {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If all pr versions are the equal but one has further prversion, this one greater
0000000000000000000000000000000000000000;;		if i == len(v.Pre) && i == len(o.Pre) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		} else if i == len(v.Pre) && i < len(o.Pre) {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates v and returns error in case
0000000000000000000000000000000000000000;;	func (v Version) Validate() error {
0000000000000000000000000000000000000000;;		// Major, Minor, Patch already validated using uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pre := range v.Pre {
0000000000000000000000000000000000000000;;			if !pre.IsNum { //Numeric prerelease versions already uint64
0000000000000000000000000000000000000000;;				if len(pre.VersionStr) == 0 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Prerelease can not be empty %q", pre.VersionStr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !containsOnly(pre.VersionStr, alphanum) {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Invalid character(s) found in prerelease %q", pre.VersionStr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, build := range v.Build {
0000000000000000000000000000000000000000;;			if len(build) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Build meta data can not be empty %q", build)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !containsOnly(build, alphanum) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Invalid character(s) found in build meta data %q", build)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New is an alias for Parse and returns a pointer, parses version string and returns a validated Version or error
0000000000000000000000000000000000000000;;	func New(s string) (vp *Version, err error) {
0000000000000000000000000000000000000000;;		v, err := Parse(s)
0000000000000000000000000000000000000000;;		vp = &v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make is an alias for Parse, parses version string and returns a validated Version or error
0000000000000000000000000000000000000000;;	func Make(s string) (Version, error) {
0000000000000000000000000000000000000000;;		return Parse(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseTolerant allows for certain version specifications that do not strictly adhere to semver
0000000000000000000000000000000000000000;;	// specs to be parsed by this library. It does so by normalizing versions before passing them to
0000000000000000000000000000000000000000;;	// Parse(). It currently trims spaces, removes a "v" prefix, and adds a 0 patch number to versions
0000000000000000000000000000000000000000;;	// with only major and minor components specified
0000000000000000000000000000000000000000;;	func ParseTolerant(s string) (Version, error) {
0000000000000000000000000000000000000000;;		s = strings.TrimSpace(s)
0000000000000000000000000000000000000000;;		s = strings.TrimPrefix(s, "v")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split into major.minor.(patch+pr+meta)
0000000000000000000000000000000000000000;;		parts := strings.SplitN(s, ".", 3)
0000000000000000000000000000000000000000;;		if len(parts) < 3 {
0000000000000000000000000000000000000000;;			if strings.ContainsAny(parts[len(parts)-1], "+-") {
0000000000000000000000000000000000000000;;				return Version{}, errors.New("Short version cannot contain PreRelease/Build meta data")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for len(parts) < 3 {
0000000000000000000000000000000000000000;;				parts = append(parts, "0")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = strings.Join(parts, ".")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Parse(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse parses version string and returns a validated Version or error
0000000000000000000000000000000000000000;;	func Parse(s string) (Version, error) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return Version{}, errors.New("Version string empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split into major.minor.(patch+pr+meta)
0000000000000000000000000000000000000000;;		parts := strings.SplitN(s, ".", 3)
0000000000000000000000000000000000000000;;		if len(parts) != 3 {
0000000000000000000000000000000000000000;;			return Version{}, errors.New("No Major.Minor.Patch elements found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Major
0000000000000000000000000000000000000000;;		if !containsOnly(parts[0], numbers) {
0000000000000000000000000000000000000000;;			return Version{}, fmt.Errorf("Invalid character(s) found in major number %q", parts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasLeadingZeroes(parts[0]) {
0000000000000000000000000000000000000000;;			return Version{}, fmt.Errorf("Major number must not contain leading zeroes %q", parts[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		major, err := strconv.ParseUint(parts[0], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Version{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minor
0000000000000000000000000000000000000000;;		if !containsOnly(parts[1], numbers) {
0000000000000000000000000000000000000000;;			return Version{}, fmt.Errorf("Invalid character(s) found in minor number %q", parts[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasLeadingZeroes(parts[1]) {
0000000000000000000000000000000000000000;;			return Version{}, fmt.Errorf("Minor number must not contain leading zeroes %q", parts[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		minor, err := strconv.ParseUint(parts[1], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Version{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := Version{}
0000000000000000000000000000000000000000;;		v.Major = major
0000000000000000000000000000000000000000;;		v.Minor = minor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var build, prerelease []string
0000000000000000000000000000000000000000;;		patchStr := parts[2]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if buildIndex := strings.IndexRune(patchStr, '+'); buildIndex != -1 {
0000000000000000000000000000000000000000;;			build = strings.Split(patchStr[buildIndex+1:], ".")
0000000000000000000000000000000000000000;;			patchStr = patchStr[:buildIndex]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if preIndex := strings.IndexRune(patchStr, '-'); preIndex != -1 {
0000000000000000000000000000000000000000;;			prerelease = strings.Split(patchStr[preIndex+1:], ".")
0000000000000000000000000000000000000000;;			patchStr = patchStr[:preIndex]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !containsOnly(patchStr, numbers) {
0000000000000000000000000000000000000000;;			return Version{}, fmt.Errorf("Invalid character(s) found in patch number %q", patchStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hasLeadingZeroes(patchStr) {
0000000000000000000000000000000000000000;;			return Version{}, fmt.Errorf("Patch number must not contain leading zeroes %q", patchStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		patch, err := strconv.ParseUint(patchStr, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Version{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v.Patch = patch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prerelease
0000000000000000000000000000000000000000;;		for _, prstr := range prerelease {
0000000000000000000000000000000000000000;;			parsedPR, err := NewPRVersion(prstr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return Version{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Pre = append(v.Pre, parsedPR)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build meta data
0000000000000000000000000000000000000000;;		for _, str := range build {
0000000000000000000000000000000000000000;;			if len(str) == 0 {
0000000000000000000000000000000000000000;;				return Version{}, errors.New("Build meta data is empty")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !containsOnly(str, alphanum) {
0000000000000000000000000000000000000000;;				return Version{}, fmt.Errorf("Invalid character(s) found in build meta data %q", str)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Build = append(v.Build, str)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustParse is like Parse but panics if the version cannot be parsed.
0000000000000000000000000000000000000000;;	func MustParse(s string) Version {
0000000000000000000000000000000000000000;;		v, err := Parse(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(`semver: Parse(` + s + `): ` + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PRVersion represents a PreRelease Version
0000000000000000000000000000000000000000;;	type PRVersion struct {
0000000000000000000000000000000000000000;;		VersionStr string
0000000000000000000000000000000000000000;;		VersionNum uint64
0000000000000000000000000000000000000000;;		IsNum      bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPRVersion creates a new valid prerelease version
0000000000000000000000000000000000000000;;	func NewPRVersion(s string) (PRVersion, error) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return PRVersion{}, errors.New("Prerelease is empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := PRVersion{}
0000000000000000000000000000000000000000;;		if containsOnly(s, numbers) {
0000000000000000000000000000000000000000;;			if hasLeadingZeroes(s) {
0000000000000000000000000000000000000000;;				return PRVersion{}, fmt.Errorf("Numeric PreRelease version must not contain leading zeroes %q", s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			num, err := strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Might never be hit, but just in case
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return PRVersion{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.VersionNum = num
0000000000000000000000000000000000000000;;			v.IsNum = true
0000000000000000000000000000000000000000;;		} else if containsOnly(s, alphanum) {
0000000000000000000000000000000000000000;;			v.VersionStr = s
0000000000000000000000000000000000000000;;			v.IsNum = false
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return PRVersion{}, fmt.Errorf("Invalid character(s) found in prerelease %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNumeric checks if prerelease-version is numeric
0000000000000000000000000000000000000000;;	func (v PRVersion) IsNumeric() bool {
0000000000000000000000000000000000000000;;		return v.IsNum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare compares two PreRelease Versions v and o:
0000000000000000000000000000000000000000;;	// -1 == v is less than o
0000000000000000000000000000000000000000;;	// 0 == v is equal to o
0000000000000000000000000000000000000000;;	// 1 == v is greater than o
0000000000000000000000000000000000000000;;	func (v PRVersion) Compare(o PRVersion) int {
0000000000000000000000000000000000000000;;		if v.IsNum && !o.IsNum {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		} else if !v.IsNum && o.IsNum {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		} else if v.IsNum && o.IsNum {
0000000000000000000000000000000000000000;;			if v.VersionNum == o.VersionNum {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			} else if v.VersionNum > o.VersionNum {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else { // both are Alphas
0000000000000000000000000000000000000000;;			if v.VersionStr == o.VersionStr {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			} else if v.VersionStr > o.VersionStr {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PreRelease version to string
0000000000000000000000000000000000000000;;	func (v PRVersion) String() string {
0000000000000000000000000000000000000000;;		if v.IsNum {
0000000000000000000000000000000000000000;;			return strconv.FormatUint(v.VersionNum, 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.VersionStr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func containsOnly(s string, set string) bool {
0000000000000000000000000000000000000000;;		return strings.IndexFunc(s, func(r rune) bool {
0000000000000000000000000000000000000000;;			return !strings.ContainsRune(set, r)
0000000000000000000000000000000000000000;;		}) == -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hasLeadingZeroes(s string) bool {
0000000000000000000000000000000000000000;;		return len(s) > 1 && s[0] == '0'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBuildVersion creates a new valid build version
0000000000000000000000000000000000000000;;	func NewBuildVersion(s string) (string, error) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return "", errors.New("Buildversion is empty")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !containsOnly(s, alphanum) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Invalid character(s) found in build meta data %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
