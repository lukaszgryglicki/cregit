0000000000000000000000000000000000000000;;	// Copyright (c) 2015, Daniel Mart√≠ <mvdan@mvdan.cc>
0000000000000000000000000000000000000000;;	// See LICENSE for licensing information
ecac765faaa35a5c5050441e1e859d68858ad813;Godeps/_workspace/src/github.com/mvdan/xurls/xurls.go[Godeps/_workspace/src/github.com/mvdan/xurls/xurls.go][vendor/github.com/mvdan/xurls/xurls.go];	
0000000000000000000000000000000000000000;;	// Package xurls extracts urls from plain text using regular expressions.
0000000000000000000000000000000000000000;;	package xurls
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "regexp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:generate go run generate/tldsgen/main.go
0000000000000000000000000000000000000000;;	//go:generate go run generate/regexgen/main.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		letter    = `\p{L}`
0000000000000000000000000000000000000000;;		number    = `\p{N}`
0000000000000000000000000000000000000000;;		iriChar   = letter + number
0000000000000000000000000000000000000000;;		currency  = `\p{Sc}`
0000000000000000000000000000000000000000;;		otherSymb = `\p{So}`
0000000000000000000000000000000000000000;;		endChar   = iriChar + `/\-+_&~*%=#` + currency
0000000000000000000000000000000000000000;;		midChar   = endChar + `@.,:;'?!|` + otherSymb
0000000000000000000000000000000000000000;;		wellParen = `\([` + midChar + `]*(\([` + midChar + `]*\)[` + midChar + `]*)*\)`
0000000000000000000000000000000000000000;;		wellBrack = `\[[` + midChar + `]*(\[[` + midChar + `]*\][` + midChar + `]*)*\]`
0000000000000000000000000000000000000000;;		wellBrace = `\{[` + midChar + `]*(\{[` + midChar + `]*\}[` + midChar + `]*)*\}`
0000000000000000000000000000000000000000;;		wellAll   = wellParen + `|` + wellBrack + `|` + wellBrace
0000000000000000000000000000000000000000;;		pathCont  = `([` + midChar + `]*(` + wellAll + `|[` + endChar + `])+)+`
0000000000000000000000000000000000000000;;		comScheme = `[a-zA-Z][a-zA-Z.\-+]*://`
0000000000000000000000000000000000000000;;		scheme    = `(` + comScheme + `|` + otherScheme + `)`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iri      = `[` + iriChar + `]([` + iriChar + `\-]*[` + iriChar + `])?`
0000000000000000000000000000000000000000;;		domain   = `(` + iri + `\.)+`
0000000000000000000000000000000000000000;;		octet    = `(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])`
0000000000000000000000000000000000000000;;		ipv4Addr = `\b` + octet + `\.` + octet + `\.` + octet + `\.` + octet + `\b`
0000000000000000000000000000000000000000;;		ipv6Addr = `([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:([0-9a-fA-F]{1,4}:[0-9a-fA-F]{0,4}|:[0-9a-fA-F]{1,4})?|(:[0-9a-fA-F]{1,4}){0,2})|(:[0-9a-fA-F]{1,4}){0,3})|(:[0-9a-fA-F]{1,4}){0,4})|:(:[0-9a-fA-F]{1,4}){0,5})((:[0-9a-fA-F]{1,4}){2}|:(25[0-5]|(2[0-4]|1[0-9]|[1-9])?[0-9])(\.(25[0-5]|(2[0-4]|1[0-9]|[1-9])?[0-9])){3})|(([0-9a-fA-F]{1,4}:){1,6}|:):[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){7}:`
0000000000000000000000000000000000000000;;		ipAddr   = `(` + ipv4Addr + `|` + ipv6Addr + `)`
0000000000000000000000000000000000000000;;		site     = domain + gtld
0000000000000000000000000000000000000000;;		hostName = `(` + site + `|` + ipAddr + `)`
0000000000000000000000000000000000000000;;		port     = `(:[0-9]*)?`
0000000000000000000000000000000000000000;;		path     = `(/|/` + pathCont + `?|\b|$)`
0000000000000000000000000000000000000000;;		webURL   = hostName + port + path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		strict  = `(\b` + scheme + pathCont + `)`
0000000000000000000000000000000000000000;;		relaxed = `(` + strict + `|` + webURL + `)`
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Relaxed matches all the urls it can find.
0000000000000000000000000000000000000000;;		Relaxed = regexp.MustCompile(relaxed)
0000000000000000000000000000000000000000;;		// Strict only matches urls with a scheme to avoid false positives.
0000000000000000000000000000000000000000;;		Strict = regexp.MustCompile(strict)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		Relaxed.Longest()
0000000000000000000000000000000000000000;;		Strict.Longest()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrictMatchingScheme produces a regexp that matches urls like Strict but
0000000000000000000000000000000000000000;;	// whose scheme matches the given regular expression.
0000000000000000000000000000000000000000;;	func StrictMatchingScheme(exp string) (*regexp.Regexp, error) {
0000000000000000000000000000000000000000;;		strictMatching := `(\b(?i)(` + exp + `)(?-i)` + pathCont + `)`
0000000000000000000000000000000000000000;;		re, err := regexp.Compile(strictMatching)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		re.Longest()
0000000000000000000000000000000000000000;;		return re, nil
0000000000000000000000000000000000000000;;	}
