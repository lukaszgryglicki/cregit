0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/cbor.go[Godeps/_workspace/src/github.com/ugorji/go/codec/cbor.go][vendor/github.com/ugorji/go/codec/cbor.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cborMajorUint byte = iota
0000000000000000000000000000000000000000;;		cborMajorNegInt
0000000000000000000000000000000000000000;;		cborMajorBytes
0000000000000000000000000000000000000000;;		cborMajorText
0000000000000000000000000000000000000000;;		cborMajorArray
0000000000000000000000000000000000000000;;		cborMajorMap
0000000000000000000000000000000000000000;;		cborMajorTag
0000000000000000000000000000000000000000;;		cborMajorOther
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cborBdFalse byte = 0xf4 + iota
0000000000000000000000000000000000000000;;		cborBdTrue
0000000000000000000000000000000000000000;;		cborBdNil
0000000000000000000000000000000000000000;;		cborBdUndefined
0000000000000000000000000000000000000000;;		cborBdExt
0000000000000000000000000000000000000000;;		cborBdFloat16
0000000000000000000000000000000000000000;;		cborBdFloat32
0000000000000000000000000000000000000000;;		cborBdFloat64
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cborBdIndefiniteBytes  byte = 0x5f
0000000000000000000000000000000000000000;;		cborBdIndefiniteString      = 0x7f
0000000000000000000000000000000000000000;;		cborBdIndefiniteArray       = 0x9f
0000000000000000000000000000000000000000;;		cborBdIndefiniteMap         = 0xbf
0000000000000000000000000000000000000000;;		cborBdBreak                 = 0xff
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CborStreamBytes  byte = 0x5f
0000000000000000000000000000000000000000;;		CborStreamString      = 0x7f
0000000000000000000000000000000000000000;;		CborStreamArray       = 0x9f
0000000000000000000000000000000000000000;;		CborStreamMap         = 0xbf
0000000000000000000000000000000000000000;;		CborStreamBreak       = 0xff
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cborBaseUint   byte = 0x00
0000000000000000000000000000000000000000;;		cborBaseNegInt      = 0x20
0000000000000000000000000000000000000000;;		cborBaseBytes       = 0x40
0000000000000000000000000000000000000000;;		cborBaseString      = 0x60
0000000000000000000000000000000000000000;;		cborBaseArray       = 0x80
0000000000000000000000000000000000000000;;		cborBaseMap         = 0xa0
0000000000000000000000000000000000000000;;		cborBaseTag         = 0xc0
0000000000000000000000000000000000000000;;		cborBaseSimple      = 0xe0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cborEncDriver struct {
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;		encNoSeparator
0000000000000000000000000000000000000000;;		e *Encoder
0000000000000000000000000000000000000000;;		w encWriter
0000000000000000000000000000000000000000;;		h *CborHandle
0000000000000000000000000000000000000000;;		x [8]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeNil() {
0000000000000000000000000000000000000000;;		e.w.writen1(cborBdNil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeBool(b bool) {
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			e.w.writen1(cborBdTrue)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(cborBdFalse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeFloat32(f float32) {
0000000000000000000000000000000000000000;;		e.w.writen1(cborBdFloat32)
0000000000000000000000000000000000000000;;		bigenHelper{e.x[:4], e.w}.writeUint32(math.Float32bits(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeFloat64(f float64) {
0000000000000000000000000000000000000000;;		e.w.writen1(cborBdFloat64)
0000000000000000000000000000000000000000;;		bigenHelper{e.x[:8], e.w}.writeUint64(math.Float64bits(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) encUint(v uint64, bd byte) {
0000000000000000000000000000000000000000;;		if v <= 0x17 {
0000000000000000000000000000000000000000;;			e.w.writen1(byte(v) + bd)
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint8 {
0000000000000000000000000000000000000000;;			e.w.writen2(bd+0x18, uint8(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint16 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 0x19)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:2], e.w}.writeUint16(uint16(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint32 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 0x1a)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:4], e.w}.writeUint32(uint32(v))
0000000000000000000000000000000000000000;;		} else { // if v <= math.MaxUint64 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 0x1b)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:8], e.w}.writeUint64(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeInt(v int64) {
0000000000000000000000000000000000000000;;		if v < 0 {
0000000000000000000000000000000000000000;;			e.encUint(uint64(-1-v), cborBaseNegInt)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.encUint(uint64(v), cborBaseUint)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeUint(v uint64) {
0000000000000000000000000000000000000000;;		e.encUint(v, cborBaseUint)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) encLen(bd byte, length int) {
0000000000000000000000000000000000000000;;		e.encUint(uint64(length), bd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeExt(rv interface{}, xtag uint64, ext Ext, en *Encoder) {
0000000000000000000000000000000000000000;;		e.encUint(uint64(xtag), cborBaseTag)
0000000000000000000000000000000000000000;;		if v := ext.ConvertExt(rv); v == nil {
0000000000000000000000000000000000000000;;			e.EncodeNil()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			en.encode(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeRawExt(re *RawExt, en *Encoder) {
0000000000000000000000000000000000000000;;		e.encUint(uint64(re.Tag), cborBaseTag)
0000000000000000000000000000000000000000;;		if re.Data != nil {
0000000000000000000000000000000000000000;;			en.encode(re.Data)
0000000000000000000000000000000000000000;;		} else if re.Value == nil {
0000000000000000000000000000000000000000;;			e.EncodeNil()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			en.encode(re.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeArrayStart(length int) {
0000000000000000000000000000000000000000;;		e.encLen(cborBaseArray, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeMapStart(length int) {
0000000000000000000000000000000000000000;;		e.encLen(cborBaseMap, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeString(c charEncoding, v string) {
0000000000000000000000000000000000000000;;		e.encLen(cborBaseString, len(v))
0000000000000000000000000000000000000000;;		e.w.writestr(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeSymbol(v string) {
0000000000000000000000000000000000000000;;		e.EncodeString(c_UTF8, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) EncodeStringBytes(c charEncoding, v []byte) {
0000000000000000000000000000000000000000;;		if c == c_RAW {
0000000000000000000000000000000000000000;;			e.encLen(cborBaseBytes, len(v))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.encLen(cborBaseString, len(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w.writeb(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type cborDecDriver struct {
0000000000000000000000000000000000000000;;		d      *Decoder
0000000000000000000000000000000000000000;;		h      *CborHandle
0000000000000000000000000000000000000000;;		r      decReader
0000000000000000000000000000000000000000;;		b      [scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;		br     bool // bytes reader
0000000000000000000000000000000000000000;;		bdRead bool
0000000000000000000000000000000000000000;;		bd     byte
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;		decNoSeparator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) readNextBd() {
0000000000000000000000000000000000000000;;		d.bd = d.r.readn1()
0000000000000000000000000000000000000000;;		d.bdRead = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) uncacheRead() {
0000000000000000000000000000000000000000;;		if d.bdRead {
0000000000000000000000000000000000000000;;			d.r.unreadn1()
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) ContainerType() (vt valueType) {
0000000000000000000000000000000000000000;;		if d.bd == cborBdNil {
0000000000000000000000000000000000000000;;			return valueTypeNil
0000000000000000000000000000000000000000;;		} else if d.bd == cborBdIndefiniteBytes || (d.bd >= cborBaseBytes && d.bd < cborBaseString) {
0000000000000000000000000000000000000000;;			return valueTypeBytes
0000000000000000000000000000000000000000;;		} else if d.bd == cborBdIndefiniteString || (d.bd >= cborBaseString && d.bd < cborBaseArray) {
0000000000000000000000000000000000000000;;			return valueTypeString
0000000000000000000000000000000000000000;;		} else if d.bd == cborBdIndefiniteArray || (d.bd >= cborBaseArray && d.bd < cborBaseMap) {
0000000000000000000000000000000000000000;;			return valueTypeArray
0000000000000000000000000000000000000000;;		} else if d.bd == cborBdIndefiniteMap || (d.bd >= cborBaseMap && d.bd < cborBaseTag) {
0000000000000000000000000000000000000000;;			return valueTypeMap
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// d.d.errorf("isContainerType: unsupported parameter: %v", vt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return valueTypeUnset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) TryDecodeAsNil() bool {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// treat Nil and Undefined as nil values
0000000000000000000000000000000000000000;;		if d.bd == cborBdNil || d.bd == cborBdUndefined {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) CheckBreak() bool {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == cborBdBreak {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) decUint() (ui uint64) {
0000000000000000000000000000000000000000;;		v := d.bd & 0x1f
0000000000000000000000000000000000000000;;		if v <= 0x17 {
0000000000000000000000000000000000000000;;			ui = uint64(v)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if v == 0x18 {
0000000000000000000000000000000000000000;;				ui = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;			} else if v == 0x19 {
0000000000000000000000000000000000000000;;				ui = uint64(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;			} else if v == 0x1a {
0000000000000000000000000000000000000000;;				ui = uint64(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;			} else if v == 0x1b {
0000000000000000000000000000000000000000;;				ui = uint64(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("decUint: Invalid descriptor: %v", d.bd)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) decCheckInteger() (neg bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		major := d.bd >> 5
0000000000000000000000000000000000000000;;		if major == cborMajorUint {
0000000000000000000000000000000000000000;;		} else if major == cborMajorNegInt {
0000000000000000000000000000000000000000;;			neg = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("invalid major: %v (bd: %v)", major, d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeInt(bitsize uint8) (i int64) {
0000000000000000000000000000000000000000;;		neg := d.decCheckInteger()
0000000000000000000000000000000000000000;;		ui := d.decUint()
0000000000000000000000000000000000000000;;		// check if this number can be converted to an int without overflow
0000000000000000000000000000000000000000;;		var overflow bool
0000000000000000000000000000000000000000;;		if neg {
0000000000000000000000000000000000000000;;			if i, overflow = chkOvf.SignedInt(ui + 1); overflow {
0000000000000000000000000000000000000000;;				d.d.errorf("cbor: overflow converting %v to signed integer", ui+1)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = -i
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if i, overflow = chkOvf.SignedInt(ui); overflow {
0000000000000000000000000000000000000000;;				d.d.errorf("cbor: overflow converting %v to signed integer", ui)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOvf.Int(i, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("cbor: overflow integer: %v", i)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeUint(bitsize uint8) (ui uint64) {
0000000000000000000000000000000000000000;;		if d.decCheckInteger() {
0000000000000000000000000000000000000000;;			d.d.errorf("Assigning negative signed value to unsigned type")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ui = d.decUint()
0000000000000000000000000000000000000000;;		if chkOvf.Uint(ui, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("cbor: overflow integer: %v", ui)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeFloat(chkOverflow32 bool) (f float64) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bd := d.bd; bd == cborBdFloat16 {
0000000000000000000000000000000000000000;;			f = float64(math.Float32frombits(halfFloatToFloatBits(bigen.Uint16(d.r.readx(2)))))
0000000000000000000000000000000000000000;;		} else if bd == cborBdFloat32 {
0000000000000000000000000000000000000000;;			f = float64(math.Float32frombits(bigen.Uint32(d.r.readx(4))))
0000000000000000000000000000000000000000;;		} else if bd == cborBdFloat64 {
0000000000000000000000000000000000000000;;			f = math.Float64frombits(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;		} else if bd >= cborBaseUint && bd < cborBaseBytes {
0000000000000000000000000000000000000000;;			f = float64(d.DecodeInt(64))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("Float only valid from float16/32/64: Invalid descriptor: %v", bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOverflow32 && chkOvf.Float32(f) {
0000000000000000000000000000000000000000;;			d.d.errorf("cbor: float32 overflow: %v", f)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bool can be decoded from bool only (single byte).
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeBool() (b bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bd := d.bd; bd == cborBdTrue {
0000000000000000000000000000000000000000;;			b = true
0000000000000000000000000000000000000000;;		} else if bd == cborBdFalse {
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid single-byte value for bool: %s: %x", msgBadDesc, d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) ReadMapStart() (length int) {
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		if d.bd == cborBdIndefiniteMap {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.decLen()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) ReadArrayStart() (length int) {
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		if d.bd == cborBdIndefiniteArray {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.decLen()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) decLen() int {
0000000000000000000000000000000000000000;;		return int(d.decUint())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) decAppendIndefiniteBytes(bs []byte) []byte {
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if d.CheckBreak() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if major := d.bd >> 5; major != cborMajorBytes && major != cborMajorText {
0000000000000000000000000000000000000000;;				d.d.errorf("cbor: expect bytes or string major type in indefinite string/bytes; got: %v, byte: %v", major, d.bd)
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n := d.decLen()
0000000000000000000000000000000000000000;;			oldLen := len(bs)
0000000000000000000000000000000000000000;;			newLen := oldLen + n
0000000000000000000000000000000000000000;;			if newLen > cap(bs) {
0000000000000000000000000000000000000000;;				bs2 := make([]byte, newLen, 2*cap(bs)+n)
0000000000000000000000000000000000000000;;				copy(bs2, bs)
0000000000000000000000000000000000000000;;				bs = bs2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				bs = bs[:newLen]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.r.readb(bs[oldLen:newLen])
0000000000000000000000000000000000000000;;			// bs = append(bs, d.r.readn()...)
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return bs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeBytes(bs []byte, isstring, zerocopy bool) (bsOut []byte) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == cborBdNil || d.bd == cborBdUndefined {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == cborBdIndefiniteBytes || d.bd == cborBdIndefiniteString {
0000000000000000000000000000000000000000;;			if bs == nil {
0000000000000000000000000000000000000000;;				return d.decAppendIndefiniteBytes(nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return d.decAppendIndefiniteBytes(bs[:0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clen := d.decLen()
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		if zerocopy {
0000000000000000000000000000000000000000;;			if d.br {
0000000000000000000000000000000000000000;;				return d.r.readx(clen)
0000000000000000000000000000000000000000;;			} else if len(bs) == 0 {
0000000000000000000000000000000000000000;;				bs = d.b[:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decByteSlice(d.r, clen, bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeString() (s string) {
0000000000000000000000000000000000000000;;		return string(d.DecodeBytes(d.b[:], true, true))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeExt(rv interface{}, xtag uint64, ext Ext) (realxtag uint64) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u := d.decUint()
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		realxtag = u
0000000000000000000000000000000000000000;;		if ext == nil {
0000000000000000000000000000000000000000;;			re := rv.(*RawExt)
0000000000000000000000000000000000000000;;			re.Tag = realxtag
0000000000000000000000000000000000000000;;			d.d.decode(&re.Value)
0000000000000000000000000000000000000000;;		} else if xtag != realxtag {
0000000000000000000000000000000000000000;;			d.d.errorf("Wrong extension tag. Got %b. Expecting: %v", realxtag, xtag)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var v interface{}
0000000000000000000000000000000000000000;;			d.d.decode(&v)
0000000000000000000000000000000000000000;;			ext.UpdateExt(rv, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) DecodeNaked() {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := &d.d.n
0000000000000000000000000000000000000000;;		var decodeFurther bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch d.bd {
0000000000000000000000000000000000000000;;		case cborBdNil:
0000000000000000000000000000000000000000;;			n.v = valueTypeNil
0000000000000000000000000000000000000000;;		case cborBdFalse:
0000000000000000000000000000000000000000;;			n.v = valueTypeBool
0000000000000000000000000000000000000000;;			n.b = false
0000000000000000000000000000000000000000;;		case cborBdTrue:
0000000000000000000000000000000000000000;;			n.v = valueTypeBool
0000000000000000000000000000000000000000;;			n.b = true
0000000000000000000000000000000000000000;;		case cborBdFloat16, cborBdFloat32:
0000000000000000000000000000000000000000;;			n.v = valueTypeFloat
0000000000000000000000000000000000000000;;			n.f = d.DecodeFloat(true)
0000000000000000000000000000000000000000;;		case cborBdFloat64:
0000000000000000000000000000000000000000;;			n.v = valueTypeFloat
0000000000000000000000000000000000000000;;			n.f = d.DecodeFloat(false)
0000000000000000000000000000000000000000;;		case cborBdIndefiniteBytes:
0000000000000000000000000000000000000000;;			n.v = valueTypeBytes
0000000000000000000000000000000000000000;;			n.l = d.DecodeBytes(nil, false, false)
0000000000000000000000000000000000000000;;		case cborBdIndefiniteString:
0000000000000000000000000000000000000000;;			n.v = valueTypeString
0000000000000000000000000000000000000000;;			n.s = d.DecodeString()
0000000000000000000000000000000000000000;;		case cborBdIndefiniteArray:
0000000000000000000000000000000000000000;;			n.v = valueTypeArray
0000000000000000000000000000000000000000;;			decodeFurther = true
0000000000000000000000000000000000000000;;		case cborBdIndefiniteMap:
0000000000000000000000000000000000000000;;			n.v = valueTypeMap
0000000000000000000000000000000000000000;;			decodeFurther = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case d.bd >= cborBaseUint && d.bd < cborBaseNegInt:
0000000000000000000000000000000000000000;;				if d.h.SignedInteger {
0000000000000000000000000000000000000000;;					n.v = valueTypeInt
0000000000000000000000000000000000000000;;					n.i = d.DecodeInt(64)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					n.v = valueTypeUint
0000000000000000000000000000000000000000;;					n.u = d.DecodeUint(64)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case d.bd >= cborBaseNegInt && d.bd < cborBaseBytes:
0000000000000000000000000000000000000000;;				n.v = valueTypeInt
0000000000000000000000000000000000000000;;				n.i = d.DecodeInt(64)
0000000000000000000000000000000000000000;;			case d.bd >= cborBaseBytes && d.bd < cborBaseString:
0000000000000000000000000000000000000000;;				n.v = valueTypeBytes
0000000000000000000000000000000000000000;;				n.l = d.DecodeBytes(nil, false, false)
0000000000000000000000000000000000000000;;			case d.bd >= cborBaseString && d.bd < cborBaseArray:
0000000000000000000000000000000000000000;;				n.v = valueTypeString
0000000000000000000000000000000000000000;;				n.s = d.DecodeString()
0000000000000000000000000000000000000000;;			case d.bd >= cborBaseArray && d.bd < cborBaseMap:
0000000000000000000000000000000000000000;;				n.v = valueTypeArray
0000000000000000000000000000000000000000;;				decodeFurther = true
0000000000000000000000000000000000000000;;			case d.bd >= cborBaseMap && d.bd < cborBaseTag:
0000000000000000000000000000000000000000;;				n.v = valueTypeMap
0000000000000000000000000000000000000000;;				decodeFurther = true
0000000000000000000000000000000000000000;;			case d.bd >= cborBaseTag && d.bd < cborBaseSimple:
0000000000000000000000000000000000000000;;				n.v = valueTypeExt
0000000000000000000000000000000000000000;;				n.u = d.decUint()
0000000000000000000000000000000000000000;;				n.l = nil
0000000000000000000000000000000000000000;;				// d.bdRead = false
0000000000000000000000000000000000000000;;				// d.d.decode(&re.Value) // handled by decode itself.
0000000000000000000000000000000000000000;;				// decodeFurther = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				d.d.errorf("decodeNaked: Unrecognized d.bd: 0x%x", d.bd)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !decodeFurther {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CborHandle is a Handle for the CBOR encoding format,
0000000000000000000000000000000000000000;;	// defined at http://tools.ietf.org/html/rfc7049 and documented further at http://cbor.io .
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// CBOR is comprehensively supported, including support for:
0000000000000000000000000000000000000000;;	//   - indefinite-length arrays/maps/bytes/strings
0000000000000000000000000000000000000000;;	//   - (extension) tags in range 0..0xffff (0 .. 65535)
0000000000000000000000000000000000000000;;	//   - half, single and double-precision floats
0000000000000000000000000000000000000000;;	//   - all numbers (1, 2, 4 and 8-byte signed and unsigned integers)
0000000000000000000000000000000000000000;;	//   - nil, true, false, ...
0000000000000000000000000000000000000000;;	//   - arrays and maps, bytes and text strings
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// None of the optional extensions (with tags) defined in the spec are supported out-of-the-box.
0000000000000000000000000000000000000000;;	// Users can implement them as needed (using SetExt), including spec-documented ones:
0000000000000000000000000000000000000000;;	//   - timestamp, BigNum, BigFloat, Decimals, Encoded Text (e.g. URL, regexp, base64, MIME Message), etc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To encode with indefinite lengths (streaming), users will use
0000000000000000000000000000000000000000;;	// (Must)Encode methods of *Encoder, along with writing CborStreamXXX constants.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example, to encode "one-byte" as an indefinite length string:
0000000000000000000000000000000000000000;;	//     var buf bytes.Buffer
0000000000000000000000000000000000000000;;	//     e := NewEncoder(&buf, new(CborHandle))
0000000000000000000000000000000000000000;;	//     buf.WriteByte(CborStreamString)
0000000000000000000000000000000000000000;;	//     e.MustEncode("one-")
0000000000000000000000000000000000000000;;	//     e.MustEncode("byte")
0000000000000000000000000000000000000000;;	//     buf.WriteByte(CborStreamBreak)
0000000000000000000000000000000000000000;;	//     encodedBytes := buf.Bytes()
0000000000000000000000000000000000000000;;	//     var vv interface{}
0000000000000000000000000000000000000000;;	//     NewDecoderBytes(buf.Bytes(), new(CborHandle)).MustDecode(&vv)
0000000000000000000000000000000000000000;;	//     // Now, vv contains the same string "one-byte"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type CborHandle struct {
0000000000000000000000000000000000000000;;		binaryEncodingType
0000000000000000000000000000000000000000;;		BasicHandle
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *CborHandle) SetInterfaceExt(rt reflect.Type, tag uint64, ext InterfaceExt) (err error) {
0000000000000000000000000000000000000000;;		return h.SetExt(rt, tag, &setExtWrapper{i: ext})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *CborHandle) newEncDriver(e *Encoder) encDriver {
0000000000000000000000000000000000000000;;		return &cborEncDriver{e: e, w: e.w, h: h}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *CborHandle) newDecDriver(d *Decoder) decDriver {
0000000000000000000000000000000000000000;;		return &cborDecDriver{d: d, r: d.r, h: h, br: d.bytes}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *cborEncDriver) reset() {
0000000000000000000000000000000000000000;;		e.w = e.e.w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *cborDecDriver) reset() {
0000000000000000000000000000000000000000;;		d.r = d.d.r
0000000000000000000000000000000000000000;;		d.bd, d.bdRead = 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ decDriver = (*cborDecDriver)(nil)
0000000000000000000000000000000000000000;;	var _ encDriver = (*cborEncDriver)(nil)
