0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/encode.go[Godeps/_workspace/src/github.com/ugorji/go/codec/encode.go][vendor/github.com/ugorji/go/codec/encode.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defEncByteBufSize = 1 << 6 // 4:16, 6:64, 8:256, 10:1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsSymbolFlag defines what should be encoded as symbols.
0000000000000000000000000000000000000000;;	type AsSymbolFlag uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// AsSymbolDefault is default.
0000000000000000000000000000000000000000;;		// Currently, this means only encode struct field names as symbols.
0000000000000000000000000000000000000000;;		// The default is subject to change.
0000000000000000000000000000000000000000;;		AsSymbolDefault AsSymbolFlag = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AsSymbolAll means encode anything which could be a symbol as a symbol.
0000000000000000000000000000000000000000;;		AsSymbolAll = 0xfe
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AsSymbolNone means do not encode anything as a symbol.
0000000000000000000000000000000000000000;;		AsSymbolNone = 1 << iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AsSymbolMapStringKeys means encode keys in map[string]XXX as symbols.
0000000000000000000000000000000000000000;;		AsSymbolMapStringKeysFlag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AsSymbolStructFieldName means encode struct field names as symbols.
0000000000000000000000000000000000000000;;		AsSymbolStructFieldNameFlag
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encWriter abstracts writing to a byte array or to an io.Writer.
0000000000000000000000000000000000000000;;	type encWriter interface {
0000000000000000000000000000000000000000;;		writeb([]byte)
0000000000000000000000000000000000000000;;		writestr(string)
0000000000000000000000000000000000000000;;		writen1(byte)
0000000000000000000000000000000000000000;;		writen2(byte, byte)
0000000000000000000000000000000000000000;;		atEndOfEncode()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encDriver abstracts the actual codec (binc vs msgpack, etc)
0000000000000000000000000000000000000000;;	type encDriver interface {
0000000000000000000000000000000000000000;;		IsBuiltinType(rt uintptr) bool
0000000000000000000000000000000000000000;;		EncodeBuiltin(rt uintptr, v interface{})
0000000000000000000000000000000000000000;;		EncodeNil()
0000000000000000000000000000000000000000;;		EncodeInt(i int64)
0000000000000000000000000000000000000000;;		EncodeUint(i uint64)
0000000000000000000000000000000000000000;;		EncodeBool(b bool)
0000000000000000000000000000000000000000;;		EncodeFloat32(f float32)
0000000000000000000000000000000000000000;;		EncodeFloat64(f float64)
0000000000000000000000000000000000000000;;		// encodeExtPreamble(xtag byte, length int)
0000000000000000000000000000000000000000;;		EncodeRawExt(re *RawExt, e *Encoder)
0000000000000000000000000000000000000000;;		EncodeExt(v interface{}, xtag uint64, ext Ext, e *Encoder)
0000000000000000000000000000000000000000;;		EncodeArrayStart(length int)
0000000000000000000000000000000000000000;;		EncodeMapStart(length int)
0000000000000000000000000000000000000000;;		EncodeString(c charEncoding, v string)
0000000000000000000000000000000000000000;;		EncodeSymbol(v string)
0000000000000000000000000000000000000000;;		EncodeStringBytes(c charEncoding, v []byte)
0000000000000000000000000000000000000000;;		//TODO
0000000000000000000000000000000000000000;;		//encBignum(f *big.Int)
0000000000000000000000000000000000000000;;		//encStringRunes(c charEncoding, v []rune)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encDriverAsis interface {
0000000000000000000000000000000000000000;;		EncodeAsis(v []byte)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encNoSeparator struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ encNoSeparator) EncodeEnd() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ioEncWriterWriter interface {
0000000000000000000000000000000000000000;;		WriteByte(c byte) error
0000000000000000000000000000000000000000;;		WriteString(s string) (n int, err error)
0000000000000000000000000000000000000000;;		Write(p []byte) (n int, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ioEncStringWriter interface {
0000000000000000000000000000000000000000;;		WriteString(s string) (n int, err error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EncodeOptions struct {
0000000000000000000000000000000000000000;;		// Encode a struct as an array, and not as a map
0000000000000000000000000000000000000000;;		StructToArray bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Canonical representation means that encoding a value will always result in the same
0000000000000000000000000000000000000000;;		// sequence of bytes.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This only affects maps, as the iteration order for maps is random.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The implementation MAY use the natural sort order for the map keys if possible:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//     - If there is a natural sort order (ie for number, bool, string or []byte keys),
0000000000000000000000000000000000000000;;		//       then the map keys are first sorted in natural order and then written
0000000000000000000000000000000000000000;;		//       with corresponding map values to the strema.
0000000000000000000000000000000000000000;;		//     - If there is no natural sort order, then the map keys will first be
0000000000000000000000000000000000000000;;		//       encoded into []byte, and then sorted,
0000000000000000000000000000000000000000;;		//       before writing the sorted keys and the corresponding map values to the stream.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		Canonical bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CheckCircularRef controls whether we check for circular references
0000000000000000000000000000000000000000;;		// and error fast during an encode.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If enabled, an error is received if a pointer to a struct
0000000000000000000000000000000000000000;;		// references itself either directly or through one of its fields (iteratively).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This is opt-in, as there may be a performance hit to checking circular references.
0000000000000000000000000000000000000000;;		CheckCircularRef bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RecursiveEmptyCheck controls whether we descend into interfaces, structs and pointers
0000000000000000000000000000000000000000;;		// when checking if a value is empty.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note that this may make OmitEmpty more expensive, as it incurs a lot more reflect calls.
0000000000000000000000000000000000000000;;		RecursiveEmptyCheck bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Raw controls whether we encode Raw values.
0000000000000000000000000000000000000000;;		// This is a "dangerous" option and must be explicitly set.
0000000000000000000000000000000000000000;;		// If set, we blindly encode Raw values as-is, without checking
0000000000000000000000000000000000000000;;		// if they are a correct representation of a value in that format.
0000000000000000000000000000000000000000;;		// If unset, we error out.
0000000000000000000000000000000000000000;;		Raw bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AsSymbols defines what should be encoded as symbols.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Encoding as symbols can reduce the encoded size significantly.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// However, during decoding, each string to be encoded as a symbol must
0000000000000000000000000000000000000000;;		// be checked to see if it has been seen before. Consequently, encoding time
0000000000000000000000000000000000000000;;		// will increase if using symbols, because string comparisons has a clear cost.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Sample values:
0000000000000000000000000000000000000000;;		//   AsSymbolNone
0000000000000000000000000000000000000000;;		//   AsSymbolAll
0000000000000000000000000000000000000000;;		//   AsSymbolMapStringKeys
0000000000000000000000000000000000000000;;		//   AsSymbolMapStringKeysFlag | AsSymbolStructFieldNameFlag
0000000000000000000000000000000000000000;;		AsSymbols AsSymbolFlag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ---------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleIoEncWriterWriter struct {
0000000000000000000000000000000000000000;;		w  io.Writer
0000000000000000000000000000000000000000;;		bw io.ByteWriter
0000000000000000000000000000000000000000;;		sw ioEncStringWriter
0000000000000000000000000000000000000000;;		bs [1]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *simpleIoEncWriterWriter) WriteByte(c byte) (err error) {
0000000000000000000000000000000000000000;;		if o.bw != nil {
0000000000000000000000000000000000000000;;			return o.bw.WriteByte(c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// _, err = o.w.Write([]byte{c})
0000000000000000000000000000000000000000;;		o.bs[0] = c
0000000000000000000000000000000000000000;;		_, err = o.w.Write(o.bs[:])
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *simpleIoEncWriterWriter) WriteString(s string) (n int, err error) {
0000000000000000000000000000000000000000;;		if o.sw != nil {
0000000000000000000000000000000000000000;;			return o.sw.WriteString(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// return o.w.Write([]byte(s))
0000000000000000000000000000000000000000;;		return o.w.Write(bytesView(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *simpleIoEncWriterWriter) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return o.w.Write(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ioEncWriter implements encWriter and can write to an io.Writer implementation
0000000000000000000000000000000000000000;;	type ioEncWriter struct {
0000000000000000000000000000000000000000;;		w ioEncWriterWriter
0000000000000000000000000000000000000000;;		s simpleIoEncWriterWriter
0000000000000000000000000000000000000000;;		// x [8]byte // temp byte array re-used internally for efficiency
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioEncWriter) writeb(bs []byte) {
0000000000000000000000000000000000000000;;		if len(bs) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := z.w.Write(bs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != len(bs) {
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("incorrect num bytes written. Expecting: %v, Wrote: %v", len(bs), n))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioEncWriter) writestr(s string) {
0000000000000000000000000000000000000000;;		n, err := z.w.WriteString(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != len(s) {
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("incorrect num bytes written. Expecting: %v, Wrote: %v", len(s), n))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioEncWriter) writen1(b byte) {
0000000000000000000000000000000000000000;;		if err := z.w.WriteByte(b); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioEncWriter) writen2(b1 byte, b2 byte) {
0000000000000000000000000000000000000000;;		z.writen1(b1)
0000000000000000000000000000000000000000;;		z.writen1(b2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioEncWriter) atEndOfEncode() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bytesEncWriter implements encWriter and can write to an byte slice.
0000000000000000000000000000000000000000;;	// It is used by Marshal function.
0000000000000000000000000000000000000000;;	type bytesEncWriter struct {
0000000000000000000000000000000000000000;;		b   []byte
0000000000000000000000000000000000000000;;		c   int     // cursor
0000000000000000000000000000000000000000;;		out *[]byte // write out on atEndOfEncode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesEncWriter) writeb(s []byte) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oc, a := z.growNoAlloc(len(s))
0000000000000000000000000000000000000000;;		if a {
0000000000000000000000000000000000000000;;			z.growAlloc(len(s), oc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(z.b[oc:], s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesEncWriter) writestr(s string) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oc, a := z.growNoAlloc(len(s))
0000000000000000000000000000000000000000;;		if a {
0000000000000000000000000000000000000000;;			z.growAlloc(len(s), oc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(z.b[oc:], s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesEncWriter) writen1(b1 byte) {
0000000000000000000000000000000000000000;;		oc, a := z.growNoAlloc(1)
0000000000000000000000000000000000000000;;		if a {
0000000000000000000000000000000000000000;;			z.growAlloc(1, oc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.b[oc] = b1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesEncWriter) writen2(b1 byte, b2 byte) {
0000000000000000000000000000000000000000;;		oc, a := z.growNoAlloc(2)
0000000000000000000000000000000000000000;;		if a {
0000000000000000000000000000000000000000;;			z.growAlloc(2, oc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.b[oc+1] = b2
0000000000000000000000000000000000000000;;		z.b[oc] = b1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesEncWriter) atEndOfEncode() {
0000000000000000000000000000000000000000;;		*(z.out) = z.b[:z.c]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// have a growNoalloc(n int), which can be inlined.
0000000000000000000000000000000000000000;;	// if allocation is needed, then call growAlloc(n int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesEncWriter) growNoAlloc(n int) (oldcursor int, allocNeeded bool) {
0000000000000000000000000000000000000000;;		oldcursor = z.c
0000000000000000000000000000000000000000;;		z.c = z.c + n
0000000000000000000000000000000000000000;;		if z.c > len(z.b) {
0000000000000000000000000000000000000000;;			if z.c > cap(z.b) {
0000000000000000000000000000000000000000;;				allocNeeded = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				z.b = z.b[:cap(z.b)]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesEncWriter) growAlloc(n int, oldcursor int) {
0000000000000000000000000000000000000000;;		// appendslice logic (if cap < 1024, *2, else *1.25): more expensive. many copy calls.
0000000000000000000000000000000000000000;;		// bytes.Buffer model (2*cap + n): much better
0000000000000000000000000000000000000000;;		// bs := make([]byte, 2*cap(z.b)+n)
0000000000000000000000000000000000000000;;		bs := make([]byte, growCap(cap(z.b), 1, n))
0000000000000000000000000000000000000000;;		copy(bs, z.b[:oldcursor])
0000000000000000000000000000000000000000;;		z.b = bs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ---------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encFnInfo struct {
0000000000000000000000000000000000000000;;		e     *Encoder
0000000000000000000000000000000000000000;;		ti    *typeInfo
0000000000000000000000000000000000000000;;		xfFn  Ext
0000000000000000000000000000000000000000;;		xfTag uint64
0000000000000000000000000000000000000000;;		seq   seqType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) builtin(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeBuiltin(f.ti.rtid, rv.Interface())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) raw(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.raw(rv.Interface().(Raw))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) rawExt(rv reflect.Value) {
0000000000000000000000000000000000000000;;		// rev := rv.Interface().(RawExt)
0000000000000000000000000000000000000000;;		// f.e.e.EncodeRawExt(&rev, f.e)
0000000000000000000000000000000000000000;;		var re *RawExt
0000000000000000000000000000000000000000;;		if rv.CanAddr() {
0000000000000000000000000000000000000000;;			re = rv.Addr().Interface().(*RawExt)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rev := rv.Interface().(RawExt)
0000000000000000000000000000000000000000;;			re = &rev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.e.e.EncodeRawExt(re, f.e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) ext(rv reflect.Value) {
0000000000000000000000000000000000000000;;		// if this is a struct|array and it was addressable, then pass the address directly (not the value)
0000000000000000000000000000000000000000;;		if k := rv.Kind(); (k == reflect.Struct || k == reflect.Array) && rv.CanAddr() {
0000000000000000000000000000000000000000;;			rv = rv.Addr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.e.e.EncodeExt(rv.Interface(), f.xfTag, f.xfFn, f.e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) getValueForMarshalInterface(rv reflect.Value, indir int8) (v interface{}, proceed bool) {
0000000000000000000000000000000000000000;;		if indir == 0 {
0000000000000000000000000000000000000000;;			v = rv.Interface()
0000000000000000000000000000000000000000;;		} else if indir == -1 {
0000000000000000000000000000000000000000;;			// If a non-pointer was passed to Encode(), then that value is not addressable.
0000000000000000000000000000000000000000;;			// Take addr if addressable, else copy value to an addressable value.
0000000000000000000000000000000000000000;;			if rv.CanAddr() {
0000000000000000000000000000000000000000;;				v = rv.Addr().Interface()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rv2 := reflect.New(rv.Type())
0000000000000000000000000000000000000000;;				rv2.Elem().Set(rv)
0000000000000000000000000000000000000000;;				v = rv2.Interface()
0000000000000000000000000000000000000000;;				// fmt.Printf("rv.Type: %v, rv2.Type: %v, v: %v\n", rv.Type(), rv2.Type(), v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for j := int8(0); j < indir; j++ {
0000000000000000000000000000000000000000;;				if rv.IsNil() {
0000000000000000000000000000000000000000;;					f.e.e.EncodeNil()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rv = rv.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = rv.Interface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) selferMarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		if v, proceed := f.getValueForMarshalInterface(rv, f.ti.csIndir); proceed {
0000000000000000000000000000000000000000;;			v.(Selfer).CodecEncodeSelf(f.e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) binaryMarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		if v, proceed := f.getValueForMarshalInterface(rv, f.ti.bmIndir); proceed {
0000000000000000000000000000000000000000;;			bs, fnerr := v.(encoding.BinaryMarshaler).MarshalBinary()
0000000000000000000000000000000000000000;;			f.e.marshal(bs, fnerr, false, c_RAW)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) textMarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		if v, proceed := f.getValueForMarshalInterface(rv, f.ti.tmIndir); proceed {
0000000000000000000000000000000000000000;;			// debugf(">>>> encoding.TextMarshaler: %T", rv.Interface())
0000000000000000000000000000000000000000;;			bs, fnerr := v.(encoding.TextMarshaler).MarshalText()
0000000000000000000000000000000000000000;;			f.e.marshal(bs, fnerr, false, c_UTF8)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) jsonMarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		if v, proceed := f.getValueForMarshalInterface(rv, f.ti.jmIndir); proceed {
0000000000000000000000000000000000000000;;			bs, fnerr := v.(jsonMarshaler).MarshalJSON()
0000000000000000000000000000000000000000;;			f.e.marshal(bs, fnerr, true, c_UTF8)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kBool(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeBool(rv.Bool())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kString(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeString(c_UTF8, rv.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kFloat64(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeFloat64(rv.Float())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kFloat32(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeFloat32(float32(rv.Float()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kInt(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeInt(rv.Int())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kUint(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeUint(rv.Uint())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kInvalid(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.e.EncodeNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kErr(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.e.errorf("unsupported kind %s, for %#v", rv.Kind(), rv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kSlice(rv reflect.Value) {
0000000000000000000000000000000000000000;;		ti := f.ti
0000000000000000000000000000000000000000;;		// array may be non-addressable, so we have to manage with care
0000000000000000000000000000000000000000;;		//   (don't call rv.Bytes, rv.Slice, etc).
0000000000000000000000000000000000000000;;		// E.g. type struct S{B [2]byte};
0000000000000000000000000000000000000000;;		//   Encode(S{}) will bomb on "panic: slice of unaddressable array".
0000000000000000000000000000000000000000;;		e := f.e
0000000000000000000000000000000000000000;;		if f.seq != seqTypeArray {
0000000000000000000000000000000000000000;;			if rv.IsNil() {
0000000000000000000000000000000000000000;;				e.e.EncodeNil()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If in this method, then there was no extension function defined.
0000000000000000000000000000000000000000;;			// So it's okay to treat as []byte.
0000000000000000000000000000000000000000;;			if ti.rtid == uint8SliceTypId {
0000000000000000000000000000000000000000;;				e.e.EncodeStringBytes(c_RAW, rv.Bytes())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr := e.cr
0000000000000000000000000000000000000000;;		rtelem := ti.rt.Elem()
0000000000000000000000000000000000000000;;		l := rv.Len()
0000000000000000000000000000000000000000;;		if ti.rtid == uint8SliceTypId || rtelem.Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;			switch f.seq {
0000000000000000000000000000000000000000;;			case seqTypeArray:
0000000000000000000000000000000000000000;;				// if l == 0 { e.e.encodeStringBytes(c_RAW, nil) } else
0000000000000000000000000000000000000000;;				if rv.CanAddr() {
0000000000000000000000000000000000000000;;					e.e.EncodeStringBytes(c_RAW, rv.Slice(0, l).Bytes())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					var bs []byte
0000000000000000000000000000000000000000;;					if l <= cap(e.b) {
0000000000000000000000000000000000000000;;						bs = e.b[:l]
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						bs = make([]byte, l)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					reflect.Copy(reflect.ValueOf(bs), rv)
0000000000000000000000000000000000000000;;					// TODO: Test that reflect.Copy works instead of manual one-by-one
0000000000000000000000000000000000000000;;					// for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;					// 	bs[i] = byte(rv.Index(i).Uint())
0000000000000000000000000000000000000000;;					// }
0000000000000000000000000000000000000000;;					e.e.EncodeStringBytes(c_RAW, bs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case seqTypeSlice:
0000000000000000000000000000000000000000;;				e.e.EncodeStringBytes(c_RAW, rv.Bytes())
0000000000000000000000000000000000000000;;			case seqTypeChan:
0000000000000000000000000000000000000000;;				bs := e.b[:0]
0000000000000000000000000000000000000000;;				// do not use range, so that the number of elements encoded
0000000000000000000000000000000000000000;;				// does not change, and encoding does not hang waiting on someone to close chan.
0000000000000000000000000000000000000000;;				// for b := range rv.Interface().(<-chan byte) {
0000000000000000000000000000000000000000;;				// 	bs = append(bs, b)
0000000000000000000000000000000000000000;;				// }
0000000000000000000000000000000000000000;;				ch := rv.Interface().(<-chan byte)
0000000000000000000000000000000000000000;;				for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;					bs = append(bs, <-ch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.e.EncodeStringBytes(c_RAW, bs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ti.mbs {
0000000000000000000000000000000000000000;;			if l%2 == 1 {
0000000000000000000000000000000000000000;;				e.errorf("mapBySlice requires even slice length, but got %v", l)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.e.EncodeMapStart(l / 2)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.e.EncodeArrayStart(l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l > 0 {
0000000000000000000000000000000000000000;;			for rtelem.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				rtelem = rtelem.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if kind is reflect.Interface, do not pre-determine the
0000000000000000000000000000000000000000;;			// encoding type, because preEncodeValue may break it down to
0000000000000000000000000000000000000000;;			// a concrete type and kInterface will bomb.
0000000000000000000000000000000000000000;;			var fn *encFn
0000000000000000000000000000000000000000;;			if rtelem.Kind() != reflect.Interface {
0000000000000000000000000000000000000000;;				rtelemid := reflect.ValueOf(rtelem).Pointer()
0000000000000000000000000000000000000000;;				fn = e.getEncFn(rtelemid, rtelem, true, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO: Consider perf implication of encoding odd index values as symbols if type is string
0000000000000000000000000000000000000000;;			for j := 0; j < l; j++ {
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					if ti.mbs {
0000000000000000000000000000000000000000;;						if j%2 == 0 {
0000000000000000000000000000000000000000;;							cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerArrayElem)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if f.seq == seqTypeChan {
0000000000000000000000000000000000000000;;					if rv2, ok2 := rv.Recv(); ok2 {
0000000000000000000000000000000000000000;;						e.encodeValue(rv2, fn)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						e.encode(nil) // WE HAVE TO DO SOMETHING, so nil if nothing received.
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					e.encodeValue(rv.Index(j), fn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cr != nil {
0000000000000000000000000000000000000000;;			if ti.mbs {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerArrayEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kStruct(rv reflect.Value) {
0000000000000000000000000000000000000000;;		fti := f.ti
0000000000000000000000000000000000000000;;		e := f.e
0000000000000000000000000000000000000000;;		cr := e.cr
0000000000000000000000000000000000000000;;		tisfi := fti.sfip
0000000000000000000000000000000000000000;;		toMap := !(fti.toArray || e.h.StructToArray)
0000000000000000000000000000000000000000;;		newlen := len(fti.sfi)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use sync.Pool to reduce allocating slices unnecessarily.
0000000000000000000000000000000000000000;;		// The cost of sync.Pool is less than the cost of new allocation.
0000000000000000000000000000000000000000;;		pool, poolv, fkvs := encStructPoolGet(newlen)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if toMap, use the sorted array. If toArray, use unsorted array (to match sequence in struct)
0000000000000000000000000000000000000000;;		if toMap {
0000000000000000000000000000000000000000;;			tisfi = fti.sfi
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newlen = 0
0000000000000000000000000000000000000000;;		var kv stringRv
0000000000000000000000000000000000000000;;		recur := e.h.RecursiveEmptyCheck
0000000000000000000000000000000000000000;;		for _, si := range tisfi {
0000000000000000000000000000000000000000;;			kv.r = si.field(rv, false)
0000000000000000000000000000000000000000;;			if toMap {
0000000000000000000000000000000000000000;;				if si.omitEmpty && isEmptyValue(kv.r, recur, recur) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kv.v = si.encName
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// use the zero value.
0000000000000000000000000000000000000000;;				// if a reference or struct, set to nil (so you do not output too much)
0000000000000000000000000000000000000000;;				if si.omitEmpty && isEmptyValue(kv.r, recur, recur) {
0000000000000000000000000000000000000000;;					switch kv.r.Kind() {
0000000000000000000000000000000000000000;;					case reflect.Struct, reflect.Interface, reflect.Ptr, reflect.Array, reflect.Map, reflect.Slice:
0000000000000000000000000000000000000000;;						kv.r = reflect.Value{} //encode as nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fkvs[newlen] = kv
0000000000000000000000000000000000000000;;			newlen++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// debugf(">>>> kStruct: newlen: %v", newlen)
0000000000000000000000000000000000000000;;		// sep := !e.be
0000000000000000000000000000000000000000;;		ee := e.e //don't dereference every time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if toMap {
0000000000000000000000000000000000000000;;			ee.EncodeMapStart(newlen)
0000000000000000000000000000000000000000;;			// asSymbols := e.h.AsSymbols&AsSymbolStructFieldNameFlag != 0
0000000000000000000000000000000000000000;;			asSymbols := e.h.AsSymbols == AsSymbolDefault || e.h.AsSymbols&AsSymbolStructFieldNameFlag != 0
0000000000000000000000000000000000000000;;			for j := 0; j < newlen; j++ {
0000000000000000000000000000000000000000;;				kv = fkvs[j]
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if asSymbols {
0000000000000000000000000000000000000000;;					ee.EncodeSymbol(kv.v)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ee.EncodeString(c_UTF8, kv.v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.encodeValue(kv.r, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ee.EncodeArrayStart(newlen)
0000000000000000000000000000000000000000;;			for j := 0; j < newlen; j++ {
0000000000000000000000000000000000000000;;				kv = fkvs[j]
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerArrayElem)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.encodeValue(kv.r, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerArrayEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do not use defer. Instead, use explicit pool return at end of function.
0000000000000000000000000000000000000000;;		// defer has a cost we are trying to avoid.
0000000000000000000000000000000000000000;;		// If there is a panic and these slices are not returned, it is ok.
0000000000000000000000000000000000000000;;		if pool != nil {
0000000000000000000000000000000000000000;;			pool.Put(poolv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (f *encFnInfo) kPtr(rv reflect.Value) {
0000000000000000000000000000000000000000;;	// 	debugf(">>>>>>> ??? encode kPtr called - shouldn't get called")
0000000000000000000000000000000000000000;;	// 	if rv.IsNil() {
0000000000000000000000000000000000000000;;	// 		f.e.e.encodeNil()
0000000000000000000000000000000000000000;;	// 		return
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	f.e.encodeValue(rv.Elem())
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (f *encFnInfo) kInterface(rv reflect.Value) {
0000000000000000000000000000000000000000;;	// 	println("kInterface called")
0000000000000000000000000000000000000000;;	// 	debug.PrintStack()
0000000000000000000000000000000000000000;;	// 	if rv.IsNil() {
0000000000000000000000000000000000000000;;	// 		f.e.e.EncodeNil()
0000000000000000000000000000000000000000;;	// 		return
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	f.e.encodeValue(rv.Elem(), nil)
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *encFnInfo) kMap(rv reflect.Value) {
0000000000000000000000000000000000000000;;		ee := f.e.e
0000000000000000000000000000000000000000;;		if rv.IsNil() {
0000000000000000000000000000000000000000;;			ee.EncodeNil()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := rv.Len()
0000000000000000000000000000000000000000;;		ee.EncodeMapStart(l)
0000000000000000000000000000000000000000;;		e := f.e
0000000000000000000000000000000000000000;;		cr := e.cr
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var asSymbols bool
0000000000000000000000000000000000000000;;		// determine the underlying key and val encFn's for the map.
0000000000000000000000000000000000000000;;		// This eliminates some work which is done for each loop iteration i.e.
0000000000000000000000000000000000000000;;		// rv.Type(), ref.ValueOf(rt).Pointer(), then check map/list for fn.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// However, if kind is reflect.Interface, do not pre-determine the
0000000000000000000000000000000000000000;;		// encoding type, because preEncodeValue may break it down to
0000000000000000000000000000000000000000;;		// a concrete type and kInterface will bomb.
0000000000000000000000000000000000000000;;		var keyFn, valFn *encFn
0000000000000000000000000000000000000000;;		ti := f.ti
0000000000000000000000000000000000000000;;		rtkey := ti.rt.Key()
0000000000000000000000000000000000000000;;		rtval := ti.rt.Elem()
0000000000000000000000000000000000000000;;		rtkeyid := reflect.ValueOf(rtkey).Pointer()
0000000000000000000000000000000000000000;;		// keyTypeIsString := f.ti.rt.Key().Kind() == reflect.String
0000000000000000000000000000000000000000;;		var keyTypeIsString = rtkeyid == stringTypId
0000000000000000000000000000000000000000;;		if keyTypeIsString {
0000000000000000000000000000000000000000;;			asSymbols = e.h.AsSymbols&AsSymbolMapStringKeysFlag != 0
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for rtkey.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				rtkey = rtkey.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rtkey.Kind() != reflect.Interface {
0000000000000000000000000000000000000000;;				rtkeyid = reflect.ValueOf(rtkey).Pointer()
0000000000000000000000000000000000000000;;				keyFn = e.getEncFn(rtkeyid, rtkey, true, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for rtval.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			rtval = rtval.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rtval.Kind() != reflect.Interface {
0000000000000000000000000000000000000000;;			rtvalid := reflect.ValueOf(rtval).Pointer()
0000000000000000000000000000000000000000;;			valFn = e.getEncFn(rtvalid, rtval, true, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mks := rv.MapKeys()
0000000000000000000000000000000000000000;;		// for j, lmks := 0, len(mks); j < lmks; j++ {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.h.Canonical {
0000000000000000000000000000000000000000;;			e.kMapCanonical(rtkeyid, rtkey, rv, mks, valFn, asSymbols)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for j := range mks {
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if keyTypeIsString {
0000000000000000000000000000000000000000;;					if asSymbols {
0000000000000000000000000000000000000000;;						ee.EncodeSymbol(mks[j].String())
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						ee.EncodeString(c_UTF8, mks[j].String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					e.encodeValue(mks[j], keyFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.encodeValue(rv.MapIndex(mks[j]), valFn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cr != nil {
0000000000000000000000000000000000000000;;			cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) kMapCanonical(rtkeyid uintptr, rtkey reflect.Type, rv reflect.Value, mks []reflect.Value, valFn *encFn, asSymbols bool) {
0000000000000000000000000000000000000000;;		ee := e.e
0000000000000000000000000000000000000000;;		cr := e.cr
0000000000000000000000000000000000000000;;		// we previously did out-of-band if an extension was registered.
0000000000000000000000000000000000000000;;		// This is not necessary, as the natural kind is sufficient for ordering.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rtkeyid == uint8SliceTypId {
0000000000000000000000000000000000000000;;			mksv := make([]bytesRv, len(mks))
0000000000000000000000000000000000000000;;			for i, k := range mks {
0000000000000000000000000000000000000000;;				v := &mksv[i]
0000000000000000000000000000000000000000;;				v.r = k
0000000000000000000000000000000000000000;;				v.v = k.Bytes()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(bytesRvSlice(mksv))
0000000000000000000000000000000000000000;;			for i := range mksv {
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ee.EncodeStringBytes(c_RAW, mksv[i].v)
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e.encodeValue(rv.MapIndex(mksv[i].r), valFn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			switch rtkey.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				mksv := make([]boolRv, len(mks))
0000000000000000000000000000000000000000;;				for i, k := range mks {
0000000000000000000000000000000000000000;;					v := &mksv[i]
0000000000000000000000000000000000000000;;					v.r = k
0000000000000000000000000000000000000000;;					v.v = k.Bool()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(boolRvSlice(mksv))
0000000000000000000000000000000000000000;;				for i := range mksv {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ee.EncodeBool(mksv[i].v)
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.encodeValue(rv.MapIndex(mksv[i].r), valFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				mksv := make([]stringRv, len(mks))
0000000000000000000000000000000000000000;;				for i, k := range mks {
0000000000000000000000000000000000000000;;					v := &mksv[i]
0000000000000000000000000000000000000000;;					v.r = k
0000000000000000000000000000000000000000;;					v.v = k.String()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(stringRvSlice(mksv))
0000000000000000000000000000000000000000;;				for i := range mksv {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if asSymbols {
0000000000000000000000000000000000000000;;						ee.EncodeSymbol(mksv[i].v)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						ee.EncodeString(c_UTF8, mksv[i].v)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.encodeValue(rv.MapIndex(mksv[i].r), valFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint, reflect.Uintptr:
0000000000000000000000000000000000000000;;				mksv := make([]uintRv, len(mks))
0000000000000000000000000000000000000000;;				for i, k := range mks {
0000000000000000000000000000000000000000;;					v := &mksv[i]
0000000000000000000000000000000000000000;;					v.r = k
0000000000000000000000000000000000000000;;					v.v = k.Uint()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(uintRvSlice(mksv))
0000000000000000000000000000000000000000;;				for i := range mksv {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ee.EncodeUint(mksv[i].v)
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.encodeValue(rv.MapIndex(mksv[i].r), valFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
0000000000000000000000000000000000000000;;				mksv := make([]intRv, len(mks))
0000000000000000000000000000000000000000;;				for i, k := range mks {
0000000000000000000000000000000000000000;;					v := &mksv[i]
0000000000000000000000000000000000000000;;					v.r = k
0000000000000000000000000000000000000000;;					v.v = k.Int()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(intRvSlice(mksv))
0000000000000000000000000000000000000000;;				for i := range mksv {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ee.EncodeInt(mksv[i].v)
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.encodeValue(rv.MapIndex(mksv[i].r), valFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Float32:
0000000000000000000000000000000000000000;;				mksv := make([]floatRv, len(mks))
0000000000000000000000000000000000000000;;				for i, k := range mks {
0000000000000000000000000000000000000000;;					v := &mksv[i]
0000000000000000000000000000000000000000;;					v.r = k
0000000000000000000000000000000000000000;;					v.v = k.Float()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(floatRvSlice(mksv))
0000000000000000000000000000000000000000;;				for i := range mksv {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ee.EncodeFloat32(float32(mksv[i].v))
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.encodeValue(rv.MapIndex(mksv[i].r), valFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Float64:
0000000000000000000000000000000000000000;;				mksv := make([]floatRv, len(mks))
0000000000000000000000000000000000000000;;				for i, k := range mks {
0000000000000000000000000000000000000000;;					v := &mksv[i]
0000000000000000000000000000000000000000;;					v.r = k
0000000000000000000000000000000000000000;;					v.v = k.Float()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(floatRvSlice(mksv))
0000000000000000000000000000000000000000;;				for i := range mksv {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ee.EncodeFloat64(mksv[i].v)
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.encodeValue(rv.MapIndex(mksv[i].r), valFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// out-of-band
0000000000000000000000000000000000000000;;				// first encode each key to a []byte first, then sort them, then record
0000000000000000000000000000000000000000;;				var mksv []byte = make([]byte, 0, len(mks)*16) // temporary byte slice for the encoding
0000000000000000000000000000000000000000;;				e2 := NewEncoderBytes(&mksv, e.hh)
0000000000000000000000000000000000000000;;				mksbv := make([]bytesRv, len(mks))
0000000000000000000000000000000000000000;;				for i, k := range mks {
0000000000000000000000000000000000000000;;					v := &mksbv[i]
0000000000000000000000000000000000000000;;					l := len(mksv)
0000000000000000000000000000000000000000;;					e2.MustEncode(k)
0000000000000000000000000000000000000000;;					v.r = k
0000000000000000000000000000000000000000;;					v.v = mksv[l:]
0000000000000000000000000000000000000000;;					// fmt.Printf(">>>>> %s\n", mksv[l:])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sort.Sort(bytesRvSlice(mksbv))
0000000000000000000000000000000000000000;;				for j := range mksbv {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.asis(mksbv[j].v)
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					e.encodeValue(rv.MapIndex(mksbv[j].r), valFn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// --------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encFn encapsulates the captured variables and the encode function.
0000000000000000000000000000000000000000;;	// This way, we only do some calculations one times, and pass to the
0000000000000000000000000000000000000000;;	// code block that should be called (encapsulated in a function)
0000000000000000000000000000000000000000;;	// instead of executing the checks every time.
0000000000000000000000000000000000000000;;	type encFn struct {
0000000000000000000000000000000000000000;;		i encFnInfo
0000000000000000000000000000000000000000;;		f func(*encFnInfo, reflect.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// --------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encRtidFn struct {
0000000000000000000000000000000000000000;;		rtid uintptr
0000000000000000000000000000000000000000;;		fn   encFn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Encoder writes an object to an output stream in the codec format.
0000000000000000000000000000000000000000;;	type Encoder struct {
0000000000000000000000000000000000000000;;		// hopefully, reduce derefencing cost by laying the encWriter inside the Encoder
0000000000000000000000000000000000000000;;		e encDriver
0000000000000000000000000000000000000000;;		// NOTE: Encoder shouldn't call it's write methods,
0000000000000000000000000000000000000000;;		// as the handler MAY need to do some coordination.
0000000000000000000000000000000000000000;;		w  encWriter
0000000000000000000000000000000000000000;;		s  []encRtidFn
0000000000000000000000000000000000000000;;		ci set
0000000000000000000000000000000000000000;;		be bool // is binary encoding
0000000000000000000000000000000000000000;;		js bool // is json handle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wi ioEncWriter
0000000000000000000000000000000000000000;;		wb bytesEncWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h  *BasicHandle
0000000000000000000000000000000000000000;;		hh Handle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cr containerStateRecv
0000000000000000000000000000000000000000;;		as encDriverAsis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f map[uintptr]*encFn
0000000000000000000000000000000000000000;;		b [scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder returns an Encoder for encoding into an io.Writer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For efficiency, Users are encouraged to pass in a memory buffered writer
0000000000000000000000000000000000000000;;	// (eg bufio.Writer, bytes.Buffer).
0000000000000000000000000000000000000000;;	func NewEncoder(w io.Writer, h Handle) *Encoder {
0000000000000000000000000000000000000000;;		e := newEncoder(h)
0000000000000000000000000000000000000000;;		e.Reset(w)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoderBytes returns an encoder for encoding directly and efficiently
0000000000000000000000000000000000000000;;	// into a byte slice, using zero-copying to temporary slices.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will potentially replace the output byte slice pointed to.
0000000000000000000000000000000000000000;;	// After encoding, the out parameter contains the encoded contents.
0000000000000000000000000000000000000000;;	func NewEncoderBytes(out *[]byte, h Handle) *Encoder {
0000000000000000000000000000000000000000;;		e := newEncoder(h)
0000000000000000000000000000000000000000;;		e.ResetBytes(out)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newEncoder(h Handle) *Encoder {
0000000000000000000000000000000000000000;;		e := &Encoder{hh: h, h: h.getBasicHandle(), be: h.isBinary()}
0000000000000000000000000000000000000000;;		_, e.js = h.(*JsonHandle)
0000000000000000000000000000000000000000;;		e.e = h.newEncDriver(e)
0000000000000000000000000000000000000000;;		e.as, _ = e.e.(encDriverAsis)
0000000000000000000000000000000000000000;;		e.cr, _ = e.e.(containerStateRecv)
0000000000000000000000000000000000000000;;		return e
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reset the Encoder with a new output stream.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This accommodates using the state of the Encoder,
0000000000000000000000000000000000000000;;	// where it has "cached" information about sub-engines.
0000000000000000000000000000000000000000;;	func (e *Encoder) Reset(w io.Writer) {
0000000000000000000000000000000000000000;;		ww, ok := w.(ioEncWriterWriter)
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			e.wi.w = ww
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sww := &e.wi.s
0000000000000000000000000000000000000000;;			sww.w = w
0000000000000000000000000000000000000000;;			sww.bw, _ = w.(io.ByteWriter)
0000000000000000000000000000000000000000;;			sww.sw, _ = w.(ioEncStringWriter)
0000000000000000000000000000000000000000;;			e.wi.w = sww
0000000000000000000000000000000000000000;;			//ww = bufio.NewWriterSize(w, defEncByteBufSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w = &e.wi
0000000000000000000000000000000000000000;;		e.e.reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) ResetBytes(out *[]byte) {
0000000000000000000000000000000000000000;;		in := *out
0000000000000000000000000000000000000000;;		if in == nil {
0000000000000000000000000000000000000000;;			in = make([]byte, defEncByteBufSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.wb.b, e.wb.out, e.wb.c = in, out, 0
0000000000000000000000000000000000000000;;		e.w = &e.wb
0000000000000000000000000000000000000000;;		e.e.reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (e *Encoder) sendContainerState(c containerState) {
0000000000000000000000000000000000000000;;	// 	if e.cr != nil {
0000000000000000000000000000000000000000;;	// 		e.cr.sendContainerState(c)
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode writes an object into a stream.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Encoding can be configured via the struct tag for the fields.
0000000000000000000000000000000000000000;;	// The "codec" key in struct field's tag value is the key name,
0000000000000000000000000000000000000000;;	// followed by an optional comma and options.
0000000000000000000000000000000000000000;;	// Note that the "json" key is used in the absence of the "codec" key.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To set an option on all fields (e.g. omitempty on all fields), you
0000000000000000000000000000000000000000;;	// can create a field called _struct, and set flags on it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Struct values "usually" encode as maps. Each exported struct field is encoded unless:
0000000000000000000000000000000000000000;;	//    - the field's tag is "-", OR
0000000000000000000000000000000000000000;;	//    - the field is empty (empty or the zero value) and its tag specifies the "omitempty" option.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When encoding as a map, the first string in the tag (before the comma)
0000000000000000000000000000000000000000;;	// is the map key string to use when encoding.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// However, struct values may encode as arrays. This happens when:
0000000000000000000000000000000000000000;;	//    - StructToArray Encode option is set, OR
0000000000000000000000000000000000000000;;	//    - the tag on the _struct field sets the "toarray" option
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Values with types that implement MapBySlice are encoded as stream maps.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The empty values (for omitempty option) are false, 0, any nil pointer
0000000000000000000000000000000000000000;;	// or interface value, and any array, slice, map, or string of length zero.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Anonymous fields are encoded inline except:
0000000000000000000000000000000000000000;;	//    - the struct tag specifies a replacement name (first value)
0000000000000000000000000000000000000000;;	//    - the field is of an interface type
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      // NOTE: 'json:' can be used as struct tag key, in place 'codec:' below.
0000000000000000000000000000000000000000;;	//      type MyStruct struct {
0000000000000000000000000000000000000000;;	//          _struct bool    `codec:",omitempty"`   //set omitempty for every field
0000000000000000000000000000000000000000;;	//          Field1 string   `codec:"-"`            //skip this field
0000000000000000000000000000000000000000;;	//          Field2 int      `codec:"myName"`       //Use key "myName" in encode stream
0000000000000000000000000000000000000000;;	//          Field3 int32    `codec:",omitempty"`   //use key "Field3". Omit if empty.
0000000000000000000000000000000000000000;;	//          Field4 bool     `codec:"f4,omitempty"` //use key "f4". Omit if empty.
0000000000000000000000000000000000000000;;	//          io.Reader                              //use key "Reader".
0000000000000000000000000000000000000000;;	//          MyStruct        `codec:"my1"           //use key "my1".
0000000000000000000000000000000000000000;;	//          MyStruct                               //inline it
0000000000000000000000000000000000000000;;	//          ...
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//      type MyStruct struct {
0000000000000000000000000000000000000000;;	//          _struct bool    `codec:",omitempty,toarray"`   //set omitempty for every field
0000000000000000000000000000000000000000;;	//                                                         //and encode struct as an array
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The mode of encoding is based on the type of the value. When a value is seen:
0000000000000000000000000000000000000000;;	//   - If a Selfer, call its CodecEncodeSelf method
0000000000000000000000000000000000000000;;	//   - If an extension is registered for it, call that extension function
0000000000000000000000000000000000000000;;	//   - If it implements encoding.(Binary|Text|JSON)Marshaler, call its Marshal(Binary|Text|JSON) method
0000000000000000000000000000000000000000;;	//   - Else encode it based on its reflect.Kind
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that struct field names and keys in map[string]XXX will be treated as symbols.
0000000000000000000000000000000000000000;;	// Some formats support symbols (e.g. binc) and will properly encode the string
0000000000000000000000000000000000000000;;	// only once in the stream, and use a tag to refer to it thereafter.
0000000000000000000000000000000000000000;;	func (e *Encoder) Encode(v interface{}) (err error) {
0000000000000000000000000000000000000000;;		defer panicToErr(&err)
0000000000000000000000000000000000000000;;		e.encode(v)
0000000000000000000000000000000000000000;;		e.w.atEndOfEncode()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustEncode is like Encode, but panics if unable to Encode.
0000000000000000000000000000000000000000;;	// This provides insight to the code location that triggered the error.
0000000000000000000000000000000000000000;;	func (e *Encoder) MustEncode(v interface{}) {
0000000000000000000000000000000000000000;;		e.encode(v)
0000000000000000000000000000000000000000;;		e.w.atEndOfEncode()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) encode(iv interface{}) {
0000000000000000000000000000000000000000;;		// if ics, ok := iv.(Selfer); ok {
0000000000000000000000000000000000000000;;		// 	ics.CodecEncodeSelf(e)
0000000000000000000000000000000000000000;;		// 	return
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v := iv.(type) {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			e.e.EncodeNil()
0000000000000000000000000000000000000000;;		case Selfer:
0000000000000000000000000000000000000000;;			v.CodecEncodeSelf(e)
0000000000000000000000000000000000000000;;		case Raw:
0000000000000000000000000000000000000000;;			e.raw(v)
0000000000000000000000000000000000000000;;		case reflect.Value:
0000000000000000000000000000000000000000;;			e.encodeValue(v, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			e.e.EncodeString(c_UTF8, v)
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			e.e.EncodeBool(v)
0000000000000000000000000000000000000000;;		case int:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(v))
0000000000000000000000000000000000000000;;		case int8:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(v))
0000000000000000000000000000000000000000;;		case int16:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(v))
0000000000000000000000000000000000000000;;		case int32:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(v))
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(v)
0000000000000000000000000000000000000000;;		case uint:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(v))
0000000000000000000000000000000000000000;;		case uint8:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(v))
0000000000000000000000000000000000000000;;		case uint16:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(v))
0000000000000000000000000000000000000000;;		case uint32:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(v))
0000000000000000000000000000000000000000;;		case uint64:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(v)
0000000000000000000000000000000000000000;;		case float32:
0000000000000000000000000000000000000000;;			e.e.EncodeFloat32(v)
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			e.e.EncodeFloat64(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case []uint8:
0000000000000000000000000000000000000000;;			e.e.EncodeStringBytes(c_RAW, v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *string:
0000000000000000000000000000000000000000;;			e.e.EncodeString(c_UTF8, *v)
0000000000000000000000000000000000000000;;		case *bool:
0000000000000000000000000000000000000000;;			e.e.EncodeBool(*v)
0000000000000000000000000000000000000000;;		case *int:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(*v))
0000000000000000000000000000000000000000;;		case *int8:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(*v))
0000000000000000000000000000000000000000;;		case *int16:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(*v))
0000000000000000000000000000000000000000;;		case *int32:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(int64(*v))
0000000000000000000000000000000000000000;;		case *int64:
0000000000000000000000000000000000000000;;			e.e.EncodeInt(*v)
0000000000000000000000000000000000000000;;		case *uint:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(*v))
0000000000000000000000000000000000000000;;		case *uint8:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(*v))
0000000000000000000000000000000000000000;;		case *uint16:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(*v))
0000000000000000000000000000000000000000;;		case *uint32:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(uint64(*v))
0000000000000000000000000000000000000000;;		case *uint64:
0000000000000000000000000000000000000000;;			e.e.EncodeUint(*v)
0000000000000000000000000000000000000000;;		case *float32:
0000000000000000000000000000000000000000;;			e.e.EncodeFloat32(*v)
0000000000000000000000000000000000000000;;		case *float64:
0000000000000000000000000000000000000000;;			e.e.EncodeFloat64(*v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *[]uint8:
0000000000000000000000000000000000000000;;			e.e.EncodeStringBytes(c_RAW, *v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			const checkCodecSelfer1 = true // in case T is passed, where *T is a Selfer, still checkCodecSelfer
0000000000000000000000000000000000000000;;			if !fastpathEncodeTypeSwitch(iv, e) {
0000000000000000000000000000000000000000;;				e.encodeI(iv, false, checkCodecSelfer1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) preEncodeValue(rv reflect.Value) (rv2 reflect.Value, sptr uintptr, proceed bool) {
0000000000000000000000000000000000000000;;		// use a goto statement instead of a recursive function for ptr/interface.
0000000000000000000000000000000000000000;;	TOP:
0000000000000000000000000000000000000000;;		switch rv.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if rv.IsNil() {
0000000000000000000000000000000000000000;;				e.e.EncodeNil()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rv = rv.Elem()
0000000000000000000000000000000000000000;;			if e.h.CheckCircularRef && rv.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;				// TODO: Movable pointers will be an issue here. Future problem.
0000000000000000000000000000000000000000;;				sptr = rv.UnsafeAddr()
0000000000000000000000000000000000000000;;				break TOP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			goto TOP
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if rv.IsNil() {
0000000000000000000000000000000000000000;;				e.e.EncodeNil()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rv = rv.Elem()
0000000000000000000000000000000000000000;;			goto TOP
0000000000000000000000000000000000000000;;		case reflect.Slice, reflect.Map:
0000000000000000000000000000000000000000;;			if rv.IsNil() {
0000000000000000000000000000000000000000;;				e.e.EncodeNil()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Invalid, reflect.Func:
0000000000000000000000000000000000000000;;			e.e.EncodeNil()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proceed = true
0000000000000000000000000000000000000000;;		rv2 = rv
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) doEncodeValue(rv reflect.Value, fn *encFn, sptr uintptr,
0000000000000000000000000000000000000000;;		checkFastpath, checkCodecSelfer bool) {
0000000000000000000000000000000000000000;;		if sptr != 0 {
0000000000000000000000000000000000000000;;			if (&e.ci).add(sptr) {
0000000000000000000000000000000000000000;;				e.errorf("circular reference found: # %d", sptr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if fn == nil {
0000000000000000000000000000000000000000;;			rt := rv.Type()
0000000000000000000000000000000000000000;;			rtid := reflect.ValueOf(rt).Pointer()
0000000000000000000000000000000000000000;;			// fn = e.getEncFn(rtid, rt, true, true)
0000000000000000000000000000000000000000;;			fn = e.getEncFn(rtid, rt, checkFastpath, checkCodecSelfer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fn.f(&fn.i, rv)
0000000000000000000000000000000000000000;;		if sptr != 0 {
0000000000000000000000000000000000000000;;			(&e.ci).remove(sptr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) encodeI(iv interface{}, checkFastpath, checkCodecSelfer bool) {
0000000000000000000000000000000000000000;;		if rv, sptr, proceed := e.preEncodeValue(reflect.ValueOf(iv)); proceed {
0000000000000000000000000000000000000000;;			e.doEncodeValue(rv, nil, sptr, checkFastpath, checkCodecSelfer)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) encodeValue(rv reflect.Value, fn *encFn) {
0000000000000000000000000000000000000000;;		// if a valid fn is passed, it MUST BE for the dereferenced type of rv
0000000000000000000000000000000000000000;;		if rv, sptr, proceed := e.preEncodeValue(rv); proceed {
0000000000000000000000000000000000000000;;			e.doEncodeValue(rv, fn, sptr, true, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) getEncFn(rtid uintptr, rt reflect.Type, checkFastpath, checkCodecSelfer bool) (fn *encFn) {
0000000000000000000000000000000000000000;;		// rtid := reflect.ValueOf(rt).Pointer()
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if useMapForCodecCache {
0000000000000000000000000000000000000000;;			fn, ok = e.f[rtid]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for i := range e.s {
0000000000000000000000000000000000000000;;				v := &(e.s[i])
0000000000000000000000000000000000000000;;				if v.rtid == rtid {
0000000000000000000000000000000000000000;;					fn, ok = &(v.fn), true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if useMapForCodecCache {
0000000000000000000000000000000000000000;;			if e.f == nil {
0000000000000000000000000000000000000000;;				e.f = make(map[uintptr]*encFn, initCollectionCap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fn = new(encFn)
0000000000000000000000000000000000000000;;			e.f[rtid] = fn
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if e.s == nil {
0000000000000000000000000000000000000000;;				e.s = make([]encRtidFn, 0, initCollectionCap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.s = append(e.s, encRtidFn{rtid: rtid})
0000000000000000000000000000000000000000;;			fn = &(e.s[len(e.s)-1]).fn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti := e.h.getTypeInfo(rtid, rt)
0000000000000000000000000000000000000000;;		fi := &(fn.i)
0000000000000000000000000000000000000000;;		fi.e = e
0000000000000000000000000000000000000000;;		fi.ti = ti
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if checkCodecSelfer && ti.cs {
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).selferMarshal
0000000000000000000000000000000000000000;;		} else if rtid == rawTypId {
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).raw
0000000000000000000000000000000000000000;;		} else if rtid == rawExtTypId {
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).rawExt
0000000000000000000000000000000000000000;;		} else if e.e.IsBuiltinType(rtid) {
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).builtin
0000000000000000000000000000000000000000;;		} else if xfFn := e.h.getExt(rtid); xfFn != nil {
0000000000000000000000000000000000000000;;			fi.xfTag, fi.xfFn = xfFn.tag, xfFn.ext
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).ext
0000000000000000000000000000000000000000;;		} else if supportMarshalInterfaces && e.be && ti.bm {
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).binaryMarshal
0000000000000000000000000000000000000000;;		} else if supportMarshalInterfaces && !e.be && e.js && ti.jm {
0000000000000000000000000000000000000000;;			//If JSON, we should check JSONMarshal before textMarshal
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).jsonMarshal
0000000000000000000000000000000000000000;;		} else if supportMarshalInterfaces && !e.be && ti.tm {
0000000000000000000000000000000000000000;;			fn.f = (*encFnInfo).textMarshal
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rk := rt.Kind()
0000000000000000000000000000000000000000;;			if fastpathEnabled && checkFastpath && (rk == reflect.Map || rk == reflect.Slice) {
0000000000000000000000000000000000000000;;				if rt.PkgPath() == "" { // un-named slice or map
0000000000000000000000000000000000000000;;					if idx := fastpathAV.index(rtid); idx != -1 {
0000000000000000000000000000000000000000;;						fn.f = fastpathAV[idx].encfn
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					ok = false
0000000000000000000000000000000000000000;;					// use mapping for underlying type if there
0000000000000000000000000000000000000000;;					var rtu reflect.Type
0000000000000000000000000000000000000000;;					if rk == reflect.Map {
0000000000000000000000000000000000000000;;						rtu = reflect.MapOf(rt.Key(), rt.Elem())
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						rtu = reflect.SliceOf(rt.Elem())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rtuid := reflect.ValueOf(rtu).Pointer()
0000000000000000000000000000000000000000;;					if idx := fastpathAV.index(rtuid); idx != -1 {
0000000000000000000000000000000000000000;;						xfnf := fastpathAV[idx].encfn
0000000000000000000000000000000000000000;;						xrt := fastpathAV[idx].rt
0000000000000000000000000000000000000000;;						fn.f = func(xf *encFnInfo, xrv reflect.Value) {
0000000000000000000000000000000000000000;;							xfnf(xf, xrv.Convert(xrt))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fn.f == nil {
0000000000000000000000000000000000000000;;				switch rk {
0000000000000000000000000000000000000000;;				case reflect.Bool:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kBool
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kString
0000000000000000000000000000000000000000;;				case reflect.Float64:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kFloat64
0000000000000000000000000000000000000000;;				case reflect.Float32:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kFloat32
0000000000000000000000000000000000000000;;				case reflect.Int, reflect.Int8, reflect.Int64, reflect.Int32, reflect.Int16:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kInt
0000000000000000000000000000000000000000;;				case reflect.Uint8, reflect.Uint64, reflect.Uint, reflect.Uint32, reflect.Uint16, reflect.Uintptr:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kUint
0000000000000000000000000000000000000000;;				case reflect.Invalid:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kInvalid
0000000000000000000000000000000000000000;;				case reflect.Chan:
0000000000000000000000000000000000000000;;					fi.seq = seqTypeChan
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kSlice
0000000000000000000000000000000000000000;;				case reflect.Slice:
0000000000000000000000000000000000000000;;					fi.seq = seqTypeSlice
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kSlice
0000000000000000000000000000000000000000;;				case reflect.Array:
0000000000000000000000000000000000000000;;					fi.seq = seqTypeArray
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kSlice
0000000000000000000000000000000000000000;;				case reflect.Struct:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kStruct
0000000000000000000000000000000000000000;;					// reflect.Ptr and reflect.Interface are handled already by preEncodeValue
0000000000000000000000000000000000000000;;					// case reflect.Ptr:
0000000000000000000000000000000000000000;;					// 	fn.f = (*encFnInfo).kPtr
0000000000000000000000000000000000000000;;					// case reflect.Interface:
0000000000000000000000000000000000000000;;					// 	fn.f = (*encFnInfo).kInterface
0000000000000000000000000000000000000000;;				case reflect.Map:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kMap
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					fn.f = (*encFnInfo).kErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) marshal(bs []byte, fnerr error, asis bool, c charEncoding) {
0000000000000000000000000000000000000000;;		if fnerr != nil {
0000000000000000000000000000000000000000;;			panic(fnerr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bs == nil {
0000000000000000000000000000000000000000;;			e.e.EncodeNil()
0000000000000000000000000000000000000000;;		} else if asis {
0000000000000000000000000000000000000000;;			e.asis(bs)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.e.EncodeStringBytes(c, bs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) asis(v []byte) {
0000000000000000000000000000000000000000;;		if e.as == nil {
0000000000000000000000000000000000000000;;			e.w.writeb(v)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.as.EncodeAsis(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) raw(vv Raw) {
0000000000000000000000000000000000000000;;		v := []byte(vv)
0000000000000000000000000000000000000000;;		if !e.h.Raw {
0000000000000000000000000000000000000000;;			e.errorf("Raw values cannot be encoded: %v", v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.as == nil {
0000000000000000000000000000000000000000;;			e.w.writeb(v)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.as.EncodeAsis(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Encoder) errorf(format string, params ...interface{}) {
0000000000000000000000000000000000000000;;		err := fmt.Errorf(format, params...)
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const encStructPoolLen = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encStructPool is an array of sync.Pool.
0000000000000000000000000000000000000000;;	// Each element of the array pools one of encStructPool(8|16|32|64).
0000000000000000000000000000000000000000;;	// It allows the re-use of slices up to 64 in length.
0000000000000000000000000000000000000000;;	// A performance cost of encoding structs was collecting
0000000000000000000000000000000000000000;;	// which values were empty and should be omitted.
0000000000000000000000000000000000000000;;	// We needed slices of reflect.Value and string to collect them.
0000000000000000000000000000000000000000;;	// This shared pool reduces the amount of unnecessary creation we do.
0000000000000000000000000000000000000000;;	// The cost is that of locking sometimes, but sync.Pool is efficient
0000000000000000000000000000000000000000;;	// enough to reduce thread contention.
0000000000000000000000000000000000000000;;	var encStructPool [encStructPoolLen]sync.Pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		encStructPool[0].New = func() interface{} { return new([8]stringRv) }
0000000000000000000000000000000000000000;;		encStructPool[1].New = func() interface{} { return new([16]stringRv) }
0000000000000000000000000000000000000000;;		encStructPool[2].New = func() interface{} { return new([32]stringRv) }
0000000000000000000000000000000000000000;;		encStructPool[3].New = func() interface{} { return new([64]stringRv) }
0000000000000000000000000000000000000000;;		encStructPool[4].New = func() interface{} { return new([128]stringRv) }
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encStructPoolGet(newlen int) (p *sync.Pool, v interface{}, s []stringRv) {
0000000000000000000000000000000000000000;;		// if encStructPoolLen != 5 { // constant chec, so removed at build time.
0000000000000000000000000000000000000000;;		// 	panic(errors.New("encStructPoolLen must be equal to 4")) // defensive, in case it is changed
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		// idxpool := newlen / 8
0000000000000000000000000000000000000000;;		if newlen <= 8 {
0000000000000000000000000000000000000000;;			p = &encStructPool[0]
0000000000000000000000000000000000000000;;			v = p.Get()
0000000000000000000000000000000000000000;;			s = v.(*[8]stringRv)[:newlen]
0000000000000000000000000000000000000000;;		} else if newlen <= 16 {
0000000000000000000000000000000000000000;;			p = &encStructPool[1]
0000000000000000000000000000000000000000;;			v = p.Get()
0000000000000000000000000000000000000000;;			s = v.(*[16]stringRv)[:newlen]
0000000000000000000000000000000000000000;;		} else if newlen <= 32 {
0000000000000000000000000000000000000000;;			p = &encStructPool[2]
0000000000000000000000000000000000000000;;			v = p.Get()
0000000000000000000000000000000000000000;;			s = v.(*[32]stringRv)[:newlen]
0000000000000000000000000000000000000000;;		} else if newlen <= 64 {
0000000000000000000000000000000000000000;;			p = &encStructPool[3]
0000000000000000000000000000000000000000;;			v = p.Get()
0000000000000000000000000000000000000000;;			s = v.(*[64]stringRv)[:newlen]
0000000000000000000000000000000000000000;;		} else if newlen <= 128 {
0000000000000000000000000000000000000000;;			p = &encStructPool[4]
0000000000000000000000000000000000000000;;			v = p.Get()
0000000000000000000000000000000000000000;;			s = v.(*[128]stringRv)[:newlen]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s = make([]stringRv, newlen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func encErr(format string, params ...interface{}) {
0000000000000000000000000000000000000000;;	// 	doPanic(msgTagEnc, format, params...)
0000000000000000000000000000000000000000;;	// }
