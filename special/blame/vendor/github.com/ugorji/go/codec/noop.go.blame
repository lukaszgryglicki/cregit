0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/noop.go[Godeps/_workspace/src/github.com/ugorji/go/codec/noop.go][vendor/github.com/ugorji/go/codec/noop.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NoopHandle returns a no-op handle. It basically does nothing.
0000000000000000000000000000000000000000;;	// It is only useful for benchmarking, as it gives an idea of the
0000000000000000000000000000000000000000;;	// overhead from the codec framework.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// LIBRARY USERS: *** DO NOT USE ***
0000000000000000000000000000000000000000;;	func NoopHandle(slen int) *noopHandle {
0000000000000000000000000000000000000000;;		h := noopHandle{}
0000000000000000000000000000000000000000;;		h.rand = rand.New(rand.NewSource(time.Now().UnixNano()))
0000000000000000000000000000000000000000;;		h.B = make([][]byte, slen)
0000000000000000000000000000000000000000;;		h.S = make([]string, slen)
0000000000000000000000000000000000000000;;		for i := 0; i < len(h.S); i++ {
0000000000000000000000000000000000000000;;			b := make([]byte, i+1)
0000000000000000000000000000000000000000;;			for j := 0; j < len(b); j++ {
0000000000000000000000000000000000000000;;				b[j] = 'a' + byte(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.B[i] = b
0000000000000000000000000000000000000000;;			h.S[i] = string(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// noopHandle does nothing.
0000000000000000000000000000000000000000;;	// It is used to simulate the overhead of the codec framework.
0000000000000000000000000000000000000000;;	type noopHandle struct {
0000000000000000000000000000000000000000;;		BasicHandle
0000000000000000000000000000000000000000;;		binaryEncodingType
0000000000000000000000000000000000000000;;		noopDrv // noopDrv is unexported here, so we can get a copy of it when needed.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noopDrv struct {
0000000000000000000000000000000000000000;;		d    *Decoder
0000000000000000000000000000000000000000;;		e    *Encoder
0000000000000000000000000000000000000000;;		i    int
0000000000000000000000000000000000000000;;		S    []string
0000000000000000000000000000000000000000;;		B    [][]byte
0000000000000000000000000000000000000000;;		mks  []bool    // stack. if map (true), else if array (false)
0000000000000000000000000000000000000000;;		mk   bool      // top of stack. what container are we on? map or array?
0000000000000000000000000000000000000000;;		ct   valueType // last response for IsContainerType.
0000000000000000000000000000000000000000;;		cb   int       // counter for ContainerType
0000000000000000000000000000000000000000;;		rand *rand.Rand
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) r(v int) int { return h.rand.Intn(v) }
0000000000000000000000000000000000000000;;	func (h *noopDrv) m(v int) int { h.i++; return h.i % v }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) newEncDriver(e *Encoder) encDriver { h.e = e; return h }
0000000000000000000000000000000000000000;;	func (h *noopDrv) newDecDriver(d *Decoder) decDriver { h.d = d; return h }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) reset()       {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) uncacheRead() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// --- encDriver
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stack functions (for map and array)
0000000000000000000000000000000000000000;;	func (h *noopDrv) start(b bool) {
0000000000000000000000000000000000000000;;		// println("start", len(h.mks)+1)
0000000000000000000000000000000000000000;;		h.mks = append(h.mks, b)
0000000000000000000000000000000000000000;;		h.mk = b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (h *noopDrv) end() {
0000000000000000000000000000000000000000;;		// println("end: ", len(h.mks)-1)
0000000000000000000000000000000000000000;;		h.mks = h.mks[:len(h.mks)-1]
0000000000000000000000000000000000000000;;		if len(h.mks) > 0 {
0000000000000000000000000000000000000000;;			h.mk = h.mks[len(h.mks)-1]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			h.mk = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeBuiltin(rt uintptr, v interface{}) {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeNil()                              {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeInt(i int64)                       {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeUint(i uint64)                     {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeBool(b bool)                       {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeFloat32(f float32)                 {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeFloat64(f float64)                 {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeRawExt(re *RawExt, e *Encoder)     {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeArrayStart(length int)             { h.start(true) }
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeMapStart(length int)               { h.start(false) }
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeEnd()                              { h.end() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeString(c charEncoding, v string)      {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeSymbol(v string)                      {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeStringBytes(c charEncoding, v []byte) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) EncodeExt(rv interface{}, xtag uint64, ext Ext, e *Encoder) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ---- decDriver
0000000000000000000000000000000000000000;;	func (h *noopDrv) initReadNext()                              {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) CheckBreak() bool                           { return false }
0000000000000000000000000000000000000000;;	func (h *noopDrv) IsBuiltinType(rt uintptr) bool              { return false }
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeBuiltin(rt uintptr, v interface{})    {}
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeInt(bitsize uint8) (i int64)          { return int64(h.m(15)) }
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeUint(bitsize uint8) (ui uint64)       { return uint64(h.m(35)) }
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeFloat(chkOverflow32 bool) (f float64) { return float64(h.m(95)) }
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeBool() (b bool)                       { return h.m(2) == 0 }
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeString() (s string)                   { return h.S[h.m(8)] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (h *noopDrv) DecodeStringAsBytes(bs []byte) []byte       { return h.DecodeBytes(bs) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeBytes(bs []byte, isstring, zerocopy bool) []byte { return h.B[h.m(len(h.B))] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) ReadEnd() { h.end() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toggle map/slice
0000000000000000000000000000000000000000;;	func (h *noopDrv) ReadMapStart() int   { h.start(true); return h.m(10) }
0000000000000000000000000000000000000000;;	func (h *noopDrv) ReadArrayStart() int { h.start(false); return h.m(10) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) ContainerType() (vt valueType) {
0000000000000000000000000000000000000000;;		// return h.m(2) == 0
0000000000000000000000000000000000000000;;		// handle kStruct, which will bomb is it calls this and doesn't get back a map or array.
0000000000000000000000000000000000000000;;		// consequently, if the return value is not map or array, reset it to one of them based on h.m(7) % 2
0000000000000000000000000000000000000000;;		// for kstruct: at least one out of every 2 times, return one of valueTypeMap or Array (else kstruct bombs)
0000000000000000000000000000000000000000;;		// however, every 10th time it is called, we just return something else.
0000000000000000000000000000000000000000;;		var vals = [...]valueType{valueTypeArray, valueTypeMap}
0000000000000000000000000000000000000000;;		//  ------------ TAKE ------------
0000000000000000000000000000000000000000;;		// if h.cb%2 == 0 {
0000000000000000000000000000000000000000;;		// 	if h.ct == valueTypeMap || h.ct == valueTypeArray {
0000000000000000000000000000000000000000;;		// 	} else {
0000000000000000000000000000000000000000;;		// 		h.ct = vals[h.m(2)]
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		// } else if h.cb%5 == 0 {
0000000000000000000000000000000000000000;;		// 	h.ct = valueType(h.m(8))
0000000000000000000000000000000000000000;;		// } else {
0000000000000000000000000000000000000000;;		// 	h.ct = vals[h.m(2)]
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		//  ------------ TAKE ------------
0000000000000000000000000000000000000000;;		// if h.cb%16 == 0 {
0000000000000000000000000000000000000000;;		// 	h.ct = valueType(h.cb % 8)
0000000000000000000000000000000000000000;;		// } else {
0000000000000000000000000000000000000000;;		// 	h.ct = vals[h.cb%2]
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		h.ct = vals[h.cb%2]
0000000000000000000000000000000000000000;;		h.cb++
0000000000000000000000000000000000000000;;		return h.ct
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if h.ct == valueTypeNil || h.ct == valueTypeString || h.ct == valueTypeBytes {
0000000000000000000000000000000000000000;;		// 	return h.ct
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		// return valueTypeUnset
0000000000000000000000000000000000000000;;		// TODO: may need to tweak this so it works.
0000000000000000000000000000000000000000;;		// if h.ct == valueTypeMap && vt == valueTypeArray || h.ct == valueTypeArray && vt == valueTypeMap {
0000000000000000000000000000000000000000;;		// 	h.cb = !h.cb
0000000000000000000000000000000000000000;;		// 	h.ct = vt
0000000000000000000000000000000000000000;;		// 	return h.cb
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		// // go in a loop and check it.
0000000000000000000000000000000000000000;;		// h.ct = vt
0000000000000000000000000000000000000000;;		// h.cb = h.m(7) == 0
0000000000000000000000000000000000000000;;		// return h.cb
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (h *noopDrv) TryDecodeAsNil() bool {
0000000000000000000000000000000000000000;;		if h.mk {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return h.m(8) == 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeExt(rv interface{}, xtag uint64, ext Ext) uint64 {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *noopDrv) DecodeNaked() {
0000000000000000000000000000000000000000;;		// use h.r (random) not h.m() because h.m() could cause the same value to be given.
0000000000000000000000000000000000000000;;		var sk int
0000000000000000000000000000000000000000;;		if h.mk {
0000000000000000000000000000000000000000;;			// if mapkey, do not support values of nil OR bytes, array, map or rawext
0000000000000000000000000000000000000000;;			sk = h.r(7) + 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sk = h.r(12)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := &h.d.n
0000000000000000000000000000000000000000;;		switch sk {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			n.v = valueTypeNil
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			n.v, n.b = valueTypeBool, false
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			n.v, n.b = valueTypeBool, true
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			n.v, n.i = valueTypeInt, h.DecodeInt(64)
0000000000000000000000000000000000000000;;		case 4:
0000000000000000000000000000000000000000;;			n.v, n.u = valueTypeUint, h.DecodeUint(64)
0000000000000000000000000000000000000000;;		case 5:
0000000000000000000000000000000000000000;;			n.v, n.f = valueTypeFloat, h.DecodeFloat(true)
0000000000000000000000000000000000000000;;		case 6:
0000000000000000000000000000000000000000;;			n.v, n.f = valueTypeFloat, h.DecodeFloat(false)
0000000000000000000000000000000000000000;;		case 7:
0000000000000000000000000000000000000000;;			n.v, n.s = valueTypeString, h.DecodeString()
0000000000000000000000000000000000000000;;		case 8:
0000000000000000000000000000000000000000;;			n.v, n.l = valueTypeBytes, h.B[h.m(len(h.B))]
0000000000000000000000000000000000000000;;		case 9:
0000000000000000000000000000000000000000;;			n.v = valueTypeArray
0000000000000000000000000000000000000000;;		case 10:
0000000000000000000000000000000000000000;;			n.v = valueTypeMap
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			n.v = valueTypeExt
0000000000000000000000000000000000000000;;			n.u = h.DecodeUint(64)
0000000000000000000000000000000000000000;;			n.l = h.B[h.m(len(h.B))]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.ct = n.v
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
