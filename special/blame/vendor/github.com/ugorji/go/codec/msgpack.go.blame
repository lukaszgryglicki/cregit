0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/msgpack.go[Godeps/_workspace/src/github.com/ugorji/go/codec/msgpack.go][vendor/github.com/ugorji/go/codec/msgpack.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	MSGPACK
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Msgpack-c implementation powers the c, c++, python, ruby, etc libraries.
0000000000000000000000000000000000000000;;	We need to maintain compatibility with it and how it encodes integer values
0000000000000000000000000000000000000000;;	without caring about the type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For compatibility with behaviour of msgpack-c reference implementation:
0000000000000000000000000000000000000000;;	  - Go intX (>0) and uintX
0000000000000000000000000000000000000000;;	       IS ENCODED AS
0000000000000000000000000000000000000000;;	    msgpack +ve fixnum, unsigned
0000000000000000000000000000000000000000;;	  - Go intX (<0)
0000000000000000000000000000000000000000;;	       IS ENCODED AS
0000000000000000000000000000000000000000;;	    msgpack -ve fixnum, signed
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"net/rpc"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		mpPosFixNumMin byte = 0x00
0000000000000000000000000000000000000000;;		mpPosFixNumMax      = 0x7f
0000000000000000000000000000000000000000;;		mpFixMapMin         = 0x80
0000000000000000000000000000000000000000;;		mpFixMapMax         = 0x8f
0000000000000000000000000000000000000000;;		mpFixArrayMin       = 0x90
0000000000000000000000000000000000000000;;		mpFixArrayMax       = 0x9f
0000000000000000000000000000000000000000;;		mpFixStrMin         = 0xa0
0000000000000000000000000000000000000000;;		mpFixStrMax         = 0xbf
0000000000000000000000000000000000000000;;		mpNil               = 0xc0
0000000000000000000000000000000000000000;;		_                   = 0xc1
0000000000000000000000000000000000000000;;		mpFalse             = 0xc2
0000000000000000000000000000000000000000;;		mpTrue              = 0xc3
0000000000000000000000000000000000000000;;		mpFloat             = 0xca
0000000000000000000000000000000000000000;;		mpDouble            = 0xcb
0000000000000000000000000000000000000000;;		mpUint8             = 0xcc
0000000000000000000000000000000000000000;;		mpUint16            = 0xcd
0000000000000000000000000000000000000000;;		mpUint32            = 0xce
0000000000000000000000000000000000000000;;		mpUint64            = 0xcf
0000000000000000000000000000000000000000;;		mpInt8              = 0xd0
0000000000000000000000000000000000000000;;		mpInt16             = 0xd1
0000000000000000000000000000000000000000;;		mpInt32             = 0xd2
0000000000000000000000000000000000000000;;		mpInt64             = 0xd3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// extensions below
0000000000000000000000000000000000000000;;		mpBin8     = 0xc4
0000000000000000000000000000000000000000;;		mpBin16    = 0xc5
0000000000000000000000000000000000000000;;		mpBin32    = 0xc6
0000000000000000000000000000000000000000;;		mpExt8     = 0xc7
0000000000000000000000000000000000000000;;		mpExt16    = 0xc8
0000000000000000000000000000000000000000;;		mpExt32    = 0xc9
0000000000000000000000000000000000000000;;		mpFixExt1  = 0xd4
0000000000000000000000000000000000000000;;		mpFixExt2  = 0xd5
0000000000000000000000000000000000000000;;		mpFixExt4  = 0xd6
0000000000000000000000000000000000000000;;		mpFixExt8  = 0xd7
0000000000000000000000000000000000000000;;		mpFixExt16 = 0xd8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mpStr8  = 0xd9 // new
0000000000000000000000000000000000000000;;		mpStr16 = 0xda
0000000000000000000000000000000000000000;;		mpStr32 = 0xdb
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mpArray16 = 0xdc
0000000000000000000000000000000000000000;;		mpArray32 = 0xdd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mpMap16 = 0xde
0000000000000000000000000000000000000000;;		mpMap32 = 0xdf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mpNegFixNumMin = 0xe0
0000000000000000000000000000000000000000;;		mpNegFixNumMax = 0xff
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MsgpackSpecRpcMultiArgs is a special type which signifies to the MsgpackSpecRpcCodec
0000000000000000000000000000000000000000;;	// that the backend RPC service takes multiple arguments, which have been arranged
0000000000000000000000000000000000000000;;	// in sequence in the slice.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Codec then passes it AS-IS to the rpc service (without wrapping it in an
0000000000000000000000000000000000000000;;	// array of 1 element).
0000000000000000000000000000000000000000;;	type MsgpackSpecRpcMultiArgs []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A MsgpackContainer type specifies the different types of msgpackContainers.
0000000000000000000000000000000000000000;;	type msgpackContainerType struct {
0000000000000000000000000000000000000000;;		fixCutoff                   int
0000000000000000000000000000000000000000;;		bFixMin, b8, b16, b32       byte
0000000000000000000000000000000000000000;;		hasFixMin, has8, has8Always bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		msgpackContainerStr  = msgpackContainerType{32, mpFixStrMin, mpStr8, mpStr16, mpStr32, true, true, false}
0000000000000000000000000000000000000000;;		msgpackContainerBin  = msgpackContainerType{0, 0, mpBin8, mpBin16, mpBin32, false, true, true}
0000000000000000000000000000000000000000;;		msgpackContainerList = msgpackContainerType{16, mpFixArrayMin, 0, mpArray16, mpArray32, true, false, false}
0000000000000000000000000000000000000000;;		msgpackContainerMap  = msgpackContainerType{16, mpFixMapMin, 0, mpMap16, mpMap32, true, false, false}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//---------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type msgpackEncDriver struct {
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;		encNoSeparator
0000000000000000000000000000000000000000;;		e *Encoder
0000000000000000000000000000000000000000;;		w encWriter
0000000000000000000000000000000000000000;;		h *MsgpackHandle
0000000000000000000000000000000000000000;;		x [8]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeNil() {
0000000000000000000000000000000000000000;;		e.w.writen1(mpNil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeInt(i int64) {
0000000000000000000000000000000000000000;;		if i >= 0 {
0000000000000000000000000000000000000000;;			e.EncodeUint(uint64(i))
0000000000000000000000000000000000000000;;		} else if i >= -32 {
0000000000000000000000000000000000000000;;			e.w.writen1(byte(i))
0000000000000000000000000000000000000000;;		} else if i >= math.MinInt8 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpInt8, byte(i))
0000000000000000000000000000000000000000;;		} else if i >= math.MinInt16 {
0000000000000000000000000000000000000000;;			e.w.writen1(mpInt16)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:2], e.w}.writeUint16(uint16(i))
0000000000000000000000000000000000000000;;		} else if i >= math.MinInt32 {
0000000000000000000000000000000000000000;;			e.w.writen1(mpInt32)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:4], e.w}.writeUint32(uint32(i))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(mpInt64)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:8], e.w}.writeUint64(uint64(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeUint(i uint64) {
0000000000000000000000000000000000000000;;		if i <= math.MaxInt8 {
0000000000000000000000000000000000000000;;			e.w.writen1(byte(i))
0000000000000000000000000000000000000000;;		} else if i <= math.MaxUint8 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpUint8, byte(i))
0000000000000000000000000000000000000000;;		} else if i <= math.MaxUint16 {
0000000000000000000000000000000000000000;;			e.w.writen1(mpUint16)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:2], e.w}.writeUint16(uint16(i))
0000000000000000000000000000000000000000;;		} else if i <= math.MaxUint32 {
0000000000000000000000000000000000000000;;			e.w.writen1(mpUint32)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:4], e.w}.writeUint32(uint32(i))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(mpUint64)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:8], e.w}.writeUint64(uint64(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeBool(b bool) {
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			e.w.writen1(mpTrue)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(mpFalse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeFloat32(f float32) {
0000000000000000000000000000000000000000;;		e.w.writen1(mpFloat)
0000000000000000000000000000000000000000;;		bigenHelper{e.x[:4], e.w}.writeUint32(math.Float32bits(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeFloat64(f float64) {
0000000000000000000000000000000000000000;;		e.w.writen1(mpDouble)
0000000000000000000000000000000000000000;;		bigenHelper{e.x[:8], e.w}.writeUint64(math.Float64bits(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeExt(v interface{}, xtag uint64, ext Ext, _ *Encoder) {
0000000000000000000000000000000000000000;;		bs := ext.WriteExt(v)
0000000000000000000000000000000000000000;;		if bs == nil {
0000000000000000000000000000000000000000;;			e.EncodeNil()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.h.WriteExt {
0000000000000000000000000000000000000000;;			e.encodeExtPreamble(uint8(xtag), len(bs))
0000000000000000000000000000000000000000;;			e.w.writeb(bs)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.EncodeStringBytes(c_RAW, bs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeRawExt(re *RawExt, _ *Encoder) {
0000000000000000000000000000000000000000;;		e.encodeExtPreamble(uint8(re.Tag), len(re.Data))
0000000000000000000000000000000000000000;;		e.w.writeb(re.Data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) encodeExtPreamble(xtag byte, l int) {
0000000000000000000000000000000000000000;;		if l == 1 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpFixExt1, xtag)
0000000000000000000000000000000000000000;;		} else if l == 2 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpFixExt2, xtag)
0000000000000000000000000000000000000000;;		} else if l == 4 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpFixExt4, xtag)
0000000000000000000000000000000000000000;;		} else if l == 8 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpFixExt8, xtag)
0000000000000000000000000000000000000000;;		} else if l == 16 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpFixExt16, xtag)
0000000000000000000000000000000000000000;;		} else if l < 256 {
0000000000000000000000000000000000000000;;			e.w.writen2(mpExt8, byte(l))
0000000000000000000000000000000000000000;;			e.w.writen1(xtag)
0000000000000000000000000000000000000000;;		} else if l < 65536 {
0000000000000000000000000000000000000000;;			e.w.writen1(mpExt16)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:2], e.w}.writeUint16(uint16(l))
0000000000000000000000000000000000000000;;			e.w.writen1(xtag)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(mpExt32)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:4], e.w}.writeUint32(uint32(l))
0000000000000000000000000000000000000000;;			e.w.writen1(xtag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeArrayStart(length int) {
0000000000000000000000000000000000000000;;		e.writeContainerLen(msgpackContainerList, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeMapStart(length int) {
0000000000000000000000000000000000000000;;		e.writeContainerLen(msgpackContainerMap, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeString(c charEncoding, s string) {
0000000000000000000000000000000000000000;;		if c == c_RAW && e.h.WriteExt {
0000000000000000000000000000000000000000;;			e.writeContainerLen(msgpackContainerBin, len(s))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.writeContainerLen(msgpackContainerStr, len(s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) > 0 {
0000000000000000000000000000000000000000;;			e.w.writestr(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeSymbol(v string) {
0000000000000000000000000000000000000000;;		e.EncodeString(c_UTF8, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) EncodeStringBytes(c charEncoding, bs []byte) {
0000000000000000000000000000000000000000;;		if c == c_RAW && e.h.WriteExt {
0000000000000000000000000000000000000000;;			e.writeContainerLen(msgpackContainerBin, len(bs))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.writeContainerLen(msgpackContainerStr, len(bs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(bs) > 0 {
0000000000000000000000000000000000000000;;			e.w.writeb(bs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) writeContainerLen(ct msgpackContainerType, l int) {
0000000000000000000000000000000000000000;;		if ct.hasFixMin && l < ct.fixCutoff {
0000000000000000000000000000000000000000;;			e.w.writen1(ct.bFixMin | byte(l))
0000000000000000000000000000000000000000;;		} else if ct.has8 && l < 256 && (ct.has8Always || e.h.WriteExt) {
0000000000000000000000000000000000000000;;			e.w.writen2(ct.b8, uint8(l))
0000000000000000000000000000000000000000;;		} else if l < 65536 {
0000000000000000000000000000000000000000;;			e.w.writen1(ct.b16)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:2], e.w}.writeUint16(uint16(l))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(ct.b32)
0000000000000000000000000000000000000000;;			bigenHelper{e.x[:4], e.w}.writeUint32(uint32(l))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//---------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type msgpackDecDriver struct {
0000000000000000000000000000000000000000;;		d      *Decoder
0000000000000000000000000000000000000000;;		r      decReader // *Decoder decReader decReaderT
0000000000000000000000000000000000000000;;		h      *MsgpackHandle
0000000000000000000000000000000000000000;;		b      [scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;		bd     byte
0000000000000000000000000000000000000000;;		bdRead bool
0000000000000000000000000000000000000000;;		br     bool // bytes reader
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;		noStreamingCodec
0000000000000000000000000000000000000000;;		decNoSeparator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Note: This returns either a primitive (int, bool, etc) for non-containers,
0000000000000000000000000000000000000000;;	// or a containerType, or a specific type denoting nil or extension.
0000000000000000000000000000000000000000;;	// It is called when a nil interface{} is passed, leaving it up to the DecDriver
0000000000000000000000000000000000000000;;	// to introspect the stream and decide how best to decode.
0000000000000000000000000000000000000000;;	// It deciphers the value by looking at the stream first.
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeNaked() {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bd := d.bd
0000000000000000000000000000000000000000;;		n := &d.d.n
0000000000000000000000000000000000000000;;		var decodeFurther bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch bd {
0000000000000000000000000000000000000000;;		case mpNil:
0000000000000000000000000000000000000000;;			n.v = valueTypeNil
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		case mpFalse:
0000000000000000000000000000000000000000;;			n.v = valueTypeBool
0000000000000000000000000000000000000000;;			n.b = false
0000000000000000000000000000000000000000;;		case mpTrue:
0000000000000000000000000000000000000000;;			n.v = valueTypeBool
0000000000000000000000000000000000000000;;			n.b = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case mpFloat:
0000000000000000000000000000000000000000;;			n.v = valueTypeFloat
0000000000000000000000000000000000000000;;			n.f = float64(math.Float32frombits(bigen.Uint32(d.r.readx(4))))
0000000000000000000000000000000000000000;;		case mpDouble:
0000000000000000000000000000000000000000;;			n.v = valueTypeFloat
0000000000000000000000000000000000000000;;			n.f = math.Float64frombits(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case mpUint8:
0000000000000000000000000000000000000000;;			n.v = valueTypeUint
0000000000000000000000000000000000000000;;			n.u = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;		case mpUint16:
0000000000000000000000000000000000000000;;			n.v = valueTypeUint
0000000000000000000000000000000000000000;;			n.u = uint64(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;		case mpUint32:
0000000000000000000000000000000000000000;;			n.v = valueTypeUint
0000000000000000000000000000000000000000;;			n.u = uint64(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;		case mpUint64:
0000000000000000000000000000000000000000;;			n.v = valueTypeUint
0000000000000000000000000000000000000000;;			n.u = uint64(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case mpInt8:
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = int64(int8(d.r.readn1()))
0000000000000000000000000000000000000000;;		case mpInt16:
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = int64(int16(bigen.Uint16(d.r.readx(2))))
0000000000000000000000000000000000000000;;		case mpInt32:
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = int64(int32(bigen.Uint32(d.r.readx(4))))
0000000000000000000000000000000000000000;;		case mpInt64:
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = int64(int64(bigen.Uint64(d.r.readx(8))))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case bd >= mpPosFixNumMin && bd <= mpPosFixNumMax:
0000000000000000000000000000000000000000;;				// positive fixnum (always signed)
0000000000000000000000000000000000000000;;				n.v = valueTypeInt
0000000000000000000000000000000000000000;;				n.i = int64(int8(bd))
0000000000000000000000000000000000000000;;			case bd >= mpNegFixNumMin && bd <= mpNegFixNumMax:
0000000000000000000000000000000000000000;;				// negative fixnum
0000000000000000000000000000000000000000;;				n.v = valueTypeInt
0000000000000000000000000000000000000000;;				n.i = int64(int8(bd))
0000000000000000000000000000000000000000;;			case bd == mpStr8, bd == mpStr16, bd == mpStr32, bd >= mpFixStrMin && bd <= mpFixStrMax:
0000000000000000000000000000000000000000;;				if d.h.RawToString {
0000000000000000000000000000000000000000;;					n.v = valueTypeString
0000000000000000000000000000000000000000;;					n.s = d.DecodeString()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					n.v = valueTypeBytes
0000000000000000000000000000000000000000;;					n.l = d.DecodeBytes(nil, false, false)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case bd == mpBin8, bd == mpBin16, bd == mpBin32:
0000000000000000000000000000000000000000;;				n.v = valueTypeBytes
0000000000000000000000000000000000000000;;				n.l = d.DecodeBytes(nil, false, false)
0000000000000000000000000000000000000000;;			case bd == mpArray16, bd == mpArray32, bd >= mpFixArrayMin && bd <= mpFixArrayMax:
0000000000000000000000000000000000000000;;				n.v = valueTypeArray
0000000000000000000000000000000000000000;;				decodeFurther = true
0000000000000000000000000000000000000000;;			case bd == mpMap16, bd == mpMap32, bd >= mpFixMapMin && bd <= mpFixMapMax:
0000000000000000000000000000000000000000;;				n.v = valueTypeMap
0000000000000000000000000000000000000000;;				decodeFurther = true
0000000000000000000000000000000000000000;;			case bd >= mpFixExt1 && bd <= mpFixExt16, bd >= mpExt8 && bd <= mpExt32:
0000000000000000000000000000000000000000;;				n.v = valueTypeExt
0000000000000000000000000000000000000000;;				clen := d.readExtLen()
0000000000000000000000000000000000000000;;				n.u = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;				n.l = d.r.readx(clen)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				d.d.errorf("Nil-Deciphered DecodeValue: %s: hex: %x, dec: %d", msgBadDesc, bd, bd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !decodeFurther {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.v == valueTypeUint && d.h.SignedInteger {
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = int64(n.u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// int can be decoded from msgpack type: intXXX or uintXXX
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeInt(bitsize uint8) (i int64) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch d.bd {
0000000000000000000000000000000000000000;;		case mpUint8:
0000000000000000000000000000000000000000;;			i = int64(uint64(d.r.readn1()))
0000000000000000000000000000000000000000;;		case mpUint16:
0000000000000000000000000000000000000000;;			i = int64(uint64(bigen.Uint16(d.r.readx(2))))
0000000000000000000000000000000000000000;;		case mpUint32:
0000000000000000000000000000000000000000;;			i = int64(uint64(bigen.Uint32(d.r.readx(4))))
0000000000000000000000000000000000000000;;		case mpUint64:
0000000000000000000000000000000000000000;;			i = int64(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;		case mpInt8:
0000000000000000000000000000000000000000;;			i = int64(int8(d.r.readn1()))
0000000000000000000000000000000000000000;;		case mpInt16:
0000000000000000000000000000000000000000;;			i = int64(int16(bigen.Uint16(d.r.readx(2))))
0000000000000000000000000000000000000000;;		case mpInt32:
0000000000000000000000000000000000000000;;			i = int64(int32(bigen.Uint32(d.r.readx(4))))
0000000000000000000000000000000000000000;;		case mpInt64:
0000000000000000000000000000000000000000;;			i = int64(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case d.bd >= mpPosFixNumMin && d.bd <= mpPosFixNumMax:
0000000000000000000000000000000000000000;;				i = int64(int8(d.bd))
0000000000000000000000000000000000000000;;			case d.bd >= mpNegFixNumMin && d.bd <= mpNegFixNumMax:
0000000000000000000000000000000000000000;;				i = int64(int8(d.bd))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				d.d.errorf("Unhandled single-byte unsigned integer value: %s: %x", msgBadDesc, d.bd)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check overflow (logic adapted from std pkg reflect/value.go OverflowUint()
0000000000000000000000000000000000000000;;		if bitsize > 0 {
0000000000000000000000000000000000000000;;			if trunc := (i << (64 - bitsize)) >> (64 - bitsize); i != trunc {
0000000000000000000000000000000000000000;;				d.d.errorf("Overflow int value: %v", i)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// uint can be decoded from msgpack type: intXXX or uintXXX
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeUint(bitsize uint8) (ui uint64) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch d.bd {
0000000000000000000000000000000000000000;;		case mpUint8:
0000000000000000000000000000000000000000;;			ui = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;		case mpUint16:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;		case mpUint32:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;		case mpUint64:
0000000000000000000000000000000000000000;;			ui = bigen.Uint64(d.r.readx(8))
0000000000000000000000000000000000000000;;		case mpInt8:
0000000000000000000000000000000000000000;;			if i := int64(int8(d.r.readn1())); i >= 0 {
0000000000000000000000000000000000000000;;				ui = uint64(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("Assigning negative signed value: %v, to unsigned type", i)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case mpInt16:
0000000000000000000000000000000000000000;;			if i := int64(int16(bigen.Uint16(d.r.readx(2)))); i >= 0 {
0000000000000000000000000000000000000000;;				ui = uint64(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("Assigning negative signed value: %v, to unsigned type", i)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case mpInt32:
0000000000000000000000000000000000000000;;			if i := int64(int32(bigen.Uint32(d.r.readx(4)))); i >= 0 {
0000000000000000000000000000000000000000;;				ui = uint64(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("Assigning negative signed value: %v, to unsigned type", i)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case mpInt64:
0000000000000000000000000000000000000000;;			if i := int64(bigen.Uint64(d.r.readx(8))); i >= 0 {
0000000000000000000000000000000000000000;;				ui = uint64(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("Assigning negative signed value: %v, to unsigned type", i)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case d.bd >= mpPosFixNumMin && d.bd <= mpPosFixNumMax:
0000000000000000000000000000000000000000;;				ui = uint64(d.bd)
0000000000000000000000000000000000000000;;			case d.bd >= mpNegFixNumMin && d.bd <= mpNegFixNumMax:
0000000000000000000000000000000000000000;;				d.d.errorf("Assigning negative signed value: %v, to unsigned type", int(d.bd))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				d.d.errorf("Unhandled single-byte unsigned integer value: %s: %x", msgBadDesc, d.bd)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check overflow (logic adapted from std pkg reflect/value.go OverflowUint()
0000000000000000000000000000000000000000;;		if bitsize > 0 {
0000000000000000000000000000000000000000;;			if trunc := (ui << (64 - bitsize)) >> (64 - bitsize); ui != trunc {
0000000000000000000000000000000000000000;;				d.d.errorf("Overflow uint value: %v", ui)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// float can either be decoded from msgpack type: float, double or intX
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeFloat(chkOverflow32 bool) (f float64) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == mpFloat {
0000000000000000000000000000000000000000;;			f = float64(math.Float32frombits(bigen.Uint32(d.r.readx(4))))
0000000000000000000000000000000000000000;;		} else if d.bd == mpDouble {
0000000000000000000000000000000000000000;;			f = math.Float64frombits(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f = float64(d.DecodeInt(0))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOverflow32 && chkOvf.Float32(f) {
0000000000000000000000000000000000000000;;			d.d.errorf("msgpack: float32 overflow: %v", f)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bool can be decoded from bool, fixnum 0 or 1.
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeBool() (b bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == mpFalse || d.bd == 0 {
0000000000000000000000000000000000000000;;			// b = false
0000000000000000000000000000000000000000;;		} else if d.bd == mpTrue || d.bd == 1 {
0000000000000000000000000000000000000000;;			b = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid single-byte value for bool: %s: %x", msgBadDesc, d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeBytes(bs []byte, isstring, zerocopy bool) (bsOut []byte) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var clen int
0000000000000000000000000000000000000000;;		// ignore isstring. Expect that the bytes may be found from msgpackContainerStr or msgpackContainerBin
0000000000000000000000000000000000000000;;		if bd := d.bd; bd == mpBin8 || bd == mpBin16 || bd == mpBin32 {
0000000000000000000000000000000000000000;;			clen = d.readContainerLen(msgpackContainerBin)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			clen = d.readContainerLen(msgpackContainerStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// println("DecodeBytes: clen: ", clen)
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		// bytes may be nil, so handle it. if nil, clen=-1.
0000000000000000000000000000000000000000;;		if clen < 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if zerocopy {
0000000000000000000000000000000000000000;;			if d.br {
0000000000000000000000000000000000000000;;				return d.r.readx(clen)
0000000000000000000000000000000000000000;;			} else if len(bs) == 0 {
0000000000000000000000000000000000000000;;				bs = d.b[:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decByteSlice(d.r, clen, bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeString() (s string) {
0000000000000000000000000000000000000000;;		return string(d.DecodeBytes(d.b[:], true, true))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) readNextBd() {
0000000000000000000000000000000000000000;;		d.bd = d.r.readn1()
0000000000000000000000000000000000000000;;		d.bdRead = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) uncacheRead() {
0000000000000000000000000000000000000000;;		if d.bdRead {
0000000000000000000000000000000000000000;;			d.r.unreadn1()
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) ContainerType() (vt valueType) {
0000000000000000000000000000000000000000;;		bd := d.bd
0000000000000000000000000000000000000000;;		if bd == mpNil {
0000000000000000000000000000000000000000;;			return valueTypeNil
0000000000000000000000000000000000000000;;		} else if bd == mpBin8 || bd == mpBin16 || bd == mpBin32 ||
0000000000000000000000000000000000000000;;			(!d.h.RawToString &&
0000000000000000000000000000000000000000;;				(bd == mpStr8 || bd == mpStr16 || bd == mpStr32 || (bd >= mpFixStrMin && bd <= mpFixStrMax))) {
0000000000000000000000000000000000000000;;			return valueTypeBytes
0000000000000000000000000000000000000000;;		} else if d.h.RawToString &&
0000000000000000000000000000000000000000;;			(bd == mpStr8 || bd == mpStr16 || bd == mpStr32 || (bd >= mpFixStrMin && bd <= mpFixStrMax)) {
0000000000000000000000000000000000000000;;			return valueTypeString
0000000000000000000000000000000000000000;;		} else if bd == mpArray16 || bd == mpArray32 || (bd >= mpFixArrayMin && bd <= mpFixArrayMax) {
0000000000000000000000000000000000000000;;			return valueTypeArray
0000000000000000000000000000000000000000;;		} else if bd == mpMap16 || bd == mpMap32 || (bd >= mpFixMapMin && bd <= mpFixMapMax) {
0000000000000000000000000000000000000000;;			return valueTypeMap
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// d.d.errorf("isContainerType: unsupported parameter: %v", vt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return valueTypeUnset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) TryDecodeAsNil() (v bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == mpNil {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			v = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) readContainerLen(ct msgpackContainerType) (clen int) {
0000000000000000000000000000000000000000;;		bd := d.bd
0000000000000000000000000000000000000000;;		if bd == mpNil {
0000000000000000000000000000000000000000;;			clen = -1 // to represent nil
0000000000000000000000000000000000000000;;		} else if bd == ct.b8 {
0000000000000000000000000000000000000000;;			clen = int(d.r.readn1())
0000000000000000000000000000000000000000;;		} else if bd == ct.b16 {
0000000000000000000000000000000000000000;;			clen = int(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;		} else if bd == ct.b32 {
0000000000000000000000000000000000000000;;			clen = int(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;		} else if (ct.bFixMin & bd) == ct.bFixMin {
0000000000000000000000000000000000000000;;			clen = int(ct.bFixMin ^ bd)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("readContainerLen: %s: hex: %x, decimal: %d", msgBadDesc, bd, bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) ReadMapStart() int {
0000000000000000000000000000000000000000;;		return d.readContainerLen(msgpackContainerMap)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) ReadArrayStart() int {
0000000000000000000000000000000000000000;;		return d.readContainerLen(msgpackContainerList)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) readExtLen() (clen int) {
0000000000000000000000000000000000000000;;		switch d.bd {
0000000000000000000000000000000000000000;;		case mpNil:
0000000000000000000000000000000000000000;;			clen = -1 // to represent nil
0000000000000000000000000000000000000000;;		case mpFixExt1:
0000000000000000000000000000000000000000;;			clen = 1
0000000000000000000000000000000000000000;;		case mpFixExt2:
0000000000000000000000000000000000000000;;			clen = 2
0000000000000000000000000000000000000000;;		case mpFixExt4:
0000000000000000000000000000000000000000;;			clen = 4
0000000000000000000000000000000000000000;;		case mpFixExt8:
0000000000000000000000000000000000000000;;			clen = 8
0000000000000000000000000000000000000000;;		case mpFixExt16:
0000000000000000000000000000000000000000;;			clen = 16
0000000000000000000000000000000000000000;;		case mpExt8:
0000000000000000000000000000000000000000;;			clen = int(d.r.readn1())
0000000000000000000000000000000000000000;;		case mpExt16:
0000000000000000000000000000000000000000;;			clen = int(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;		case mpExt32:
0000000000000000000000000000000000000000;;			clen = int(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.d.errorf("decoding ext bytes: found unexpected byte: %x", d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) DecodeExt(rv interface{}, xtag uint64, ext Ext) (realxtag uint64) {
0000000000000000000000000000000000000000;;		if xtag > 0xff {
0000000000000000000000000000000000000000;;			d.d.errorf("decodeExt: tag must be <= 0xff; got: %v", xtag)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		realxtag1, xbs := d.decodeExtV(ext != nil, uint8(xtag))
0000000000000000000000000000000000000000;;		realxtag = uint64(realxtag1)
0000000000000000000000000000000000000000;;		if ext == nil {
0000000000000000000000000000000000000000;;			re := rv.(*RawExt)
0000000000000000000000000000000000000000;;			re.Tag = realxtag
0000000000000000000000000000000000000000;;			re.Data = detachZeroCopyBytes(d.br, re.Data, xbs)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ext.ReadExt(rv, xbs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) decodeExtV(verifyTag bool, tag byte) (xtag byte, xbs []byte) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		xbd := d.bd
0000000000000000000000000000000000000000;;		if xbd == mpBin8 || xbd == mpBin16 || xbd == mpBin32 {
0000000000000000000000000000000000000000;;			xbs = d.DecodeBytes(nil, false, true)
0000000000000000000000000000000000000000;;		} else if xbd == mpStr8 || xbd == mpStr16 || xbd == mpStr32 ||
0000000000000000000000000000000000000000;;			(xbd >= mpFixStrMin && xbd <= mpFixStrMax) {
0000000000000000000000000000000000000000;;			xbs = d.DecodeBytes(nil, true, true)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			clen := d.readExtLen()
0000000000000000000000000000000000000000;;			xtag = d.r.readn1()
0000000000000000000000000000000000000000;;			if verifyTag && xtag != tag {
0000000000000000000000000000000000000000;;				d.d.errorf("Wrong extension tag. Got %b. Expecting: %v", xtag, tag)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			xbs = d.r.readx(clen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//--------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//MsgpackHandle is a Handle for the Msgpack Schema-Free Encoding Format.
0000000000000000000000000000000000000000;;	type MsgpackHandle struct {
0000000000000000000000000000000000000000;;		BasicHandle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RawToString controls how raw bytes are decoded into a nil interface{}.
0000000000000000000000000000000000000000;;		RawToString bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WriteExt flag supports encoding configured extensions with extension tags.
0000000000000000000000000000000000000000;;		// It also controls whether other elements of the new spec are encoded (ie Str8).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// With WriteExt=false, configured extensions are serialized as raw bytes
0000000000000000000000000000000000000000;;		// and Str8 is not encoded.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// A stream can still be decoded into a typed value, provided an appropriate value
0000000000000000000000000000000000000000;;		// is provided, but the type cannot be inferred from the stream. If no appropriate
0000000000000000000000000000000000000000;;		// type is provided (e.g. decoding into a nil interface{}), you get back
0000000000000000000000000000000000000000;;		// a []byte or string based on the setting of RawToString.
0000000000000000000000000000000000000000;;		WriteExt bool
0000000000000000000000000000000000000000;;		binaryEncodingType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *MsgpackHandle) SetBytesExt(rt reflect.Type, tag uint64, ext BytesExt) (err error) {
0000000000000000000000000000000000000000;;		return h.SetExt(rt, tag, &setExtWrapper{b: ext})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *MsgpackHandle) newEncDriver(e *Encoder) encDriver {
0000000000000000000000000000000000000000;;		return &msgpackEncDriver{e: e, w: e.w, h: h}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *MsgpackHandle) newDecDriver(d *Decoder) decDriver {
0000000000000000000000000000000000000000;;		return &msgpackDecDriver{d: d, r: d.r, h: h, br: d.bytes}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *msgpackEncDriver) reset() {
0000000000000000000000000000000000000000;;		e.w = e.e.w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *msgpackDecDriver) reset() {
0000000000000000000000000000000000000000;;		d.r = d.d.r
0000000000000000000000000000000000000000;;		d.bd, d.bdRead = 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//--------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type msgpackSpecRpcCodec struct {
0000000000000000000000000000000000000000;;		rpcCodec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// /////////////// Spec RPC Codec ///////////////////
0000000000000000000000000000000000000000;;	func (c *msgpackSpecRpcCodec) WriteRequest(r *rpc.Request, body interface{}) error {
0000000000000000000000000000000000000000;;		// WriteRequest can write to both a Go service, and other services that do
0000000000000000000000000000000000000000;;		// not abide by the 1 argument rule of a Go service.
0000000000000000000000000000000000000000;;		// We discriminate based on if the body is a MsgpackSpecRpcMultiArgs
0000000000000000000000000000000000000000;;		var bodyArr []interface{}
0000000000000000000000000000000000000000;;		if m, ok := body.(MsgpackSpecRpcMultiArgs); ok {
0000000000000000000000000000000000000000;;			bodyArr = ([]interface{})(m)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bodyArr = []interface{}{body}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r2 := []interface{}{0, uint32(r.Seq), r.ServiceMethod, bodyArr}
0000000000000000000000000000000000000000;;		return c.write(r2, nil, false, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *msgpackSpecRpcCodec) WriteResponse(r *rpc.Response, body interface{}) error {
0000000000000000000000000000000000000000;;		var moe interface{}
0000000000000000000000000000000000000000;;		if r.Error != "" {
0000000000000000000000000000000000000000;;			moe = r.Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if moe != nil && body != nil {
0000000000000000000000000000000000000000;;			body = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r2 := []interface{}{1, uint32(r.Seq), moe, body}
0000000000000000000000000000000000000000;;		return c.write(r2, nil, false, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *msgpackSpecRpcCodec) ReadResponseHeader(r *rpc.Response) error {
0000000000000000000000000000000000000000;;		return c.parseCustomHeader(1, &r.Seq, &r.Error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *msgpackSpecRpcCodec) ReadRequestHeader(r *rpc.Request) error {
0000000000000000000000000000000000000000;;		return c.parseCustomHeader(0, &r.Seq, &r.ServiceMethod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *msgpackSpecRpcCodec) ReadRequestBody(body interface{}) error {
0000000000000000000000000000000000000000;;		if body == nil { // read and discard
0000000000000000000000000000000000000000;;			return c.read(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bodyArr := []interface{}{body}
0000000000000000000000000000000000000000;;		return c.read(&bodyArr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *msgpackSpecRpcCodec) parseCustomHeader(expectTypeByte byte, msgid *uint64, methodOrError *string) (err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.isClosed() {
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We read the response header by hand
0000000000000000000000000000000000000000;;		// so that the body can be decoded on its own from the stream at a later time.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const fia byte = 0x94 //four item array descriptor value
0000000000000000000000000000000000000000;;		// Not sure why the panic of EOF is swallowed above.
0000000000000000000000000000000000000000;;		// if bs1 := c.dec.r.readn1(); bs1 != fia {
0000000000000000000000000000000000000000;;		// 	err = fmt.Errorf("Unexpected value for array descriptor: Expecting %v. Received %v", fia, bs1)
0000000000000000000000000000000000000000;;		// 	return
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		var b byte
0000000000000000000000000000000000000000;;		b, err = c.br.ReadByte()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b != fia {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Unexpected value for array descriptor: Expecting %v. Received %v", fia, b)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err = c.read(&b); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b != expectTypeByte {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("Unexpected byte descriptor in header. Expecting %v. Received %v", expectTypeByte, b)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = c.read(msgid); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = c.read(methodOrError); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//--------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// msgpackSpecRpc is the implementation of Rpc that uses custom communication protocol
0000000000000000000000000000000000000000;;	// as defined in the msgpack spec at https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md
0000000000000000000000000000000000000000;;	type msgpackSpecRpc struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MsgpackSpecRpc implements Rpc using the communication protocol defined in
0000000000000000000000000000000000000000;;	// the msgpack spec at https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md .
0000000000000000000000000000000000000000;;	// Its methods (ServerCodec and ClientCodec) return values that implement RpcCodecBuffered.
0000000000000000000000000000000000000000;;	var MsgpackSpecRpc msgpackSpecRpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x msgpackSpecRpc) ServerCodec(conn io.ReadWriteCloser, h Handle) rpc.ServerCodec {
0000000000000000000000000000000000000000;;		return &msgpackSpecRpcCodec{newRPCCodec(conn, h)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x msgpackSpecRpc) ClientCodec(conn io.ReadWriteCloser, h Handle) rpc.ClientCodec {
0000000000000000000000000000000000000000;;		return &msgpackSpecRpcCodec{newRPCCodec(conn, h)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ decDriver = (*msgpackDecDriver)(nil)
0000000000000000000000000000000000000000;;	var _ encDriver = (*msgpackEncDriver)(nil)
