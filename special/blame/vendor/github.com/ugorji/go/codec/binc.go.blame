0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/binc.go[Godeps/_workspace/src/github.com/ugorji/go/codec/binc.go][vendor/github.com/ugorji/go/codec/binc.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const bincDoPrune = true // No longer needed. Needed before as C lib did not support pruning.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// vd as low 4 bits (there are 16 slots)
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bincVdSpecial byte = iota
0000000000000000000000000000000000000000;;		bincVdPosInt
0000000000000000000000000000000000000000;;		bincVdNegInt
0000000000000000000000000000000000000000;;		bincVdFloat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bincVdString
0000000000000000000000000000000000000000;;		bincVdByteArray
0000000000000000000000000000000000000000;;		bincVdArray
0000000000000000000000000000000000000000;;		bincVdMap
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bincVdTimestamp
0000000000000000000000000000000000000000;;		bincVdSmallInt
0000000000000000000000000000000000000000;;		bincVdUnicodeOther
0000000000000000000000000000000000000000;;		bincVdSymbol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bincVdDecimal
0000000000000000000000000000000000000000;;		_               // open slot
0000000000000000000000000000000000000000;;		_               // open slot
0000000000000000000000000000000000000000;;		bincVdCustomExt = 0x0f
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bincSpNil byte = iota
0000000000000000000000000000000000000000;;		bincSpFalse
0000000000000000000000000000000000000000;;		bincSpTrue
0000000000000000000000000000000000000000;;		bincSpNan
0000000000000000000000000000000000000000;;		bincSpPosInf
0000000000000000000000000000000000000000;;		bincSpNegInf
0000000000000000000000000000000000000000;;		bincSpZeroFloat
0000000000000000000000000000000000000000;;		bincSpZero
0000000000000000000000000000000000000000;;		bincSpNegOne
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bincFlBin16 byte = iota
0000000000000000000000000000000000000000;;		bincFlBin32
0000000000000000000000000000000000000000;;		_ // bincFlBin32e
0000000000000000000000000000000000000000;;		bincFlBin64
0000000000000000000000000000000000000000;;		_ // bincFlBin64e
0000000000000000000000000000000000000000;;		// others not currently supported
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bincEncDriver struct {
0000000000000000000000000000000000000000;;		e *Encoder
0000000000000000000000000000000000000000;;		w encWriter
0000000000000000000000000000000000000000;;		m map[string]uint16 // symbols
0000000000000000000000000000000000000000;;		b [scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;		s uint16 // symbols sequencer
0000000000000000000000000000000000000000;;		encNoSeparator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) IsBuiltinType(rt uintptr) bool {
0000000000000000000000000000000000000000;;		return rt == timeTypId
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeBuiltin(rt uintptr, v interface{}) {
0000000000000000000000000000000000000000;;		if rt == timeTypId {
0000000000000000000000000000000000000000;;			var bs []byte
0000000000000000000000000000000000000000;;			switch x := v.(type) {
0000000000000000000000000000000000000000;;			case time.Time:
0000000000000000000000000000000000000000;;				bs = encodeTime(x)
0000000000000000000000000000000000000000;;			case *time.Time:
0000000000000000000000000000000000000000;;				bs = encodeTime(*x)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				e.e.errorf("binc error encoding builtin: expect time.Time, received %T", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdTimestamp<<4 | uint8(len(bs)))
0000000000000000000000000000000000000000;;			e.w.writeb(bs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeNil() {
0000000000000000000000000000000000000000;;		e.w.writen1(bincVdSpecial<<4 | bincSpNil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeBool(b bool) {
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdSpecial<<4 | bincSpTrue)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdSpecial<<4 | bincSpFalse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeFloat32(f float32) {
0000000000000000000000000000000000000000;;		if f == 0 {
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdSpecial<<4 | bincSpZeroFloat)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w.writen1(bincVdFloat<<4 | bincFlBin32)
0000000000000000000000000000000000000000;;		bigenHelper{e.b[:4], e.w}.writeUint32(math.Float32bits(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeFloat64(f float64) {
0000000000000000000000000000000000000000;;		if f == 0 {
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdSpecial<<4 | bincSpZeroFloat)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bigen.PutUint64(e.b[:8], math.Float64bits(f))
0000000000000000000000000000000000000000;;		if bincDoPrune {
0000000000000000000000000000000000000000;;			i := 7
0000000000000000000000000000000000000000;;			for ; i >= 0 && (e.b[i] == 0); i-- {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			if i <= 6 {
0000000000000000000000000000000000000000;;				e.w.writen1(bincVdFloat<<4 | 0x8 | bincFlBin64)
0000000000000000000000000000000000000000;;				e.w.writen1(byte(i))
0000000000000000000000000000000000000000;;				e.w.writeb(e.b[:i])
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w.writen1(bincVdFloat<<4 | bincFlBin64)
0000000000000000000000000000000000000000;;		e.w.writeb(e.b[:8])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) encIntegerPrune(bd byte, pos bool, v uint64, lim uint8) {
0000000000000000000000000000000000000000;;		if lim == 4 {
0000000000000000000000000000000000000000;;			bigen.PutUint32(e.b[:lim], uint32(v))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bigen.PutUint64(e.b[:lim], v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bincDoPrune {
0000000000000000000000000000000000000000;;			i := pruneSignExt(e.b[:lim], pos)
0000000000000000000000000000000000000000;;			e.w.writen1(bd | lim - 1 - byte(i))
0000000000000000000000000000000000000000;;			e.w.writeb(e.b[i:lim])
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(bd | lim - 1)
0000000000000000000000000000000000000000;;			e.w.writeb(e.b[:lim])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeInt(v int64) {
0000000000000000000000000000000000000000;;		const nbd byte = bincVdNegInt << 4
0000000000000000000000000000000000000000;;		if v >= 0 {
0000000000000000000000000000000000000000;;			e.encUint(bincVdPosInt<<4, true, uint64(v))
0000000000000000000000000000000000000000;;		} else if v == -1 {
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdSpecial<<4 | bincSpNegOne)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.encUint(bincVdNegInt<<4, false, uint64(-v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeUint(v uint64) {
0000000000000000000000000000000000000000;;		e.encUint(bincVdPosInt<<4, true, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) encUint(bd byte, pos bool, v uint64) {
0000000000000000000000000000000000000000;;		if v == 0 {
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdSpecial<<4 | bincSpZero)
0000000000000000000000000000000000000000;;		} else if pos && v >= 1 && v <= 16 {
0000000000000000000000000000000000000000;;			e.w.writen1(bincVdSmallInt<<4 | byte(v-1))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint8 {
0000000000000000000000000000000000000000;;			e.w.writen2(bd|0x0, byte(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint16 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd | 0x01)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:2], e.w}.writeUint16(uint16(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint32 {
0000000000000000000000000000000000000000;;			e.encIntegerPrune(bd, pos, v, 4)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.encIntegerPrune(bd, pos, v, 8)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeExt(rv interface{}, xtag uint64, ext Ext, _ *Encoder) {
0000000000000000000000000000000000000000;;		bs := ext.WriteExt(rv)
0000000000000000000000000000000000000000;;		if bs == nil {
0000000000000000000000000000000000000000;;			e.EncodeNil()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.encodeExtPreamble(uint8(xtag), len(bs))
0000000000000000000000000000000000000000;;		e.w.writeb(bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeRawExt(re *RawExt, _ *Encoder) {
0000000000000000000000000000000000000000;;		e.encodeExtPreamble(uint8(re.Tag), len(re.Data))
0000000000000000000000000000000000000000;;		e.w.writeb(re.Data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) encodeExtPreamble(xtag byte, length int) {
0000000000000000000000000000000000000000;;		e.encLen(bincVdCustomExt<<4, uint64(length))
0000000000000000000000000000000000000000;;		e.w.writen1(xtag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeArrayStart(length int) {
0000000000000000000000000000000000000000;;		e.encLen(bincVdArray<<4, uint64(length))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeMapStart(length int) {
0000000000000000000000000000000000000000;;		e.encLen(bincVdMap<<4, uint64(length))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeString(c charEncoding, v string) {
0000000000000000000000000000000000000000;;		l := uint64(len(v))
0000000000000000000000000000000000000000;;		e.encBytesLen(c, l)
0000000000000000000000000000000000000000;;		if l > 0 {
0000000000000000000000000000000000000000;;			e.w.writestr(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeSymbol(v string) {
0000000000000000000000000000000000000000;;		// if WriteSymbolsNoRefs {
0000000000000000000000000000000000000000;;		// 	e.encodeString(c_UTF8, v)
0000000000000000000000000000000000000000;;		// 	return
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//symbols only offer benefit when string length > 1.
0000000000000000000000000000000000000000;;		//This is because strings with length 1 take only 2 bytes to store
0000000000000000000000000000000000000000;;		//(bd with embedded length, and single byte for string val).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := len(v)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			e.encBytesLen(c_UTF8, 0)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if l == 1 {
0000000000000000000000000000000000000000;;			e.encBytesLen(c_UTF8, 1)
0000000000000000000000000000000000000000;;			e.w.writen1(v[0])
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e.m == nil {
0000000000000000000000000000000000000000;;			e.m = make(map[string]uint16, 16)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ui, ok := e.m[v]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if ui <= math.MaxUint8 {
0000000000000000000000000000000000000000;;				e.w.writen2(bincVdSymbol<<4, byte(ui))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.w.writen1(bincVdSymbol<<4 | 0x8)
0000000000000000000000000000000000000000;;				bigenHelper{e.b[:2], e.w}.writeUint16(ui)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.s++
0000000000000000000000000000000000000000;;			ui = e.s
0000000000000000000000000000000000000000;;			//ui = uint16(atomic.AddUint32(&e.s, 1))
0000000000000000000000000000000000000000;;			e.m[v] = ui
0000000000000000000000000000000000000000;;			var lenprec uint8
0000000000000000000000000000000000000000;;			if l <= math.MaxUint8 {
0000000000000000000000000000000000000000;;				// lenprec = 0
0000000000000000000000000000000000000000;;			} else if l <= math.MaxUint16 {
0000000000000000000000000000000000000000;;				lenprec = 1
0000000000000000000000000000000000000000;;			} else if int64(l) <= math.MaxUint32 {
0000000000000000000000000000000000000000;;				lenprec = 2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				lenprec = 3
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ui <= math.MaxUint8 {
0000000000000000000000000000000000000000;;				e.w.writen2(bincVdSymbol<<4|0x0|0x4|lenprec, byte(ui))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.w.writen1(bincVdSymbol<<4 | 0x8 | 0x4 | lenprec)
0000000000000000000000000000000000000000;;				bigenHelper{e.b[:2], e.w}.writeUint16(ui)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lenprec == 0 {
0000000000000000000000000000000000000000;;				e.w.writen1(byte(l))
0000000000000000000000000000000000000000;;			} else if lenprec == 1 {
0000000000000000000000000000000000000000;;				bigenHelper{e.b[:2], e.w}.writeUint16(uint16(l))
0000000000000000000000000000000000000000;;			} else if lenprec == 2 {
0000000000000000000000000000000000000000;;				bigenHelper{e.b[:4], e.w}.writeUint32(uint32(l))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				bigenHelper{e.b[:8], e.w}.writeUint64(uint64(l))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.w.writestr(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) EncodeStringBytes(c charEncoding, v []byte) {
0000000000000000000000000000000000000000;;		l := uint64(len(v))
0000000000000000000000000000000000000000;;		e.encBytesLen(c, l)
0000000000000000000000000000000000000000;;		if l > 0 {
0000000000000000000000000000000000000000;;			e.w.writeb(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) encBytesLen(c charEncoding, length uint64) {
0000000000000000000000000000000000000000;;		//TODO: support bincUnicodeOther (for now, just use string or bytearray)
0000000000000000000000000000000000000000;;		if c == c_RAW {
0000000000000000000000000000000000000000;;			e.encLen(bincVdByteArray<<4, length)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.encLen(bincVdString<<4, length)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) encLen(bd byte, l uint64) {
0000000000000000000000000000000000000000;;		if l < 12 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd | uint8(l+4))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.encLenNumber(bd, l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) encLenNumber(bd byte, v uint64) {
0000000000000000000000000000000000000000;;		if v <= math.MaxUint8 {
0000000000000000000000000000000000000000;;			e.w.writen2(bd, byte(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint16 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd | 0x01)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:2], e.w}.writeUint16(uint16(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint32 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd | 0x02)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:4], e.w}.writeUint32(uint32(v))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(bd | 0x03)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:8], e.w}.writeUint64(uint64(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bincDecSymbol struct {
0000000000000000000000000000000000000000;;		s string
0000000000000000000000000000000000000000;;		b []byte
0000000000000000000000000000000000000000;;		i uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bincDecDriver struct {
0000000000000000000000000000000000000000;;		d      *Decoder
0000000000000000000000000000000000000000;;		h      *BincHandle
0000000000000000000000000000000000000000;;		r      decReader
0000000000000000000000000000000000000000;;		br     bool // bytes reader
0000000000000000000000000000000000000000;;		bdRead bool
0000000000000000000000000000000000000000;;		bd     byte
0000000000000000000000000000000000000000;;		vd     byte
0000000000000000000000000000000000000000;;		vs     byte
0000000000000000000000000000000000000000;;		noStreamingCodec
0000000000000000000000000000000000000000;;		decNoSeparator
0000000000000000000000000000000000000000;;		b [scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// linear searching on this slice is ok,
0000000000000000000000000000000000000000;;		// because we typically expect < 32 symbols in each stream.
0000000000000000000000000000000000000000;;		s []bincDecSymbol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) readNextBd() {
0000000000000000000000000000000000000000;;		d.bd = d.r.readn1()
0000000000000000000000000000000000000000;;		d.vd = d.bd >> 4
0000000000000000000000000000000000000000;;		d.vs = d.bd & 0x0f
0000000000000000000000000000000000000000;;		d.bdRead = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) uncacheRead() {
0000000000000000000000000000000000000000;;		if d.bdRead {
0000000000000000000000000000000000000000;;			d.r.unreadn1()
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) ContainerType() (vt valueType) {
0000000000000000000000000000000000000000;;		if d.vd == bincVdSpecial && d.vs == bincSpNil {
0000000000000000000000000000000000000000;;			return valueTypeNil
0000000000000000000000000000000000000000;;		} else if d.vd == bincVdByteArray {
0000000000000000000000000000000000000000;;			return valueTypeBytes
0000000000000000000000000000000000000000;;		} else if d.vd == bincVdString {
0000000000000000000000000000000000000000;;			return valueTypeString
0000000000000000000000000000000000000000;;		} else if d.vd == bincVdArray {
0000000000000000000000000000000000000000;;			return valueTypeArray
0000000000000000000000000000000000000000;;		} else if d.vd == bincVdMap {
0000000000000000000000000000000000000000;;			return valueTypeMap
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// d.d.errorf("isContainerType: unsupported parameter: %v", vt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return valueTypeUnset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) TryDecodeAsNil() bool {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == bincVdSpecial<<4|bincSpNil {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) IsBuiltinType(rt uintptr) bool {
0000000000000000000000000000000000000000;;		return rt == timeTypId
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeBuiltin(rt uintptr, v interface{}) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rt == timeTypId {
0000000000000000000000000000000000000000;;			if d.vd != bincVdTimestamp {
0000000000000000000000000000000000000000;;				d.d.errorf("Invalid d.vd. Expecting 0x%x. Received: 0x%x", bincVdTimestamp, d.vd)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tt, err := decodeTime(d.r.readx(int(d.vs)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var vt *time.Time = v.(*time.Time)
0000000000000000000000000000000000000000;;			*vt = tt
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decFloatPre(vs, defaultLen byte) {
0000000000000000000000000000000000000000;;		if vs&0x8 == 0 {
0000000000000000000000000000000000000000;;			d.r.readb(d.b[0:defaultLen])
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			l := d.r.readn1()
0000000000000000000000000000000000000000;;			if l > 8 {
0000000000000000000000000000000000000000;;				d.d.errorf("At most 8 bytes used to represent float. Received: %v bytes", l)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := l; i < 8; i++ {
0000000000000000000000000000000000000000;;				d.b[i] = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.r.readb(d.b[0:l])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decFloat() (f float64) {
0000000000000000000000000000000000000000;;		//if true { f = math.Float64frombits(bigen.Uint64(d.r.readx(8))); break; }
0000000000000000000000000000000000000000;;		if x := d.vs & 0x7; x == bincFlBin32 {
0000000000000000000000000000000000000000;;			d.decFloatPre(d.vs, 4)
0000000000000000000000000000000000000000;;			f = float64(math.Float32frombits(bigen.Uint32(d.b[0:4])))
0000000000000000000000000000000000000000;;		} else if x == bincFlBin64 {
0000000000000000000000000000000000000000;;			d.decFloatPre(d.vs, 8)
0000000000000000000000000000000000000000;;			f = math.Float64frombits(bigen.Uint64(d.b[0:8]))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("only float32 and float64 are supported. d.vd: 0x%x, d.vs: 0x%x", d.vd, d.vs)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decUint() (v uint64) {
0000000000000000000000000000000000000000;;		// need to inline the code (interface conversion and type assertion expensive)
0000000000000000000000000000000000000000;;		switch d.vs {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			v = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			d.r.readb(d.b[6:8])
0000000000000000000000000000000000000000;;			v = uint64(bigen.Uint16(d.b[6:8]))
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			d.b[4] = 0
0000000000000000000000000000000000000000;;			d.r.readb(d.b[5:8])
0000000000000000000000000000000000000000;;			v = uint64(bigen.Uint32(d.b[4:8]))
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			d.r.readb(d.b[4:8])
0000000000000000000000000000000000000000;;			v = uint64(bigen.Uint32(d.b[4:8]))
0000000000000000000000000000000000000000;;		case 4, 5, 6:
0000000000000000000000000000000000000000;;			lim := int(7 - d.vs)
0000000000000000000000000000000000000000;;			d.r.readb(d.b[lim:8])
0000000000000000000000000000000000000000;;			for i := 0; i < lim; i++ {
0000000000000000000000000000000000000000;;				d.b[i] = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = uint64(bigen.Uint64(d.b[:8]))
0000000000000000000000000000000000000000;;		case 7:
0000000000000000000000000000000000000000;;			d.r.readb(d.b[:8])
0000000000000000000000000000000000000000;;			v = uint64(bigen.Uint64(d.b[:8]))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.d.errorf("unsigned integers with greater than 64 bits of precision not supported")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decCheckInteger() (ui uint64, neg bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vd, vs := d.vd, d.vs
0000000000000000000000000000000000000000;;		if vd == bincVdPosInt {
0000000000000000000000000000000000000000;;			ui = d.decUint()
0000000000000000000000000000000000000000;;		} else if vd == bincVdNegInt {
0000000000000000000000000000000000000000;;			ui = d.decUint()
0000000000000000000000000000000000000000;;			neg = true
0000000000000000000000000000000000000000;;		} else if vd == bincVdSmallInt {
0000000000000000000000000000000000000000;;			ui = uint64(d.vs) + 1
0000000000000000000000000000000000000000;;		} else if vd == bincVdSpecial {
0000000000000000000000000000000000000000;;			if vs == bincSpZero {
0000000000000000000000000000000000000000;;				//i = 0
0000000000000000000000000000000000000000;;			} else if vs == bincSpNegOne {
0000000000000000000000000000000000000000;;				neg = true
0000000000000000000000000000000000000000;;				ui = 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("numeric decode fails for special value: d.vs: 0x%x", d.vs)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("number can only be decoded from uint or int values. d.bd: 0x%x, d.vd: 0x%x", d.bd, d.vd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeInt(bitsize uint8) (i int64) {
0000000000000000000000000000000000000000;;		ui, neg := d.decCheckInteger()
0000000000000000000000000000000000000000;;		i, overflow := chkOvf.SignedInt(ui)
0000000000000000000000000000000000000000;;		if overflow {
0000000000000000000000000000000000000000;;			d.d.errorf("simple: overflow converting %v to signed integer", ui)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if neg {
0000000000000000000000000000000000000000;;			i = -i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOvf.Int(i, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("binc: overflow integer: %v", i)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeUint(bitsize uint8) (ui uint64) {
0000000000000000000000000000000000000000;;		ui, neg := d.decCheckInteger()
0000000000000000000000000000000000000000;;		if neg {
0000000000000000000000000000000000000000;;			d.d.errorf("Assigning negative signed value to unsigned type")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOvf.Uint(ui, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("binc: overflow integer: %v", ui)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeFloat(chkOverflow32 bool) (f float64) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vd, vs := d.vd, d.vs
0000000000000000000000000000000000000000;;		if vd == bincVdSpecial {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			if vs == bincSpNan {
0000000000000000000000000000000000000000;;				return math.NaN()
0000000000000000000000000000000000000000;;			} else if vs == bincSpPosInf {
0000000000000000000000000000000000000000;;				return math.Inf(1)
0000000000000000000000000000000000000000;;			} else if vs == bincSpZeroFloat || vs == bincSpZero {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			} else if vs == bincSpNegInf {
0000000000000000000000000000000000000000;;				return math.Inf(-1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("Invalid d.vs decoding float where d.vd=bincVdSpecial: %v", d.vs)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if vd == bincVdFloat {
0000000000000000000000000000000000000000;;			f = d.decFloat()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f = float64(d.DecodeInt(64))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOverflow32 && chkOvf.Float32(f) {
0000000000000000000000000000000000000000;;			d.d.errorf("binc: float32 overflow: %v", f)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bool can be decoded from bool only (single byte).
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeBool() (b bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bd := d.bd; bd == (bincVdSpecial | bincSpFalse) {
0000000000000000000000000000000000000000;;			// b = false
0000000000000000000000000000000000000000;;		} else if bd == (bincVdSpecial | bincSpTrue) {
0000000000000000000000000000000000000000;;			b = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid single-byte value for bool: %s: %x", msgBadDesc, d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) ReadMapStart() (length int) {
0000000000000000000000000000000000000000;;		if d.vd != bincVdMap {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid d.vd for map. Expecting 0x%x. Got: 0x%x", bincVdMap, d.vd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		length = d.decLen()
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) ReadArrayStart() (length int) {
0000000000000000000000000000000000000000;;		if d.vd != bincVdArray {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid d.vd for array. Expecting 0x%x. Got: 0x%x", bincVdArray, d.vd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		length = d.decLen()
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decLen() int {
0000000000000000000000000000000000000000;;		if d.vs > 3 {
0000000000000000000000000000000000000000;;			return int(d.vs - 4)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(d.decLenNumber())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decLenNumber() (v uint64) {
0000000000000000000000000000000000000000;;		if x := d.vs; x == 0 {
0000000000000000000000000000000000000000;;			v = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;		} else if x == 1 {
0000000000000000000000000000000000000000;;			d.r.readb(d.b[6:8])
0000000000000000000000000000000000000000;;			v = uint64(bigen.Uint16(d.b[6:8]))
0000000000000000000000000000000000000000;;		} else if x == 2 {
0000000000000000000000000000000000000000;;			d.r.readb(d.b[4:8])
0000000000000000000000000000000000000000;;			v = uint64(bigen.Uint32(d.b[4:8]))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.r.readb(d.b[:8])
0000000000000000000000000000000000000000;;			v = bigen.Uint64(d.b[:8])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decStringAndBytes(bs []byte, withString, zerocopy bool) (bs2 []byte, s string) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == bincVdSpecial<<4|bincSpNil {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var slen int = -1
0000000000000000000000000000000000000000;;		// var ok bool
0000000000000000000000000000000000000000;;		switch d.vd {
0000000000000000000000000000000000000000;;		case bincVdString, bincVdByteArray:
0000000000000000000000000000000000000000;;			slen = d.decLen()
0000000000000000000000000000000000000000;;			if zerocopy {
0000000000000000000000000000000000000000;;				if d.br {
0000000000000000000000000000000000000000;;					bs2 = d.r.readx(slen)
0000000000000000000000000000000000000000;;				} else if len(bs) == 0 {
0000000000000000000000000000000000000000;;					bs2 = decByteSlice(d.r, slen, d.b[:])
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					bs2 = decByteSlice(d.r, slen, bs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				bs2 = decByteSlice(d.r, slen, bs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if withString {
0000000000000000000000000000000000000000;;				s = string(bs2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case bincVdSymbol:
0000000000000000000000000000000000000000;;			// zerocopy doesn't apply for symbols,
0000000000000000000000000000000000000000;;			// as the values must be stored in a table for later use.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			//from vs: extract numSymbolBytes, containsStringVal, strLenPrecision,
0000000000000000000000000000000000000000;;			//extract symbol
0000000000000000000000000000000000000000;;			//if containsStringVal, read it and put in map
0000000000000000000000000000000000000000;;			//else look in map for string value
0000000000000000000000000000000000000000;;			var symbol uint16
0000000000000000000000000000000000000000;;			vs := d.vs
0000000000000000000000000000000000000000;;			if vs&0x8 == 0 {
0000000000000000000000000000000000000000;;				symbol = uint16(d.r.readn1())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				symbol = uint16(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if d.s == nil {
0000000000000000000000000000000000000000;;				d.s = make([]bincDecSymbol, 0, 16)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if vs&0x4 == 0 {
0000000000000000000000000000000000000000;;				for i := range d.s {
0000000000000000000000000000000000000000;;					j := &d.s[i]
0000000000000000000000000000000000000000;;					if j.i == symbol {
0000000000000000000000000000000000000000;;						bs2 = j.b
0000000000000000000000000000000000000000;;						if withString {
0000000000000000000000000000000000000000;;							if j.s == "" && bs2 != nil {
0000000000000000000000000000000000000000;;								j.s = string(bs2)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							s = j.s
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch vs & 0x3 {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					slen = int(d.r.readn1())
0000000000000000000000000000000000000000;;				case 1:
0000000000000000000000000000000000000000;;					slen = int(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;				case 2:
0000000000000000000000000000000000000000;;					slen = int(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;				case 3:
0000000000000000000000000000000000000000;;					slen = int(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// since using symbols, do not store any part of
0000000000000000000000000000000000000000;;				// the parameter bs in the map, as it might be a shared buffer.
0000000000000000000000000000000000000000;;				// bs2 = decByteSlice(d.r, slen, bs)
0000000000000000000000000000000000000000;;				bs2 = decByteSlice(d.r, slen, nil)
0000000000000000000000000000000000000000;;				if withString {
0000000000000000000000000000000000000000;;					s = string(bs2)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.s = append(d.s, bincDecSymbol{i: symbol, s: s, b: bs2})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid d.vd. Expecting string:0x%x, bytearray:0x%x or symbol: 0x%x. Got: 0x%x",
0000000000000000000000000000000000000000;;				bincVdString, bincVdByteArray, bincVdSymbol, d.vd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeString() (s string) {
0000000000000000000000000000000000000000;;		// DecodeBytes does not accommodate symbols, whose impl stores string version in map.
0000000000000000000000000000000000000000;;		// Use decStringAndBytes directly.
0000000000000000000000000000000000000000;;		// return string(d.DecodeBytes(d.b[:], true, true))
0000000000000000000000000000000000000000;;		_, s = d.decStringAndBytes(d.b[:], true, true)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeBytes(bs []byte, isstring, zerocopy bool) (bsOut []byte) {
0000000000000000000000000000000000000000;;		if isstring {
0000000000000000000000000000000000000000;;			bsOut, _ = d.decStringAndBytes(bs, false, zerocopy)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == bincVdSpecial<<4|bincSpNil {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var clen int
0000000000000000000000000000000000000000;;		if d.vd == bincVdString || d.vd == bincVdByteArray {
0000000000000000000000000000000000000000;;			clen = d.decLen()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid d.vd for bytes. Expecting string:0x%x or bytearray:0x%x. Got: 0x%x",
0000000000000000000000000000000000000000;;				bincVdString, bincVdByteArray, d.vd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		if zerocopy {
0000000000000000000000000000000000000000;;			if d.br {
0000000000000000000000000000000000000000;;				return d.r.readx(clen)
0000000000000000000000000000000000000000;;			} else if len(bs) == 0 {
0000000000000000000000000000000000000000;;				bs = d.b[:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decByteSlice(d.r, clen, bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeExt(rv interface{}, xtag uint64, ext Ext) (realxtag uint64) {
0000000000000000000000000000000000000000;;		if xtag > 0xff {
0000000000000000000000000000000000000000;;			d.d.errorf("decodeExt: tag must be <= 0xff; got: %v", xtag)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		realxtag1, xbs := d.decodeExtV(ext != nil, uint8(xtag))
0000000000000000000000000000000000000000;;		realxtag = uint64(realxtag1)
0000000000000000000000000000000000000000;;		if ext == nil {
0000000000000000000000000000000000000000;;			re := rv.(*RawExt)
0000000000000000000000000000000000000000;;			re.Tag = realxtag
0000000000000000000000000000000000000000;;			re.Data = detachZeroCopyBytes(d.br, re.Data, xbs)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ext.ReadExt(rv, xbs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) decodeExtV(verifyTag bool, tag byte) (xtag byte, xbs []byte) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.vd == bincVdCustomExt {
0000000000000000000000000000000000000000;;			l := d.decLen()
0000000000000000000000000000000000000000;;			xtag = d.r.readn1()
0000000000000000000000000000000000000000;;			if verifyTag && xtag != tag {
0000000000000000000000000000000000000000;;				d.d.errorf("Wrong extension tag. Got %b. Expecting: %v", xtag, tag)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			xbs = d.r.readx(l)
0000000000000000000000000000000000000000;;		} else if d.vd == bincVdByteArray {
0000000000000000000000000000000000000000;;			xbs = d.DecodeBytes(nil, false, true)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid d.vd for extensions (Expecting extensions or byte array). Got: 0x%x", d.vd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) DecodeNaked() {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := &d.d.n
0000000000000000000000000000000000000000;;		var decodeFurther bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch d.vd {
0000000000000000000000000000000000000000;;		case bincVdSpecial:
0000000000000000000000000000000000000000;;			switch d.vs {
0000000000000000000000000000000000000000;;			case bincSpNil:
0000000000000000000000000000000000000000;;				n.v = valueTypeNil
0000000000000000000000000000000000000000;;			case bincSpFalse:
0000000000000000000000000000000000000000;;				n.v = valueTypeBool
0000000000000000000000000000000000000000;;				n.b = false
0000000000000000000000000000000000000000;;			case bincSpTrue:
0000000000000000000000000000000000000000;;				n.v = valueTypeBool
0000000000000000000000000000000000000000;;				n.b = true
0000000000000000000000000000000000000000;;			case bincSpNan:
0000000000000000000000000000000000000000;;				n.v = valueTypeFloat
0000000000000000000000000000000000000000;;				n.f = math.NaN()
0000000000000000000000000000000000000000;;			case bincSpPosInf:
0000000000000000000000000000000000000000;;				n.v = valueTypeFloat
0000000000000000000000000000000000000000;;				n.f = math.Inf(1)
0000000000000000000000000000000000000000;;			case bincSpNegInf:
0000000000000000000000000000000000000000;;				n.v = valueTypeFloat
0000000000000000000000000000000000000000;;				n.f = math.Inf(-1)
0000000000000000000000000000000000000000;;			case bincSpZeroFloat:
0000000000000000000000000000000000000000;;				n.v = valueTypeFloat
0000000000000000000000000000000000000000;;				n.f = float64(0)
0000000000000000000000000000000000000000;;			case bincSpZero:
0000000000000000000000000000000000000000;;				n.v = valueTypeUint
0000000000000000000000000000000000000000;;				n.u = uint64(0) // int8(0)
0000000000000000000000000000000000000000;;			case bincSpNegOne:
0000000000000000000000000000000000000000;;				n.v = valueTypeInt
0000000000000000000000000000000000000000;;				n.i = int64(-1) // int8(-1)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				d.d.errorf("decodeNaked: Unrecognized special value 0x%x", d.vs)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case bincVdSmallInt:
0000000000000000000000000000000000000000;;			n.v = valueTypeUint
0000000000000000000000000000000000000000;;			n.u = uint64(int8(d.vs)) + 1 // int8(d.vs) + 1
0000000000000000000000000000000000000000;;		case bincVdPosInt:
0000000000000000000000000000000000000000;;			n.v = valueTypeUint
0000000000000000000000000000000000000000;;			n.u = d.decUint()
0000000000000000000000000000000000000000;;		case bincVdNegInt:
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = -(int64(d.decUint()))
0000000000000000000000000000000000000000;;		case bincVdFloat:
0000000000000000000000000000000000000000;;			n.v = valueTypeFloat
0000000000000000000000000000000000000000;;			n.f = d.decFloat()
0000000000000000000000000000000000000000;;		case bincVdSymbol:
0000000000000000000000000000000000000000;;			n.v = valueTypeSymbol
0000000000000000000000000000000000000000;;			n.s = d.DecodeString()
0000000000000000000000000000000000000000;;		case bincVdString:
0000000000000000000000000000000000000000;;			n.v = valueTypeString
0000000000000000000000000000000000000000;;			n.s = d.DecodeString()
0000000000000000000000000000000000000000;;		case bincVdByteArray:
0000000000000000000000000000000000000000;;			n.v = valueTypeBytes
0000000000000000000000000000000000000000;;			n.l = d.DecodeBytes(nil, false, false)
0000000000000000000000000000000000000000;;		case bincVdTimestamp:
0000000000000000000000000000000000000000;;			n.v = valueTypeTimestamp
0000000000000000000000000000000000000000;;			tt, err := decodeTime(d.r.readx(int(d.vs)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n.t = tt
0000000000000000000000000000000000000000;;		case bincVdCustomExt:
0000000000000000000000000000000000000000;;			n.v = valueTypeExt
0000000000000000000000000000000000000000;;			l := d.decLen()
0000000000000000000000000000000000000000;;			n.u = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;			n.l = d.r.readx(l)
0000000000000000000000000000000000000000;;		case bincVdArray:
0000000000000000000000000000000000000000;;			n.v = valueTypeArray
0000000000000000000000000000000000000000;;			decodeFurther = true
0000000000000000000000000000000000000000;;		case bincVdMap:
0000000000000000000000000000000000000000;;			n.v = valueTypeMap
0000000000000000000000000000000000000000;;			decodeFurther = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.d.errorf("decodeNaked: Unrecognized d.vd: 0x%x", d.vd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !decodeFurther {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.v == valueTypeUint && d.h.SignedInteger {
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = int64(n.u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//BincHandle is a Handle for the Binc Schema-Free Encoding Format
0000000000000000000000000000000000000000;;	//defined at https://github.com/ugorji/binc .
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//BincHandle currently supports all Binc features with the following EXCEPTIONS:
0000000000000000000000000000000000000000;;	//  - only integers up to 64 bits of precision are supported.
0000000000000000000000000000000000000000;;	//    big integers are unsupported.
0000000000000000000000000000000000000000;;	//  - Only IEEE 754 binary32 and binary64 floats are supported (ie Go float32 and float64 types).
0000000000000000000000000000000000000000;;	//    extended precision and decimal IEEE 754 floats are unsupported.
0000000000000000000000000000000000000000;;	//  - Only UTF-8 strings supported.
0000000000000000000000000000000000000000;;	//    Unicode_Other Binc types (UTF16, UTF32) are currently unsupported.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//Note that these EXCEPTIONS are temporary and full support is possible and may happen soon.
0000000000000000000000000000000000000000;;	type BincHandle struct {
0000000000000000000000000000000000000000;;		BasicHandle
0000000000000000000000000000000000000000;;		binaryEncodingType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *BincHandle) SetBytesExt(rt reflect.Type, tag uint64, ext BytesExt) (err error) {
0000000000000000000000000000000000000000;;		return h.SetExt(rt, tag, &setExtWrapper{b: ext})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *BincHandle) newEncDriver(e *Encoder) encDriver {
0000000000000000000000000000000000000000;;		return &bincEncDriver{e: e, w: e.w}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *BincHandle) newDecDriver(d *Decoder) decDriver {
0000000000000000000000000000000000000000;;		return &bincDecDriver{d: d, r: d.r, h: h, br: d.bytes}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *bincEncDriver) reset() {
0000000000000000000000000000000000000000;;		e.w = e.e.w
0000000000000000000000000000000000000000;;		e.s = 0
0000000000000000000000000000000000000000;;		e.m = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *bincDecDriver) reset() {
0000000000000000000000000000000000000000;;		d.r = d.d.r
0000000000000000000000000000000000000000;;		d.s = nil
0000000000000000000000000000000000000000;;		d.bd, d.bdRead, d.vd, d.vs = 0, false, 0, 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ decDriver = (*bincDecDriver)(nil)
0000000000000000000000000000000000000000;;	var _ encDriver = (*bincEncDriver)(nil)
