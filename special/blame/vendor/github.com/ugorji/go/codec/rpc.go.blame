0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/rpc.go[Godeps/_workspace/src/github.com/ugorji/go/codec/rpc.go][vendor/github.com/ugorji/go/codec/rpc.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/rpc"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rpcEncodeTerminator allows a handler specify a []byte terminator to send after each Encode.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some codecs like json need to put a space after each encoded value, to serve as a
0000000000000000000000000000000000000000;;	// delimiter for things like numbers (else json codec will continue reading till EOF).
0000000000000000000000000000000000000000;;	type rpcEncodeTerminator interface {
0000000000000000000000000000000000000000;;		rpcEncodeTerminate() []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rpc provides a rpc Server or Client Codec for rpc communication.
0000000000000000000000000000000000000000;;	type Rpc interface {
0000000000000000000000000000000000000000;;		ServerCodec(conn io.ReadWriteCloser, h Handle) rpc.ServerCodec
0000000000000000000000000000000000000000;;		ClientCodec(conn io.ReadWriteCloser, h Handle) rpc.ClientCodec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RpcCodecBuffered allows access to the underlying bufio.Reader/Writer
0000000000000000000000000000000000000000;;	// used by the rpc connection. It accommodates use-cases where the connection
0000000000000000000000000000000000000000;;	// should be used by rpc and non-rpc functions, e.g. streaming a file after
0000000000000000000000000000000000000000;;	// sending an rpc response.
0000000000000000000000000000000000000000;;	type RpcCodecBuffered interface {
0000000000000000000000000000000000000000;;		BufferedReader() *bufio.Reader
0000000000000000000000000000000000000000;;		BufferedWriter() *bufio.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rpcCodec defines the struct members and common methods.
0000000000000000000000000000000000000000;;	type rpcCodec struct {
0000000000000000000000000000000000000000;;		rwc io.ReadWriteCloser
0000000000000000000000000000000000000000;;		dec *Decoder
0000000000000000000000000000000000000000;;		enc *Encoder
0000000000000000000000000000000000000000;;		bw  *bufio.Writer
0000000000000000000000000000000000000000;;		br  *bufio.Reader
0000000000000000000000000000000000000000;;		mu  sync.Mutex
0000000000000000000000000000000000000000;;		h   Handle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cls   bool
0000000000000000000000000000000000000000;;		clsmu sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRPCCodec(conn io.ReadWriteCloser, h Handle) rpcCodec {
0000000000000000000000000000000000000000;;		bw := bufio.NewWriter(conn)
0000000000000000000000000000000000000000;;		br := bufio.NewReader(conn)
0000000000000000000000000000000000000000;;		return rpcCodec{
0000000000000000000000000000000000000000;;			rwc: conn,
0000000000000000000000000000000000000000;;			bw:  bw,
0000000000000000000000000000000000000000;;			br:  br,
0000000000000000000000000000000000000000;;			enc: NewEncoder(bw, h),
0000000000000000000000000000000000000000;;			dec: NewDecoder(br, h),
0000000000000000000000000000000000000000;;			h:   h,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rpcCodec) BufferedReader() *bufio.Reader {
0000000000000000000000000000000000000000;;		return c.br
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rpcCodec) BufferedWriter() *bufio.Writer {
0000000000000000000000000000000000000000;;		return c.bw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rpcCodec) write(obj1, obj2 interface{}, writeObj2, doFlush bool) (err error) {
0000000000000000000000000000000000000000;;		if c.isClosed() {
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = c.enc.Encode(obj1); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, tOk := c.h.(rpcEncodeTerminator)
0000000000000000000000000000000000000000;;		if tOk {
0000000000000000000000000000000000000000;;			c.bw.Write(t.rpcEncodeTerminate())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if writeObj2 {
0000000000000000000000000000000000000000;;			if err = c.enc.Encode(obj2); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tOk {
0000000000000000000000000000000000000000;;				c.bw.Write(t.rpcEncodeTerminate())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if doFlush {
0000000000000000000000000000000000000000;;			return c.bw.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rpcCodec) read(obj interface{}) (err error) {
0000000000000000000000000000000000000000;;		if c.isClosed() {
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		//If nil is passed in, we should still attempt to read content to nowhere.
0000000000000000000000000000000000000000;;		if obj == nil {
0000000000000000000000000000000000000000;;			var obj2 interface{}
0000000000000000000000000000000000000000;;			return c.dec.Decode(&obj2)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.dec.Decode(obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rpcCodec) isClosed() bool {
0000000000000000000000000000000000000000;;		c.clsmu.RLock()
0000000000000000000000000000000000000000;;		x := c.cls
0000000000000000000000000000000000000000;;		c.clsmu.RUnlock()
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rpcCodec) Close() error {
0000000000000000000000000000000000000000;;		if c.isClosed() {
0000000000000000000000000000000000000000;;			return io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.clsmu.Lock()
0000000000000000000000000000000000000000;;		c.cls = true
0000000000000000000000000000000000000000;;		c.clsmu.Unlock()
0000000000000000000000000000000000000000;;		return c.rwc.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *rpcCodec) ReadResponseBody(body interface{}) error {
0000000000000000000000000000000000000000;;		return c.read(body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type goRpcCodec struct {
0000000000000000000000000000000000000000;;		rpcCodec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *goRpcCodec) WriteRequest(r *rpc.Request, body interface{}) error {
0000000000000000000000000000000000000000;;		// Must protect for concurrent access as per API
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		defer c.mu.Unlock()
0000000000000000000000000000000000000000;;		return c.write(r, body, true, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *goRpcCodec) WriteResponse(r *rpc.Response, body interface{}) error {
0000000000000000000000000000000000000000;;		c.mu.Lock()
0000000000000000000000000000000000000000;;		defer c.mu.Unlock()
0000000000000000000000000000000000000000;;		return c.write(r, body, true, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *goRpcCodec) ReadResponseHeader(r *rpc.Response) error {
0000000000000000000000000000000000000000;;		return c.read(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *goRpcCodec) ReadRequestHeader(r *rpc.Request) error {
0000000000000000000000000000000000000000;;		return c.read(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *goRpcCodec) ReadRequestBody(body interface{}) error {
0000000000000000000000000000000000000000;;		return c.read(body)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goRpc is the implementation of Rpc that uses the communication protocol
0000000000000000000000000000000000000000;;	// as defined in net/rpc package.
0000000000000000000000000000000000000000;;	type goRpc struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoRpc implements Rpc using the communication protocol defined in net/rpc package.
0000000000000000000000000000000000000000;;	// Its methods (ServerCodec and ClientCodec) return values that implement RpcCodecBuffered.
0000000000000000000000000000000000000000;;	var GoRpc goRpc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x goRpc) ServerCodec(conn io.ReadWriteCloser, h Handle) rpc.ServerCodec {
0000000000000000000000000000000000000000;;		return &goRpcCodec{newRPCCodec(conn, h)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x goRpc) ClientCodec(conn io.ReadWriteCloser, h Handle) rpc.ClientCodec {
0000000000000000000000000000000000000000;;		return &goRpcCodec{newRPCCodec(conn, h)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ RpcCodecBuffered = (*rpcCodec)(nil) // ensure *rpcCodec implements RpcCodecBuffered
