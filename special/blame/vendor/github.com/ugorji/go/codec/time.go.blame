0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/time.go[Godeps/_workspace/src/github.com/ugorji/go/codec/time.go][vendor/github.com/ugorji/go/codec/time.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		timeDigits   = [...]byte{'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'}
0000000000000000000000000000000000000000;;		timeExtEncFn = func(rv reflect.Value) (bs []byte, err error) {
0000000000000000000000000000000000000000;;			defer panicToErr(&err)
0000000000000000000000000000000000000000;;			bs = timeExt{}.WriteExt(rv.Interface())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeExtDecFn = func(rv reflect.Value, bs []byte) (err error) {
0000000000000000000000000000000000000000;;			defer panicToErr(&err)
0000000000000000000000000000000000000000;;			timeExt{}.ReadExt(rv.Interface(), bs)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timeExt struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x timeExt) WriteExt(v interface{}) (bs []byte) {
0000000000000000000000000000000000000000;;		switch v2 := v.(type) {
0000000000000000000000000000000000000000;;		case time.Time:
0000000000000000000000000000000000000000;;			bs = encodeTime(v2)
0000000000000000000000000000000000000000;;		case *time.Time:
0000000000000000000000000000000000000000;;			bs = encodeTime(*v2)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("unsupported format for time conversion: expecting time.Time; got %T", v2))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (x timeExt) ReadExt(v interface{}, bs []byte) {
0000000000000000000000000000000000000000;;		tt, err := decodeTime(bs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*(v.(*time.Time)) = tt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x timeExt) ConvertExt(v interface{}) interface{} {
0000000000000000000000000000000000000000;;		return x.WriteExt(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (x timeExt) UpdateExt(v interface{}, src interface{}) {
0000000000000000000000000000000000000000;;		x.ReadExt(v, src.([]byte))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeTime encodes a time.Time as a []byte, including
0000000000000000000000000000000000000000;;	// information on the instant in time and UTC offset.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Format Description
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   A timestamp is composed of 3 components:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   - secs: signed integer representing seconds since unix epoch
0000000000000000000000000000000000000000;;	//   - nsces: unsigned integer representing fractional seconds as a
0000000000000000000000000000000000000000;;	//     nanosecond offset within secs, in the range 0 <= nsecs < 1e9
0000000000000000000000000000000000000000;;	//   - tz: signed integer representing timezone offset in minutes east of UTC,
0000000000000000000000000000000000000000;;	//     and a dst (daylight savings time) flag
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   When encoding a timestamp, the first byte is the descriptor, which
0000000000000000000000000000000000000000;;	//   defines which components are encoded and how many bytes are used to
0000000000000000000000000000000000000000;;	//   encode secs and nsecs components. *If secs/nsecs is 0 or tz is UTC, it
0000000000000000000000000000000000000000;;	//   is not encoded in the byte array explicitly*.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       Descriptor 8 bits are of the form `A B C DDD EE`:
0000000000000000000000000000000000000000;;	//           A:   Is secs component encoded? 1 = true
0000000000000000000000000000000000000000;;	//           B:   Is nsecs component encoded? 1 = true
0000000000000000000000000000000000000000;;	//           C:   Is tz component encoded? 1 = true
0000000000000000000000000000000000000000;;	//           DDD: Number of extra bytes for secs (range 0-7).
0000000000000000000000000000000000000000;;	//                If A = 1, secs encoded in DDD+1 bytes.
0000000000000000000000000000000000000000;;	//                    If A = 0, secs is not encoded, and is assumed to be 0.
0000000000000000000000000000000000000000;;	//                    If A = 1, then we need at least 1 byte to encode secs.
0000000000000000000000000000000000000000;;	//                    DDD says the number of extra bytes beyond that 1.
0000000000000000000000000000000000000000;;	//                    E.g. if DDD=0, then secs is represented in 1 byte.
0000000000000000000000000000000000000000;;	//                         if DDD=2, then secs is represented in 3 bytes.
0000000000000000000000000000000000000000;;	//           EE:  Number of extra bytes for nsecs (range 0-3).
0000000000000000000000000000000000000000;;	//                If B = 1, nsecs encoded in EE+1 bytes (similar to secs/DDD above)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   Following the descriptor bytes, subsequent bytes are:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       secs component encoded in `DDD + 1` bytes (if A == 1)
0000000000000000000000000000000000000000;;	//       nsecs component encoded in `EE + 1` bytes (if B == 1)
0000000000000000000000000000000000000000;;	//       tz component encoded in 2 bytes (if C == 1)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   secs and nsecs components are integers encoded in a BigEndian
0000000000000000000000000000000000000000;;	//   2-complement encoding format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   tz component is encoded as 2 bytes (16 bits). Most significant bit 15 to
0000000000000000000000000000000000000000;;	//   Least significant bit 0 are described below:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//       Timezone offset has a range of -12:00 to +14:00 (ie -720 to +840 minutes).
0000000000000000000000000000000000000000;;	//       Bit 15 = have\_dst: set to 1 if we set the dst flag.
0000000000000000000000000000000000000000;;	//       Bit 14 = dst\_on: set to 1 if dst is in effect at the time, or 0 if not.
0000000000000000000000000000000000000000;;	//       Bits 13..0 = timezone offset in minutes. It is a signed integer in Big Endian format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func encodeTime(t time.Time) []byte {
0000000000000000000000000000000000000000;;		//t := rv.Interface().(time.Time)
0000000000000000000000000000000000000000;;		tsecs, tnsecs := t.Unix(), t.Nanosecond()
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			bd   byte
0000000000000000000000000000000000000000;;			btmp [8]byte
0000000000000000000000000000000000000000;;			bs   [16]byte
0000000000000000000000000000000000000000;;			i    int = 1
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		l := t.Location()
0000000000000000000000000000000000000000;;		if l == time.UTC {
0000000000000000000000000000000000000000;;			l = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tsecs != 0 {
0000000000000000000000000000000000000000;;			bd = bd | 0x80
0000000000000000000000000000000000000000;;			bigen.PutUint64(btmp[:], uint64(tsecs))
0000000000000000000000000000000000000000;;			f := pruneSignExt(btmp[:], tsecs >= 0)
0000000000000000000000000000000000000000;;			bd = bd | (byte(7-f) << 2)
0000000000000000000000000000000000000000;;			copy(bs[i:], btmp[f:])
0000000000000000000000000000000000000000;;			i = i + (8 - f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tnsecs != 0 {
0000000000000000000000000000000000000000;;			bd = bd | 0x40
0000000000000000000000000000000000000000;;			bigen.PutUint32(btmp[:4], uint32(tnsecs))
0000000000000000000000000000000000000000;;			f := pruneSignExt(btmp[:4], true)
0000000000000000000000000000000000000000;;			bd = bd | byte(3-f)
0000000000000000000000000000000000000000;;			copy(bs[i:], btmp[f:4])
0000000000000000000000000000000000000000;;			i = i + (4 - f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l != nil {
0000000000000000000000000000000000000000;;			bd = bd | 0x20
0000000000000000000000000000000000000000;;			// Note that Go Libs do not give access to dst flag.
0000000000000000000000000000000000000000;;			_, zoneOffset := t.Zone()
0000000000000000000000000000000000000000;;			//zoneName, zoneOffset := t.Zone()
0000000000000000000000000000000000000000;;			zoneOffset /= 60
0000000000000000000000000000000000000000;;			z := uint16(zoneOffset)
0000000000000000000000000000000000000000;;			bigen.PutUint16(btmp[:2], z)
0000000000000000000000000000000000000000;;			// clear dst flags
0000000000000000000000000000000000000000;;			bs[i] = btmp[0] & 0x3f
0000000000000000000000000000000000000000;;			bs[i+1] = btmp[1]
0000000000000000000000000000000000000000;;			i = i + 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bs[0] = bd
0000000000000000000000000000000000000000;;		return bs[0:i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeTime decodes a []byte into a time.Time.
0000000000000000000000000000000000000000;;	func decodeTime(bs []byte) (tt time.Time, err error) {
0000000000000000000000000000000000000000;;		bd := bs[0]
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			tsec  int64
0000000000000000000000000000000000000000;;			tnsec uint32
0000000000000000000000000000000000000000;;			tz    uint16
0000000000000000000000000000000000000000;;			i     byte = 1
0000000000000000000000000000000000000000;;			i2    byte
0000000000000000000000000000000000000000;;			n     byte
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if bd&(1<<7) != 0 {
0000000000000000000000000000000000000000;;			var btmp [8]byte
0000000000000000000000000000000000000000;;			n = ((bd >> 2) & 0x7) + 1
0000000000000000000000000000000000000000;;			i2 = i + n
0000000000000000000000000000000000000000;;			copy(btmp[8-n:], bs[i:i2])
0000000000000000000000000000000000000000;;			//if first bit of bs[i] is set, then fill btmp[0..8-n] with 0xff (ie sign extend it)
0000000000000000000000000000000000000000;;			if bs[i]&(1<<7) != 0 {
0000000000000000000000000000000000000000;;				copy(btmp[0:8-n], bsAll0xff)
0000000000000000000000000000000000000000;;				//for j,k := byte(0), 8-n; j < k; j++ {	btmp[j] = 0xff }
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = i2
0000000000000000000000000000000000000000;;			tsec = int64(bigen.Uint64(btmp[:]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bd&(1<<6) != 0 {
0000000000000000000000000000000000000000;;			var btmp [4]byte
0000000000000000000000000000000000000000;;			n = (bd & 0x3) + 1
0000000000000000000000000000000000000000;;			i2 = i + n
0000000000000000000000000000000000000000;;			copy(btmp[4-n:], bs[i:i2])
0000000000000000000000000000000000000000;;			i = i2
0000000000000000000000000000000000000000;;			tnsec = bigen.Uint32(btmp[:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if bd&(1<<5) == 0 {
0000000000000000000000000000000000000000;;			tt = time.Unix(tsec, int64(tnsec)).UTC()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// In stdlib time.Parse, when a date is parsed without a zone name, it uses "" as zone name.
0000000000000000000000000000000000000000;;		// However, we need name here, so it can be shown when time is printed.
0000000000000000000000000000000000000000;;		// Zone name is in form: UTC-08:00.
0000000000000000000000000000000000000000;;		// Note that Go Libs do not give access to dst flag, so we ignore dst bits
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i2 = i + 2
0000000000000000000000000000000000000000;;		tz = bigen.Uint16(bs[i:i2])
0000000000000000000000000000000000000000;;		i = i2
0000000000000000000000000000000000000000;;		// sign extend sign bit into top 2 MSB (which were dst bits):
0000000000000000000000000000000000000000;;		if tz&(1<<13) == 0 { // positive
0000000000000000000000000000000000000000;;			tz = tz & 0x3fff //clear 2 MSBs: dst bits
0000000000000000000000000000000000000000;;		} else { // negative
0000000000000000000000000000000000000000;;			tz = tz | 0xc000 //set 2 MSBs: dst bits
0000000000000000000000000000000000000000;;			//tzname[3] = '-' (TODO: verify. this works here)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tzint := int16(tz)
0000000000000000000000000000000000000000;;		if tzint == 0 {
0000000000000000000000000000000000000000;;			tt = time.Unix(tsec, int64(tnsec)).UTC()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// For Go Time, do not use a descriptive timezone.
0000000000000000000000000000000000000000;;			// It's unnecessary, and makes it harder to do a reflect.DeepEqual.
0000000000000000000000000000000000000000;;			// The Offset already tells what the offset should be, if not on UTC and unknown zone name.
0000000000000000000000000000000000000000;;			// var zoneName = timeLocUTCName(tzint)
0000000000000000000000000000000000000000;;			tt = time.Unix(tsec, int64(tnsec)).In(time.FixedZone("", int(tzint)*60))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func timeLocUTCName(tzint int16) string {
0000000000000000000000000000000000000000;;		if tzint == 0 {
0000000000000000000000000000000000000000;;			return "UTC"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var tzname = []byte("UTC+00:00")
0000000000000000000000000000000000000000;;		//tzname := fmt.Sprintf("UTC%s%02d:%02d", tzsign, tz/60, tz%60) //perf issue using Sprintf. inline below.
0000000000000000000000000000000000000000;;		//tzhr, tzmin := tz/60, tz%60 //faster if u convert to int first
0000000000000000000000000000000000000000;;		var tzhr, tzmin int16
0000000000000000000000000000000000000000;;		if tzint < 0 {
0000000000000000000000000000000000000000;;			tzname[3] = '-' // (TODO: verify. this works here)
0000000000000000000000000000000000000000;;			tzhr, tzmin = -tzint/60, (-tzint)%60
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tzhr, tzmin = tzint/60, tzint%60
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tzname[4] = timeDigits[tzhr/10]
0000000000000000000000000000000000000000;;		tzname[5] = timeDigits[tzhr%10]
0000000000000000000000000000000000000000;;		tzname[7] = timeDigits[tzmin/10]
0000000000000000000000000000000000000000;;		tzname[8] = timeDigits[tzmin%10]
0000000000000000000000000000000000000000;;		return string(tzname)
0000000000000000000000000000000000000000;;		//return time.FixedZone(string(tzname), int(tzint)*60)
0000000000000000000000000000000000000000;;	}
