0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/simple.go[Godeps/_workspace/src/github.com/ugorji/go/codec/simple.go][vendor/github.com/ugorji/go/codec/simple.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_               uint8 = iota
0000000000000000000000000000000000000000;;		simpleVdNil           = 1
0000000000000000000000000000000000000000;;		simpleVdFalse         = 2
0000000000000000000000000000000000000000;;		simpleVdTrue          = 3
0000000000000000000000000000000000000000;;		simpleVdFloat32       = 4
0000000000000000000000000000000000000000;;		simpleVdFloat64       = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// each lasts for 4 (ie n, n+1, n+2, n+3)
0000000000000000000000000000000000000000;;		simpleVdPosInt = 8
0000000000000000000000000000000000000000;;		simpleVdNegInt = 12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// containers: each lasts for 4 (ie n, n+1, n+2, ... n+7)
0000000000000000000000000000000000000000;;		simpleVdString    = 216
0000000000000000000000000000000000000000;;		simpleVdByteArray = 224
0000000000000000000000000000000000000000;;		simpleVdArray     = 232
0000000000000000000000000000000000000000;;		simpleVdMap       = 240
0000000000000000000000000000000000000000;;		simpleVdExt       = 248
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleEncDriver struct {
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;		encNoSeparator
0000000000000000000000000000000000000000;;		e *Encoder
0000000000000000000000000000000000000000;;		h *SimpleHandle
0000000000000000000000000000000000000000;;		w encWriter
0000000000000000000000000000000000000000;;		b [8]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeNil() {
0000000000000000000000000000000000000000;;		e.w.writen1(simpleVdNil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeBool(b bool) {
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			e.w.writen1(simpleVdTrue)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(simpleVdFalse)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeFloat32(f float32) {
0000000000000000000000000000000000000000;;		e.w.writen1(simpleVdFloat32)
0000000000000000000000000000000000000000;;		bigenHelper{e.b[:4], e.w}.writeUint32(math.Float32bits(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeFloat64(f float64) {
0000000000000000000000000000000000000000;;		e.w.writen1(simpleVdFloat64)
0000000000000000000000000000000000000000;;		bigenHelper{e.b[:8], e.w}.writeUint64(math.Float64bits(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeInt(v int64) {
0000000000000000000000000000000000000000;;		if v < 0 {
0000000000000000000000000000000000000000;;			e.encUint(uint64(-v), simpleVdNegInt)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.encUint(uint64(v), simpleVdPosInt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeUint(v uint64) {
0000000000000000000000000000000000000000;;		e.encUint(v, simpleVdPosInt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) encUint(v uint64, bd uint8) {
0000000000000000000000000000000000000000;;		if v <= math.MaxUint8 {
0000000000000000000000000000000000000000;;			e.w.writen2(bd, uint8(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint16 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 1)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:2], e.w}.writeUint16(uint16(v))
0000000000000000000000000000000000000000;;		} else if v <= math.MaxUint32 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 2)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:4], e.w}.writeUint32(uint32(v))
0000000000000000000000000000000000000000;;		} else { // if v <= math.MaxUint64 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 3)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:8], e.w}.writeUint64(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) encLen(bd byte, length int) {
0000000000000000000000000000000000000000;;		if length == 0 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd)
0000000000000000000000000000000000000000;;		} else if length <= math.MaxUint8 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 1)
0000000000000000000000000000000000000000;;			e.w.writen1(uint8(length))
0000000000000000000000000000000000000000;;		} else if length <= math.MaxUint16 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 2)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:2], e.w}.writeUint16(uint16(length))
0000000000000000000000000000000000000000;;		} else if int64(length) <= math.MaxUint32 {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 3)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:4], e.w}.writeUint32(uint32(length))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writen1(bd + 4)
0000000000000000000000000000000000000000;;			bigenHelper{e.b[:8], e.w}.writeUint64(uint64(length))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeExt(rv interface{}, xtag uint64, ext Ext, _ *Encoder) {
0000000000000000000000000000000000000000;;		bs := ext.WriteExt(rv)
0000000000000000000000000000000000000000;;		if bs == nil {
0000000000000000000000000000000000000000;;			e.EncodeNil()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.encodeExtPreamble(uint8(xtag), len(bs))
0000000000000000000000000000000000000000;;		e.w.writeb(bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeRawExt(re *RawExt, _ *Encoder) {
0000000000000000000000000000000000000000;;		e.encodeExtPreamble(uint8(re.Tag), len(re.Data))
0000000000000000000000000000000000000000;;		e.w.writeb(re.Data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) encodeExtPreamble(xtag byte, length int) {
0000000000000000000000000000000000000000;;		e.encLen(simpleVdExt, length)
0000000000000000000000000000000000000000;;		e.w.writen1(xtag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeArrayStart(length int) {
0000000000000000000000000000000000000000;;		e.encLen(simpleVdArray, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeMapStart(length int) {
0000000000000000000000000000000000000000;;		e.encLen(simpleVdMap, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeString(c charEncoding, v string) {
0000000000000000000000000000000000000000;;		e.encLen(simpleVdString, len(v))
0000000000000000000000000000000000000000;;		e.w.writestr(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeSymbol(v string) {
0000000000000000000000000000000000000000;;		e.EncodeString(c_UTF8, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) EncodeStringBytes(c charEncoding, v []byte) {
0000000000000000000000000000000000000000;;		e.encLen(simpleVdByteArray, len(v))
0000000000000000000000000000000000000000;;		e.w.writeb(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleDecDriver struct {
0000000000000000000000000000000000000000;;		d      *Decoder
0000000000000000000000000000000000000000;;		h      *SimpleHandle
0000000000000000000000000000000000000000;;		r      decReader
0000000000000000000000000000000000000000;;		bdRead bool
0000000000000000000000000000000000000000;;		bd     byte
0000000000000000000000000000000000000000;;		br     bool // bytes reader
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;		noStreamingCodec
0000000000000000000000000000000000000000;;		decNoSeparator
0000000000000000000000000000000000000000;;		b [scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) readNextBd() {
0000000000000000000000000000000000000000;;		d.bd = d.r.readn1()
0000000000000000000000000000000000000000;;		d.bdRead = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) uncacheRead() {
0000000000000000000000000000000000000000;;		if d.bdRead {
0000000000000000000000000000000000000000;;			d.r.unreadn1()
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) ContainerType() (vt valueType) {
0000000000000000000000000000000000000000;;		if d.bd == simpleVdNil {
0000000000000000000000000000000000000000;;			return valueTypeNil
0000000000000000000000000000000000000000;;		} else if d.bd == simpleVdByteArray || d.bd == simpleVdByteArray+1 ||
0000000000000000000000000000000000000000;;			d.bd == simpleVdByteArray+2 || d.bd == simpleVdByteArray+3 || d.bd == simpleVdByteArray+4 {
0000000000000000000000000000000000000000;;			return valueTypeBytes
0000000000000000000000000000000000000000;;		} else if d.bd == simpleVdString || d.bd == simpleVdString+1 ||
0000000000000000000000000000000000000000;;			d.bd == simpleVdString+2 || d.bd == simpleVdString+3 || d.bd == simpleVdString+4 {
0000000000000000000000000000000000000000;;			return valueTypeString
0000000000000000000000000000000000000000;;		} else if d.bd == simpleVdArray || d.bd == simpleVdArray+1 ||
0000000000000000000000000000000000000000;;			d.bd == simpleVdArray+2 || d.bd == simpleVdArray+3 || d.bd == simpleVdArray+4 {
0000000000000000000000000000000000000000;;			return valueTypeArray
0000000000000000000000000000000000000000;;		} else if d.bd == simpleVdMap || d.bd == simpleVdMap+1 ||
0000000000000000000000000000000000000000;;			d.bd == simpleVdMap+2 || d.bd == simpleVdMap+3 || d.bd == simpleVdMap+4 {
0000000000000000000000000000000000000000;;			return valueTypeMap
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// d.d.errorf("isContainerType: unsupported parameter: %v", vt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return valueTypeUnset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) TryDecodeAsNil() bool {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == simpleVdNil {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) decCheckInteger() (ui uint64, neg bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch d.bd {
0000000000000000000000000000000000000000;;		case simpleVdPosInt:
0000000000000000000000000000000000000000;;			ui = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;		case simpleVdPosInt + 1:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;		case simpleVdPosInt + 2:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;		case simpleVdPosInt + 3:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;		case simpleVdNegInt:
0000000000000000000000000000000000000000;;			ui = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;			neg = true
0000000000000000000000000000000000000000;;		case simpleVdNegInt + 1:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;			neg = true
0000000000000000000000000000000000000000;;		case simpleVdNegInt + 2:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;			neg = true
0000000000000000000000000000000000000000;;		case simpleVdNegInt + 3:
0000000000000000000000000000000000000000;;			ui = uint64(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;			neg = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.d.errorf("decIntAny: Integer only valid from pos/neg integer1..8. Invalid descriptor: %v", d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// don't do this check, because callers may only want the unsigned value.
0000000000000000000000000000000000000000;;		// if ui > math.MaxInt64 {
0000000000000000000000000000000000000000;;		// 	d.d.errorf("decIntAny: Integer out of range for signed int64: %v", ui)
0000000000000000000000000000000000000000;;		//		return
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeInt(bitsize uint8) (i int64) {
0000000000000000000000000000000000000000;;		ui, neg := d.decCheckInteger()
0000000000000000000000000000000000000000;;		i, overflow := chkOvf.SignedInt(ui)
0000000000000000000000000000000000000000;;		if overflow {
0000000000000000000000000000000000000000;;			d.d.errorf("simple: overflow converting %v to signed integer", ui)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if neg {
0000000000000000000000000000000000000000;;			i = -i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOvf.Int(i, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("simple: overflow integer: %v", i)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeUint(bitsize uint8) (ui uint64) {
0000000000000000000000000000000000000000;;		ui, neg := d.decCheckInteger()
0000000000000000000000000000000000000000;;		if neg {
0000000000000000000000000000000000000000;;			d.d.errorf("Assigning negative signed value to unsigned type")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOvf.Uint(ui, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("simple: overflow integer: %v", ui)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeFloat(chkOverflow32 bool) (f float64) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == simpleVdFloat32 {
0000000000000000000000000000000000000000;;			f = float64(math.Float32frombits(bigen.Uint32(d.r.readx(4))))
0000000000000000000000000000000000000000;;		} else if d.bd == simpleVdFloat64 {
0000000000000000000000000000000000000000;;			f = math.Float64frombits(bigen.Uint64(d.r.readx(8)))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if d.bd >= simpleVdPosInt && d.bd <= simpleVdNegInt+3 {
0000000000000000000000000000000000000000;;				f = float64(d.DecodeInt(64))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf("Float only valid from float32/64: Invalid descriptor: %v", d.bd)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOverflow32 && chkOvf.Float32(f) {
0000000000000000000000000000000000000000;;			d.d.errorf("msgpack: float32 overflow: %v", f)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bool can be decoded from bool only (single byte).
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeBool() (b bool) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == simpleVdTrue {
0000000000000000000000000000000000000000;;			b = true
0000000000000000000000000000000000000000;;		} else if d.bd == simpleVdFalse {
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid single-byte value for bool: %s: %x", msgBadDesc, d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) ReadMapStart() (length int) {
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return d.decLen()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) ReadArrayStart() (length int) {
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return d.decLen()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) decLen() int {
0000000000000000000000000000000000000000;;		switch d.bd % 8 {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return int(d.r.readn1())
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			return int(bigen.Uint16(d.r.readx(2)))
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			ui := uint64(bigen.Uint32(d.r.readx(4)))
0000000000000000000000000000000000000000;;			if chkOvf.Uint(ui, intBitsize) {
0000000000000000000000000000000000000000;;				d.d.errorf("simple: overflow integer: %v", ui)
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int(ui)
0000000000000000000000000000000000000000;;		case 4:
0000000000000000000000000000000000000000;;			ui := bigen.Uint64(d.r.readx(8))
0000000000000000000000000000000000000000;;			if chkOvf.Uint(ui, intBitsize) {
0000000000000000000000000000000000000000;;				d.d.errorf("simple: overflow integer: %v", ui)
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return int(ui)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.d.errorf("decLen: Cannot read length: bd%%8 must be in range 0..4. Got: %d", d.bd%8)
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeString() (s string) {
0000000000000000000000000000000000000000;;		return string(d.DecodeBytes(d.b[:], true, true))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeBytes(bs []byte, isstring, zerocopy bool) (bsOut []byte) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.bd == simpleVdNil {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		clen := d.decLen()
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		if zerocopy {
0000000000000000000000000000000000000000;;			if d.br {
0000000000000000000000000000000000000000;;				return d.r.readx(clen)
0000000000000000000000000000000000000000;;			} else if len(bs) == 0 {
0000000000000000000000000000000000000000;;				bs = d.b[:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return decByteSlice(d.r, clen, bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeExt(rv interface{}, xtag uint64, ext Ext) (realxtag uint64) {
0000000000000000000000000000000000000000;;		if xtag > 0xff {
0000000000000000000000000000000000000000;;			d.d.errorf("decodeExt: tag must be <= 0xff; got: %v", xtag)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		realxtag1, xbs := d.decodeExtV(ext != nil, uint8(xtag))
0000000000000000000000000000000000000000;;		realxtag = uint64(realxtag1)
0000000000000000000000000000000000000000;;		if ext == nil {
0000000000000000000000000000000000000000;;			re := rv.(*RawExt)
0000000000000000000000000000000000000000;;			re.Tag = realxtag
0000000000000000000000000000000000000000;;			re.Data = detachZeroCopyBytes(d.br, re.Data, xbs)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ext.ReadExt(rv, xbs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) decodeExtV(verifyTag bool, tag byte) (xtag byte, xbs []byte) {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch d.bd {
0000000000000000000000000000000000000000;;		case simpleVdExt, simpleVdExt + 1, simpleVdExt + 2, simpleVdExt + 3, simpleVdExt + 4:
0000000000000000000000000000000000000000;;			l := d.decLen()
0000000000000000000000000000000000000000;;			xtag = d.r.readn1()
0000000000000000000000000000000000000000;;			if verifyTag && xtag != tag {
0000000000000000000000000000000000000000;;				d.d.errorf("Wrong extension tag. Got %b. Expecting: %v", xtag, tag)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			xbs = d.r.readx(l)
0000000000000000000000000000000000000000;;		case simpleVdByteArray, simpleVdByteArray + 1, simpleVdByteArray + 2, simpleVdByteArray + 3, simpleVdByteArray + 4:
0000000000000000000000000000000000000000;;			xbs = d.DecodeBytes(nil, false, true)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.d.errorf("Invalid d.bd for extensions (Expecting extensions or byte array). Got: 0x%x", d.bd)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bdRead = false
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) DecodeNaked() {
0000000000000000000000000000000000000000;;		if !d.bdRead {
0000000000000000000000000000000000000000;;			d.readNextBd()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := &d.d.n
0000000000000000000000000000000000000000;;		var decodeFurther bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch d.bd {
0000000000000000000000000000000000000000;;		case simpleVdNil:
0000000000000000000000000000000000000000;;			n.v = valueTypeNil
0000000000000000000000000000000000000000;;		case simpleVdFalse:
0000000000000000000000000000000000000000;;			n.v = valueTypeBool
0000000000000000000000000000000000000000;;			n.b = false
0000000000000000000000000000000000000000;;		case simpleVdTrue:
0000000000000000000000000000000000000000;;			n.v = valueTypeBool
0000000000000000000000000000000000000000;;			n.b = true
0000000000000000000000000000000000000000;;		case simpleVdPosInt, simpleVdPosInt + 1, simpleVdPosInt + 2, simpleVdPosInt + 3:
0000000000000000000000000000000000000000;;			if d.h.SignedInteger {
0000000000000000000000000000000000000000;;				n.v = valueTypeInt
0000000000000000000000000000000000000000;;				n.i = d.DecodeInt(64)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n.v = valueTypeUint
0000000000000000000000000000000000000000;;				n.u = d.DecodeUint(64)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case simpleVdNegInt, simpleVdNegInt + 1, simpleVdNegInt + 2, simpleVdNegInt + 3:
0000000000000000000000000000000000000000;;			n.v = valueTypeInt
0000000000000000000000000000000000000000;;			n.i = d.DecodeInt(64)
0000000000000000000000000000000000000000;;		case simpleVdFloat32:
0000000000000000000000000000000000000000;;			n.v = valueTypeFloat
0000000000000000000000000000000000000000;;			n.f = d.DecodeFloat(true)
0000000000000000000000000000000000000000;;		case simpleVdFloat64:
0000000000000000000000000000000000000000;;			n.v = valueTypeFloat
0000000000000000000000000000000000000000;;			n.f = d.DecodeFloat(false)
0000000000000000000000000000000000000000;;		case simpleVdString, simpleVdString + 1, simpleVdString + 2, simpleVdString + 3, simpleVdString + 4:
0000000000000000000000000000000000000000;;			n.v = valueTypeString
0000000000000000000000000000000000000000;;			n.s = d.DecodeString()
0000000000000000000000000000000000000000;;		case simpleVdByteArray, simpleVdByteArray + 1, simpleVdByteArray + 2, simpleVdByteArray + 3, simpleVdByteArray + 4:
0000000000000000000000000000000000000000;;			n.v = valueTypeBytes
0000000000000000000000000000000000000000;;			n.l = d.DecodeBytes(nil, false, false)
0000000000000000000000000000000000000000;;		case simpleVdExt, simpleVdExt + 1, simpleVdExt + 2, simpleVdExt + 3, simpleVdExt + 4:
0000000000000000000000000000000000000000;;			n.v = valueTypeExt
0000000000000000000000000000000000000000;;			l := d.decLen()
0000000000000000000000000000000000000000;;			n.u = uint64(d.r.readn1())
0000000000000000000000000000000000000000;;			n.l = d.r.readx(l)
0000000000000000000000000000000000000000;;		case simpleVdArray, simpleVdArray + 1, simpleVdArray + 2, simpleVdArray + 3, simpleVdArray + 4:
0000000000000000000000000000000000000000;;			n.v = valueTypeArray
0000000000000000000000000000000000000000;;			decodeFurther = true
0000000000000000000000000000000000000000;;		case simpleVdMap, simpleVdMap + 1, simpleVdMap + 2, simpleVdMap + 3, simpleVdMap + 4:
0000000000000000000000000000000000000000;;			n.v = valueTypeMap
0000000000000000000000000000000000000000;;			decodeFurther = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.d.errorf("decodeNaked: Unrecognized d.bd: 0x%x", d.bd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !decodeFurther {
0000000000000000000000000000000000000000;;			d.bdRead = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SimpleHandle is a Handle for a very simple encoding format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// simple is a simplistic codec similar to binc, but not as compact.
0000000000000000000000000000000000000000;;	//   - Encoding of a value is always preceded by the descriptor byte (bd)
0000000000000000000000000000000000000000;;	//   - True, false, nil are encoded fully in 1 byte (the descriptor)
0000000000000000000000000000000000000000;;	//   - Integers (intXXX, uintXXX) are encoded in 1, 2, 4 or 8 bytes (plus a descriptor byte).
0000000000000000000000000000000000000000;;	//     There are positive (uintXXX and intXXX >= 0) and negative (intXXX < 0) integers.
0000000000000000000000000000000000000000;;	//   - Floats are encoded in 4 or 8 bytes (plus a descriptor byte)
0000000000000000000000000000000000000000;;	//   - Lenght of containers (strings, bytes, array, map, extensions)
0000000000000000000000000000000000000000;;	//     are encoded in 0, 1, 2, 4 or 8 bytes.
0000000000000000000000000000000000000000;;	//     Zero-length containers have no length encoded.
0000000000000000000000000000000000000000;;	//     For others, the number of bytes is given by pow(2, bd%3)
0000000000000000000000000000000000000000;;	//   - maps are encoded as [bd] [length] [[key][value]]...
0000000000000000000000000000000000000000;;	//   - arrays are encoded as [bd] [length] [value]...
0000000000000000000000000000000000000000;;	//   - extensions are encoded as [bd] [length] [tag] [byte]...
0000000000000000000000000000000000000000;;	//   - strings/bytearrays are encoded as [bd] [length] [byte]...
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The full spec will be published soon.
0000000000000000000000000000000000000000;;	type SimpleHandle struct {
0000000000000000000000000000000000000000;;		BasicHandle
0000000000000000000000000000000000000000;;		binaryEncodingType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *SimpleHandle) SetBytesExt(rt reflect.Type, tag uint64, ext BytesExt) (err error) {
0000000000000000000000000000000000000000;;		return h.SetExt(rt, tag, &setExtWrapper{b: ext})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *SimpleHandle) newEncDriver(e *Encoder) encDriver {
0000000000000000000000000000000000000000;;		return &simpleEncDriver{e: e, w: e.w, h: h}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *SimpleHandle) newDecDriver(d *Decoder) decDriver {
0000000000000000000000000000000000000000;;		return &simpleDecDriver{d: d, r: d.r, h: h, br: d.bytes}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *simpleEncDriver) reset() {
0000000000000000000000000000000000000000;;		e.w = e.e.w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *simpleDecDriver) reset() {
0000000000000000000000000000000000000000;;		d.r = d.d.r
0000000000000000000000000000000000000000;;		d.bd, d.bdRead = 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ decDriver = (*simpleDecDriver)(nil)
0000000000000000000000000000000000000000;;	var _ encDriver = (*simpleEncDriver)(nil)
