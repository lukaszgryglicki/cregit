0000000000000000000000000000000000000000;;	# Codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	High Performance, Feature-Rich Idiomatic Go codec/encoding library for
0000000000000000000000000000000000000000;;	binc, msgpack, cbor, json.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Supported Serialization formats are:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - msgpack: https://github.com/msgpack/msgpack
0000000000000000000000000000000000000000;;	  - binc:    http://github.com/ugorji/binc
0000000000000000000000000000000000000000;;	  - cbor:    http://cbor.io http://tools.ietf.org/html/rfc7049
0000000000000000000000000000000000000000;;	  - json:    http://json.org http://tools.ietf.org/html/rfc7159
0000000000000000000000000000000000000000;;	  - simple: 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To install:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    go get github.com/ugorji/go/codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This package understands the `unsafe` tag, to allow using unsafe semantics:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - When decoding into a struct, you need to read the field name as a string 
0000000000000000000000000000000000000000;;	    so you can find the struct field it is mapped to.
0000000000000000000000000000000000000000;;	    Using `unsafe` will bypass the allocation and copying overhead of `[]byte->string` conversion.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To use it, you must pass the `unsafe` tag during install:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	go install -tags=unsafe github.com/ugorji/go/codec 
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Online documentation: http://godoc.org/github.com/ugorji/go/codec  
0000000000000000000000000000000000000000;;	Detailed Usage/How-to Primer: http://ugorji.net/blog/go-codec-primer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The idiomatic Go support is as seen in other encoding packages in
0000000000000000000000000000000000000000;;	the standard library (ie json, xml, gob, etc).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Rich Feature Set includes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - Simple but extremely powerful and feature-rich API
0000000000000000000000000000000000000000;;	  - Very High Performance.
0000000000000000000000000000000000000000;;	    Our extensive benchmarks show us outperforming Gob, Json, Bson, etc by 2-4X.
0000000000000000000000000000000000000000;;	  - Multiple conversions:
0000000000000000000000000000000000000000;;	    Package coerces types where appropriate 
0000000000000000000000000000000000000000;;	    e.g. decode an int in the stream into a float, etc.
0000000000000000000000000000000000000000;;	  - Corner Cases: 
0000000000000000000000000000000000000000;;	    Overflows, nil maps/slices, nil values in streams are handled correctly
0000000000000000000000000000000000000000;;	  - Standard field renaming via tags
0000000000000000000000000000000000000000;;	  - Support for omitting empty fields during an encoding
0000000000000000000000000000000000000000;;	  - Encoding from any value and decoding into pointer to any value
0000000000000000000000000000000000000000;;	    (struct, slice, map, primitives, pointers, interface{}, etc)
0000000000000000000000000000000000000000;;	  - Extensions to support efficient encoding/decoding of any named types
0000000000000000000000000000000000000000;;	  - Support encoding.(Binary|Text)(M|Unm)arshaler interfaces
0000000000000000000000000000000000000000;;	  - Decoding without a schema (into a interface{}).
0000000000000000000000000000000000000000;;	    Includes Options to configure what specific map or slice type to use
0000000000000000000000000000000000000000;;	    when decoding an encoded list or map into a nil interface{}
0000000000000000000000000000000000000000;;	  - Encode a struct as an array, and decode struct from an array in the data stream
0000000000000000000000000000000000000000;;	  - Comprehensive support for anonymous fields
0000000000000000000000000000000000000000;;	  - Fast (no-reflection) encoding/decoding of common maps and slices
0000000000000000000000000000000000000000;;	  - Code-generation for faster performance.
0000000000000000000000000000000000000000;;	  - Support binary (e.g. messagepack, cbor) and text (e.g. json) formats
0000000000000000000000000000000000000000;;	  - Support indefinite-length formats to enable true streaming 
0000000000000000000000000000000000000000;;	    (for formats which support it e.g. json, cbor)
0000000000000000000000000000000000000000;;	  - Support canonical encoding, where a value is ALWAYS encoded as same sequence of bytes.
0000000000000000000000000000000000000000;;	    This mostly applies to maps, where iteration order is non-deterministic.
0000000000000000000000000000000000000000;;	  - NIL in data stream decoded as zero value
0000000000000000000000000000000000000000;;	  - Never silently skip data when decoding.
0000000000000000000000000000000000000000;;	    User decides whether to return an error or silently skip data when keys or indexes
0000000000000000000000000000000000000000;;	    in the data stream do not map to fields in the struct.
0000000000000000000000000000000000000000;;	  - Encode/Decode from/to chan types (for iterative streaming support)
0000000000000000000000000000000000000000;;	  - Drop-in replacement for encoding/json. `json:` key in struct tag supported.
0000000000000000000000000000000000000000;;	  - Provides a RPC Server and Client Codec for net/rpc communication protocol.
0000000000000000000000000000000000000000;;	  - Handle unique idiosyncrasies of codecs e.g. 
0000000000000000000000000000000000000000;;	    - For messagepack, configure how ambiguities in handling raw bytes are resolved 
0000000000000000000000000000000000000000;;	    - For messagepack, provide rpc server/client codec to support
0000000000000000000000000000000000000000;;	      msgpack-rpc protocol defined at:
0000000000000000000000000000000000000000;;	      https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Extension Support
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Users can register a function to handle the encoding or decoding of
0000000000000000000000000000000000000000;;	their custom types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are no restrictions on what the custom type can be. Some examples:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    type BisSet   []int
0000000000000000000000000000000000000000;;	    type BitSet64 uint64
0000000000000000000000000000000000000000;;	    type UUID     string
0000000000000000000000000000000000000000;;	    type MyStructWithUnexportedFields struct { a int; b bool; c []int; }
0000000000000000000000000000000000000000;;	    type GifImage struct { ... }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	As an illustration, MyStructWithUnexportedFields would normally be
0000000000000000000000000000000000000000;;	encoded as an empty map because it has no exported fields, while UUID
0000000000000000000000000000000000000000;;	would be encoded as a string. However, with extension support, you can
0000000000000000000000000000000000000000;;	encode any of these however you like.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## RPC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	RPC Client and Server Codecs are implemented, so the codecs can be used
0000000000000000000000000000000000000000;;	with the standard net/rpc package.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Typical usage model:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    // create and configure Handle
0000000000000000000000000000000000000000;;	    var (
0000000000000000000000000000000000000000;;	      bh codec.BincHandle
0000000000000000000000000000000000000000;;	      mh codec.MsgpackHandle
0000000000000000000000000000000000000000;;	      ch codec.CborHandle
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    mh.MapType = reflect.TypeOf(map[string]interface{}(nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    // configure extensions
0000000000000000000000000000000000000000;;	    // e.g. for msgpack, define functions and enable Time support for tag 1
0000000000000000000000000000000000000000;;	    // mh.SetExt(reflect.TypeOf(time.Time{}), 1, myExt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    // create and use decoder/encoder
0000000000000000000000000000000000000000;;	    var (
0000000000000000000000000000000000000000;;	      r io.Reader
0000000000000000000000000000000000000000;;	      w io.Writer
0000000000000000000000000000000000000000;;	      b []byte
0000000000000000000000000000000000000000;;	      h = &bh // or mh to use msgpack
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    dec = codec.NewDecoder(r, h)
0000000000000000000000000000000000000000;;	    dec = codec.NewDecoderBytes(b, h)
0000000000000000000000000000000000000000;;	    err = dec.Decode(&v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    enc = codec.NewEncoder(w, h)
0000000000000000000000000000000000000000;;	    enc = codec.NewEncoderBytes(&b, h)
0000000000000000000000000000000000000000;;	    err = enc.Encode(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    //RPC Server
0000000000000000000000000000000000000000;;	    go func() {
0000000000000000000000000000000000000000;;	        for {
0000000000000000000000000000000000000000;;	            conn, err := listener.Accept()
0000000000000000000000000000000000000000;;	            rpcCodec := codec.GoRpc.ServerCodec(conn, h)
0000000000000000000000000000000000000000;;	            //OR rpcCodec := codec.MsgpackSpecRpc.ServerCodec(conn, h)
0000000000000000000000000000000000000000;;	            rpc.ServeCodec(rpcCodec)
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	    }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    //RPC Communication (client side)
0000000000000000000000000000000000000000;;	    conn, err = net.Dial("tcp", "localhost:5555")
0000000000000000000000000000000000000000;;	    rpcCodec := codec.GoRpc.ClientCodec(conn, h)
0000000000000000000000000000000000000000;;	    //OR rpcCodec := codec.MsgpackSpecRpc.ClientCodec(conn, h)
0000000000000000000000000000000000000000;;	    client := rpc.NewClientWithCodec(rpcCodec)
0000000000000000000000000000000000000000;;	
