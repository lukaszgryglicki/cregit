0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/0doc.go[Godeps/_workspace/src/github.com/ugorji/go/codec/0doc.go][vendor/github.com/ugorji/go/codec/0doc.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	High Performance, Feature-Rich Idiomatic Go codec/encoding library for 
0000000000000000000000000000000000000000;;	binc, msgpack, cbor, json.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Supported Serialization formats are:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - msgpack: https://github.com/msgpack/msgpack
0000000000000000000000000000000000000000;;	  - binc:    http://github.com/ugorji/binc
0000000000000000000000000000000000000000;;	  - cbor:    http://cbor.io http://tools.ietf.org/html/rfc7049
0000000000000000000000000000000000000000;;	  - json:    http://json.org http://tools.ietf.org/html/rfc7159
0000000000000000000000000000000000000000;;	  - simple: 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To install:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    go get github.com/ugorji/go/codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This package understands the 'unsafe' tag, to allow using unsafe semantics:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - When decoding into a struct, you need to read the field name as a string 
0000000000000000000000000000000000000000;;	    so you can find the struct field it is mapped to.
0000000000000000000000000000000000000000;;	    Using `unsafe` will bypass the allocation and copying overhead of []byte->string conversion.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To install using unsafe, pass the 'unsafe' tag:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    go get -tags=unsafe github.com/ugorji/go/codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For detailed usage information, read the primer at http://ugorji.net/blog/go-codec-primer .
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The idiomatic Go support is as seen in other encoding packages in
0000000000000000000000000000000000000000;;	the standard library (ie json, xml, gob, etc).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Rich Feature Set includes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - Simple but extremely powerful and feature-rich API
0000000000000000000000000000000000000000;;	  - Very High Performance.
0000000000000000000000000000000000000000;;	    Our extensive benchmarks show us outperforming Gob, Json, Bson, etc by 2-4X.
0000000000000000000000000000000000000000;;	  - Multiple conversions:
0000000000000000000000000000000000000000;;	    Package coerces types where appropriate 
0000000000000000000000000000000000000000;;	    e.g. decode an int in the stream into a float, etc.
0000000000000000000000000000000000000000;;	  - Corner Cases: 
0000000000000000000000000000000000000000;;	    Overflows, nil maps/slices, nil values in streams are handled correctly
0000000000000000000000000000000000000000;;	  - Standard field renaming via tags
0000000000000000000000000000000000000000;;	  - Support for omitting empty fields during an encoding
0000000000000000000000000000000000000000;;	  - Encoding from any value and decoding into pointer to any value
0000000000000000000000000000000000000000;;	    (struct, slice, map, primitives, pointers, interface{}, etc)
0000000000000000000000000000000000000000;;	  - Extensions to support efficient encoding/decoding of any named types
0000000000000000000000000000000000000000;;	  - Support encoding.(Binary|Text)(M|Unm)arshaler interfaces
0000000000000000000000000000000000000000;;	  - Decoding without a schema (into a interface{}).
0000000000000000000000000000000000000000;;	    Includes Options to configure what specific map or slice type to use
0000000000000000000000000000000000000000;;	    when decoding an encoded list or map into a nil interface{}
0000000000000000000000000000000000000000;;	  - Encode a struct as an array, and decode struct from an array in the data stream
0000000000000000000000000000000000000000;;	  - Comprehensive support for anonymous fields
0000000000000000000000000000000000000000;;	  - Fast (no-reflection) encoding/decoding of common maps and slices
0000000000000000000000000000000000000000;;	  - Code-generation for faster performance.
0000000000000000000000000000000000000000;;	  - Support binary (e.g. messagepack, cbor) and text (e.g. json) formats
0000000000000000000000000000000000000000;;	  - Support indefinite-length formats to enable true streaming 
0000000000000000000000000000000000000000;;	    (for formats which support it e.g. json, cbor)
0000000000000000000000000000000000000000;;	  - Support canonical encoding, where a value is ALWAYS encoded as same sequence of bytes.
0000000000000000000000000000000000000000;;	    This mostly applies to maps, where iteration order is non-deterministic.
0000000000000000000000000000000000000000;;	  - NIL in data stream decoded as zero value
0000000000000000000000000000000000000000;;	  - Never silently skip data when decoding.
0000000000000000000000000000000000000000;;	    User decides whether to return an error or silently skip data when keys or indexes
0000000000000000000000000000000000000000;;	    in the data stream do not map to fields in the struct.
0000000000000000000000000000000000000000;;	  - Detect and error when encoding a cyclic reference (instead of stack overflow shutdown)
0000000000000000000000000000000000000000;;	  - Encode/Decode from/to chan types (for iterative streaming support)
0000000000000000000000000000000000000000;;	  - Drop-in replacement for encoding/json. `json:` key in struct tag supported.
0000000000000000000000000000000000000000;;	  - Provides a RPC Server and Client Codec for net/rpc communication protocol.
0000000000000000000000000000000000000000;;	  - Handle unique idiosyncrasies of codecs e.g. 
0000000000000000000000000000000000000000;;	    - For messagepack, configure how ambiguities in handling raw bytes are resolved 
0000000000000000000000000000000000000000;;	    - For messagepack, provide rpc server/client codec to support 
0000000000000000000000000000000000000000;;	      msgpack-rpc protocol defined at:
0000000000000000000000000000000000000000;;	      https://github.com/msgpack-rpc/msgpack-rpc/blob/master/spec.md
0000000000000000000000000000000000000000;;	  
0000000000000000000000000000000000000000;;	Extension Support
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Users can register a function to handle the encoding or decoding of
0000000000000000000000000000000000000000;;	their custom types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are no restrictions on what the custom type can be. Some examples:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    type BisSet   []int
0000000000000000000000000000000000000000;;	    type BitSet64 uint64
0000000000000000000000000000000000000000;;	    type UUID     string
0000000000000000000000000000000000000000;;	    type MyStructWithUnexportedFields struct { a int; b bool; c []int; }
0000000000000000000000000000000000000000;;	    type GifImage struct { ... }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	As an illustration, MyStructWithUnexportedFields would normally be
0000000000000000000000000000000000000000;;	encoded as an empty map because it has no exported fields, while UUID
0000000000000000000000000000000000000000;;	would be encoded as a string. However, with extension support, you can
0000000000000000000000000000000000000000;;	encode any of these however you like.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	RPC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	RPC Client and Server Codecs are implemented, so the codecs can be used
0000000000000000000000000000000000000000;;	with the standard net/rpc package.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The Handle is SAFE for concurrent READ, but NOT SAFE for concurrent modification.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The Encoder and Decoder are NOT safe for concurrent use.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Consequently, the usage model is basically:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    - Create and initialize the Handle before any use.
0000000000000000000000000000000000000000;;	      Once created, DO NOT modify it.
0000000000000000000000000000000000000000;;	    - Multiple Encoders or Decoders can now use the Handle concurrently.
0000000000000000000000000000000000000000;;	      They only read information off the Handle (never write).
0000000000000000000000000000000000000000;;	    - However, each Encoder or Decoder MUST not be used concurrently
0000000000000000000000000000000000000000;;	    - To re-use an Encoder/Decoder, call Reset(...) on it first.
0000000000000000000000000000000000000000;;	      This allows you use state maintained on the Encoder/Decoder.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Sample usage model:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    // create and configure Handle
0000000000000000000000000000000000000000;;	    var (
0000000000000000000000000000000000000000;;	      bh codec.BincHandle
0000000000000000000000000000000000000000;;	      mh codec.MsgpackHandle
0000000000000000000000000000000000000000;;	      ch codec.CborHandle
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    mh.MapType = reflect.TypeOf(map[string]interface{}(nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    // configure extensions
0000000000000000000000000000000000000000;;	    // e.g. for msgpack, define functions and enable Time support for tag 1
0000000000000000000000000000000000000000;;	    // mh.SetExt(reflect.TypeOf(time.Time{}), 1, myExt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    // create and use decoder/encoder
0000000000000000000000000000000000000000;;	    var (
0000000000000000000000000000000000000000;;	      r io.Reader
0000000000000000000000000000000000000000;;	      w io.Writer
0000000000000000000000000000000000000000;;	      b []byte
0000000000000000000000000000000000000000;;	      h = &bh // or mh to use msgpack
0000000000000000000000000000000000000000;;	    )
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    dec = codec.NewDecoder(r, h)
0000000000000000000000000000000000000000;;	    dec = codec.NewDecoderBytes(b, h)
0000000000000000000000000000000000000000;;	    err = dec.Decode(&v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    enc = codec.NewEncoder(w, h)
0000000000000000000000000000000000000000;;	    enc = codec.NewEncoderBytes(&b, h)
0000000000000000000000000000000000000000;;	    err = enc.Encode(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    //RPC Server
0000000000000000000000000000000000000000;;	    go func() {
0000000000000000000000000000000000000000;;	        for {
0000000000000000000000000000000000000000;;	            conn, err := listener.Accept()
0000000000000000000000000000000000000000;;	            rpcCodec := codec.GoRpc.ServerCodec(conn, h)
0000000000000000000000000000000000000000;;	            //OR rpcCodec := codec.MsgpackSpecRpc.ServerCodec(conn, h)
0000000000000000000000000000000000000000;;	            rpc.ServeCodec(rpcCodec)
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	    }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    //RPC Communication (client side)
0000000000000000000000000000000000000000;;	    conn, err = net.Dial("tcp", "localhost:5555")
0000000000000000000000000000000000000000;;	    rpcCodec := codec.GoRpc.ClientCodec(conn, h)
0000000000000000000000000000000000000000;;	    //OR rpcCodec := codec.MsgpackSpecRpc.ClientCodec(conn, h)
0000000000000000000000000000000000000000;;	    client := rpc.NewClientWithCodec(rpcCodec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Benefits of go-codec:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    - encoding/json always reads whole file into memory first.
0000000000000000000000000000000000000000;;	//      This makes it unsuitable for parsing very large files.
0000000000000000000000000000000000000000;;	//    - encoding/xml cannot parse into a map[string]interface{}
0000000000000000000000000000000000000000;;	//      I found this out on reading https://github.com/clbanning/mxj
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   - optimization for codecgen:
0000000000000000000000000000000000000000;;	//     if len of entity is <= 3 words, then support a value receiver for encode.
0000000000000000000000000000000000000000;;	//   - (En|De)coder should store an error when it occurs.
0000000000000000000000000000000000000000;;	//     Until reset, subsequent calls return that error that was stored.
0000000000000000000000000000000000000000;;	//     This means that free panics must go away.
0000000000000000000000000000000000000000;;	//     All errors must be raised through errorf method.
0000000000000000000000000000000000000000;;	//   - Decoding using a chan is good, but incurs concurrency costs.
0000000000000000000000000000000000000000;;	//     This is because there's no fast way to use a channel without it
0000000000000000000000000000000000000000;;	//     having to switch goroutines constantly.
0000000000000000000000000000000000000000;;	//     Callback pattern is still the best. Maybe consider supporting something like:
0000000000000000000000000000000000000000;;	//        type X struct {
0000000000000000000000000000000000000000;;	//             Name string
0000000000000000000000000000000000000000;;	//             Ys []Y
0000000000000000000000000000000000000000;;	//             Ys chan <- Y
0000000000000000000000000000000000000000;;	//             Ys func(Y) -> call this function for each entry
0000000000000000000000000000000000000000;;	//        }
0000000000000000000000000000000000000000;;	//    - Consider adding a isZeroer interface { isZero() bool }
0000000000000000000000000000000000000000;;	//      It is used within isEmpty, for omitEmpty support.
0000000000000000000000000000000000000000;;	//    - Consider making Handle used AS-IS within the encoding/decoding session.
0000000000000000000000000000000000000000;;	//      This means that we don't cache Handle information within the (En|De)coder,
0000000000000000000000000000000000000000;;	//      except we really need it at Reset(...)
0000000000000000000000000000000000000000;;	//    - Consider adding math/big support
0000000000000000000000000000000000000000;;	//    - Consider reducing the size of the generated functions:
0000000000000000000000000000000000000000;;	//      Maybe use one loop, and put the conditionals in the loop.
0000000000000000000000000000000000000000;;	//      for ... { if cLen > 0 { if j == cLen { break } } else if dd.CheckBreak() { break } }
