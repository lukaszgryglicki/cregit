0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/helper_internal.go[Godeps/_workspace/src/github.com/ugorji/go/codec/helper_internal.go][vendor/github.com/ugorji/go/codec/helper_internal.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All non-std package dependencies live in this file,
0000000000000000000000000000000000000000;;	// so porting to different environment is easy (just update functions).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func panicValToErr(panicVal interface{}, err *error) {
0000000000000000000000000000000000000000;;		if panicVal == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// case nil
0000000000000000000000000000000000000000;;		switch xerr := panicVal.(type) {
0000000000000000000000000000000000000000;;		case error:
0000000000000000000000000000000000000000;;			*err = xerr
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			*err = errors.New(xerr)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			*err = fmt.Errorf("%v", panicVal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hIsEmptyValue(v reflect.Value, deref, checkStruct bool) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Invalid:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;			if deref {
0000000000000000000000000000000000000000;;				if v.IsNil() {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return hIsEmptyValue(v.Elem(), deref, checkStruct)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return v.IsNil()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if !checkStruct {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// return true if all fields are empty. else return false.
0000000000000000000000000000000000000000;;			// we cannot use equality check, because some fields may be maps/slices/etc
0000000000000000000000000000000000000000;;			// and consequently the structs are not comparable.
0000000000000000000000000000000000000000;;			// return v.Interface() == reflect.Zero(v.Type()).Interface()
0000000000000000000000000000000000000000;;			for i, n := 0, v.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;				if !hIsEmptyValue(v.Field(i), deref, checkStruct) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEmptyValue(v reflect.Value, deref, checkStruct bool) bool {
0000000000000000000000000000000000000000;;		return hIsEmptyValue(v, deref, checkStruct)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pruneSignExt(v []byte, pos bool) (n int) {
0000000000000000000000000000000000000000;;		if len(v) < 2 {
0000000000000000000000000000000000000000;;		} else if pos && v[0] == 0 {
0000000000000000000000000000000000000000;;			for ; v[n] == 0 && n+1 < len(v) && (v[n+1]&(1<<7) == 0); n++ {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if !pos && v[0] == 0xff {
0000000000000000000000000000000000000000;;			for ; v[n] == 0xff && n+1 < len(v) && (v[n+1]&(1<<7) != 0); n++ {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func implementsIntf(typ, iTyp reflect.Type) (success bool, indir int8) {
0000000000000000000000000000000000000000;;		if typ == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rt := typ
0000000000000000000000000000000000000000;;		// The type might be a pointer and we need to keep
0000000000000000000000000000000000000000;;		// dereferencing to the base type until we find an implementation.
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if rt.Implements(iTyp) {
0000000000000000000000000000000000000000;;				return true, indir
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p := rt; p.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				indir++
0000000000000000000000000000000000000000;;				if indir >= math.MaxInt8 { // insane number of indirections
0000000000000000000000000000000000000000;;					return false, 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rt = p.Elem()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// No luck yet, but if this is a base type (non-pointer), the pointer might satisfy.
0000000000000000000000000000000000000000;;		if typ.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			// Not a pointer, but does the pointer work?
0000000000000000000000000000000000000000;;			if reflect.PtrTo(typ).Implements(iTyp) {
0000000000000000000000000000000000000000;;				return true, -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validate that this function is correct ...
0000000000000000000000000000000000000000;;	// culled from OGRE (Object-Oriented Graphics Rendering Engine)
0000000000000000000000000000000000000000;;	// function: halfToFloatI (http://stderr.org/doc/ogre-doc/api/OgreBitwise_8h-source.html)
0000000000000000000000000000000000000000;;	func halfFloatToFloatBits(yy uint16) (d uint32) {
0000000000000000000000000000000000000000;;		y := uint32(yy)
0000000000000000000000000000000000000000;;		s := (y >> 15) & 0x01
0000000000000000000000000000000000000000;;		e := (y >> 10) & 0x1f
0000000000000000000000000000000000000000;;		m := y & 0x03ff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e == 0 {
0000000000000000000000000000000000000000;;			if m == 0 { // plu or minus 0
0000000000000000000000000000000000000000;;				return s << 31
0000000000000000000000000000000000000000;;			} else { // Denormalized number -- renormalize it
0000000000000000000000000000000000000000;;				for (m & 0x00000400) == 0 {
0000000000000000000000000000000000000000;;					m <<= 1
0000000000000000000000000000000000000000;;					e -= 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				e += 1
0000000000000000000000000000000000000000;;				const zz uint32 = 0x0400
0000000000000000000000000000000000000000;;				m &= ^zz
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if e == 31 {
0000000000000000000000000000000000000000;;			if m == 0 { // Inf
0000000000000000000000000000000000000000;;				return (s << 31) | 0x7f800000
0000000000000000000000000000000000000000;;			} else { // NaN
0000000000000000000000000000000000000000;;				return (s << 31) | 0x7f800000 | (m << 13)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e = e + (127 - 15)
0000000000000000000000000000000000000000;;		m = m << 13
0000000000000000000000000000000000000000;;		return (s << 31) | (e << 23) | m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GrowCap will return a new capacity for a slice, given the following:
0000000000000000000000000000000000000000;;	//   - oldCap: current capacity
0000000000000000000000000000000000000000;;	//   - unit: in-memory size of an element
0000000000000000000000000000000000000000;;	//   - num: number of elements to add
0000000000000000000000000000000000000000;;	func growCap(oldCap, unit, num int) (newCap int) {
0000000000000000000000000000000000000000;;		// appendslice logic (if cap < 1024, *2, else *1.25):
0000000000000000000000000000000000000000;;		//   leads to many copy calls, especially when copying bytes.
0000000000000000000000000000000000000000;;		//   bytes.Buffer model (2*cap + n): much better for bytes.
0000000000000000000000000000000000000000;;		// smarter way is to take the byte-size of the appended element(type) into account
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// maintain 3 thresholds:
0000000000000000000000000000000000000000;;		// t1: if cap <= t1, newcap = 2x
0000000000000000000000000000000000000000;;		// t2: if cap <= t2, newcap = 1.75x
0000000000000000000000000000000000000000;;		// t3: if cap <= t3, newcap = 1.5x
0000000000000000000000000000000000000000;;		//     else          newcap = 1.25x
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// t1, t2, t3 >= 1024 always.
0000000000000000000000000000000000000000;;		// i.e. if unit size >= 16, then always do 2x or 1.25x (ie t1, t2, t3 are all same)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// With this, appending for bytes increase by:
0000000000000000000000000000000000000000;;		//    100% up to 4K
0000000000000000000000000000000000000000;;		//     75% up to 8K
0000000000000000000000000000000000000000;;		//     50% up to 16K
0000000000000000000000000000000000000000;;		//     25% beyond that
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// unit can be 0 e.g. for struct{}{}; handle that appropriately
0000000000000000000000000000000000000000;;		var t1, t2, t3 int // thresholds
0000000000000000000000000000000000000000;;		if unit <= 1 {
0000000000000000000000000000000000000000;;			t1, t2, t3 = 4*1024, 8*1024, 16*1024
0000000000000000000000000000000000000000;;		} else if unit < 16 {
0000000000000000000000000000000000000000;;			t3 = 16 / unit * 1024
0000000000000000000000000000000000000000;;			t1 = t3 * 1 / 4
0000000000000000000000000000000000000000;;			t2 = t3 * 2 / 4
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t1, t2, t3 = 1024, 1024, 1024
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var x int // temporary variable
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// x is multiplier here: one of 5, 6, 7 or 8; incr of 25%, 50%, 75% or 100% respectively
0000000000000000000000000000000000000000;;		if oldCap <= t1 { // [0,t1]
0000000000000000000000000000000000000000;;			x = 8
0000000000000000000000000000000000000000;;		} else if oldCap > t3 { // (t3,infinity]
0000000000000000000000000000000000000000;;			x = 5
0000000000000000000000000000000000000000;;		} else if oldCap <= t2 { // (t1,t2]
0000000000000000000000000000000000000000;;			x = 7
0000000000000000000000000000000000000000;;		} else { // (t2,t3]
0000000000000000000000000000000000000000;;			x = 6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newCap = x * oldCap / 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if num > 0 {
0000000000000000000000000000000000000000;;			newCap += num
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ensure newCap is a multiple of 64 (if it is > 64) or 16.
0000000000000000000000000000000000000000;;		if newCap > 64 {
0000000000000000000000000000000000000000;;			if x = newCap % 64; x != 0 {
0000000000000000000000000000000000000000;;				x = newCap / 64
0000000000000000000000000000000000000000;;				newCap = 64 * (x + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if x = newCap % 16; x != 0 {
0000000000000000000000000000000000000000;;				x = newCap / 16
0000000000000000000000000000000000000000;;				newCap = 16 * (x + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandSliceValue(s reflect.Value, num int) reflect.Value {
0000000000000000000000000000000000000000;;		if num <= 0 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l0 := s.Len()
0000000000000000000000000000000000000000;;		l1 := l0 + num // new slice length
0000000000000000000000000000000000000000;;		if l1 < l0 {
0000000000000000000000000000000000000000;;			panic("ExpandSlice: slice overflow")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c0 := s.Cap()
0000000000000000000000000000000000000000;;		if l1 <= c0 {
0000000000000000000000000000000000000000;;			return s.Slice(0, l1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		st := s.Type()
0000000000000000000000000000000000000000;;		c1 := growCap(c0, int(st.Elem().Size()), num)
0000000000000000000000000000000000000000;;		s2 := reflect.MakeSlice(st, l1, c1)
0000000000000000000000000000000000000000;;		// println("expandslicevalue: cap-old: ", c0, ", cap-new: ", c1, ", len-new: ", l1)
0000000000000000000000000000000000000000;;		reflect.Copy(s2, s)
0000000000000000000000000000000000000000;;		return s2
0000000000000000000000000000000000000000;;	}
