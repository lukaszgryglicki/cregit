0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/gen.go[Godeps/_workspace/src/github.com/ugorji/go/codec/gen.go][vendor/github.com/ugorji/go/codec/gen.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/format"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ---------------------------------------------------
0000000000000000000000000000000000000000;;	// codecgen supports the full cycle of reflection-based codec:
0000000000000000000000000000000000000000;;	//    - RawExt
0000000000000000000000000000000000000000;;	//    - Raw
0000000000000000000000000000000000000000;;	//    - Builtins
0000000000000000000000000000000000000000;;	//    - Extensions
0000000000000000000000000000000000000000;;	//    - (Binary|Text|JSON)(Unm|M)arshal
0000000000000000000000000000000000000000;;	//    - generic by-kind
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This means that, for dynamic things, we MUST use reflection to at least get the reflect.Type.
0000000000000000000000000000000000000000;;	// In those areas, we try to only do reflection or interface-conversion when NECESSARY:
0000000000000000000000000000000000000000;;	//    - Extensions, only if Extensions are configured.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// However, codecgen doesn't support the following:
0000000000000000000000000000000000000000;;	//   - Canonical option. (codecgen IGNORES it currently)
0000000000000000000000000000000000000000;;	//     This is just because it has not been implemented.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// During encode/decode, Selfer takes precedence.
0000000000000000000000000000000000000000;;	// A type implementing Selfer will know how to encode/decode itself statically.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following field types are supported:
0000000000000000000000000000000000000000;;	//     array: [n]T
0000000000000000000000000000000000000000;;	//     slice: []T
0000000000000000000000000000000000000000;;	//     map: map[K]V
0000000000000000000000000000000000000000;;	//     primitive: [u]int[n], float(32|64), bool, string
0000000000000000000000000000000000000000;;	//     struct
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ---------------------------------------------------
0000000000000000000000000000000000000000;;	// Note that a Selfer cannot call (e|d).(En|De)code on itself,
0000000000000000000000000000000000000000;;	// as this will cause a circular reference, as (En|De)code will call Selfer methods.
0000000000000000000000000000000000000000;;	// Any type that implements Selfer must implement completely and not fallback to (En|De)code.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In addition, code in this file manages the generation of fast-path implementations of
0000000000000000000000000000000000000000;;	// encode/decode of slices/maps of primitive keys/values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Users MUST re-generate their implementations whenever the code shape changes.
0000000000000000000000000000000000000000;;	// The generated code will panic if it was generated with a version older than the supporting library.
0000000000000000000000000000000000000000;;	// ---------------------------------------------------
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// codec framework is very feature rich.
0000000000000000000000000000000000000000;;	// When encoding or decoding into an interface, it depends on the runtime type of the interface.
0000000000000000000000000000000000000000;;	// The type of the interface may be a named type, an extension, etc.
0000000000000000000000000000000000000000;;	// Consequently, we fallback to runtime codec for encoding/decoding interfaces.
0000000000000000000000000000000000000000;;	// In addition, we fallback for any value which cannot be guaranteed at runtime.
0000000000000000000000000000000000000000;;	// This allows us support ANY value, including any named types, specifically those which
0000000000000000000000000000000000000000;;	// do not implement our interfaces (e.g. Selfer).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This explains some slowness compared to other code generation codecs (e.g. msgp).
0000000000000000000000000000000000000000;;	// This reduction in speed is only seen when your refers to interfaces,
0000000000000000000000000000000000000000;;	// e.g. type T struct { A interface{}; B []interface{}; C map[string]interface{} }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// codecgen will panic if the file was generated with an old version of the library in use.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	//   It was a conscious decision to have gen.go always explicitly call EncodeNil or TryDecodeAsNil.
0000000000000000000000000000000000000000;;	//   This way, there isn't a function call overhead just to see that we should not enter a block of code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenVersion is the current version of codecgen.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Increment this value each time codecgen changes fundamentally.
0000000000000000000000000000000000000000;;	// Fundamental changes are:
0000000000000000000000000000000000000000;;	//   - helper methods change (signature change, new ones added, some removed, etc)
0000000000000000000000000000000000000000;;	//   - codecgen command line changes
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// v1: Initial Version
0000000000000000000000000000000000000000;;	// v2:
0000000000000000000000000000000000000000;;	// v3: Changes for Kubernetes:
0000000000000000000000000000000000000000;;	//     changes in signature of some unpublished helper methods and codecgen cmdline arguments.
0000000000000000000000000000000000000000;;	// v4: Removed separator support from (en|de)cDriver, and refactored codec(gen)
0000000000000000000000000000000000000000;;	// v5: changes to support faster json decoding. Let encoder/decoder maintain state of collections.
0000000000000000000000000000000000000000;;	const GenVersion = 5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		genCodecPkg        = "codec1978"
0000000000000000000000000000000000000000;;		genTempVarPfx      = "yy"
0000000000000000000000000000000000000000;;		genTopLevelVarName = "x"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ignore canBeNil parameter, and always set to true.
0000000000000000000000000000000000000000;;		// This is because nil can appear anywhere, so we should always check.
0000000000000000000000000000000000000000;;		genAnythingCanBeNil = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if genUseOneFunctionForDecStructMap, make a single codecDecodeSelferFromMap function;
0000000000000000000000000000000000000000;;		// else make codecDecodeSelferFromMap{LenPrefix,CheckBreak} so that conditionals
0000000000000000000000000000000000000000;;		// are not executed a lot.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// From testing, it didn't make much difference in runtime, so keep as true (one function only)
0000000000000000000000000000000000000000;;		genUseOneFunctionForDecStructMap = true
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genStructMapStyle uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		genStructMapStyleConsolidated genStructMapStyle = iota
0000000000000000000000000000000000000000;;		genStructMapStyleLenPrefix
0000000000000000000000000000000000000000;;		genStructMapStyleCheckBreak
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		genAllTypesSamePkgErr  = errors.New("All types must be in the same package")
0000000000000000000000000000000000000000;;		genExpectArrayOrMapErr = errors.New("unexpected type. Expecting array/map/slice")
0000000000000000000000000000000000000000;;		genBase64enc           = base64.NewEncoding("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789__")
0000000000000000000000000000000000000000;;		genQNameRegex          = regexp.MustCompile(`[A-Za-z_.]+`)
0000000000000000000000000000000000000000;;		genCheckVendor         bool
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genRunner holds some state used during a Gen run.
0000000000000000000000000000000000000000;;	type genRunner struct {
0000000000000000000000000000000000000000;;		w io.Writer      // output
0000000000000000000000000000000000000000;;		c uint64         // counter used for generating varsfx
0000000000000000000000000000000000000000;;		t []reflect.Type // list of types to run selfer on
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tc reflect.Type     // currently running selfer on this type
0000000000000000000000000000000000000000;;		te map[uintptr]bool // types for which the encoder has been created
0000000000000000000000000000000000000000;;		td map[uintptr]bool // types for which the decoder has been created
0000000000000000000000000000000000000000;;		cp string           // codec import path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		im  map[string]reflect.Type // imports to add
0000000000000000000000000000000000000000;;		imn map[string]string       // package names of imports to add
0000000000000000000000000000000000000000;;		imc uint64                  // counter for import numbers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		is map[reflect.Type]struct{} // types seen during import search
0000000000000000000000000000000000000000;;		bp string                    // base PkgPath, for which we are generating for
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpfx   string // codec package prefix
0000000000000000000000000000000000000000;;		unsafe bool   // is unsafe to be used in generated code?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tm map[reflect.Type]struct{} // types for which enc/dec must be generated
0000000000000000000000000000000000000000;;		ts []reflect.Type            // types for which enc/dec must be generated
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xs string // top level variable/constant suffix
0000000000000000000000000000000000000000;;		hn string // fn helper type name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ti *TypeInfos
0000000000000000000000000000000000000000;;		// rr *rand.Rand // random generator for file-specific types
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gen will write a complete go file containing Selfer implementations for each
0000000000000000000000000000000000000000;;	// type passed. All the types must be in the same package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Library users: *DO NOT USE IT DIRECTLY. IT WILL CHANGE CONTINOUSLY WITHOUT NOTICE.*
0000000000000000000000000000000000000000;;	func Gen(w io.Writer, buildTags, pkgName, uid string, useUnsafe bool, ti *TypeInfos, typ ...reflect.Type) {
0000000000000000000000000000000000000000;;		// All types passed to this method do not have a codec.Selfer method implemented directly.
0000000000000000000000000000000000000000;;		// codecgen already checks the AST and skips any types that define the codec.Selfer methods.
0000000000000000000000000000000000000000;;		// Consequently, there's no need to check and trim them if they implement codec.Selfer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(typ) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := genRunner{
0000000000000000000000000000000000000000;;			unsafe: useUnsafe,
0000000000000000000000000000000000000000;;			w:      w,
0000000000000000000000000000000000000000;;			t:      typ,
0000000000000000000000000000000000000000;;			te:     make(map[uintptr]bool),
0000000000000000000000000000000000000000;;			td:     make(map[uintptr]bool),
0000000000000000000000000000000000000000;;			im:     make(map[string]reflect.Type),
0000000000000000000000000000000000000000;;			imn:    make(map[string]string),
0000000000000000000000000000000000000000;;			is:     make(map[reflect.Type]struct{}),
0000000000000000000000000000000000000000;;			tm:     make(map[reflect.Type]struct{}),
0000000000000000000000000000000000000000;;			ts:     []reflect.Type{},
0000000000000000000000000000000000000000;;			bp:     genImportPath(typ[0]),
0000000000000000000000000000000000000000;;			xs:     uid,
0000000000000000000000000000000000000000;;			ti:     ti,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x.ti == nil {
0000000000000000000000000000000000000000;;			x.ti = defTypeInfos
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x.xs == "" {
0000000000000000000000000000000000000000;;			rr := rand.New(rand.NewSource(time.Now().UnixNano()))
0000000000000000000000000000000000000000;;			x.xs = strconv.FormatInt(rr.Int63n(9999), 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// gather imports first:
0000000000000000000000000000000000000000;;		x.cp = genImportPath(reflect.TypeOf(x))
0000000000000000000000000000000000000000;;		x.imn[x.cp] = genCodecPkg
0000000000000000000000000000000000000000;;		for _, t := range typ {
0000000000000000000000000000000000000000;;			// fmt.Printf("###########: PkgPath: '%v', Name: '%s'\n", genImportPath(t), t.Name())
0000000000000000000000000000000000000000;;			if genImportPath(t) != x.bp {
0000000000000000000000000000000000000000;;				panic(genAllTypesSamePkgErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.genRefPkgs(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buildTags != "" {
0000000000000000000000000000000000000000;;			x.line("// +build " + buildTags)
0000000000000000000000000000000000000000;;			x.line("")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line(`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ************************************************************
0000000000000000000000000000000000000000;;	// DO NOT EDIT.
0000000000000000000000000000000000000000;;	// THIS FILE IS AUTO-GENERATED BY codecgen.
0000000000000000000000000000000000000000;;	// ************************************************************
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		x.line("package " + pkgName)
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;		x.line("import (")
0000000000000000000000000000000000000000;;		if x.cp != x.bp {
0000000000000000000000000000000000000000;;			x.cpfx = genCodecPkg + "."
0000000000000000000000000000000000000000;;			x.linef("%s \"%s\"", genCodecPkg, x.cp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// use a sorted set of im keys, so that we can get consistent output
0000000000000000000000000000000000000000;;		imKeys := make([]string, 0, len(x.im))
0000000000000000000000000000000000000000;;		for k, _ := range x.im {
0000000000000000000000000000000000000000;;			imKeys = append(imKeys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(imKeys)
0000000000000000000000000000000000000000;;		for _, k := range imKeys { // for k, _ := range x.im {
0000000000000000000000000000000000000000;;			x.linef("%s \"%s\"", x.imn[k], k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// add required packages
0000000000000000000000000000000000000000;;		for _, k := range [...]string{"reflect", "unsafe", "runtime", "fmt", "errors"} {
0000000000000000000000000000000000000000;;			if _, ok := x.im[k]; !ok {
0000000000000000000000000000000000000000;;				if k == "unsafe" && !x.unsafe {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				x.line("\"" + k + "\"")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line(")")
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.line("const (")
0000000000000000000000000000000000000000;;		x.linef("// ----- content types ----")
0000000000000000000000000000000000000000;;		x.linef("codecSelferC_UTF8%s = %v", x.xs, int64(c_UTF8))
0000000000000000000000000000000000000000;;		x.linef("codecSelferC_RAW%s = %v", x.xs, int64(c_RAW))
0000000000000000000000000000000000000000;;		x.linef("// ----- value types used ----")
0000000000000000000000000000000000000000;;		x.linef("codecSelferValueTypeArray%s = %v", x.xs, int64(valueTypeArray))
0000000000000000000000000000000000000000;;		x.linef("codecSelferValueTypeMap%s = %v", x.xs, int64(valueTypeMap))
0000000000000000000000000000000000000000;;		x.linef("// ----- containerStateValues ----")
0000000000000000000000000000000000000000;;		x.linef("codecSelfer_containerMapKey%s = %v", x.xs, int64(containerMapKey))
0000000000000000000000000000000000000000;;		x.linef("codecSelfer_containerMapValue%s = %v", x.xs, int64(containerMapValue))
0000000000000000000000000000000000000000;;		x.linef("codecSelfer_containerMapEnd%s = %v", x.xs, int64(containerMapEnd))
0000000000000000000000000000000000000000;;		x.linef("codecSelfer_containerArrayElem%s = %v", x.xs, int64(containerArrayElem))
0000000000000000000000000000000000000000;;		x.linef("codecSelfer_containerArrayEnd%s = %v", x.xs, int64(containerArrayEnd))
0000000000000000000000000000000000000000;;		x.line(")")
0000000000000000000000000000000000000000;;		x.line("var (")
0000000000000000000000000000000000000000;;		x.line("codecSelferBitsize" + x.xs + " = uint8(reflect.TypeOf(uint(0)).Bits())")
0000000000000000000000000000000000000000;;		x.line("codecSelferOnlyMapOrArrayEncodeToStructErr" + x.xs + " = errors.New(`only encoded map or array can be decoded into a struct`)")
0000000000000000000000000000000000000000;;		x.line(")")
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if x.unsafe {
0000000000000000000000000000000000000000;;			x.line("type codecSelferUnsafeString" + x.xs + " struct { Data uintptr; Len int}")
0000000000000000000000000000000000000000;;			x.line("")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.hn = "codecSelfer" + x.xs
0000000000000000000000000000000000000000;;		x.line("type " + x.hn + " struct{}")
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.varsfxreset()
0000000000000000000000000000000000000000;;		x.line("func init() {")
0000000000000000000000000000000000000000;;		x.linef("if %sGenVersion != %v {", x.cpfx, GenVersion)
0000000000000000000000000000000000000000;;		x.line("_, file, _, _ := runtime.Caller(0)")
0000000000000000000000000000000000000000;;		x.line(`err := fmt.Errorf("codecgen version mismatch: current: %v, need %v. Re-generate file: %v", `)
0000000000000000000000000000000000000000;;		x.linef(`%v, %sGenVersion, file)`, GenVersion, x.cpfx)
0000000000000000000000000000000000000000;;		x.line("panic(err)")
0000000000000000000000000000000000000000;;		x.linef("}")
0000000000000000000000000000000000000000;;		x.line("if false { // reference the types, but skip this branch at build/run time")
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		// for k, t := range x.im {
0000000000000000000000000000000000000000;;		for _, k := range imKeys {
0000000000000000000000000000000000000000;;			t := x.im[k]
0000000000000000000000000000000000000000;;			x.linef("var v%v %s.%s", n, x.imn[k], t.Name())
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x.unsafe {
0000000000000000000000000000000000000000;;			x.linef("var v%v unsafe.Pointer", n)
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			x.out("_")
0000000000000000000000000000000000000000;;			for i := 1; i < n; i++ {
0000000000000000000000000000000000000000;;				x.out(", _")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.out(" = v0")
0000000000000000000000000000000000000000;;			for i := 1; i < n; i++ {
0000000000000000000000000000000000000000;;				x.outf(", v%v", i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line("} ") // close if false
0000000000000000000000000000000000000000;;		x.line("}")  // close init
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// generate rest of type info
0000000000000000000000000000000000000000;;		for _, t := range typ {
0000000000000000000000000000000000000000;;			x.tc = t
0000000000000000000000000000000000000000;;			x.selfer(true)
0000000000000000000000000000000000000000;;			x.selfer(false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, t := range x.ts {
0000000000000000000000000000000000000000;;			rtid := reflect.ValueOf(t).Pointer()
0000000000000000000000000000000000000000;;			// generate enc functions for all these slice/map types.
0000000000000000000000000000000000000000;;			x.varsfxreset()
0000000000000000000000000000000000000000;;			x.linef("func (x %s) enc%s(v %s%s, e *%sEncoder) {", x.hn, x.genMethodNameT(t), x.arr2str(t, "*"), x.genTypeName(t), x.cpfx)
0000000000000000000000000000000000000000;;			x.genRequiredMethodVars(true)
0000000000000000000000000000000000000000;;			switch t.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Array, reflect.Slice, reflect.Chan:
0000000000000000000000000000000000000000;;				x.encListFallback("v", t)
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				x.encMapFallback("v", t)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(genExpectArrayOrMapErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.line("}")
0000000000000000000000000000000000000000;;			x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// generate dec functions for all these slice/map types.
0000000000000000000000000000000000000000;;			x.varsfxreset()
0000000000000000000000000000000000000000;;			x.linef("func (x %s) dec%s(v *%s, d *%sDecoder) {", x.hn, x.genMethodNameT(t), x.genTypeName(t), x.cpfx)
0000000000000000000000000000000000000000;;			x.genRequiredMethodVars(false)
0000000000000000000000000000000000000000;;			switch t.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Array, reflect.Slice, reflect.Chan:
0000000000000000000000000000000000000000;;				x.decListFallback("v", rtid, t)
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;				x.decMapFallback("v", rtid, t)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(genExpectArrayOrMapErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.line("}")
0000000000000000000000000000000000000000;;			x.line("")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) checkForSelfer(t reflect.Type, varname string) bool {
0000000000000000000000000000000000000000;;		// return varname != genTopLevelVarName && t != x.tc
0000000000000000000000000000000000000000;;		// the only time we checkForSelfer is if we are not at the TOP of the generated code.
0000000000000000000000000000000000000000;;		return varname != genTopLevelVarName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) arr2str(t reflect.Type, s string) string {
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Array {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) genRequiredMethodVars(encode bool) {
0000000000000000000000000000000000000000;;		x.line("var h " + x.hn)
0000000000000000000000000000000000000000;;		if encode {
0000000000000000000000000000000000000000;;			x.line("z, r := " + x.cpfx + "GenHelperEncoder(e)")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.line("z, r := " + x.cpfx + "GenHelperDecoder(d)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line("_, _, _ = h, z, r")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) genRefPkgs(t reflect.Type) {
0000000000000000000000000000000000000000;;		if _, ok := x.is[t]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// fmt.Printf(">>>>>>: PkgPath: '%v', Name: '%s'\n", genImportPath(t), t.Name())
0000000000000000000000000000000000000000;;		x.is[t] = struct{}{}
0000000000000000000000000000000000000000;;		tpkg, tname := genImportPath(t), t.Name()
0000000000000000000000000000000000000000;;		if tpkg != "" && tpkg != x.bp && tpkg != x.cp && tname != "" && tname[0] >= 'A' && tname[0] <= 'Z' {
0000000000000000000000000000000000000000;;			if _, ok := x.im[tpkg]; !ok {
0000000000000000000000000000000000000000;;				x.im[tpkg] = t
0000000000000000000000000000000000000000;;				if idx := strings.LastIndex(tpkg, "/"); idx < 0 {
0000000000000000000000000000000000000000;;					x.imn[tpkg] = tpkg
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					x.imc++
0000000000000000000000000000000000000000;;					x.imn[tpkg] = "pkg" + strconv.FormatUint(x.imc, 10) + "_" + genGoIdentifier(tpkg[idx+1:], false)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Slice, reflect.Ptr, reflect.Chan:
0000000000000000000000000000000000000000;;			x.genRefPkgs(t.Elem())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			x.genRefPkgs(t.Elem())
0000000000000000000000000000000000000000;;			x.genRefPkgs(t.Key())
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;				if fname := t.Field(i).Name; fname != "" && fname[0] >= 'A' && fname[0] <= 'Z' {
0000000000000000000000000000000000000000;;					x.genRefPkgs(t.Field(i).Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) line(s string) {
0000000000000000000000000000000000000000;;		x.out(s)
0000000000000000000000000000000000000000;;		if len(s) == 0 || s[len(s)-1] != '\n' {
0000000000000000000000000000000000000000;;			x.out("\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) varsfx() string {
0000000000000000000000000000000000000000;;		x.c++
0000000000000000000000000000000000000000;;		return strconv.FormatUint(x.c, 10)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) varsfxreset() {
0000000000000000000000000000000000000000;;		x.c = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) out(s string) {
0000000000000000000000000000000000000000;;		if _, err := io.WriteString(x.w, s); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) linef(s string, params ...interface{}) {
0000000000000000000000000000000000000000;;		x.line(fmt.Sprintf(s, params...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) outf(s string, params ...interface{}) {
0000000000000000000000000000000000000000;;		x.out(fmt.Sprintf(s, params...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) genTypeName(t reflect.Type) (n string) {
0000000000000000000000000000000000000000;;		// defer func() { fmt.Printf(">>>> ####: genTypeName: t: %v, name: '%s'\n", t, n) }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the type has a PkgPath, which doesn't match the current package,
0000000000000000000000000000000000000000;;		// then include it.
0000000000000000000000000000000000000000;;		// We cannot depend on t.String() because it includes current package,
0000000000000000000000000000000000000000;;		// or t.PkgPath because it includes full import path,
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		var ptrPfx string
0000000000000000000000000000000000000000;;		for t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			ptrPfx += "*"
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tn := t.Name(); tn != "" {
0000000000000000000000000000000000000000;;			return ptrPfx + x.genTypeNamePrim(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			return ptrPfx + "map[" + x.genTypeName(t.Key()) + "]" + x.genTypeName(t.Elem())
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return ptrPfx + "[]" + x.genTypeName(t.Elem())
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			return ptrPfx + "[" + strconv.FormatInt(int64(t.Len()), 10) + "]" + x.genTypeName(t.Elem())
0000000000000000000000000000000000000000;;		case reflect.Chan:
0000000000000000000000000000000000000000;;			return ptrPfx + t.ChanDir().String() + " " + x.genTypeName(t.Elem())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if t == intfTyp {
0000000000000000000000000000000000000000;;				return ptrPfx + "interface{}"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return ptrPfx + x.genTypeNamePrim(t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) genTypeNamePrim(t reflect.Type) (n string) {
0000000000000000000000000000000000000000;;		if t.Name() == "" {
0000000000000000000000000000000000000000;;			return t.String()
0000000000000000000000000000000000000000;;		} else if genImportPath(t) == "" || genImportPath(t) == genImportPath(x.tc) {
0000000000000000000000000000000000000000;;			return t.Name()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return x.imn[genImportPath(t)] + "." + t.Name()
0000000000000000000000000000000000000000;;			// return t.String() // best way to get the package name inclusive
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) genZeroValueR(t reflect.Type) string {
0000000000000000000000000000000000000000;;		// if t is a named type, w
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr, reflect.Interface, reflect.Chan, reflect.Func,
0000000000000000000000000000000000000000;;			reflect.Slice, reflect.Map, reflect.Invalid:
0000000000000000000000000000000000000000;;			return "nil"
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return "false"
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return `""`
0000000000000000000000000000000000000000;;		case reflect.Struct, reflect.Array:
0000000000000000000000000000000000000000;;			return x.genTypeName(t) + "{}"
0000000000000000000000000000000000000000;;		default: // all numbers
0000000000000000000000000000000000000000;;			return "0"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) genMethodNameT(t reflect.Type) (s string) {
0000000000000000000000000000000000000000;;		return genMethodNameT(t, x.tc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) selfer(encode bool) {
0000000000000000000000000000000000000000;;		t := x.tc
0000000000000000000000000000000000000000;;		t0 := t
0000000000000000000000000000000000000000;;		// always make decode use a pointer receiver,
0000000000000000000000000000000000000000;;		// and structs always use a ptr receiver (encode|decode)
0000000000000000000000000000000000000000;;		isptr := !encode || t.Kind() == reflect.Struct
0000000000000000000000000000000000000000;;		x.varsfxreset()
0000000000000000000000000000000000000000;;		fnSigPfx := "func (x "
0000000000000000000000000000000000000000;;		if isptr {
0000000000000000000000000000000000000000;;			fnSigPfx += "*"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fnSigPfx += x.genTypeName(t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.out(fnSigPfx)
0000000000000000000000000000000000000000;;		if isptr {
0000000000000000000000000000000000000000;;			t = reflect.PtrTo(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if encode {
0000000000000000000000000000000000000000;;			x.line(") CodecEncodeSelf(e *" + x.cpfx + "Encoder) {")
0000000000000000000000000000000000000000;;			x.genRequiredMethodVars(true)
0000000000000000000000000000000000000000;;			// x.enc(genTopLevelVarName, t)
0000000000000000000000000000000000000000;;			x.encVar(genTopLevelVarName, t)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.line(") CodecDecodeSelf(d *" + x.cpfx + "Decoder) {")
0000000000000000000000000000000000000000;;			x.genRequiredMethodVars(false)
0000000000000000000000000000000000000000;;			// do not use decVar, as there is no need to check TryDecodeAsNil
0000000000000000000000000000000000000000;;			// or way to elegantly handle that, and also setting it to a
0000000000000000000000000000000000000000;;			// non-nil value doesn't affect the pointer passed.
0000000000000000000000000000000000000000;;			// x.decVar(genTopLevelVarName, t, false)
0000000000000000000000000000000000000000;;			x.dec(genTopLevelVarName, t0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if encode || t0.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write is containerMap
0000000000000000000000000000000000000000;;		if genUseOneFunctionForDecStructMap {
0000000000000000000000000000000000000000;;			x.out(fnSigPfx)
0000000000000000000000000000000000000000;;			x.line(") codecDecodeSelfFromMap(l int, d *" + x.cpfx + "Decoder) {")
0000000000000000000000000000000000000000;;			x.genRequiredMethodVars(false)
0000000000000000000000000000000000000000;;			x.decStructMap(genTopLevelVarName, "l", reflect.ValueOf(t0).Pointer(), t0, genStructMapStyleConsolidated)
0000000000000000000000000000000000000000;;			x.line("}")
0000000000000000000000000000000000000000;;			x.line("")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.out(fnSigPfx)
0000000000000000000000000000000000000000;;			x.line(") codecDecodeSelfFromMapLenPrefix(l int, d *" + x.cpfx + "Decoder) {")
0000000000000000000000000000000000000000;;			x.genRequiredMethodVars(false)
0000000000000000000000000000000000000000;;			x.decStructMap(genTopLevelVarName, "l", reflect.ValueOf(t0).Pointer(), t0, genStructMapStyleLenPrefix)
0000000000000000000000000000000000000000;;			x.line("}")
0000000000000000000000000000000000000000;;			x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			x.out(fnSigPfx)
0000000000000000000000000000000000000000;;			x.line(") codecDecodeSelfFromMapCheckBreak(l int, d *" + x.cpfx + "Decoder) {")
0000000000000000000000000000000000000000;;			x.genRequiredMethodVars(false)
0000000000000000000000000000000000000000;;			x.decStructMap(genTopLevelVarName, "l", reflect.ValueOf(t0).Pointer(), t0, genStructMapStyleCheckBreak)
0000000000000000000000000000000000000000;;			x.line("}")
0000000000000000000000000000000000000000;;			x.line("")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// write containerArray
0000000000000000000000000000000000000000;;		x.out(fnSigPfx)
0000000000000000000000000000000000000000;;		x.line(") codecDecodeSelfFromArray(l int, d *" + x.cpfx + "Decoder) {")
0000000000000000000000000000000000000000;;		x.genRequiredMethodVars(false)
0000000000000000000000000000000000000000;;		x.decStructArray(genTopLevelVarName, "l", "return", reflect.ValueOf(t0).Pointer(), t0)
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;		x.line("")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// used for chan, array, slice, map
0000000000000000000000000000000000000000;;	func (x *genRunner) xtraSM(varname string, encode bool, t reflect.Type) {
0000000000000000000000000000000000000000;;		if encode {
0000000000000000000000000000000000000000;;			x.linef("h.enc%s((%s%s)(%s), e)", x.genMethodNameT(t), x.arr2str(t, "*"), x.genTypeName(t), varname)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.linef("h.dec%s((*%s)(%s), d)", x.genMethodNameT(t), x.genTypeName(t), varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.registerXtraT(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) registerXtraT(t reflect.Type) {
0000000000000000000000000000000000000000;;		// recursively register the types
0000000000000000000000000000000000000000;;		if _, ok := x.tm[t]; ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var tkey reflect.Type
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Chan, reflect.Slice, reflect.Array:
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			tkey = t.Key()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.tm[t] = struct{}{}
0000000000000000000000000000000000000000;;		x.ts = append(x.ts, t)
0000000000000000000000000000000000000000;;		// check if this refers to any xtra types eg. a slice of array: add the array
0000000000000000000000000000000000000000;;		x.registerXtraT(t.Elem())
0000000000000000000000000000000000000000;;		if tkey != nil {
0000000000000000000000000000000000000000;;			x.registerXtraT(tkey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encVar will encode a variable.
0000000000000000000000000000000000000000;;	// The parameter, t, is the reflect.Type of the variable itself
0000000000000000000000000000000000000000;;	func (x *genRunner) encVar(varname string, t reflect.Type) {
0000000000000000000000000000000000000000;;		// fmt.Printf(">>>>>> varname: %s, t: %v\n", varname, t)
0000000000000000000000000000000000000000;;		var checkNil bool
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr, reflect.Interface, reflect.Slice, reflect.Map, reflect.Chan:
0000000000000000000000000000000000000000;;			checkNil = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if checkNil {
0000000000000000000000000000000000000000;;			x.linef("if %s == nil { r.EncodeNil() } else { ", varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			switch t.Elem().Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct, reflect.Array:
0000000000000000000000000000000000000000;;				x.enc(varname, genNonPtr(t))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				i := x.varsfx()
0000000000000000000000000000000000000000;;				x.line(genTempVarPfx + i + " := *" + varname)
0000000000000000000000000000000000000000;;				x.enc(genTempVarPfx+i, genNonPtr(t))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct, reflect.Array:
0000000000000000000000000000000000000000;;			i := x.varsfx()
0000000000000000000000000000000000000000;;			x.line(genTempVarPfx + i + " := &" + varname)
0000000000000000000000000000000000000000;;			x.enc(genTempVarPfx+i, t)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			x.enc(varname, t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if checkNil {
0000000000000000000000000000000000000000;;			x.line("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// enc will encode a variable (varname) of type t,
0000000000000000000000000000000000000000;;	// except t is of kind reflect.Struct or reflect.Array, wherein varname is of type ptrTo(T) (to prevent copying)
0000000000000000000000000000000000000000;;	func (x *genRunner) enc(varname string, t reflect.Type) {
0000000000000000000000000000000000000000;;		rtid := reflect.ValueOf(t).Pointer()
0000000000000000000000000000000000000000;;		// We call CodecEncodeSelf if one of the following are honored:
0000000000000000000000000000000000000000;;		//   - the type already implements Selfer, call that
0000000000000000000000000000000000000000;;		//   - the type has a Selfer implementation just created, use that
0000000000000000000000000000000000000000;;		//   - the type is in the list of the ones we will generate for, but it is not currently being generated
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mi := x.varsfx()
0000000000000000000000000000000000000000;;		tptr := reflect.PtrTo(t)
0000000000000000000000000000000000000000;;		tk := t.Kind()
0000000000000000000000000000000000000000;;		if x.checkForSelfer(t, varname) {
0000000000000000000000000000000000000000;;			if tk == reflect.Array || tk == reflect.Struct { // varname is of type *T
0000000000000000000000000000000000000000;;				if tptr.Implements(selferTyp) || t.Implements(selferTyp) {
0000000000000000000000000000000000000000;;					x.line(varname + ".CodecEncodeSelf(e)")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else { // varname is of type T
0000000000000000000000000000000000000000;;				if t.Implements(selferTyp) {
0000000000000000000000000000000000000000;;					x.line(varname + ".CodecEncodeSelf(e)")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				} else if tptr.Implements(selferTyp) {
0000000000000000000000000000000000000000;;					x.linef("%ssf%s := &%s", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;					x.linef("%ssf%s.CodecEncodeSelf(e)", genTempVarPfx, mi)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, ok := x.te[rtid]; ok {
0000000000000000000000000000000000000000;;				x.line(varname + ".CodecEncodeSelf(e)")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inlist := false
0000000000000000000000000000000000000000;;		for _, t0 := range x.t {
0000000000000000000000000000000000000000;;			if t == t0 {
0000000000000000000000000000000000000000;;				inlist = true
0000000000000000000000000000000000000000;;				if x.checkForSelfer(t, varname) {
0000000000000000000000000000000000000000;;					x.line(varname + ".CodecEncodeSelf(e)")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rtidAdded bool
0000000000000000000000000000000000000000;;		if t == x.tc {
0000000000000000000000000000000000000000;;			x.te[rtid] = true
0000000000000000000000000000000000000000;;			rtidAdded = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if
0000000000000000000000000000000000000000;;		//   - type is RawExt, Raw
0000000000000000000000000000000000000000;;		//   - the type implements (Text|JSON|Binary)(Unm|M)arshal
0000000000000000000000000000000000000000;;		x.linef("%sm%s := z.EncBinary()", genTempVarPfx, mi)
0000000000000000000000000000000000000000;;		x.linef("_ = %sm%s", genTempVarPfx, mi)
0000000000000000000000000000000000000000;;		x.line("if false {")           //start if block
0000000000000000000000000000000000000000;;		defer func() { x.line("}") }() //end if block
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t == rawTyp {
0000000000000000000000000000000000000000;;			x.linef("} else { z.EncRaw(%v)", varname)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t == rawExtTyp {
0000000000000000000000000000000000000000;;			x.linef("} else { r.EncodeRawExt(%v, e)", varname)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// HACK: Support for Builtins.
0000000000000000000000000000000000000000;;		//       Currently, only Binc supports builtins, and the only builtin type is time.Time.
0000000000000000000000000000000000000000;;		//       Have a method that returns the rtid for time.Time if Handle is Binc.
0000000000000000000000000000000000000000;;		if t == timeTyp {
0000000000000000000000000000000000000000;;			vrtid := genTempVarPfx + "m" + x.varsfx()
0000000000000000000000000000000000000000;;			x.linef("} else if %s := z.TimeRtidIfBinc(); %s != 0 { ", vrtid, vrtid)
0000000000000000000000000000000000000000;;			x.linef("r.EncodeBuiltin(%s, %s)", vrtid, varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// only check for extensions if the type is named, and has a packagePath.
0000000000000000000000000000000000000000;;		if genImportPath(t) != "" && t.Name() != "" {
0000000000000000000000000000000000000000;;			// first check if extensions are configued, before doing the interface conversion
0000000000000000000000000000000000000000;;			x.linef("} else if z.HasExtensions() && z.EncExt(%s) {", varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tk == reflect.Array || tk == reflect.Struct { // varname is of type *T
0000000000000000000000000000000000000000;;			if t.Implements(binaryMarshalerTyp) || tptr.Implements(binaryMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if %sm%s { z.EncBinaryMarshal(%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.Implements(jsonMarshalerTyp) || tptr.Implements(jsonMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if !%sm%s && z.IsJSONHandle() { z.EncJSONMarshal(%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			} else if t.Implements(textMarshalerTyp) || tptr.Implements(textMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if !%sm%s { z.EncTextMarshal(%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else { // varname is of type T
0000000000000000000000000000000000000000;;			if t.Implements(binaryMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if %sm%s { z.EncBinaryMarshal(%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			} else if tptr.Implements(binaryMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if %sm%s { z.EncBinaryMarshal(&%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.Implements(jsonMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if !%sm%s && z.IsJSONHandle() { z.EncJSONMarshal(%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			} else if tptr.Implements(jsonMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if !%sm%s && z.IsJSONHandle() { z.EncJSONMarshal(&%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			} else if t.Implements(textMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if !%sm%s { z.EncTextMarshal(%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			} else if tptr.Implements(textMarshalerTyp) {
0000000000000000000000000000000000000000;;				x.linef("} else if !%sm%s { z.EncTextMarshal(&%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line("} else {")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			x.line("r.EncodeInt(int64(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			x.line("r.EncodeUint(uint64(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			x.line("r.EncodeFloat32(float32(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			x.line("r.EncodeFloat64(float64(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			x.line("r.EncodeBool(bool(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			x.line("r.EncodeString(codecSelferC_UTF8" + x.xs + ", string(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Chan:
0000000000000000000000000000000000000000;;			x.xtraSM(varname, true, t)
0000000000000000000000000000000000000000;;			// x.encListFallback(varname, rtid, t)
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			x.xtraSM(varname, true, t)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			// if nil, call dedicated function
0000000000000000000000000000000000000000;;			// if a []uint8, call dedicated function
0000000000000000000000000000000000000000;;			// if a known fastpath slice, call dedicated function
0000000000000000000000000000000000000000;;			// else write encode function in-line.
0000000000000000000000000000000000000000;;			// - if elements are primitives or Selfers, call dedicated function on each member.
0000000000000000000000000000000000000000;;			// - else call Encoder.encode(XXX) on it.
0000000000000000000000000000000000000000;;			if rtid == uint8SliceTypId {
0000000000000000000000000000000000000000;;				x.line("r.EncodeStringBytes(codecSelferC_RAW" + x.xs + ", []byte(" + varname + "))")
0000000000000000000000000000000000000000;;			} else if fastpathAV.index(rtid) != -1 {
0000000000000000000000000000000000000000;;				g := x.newGenV(t)
0000000000000000000000000000000000000000;;				x.line("z.F." + g.MethodNamePfx("Enc", false) + "V(" + varname + ", false, e)")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.xtraSM(varname, true, t)
0000000000000000000000000000000000000000;;				// x.encListFallback(varname, rtid, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			// if nil, call dedicated function
0000000000000000000000000000000000000000;;			// if a known fastpath map, call dedicated function
0000000000000000000000000000000000000000;;			// else write encode function in-line.
0000000000000000000000000000000000000000;;			// - if elements are primitives or Selfers, call dedicated function on each member.
0000000000000000000000000000000000000000;;			// - else call Encoder.encode(XXX) on it.
0000000000000000000000000000000000000000;;			// x.line("if " + varname + " == nil { \nr.EncodeNil()\n } else { ")
0000000000000000000000000000000000000000;;			if fastpathAV.index(rtid) != -1 {
0000000000000000000000000000000000000000;;				g := x.newGenV(t)
0000000000000000000000000000000000000000;;				x.line("z.F." + g.MethodNamePfx("Enc", false) + "V(" + varname + ", false, e)")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.xtraSM(varname, true, t)
0000000000000000000000000000000000000000;;				// x.encMapFallback(varname, rtid, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if !inlist {
0000000000000000000000000000000000000000;;				delete(x.te, rtid)
0000000000000000000000000000000000000000;;				x.line("z.EncFallback(" + varname + ")")
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.encStruct(varname, rtid, t)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if rtidAdded {
0000000000000000000000000000000000000000;;				delete(x.te, rtid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.line("z.EncFallback(" + varname + ")")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) encZero(t reflect.Type) {
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			x.line("r.EncodeInt(0)")
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			x.line("r.EncodeUint(0)")
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			x.line("r.EncodeFloat32(0)")
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			x.line("r.EncodeFloat64(0)")
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			x.line("r.EncodeBool(false)")
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			x.line("r.EncodeString(codecSelferC_UTF8" + x.xs + `, "")`)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			x.line("r.EncodeNil()")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) encStruct(varname string, rtid uintptr, t reflect.Type) {
0000000000000000000000000000000000000000;;		// Use knowledge from structfieldinfo (mbs, encodable fields. Ignore omitempty. )
0000000000000000000000000000000000000000;;		// replicate code in kStruct i.e. for each field, deref type to non-pointer, and call x.enc on it
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if t === type currently running selfer on, do for all
0000000000000000000000000000000000000000;;		ti := x.ti.get(rtid, t)
0000000000000000000000000000000000000000;;		i := x.varsfx()
0000000000000000000000000000000000000000;;		sepVarname := genTempVarPfx + "sep" + i
0000000000000000000000000000000000000000;;		numfieldsvar := genTempVarPfx + "q" + i
0000000000000000000000000000000000000000;;		ti2arrayvar := genTempVarPfx + "r" + i
0000000000000000000000000000000000000000;;		struct2arrvar := genTempVarPfx + "2arr" + i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.line(sepVarname + " := !z.EncBinary()")
0000000000000000000000000000000000000000;;		x.linef("%s := z.EncBasicHandle().StructToArray", struct2arrvar)
0000000000000000000000000000000000000000;;		tisfi := ti.sfip // always use sequence from file. decStruct expects same thing.
0000000000000000000000000000000000000000;;		// due to omitEmpty, we need to calculate the
0000000000000000000000000000000000000000;;		// number of non-empty things we write out first.
0000000000000000000000000000000000000000;;		// This is required as we need to pre-determine the size of the container,
0000000000000000000000000000000000000000;;		// to support length-prefixing.
0000000000000000000000000000000000000000;;		x.linef("var %s [%v]bool", numfieldsvar, len(tisfi))
0000000000000000000000000000000000000000;;		x.linef("_, _, _ = %s, %s, %s", sepVarname, numfieldsvar, struct2arrvar)
0000000000000000000000000000000000000000;;		x.linef("const %s bool = %v", ti2arrayvar, ti.toArray)
0000000000000000000000000000000000000000;;		nn := 0
0000000000000000000000000000000000000000;;		for j, si := range tisfi {
0000000000000000000000000000000000000000;;			if !si.omitEmpty {
0000000000000000000000000000000000000000;;				nn++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var t2 reflect.StructField
0000000000000000000000000000000000000000;;			var omitline string
0000000000000000000000000000000000000000;;			if si.i != -1 {
0000000000000000000000000000000000000000;;				t2 = t.Field(int(si.i))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t2typ := t
0000000000000000000000000000000000000000;;				varname3 := varname
0000000000000000000000000000000000000000;;				for _, ix := range si.is {
0000000000000000000000000000000000000000;;					for t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						t2typ = t2typ.Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t2 = t2typ.Field(ix)
0000000000000000000000000000000000000000;;					t2typ = t2.Type
0000000000000000000000000000000000000000;;					varname3 = varname3 + "." + t2.Name
0000000000000000000000000000000000000000;;					if t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						omitline += varname3 + " != nil && "
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// never check omitEmpty on a struct type, as it may contain uncomparable map/slice/etc.
0000000000000000000000000000000000000000;;			// also, for maps/slices/arrays, check if len ! 0 (not if == zero value)
0000000000000000000000000000000000000000;;			switch t2.Type.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				omitline += " true"
0000000000000000000000000000000000000000;;			case reflect.Map, reflect.Slice, reflect.Array, reflect.Chan:
0000000000000000000000000000000000000000;;				omitline += "len(" + varname + "." + t2.Name + ") != 0"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				omitline += varname + "." + t2.Name + " != " + x.genZeroValueR(t2.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.linef("%s[%v] = %s", numfieldsvar, j, omitline)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.linef("var %snn%s int", genTempVarPfx, i)
0000000000000000000000000000000000000000;;		x.linef("if %s || %s {", ti2arrayvar, struct2arrvar) // if ti.toArray {
0000000000000000000000000000000000000000;;		x.line("r.EncodeArrayStart(" + strconv.FormatInt(int64(len(tisfi)), 10) + ")")
0000000000000000000000000000000000000000;;		x.linef("} else {") // if not ti.toArray
0000000000000000000000000000000000000000;;		x.linef("%snn%s = %v", genTempVarPfx, i, nn)
0000000000000000000000000000000000000000;;		x.linef("for _, b := range %s { if b { %snn%s++ } }", numfieldsvar, genTempVarPfx, i)
0000000000000000000000000000000000000000;;		x.linef("r.EncodeMapStart(%snn%s)", genTempVarPfx, i)
0000000000000000000000000000000000000000;;		x.linef("%snn%s = %v", genTempVarPfx, i, 0)
0000000000000000000000000000000000000000;;		// x.line("r.EncodeMapStart(" + strconv.FormatInt(int64(len(tisfi)), 10) + ")")
0000000000000000000000000000000000000000;;		x.line("}") // close if not StructToArray
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for j, si := range tisfi {
0000000000000000000000000000000000000000;;			i := x.varsfx()
0000000000000000000000000000000000000000;;			isNilVarName := genTempVarPfx + "n" + i
0000000000000000000000000000000000000000;;			var labelUsed bool
0000000000000000000000000000000000000000;;			var t2 reflect.StructField
0000000000000000000000000000000000000000;;			if si.i != -1 {
0000000000000000000000000000000000000000;;				t2 = t.Field(int(si.i))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				t2typ := t
0000000000000000000000000000000000000000;;				varname3 := varname
0000000000000000000000000000000000000000;;				for _, ix := range si.is {
0000000000000000000000000000000000000000;;					// fmt.Printf("%%%% %v, ix: %v\n", t2typ, ix)
0000000000000000000000000000000000000000;;					for t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						t2typ = t2typ.Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t2 = t2typ.Field(ix)
0000000000000000000000000000000000000000;;					t2typ = t2.Type
0000000000000000000000000000000000000000;;					varname3 = varname3 + "." + t2.Name
0000000000000000000000000000000000000000;;					if t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						if !labelUsed {
0000000000000000000000000000000000000000;;							x.line("var " + isNilVarName + " bool")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						x.line("if " + varname3 + " == nil { " + isNilVarName + " = true ")
0000000000000000000000000000000000000000;;						x.line("goto LABEL" + i)
0000000000000000000000000000000000000000;;						x.line("}")
0000000000000000000000000000000000000000;;						labelUsed = true
0000000000000000000000000000000000000000;;						// "varname3 = new(" + x.genTypeName(t3.Elem()) + ") }")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// t2 = t.FieldByIndex(si.is)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if labelUsed {
0000000000000000000000000000000000000000;;				x.line("LABEL" + i + ":")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if the type of the field is a Selfer, or one of the ones
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			x.linef("if %s || %s {", ti2arrayvar, struct2arrvar) // if ti.toArray
0000000000000000000000000000000000000000;;			if labelUsed {
0000000000000000000000000000000000000000;;				x.line("if " + isNilVarName + " { r.EncodeNil() } else { ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.linef("z.EncSendContainerState(codecSelfer_containerArrayElem%s)", x.xs)
0000000000000000000000000000000000000000;;			if si.omitEmpty {
0000000000000000000000000000000000000000;;				x.linef("if %s[%v] {", numfieldsvar, j)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.encVar(varname+"."+t2.Name, t2.Type)
0000000000000000000000000000000000000000;;			if si.omitEmpty {
0000000000000000000000000000000000000000;;				x.linef("} else {")
0000000000000000000000000000000000000000;;				x.encZero(t2.Type)
0000000000000000000000000000000000000000;;				x.linef("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if labelUsed {
0000000000000000000000000000000000000000;;				x.line("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			x.linef("} else {") // if not ti.toArray
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if si.omitEmpty {
0000000000000000000000000000000000000000;;				x.linef("if %s[%v] {", numfieldsvar, j)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.linef("z.EncSendContainerState(codecSelfer_containerMapKey%s)", x.xs)
0000000000000000000000000000000000000000;;			x.line("r.EncodeString(codecSelferC_UTF8" + x.xs + ", string(\"" + si.encName + "\"))")
0000000000000000000000000000000000000000;;			x.linef("z.EncSendContainerState(codecSelfer_containerMapValue%s)", x.xs)
0000000000000000000000000000000000000000;;			if labelUsed {
0000000000000000000000000000000000000000;;				x.line("if " + isNilVarName + " { r.EncodeNil() } else { ")
0000000000000000000000000000000000000000;;				x.encVar(varname+"."+t2.Name, t2.Type)
0000000000000000000000000000000000000000;;				x.line("}")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.encVar(varname+"."+t2.Name, t2.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if si.omitEmpty {
0000000000000000000000000000000000000000;;				x.line("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.linef("} ") // end if/else ti.toArray
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.linef("if %s || %s {", ti2arrayvar, struct2arrvar) // if ti.toArray {
0000000000000000000000000000000000000000;;		x.linef("z.EncSendContainerState(codecSelfer_containerArrayEnd%s)", x.xs)
0000000000000000000000000000000000000000;;		x.line("} else {")
0000000000000000000000000000000000000000;;		x.linef("z.EncSendContainerState(codecSelfer_containerMapEnd%s)", x.xs)
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) encListFallback(varname string, t reflect.Type) {
0000000000000000000000000000000000000000;;		if t.AssignableTo(uint8SliceTyp) {
0000000000000000000000000000000000000000;;			x.linef("r.EncodeStringBytes(codecSelferC_RAW%s, []byte(%s))", x.xs, varname)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Array && t.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;			x.linef("r.EncodeStringBytes(codecSelferC_RAW%s, ([%v]byte(%s))[:])", x.xs, t.Len(), varname)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := x.varsfx()
0000000000000000000000000000000000000000;;		g := genTempVarPfx
0000000000000000000000000000000000000000;;		x.line("r.EncodeArrayStart(len(" + varname + "))")
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Chan {
0000000000000000000000000000000000000000;;			x.linef("for %si%s, %si2%s := 0, len(%s); %si%s < %si2%s; %si%s++ {", g, i, g, i, varname, g, i, g, i, g, i)
0000000000000000000000000000000000000000;;			x.linef("z.EncSendContainerState(codecSelfer_containerArrayElem%s)", x.xs)
0000000000000000000000000000000000000000;;			x.linef("%sv%s := <-%s", g, i, varname)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// x.linef("for %si%s, %sv%s := range %s {", genTempVarPfx, i, genTempVarPfx, i, varname)
0000000000000000000000000000000000000000;;			x.linef("for _, %sv%s := range %s {", genTempVarPfx, i, varname)
0000000000000000000000000000000000000000;;			x.linef("z.EncSendContainerState(codecSelfer_containerArrayElem%s)", x.xs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.encVar(genTempVarPfx+"v"+i, t.Elem())
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;		x.linef("z.EncSendContainerState(codecSelfer_containerArrayEnd%s)", x.xs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) encMapFallback(varname string, t reflect.Type) {
0000000000000000000000000000000000000000;;		// TODO: expand this to handle canonical.
0000000000000000000000000000000000000000;;		i := x.varsfx()
0000000000000000000000000000000000000000;;		x.line("r.EncodeMapStart(len(" + varname + "))")
0000000000000000000000000000000000000000;;		x.linef("for %sk%s, %sv%s := range %s {", genTempVarPfx, i, genTempVarPfx, i, varname)
0000000000000000000000000000000000000000;;		// x.line("for " + genTempVarPfx + "k" + i + ", " + genTempVarPfx + "v" + i + " := range " + varname + " {")
0000000000000000000000000000000000000000;;		x.linef("z.EncSendContainerState(codecSelfer_containerMapKey%s)", x.xs)
0000000000000000000000000000000000000000;;		x.encVar(genTempVarPfx+"k"+i, t.Key())
0000000000000000000000000000000000000000;;		x.linef("z.EncSendContainerState(codecSelfer_containerMapValue%s)", x.xs)
0000000000000000000000000000000000000000;;		x.encVar(genTempVarPfx+"v"+i, t.Elem())
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;		x.linef("z.EncSendContainerState(codecSelfer_containerMapEnd%s)", x.xs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decVar(varname string, t reflect.Type, canBeNil bool) {
0000000000000000000000000000000000000000;;		// We only encode as nil if a nillable value.
0000000000000000000000000000000000000000;;		// This removes some of the wasted checks for TryDecodeAsNil.
0000000000000000000000000000000000000000;;		// We need to think about this more, to see what happens if omitempty, etc
0000000000000000000000000000000000000000;;		// cause a nil value to be stored when something is expected.
0000000000000000000000000000000000000000;;		// This could happen when decoding from a struct encoded as an array.
0000000000000000000000000000000000000000;;		// For that, decVar should be called with canNil=true, to force true as its value.
0000000000000000000000000000000000000000;;		i := x.varsfx()
0000000000000000000000000000000000000000;;		if !canBeNil {
0000000000000000000000000000000000000000;;			canBeNil = genAnythingCanBeNil || !genIsImmutable(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if canBeNil {
0000000000000000000000000000000000000000;;			x.line("if r.TryDecodeAsNil() {")
0000000000000000000000000000000000000000;;			if t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				x.line("if " + varname + " != nil { ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if varname is a field of a struct (has a dot in it),
0000000000000000000000000000000000000000;;				// then just set it to nil
0000000000000000000000000000000000000000;;				if strings.IndexByte(varname, '.') != -1 {
0000000000000000000000000000000000000000;;					x.line(varname + " = nil")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					x.line("*" + varname + " = " + x.genZeroValueR(t.Elem()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				x.line("}")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.line(varname + " = " + x.genZeroValueR(t))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.line("} else {")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.line("// cannot be nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			if x.decTryAssignPrimitive(varname, t) {
0000000000000000000000000000000000000000;;				x.line(genTempVarPfx + "v" + i + " := &" + varname)
0000000000000000000000000000000000000000;;				x.dec(genTempVarPfx+"v"+i, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.linef("if %s == nil { %s = new(%s) }", varname, varname, x.genTypeName(t.Elem()))
0000000000000000000000000000000000000000;;			// Ensure we set underlying ptr to a non-nil value (so we can deref to it later).
0000000000000000000000000000000000000000;;			// There's a chance of a **T in here which is nil.
0000000000000000000000000000000000000000;;			var ptrPfx string
0000000000000000000000000000000000000000;;			for t = t.Elem(); t.Kind() == reflect.Ptr; t = t.Elem() {
0000000000000000000000000000000000000000;;				ptrPfx += "*"
0000000000000000000000000000000000000000;;				x.linef("if %s%s == nil { %s%s = new(%s)}",
0000000000000000000000000000000000000000;;					ptrPfx, varname, ptrPfx, varname, x.genTypeName(t))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// if varname has [ in it, then create temp variable for this ptr thingie
0000000000000000000000000000000000000000;;			if strings.Index(varname, "[") >= 0 {
0000000000000000000000000000000000000000;;				varname2 := genTempVarPfx + "w" + i
0000000000000000000000000000000000000000;;				x.line(varname2 + " := " + varname)
0000000000000000000000000000000000000000;;				varname = varname2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ptrPfx == "" {
0000000000000000000000000000000000000000;;				x.dec(varname, t)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.line(genTempVarPfx + "z" + i + " := " + ptrPfx + varname)
0000000000000000000000000000000000000000;;				x.dec(genTempVarPfx+"z"+i, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if canBeNil {
0000000000000000000000000000000000000000;;			x.line("} ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dec will decode a variable (varname) of type ptrTo(t).
0000000000000000000000000000000000000000;;	// t is always a basetype (i.e. not of kind reflect.Ptr).
0000000000000000000000000000000000000000;;	func (x *genRunner) dec(varname string, t reflect.Type) {
0000000000000000000000000000000000000000;;		// assumptions:
0000000000000000000000000000000000000000;;		//   - the varname is to a pointer already. No need to take address of it
0000000000000000000000000000000000000000;;		//   - t is always a baseType T (not a *T, etc).
0000000000000000000000000000000000000000;;		rtid := reflect.ValueOf(t).Pointer()
0000000000000000000000000000000000000000;;		tptr := reflect.PtrTo(t)
0000000000000000000000000000000000000000;;		if x.checkForSelfer(t, varname) {
0000000000000000000000000000000000000000;;			if t.Implements(selferTyp) || tptr.Implements(selferTyp) {
0000000000000000000000000000000000000000;;				x.line(varname + ".CodecDecodeSelf(d)")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := x.td[rtid]; ok {
0000000000000000000000000000000000000000;;				x.line(varname + ".CodecDecodeSelf(d)")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inlist := false
0000000000000000000000000000000000000000;;		for _, t0 := range x.t {
0000000000000000000000000000000000000000;;			if t == t0 {
0000000000000000000000000000000000000000;;				inlist = true
0000000000000000000000000000000000000000;;				if x.checkForSelfer(t, varname) {
0000000000000000000000000000000000000000;;					x.line(varname + ".CodecDecodeSelf(d)")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rtidAdded bool
0000000000000000000000000000000000000000;;		if t == x.tc {
0000000000000000000000000000000000000000;;			x.td[rtid] = true
0000000000000000000000000000000000000000;;			rtidAdded = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if
0000000000000000000000000000000000000000;;		//   - type is Raw, RawExt
0000000000000000000000000000000000000000;;		//   - the type implements (Text|JSON|Binary)(Unm|M)arshal
0000000000000000000000000000000000000000;;		mi := x.varsfx()
0000000000000000000000000000000000000000;;		x.linef("%sm%s := z.DecBinary()", genTempVarPfx, mi)
0000000000000000000000000000000000000000;;		x.linef("_ = %sm%s", genTempVarPfx, mi)
0000000000000000000000000000000000000000;;		x.line("if false {")           //start if block
0000000000000000000000000000000000000000;;		defer func() { x.line("}") }() //end if block
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t == rawTyp {
0000000000000000000000000000000000000000;;			x.linef("} else { *%v = z.DecRaw()", varname)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t == rawExtTyp {
0000000000000000000000000000000000000000;;			x.linef("} else { r.DecodeExt(%v, 0, nil)", varname)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HACK: Support for Builtins.
0000000000000000000000000000000000000000;;		//       Currently, only Binc supports builtins, and the only builtin type is time.Time.
0000000000000000000000000000000000000000;;		//       Have a method that returns the rtid for time.Time if Handle is Binc.
0000000000000000000000000000000000000000;;		if t == timeTyp {
0000000000000000000000000000000000000000;;			vrtid := genTempVarPfx + "m" + x.varsfx()
0000000000000000000000000000000000000000;;			x.linef("} else if %s := z.TimeRtidIfBinc(); %s != 0 { ", vrtid, vrtid)
0000000000000000000000000000000000000000;;			x.linef("r.DecodeBuiltin(%s, %s)", vrtid, varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// only check for extensions if the type is named, and has a packagePath.
0000000000000000000000000000000000000000;;		if genImportPath(t) != "" && t.Name() != "" {
0000000000000000000000000000000000000000;;			// first check if extensions are configued, before doing the interface conversion
0000000000000000000000000000000000000000;;			x.linef("} else if z.HasExtensions() && z.DecExt(%s) {", varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Implements(binaryUnmarshalerTyp) || tptr.Implements(binaryUnmarshalerTyp) {
0000000000000000000000000000000000000000;;			x.linef("} else if %sm%s { z.DecBinaryUnmarshal(%v) ", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Implements(jsonUnmarshalerTyp) || tptr.Implements(jsonUnmarshalerTyp) {
0000000000000000000000000000000000000000;;			x.linef("} else if !%sm%s && z.IsJSONHandle() { z.DecJSONUnmarshal(%v)", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;		} else if t.Implements(textUnmarshalerTyp) || tptr.Implements(textUnmarshalerTyp) {
0000000000000000000000000000000000000000;;			x.linef("} else if !%sm%s { z.DecTextUnmarshal(%v)", genTempVarPfx, mi, varname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.line("} else {")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since these are pointers, we cannot share, and have to use them one by one
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int:
0000000000000000000000000000000000000000;;			x.line("*((*int)(" + varname + ")) = int(r.DecodeInt(codecSelferBitsize" + x.xs + "))")
0000000000000000000000000000000000000000;;			// x.line("z.DecInt((*int)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Int8:
0000000000000000000000000000000000000000;;			x.line("*((*int8)(" + varname + ")) = int8(r.DecodeInt(8))")
0000000000000000000000000000000000000000;;			// x.line("z.DecInt8((*int8)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Int16:
0000000000000000000000000000000000000000;;			x.line("*((*int16)(" + varname + ")) = int16(r.DecodeInt(16))")
0000000000000000000000000000000000000000;;			// x.line("z.DecInt16((*int16)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			x.line("*((*int32)(" + varname + ")) = int32(r.DecodeInt(32))")
0000000000000000000000000000000000000000;;			// x.line("z.DecInt32((*int32)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			x.line("*((*int64)(" + varname + ")) = int64(r.DecodeInt(64))")
0000000000000000000000000000000000000000;;			// x.line("z.DecInt64((*int64)(" + varname + "))")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Uint:
0000000000000000000000000000000000000000;;			x.line("*((*uint)(" + varname + ")) = uint(r.DecodeUint(codecSelferBitsize" + x.xs + "))")
0000000000000000000000000000000000000000;;			// x.line("z.DecUint((*uint)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Uint8:
0000000000000000000000000000000000000000;;			x.line("*((*uint8)(" + varname + ")) = uint8(r.DecodeUint(8))")
0000000000000000000000000000000000000000;;			// x.line("z.DecUint8((*uint8)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Uint16:
0000000000000000000000000000000000000000;;			x.line("*((*uint16)(" + varname + ")) = uint16(r.DecodeUint(16))")
0000000000000000000000000000000000000000;;			//x.line("z.DecUint16((*uint16)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			x.line("*((*uint32)(" + varname + ")) = uint32(r.DecodeUint(32))")
0000000000000000000000000000000000000000;;			//x.line("z.DecUint32((*uint32)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			x.line("*((*uint64)(" + varname + ")) = uint64(r.DecodeUint(64))")
0000000000000000000000000000000000000000;;			//x.line("z.DecUint64((*uint64)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Uintptr:
0000000000000000000000000000000000000000;;			x.line("*((*uintptr)(" + varname + ")) = uintptr(r.DecodeUint(codecSelferBitsize" + x.xs + "))")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			x.line("*((*float32)(" + varname + ")) = float32(r.DecodeFloat(true))")
0000000000000000000000000000000000000000;;			//x.line("z.DecFloat32((*float32)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			x.line("*((*float64)(" + varname + ")) = float64(r.DecodeFloat(false))")
0000000000000000000000000000000000000000;;			// x.line("z.DecFloat64((*float64)(" + varname + "))")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			x.line("*((*bool)(" + varname + ")) = r.DecodeBool()")
0000000000000000000000000000000000000000;;			// x.line("z.DecBool((*bool)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			x.line("*((*string)(" + varname + ")) = r.DecodeString()")
0000000000000000000000000000000000000000;;			// x.line("z.DecString((*string)(" + varname + "))")
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Chan:
0000000000000000000000000000000000000000;;			x.xtraSM(varname, false, t)
0000000000000000000000000000000000000000;;			// x.decListFallback(varname, rtid, true, t)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			// if a []uint8, call dedicated function
0000000000000000000000000000000000000000;;			// if a known fastpath slice, call dedicated function
0000000000000000000000000000000000000000;;			// else write encode function in-line.
0000000000000000000000000000000000000000;;			// - if elements are primitives or Selfers, call dedicated function on each member.
0000000000000000000000000000000000000000;;			// - else call Encoder.encode(XXX) on it.
0000000000000000000000000000000000000000;;			if rtid == uint8SliceTypId {
0000000000000000000000000000000000000000;;				x.line("*" + varname + " = r.DecodeBytes(*(*[]byte)(" + varname + "), false, false)")
0000000000000000000000000000000000000000;;			} else if fastpathAV.index(rtid) != -1 {
0000000000000000000000000000000000000000;;				g := x.newGenV(t)
0000000000000000000000000000000000000000;;				x.line("z.F." + g.MethodNamePfx("Dec", false) + "X(" + varname + ", false, d)")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.xtraSM(varname, false, t)
0000000000000000000000000000000000000000;;				// x.decListFallback(varname, rtid, false, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			// if a known fastpath map, call dedicated function
0000000000000000000000000000000000000000;;			// else write encode function in-line.
0000000000000000000000000000000000000000;;			// - if elements are primitives or Selfers, call dedicated function on each member.
0000000000000000000000000000000000000000;;			// - else call Encoder.encode(XXX) on it.
0000000000000000000000000000000000000000;;			if fastpathAV.index(rtid) != -1 {
0000000000000000000000000000000000000000;;				g := x.newGenV(t)
0000000000000000000000000000000000000000;;				x.line("z.F." + g.MethodNamePfx("Dec", false) + "X(" + varname + ", false, d)")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x.xtraSM(varname, false, t)
0000000000000000000000000000000000000000;;				// x.decMapFallback(varname, rtid, t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if inlist {
0000000000000000000000000000000000000000;;				x.decStruct(varname, rtid, t)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// delete(x.td, rtid)
0000000000000000000000000000000000000000;;				x.line("z.DecFallback(" + varname + ", false)")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if rtidAdded {
0000000000000000000000000000000000000000;;				delete(x.te, rtid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.line("z.DecFallback(" + varname + ", true)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decTryAssignPrimitive(varname string, t reflect.Type) (tryAsPtr bool) {
0000000000000000000000000000000000000000;;		// This should only be used for exact primitives (ie un-named types).
0000000000000000000000000000000000000000;;		// Named types may be implementations of Selfer, Unmarshaler, etc.
0000000000000000000000000000000000000000;;		// They should be handled by dec(...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t.Name() != "" {
0000000000000000000000000000000000000000;;			tryAsPtr = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeInt(codecSelferBitsize%s)", varname, x.xs)
0000000000000000000000000000000000000000;;		case reflect.Int8:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeInt(8)", varname)
0000000000000000000000000000000000000000;;		case reflect.Int16:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeInt(16)", varname)
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeInt(32)", varname)
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeInt(64)", varname)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Uint:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeUint(codecSelferBitsize%s)", varname, x.xs)
0000000000000000000000000000000000000000;;		case reflect.Uint8:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeUint(8)", varname)
0000000000000000000000000000000000000000;;		case reflect.Uint16:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeUint(16)", varname)
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeUint(32)", varname)
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeUint(64)", varname)
0000000000000000000000000000000000000000;;		case reflect.Uintptr:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeUint(codecSelferBitsize%s)", varname, x.xs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeFloat(true)", varname)
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeFloat(false)", varname)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeBool()", varname)
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			x.linef("%s = r.DecodeString()", varname)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			tryAsPtr = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decListFallback(varname string, rtid uintptr, t reflect.Type) {
0000000000000000000000000000000000000000;;		if t.AssignableTo(uint8SliceTyp) {
0000000000000000000000000000000000000000;;			x.line("*" + varname + " = r.DecodeBytes(*((*[]byte)(" + varname + ")), false, false)")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Kind() == reflect.Array && t.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;			x.linef("r.DecodeBytes( ((*[%s]byte)(%s))[:], false, true)", t.Len(), varname)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type tstruc struct {
0000000000000000000000000000000000000000;;			TempVar   string
0000000000000000000000000000000000000000;;			Rand      string
0000000000000000000000000000000000000000;;			Varname   string
0000000000000000000000000000000000000000;;			CTyp      string
0000000000000000000000000000000000000000;;			Typ       string
0000000000000000000000000000000000000000;;			Immutable bool
0000000000000000000000000000000000000000;;			Size      int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		telem := t.Elem()
0000000000000000000000000000000000000000;;		ts := tstruc{genTempVarPfx, x.varsfx(), varname, x.genTypeName(t), x.genTypeName(telem), genIsImmutable(telem), int(telem.Size())}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		funcs := make(template.FuncMap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		funcs["decLineVar"] = func(varname string) string {
0000000000000000000000000000000000000000;;			x.decVar(varname, telem, false)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decLine"] = func(pfx string) string {
0000000000000000000000000000000000000000;;			x.decVar(ts.TempVar+pfx+ts.Rand, reflect.PtrTo(telem), false)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["var"] = func(s string) string {
0000000000000000000000000000000000000000;;			return ts.TempVar + s + ts.Rand
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["zero"] = func() string {
0000000000000000000000000000000000000000;;			return x.genZeroValueR(telem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["isArray"] = func() bool {
0000000000000000000000000000000000000000;;			return t.Kind() == reflect.Array
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["isSlice"] = func() bool {
0000000000000000000000000000000000000000;;			return t.Kind() == reflect.Slice
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["isChan"] = func() bool {
0000000000000000000000000000000000000000;;			return t.Kind() == reflect.Chan
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tm, err := template.New("").Funcs(funcs).Parse(genDecListTmpl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = tm.Execute(x.w, &ts); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decMapFallback(varname string, rtid uintptr, t reflect.Type) {
0000000000000000000000000000000000000000;;		type tstruc struct {
0000000000000000000000000000000000000000;;			TempVar string
0000000000000000000000000000000000000000;;			Sfx     string
0000000000000000000000000000000000000000;;			Rand    string
0000000000000000000000000000000000000000;;			Varname string
0000000000000000000000000000000000000000;;			KTyp    string
0000000000000000000000000000000000000000;;			Typ     string
0000000000000000000000000000000000000000;;			Size    int
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		telem := t.Elem()
0000000000000000000000000000000000000000;;		tkey := t.Key()
0000000000000000000000000000000000000000;;		ts := tstruc{
0000000000000000000000000000000000000000;;			genTempVarPfx, x.xs, x.varsfx(), varname, x.genTypeName(tkey),
0000000000000000000000000000000000000000;;			x.genTypeName(telem), int(telem.Size() + tkey.Size()),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		funcs := make(template.FuncMap)
0000000000000000000000000000000000000000;;		funcs["decElemZero"] = func() string {
0000000000000000000000000000000000000000;;			return x.genZeroValueR(telem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decElemKindImmutable"] = func() bool {
0000000000000000000000000000000000000000;;			return genIsImmutable(telem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decElemKindPtr"] = func() bool {
0000000000000000000000000000000000000000;;			return telem.Kind() == reflect.Ptr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decElemKindIntf"] = func() bool {
0000000000000000000000000000000000000000;;			return telem.Kind() == reflect.Interface
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decLineVarK"] = func(varname string) string {
0000000000000000000000000000000000000000;;			x.decVar(varname, tkey, false)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decLineVar"] = func(varname string) string {
0000000000000000000000000000000000000000;;			x.decVar(varname, telem, false)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decLineK"] = func(pfx string) string {
0000000000000000000000000000000000000000;;			x.decVar(ts.TempVar+pfx+ts.Rand, reflect.PtrTo(tkey), false)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["decLine"] = func(pfx string) string {
0000000000000000000000000000000000000000;;			x.decVar(ts.TempVar+pfx+ts.Rand, reflect.PtrTo(telem), false)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		funcs["var"] = func(s string) string {
0000000000000000000000000000000000000000;;			return ts.TempVar + s + ts.Rand
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tm, err := template.New("").Funcs(funcs).Parse(genDecMapTmpl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = tm.Execute(x.w, &ts); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decStructMapSwitch(kName string, varname string, rtid uintptr, t reflect.Type) {
0000000000000000000000000000000000000000;;		ti := x.ti.get(rtid, t)
0000000000000000000000000000000000000000;;		tisfi := ti.sfip // always use sequence from file. decStruct expects same thing.
0000000000000000000000000000000000000000;;		x.line("switch (" + kName + ") {")
0000000000000000000000000000000000000000;;		for _, si := range tisfi {
0000000000000000000000000000000000000000;;			x.line("case \"" + si.encName + "\":")
0000000000000000000000000000000000000000;;			var t2 reflect.StructField
0000000000000000000000000000000000000000;;			if si.i != -1 {
0000000000000000000000000000000000000000;;				t2 = t.Field(int(si.i))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				//we must accommodate anonymous fields, where the embedded field is a nil pointer in the value.
0000000000000000000000000000000000000000;;				// t2 = t.FieldByIndex(si.is)
0000000000000000000000000000000000000000;;				t2typ := t
0000000000000000000000000000000000000000;;				varname3 := varname
0000000000000000000000000000000000000000;;				for _, ix := range si.is {
0000000000000000000000000000000000000000;;					for t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						t2typ = t2typ.Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t2 = t2typ.Field(ix)
0000000000000000000000000000000000000000;;					t2typ = t2.Type
0000000000000000000000000000000000000000;;					varname3 = varname3 + "." + t2.Name
0000000000000000000000000000000000000000;;					if t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						x.linef("if %s == nil { %s = new(%s) }", varname3, varname3, x.genTypeName(t2typ.Elem()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x.decVar(varname+"."+t2.Name, t2.Type, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line("default:")
0000000000000000000000000000000000000000;;		// pass the slice here, so that the string will not escape, and maybe save allocation
0000000000000000000000000000000000000000;;		x.line("z.DecStructFieldNotFound(-1, " + kName + ")")
0000000000000000000000000000000000000000;;		x.line("} // end switch " + kName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decStructMap(varname, lenvarname string, rtid uintptr, t reflect.Type, style genStructMapStyle) {
0000000000000000000000000000000000000000;;		tpfx := genTempVarPfx
0000000000000000000000000000000000000000;;		i := x.varsfx()
0000000000000000000000000000000000000000;;		kName := tpfx + "s" + i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We thought to use ReadStringAsBytes, as go compiler might optimize the copy out.
0000000000000000000000000000000000000000;;		// However, using that was more expensive, as it seems that the switch expression
0000000000000000000000000000000000000000;;		// is evaluated each time.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We could depend on decodeString using a temporary/shared buffer internally.
0000000000000000000000000000000000000000;;		// However, this model of creating a byte array, and using explicitly is faster,
0000000000000000000000000000000000000000;;		// and allows optional use of unsafe []byte->string conversion without alloc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Also, ensure that the slice array doesn't escape.
0000000000000000000000000000000000000000;;		// That will help escape analysis prevent allocation when it gets better.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// x.line("var " + kName + "Arr = [32]byte{} // default string to decode into")
0000000000000000000000000000000000000000;;		// x.line("var " + kName + "Slc = " + kName + "Arr[:] // default slice to decode into")
0000000000000000000000000000000000000000;;		// use the scratch buffer to avoid allocation (most field names are < 32).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.line("var " + kName + "Slc = z.DecScratchBuffer() // default slice to decode into")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.line("_ = " + kName + "Slc")
0000000000000000000000000000000000000000;;		switch style {
0000000000000000000000000000000000000000;;		case genStructMapStyleLenPrefix:
0000000000000000000000000000000000000000;;			x.linef("for %sj%s := 0; %sj%s < %s; %sj%s++ {", tpfx, i, tpfx, i, lenvarname, tpfx, i)
0000000000000000000000000000000000000000;;		case genStructMapStyleCheckBreak:
0000000000000000000000000000000000000000;;			x.linef("for %sj%s := 0; !r.CheckBreak(); %sj%s++ {", tpfx, i, tpfx, i)
0000000000000000000000000000000000000000;;		default: // 0, otherwise.
0000000000000000000000000000000000000000;;			x.linef("var %shl%s bool = %s >= 0", tpfx, i, lenvarname) // has length
0000000000000000000000000000000000000000;;			x.linef("for %sj%s := 0; ; %sj%s++ {", tpfx, i, tpfx, i)
0000000000000000000000000000000000000000;;			x.linef("if %shl%s { if %sj%s >= %s { break }", tpfx, i, tpfx, i, lenvarname)
0000000000000000000000000000000000000000;;			x.line("} else { if r.CheckBreak() { break }; }")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.linef("z.DecSendContainerState(codecSelfer_containerMapKey%s)", x.xs)
0000000000000000000000000000000000000000;;		x.line(kName + "Slc = r.DecodeBytes(" + kName + "Slc, true, true)")
0000000000000000000000000000000000000000;;		// let string be scoped to this loop alone, so it doesn't escape.
0000000000000000000000000000000000000000;;		if x.unsafe {
0000000000000000000000000000000000000000;;			x.line(kName + "SlcHdr := codecSelferUnsafeString" + x.xs + "{uintptr(unsafe.Pointer(&" +
0000000000000000000000000000000000000000;;				kName + "Slc[0])), len(" + kName + "Slc)}")
0000000000000000000000000000000000000000;;			x.line(kName + " := *(*string)(unsafe.Pointer(&" + kName + "SlcHdr))")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.line(kName + " := string(" + kName + "Slc)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.linef("z.DecSendContainerState(codecSelfer_containerMapValue%s)", x.xs)
0000000000000000000000000000000000000000;;		x.decStructMapSwitch(kName, varname, rtid, t)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.line("} // end for " + tpfx + "j" + i)
0000000000000000000000000000000000000000;;		x.linef("z.DecSendContainerState(codecSelfer_containerMapEnd%s)", x.xs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decStructArray(varname, lenvarname, breakString string, rtid uintptr, t reflect.Type) {
0000000000000000000000000000000000000000;;		tpfx := genTempVarPfx
0000000000000000000000000000000000000000;;		i := x.varsfx()
0000000000000000000000000000000000000000;;		ti := x.ti.get(rtid, t)
0000000000000000000000000000000000000000;;		tisfi := ti.sfip // always use sequence from file. decStruct expects same thing.
0000000000000000000000000000000000000000;;		x.linef("var %sj%s int", tpfx, i)
0000000000000000000000000000000000000000;;		x.linef("var %sb%s bool", tpfx, i)                        // break
0000000000000000000000000000000000000000;;		x.linef("var %shl%s bool = %s >= 0", tpfx, i, lenvarname) // has length
0000000000000000000000000000000000000000;;		for _, si := range tisfi {
0000000000000000000000000000000000000000;;			var t2 reflect.StructField
0000000000000000000000000000000000000000;;			if si.i != -1 {
0000000000000000000000000000000000000000;;				t2 = t.Field(int(si.i))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				//we must accommodate anonymous fields, where the embedded field is a nil pointer in the value.
0000000000000000000000000000000000000000;;				// t2 = t.FieldByIndex(si.is)
0000000000000000000000000000000000000000;;				t2typ := t
0000000000000000000000000000000000000000;;				varname3 := varname
0000000000000000000000000000000000000000;;				for _, ix := range si.is {
0000000000000000000000000000000000000000;;					for t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						t2typ = t2typ.Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t2 = t2typ.Field(ix)
0000000000000000000000000000000000000000;;					t2typ = t2.Type
0000000000000000000000000000000000000000;;					varname3 = varname3 + "." + t2.Name
0000000000000000000000000000000000000000;;					if t2typ.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						x.linef("if %s == nil { %s = new(%s) }", varname3, varname3, x.genTypeName(t2typ.Elem()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			x.linef("%sj%s++; if %shl%s { %sb%s = %sj%s > %s } else { %sb%s = r.CheckBreak() }",
0000000000000000000000000000000000000000;;				tpfx, i, tpfx, i, tpfx, i,
0000000000000000000000000000000000000000;;				tpfx, i, lenvarname, tpfx, i)
0000000000000000000000000000000000000000;;			x.linef("if %sb%s { z.DecSendContainerState(codecSelfer_containerArrayEnd%s); %s }",
0000000000000000000000000000000000000000;;				tpfx, i, x.xs, breakString)
0000000000000000000000000000000000000000;;			x.linef("z.DecSendContainerState(codecSelfer_containerArrayElem%s)", x.xs)
0000000000000000000000000000000000000000;;			x.decVar(varname+"."+t2.Name, t2.Type, true)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// read remaining values and throw away.
0000000000000000000000000000000000000000;;		x.line("for {")
0000000000000000000000000000000000000000;;		x.linef("%sj%s++; if %shl%s { %sb%s = %sj%s > %s } else { %sb%s = r.CheckBreak() }",
0000000000000000000000000000000000000000;;			tpfx, i, tpfx, i, tpfx, i,
0000000000000000000000000000000000000000;;			tpfx, i, lenvarname, tpfx, i)
0000000000000000000000000000000000000000;;		x.linef("if %sb%s { break }", tpfx, i)
0000000000000000000000000000000000000000;;		x.linef("z.DecSendContainerState(codecSelfer_containerArrayElem%s)", x.xs)
0000000000000000000000000000000000000000;;		x.linef(`z.DecStructFieldNotFound(%sj%s - 1, "")`, tpfx, i)
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;		x.linef("z.DecSendContainerState(codecSelfer_containerArrayEnd%s)", x.xs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) decStruct(varname string, rtid uintptr, t reflect.Type) {
0000000000000000000000000000000000000000;;		// if container is map
0000000000000000000000000000000000000000;;		i := x.varsfx()
0000000000000000000000000000000000000000;;		x.linef("%sct%s := r.ContainerType()", genTempVarPfx, i)
0000000000000000000000000000000000000000;;		x.linef("if %sct%s == codecSelferValueTypeMap%s {", genTempVarPfx, i, x.xs)
0000000000000000000000000000000000000000;;		x.line(genTempVarPfx + "l" + i + " := r.ReadMapStart()")
0000000000000000000000000000000000000000;;		x.linef("if %sl%s == 0 {", genTempVarPfx, i)
0000000000000000000000000000000000000000;;		x.linef("z.DecSendContainerState(codecSelfer_containerMapEnd%s)", x.xs)
0000000000000000000000000000000000000000;;		if genUseOneFunctionForDecStructMap {
0000000000000000000000000000000000000000;;			x.line("} else { ")
0000000000000000000000000000000000000000;;			x.linef("x.codecDecodeSelfFromMap(%sl%s, d)", genTempVarPfx, i)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			x.line("} else if " + genTempVarPfx + "l" + i + " > 0 { ")
0000000000000000000000000000000000000000;;			x.line("x.codecDecodeSelfFromMapLenPrefix(" + genTempVarPfx + "l" + i + ", d)")
0000000000000000000000000000000000000000;;			x.line("} else {")
0000000000000000000000000000000000000000;;			x.line("x.codecDecodeSelfFromMapCheckBreak(" + genTempVarPfx + "l" + i + ", d)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// else if container is array
0000000000000000000000000000000000000000;;		x.linef("} else if %sct%s == codecSelferValueTypeArray%s {", genTempVarPfx, i, x.xs)
0000000000000000000000000000000000000000;;		x.line(genTempVarPfx + "l" + i + " := r.ReadArrayStart()")
0000000000000000000000000000000000000000;;		x.linef("if %sl%s == 0 {", genTempVarPfx, i)
0000000000000000000000000000000000000000;;		x.linef("z.DecSendContainerState(codecSelfer_containerArrayEnd%s)", x.xs)
0000000000000000000000000000000000000000;;		x.line("} else { ")
0000000000000000000000000000000000000000;;		x.linef("x.codecDecodeSelfFromArray(%sl%s, d)", genTempVarPfx, i)
0000000000000000000000000000000000000000;;		x.line("}")
0000000000000000000000000000000000000000;;		// else panic
0000000000000000000000000000000000000000;;		x.line("} else { ")
0000000000000000000000000000000000000000;;		x.line("panic(codecSelferOnlyMapOrArrayEncodeToStructErr" + x.xs + ")")
0000000000000000000000000000000000000000;;		x.line("} ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// --------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genV struct {
0000000000000000000000000000000000000000;;		// genV is either a primitive (Primitive != "") or a map (MapKey != "") or a slice
0000000000000000000000000000000000000000;;		MapKey    string
0000000000000000000000000000000000000000;;		Elem      string
0000000000000000000000000000000000000000;;		Primitive string
0000000000000000000000000000000000000000;;		Size      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genRunner) newGenV(t reflect.Type) (v genV) {
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice, reflect.Array:
0000000000000000000000000000000000000000;;			te := t.Elem()
0000000000000000000000000000000000000000;;			v.Elem = x.genTypeName(te)
0000000000000000000000000000000000000000;;			v.Size = int(te.Size())
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			te, tk := t.Elem(), t.Key()
0000000000000000000000000000000000000000;;			v.Elem = x.genTypeName(te)
0000000000000000000000000000000000000000;;			v.MapKey = x.genTypeName(tk)
0000000000000000000000000000000000000000;;			v.Size = int(te.Size() + tk.Size())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("unexpected type for newGenV. Requires map or slice type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *genV) MethodNamePfx(prefix string, prim bool) string {
0000000000000000000000000000000000000000;;		var name []byte
0000000000000000000000000000000000000000;;		if prefix != "" {
0000000000000000000000000000000000000000;;			name = append(name, prefix...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if prim {
0000000000000000000000000000000000000000;;			name = append(name, genTitleCaseName(x.Primitive)...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if x.MapKey == "" {
0000000000000000000000000000000000000000;;				name = append(name, "Slice"...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				name = append(name, "Map"...)
0000000000000000000000000000000000000000;;				name = append(name, genTitleCaseName(x.MapKey)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = append(name, genTitleCaseName(x.Elem)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genImportPath returns import path of a non-predeclared named typed, or an empty string otherwise.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This handles the misbehaviour that occurs when 1.5-style vendoring is enabled,
0000000000000000000000000000000000000000;;	// where PkgPath returns the full path, including the vendoring pre-fix that should have been stripped.
0000000000000000000000000000000000000000;;	// We strip it here.
0000000000000000000000000000000000000000;;	func genImportPath(t reflect.Type) (s string) {
0000000000000000000000000000000000000000;;		s = t.PkgPath()
0000000000000000000000000000000000000000;;		if genCheckVendor {
0000000000000000000000000000000000000000;;			// HACK: Misbehaviour occurs in go 1.5. May have to re-visit this later.
0000000000000000000000000000000000000000;;			// if s contains /vendor/ OR startsWith vendor/, then return everything after it.
0000000000000000000000000000000000000000;;			const vendorStart = "vendor/"
0000000000000000000000000000000000000000;;			const vendorInline = "/vendor/"
0000000000000000000000000000000000000000;;			if i := strings.LastIndex(s, vendorInline); i >= 0 {
0000000000000000000000000000000000000000;;				s = s[i+len(vendorInline):]
0000000000000000000000000000000000000000;;			} else if strings.HasPrefix(s, vendorStart) {
0000000000000000000000000000000000000000;;				s = s[len(vendorStart):]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A go identifier is (letter|_)[letter|number|_]*
0000000000000000000000000000000000000000;;	func genGoIdentifier(s string, checkFirstChar bool) string {
0000000000000000000000000000000000000000;;		b := make([]byte, 0, len(s))
0000000000000000000000000000000000000000;;		t := make([]byte, 4)
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		for i, r := range s {
0000000000000000000000000000000000000000;;			if checkFirstChar && i == 0 && !unicode.IsLetter(r) {
0000000000000000000000000000000000000000;;				b = append(b, '_')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// r must be unicode_letter, unicode_digit or _
0000000000000000000000000000000000000000;;			if unicode.IsLetter(r) || unicode.IsDigit(r) {
0000000000000000000000000000000000000000;;				n = utf8.EncodeRune(t, r)
0000000000000000000000000000000000000000;;				b = append(b, t[:n]...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				b = append(b, '_')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genNonPtr(t reflect.Type) reflect.Type {
0000000000000000000000000000000000000000;;		for t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genTitleCaseName(s string) string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "interface{}", "interface {}":
0000000000000000000000000000000000000000;;			return "Intf"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return strings.ToUpper(s[0:1]) + s[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genMethodNameT(t reflect.Type, tRef reflect.Type) (n string) {
0000000000000000000000000000000000000000;;		var ptrPfx string
0000000000000000000000000000000000000000;;		for t.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			ptrPfx += "Ptrto"
0000000000000000000000000000000000000000;;			t = t.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tstr := t.String()
0000000000000000000000000000000000000000;;		if tn := t.Name(); tn != "" {
0000000000000000000000000000000000000000;;			if tRef != nil && genImportPath(t) == genImportPath(tRef) {
0000000000000000000000000000000000000000;;				return ptrPfx + tn
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if genQNameRegex.MatchString(tstr) {
0000000000000000000000000000000000000000;;					return ptrPfx + strings.Replace(tstr, ".", "_", 1000)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return ptrPfx + genCustomTypeName(tstr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			return ptrPfx + "Map" + genMethodNameT(t.Key(), tRef) + genMethodNameT(t.Elem(), tRef)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return ptrPfx + "Slice" + genMethodNameT(t.Elem(), tRef)
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			return ptrPfx + "Array" + strconv.FormatInt(int64(t.Len()), 10) + genMethodNameT(t.Elem(), tRef)
0000000000000000000000000000000000000000;;		case reflect.Chan:
0000000000000000000000000000000000000000;;			var cx string
0000000000000000000000000000000000000000;;			switch t.ChanDir() {
0000000000000000000000000000000000000000;;			case reflect.SendDir:
0000000000000000000000000000000000000000;;				cx = "ChanSend"
0000000000000000000000000000000000000000;;			case reflect.RecvDir:
0000000000000000000000000000000000000000;;				cx = "ChanRecv"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				cx = "Chan"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ptrPfx + cx + genMethodNameT(t.Elem(), tRef)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if t == intfTyp {
0000000000000000000000000000000000000000;;				return ptrPfx + "Interface"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if tRef != nil && genImportPath(t) == genImportPath(tRef) {
0000000000000000000000000000000000000000;;					if t.Name() != "" {
0000000000000000000000000000000000000000;;						return ptrPfx + t.Name()
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return ptrPfx + genCustomTypeName(tstr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// best way to get the package name inclusive
0000000000000000000000000000000000000000;;					// return ptrPfx + strings.Replace(tstr, ".", "_", 1000)
0000000000000000000000000000000000000000;;					// return ptrPfx + genBase64enc.EncodeToString([]byte(tstr))
0000000000000000000000000000000000000000;;					if t.Name() != "" && genQNameRegex.MatchString(tstr) {
0000000000000000000000000000000000000000;;						return ptrPfx + strings.Replace(tstr, ".", "_", 1000)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return ptrPfx + genCustomTypeName(tstr)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genCustomNameForType base64encodes the t.String() value in such a way
0000000000000000000000000000000000000000;;	// that it can be used within a function name.
0000000000000000000000000000000000000000;;	func genCustomTypeName(tstr string) string {
0000000000000000000000000000000000000000;;		len2 := genBase64enc.EncodedLen(len(tstr))
0000000000000000000000000000000000000000;;		bufx := make([]byte, len2)
0000000000000000000000000000000000000000;;		genBase64enc.Encode(bufx, []byte(tstr))
0000000000000000000000000000000000000000;;		for i := len2 - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if bufx[i] == '=' {
0000000000000000000000000000000000000000;;				len2--
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(bufx[:len2])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genIsImmutable(t reflect.Type) (v bool) {
0000000000000000000000000000000000000000;;		return isImmutableKind(t.Kind())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genInternal struct {
0000000000000000000000000000000000000000;;		Values []genV
0000000000000000000000000000000000000000;;		Unsafe bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x genInternal) FastpathLen() (l int) {
0000000000000000000000000000000000000000;;		for _, v := range x.Values {
0000000000000000000000000000000000000000;;			if v.Primitive == "" {
0000000000000000000000000000000000000000;;				l++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genInternalZeroValue(s string) string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "interface{}", "interface {}":
0000000000000000000000000000000000000000;;			return "nil"
0000000000000000000000000000000000000000;;		case "bool":
0000000000000000000000000000000000000000;;			return "false"
0000000000000000000000000000000000000000;;		case "string":
0000000000000000000000000000000000000000;;			return `""`
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "0"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genInternalEncCommandAsString(s string, vname string) string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "uint", "uint8", "uint16", "uint32", "uint64":
0000000000000000000000000000000000000000;;			return "ee.EncodeUint(uint64(" + vname + "))"
0000000000000000000000000000000000000000;;		case "int", "int8", "int16", "int32", "int64":
0000000000000000000000000000000000000000;;			return "ee.EncodeInt(int64(" + vname + "))"
0000000000000000000000000000000000000000;;		case "string":
0000000000000000000000000000000000000000;;			return "ee.EncodeString(c_UTF8, " + vname + ")"
0000000000000000000000000000000000000000;;		case "float32":
0000000000000000000000000000000000000000;;			return "ee.EncodeFloat32(" + vname + ")"
0000000000000000000000000000000000000000;;		case "float64":
0000000000000000000000000000000000000000;;			return "ee.EncodeFloat64(" + vname + ")"
0000000000000000000000000000000000000000;;		case "bool":
0000000000000000000000000000000000000000;;			return "ee.EncodeBool(" + vname + ")"
0000000000000000000000000000000000000000;;		case "symbol":
0000000000000000000000000000000000000000;;			return "ee.EncodeSymbol(" + vname + ")"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "e.encode(" + vname + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genInternalDecCommandAsString(s string) string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "uint":
0000000000000000000000000000000000000000;;			return "uint(dd.DecodeUint(uintBitsize))"
0000000000000000000000000000000000000000;;		case "uint8":
0000000000000000000000000000000000000000;;			return "uint8(dd.DecodeUint(8))"
0000000000000000000000000000000000000000;;		case "uint16":
0000000000000000000000000000000000000000;;			return "uint16(dd.DecodeUint(16))"
0000000000000000000000000000000000000000;;		case "uint32":
0000000000000000000000000000000000000000;;			return "uint32(dd.DecodeUint(32))"
0000000000000000000000000000000000000000;;		case "uint64":
0000000000000000000000000000000000000000;;			return "dd.DecodeUint(64)"
0000000000000000000000000000000000000000;;		case "uintptr":
0000000000000000000000000000000000000000;;			return "uintptr(dd.DecodeUint(uintBitsize))"
0000000000000000000000000000000000000000;;		case "int":
0000000000000000000000000000000000000000;;			return "int(dd.DecodeInt(intBitsize))"
0000000000000000000000000000000000000000;;		case "int8":
0000000000000000000000000000000000000000;;			return "int8(dd.DecodeInt(8))"
0000000000000000000000000000000000000000;;		case "int16":
0000000000000000000000000000000000000000;;			return "int16(dd.DecodeInt(16))"
0000000000000000000000000000000000000000;;		case "int32":
0000000000000000000000000000000000000000;;			return "int32(dd.DecodeInt(32))"
0000000000000000000000000000000000000000;;		case "int64":
0000000000000000000000000000000000000000;;			return "dd.DecodeInt(64)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case "string":
0000000000000000000000000000000000000000;;			return "dd.DecodeString()"
0000000000000000000000000000000000000000;;		case "float32":
0000000000000000000000000000000000000000;;			return "float32(dd.DecodeFloat(true))"
0000000000000000000000000000000000000000;;		case "float64":
0000000000000000000000000000000000000000;;			return "dd.DecodeFloat(false)"
0000000000000000000000000000000000000000;;		case "bool":
0000000000000000000000000000000000000000;;			return "dd.DecodeBool()"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(errors.New("gen internal: unknown type for decode: " + s))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genInternalSortType(s string, elem bool) string {
0000000000000000000000000000000000000000;;		for _, v := range [...]string{"int", "uint", "float", "bool", "string"} {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(s, v) {
0000000000000000000000000000000000000000;;				if elem {
0000000000000000000000000000000000000000;;					if v == "int" || v == "uint" || v == "float" {
0000000000000000000000000000000000000000;;						return v + "64"
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return v
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return v + "Slice"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("sorttype: unexpected type: " + s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// var genInternalMu sync.Mutex
0000000000000000000000000000000000000000;;	var genInternalV genInternal
0000000000000000000000000000000000000000;;	var genInternalTmplFuncs template.FuncMap
0000000000000000000000000000000000000000;;	var genInternalOnce sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func genInternalInit() {
0000000000000000000000000000000000000000;;		types := [...]string{
0000000000000000000000000000000000000000;;			"interface{}",
0000000000000000000000000000000000000000;;			"string",
0000000000000000000000000000000000000000;;			"float32",
0000000000000000000000000000000000000000;;			"float64",
0000000000000000000000000000000000000000;;			"uint",
0000000000000000000000000000000000000000;;			"uint8",
0000000000000000000000000000000000000000;;			"uint16",
0000000000000000000000000000000000000000;;			"uint32",
0000000000000000000000000000000000000000;;			"uint64",
0000000000000000000000000000000000000000;;			"uintptr",
0000000000000000000000000000000000000000;;			"int",
0000000000000000000000000000000000000000;;			"int8",
0000000000000000000000000000000000000000;;			"int16",
0000000000000000000000000000000000000000;;			"int32",
0000000000000000000000000000000000000000;;			"int64",
0000000000000000000000000000000000000000;;			"bool",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// keep as slice, so it is in specific iteration order.
0000000000000000000000000000000000000000;;		// Initial order was uint64, string, interface{}, int, int64
0000000000000000000000000000000000000000;;		mapvaltypes := [...]string{
0000000000000000000000000000000000000000;;			"interface{}",
0000000000000000000000000000000000000000;;			"string",
0000000000000000000000000000000000000000;;			"uint",
0000000000000000000000000000000000000000;;			"uint8",
0000000000000000000000000000000000000000;;			"uint16",
0000000000000000000000000000000000000000;;			"uint32",
0000000000000000000000000000000000000000;;			"uint64",
0000000000000000000000000000000000000000;;			"uintptr",
0000000000000000000000000000000000000000;;			"int",
0000000000000000000000000000000000000000;;			"int8",
0000000000000000000000000000000000000000;;			"int16",
0000000000000000000000000000000000000000;;			"int32",
0000000000000000000000000000000000000000;;			"int64",
0000000000000000000000000000000000000000;;			"float32",
0000000000000000000000000000000000000000;;			"float64",
0000000000000000000000000000000000000000;;			"bool",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wordSizeBytes := int(intBitsize) / 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapvaltypes2 := map[string]int{
0000000000000000000000000000000000000000;;			"interface{}": 2 * wordSizeBytes,
0000000000000000000000000000000000000000;;			"string":      2 * wordSizeBytes,
0000000000000000000000000000000000000000;;			"uint":        1 * wordSizeBytes,
0000000000000000000000000000000000000000;;			"uint8":       1,
0000000000000000000000000000000000000000;;			"uint16":      2,
0000000000000000000000000000000000000000;;			"uint32":      4,
0000000000000000000000000000000000000000;;			"uint64":      8,
0000000000000000000000000000000000000000;;			"uintptr":     1 * wordSizeBytes,
0000000000000000000000000000000000000000;;			"int":         1 * wordSizeBytes,
0000000000000000000000000000000000000000;;			"int8":        1,
0000000000000000000000000000000000000000;;			"int16":       2,
0000000000000000000000000000000000000000;;			"int32":       4,
0000000000000000000000000000000000000000;;			"int64":       8,
0000000000000000000000000000000000000000;;			"float32":     4,
0000000000000000000000000000000000000000;;			"float64":     8,
0000000000000000000000000000000000000000;;			"bool":        1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var gt genInternal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For each slice or map type, there must be a (symmetrical) Encode and Decode fast-path function
0000000000000000000000000000000000000000;;		for _, s := range types {
0000000000000000000000000000000000000000;;			gt.Values = append(gt.Values, genV{Primitive: s, Size: mapvaltypes2[s]})
0000000000000000000000000000000000000000;;			if s != "uint8" { // do not generate fast path for slice of bytes. Treat specially already.
0000000000000000000000000000000000000000;;				gt.Values = append(gt.Values, genV{Elem: s, Size: mapvaltypes2[s]})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := mapvaltypes2[s]; !ok {
0000000000000000000000000000000000000000;;				gt.Values = append(gt.Values, genV{MapKey: s, Elem: s, Size: 2 * mapvaltypes2[s]})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ms := range mapvaltypes {
0000000000000000000000000000000000000000;;				gt.Values = append(gt.Values, genV{MapKey: s, Elem: ms, Size: mapvaltypes2[s] + mapvaltypes2[ms]})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		funcs := make(template.FuncMap)
0000000000000000000000000000000000000000;;		// funcs["haspfx"] = strings.HasPrefix
0000000000000000000000000000000000000000;;		funcs["encmd"] = genInternalEncCommandAsString
0000000000000000000000000000000000000000;;		funcs["decmd"] = genInternalDecCommandAsString
0000000000000000000000000000000000000000;;		funcs["zerocmd"] = genInternalZeroValue
0000000000000000000000000000000000000000;;		funcs["hasprefix"] = strings.HasPrefix
0000000000000000000000000000000000000000;;		funcs["sorttype"] = genInternalSortType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		genInternalV = gt
0000000000000000000000000000000000000000;;		genInternalTmplFuncs = funcs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// genInternalGoFile is used to generate source files from templates.
0000000000000000000000000000000000000000;;	// It is run by the program author alone.
0000000000000000000000000000000000000000;;	// Unfortunately, it has to be exported so that it can be called from a command line tool.
0000000000000000000000000000000000000000;;	// *** DO NOT USE ***
0000000000000000000000000000000000000000;;	func genInternalGoFile(r io.Reader, w io.Writer, safe bool) (err error) {
0000000000000000000000000000000000000000;;		genInternalOnce.Do(genInternalInit)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gt := genInternalV
0000000000000000000000000000000000000000;;		gt.Unsafe = !safe
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := template.New("").Funcs(genInternalTmplFuncs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmplstr, err := ioutil.ReadAll(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t, err = t.Parse(string(tmplstr)); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out bytes.Buffer
0000000000000000000000000000000000000000;;		err = t.Execute(&out, gt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bout, err := format.Source(out.Bytes())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			w.Write(out.Bytes()) // write out if error, so we can still see.
0000000000000000000000000000000000000000;;			// w.Write(bout) // write out if error, as much as possible, so we can still see.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write(bout)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
