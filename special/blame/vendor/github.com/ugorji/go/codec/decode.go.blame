0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/decode.go[Godeps/_workspace/src/github.com/ugorji/go/codec/decode.go][vendor/github.com/ugorji/go/codec/decode.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Some tagging information for error messages.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		msgBadDesc            = "Unrecognized descriptor byte"
0000000000000000000000000000000000000000;;		msgDecCannotExpandArr = "cannot expand go array from %v to stream length: %v"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		onlyMapOrArrayCanDecodeIntoStructErr = errors.New("only encoded map or array can be decoded into a struct")
0000000000000000000000000000000000000000;;		cannotDecodeIntoNilErr               = errors.New("cannot decode into nil")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decReader abstracts the reading source, allowing implementations that can
0000000000000000000000000000000000000000;;	// read from an io.Reader or directly off a byte slice with zero-copying.
0000000000000000000000000000000000000000;;	type decReader interface {
0000000000000000000000000000000000000000;;		unreadn1()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// readx will use the implementation scratch buffer if possible i.e. n < len(scratchbuf), OR
0000000000000000000000000000000000000000;;		// just return a view of the []byte being decoded from.
0000000000000000000000000000000000000000;;		// Ensure you call detachZeroCopyBytes later if this needs to be sent outside codec control.
0000000000000000000000000000000000000000;;		readx(n int) []byte
0000000000000000000000000000000000000000;;		readb([]byte)
0000000000000000000000000000000000000000;;		readn1() uint8
0000000000000000000000000000000000000000;;		readn1eof() (v uint8, eof bool)
0000000000000000000000000000000000000000;;		numread() int // number of bytes read
0000000000000000000000000000000000000000;;		track()
0000000000000000000000000000000000000000;;		stopTrack() []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decReaderByteScanner interface {
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;		io.ByteScanner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decDriver interface {
0000000000000000000000000000000000000000;;		// this will check if the next token is a break.
0000000000000000000000000000000000000000;;		CheckBreak() bool
0000000000000000000000000000000000000000;;		TryDecodeAsNil() bool
0000000000000000000000000000000000000000;;		// vt is one of: Bytes, String, Nil, Slice or Map. Return unSet if not known.
0000000000000000000000000000000000000000;;		ContainerType() (vt valueType)
0000000000000000000000000000000000000000;;		IsBuiltinType(rt uintptr) bool
0000000000000000000000000000000000000000;;		DecodeBuiltin(rt uintptr, v interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DecodeNaked will decode primitives (number, bool, string, []byte) and RawExt.
0000000000000000000000000000000000000000;;		// For maps and arrays, it will not do the decoding in-band, but will signal
0000000000000000000000000000000000000000;;		// the decoder, so that is done later, by setting the decNaked.valueType field.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note: Numbers are decoded as int64, uint64, float64 only (no smaller sized number types).
0000000000000000000000000000000000000000;;		// for extensions, DecodeNaked must read the tag and the []byte if it exists.
0000000000000000000000000000000000000000;;		// if the []byte is not read, then kInterfaceNaked will treat it as a Handle
0000000000000000000000000000000000000000;;		// that stores the subsequent value in-band, and complete reading the RawExt.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// extensions should also use readx to decode them, for efficiency.
0000000000000000000000000000000000000000;;		// kInterface will extract the detached byte slice if it has to pass it outside its realm.
0000000000000000000000000000000000000000;;		DecodeNaked()
0000000000000000000000000000000000000000;;		DecodeInt(bitsize uint8) (i int64)
0000000000000000000000000000000000000000;;		DecodeUint(bitsize uint8) (ui uint64)
0000000000000000000000000000000000000000;;		DecodeFloat(chkOverflow32 bool) (f float64)
0000000000000000000000000000000000000000;;		DecodeBool() (b bool)
0000000000000000000000000000000000000000;;		// DecodeString can also decode symbols.
0000000000000000000000000000000000000000;;		// It looks redundant as DecodeBytes is available.
0000000000000000000000000000000000000000;;		// However, some codecs (e.g. binc) support symbols and can
0000000000000000000000000000000000000000;;		// return a pre-stored string value, meaning that it can bypass
0000000000000000000000000000000000000000;;		// the cost of []byte->string conversion.
0000000000000000000000000000000000000000;;		DecodeString() (s string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DecodeBytes may be called directly, without going through reflection.
0000000000000000000000000000000000000000;;		// Consequently, it must be designed to handle possible nil.
0000000000000000000000000000000000000000;;		DecodeBytes(bs []byte, isstring, zerocopy bool) (bsOut []byte)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// decodeExt will decode into a *RawExt or into an extension.
0000000000000000000000000000000000000000;;		DecodeExt(v interface{}, xtag uint64, ext Ext) (realxtag uint64)
0000000000000000000000000000000000000000;;		// decodeExt(verifyTag bool, tag byte) (xtag byte, xbs []byte)
0000000000000000000000000000000000000000;;		ReadMapStart() int
0000000000000000000000000000000000000000;;		ReadArrayStart() int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reset()
0000000000000000000000000000000000000000;;		uncacheRead()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decNoSeparator struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ decNoSeparator) ReadEnd() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (_ decNoSeparator) uncacheRead() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DecodeOptions struct {
0000000000000000000000000000000000000000;;		// MapType specifies type to use during schema-less decoding of a map in the stream.
0000000000000000000000000000000000000000;;		// If nil, we use map[interface{}]interface{}
0000000000000000000000000000000000000000;;		MapType reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SliceType specifies type to use during schema-less decoding of an array in the stream.
0000000000000000000000000000000000000000;;		// If nil, we use []interface{}
0000000000000000000000000000000000000000;;		SliceType reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxInitLen defines the initial length that we "make" a collection (slice, chan or map) with.
0000000000000000000000000000000000000000;;		// If 0 or negative, we default to a sensible value based on the size of an element in the collection.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// For example, when decoding, a stream may say that it has MAX_UINT elements.
0000000000000000000000000000000000000000;;		// We should not auto-matically provision a slice of that length, to prevent Out-Of-Memory crash.
0000000000000000000000000000000000000000;;		// Instead, we provision up to MaxInitLen, fill that up, and start appending after that.
0000000000000000000000000000000000000000;;		MaxInitLen int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If ErrorIfNoField, return an error when decoding a map
0000000000000000000000000000000000000000;;		// from a codec stream into a struct, and no matching struct field is found.
0000000000000000000000000000000000000000;;		ErrorIfNoField bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If ErrorIfNoArrayExpand, return an error when decoding a slice/array that cannot be expanded.
0000000000000000000000000000000000000000;;		// For example, the stream contains an array of 8 items, but you are decoding into a [4]T array,
0000000000000000000000000000000000000000;;		// or you are decoding into a slice of length 4 which is non-addressable (and so cannot be set).
0000000000000000000000000000000000000000;;		ErrorIfNoArrayExpand bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If SignedInteger, use the int64 during schema-less decoding of unsigned values (not uint64).
0000000000000000000000000000000000000000;;		SignedInteger bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MapValueReset controls how we decode into a map value.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// By default, we MAY retrieve the mapping for a key, and then decode into that.
0000000000000000000000000000000000000000;;		// However, especially with big maps, that retrieval may be expensive and unnecessary
0000000000000000000000000000000000000000;;		// if the stream already contains all that is necessary to recreate the value.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If true, we will never retrieve the previous mapping,
0000000000000000000000000000000000000000;;		// but rather decode into a new value and set that in the map.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If false, we will retrieve the previous mapping if necessary e.g.
0000000000000000000000000000000000000000;;		// the previous mapping is a pointer, or is a struct or array with pre-set state,
0000000000000000000000000000000000000000;;		// or is an interface.
0000000000000000000000000000000000000000;;		MapValueReset bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InterfaceReset controls how we decode into an interface.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// By default, when we see a field that is an interface{...},
0000000000000000000000000000000000000000;;		// or a map with interface{...} value, we will attempt decoding into the
0000000000000000000000000000000000000000;;		// "contained" value.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// However, this prevents us from reading a string into an interface{}
0000000000000000000000000000000000000000;;		// that formerly contained a number.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If true, we will decode into a new "blank" value, and set that in the interface.
0000000000000000000000000000000000000000;;		// If false, we will decode into whatever is contained in the interface.
0000000000000000000000000000000000000000;;		InterfaceReset bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InternString controls interning of strings during decoding.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Some handles, e.g. json, typically will read map keys as strings.
0000000000000000000000000000000000000000;;		// If the set of keys are finite, it may help reduce allocation to
0000000000000000000000000000000000000000;;		// look them up from a map (than to allocate them afresh).
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note: Handles will be smart when using the intern functionality.
0000000000000000000000000000000000000000;;		// So everything will not be interned.
0000000000000000000000000000000000000000;;		InternString bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PreferArrayOverSlice controls whether to decode to an array or a slice.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This only impacts decoding into a nil interface{}.
0000000000000000000000000000000000000000;;		// Consequently, it has no effect on codecgen.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// *Note*: This only applies if using go1.5 and above,
0000000000000000000000000000000000000000;;		// as it requires reflect.ArrayOf support which was absent before go1.5.
0000000000000000000000000000000000000000;;		PreferArrayOverSlice bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ioDecByteScanner implements Read(), ReadByte(...), UnreadByte(...) methods
0000000000000000000000000000000000000000;;	// of io.Reader, io.ByteScanner.
0000000000000000000000000000000000000000;;	type ioDecByteScanner struct {
0000000000000000000000000000000000000000;;		r  io.Reader
0000000000000000000000000000000000000000;;		l  byte    // last byte
0000000000000000000000000000000000000000;;		ls byte    // last byte status. 0: init-canDoNothing, 1: canRead, 2: canUnread
0000000000000000000000000000000000000000;;		b  [1]byte // tiny buffer for reading single bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecByteScanner) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		var firstByte bool
0000000000000000000000000000000000000000;;		if z.ls == 1 {
0000000000000000000000000000000000000000;;			z.ls = 2
0000000000000000000000000000000000000000;;			p[0] = z.l
0000000000000000000000000000000000000000;;			if len(p) == 1 {
0000000000000000000000000000000000000000;;				n = 1
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			firstByte = true
0000000000000000000000000000000000000000;;			p = p[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = z.r.Read(p)
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			if err == io.EOF && n == len(p) {
0000000000000000000000000000000000000000;;				err = nil // read was successful, so postpone EOF (till next time)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			z.l = p[n-1]
0000000000000000000000000000000000000000;;			z.ls = 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if firstByte {
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecByteScanner) ReadByte() (c byte, err error) {
0000000000000000000000000000000000000000;;		n, err := z.Read(z.b[:])
0000000000000000000000000000000000000000;;		if n == 1 {
0000000000000000000000000000000000000000;;			c = z.b[0]
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				err = nil // read was successful, so postpone EOF (till next time)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecByteScanner) UnreadByte() (err error) {
0000000000000000000000000000000000000000;;		x := z.ls
0000000000000000000000000000000000000000;;		if x == 0 {
0000000000000000000000000000000000000000;;			err = errors.New("cannot unread - nothing has been read")
0000000000000000000000000000000000000000;;		} else if x == 1 {
0000000000000000000000000000000000000000;;			err = errors.New("cannot unread - last byte has not been read")
0000000000000000000000000000000000000000;;		} else if x == 2 {
0000000000000000000000000000000000000000;;			z.ls = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ioDecReader is a decReader that reads off an io.Reader
0000000000000000000000000000000000000000;;	type ioDecReader struct {
0000000000000000000000000000000000000000;;		br decReaderByteScanner
0000000000000000000000000000000000000000;;		// temp byte array re-used internally for efficiency during read.
0000000000000000000000000000000000000000;;		// shares buffer with Decoder, so we keep size of struct within 8 words.
0000000000000000000000000000000000000000;;		x   *[scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;		bs  ioDecByteScanner
0000000000000000000000000000000000000000;;		n   int    // num read
0000000000000000000000000000000000000000;;		tr  []byte // tracking bytes read
0000000000000000000000000000000000000000;;		trb bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) numread() int {
0000000000000000000000000000000000000000;;		return z.n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) readx(n int) (bs []byte) {
0000000000000000000000000000000000000000;;		if n <= 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n < len(z.x) {
0000000000000000000000000000000000000000;;			bs = z.x[:n]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bs = make([]byte, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := io.ReadAtLeast(z.br, bs, n); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.n += len(bs)
0000000000000000000000000000000000000000;;		if z.trb {
0000000000000000000000000000000000000000;;			z.tr = append(z.tr, bs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) readb(bs []byte) {
0000000000000000000000000000000000000000;;		if len(bs) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := io.ReadAtLeast(z.br, bs, len(bs))
0000000000000000000000000000000000000000;;		z.n += n
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if z.trb {
0000000000000000000000000000000000000000;;			z.tr = append(z.tr, bs...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) readn1() (b uint8) {
0000000000000000000000000000000000000000;;		b, err := z.br.ReadByte()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.n++
0000000000000000000000000000000000000000;;		if z.trb {
0000000000000000000000000000000000000000;;			z.tr = append(z.tr, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) readn1eof() (b uint8, eof bool) {
0000000000000000000000000000000000000000;;		b, err := z.br.ReadByte()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			z.n++
0000000000000000000000000000000000000000;;			if z.trb {
0000000000000000000000000000000000000000;;				z.tr = append(z.tr, b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if err == io.EOF {
0000000000000000000000000000000000000000;;			eof = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) unreadn1() {
0000000000000000000000000000000000000000;;		err := z.br.UnreadByte()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.n--
0000000000000000000000000000000000000000;;		if z.trb {
0000000000000000000000000000000000000000;;			if l := len(z.tr) - 1; l >= 0 {
0000000000000000000000000000000000000000;;				z.tr = z.tr[:l]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) track() {
0000000000000000000000000000000000000000;;		if z.tr != nil {
0000000000000000000000000000000000000000;;			z.tr = z.tr[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.trb = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *ioDecReader) stopTrack() (bs []byte) {
0000000000000000000000000000000000000000;;		z.trb = false
0000000000000000000000000000000000000000;;		return z.tr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bytesDecReaderCannotUnreadErr = errors.New("cannot unread last byte read")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bytesDecReader is a decReader that reads off a byte slice with zero copying
0000000000000000000000000000000000000000;;	type bytesDecReader struct {
0000000000000000000000000000000000000000;;		b []byte // data
0000000000000000000000000000000000000000;;		c int    // cursor
0000000000000000000000000000000000000000;;		a int    // available
0000000000000000000000000000000000000000;;		t int    // track start
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) reset(in []byte) {
0000000000000000000000000000000000000000;;		z.b = in
0000000000000000000000000000000000000000;;		z.a = len(in)
0000000000000000000000000000000000000000;;		z.c = 0
0000000000000000000000000000000000000000;;		z.t = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) numread() int {
0000000000000000000000000000000000000000;;		return z.c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) unreadn1() {
0000000000000000000000000000000000000000;;		if z.c == 0 || len(z.b) == 0 {
0000000000000000000000000000000000000000;;			panic(bytesDecReaderCannotUnreadErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		z.c--
0000000000000000000000000000000000000000;;		z.a++
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) readx(n int) (bs []byte) {
0000000000000000000000000000000000000000;;		// slicing from a non-constant start position is more expensive,
0000000000000000000000000000000000000000;;		// as more computation is required to decipher the pointer start position.
0000000000000000000000000000000000000000;;		// However, we do it only once, and it's better than reslicing both z.b and return value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n <= 0 {
0000000000000000000000000000000000000000;;		} else if z.a == 0 {
0000000000000000000000000000000000000000;;			panic(io.EOF)
0000000000000000000000000000000000000000;;		} else if n > z.a {
0000000000000000000000000000000000000000;;			panic(io.ErrUnexpectedEOF)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c0 := z.c
0000000000000000000000000000000000000000;;			z.c = c0 + n
0000000000000000000000000000000000000000;;			z.a = z.a - n
0000000000000000000000000000000000000000;;			bs = z.b[c0:z.c]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) readn1() (v uint8) {
0000000000000000000000000000000000000000;;		if z.a == 0 {
0000000000000000000000000000000000000000;;			panic(io.EOF)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = z.b[z.c]
0000000000000000000000000000000000000000;;		z.c++
0000000000000000000000000000000000000000;;		z.a--
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) readn1eof() (v uint8, eof bool) {
0000000000000000000000000000000000000000;;		if z.a == 0 {
0000000000000000000000000000000000000000;;			eof = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = z.b[z.c]
0000000000000000000000000000000000000000;;		z.c++
0000000000000000000000000000000000000000;;		z.a--
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) readb(bs []byte) {
0000000000000000000000000000000000000000;;		copy(bs, z.readx(len(bs)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) track() {
0000000000000000000000000000000000000000;;		z.t = z.c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z *bytesDecReader) stopTrack() (bs []byte) {
0000000000000000000000000000000000000000;;		return z.b[z.t:z.c]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decFnInfo struct {
0000000000000000000000000000000000000000;;		d     *Decoder
0000000000000000000000000000000000000000;;		ti    *typeInfo
0000000000000000000000000000000000000000;;		xfFn  Ext
0000000000000000000000000000000000000000;;		xfTag uint64
0000000000000000000000000000000000000000;;		seq   seqType
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decFn struct {
0000000000000000000000000000000000000000;;		i decFnInfo
0000000000000000000000000000000000000000;;		f func(*decFnInfo, reflect.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) builtin(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.d.d.DecodeBuiltin(f.ti.rtid, rv.Addr().Interface())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) rawExt(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.d.d.DecodeExt(rv.Addr().Interface(), 0, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) raw(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetBytes(f.d.raw())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) ext(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.d.d.DecodeExt(rv.Addr().Interface(), f.xfTag, f.xfFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) getValueForUnmarshalInterface(rv reflect.Value, indir int8) (v interface{}) {
0000000000000000000000000000000000000000;;		if indir == -1 {
0000000000000000000000000000000000000000;;			v = rv.Addr().Interface()
0000000000000000000000000000000000000000;;		} else if indir == 0 {
0000000000000000000000000000000000000000;;			v = rv.Interface()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for j := int8(0); j < indir; j++ {
0000000000000000000000000000000000000000;;				if rv.IsNil() {
0000000000000000000000000000000000000000;;					rv.Set(reflect.New(rv.Type().Elem()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rv = rv.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = rv.Interface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) selferUnmarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.getValueForUnmarshalInterface(rv, f.ti.csIndir).(Selfer).CodecDecodeSelf(f.d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) binaryUnmarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		bm := f.getValueForUnmarshalInterface(rv, f.ti.bunmIndir).(encoding.BinaryUnmarshaler)
0000000000000000000000000000000000000000;;		xbs := f.d.d.DecodeBytes(nil, false, true)
0000000000000000000000000000000000000000;;		if fnerr := bm.UnmarshalBinary(xbs); fnerr != nil {
0000000000000000000000000000000000000000;;			panic(fnerr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) textUnmarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		tm := f.getValueForUnmarshalInterface(rv, f.ti.tunmIndir).(encoding.TextUnmarshaler)
0000000000000000000000000000000000000000;;		fnerr := tm.UnmarshalText(f.d.d.DecodeBytes(f.d.b[:], true, true))
0000000000000000000000000000000000000000;;		if fnerr != nil {
0000000000000000000000000000000000000000;;			panic(fnerr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) jsonUnmarshal(rv reflect.Value) {
0000000000000000000000000000000000000000;;		tm := f.getValueForUnmarshalInterface(rv, f.ti.junmIndir).(jsonUnmarshaler)
0000000000000000000000000000000000000000;;		// bs := f.d.d.DecodeBytes(f.d.b[:], true, true)
0000000000000000000000000000000000000000;;		// grab the bytes to be read, as UnmarshalJSON needs the full JSON so as to unmarshal it itself.
0000000000000000000000000000000000000000;;		fnerr := tm.UnmarshalJSON(f.d.nextValueBytes())
0000000000000000000000000000000000000000;;		if fnerr != nil {
0000000000000000000000000000000000000000;;			panic(fnerr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kErr(rv reflect.Value) {
0000000000000000000000000000000000000000;;		f.d.errorf("no decoding function defined for kind %v", rv.Kind())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kString(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetString(f.d.d.DecodeString())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kBool(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetBool(f.d.d.DecodeBool())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kInt(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetInt(f.d.d.DecodeInt(intBitsize))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kInt64(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetInt(f.d.d.DecodeInt(64))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kInt32(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetInt(f.d.d.DecodeInt(32))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kInt8(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetInt(f.d.d.DecodeInt(8))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kInt16(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetInt(f.d.d.DecodeInt(16))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kFloat32(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetFloat(f.d.d.DecodeFloat(true))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kFloat64(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetFloat(f.d.d.DecodeFloat(false))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kUint8(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetUint(f.d.d.DecodeUint(8))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kUint64(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetUint(f.d.d.DecodeUint(64))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kUint(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetUint(f.d.d.DecodeUint(uintBitsize))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kUintptr(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetUint(f.d.d.DecodeUint(uintBitsize))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kUint32(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetUint(f.d.d.DecodeUint(32))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kUint16(rv reflect.Value) {
0000000000000000000000000000000000000000;;		rv.SetUint(f.d.d.DecodeUint(16))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (f *decFnInfo) kPtr(rv reflect.Value) {
0000000000000000000000000000000000000000;;	// 	debugf(">>>>>>> ??? decode kPtr called - shouldn't get called")
0000000000000000000000000000000000000000;;	// 	if rv.IsNil() {
0000000000000000000000000000000000000000;;	// 		rv.Set(reflect.New(rv.Type().Elem()))
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	f.d.decodeValue(rv.Elem())
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// var kIntfCtr uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kInterfaceNaked() (rvn reflect.Value) {
0000000000000000000000000000000000000000;;		// nil interface:
0000000000000000000000000000000000000000;;		// use some hieristics to decode it appropriately
0000000000000000000000000000000000000000;;		// based on the detected next value in the stream.
0000000000000000000000000000000000000000;;		d := f.d
0000000000000000000000000000000000000000;;		d.d.DecodeNaked()
0000000000000000000000000000000000000000;;		n := &d.n
0000000000000000000000000000000000000000;;		if n.v == valueTypeNil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We cannot decode non-nil stream value into nil interface with methods (e.g. io.Reader).
0000000000000000000000000000000000000000;;		// if num := f.ti.rt.NumMethod(); num > 0 {
0000000000000000000000000000000000000000;;		if f.ti.numMeth > 0 {
0000000000000000000000000000000000000000;;			d.errorf("cannot decode non-nil codec value into nil %v (%v methods)", f.ti.rt, f.ti.numMeth)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// var useRvn bool
0000000000000000000000000000000000000000;;		switch n.v {
0000000000000000000000000000000000000000;;		case valueTypeMap:
0000000000000000000000000000000000000000;;			// if d.h.MapType == nil || d.h.MapType == mapIntfIntfTyp {
0000000000000000000000000000000000000000;;			// } else if d.h.MapType == mapStrIntfTyp { // for json performance
0000000000000000000000000000000000000000;;			// }
0000000000000000000000000000000000000000;;			if d.mtid == 0 || d.mtid == mapIntfIntfTypId {
0000000000000000000000000000000000000000;;				l := len(n.ms)
0000000000000000000000000000000000000000;;				n.ms = append(n.ms, nil)
0000000000000000000000000000000000000000;;				var v2 interface{} = &n.ms[l]
0000000000000000000000000000000000000000;;				d.decode(v2)
0000000000000000000000000000000000000000;;				rvn = reflect.ValueOf(v2).Elem()
0000000000000000000000000000000000000000;;				n.ms = n.ms[:l]
0000000000000000000000000000000000000000;;			} else if d.mtid == mapStrIntfTypId { // for json performance
0000000000000000000000000000000000000000;;				l := len(n.ns)
0000000000000000000000000000000000000000;;				n.ns = append(n.ns, nil)
0000000000000000000000000000000000000000;;				var v2 interface{} = &n.ns[l]
0000000000000000000000000000000000000000;;				d.decode(v2)
0000000000000000000000000000000000000000;;				rvn = reflect.ValueOf(v2).Elem()
0000000000000000000000000000000000000000;;				n.ns = n.ns[:l]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rvn = reflect.New(d.h.MapType).Elem()
0000000000000000000000000000000000000000;;				d.decodeValue(rvn, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case valueTypeArray:
0000000000000000000000000000000000000000;;			// if d.h.SliceType == nil || d.h.SliceType == intfSliceTyp {
0000000000000000000000000000000000000000;;			if d.stid == 0 || d.stid == intfSliceTypId {
0000000000000000000000000000000000000000;;				l := len(n.ss)
0000000000000000000000000000000000000000;;				n.ss = append(n.ss, nil)
0000000000000000000000000000000000000000;;				var v2 interface{} = &n.ss[l]
0000000000000000000000000000000000000000;;				d.decode(v2)
0000000000000000000000000000000000000000;;				n.ss = n.ss[:l]
0000000000000000000000000000000000000000;;				rvn = reflect.ValueOf(v2).Elem()
0000000000000000000000000000000000000000;;				if reflectArrayOfSupported && d.stid == 0 && d.h.PreferArrayOverSlice {
0000000000000000000000000000000000000000;;					rvn = reflectArrayOf(rvn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rvn = reflect.New(d.h.SliceType).Elem()
0000000000000000000000000000000000000000;;				d.decodeValue(rvn, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case valueTypeExt:
0000000000000000000000000000000000000000;;			var v interface{}
0000000000000000000000000000000000000000;;			tag, bytes := n.u, n.l // calling decode below might taint the values
0000000000000000000000000000000000000000;;			if bytes == nil {
0000000000000000000000000000000000000000;;				l := len(n.is)
0000000000000000000000000000000000000000;;				n.is = append(n.is, nil)
0000000000000000000000000000000000000000;;				v2 := &n.is[l]
0000000000000000000000000000000000000000;;				d.decode(v2)
0000000000000000000000000000000000000000;;				v = *v2
0000000000000000000000000000000000000000;;				n.is = n.is[:l]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bfn := d.h.getExtForTag(tag)
0000000000000000000000000000000000000000;;			if bfn == nil {
0000000000000000000000000000000000000000;;				var re RawExt
0000000000000000000000000000000000000000;;				re.Tag = tag
0000000000000000000000000000000000000000;;				re.Data = detachZeroCopyBytes(d.bytes, nil, bytes)
0000000000000000000000000000000000000000;;				rvn = reflect.ValueOf(re)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rvnA := reflect.New(bfn.rt)
0000000000000000000000000000000000000000;;				rvn = rvnA.Elem()
0000000000000000000000000000000000000000;;				if bytes != nil {
0000000000000000000000000000000000000000;;					bfn.ext.ReadExt(rvnA.Interface(), bytes)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					bfn.ext.UpdateExt(rvnA.Interface(), v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case valueTypeNil:
0000000000000000000000000000000000000000;;			// no-op
0000000000000000000000000000000000000000;;		case valueTypeInt:
0000000000000000000000000000000000000000;;			rvn = reflect.ValueOf(&n.i).Elem()
0000000000000000000000000000000000000000;;		case valueTypeUint:
0000000000000000000000000000000000000000;;			rvn = reflect.ValueOf(&n.u).Elem()
0000000000000000000000000000000000000000;;		case valueTypeFloat:
0000000000000000000000000000000000000000;;			rvn = reflect.ValueOf(&n.f).Elem()
0000000000000000000000000000000000000000;;		case valueTypeBool:
0000000000000000000000000000000000000000;;			rvn = reflect.ValueOf(&n.b).Elem()
0000000000000000000000000000000000000000;;		case valueTypeString, valueTypeSymbol:
0000000000000000000000000000000000000000;;			rvn = reflect.ValueOf(&n.s).Elem()
0000000000000000000000000000000000000000;;		case valueTypeBytes:
0000000000000000000000000000000000000000;;			rvn = reflect.ValueOf(&n.l).Elem()
0000000000000000000000000000000000000000;;		case valueTypeTimestamp:
0000000000000000000000000000000000000000;;			rvn = reflect.ValueOf(&n.t).Elem()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Errorf("kInterfaceNaked: unexpected valueType: %d", n.v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kInterface(rv reflect.Value) {
0000000000000000000000000000000000000000;;		// debugf("\t===> kInterface")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note:
0000000000000000000000000000000000000000;;		// A consequence of how kInterface works, is that
0000000000000000000000000000000000000000;;		// if an interface already contains something, we try
0000000000000000000000000000000000000000;;		// to decode into what was there before.
0000000000000000000000000000000000000000;;		// We do not replace with a generic value (as got from decodeNaked).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rvn reflect.Value
0000000000000000000000000000000000000000;;		if rv.IsNil() {
0000000000000000000000000000000000000000;;			rvn = f.kInterfaceNaked()
0000000000000000000000000000000000000000;;			if rvn.IsValid() {
0000000000000000000000000000000000000000;;				rv.Set(rvn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if f.d.h.InterfaceReset {
0000000000000000000000000000000000000000;;			rvn = f.kInterfaceNaked()
0000000000000000000000000000000000000000;;			if rvn.IsValid() {
0000000000000000000000000000000000000000;;				rv.Set(rvn)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// reset to zero value based on current type in there.
0000000000000000000000000000000000000000;;				rv.Set(reflect.Zero(rv.Elem().Type()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rvn = rv.Elem()
0000000000000000000000000000000000000000;;			// Note: interface{} is settable, but underlying type may not be.
0000000000000000000000000000000000000000;;			// Consequently, we have to set the reflect.Value directly.
0000000000000000000000000000000000000000;;			// if underlying type is settable (e.g. ptr or interface),
0000000000000000000000000000000000000000;;			// we just decode into it.
0000000000000000000000000000000000000000;;			// Else we create a settable value, decode into it, and set on the interface.
0000000000000000000000000000000000000000;;			if rvn.CanSet() {
0000000000000000000000000000000000000000;;				f.d.decodeValue(rvn, nil)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rvn2 := reflect.New(rvn.Type()).Elem()
0000000000000000000000000000000000000000;;				rvn2.Set(rvn)
0000000000000000000000000000000000000000;;				f.d.decodeValue(rvn2, nil)
0000000000000000000000000000000000000000;;				rv.Set(rvn2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kStruct(rv reflect.Value) {
0000000000000000000000000000000000000000;;		fti := f.ti
0000000000000000000000000000000000000000;;		d := f.d
0000000000000000000000000000000000000000;;		dd := d.d
0000000000000000000000000000000000000000;;		cr := d.cr
0000000000000000000000000000000000000000;;		ctyp := dd.ContainerType()
0000000000000000000000000000000000000000;;		if ctyp == valueTypeMap {
0000000000000000000000000000000000000000;;			containerLen := dd.ReadMapStart()
0000000000000000000000000000000000000000;;			if containerLen == 0 {
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tisfi := fti.sfi
0000000000000000000000000000000000000000;;			hasLen := containerLen >= 0
0000000000000000000000000000000000000000;;			if hasLen {
0000000000000000000000000000000000000000;;				for j := 0; j < containerLen; j++ {
0000000000000000000000000000000000000000;;					// rvkencname := dd.DecodeString()
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rvkencname := stringView(dd.DecodeBytes(f.d.b[:], true, true))
0000000000000000000000000000000000000000;;					// rvksi := ti.getForEncName(rvkencname)
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if k := fti.indexForEncName(rvkencname); k > -1 {
0000000000000000000000000000000000000000;;						si := tisfi[k]
0000000000000000000000000000000000000000;;						if dd.TryDecodeAsNil() {
0000000000000000000000000000000000000000;;							si.setToZeroValue(rv)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							d.decodeValue(si.field(rv, true), nil)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						d.structFieldNotFound(-1, rvkencname)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for j := 0; !dd.CheckBreak(); j++ {
0000000000000000000000000000000000000000;;					// rvkencname := dd.DecodeString()
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rvkencname := stringView(dd.DecodeBytes(f.d.b[:], true, true))
0000000000000000000000000000000000000000;;					// rvksi := ti.getForEncName(rvkencname)
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if k := fti.indexForEncName(rvkencname); k > -1 {
0000000000000000000000000000000000000000;;						si := tisfi[k]
0000000000000000000000000000000000000000;;						if dd.TryDecodeAsNil() {
0000000000000000000000000000000000000000;;							si.setToZeroValue(rv)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							d.decodeValue(si.field(rv, true), nil)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						d.structFieldNotFound(-1, rvkencname)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if ctyp == valueTypeArray {
0000000000000000000000000000000000000000;;			containerLen := dd.ReadArrayStart()
0000000000000000000000000000000000000000;;			if containerLen == 0 {
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerArrayEnd)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Not much gain from doing it two ways for array.
0000000000000000000000000000000000000000;;			// Arrays are not used as much for structs.
0000000000000000000000000000000000000000;;			hasLen := containerLen >= 0
0000000000000000000000000000000000000000;;			for j, si := range fti.sfip {
0000000000000000000000000000000000000000;;				if hasLen {
0000000000000000000000000000000000000000;;					if j == containerLen {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if dd.CheckBreak() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerArrayElem)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if dd.TryDecodeAsNil() {
0000000000000000000000000000000000000000;;					si.setToZeroValue(rv)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.decodeValue(si.field(rv, true), nil)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if containerLen > len(fti.sfip) {
0000000000000000000000000000000000000000;;				// read remaining values and throw away
0000000000000000000000000000000000000000;;				for j := len(fti.sfip); j < containerLen; j++ {
0000000000000000000000000000000000000000;;					if cr != nil {
0000000000000000000000000000000000000000;;						cr.sendContainerState(containerArrayElem)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					d.structFieldNotFound(j, "")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerArrayEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f.d.error(onlyMapOrArrayCanDecodeIntoStructErr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kSlice(rv reflect.Value) {
0000000000000000000000000000000000000000;;		// A slice can be set from a map or array in stream.
0000000000000000000000000000000000000000;;		// This way, the order can be kept (as order is lost with map).
0000000000000000000000000000000000000000;;		ti := f.ti
0000000000000000000000000000000000000000;;		d := f.d
0000000000000000000000000000000000000000;;		dd := d.d
0000000000000000000000000000000000000000;;		rtelem0 := ti.rt.Elem()
0000000000000000000000000000000000000000;;		ctyp := dd.ContainerType()
0000000000000000000000000000000000000000;;		if ctyp == valueTypeBytes || ctyp == valueTypeString {
0000000000000000000000000000000000000000;;			// you can only decode bytes or string in the stream into a slice or array of bytes
0000000000000000000000000000000000000000;;			if !(ti.rtid == uint8SliceTypId || rtelem0.Kind() == reflect.Uint8) {
0000000000000000000000000000000000000000;;				f.d.errorf("bytes or string in the stream must be decoded into a slice or array of bytes, not %v", ti.rt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.seq == seqTypeChan {
0000000000000000000000000000000000000000;;				bs2 := dd.DecodeBytes(nil, false, true)
0000000000000000000000000000000000000000;;				ch := rv.Interface().(chan<- byte)
0000000000000000000000000000000000000000;;				for _, b := range bs2 {
0000000000000000000000000000000000000000;;					ch <- b
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				rvbs := rv.Bytes()
0000000000000000000000000000000000000000;;				bs2 := dd.DecodeBytes(rvbs, false, false)
0000000000000000000000000000000000000000;;				if rvbs == nil && bs2 != nil || rvbs != nil && bs2 == nil || len(bs2) != len(rvbs) {
0000000000000000000000000000000000000000;;					if rv.CanSet() {
0000000000000000000000000000000000000000;;						rv.SetBytes(bs2)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						copy(rvbs, bs2)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// array := f.seq == seqTypeChan
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		slh, containerLenS := d.decSliceHelperStart() // only expects valueType(Array|Map)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// // an array can never return a nil slice. so no need to check f.array here.
0000000000000000000000000000000000000000;;		if containerLenS == 0 {
0000000000000000000000000000000000000000;;			if f.seq == seqTypeSlice {
0000000000000000000000000000000000000000;;				if rv.IsNil() {
0000000000000000000000000000000000000000;;					rv.Set(reflect.MakeSlice(ti.rt, 0, 0))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					rv.SetLen(0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if f.seq == seqTypeChan {
0000000000000000000000000000000000000000;;				if rv.IsNil() {
0000000000000000000000000000000000000000;;					rv.Set(reflect.MakeChan(ti.rt, 0))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			slh.End()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rtelem := rtelem0
0000000000000000000000000000000000000000;;		for rtelem.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			rtelem = rtelem.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fn := d.getDecFn(rtelem, true, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rv0, rv9 reflect.Value
0000000000000000000000000000000000000000;;		rv0 = rv
0000000000000000000000000000000000000000;;		rvChanged := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for j := 0; j < containerLenS; j++ {
0000000000000000000000000000000000000000;;		var rvlen int
0000000000000000000000000000000000000000;;		if containerLenS > 0 { // hasLen
0000000000000000000000000000000000000000;;			if f.seq == seqTypeChan {
0000000000000000000000000000000000000000;;				if rv.IsNil() {
0000000000000000000000000000000000000000;;					rvlen, _ = decInferLen(containerLenS, f.d.h.MaxInitLen, int(rtelem0.Size()))
0000000000000000000000000000000000000000;;					rv.Set(reflect.MakeChan(ti.rt, rvlen))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// handle chan specially:
0000000000000000000000000000000000000000;;				for j := 0; j < containerLenS; j++ {
0000000000000000000000000000000000000000;;					rv9 = reflect.New(rtelem0).Elem()
0000000000000000000000000000000000000000;;					slh.ElemContainerState(j)
0000000000000000000000000000000000000000;;					d.decodeValue(rv9, fn)
0000000000000000000000000000000000000000;;					rv.Send(rv9)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else { // slice or array
0000000000000000000000000000000000000000;;				var truncated bool         // says len of sequence is not same as expected number of elements
0000000000000000000000000000000000000000;;				numToRead := containerLenS // if truncated, reset numToRead
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				rvcap := rv.Cap()
0000000000000000000000000000000000000000;;				rvlen = rv.Len()
0000000000000000000000000000000000000000;;				if containerLenS > rvcap {
0000000000000000000000000000000000000000;;					if f.seq == seqTypeArray {
0000000000000000000000000000000000000000;;						d.arrayCannotExpand(rvlen, containerLenS)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						oldRvlenGtZero := rvlen > 0
0000000000000000000000000000000000000000;;						rvlen, truncated = decInferLen(containerLenS, f.d.h.MaxInitLen, int(rtelem0.Size()))
0000000000000000000000000000000000000000;;						if truncated {
0000000000000000000000000000000000000000;;							if rvlen <= rvcap {
0000000000000000000000000000000000000000;;								rv.SetLen(rvlen)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								rv = reflect.MakeSlice(ti.rt, rvlen, rvlen)
0000000000000000000000000000000000000000;;								rvChanged = true
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							rv = reflect.MakeSlice(ti.rt, rvlen, rvlen)
0000000000000000000000000000000000000000;;							rvChanged = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if rvChanged && oldRvlenGtZero && !isImmutableKind(rtelem0.Kind()) {
0000000000000000000000000000000000000000;;							reflect.Copy(rv, rv0) // only copy up to length NOT cap i.e. rv0.Slice(0, rvcap)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						rvcap = rvlen
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					numToRead = rvlen
0000000000000000000000000000000000000000;;				} else if containerLenS != rvlen {
0000000000000000000000000000000000000000;;					if f.seq == seqTypeSlice {
0000000000000000000000000000000000000000;;						rv.SetLen(containerLenS)
0000000000000000000000000000000000000000;;						rvlen = containerLenS
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				j := 0
0000000000000000000000000000000000000000;;				// we read up to the numToRead
0000000000000000000000000000000000000000;;				for ; j < numToRead; j++ {
0000000000000000000000000000000000000000;;					slh.ElemContainerState(j)
0000000000000000000000000000000000000000;;					d.decodeValue(rv.Index(j), fn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if slice, expand and read up to containerLenS (or EOF) iff truncated
0000000000000000000000000000000000000000;;				// if array, swallow all the rest.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if f.seq == seqTypeArray {
0000000000000000000000000000000000000000;;					for ; j < containerLenS; j++ {
0000000000000000000000000000000000000000;;						slh.ElemContainerState(j)
0000000000000000000000000000000000000000;;						d.swallow()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if truncated { // slice was truncated, as chan NOT in this block
0000000000000000000000000000000000000000;;					for ; j < containerLenS; j++ {
0000000000000000000000000000000000000000;;						rv = expandSliceValue(rv, 1)
0000000000000000000000000000000000000000;;						rv9 = rv.Index(j)
0000000000000000000000000000000000000000;;						if resetSliceElemToZeroValue {
0000000000000000000000000000000000000000;;							rv9.Set(reflect.Zero(rtelem0))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						slh.ElemContainerState(j)
0000000000000000000000000000000000000000;;						d.decodeValue(rv9, fn)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rvlen = rv.Len()
0000000000000000000000000000000000000000;;			j := 0
0000000000000000000000000000000000000000;;			for ; !dd.CheckBreak(); j++ {
0000000000000000000000000000000000000000;;				if f.seq == seqTypeChan {
0000000000000000000000000000000000000000;;					slh.ElemContainerState(j)
0000000000000000000000000000000000000000;;					rv9 = reflect.New(rtelem0).Elem()
0000000000000000000000000000000000000000;;					d.decodeValue(rv9, fn)
0000000000000000000000000000000000000000;;					rv.Send(rv9)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// if indefinite, etc, then expand the slice if necessary
0000000000000000000000000000000000000000;;					var decodeIntoBlank bool
0000000000000000000000000000000000000000;;					if j >= rvlen {
0000000000000000000000000000000000000000;;						if f.seq == seqTypeArray {
0000000000000000000000000000000000000000;;							d.arrayCannotExpand(rvlen, j+1)
0000000000000000000000000000000000000000;;							decodeIntoBlank = true
0000000000000000000000000000000000000000;;						} else { // if f.seq == seqTypeSlice
0000000000000000000000000000000000000000;;							// rv = reflect.Append(rv, reflect.Zero(rtelem0)) // uses append logic, plus varargs
0000000000000000000000000000000000000000;;							rv = expandSliceValue(rv, 1)
0000000000000000000000000000000000000000;;							rv9 = rv.Index(j)
0000000000000000000000000000000000000000;;							// rv.Index(rv.Len() - 1).Set(reflect.Zero(rtelem0))
0000000000000000000000000000000000000000;;							if resetSliceElemToZeroValue {
0000000000000000000000000000000000000000;;								rv9.Set(reflect.Zero(rtelem0))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							rvlen++
0000000000000000000000000000000000000000;;							rvChanged = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else { // slice or array
0000000000000000000000000000000000000000;;						rv9 = rv.Index(j)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					slh.ElemContainerState(j)
0000000000000000000000000000000000000000;;					if decodeIntoBlank {
0000000000000000000000000000000000000000;;						d.swallow()
0000000000000000000000000000000000000000;;					} else { // seqTypeSlice
0000000000000000000000000000000000000000;;						d.decodeValue(rv9, fn)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.seq == seqTypeSlice {
0000000000000000000000000000000000000000;;				if j < rvlen {
0000000000000000000000000000000000000000;;					rv.SetLen(j)
0000000000000000000000000000000000000000;;				} else if j == 0 && rv.IsNil() {
0000000000000000000000000000000000000000;;					rv = reflect.MakeSlice(ti.rt, 0, 0)
0000000000000000000000000000000000000000;;					rvChanged = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slh.End()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rvChanged {
0000000000000000000000000000000000000000;;			rv0.Set(rv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kArray(rv reflect.Value) {
0000000000000000000000000000000000000000;;		// f.d.decodeValue(rv.Slice(0, rv.Len()))
0000000000000000000000000000000000000000;;		f.kSlice(rv.Slice(0, rv.Len()))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *decFnInfo) kMap(rv reflect.Value) {
0000000000000000000000000000000000000000;;		d := f.d
0000000000000000000000000000000000000000;;		dd := d.d
0000000000000000000000000000000000000000;;		containerLen := dd.ReadMapStart()
0000000000000000000000000000000000000000;;		cr := d.cr
0000000000000000000000000000000000000000;;		ti := f.ti
0000000000000000000000000000000000000000;;		if rv.IsNil() {
0000000000000000000000000000000000000000;;			rv.Set(reflect.MakeMap(ti.rt))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if containerLen == 0 {
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ktype, vtype := ti.rt.Key(), ti.rt.Elem()
0000000000000000000000000000000000000000;;		ktypeId := reflect.ValueOf(ktype).Pointer()
0000000000000000000000000000000000000000;;		vtypeKind := vtype.Kind()
0000000000000000000000000000000000000000;;		var keyFn, valFn *decFn
0000000000000000000000000000000000000000;;		var xtyp reflect.Type
0000000000000000000000000000000000000000;;		for xtyp = ktype; xtyp.Kind() == reflect.Ptr; xtyp = xtyp.Elem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyFn = d.getDecFn(xtyp, true, true)
0000000000000000000000000000000000000000;;		for xtyp = vtype; xtyp.Kind() == reflect.Ptr; xtyp = xtyp.Elem() {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		valFn = d.getDecFn(xtyp, true, true)
0000000000000000000000000000000000000000;;		var mapGet, mapSet bool
0000000000000000000000000000000000000000;;		if !f.d.h.MapValueReset {
0000000000000000000000000000000000000000;;			// if pointer, mapGet = true
0000000000000000000000000000000000000000;;			// if interface, mapGet = true if !DecodeNakedAlways (else false)
0000000000000000000000000000000000000000;;			// if builtin, mapGet = false
0000000000000000000000000000000000000000;;			// else mapGet = true
0000000000000000000000000000000000000000;;			if vtypeKind == reflect.Ptr {
0000000000000000000000000000000000000000;;				mapGet = true
0000000000000000000000000000000000000000;;			} else if vtypeKind == reflect.Interface {
0000000000000000000000000000000000000000;;				if !f.d.h.InterfaceReset {
0000000000000000000000000000000000000000;;					mapGet = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if !isImmutableKind(vtypeKind) {
0000000000000000000000000000000000000000;;				mapGet = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var rvk, rvv, rvz reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for j := 0; j < containerLen; j++ {
0000000000000000000000000000000000000000;;		if containerLen > 0 {
0000000000000000000000000000000000000000;;			for j := 0; j < containerLen; j++ {
0000000000000000000000000000000000000000;;				rvk = reflect.New(ktype).Elem()
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.decodeValue(rvk, keyFn)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// special case if a byte array.
0000000000000000000000000000000000000000;;				if ktypeId == intfTypId {
0000000000000000000000000000000000000000;;					rvk = rvk.Elem()
0000000000000000000000000000000000000000;;					if rvk.Type() == uint8SliceTyp {
0000000000000000000000000000000000000000;;						rvk = reflect.ValueOf(d.string(rvk.Bytes()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				mapSet = true // set to false if u do a get, and its a pointer, and exists
0000000000000000000000000000000000000000;;				if mapGet {
0000000000000000000000000000000000000000;;					rvv = rv.MapIndex(rvk)
0000000000000000000000000000000000000000;;					if rvv.IsValid() {
0000000000000000000000000000000000000000;;						if vtypeKind == reflect.Ptr {
0000000000000000000000000000000000000000;;							mapSet = false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if rvz.IsValid() {
0000000000000000000000000000000000000000;;							rvz.Set(reflect.Zero(vtype))
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							rvz = reflect.New(vtype).Elem()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						rvv = rvz
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if rvz.IsValid() {
0000000000000000000000000000000000000000;;						rvz.Set(reflect.Zero(vtype))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						rvz = reflect.New(vtype).Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rvv = rvz
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.decodeValue(rvv, valFn)
0000000000000000000000000000000000000000;;				if mapSet {
0000000000000000000000000000000000000000;;					rv.SetMapIndex(rvk, rvv)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for j := 0; !dd.CheckBreak(); j++ {
0000000000000000000000000000000000000000;;				rvk = reflect.New(ktype).Elem()
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.decodeValue(rvk, keyFn)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// special case if a byte array.
0000000000000000000000000000000000000000;;				if ktypeId == intfTypId {
0000000000000000000000000000000000000000;;					rvk = rvk.Elem()
0000000000000000000000000000000000000000;;					if rvk.Type() == uint8SliceTyp {
0000000000000000000000000000000000000000;;						rvk = reflect.ValueOf(d.string(rvk.Bytes()))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				mapSet = true // set to false if u do a get, and its a pointer, and exists
0000000000000000000000000000000000000000;;				if mapGet {
0000000000000000000000000000000000000000;;					rvv = rv.MapIndex(rvk)
0000000000000000000000000000000000000000;;					if rvv.IsValid() {
0000000000000000000000000000000000000000;;						if vtypeKind == reflect.Ptr {
0000000000000000000000000000000000000000;;							mapSet = false
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if rvz.IsValid() {
0000000000000000000000000000000000000000;;							rvz.Set(reflect.Zero(vtype))
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							rvz = reflect.New(vtype).Elem()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						rvv = rvz
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if rvz.IsValid() {
0000000000000000000000000000000000000000;;						rvz.Set(reflect.Zero(vtype))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						rvz = reflect.New(vtype).Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rvv = rvz
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.decodeValue(rvv, valFn)
0000000000000000000000000000000000000000;;				if mapSet {
0000000000000000000000000000000000000000;;					rv.SetMapIndex(rvk, rvv)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if cr != nil {
0000000000000000000000000000000000000000;;			cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decRtidFn struct {
0000000000000000000000000000000000000000;;		rtid uintptr
0000000000000000000000000000000000000000;;		fn   decFn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decNaked is used to keep track of the primitives decoded.
0000000000000000000000000000000000000000;;	// Without it, we would have to decode each primitive and wrap it
0000000000000000000000000000000000000000;;	// in an interface{}, causing an allocation.
0000000000000000000000000000000000000000;;	// In this model, the primitives are decoded in a "pseudo-atomic" fashion,
0000000000000000000000000000000000000000;;	// so we can rest assured that no other decoding happens while these
0000000000000000000000000000000000000000;;	// primitives are being decoded.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// maps and arrays are not handled by this mechanism.
0000000000000000000000000000000000000000;;	// However, RawExt is, and we accommodate for extensions that decode
0000000000000000000000000000000000000000;;	// RawExt from DecodeNaked, but need to decode the value subsequently.
0000000000000000000000000000000000000000;;	// kInterfaceNaked and swallow, which call DecodeNaked, handle this caveat.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// However, decNaked also keeps some arrays of default maps and slices
0000000000000000000000000000000000000000;;	// used in DecodeNaked. This way, we can get a pointer to it
0000000000000000000000000000000000000000;;	// without causing a new heap allocation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// kInterfaceNaked will ensure that there is no allocation for the common
0000000000000000000000000000000000000000;;	// uses.
0000000000000000000000000000000000000000;;	type decNaked struct {
0000000000000000000000000000000000000000;;		// r RawExt // used for RawExt, uint, []byte.
0000000000000000000000000000000000000000;;		u uint64
0000000000000000000000000000000000000000;;		i int64
0000000000000000000000000000000000000000;;		f float64
0000000000000000000000000000000000000000;;		l []byte
0000000000000000000000000000000000000000;;		s string
0000000000000000000000000000000000000000;;		t time.Time
0000000000000000000000000000000000000000;;		b bool
0000000000000000000000000000000000000000;;		v valueType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// stacks for reducing allocation
0000000000000000000000000000000000000000;;		is []interface{}
0000000000000000000000000000000000000000;;		ms []map[interface{}]interface{}
0000000000000000000000000000000000000000;;		ns []map[string]interface{}
0000000000000000000000000000000000000000;;		ss [][]interface{}
0000000000000000000000000000000000000000;;		// rs []RawExt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keep arrays at the bottom? Chance is that they are not used much.
0000000000000000000000000000000000000000;;		ia [4]interface{}
0000000000000000000000000000000000000000;;		ma [4]map[interface{}]interface{}
0000000000000000000000000000000000000000;;		na [4]map[string]interface{}
0000000000000000000000000000000000000000;;		sa [4][]interface{}
0000000000000000000000000000000000000000;;		// ra [2]RawExt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *decNaked) reset() {
0000000000000000000000000000000000000000;;		if n.ss != nil {
0000000000000000000000000000000000000000;;			n.ss = n.ss[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.is != nil {
0000000000000000000000000000000000000000;;			n.is = n.is[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.ms != nil {
0000000000000000000000000000000000000000;;			n.ms = n.ms[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.ns != nil {
0000000000000000000000000000000000000000;;			n.ns = n.ns[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Decoder reads and decodes an object from an input stream in the codec format.
0000000000000000000000000000000000000000;;	type Decoder struct {
0000000000000000000000000000000000000000;;		// hopefully, reduce derefencing cost by laying the decReader inside the Decoder.
0000000000000000000000000000000000000000;;		// Try to put things that go together to fit within a cache line (8 words).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d decDriver
0000000000000000000000000000000000000000;;		// NOTE: Decoder shouldn't call it's read methods,
0000000000000000000000000000000000000000;;		// as the handler MAY need to do some coordination.
0000000000000000000000000000000000000000;;		r decReader
0000000000000000000000000000000000000000;;		// sa [initCollectionCap]decRtidFn
0000000000000000000000000000000000000000;;		h  *BasicHandle
0000000000000000000000000000000000000000;;		hh Handle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		be    bool // is binary encoding
0000000000000000000000000000000000000000;;		bytes bool // is bytes reader
0000000000000000000000000000000000000000;;		js    bool // is json handle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rb bytesDecReader
0000000000000000000000000000000000000000;;		ri ioDecReader
0000000000000000000000000000000000000000;;		cr containerStateRecv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s []decRtidFn
0000000000000000000000000000000000000000;;		f map[uintptr]*decFn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// _  uintptr // for alignment purposes, so next one starts from a cache line
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cache the mapTypeId and sliceTypeId for faster comparisons
0000000000000000000000000000000000000000;;		mtid uintptr
0000000000000000000000000000000000000000;;		stid uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n  decNaked
0000000000000000000000000000000000000000;;		b  [scratchByteArrayLen]byte
0000000000000000000000000000000000000000;;		is map[string]string // used for interning strings
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder returns a Decoder for decoding a stream of bytes from an io.Reader.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For efficiency, Users are encouraged to pass in a memory buffered reader
0000000000000000000000000000000000000000;;	// (eg bufio.Reader, bytes.Buffer).
0000000000000000000000000000000000000000;;	func NewDecoder(r io.Reader, h Handle) *Decoder {
0000000000000000000000000000000000000000;;		d := newDecoder(h)
0000000000000000000000000000000000000000;;		d.Reset(r)
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoderBytes returns a Decoder which efficiently decodes directly
0000000000000000000000000000000000000000;;	// from a byte slice with zero copying.
0000000000000000000000000000000000000000;;	func NewDecoderBytes(in []byte, h Handle) *Decoder {
0000000000000000000000000000000000000000;;		d := newDecoder(h)
0000000000000000000000000000000000000000;;		d.ResetBytes(in)
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newDecoder(h Handle) *Decoder {
0000000000000000000000000000000000000000;;		d := &Decoder{hh: h, h: h.getBasicHandle(), be: h.isBinary()}
0000000000000000000000000000000000000000;;		n := &d.n
0000000000000000000000000000000000000000;;		// n.rs = n.ra[:0]
0000000000000000000000000000000000000000;;		n.ms = n.ma[:0]
0000000000000000000000000000000000000000;;		n.is = n.ia[:0]
0000000000000000000000000000000000000000;;		n.ns = n.na[:0]
0000000000000000000000000000000000000000;;		n.ss = n.sa[:0]
0000000000000000000000000000000000000000;;		_, d.js = h.(*JsonHandle)
0000000000000000000000000000000000000000;;		if d.h.InternString {
0000000000000000000000000000000000000000;;			d.is = make(map[string]string, 32)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.d = h.newDecDriver(d)
0000000000000000000000000000000000000000;;		d.cr, _ = d.d.(containerStateRecv)
0000000000000000000000000000000000000000;;		// d.d = h.newDecDriver(decReaderT{true, &d.rb, &d.ri})
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) resetCommon() {
0000000000000000000000000000000000000000;;		d.n.reset()
0000000000000000000000000000000000000000;;		d.d.reset()
0000000000000000000000000000000000000000;;		// reset all things which were cached from the Handle,
0000000000000000000000000000000000000000;;		// but could be changed.
0000000000000000000000000000000000000000;;		d.mtid, d.stid = 0, 0
0000000000000000000000000000000000000000;;		if d.h.MapType != nil {
0000000000000000000000000000000000000000;;			d.mtid = reflect.ValueOf(d.h.MapType).Pointer()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.h.SliceType != nil {
0000000000000000000000000000000000000000;;			d.stid = reflect.ValueOf(d.h.SliceType).Pointer()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) Reset(r io.Reader) {
0000000000000000000000000000000000000000;;		d.ri.x = &d.b
0000000000000000000000000000000000000000;;		// d.s = d.sa[:0]
0000000000000000000000000000000000000000;;		d.ri.bs.r = r
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		d.ri.br, ok = r.(decReaderByteScanner)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			d.ri.br = &d.ri.bs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.r = &d.ri
0000000000000000000000000000000000000000;;		d.resetCommon()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) ResetBytes(in []byte) {
0000000000000000000000000000000000000000;;		// d.s = d.sa[:0]
0000000000000000000000000000000000000000;;		d.rb.reset(in)
0000000000000000000000000000000000000000;;		d.r = &d.rb
0000000000000000000000000000000000000000;;		d.resetCommon()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (d *Decoder) sendContainerState(c containerState) {
0000000000000000000000000000000000000000;;	// 	if d.cr != nil {
0000000000000000000000000000000000000000;;	// 		d.cr.sendContainerState(c)
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode decodes the stream from reader and stores the result in the
0000000000000000000000000000000000000000;;	// value pointed to by v. v cannot be a nil pointer. v can also be
0000000000000000000000000000000000000000;;	// a reflect.Value of a pointer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that a pointer to a nil interface is not a nil pointer.
0000000000000000000000000000000000000000;;	// If you do not know what type of stream it is, pass in a pointer to a nil interface.
0000000000000000000000000000000000000000;;	// We will decode and store a value in that nil interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Sample usages:
0000000000000000000000000000000000000000;;	//   // Decoding into a non-nil typed value
0000000000000000000000000000000000000000;;	//   var f float32
0000000000000000000000000000000000000000;;	//   err = codec.NewDecoder(r, handle).Decode(&f)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // Decoding into nil interface
0000000000000000000000000000000000000000;;	//   var v interface{}
0000000000000000000000000000000000000000;;	//   dec := codec.NewDecoder(r, handle)
0000000000000000000000000000000000000000;;	//   err = dec.Decode(&v)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When decoding into a nil interface{}, we will decode into an appropriate value based
0000000000000000000000000000000000000000;;	// on the contents of the stream:
0000000000000000000000000000000000000000;;	//   - Numbers are decoded as float64, int64 or uint64.
0000000000000000000000000000000000000000;;	//   - Other values are decoded appropriately depending on the type:
0000000000000000000000000000000000000000;;	//     bool, string, []byte, time.Time, etc
0000000000000000000000000000000000000000;;	//   - Extensions are decoded as RawExt (if no ext function registered for the tag)
0000000000000000000000000000000000000000;;	// Configurations exist on the Handle to override defaults
0000000000000000000000000000000000000000;;	// (e.g. for MapType, SliceType and how to decode raw bytes).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When decoding into a non-nil interface{} value, the mode of encoding is based on the
0000000000000000000000000000000000000000;;	// type of the value. When a value is seen:
0000000000000000000000000000000000000000;;	//   - If an extension is registered for it, call that extension function
0000000000000000000000000000000000000000;;	//   - If it implements BinaryUnmarshaler, call its UnmarshalBinary(data []byte) error
0000000000000000000000000000000000000000;;	//   - Else decode it based on its reflect.Kind
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There are some special rules when decoding into containers (slice/array/map/struct).
0000000000000000000000000000000000000000;;	// Decode will typically use the stream contents to UPDATE the container.
0000000000000000000000000000000000000000;;	//   - A map can be decoded from a stream map, by updating matching keys.
0000000000000000000000000000000000000000;;	//   - A slice can be decoded from a stream array,
0000000000000000000000000000000000000000;;	//     by updating the first n elements, where n is length of the stream.
0000000000000000000000000000000000000000;;	//   - A slice can be decoded from a stream map, by decoding as if
0000000000000000000000000000000000000000;;	//     it contains a sequence of key-value pairs.
0000000000000000000000000000000000000000;;	//   - A struct can be decoded from a stream map, by updating matching fields.
0000000000000000000000000000000000000000;;	//   - A struct can be decoded from a stream array,
0000000000000000000000000000000000000000;;	//     by updating fields as they occur in the struct (by index).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When decoding a stream map or array with length of 0 into a nil map or slice,
0000000000000000000000000000000000000000;;	// we reset the destination map or slice to a zero-length value.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// However, when decoding a stream nil, we reset the destination container
0000000000000000000000000000000000000000;;	// to its "zero" value (e.g. nil for slice/map, etc).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (d *Decoder) Decode(v interface{}) (err error) {
0000000000000000000000000000000000000000;;		defer panicToErr(&err)
0000000000000000000000000000000000000000;;		d.decode(v)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// this is not a smart swallow, as it allocates objects and does unnecessary work.
0000000000000000000000000000000000000000;;	func (d *Decoder) swallowViaHammer() {
0000000000000000000000000000000000000000;;		var blank interface{}
0000000000000000000000000000000000000000;;		d.decodeValue(reflect.ValueOf(&blank).Elem(), nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) swallow() {
0000000000000000000000000000000000000000;;		// smarter decode that just swallows the content
0000000000000000000000000000000000000000;;		dd := d.d
0000000000000000000000000000000000000000;;		if dd.TryDecodeAsNil() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cr := d.cr
0000000000000000000000000000000000000000;;		switch dd.ContainerType() {
0000000000000000000000000000000000000000;;		case valueTypeMap:
0000000000000000000000000000000000000000;;			containerLen := dd.ReadMapStart()
0000000000000000000000000000000000000000;;			clenGtEqualZero := containerLen >= 0
0000000000000000000000000000000000000000;;			for j := 0; ; j++ {
0000000000000000000000000000000000000000;;				if clenGtEqualZero {
0000000000000000000000000000000000000000;;					if j >= containerLen {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if dd.CheckBreak() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.swallow()
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.swallow()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case valueTypeArray:
0000000000000000000000000000000000000000;;			containerLenS := dd.ReadArrayStart()
0000000000000000000000000000000000000000;;			clenGtEqualZero := containerLenS >= 0
0000000000000000000000000000000000000000;;			for j := 0; ; j++ {
0000000000000000000000000000000000000000;;				if clenGtEqualZero {
0000000000000000000000000000000000000000;;					if j >= containerLenS {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if dd.CheckBreak() {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cr != nil {
0000000000000000000000000000000000000000;;					cr.sendContainerState(containerArrayElem)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.swallow()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cr != nil {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerArrayEnd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case valueTypeBytes:
0000000000000000000000000000000000000000;;			dd.DecodeBytes(d.b[:], false, true)
0000000000000000000000000000000000000000;;		case valueTypeString:
0000000000000000000000000000000000000000;;			dd.DecodeBytes(d.b[:], true, true)
0000000000000000000000000000000000000000;;			// dd.DecodeStringAsBytes(d.b[:])
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// these are all primitives, which we can get from decodeNaked
0000000000000000000000000000000000000000;;			// if RawExt using Value, complete the processing.
0000000000000000000000000000000000000000;;			dd.DecodeNaked()
0000000000000000000000000000000000000000;;			if n := &d.n; n.v == valueTypeExt && n.l == nil {
0000000000000000000000000000000000000000;;				l := len(n.is)
0000000000000000000000000000000000000000;;				n.is = append(n.is, nil)
0000000000000000000000000000000000000000;;				v2 := &n.is[l]
0000000000000000000000000000000000000000;;				d.decode(v2)
0000000000000000000000000000000000000000;;				n.is = n.is[:l]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustDecode is like Decode, but panics if unable to Decode.
0000000000000000000000000000000000000000;;	// This provides insight to the code location that triggered the error.
0000000000000000000000000000000000000000;;	func (d *Decoder) MustDecode(v interface{}) {
0000000000000000000000000000000000000000;;		d.decode(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decode(iv interface{}) {
0000000000000000000000000000000000000000;;		// if ics, ok := iv.(Selfer); ok {
0000000000000000000000000000000000000000;;		// 	ics.CodecDecodeSelf(d)
0000000000000000000000000000000000000000;;		// 	return
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.d.TryDecodeAsNil() {
0000000000000000000000000000000000000000;;			switch v := iv.(type) {
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;			case *string:
0000000000000000000000000000000000000000;;				*v = ""
0000000000000000000000000000000000000000;;			case *bool:
0000000000000000000000000000000000000000;;				*v = false
0000000000000000000000000000000000000000;;			case *int:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *int8:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *int16:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *int32:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *int64:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *uint:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *uint8:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *uint16:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *uint32:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *uint64:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *float32:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *float64:
0000000000000000000000000000000000000000;;				*v = 0
0000000000000000000000000000000000000000;;			case *[]uint8:
0000000000000000000000000000000000000000;;				*v = nil
0000000000000000000000000000000000000000;;			case *Raw:
0000000000000000000000000000000000000000;;				*v = nil
0000000000000000000000000000000000000000;;			case reflect.Value:
0000000000000000000000000000000000000000;;				if v.Kind() != reflect.Ptr || v.IsNil() {
0000000000000000000000000000000000000000;;					d.errNotValidPtrValue(v)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// d.chkPtrValue(v)
0000000000000000000000000000000000000000;;				v = v.Elem()
0000000000000000000000000000000000000000;;				if v.IsValid() {
0000000000000000000000000000000000000000;;					v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				rv := reflect.ValueOf(iv)
0000000000000000000000000000000000000000;;				if rv.Kind() != reflect.Ptr || rv.IsNil() {
0000000000000000000000000000000000000000;;					d.errNotValidPtrValue(rv)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// d.chkPtrValue(rv)
0000000000000000000000000000000000000000;;				rv = rv.Elem()
0000000000000000000000000000000000000000;;				if rv.IsValid() {
0000000000000000000000000000000000000000;;					rv.Set(reflect.Zero(rv.Type()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v := iv.(type) {
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			d.error(cannotDecodeIntoNilErr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case Selfer:
0000000000000000000000000000000000000000;;			v.CodecDecodeSelf(d)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Value:
0000000000000000000000000000000000000000;;			if v.Kind() != reflect.Ptr || v.IsNil() {
0000000000000000000000000000000000000000;;				d.errNotValidPtrValue(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// d.chkPtrValue(v)
0000000000000000000000000000000000000000;;			d.decodeValueNotNil(v.Elem(), nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *string:
0000000000000000000000000000000000000000;;			*v = d.d.DecodeString()
0000000000000000000000000000000000000000;;		case *bool:
0000000000000000000000000000000000000000;;			*v = d.d.DecodeBool()
0000000000000000000000000000000000000000;;		case *int:
0000000000000000000000000000000000000000;;			*v = int(d.d.DecodeInt(intBitsize))
0000000000000000000000000000000000000000;;		case *int8:
0000000000000000000000000000000000000000;;			*v = int8(d.d.DecodeInt(8))
0000000000000000000000000000000000000000;;		case *int16:
0000000000000000000000000000000000000000;;			*v = int16(d.d.DecodeInt(16))
0000000000000000000000000000000000000000;;		case *int32:
0000000000000000000000000000000000000000;;			*v = int32(d.d.DecodeInt(32))
0000000000000000000000000000000000000000;;		case *int64:
0000000000000000000000000000000000000000;;			*v = d.d.DecodeInt(64)
0000000000000000000000000000000000000000;;		case *uint:
0000000000000000000000000000000000000000;;			*v = uint(d.d.DecodeUint(uintBitsize))
0000000000000000000000000000000000000000;;		case *uint8:
0000000000000000000000000000000000000000;;			*v = uint8(d.d.DecodeUint(8))
0000000000000000000000000000000000000000;;		case *uint16:
0000000000000000000000000000000000000000;;			*v = uint16(d.d.DecodeUint(16))
0000000000000000000000000000000000000000;;		case *uint32:
0000000000000000000000000000000000000000;;			*v = uint32(d.d.DecodeUint(32))
0000000000000000000000000000000000000000;;		case *uint64:
0000000000000000000000000000000000000000;;			*v = d.d.DecodeUint(64)
0000000000000000000000000000000000000000;;		case *float32:
0000000000000000000000000000000000000000;;			*v = float32(d.d.DecodeFloat(true))
0000000000000000000000000000000000000000;;		case *float64:
0000000000000000000000000000000000000000;;			*v = d.d.DecodeFloat(false)
0000000000000000000000000000000000000000;;		case *[]uint8:
0000000000000000000000000000000000000000;;			*v = d.d.DecodeBytes(*v, false, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *Raw:
0000000000000000000000000000000000000000;;			*v = d.raw()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *interface{}:
0000000000000000000000000000000000000000;;			d.decodeValueNotNil(reflect.ValueOf(iv).Elem(), nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if !fastpathDecodeTypeSwitch(iv, d) {
0000000000000000000000000000000000000000;;				d.decodeI(iv, true, false, false, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) preDecodeValue(rv reflect.Value, tryNil bool) (rv2 reflect.Value, proceed bool) {
0000000000000000000000000000000000000000;;		if tryNil && d.d.TryDecodeAsNil() {
0000000000000000000000000000000000000000;;			// No need to check if a ptr, recursively, to determine
0000000000000000000000000000000000000000;;			// whether to set value to nil.
0000000000000000000000000000000000000000;;			// Just always set value to its zero type.
0000000000000000000000000000000000000000;;			if rv.IsValid() { // rv.CanSet() // always settable, except it's invalid
0000000000000000000000000000000000000000;;				rv.Set(reflect.Zero(rv.Type()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If stream is not containing a nil value, then we can deref to the base
0000000000000000000000000000000000000000;;		// non-pointer value, and decode into that.
0000000000000000000000000000000000000000;;		for rv.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if rv.IsNil() {
0000000000000000000000000000000000000000;;				rv.Set(reflect.New(rv.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rv = rv.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rv, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeI(iv interface{}, checkPtr, tryNil, checkFastpath, checkCodecSelfer bool) {
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(iv)
0000000000000000000000000000000000000000;;		if checkPtr {
0000000000000000000000000000000000000000;;			if rv.Kind() != reflect.Ptr || rv.IsNil() {
0000000000000000000000000000000000000000;;				d.errNotValidPtrValue(rv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// d.chkPtrValue(rv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rv, proceed := d.preDecodeValue(rv, tryNil)
0000000000000000000000000000000000000000;;		if proceed {
0000000000000000000000000000000000000000;;			fn := d.getDecFn(rv.Type(), checkFastpath, checkCodecSelfer)
0000000000000000000000000000000000000000;;			fn.f(&fn.i, rv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeValue(rv reflect.Value, fn *decFn) {
0000000000000000000000000000000000000000;;		if rv, proceed := d.preDecodeValue(rv, true); proceed {
0000000000000000000000000000000000000000;;			if fn == nil {
0000000000000000000000000000000000000000;;				fn = d.getDecFn(rv.Type(), true, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fn.f(&fn.i, rv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeValueNotNil(rv reflect.Value, fn *decFn) {
0000000000000000000000000000000000000000;;		if rv, proceed := d.preDecodeValue(rv, false); proceed {
0000000000000000000000000000000000000000;;			if fn == nil {
0000000000000000000000000000000000000000;;				fn = d.getDecFn(rv.Type(), true, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fn.f(&fn.i, rv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) getDecFn(rt reflect.Type, checkFastpath, checkCodecSelfer bool) (fn *decFn) {
0000000000000000000000000000000000000000;;		rtid := reflect.ValueOf(rt).Pointer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// retrieve or register a focus'ed function for this type
0000000000000000000000000000000000000000;;		// to eliminate need to do the retrieval multiple times
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if d.f == nil && d.s == nil { debugf("---->Creating new dec f map for type: %v\n", rt) }
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if useMapForCodecCache {
0000000000000000000000000000000000000000;;			fn, ok = d.f[rtid]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for i := range d.s {
0000000000000000000000000000000000000000;;				v := &(d.s[i])
0000000000000000000000000000000000000000;;				if v.rtid == rtid {
0000000000000000000000000000000000000000;;					fn, ok = &(v.fn), true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if useMapForCodecCache {
0000000000000000000000000000000000000000;;			if d.f == nil {
0000000000000000000000000000000000000000;;				d.f = make(map[uintptr]*decFn, initCollectionCap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fn = new(decFn)
0000000000000000000000000000000000000000;;			d.f[rtid] = fn
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if d.s == nil {
0000000000000000000000000000000000000000;;				d.s = make([]decRtidFn, 0, initCollectionCap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.s = append(d.s, decRtidFn{rtid: rtid})
0000000000000000000000000000000000000000;;			fn = &(d.s[len(d.s)-1]).fn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// debugf("\tCreating new dec fn for type: %v\n", rt)
0000000000000000000000000000000000000000;;		ti := d.h.getTypeInfo(rtid, rt)
0000000000000000000000000000000000000000;;		fi := &(fn.i)
0000000000000000000000000000000000000000;;		fi.d = d
0000000000000000000000000000000000000000;;		fi.ti = ti
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// An extension can be registered for any type, regardless of the Kind
0000000000000000000000000000000000000000;;		// (e.g. type BitSet int64, type MyStruct { / * unexported fields * / }, type X []int, etc.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We can't check if it's an extension byte here first, because the user may have
0000000000000000000000000000000000000000;;		// registered a pointer or non-pointer type, meaning we may have to recurse first
0000000000000000000000000000000000000000;;		// before matching a mapped type, even though the extension byte is already detected.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// NOTE: if decoding into a nil interface{}, we return a non-nil
0000000000000000000000000000000000000000;;		// value except even if the container registers a length of 0.
0000000000000000000000000000000000000000;;		if checkCodecSelfer && ti.cs {
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).selferUnmarshal
0000000000000000000000000000000000000000;;		} else if rtid == rawExtTypId {
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).rawExt
0000000000000000000000000000000000000000;;		} else if rtid == rawTypId {
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).raw
0000000000000000000000000000000000000000;;		} else if d.d.IsBuiltinType(rtid) {
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).builtin
0000000000000000000000000000000000000000;;		} else if xfFn := d.h.getExt(rtid); xfFn != nil {
0000000000000000000000000000000000000000;;			fi.xfTag, fi.xfFn = xfFn.tag, xfFn.ext
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).ext
0000000000000000000000000000000000000000;;		} else if supportMarshalInterfaces && d.be && ti.bunm {
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).binaryUnmarshal
0000000000000000000000000000000000000000;;		} else if supportMarshalInterfaces && !d.be && d.js && ti.junm {
0000000000000000000000000000000000000000;;			//If JSON, we should check JSONUnmarshal before textUnmarshal
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).jsonUnmarshal
0000000000000000000000000000000000000000;;		} else if supportMarshalInterfaces && !d.be && ti.tunm {
0000000000000000000000000000000000000000;;			fn.f = (*decFnInfo).textUnmarshal
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rk := rt.Kind()
0000000000000000000000000000000000000000;;			if fastpathEnabled && checkFastpath && (rk == reflect.Map || rk == reflect.Slice) {
0000000000000000000000000000000000000000;;				if rt.PkgPath() == "" {
0000000000000000000000000000000000000000;;					if idx := fastpathAV.index(rtid); idx != -1 {
0000000000000000000000000000000000000000;;						fn.f = fastpathAV[idx].decfn
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// use mapping for underlying type if there
0000000000000000000000000000000000000000;;					ok = false
0000000000000000000000000000000000000000;;					var rtu reflect.Type
0000000000000000000000000000000000000000;;					if rk == reflect.Map {
0000000000000000000000000000000000000000;;						rtu = reflect.MapOf(rt.Key(), rt.Elem())
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						rtu = reflect.SliceOf(rt.Elem())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rtuid := reflect.ValueOf(rtu).Pointer()
0000000000000000000000000000000000000000;;					if idx := fastpathAV.index(rtuid); idx != -1 {
0000000000000000000000000000000000000000;;						xfnf := fastpathAV[idx].decfn
0000000000000000000000000000000000000000;;						xrt := fastpathAV[idx].rt
0000000000000000000000000000000000000000;;						fn.f = func(xf *decFnInfo, xrv reflect.Value) {
0000000000000000000000000000000000000000;;							// xfnf(xf, xrv.Convert(xrt))
0000000000000000000000000000000000000000;;							xfnf(xf, xrv.Addr().Convert(reflect.PtrTo(xrt)).Elem())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fn.f == nil {
0000000000000000000000000000000000000000;;				switch rk {
0000000000000000000000000000000000000000;;				case reflect.String:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kString
0000000000000000000000000000000000000000;;				case reflect.Bool:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kBool
0000000000000000000000000000000000000000;;				case reflect.Int:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kInt
0000000000000000000000000000000000000000;;				case reflect.Int64:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kInt64
0000000000000000000000000000000000000000;;				case reflect.Int32:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kInt32
0000000000000000000000000000000000000000;;				case reflect.Int8:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kInt8
0000000000000000000000000000000000000000;;				case reflect.Int16:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kInt16
0000000000000000000000000000000000000000;;				case reflect.Float32:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kFloat32
0000000000000000000000000000000000000000;;				case reflect.Float64:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kFloat64
0000000000000000000000000000000000000000;;				case reflect.Uint8:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kUint8
0000000000000000000000000000000000000000;;				case reflect.Uint64:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kUint64
0000000000000000000000000000000000000000;;				case reflect.Uint:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kUint
0000000000000000000000000000000000000000;;				case reflect.Uint32:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kUint32
0000000000000000000000000000000000000000;;				case reflect.Uint16:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kUint16
0000000000000000000000000000000000000000;;					// case reflect.Ptr:
0000000000000000000000000000000000000000;;					// 	fn.f = (*decFnInfo).kPtr
0000000000000000000000000000000000000000;;				case reflect.Uintptr:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kUintptr
0000000000000000000000000000000000000000;;				case reflect.Interface:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kInterface
0000000000000000000000000000000000000000;;				case reflect.Struct:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kStruct
0000000000000000000000000000000000000000;;				case reflect.Chan:
0000000000000000000000000000000000000000;;					fi.seq = seqTypeChan
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kSlice
0000000000000000000000000000000000000000;;				case reflect.Slice:
0000000000000000000000000000000000000000;;					fi.seq = seqTypeSlice
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kSlice
0000000000000000000000000000000000000000;;				case reflect.Array:
0000000000000000000000000000000000000000;;					fi.seq = seqTypeArray
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kArray
0000000000000000000000000000000000000000;;				case reflect.Map:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kMap
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					fn.f = (*decFnInfo).kErr
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) structFieldNotFound(index int, rvkencname string) {
0000000000000000000000000000000000000000;;		// NOTE: rvkencname may be a stringView, so don't pass it to another function.
0000000000000000000000000000000000000000;;		if d.h.ErrorIfNoField {
0000000000000000000000000000000000000000;;			if index >= 0 {
0000000000000000000000000000000000000000;;				d.errorf("no matching struct field found when decoding stream array at index %v", index)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			} else if rvkencname != "" {
0000000000000000000000000000000000000000;;				d.errorf("no matching struct field found when decoding stream map with key " + rvkencname)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.swallow()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) arrayCannotExpand(sliceLen, streamLen int) {
0000000000000000000000000000000000000000;;		if d.h.ErrorIfNoArrayExpand {
0000000000000000000000000000000000000000;;			d.errorf("cannot expand array len during decode from %v to %v", sliceLen, streamLen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) chkPtrValue(rv reflect.Value) {
0000000000000000000000000000000000000000;;		// We can only decode into a non-nil pointer
0000000000000000000000000000000000000000;;		if rv.Kind() == reflect.Ptr && !rv.IsNil() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.errNotValidPtrValue(rv)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) errNotValidPtrValue(rv reflect.Value) {
0000000000000000000000000000000000000000;;		if !rv.IsValid() {
0000000000000000000000000000000000000000;;			d.error(cannotDecodeIntoNilErr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !rv.CanInterface() {
0000000000000000000000000000000000000000;;			d.errorf("cannot decode into a value without an interface: %v", rv)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rvi := rv.Interface()
0000000000000000000000000000000000000000;;		d.errorf("cannot decode into non-pointer or nil pointer. Got: %v, %T, %v", rv.Kind(), rvi, rvi)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) error(err error) {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) errorf(format string, params ...interface{}) {
0000000000000000000000000000000000000000;;		params2 := make([]interface{}, len(params)+1)
0000000000000000000000000000000000000000;;		params2[0] = d.r.numread()
0000000000000000000000000000000000000000;;		copy(params2[1:], params)
0000000000000000000000000000000000000000;;		err := fmt.Errorf("[pos %d]: "+format, params2...)
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) string(v []byte) (s string) {
0000000000000000000000000000000000000000;;		if d.is != nil {
0000000000000000000000000000000000000000;;			s, ok := d.is[string(v)] // no allocation here.
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				s = string(v)
0000000000000000000000000000000000000000;;				d.is[s] = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(v) // don't return stringView, as we need a real string here.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) intern(s string) {
0000000000000000000000000000000000000000;;		if d.is != nil {
0000000000000000000000000000000000000000;;			d.is[s] = s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextValueBytes returns the next value in the stream as a set of bytes.
0000000000000000000000000000000000000000;;	func (d *Decoder) nextValueBytes() []byte {
0000000000000000000000000000000000000000;;		d.d.uncacheRead()
0000000000000000000000000000000000000000;;		d.r.track()
0000000000000000000000000000000000000000;;		d.swallow()
0000000000000000000000000000000000000000;;		return d.r.stopTrack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) raw() []byte {
0000000000000000000000000000000000000000;;		// ensure that this is not a view into the bytes
0000000000000000000000000000000000000000;;		// i.e. make new copy always.
0000000000000000000000000000000000000000;;		bs := d.nextValueBytes()
0000000000000000000000000000000000000000;;		bs2 := make([]byte, len(bs))
0000000000000000000000000000000000000000;;		copy(bs2, bs)
0000000000000000000000000000000000000000;;		return bs2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// --------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decSliceHelper assists when decoding into a slice, from a map or an array in the stream.
0000000000000000000000000000000000000000;;	// A slice can be set from a map or array in stream. This supports the MapBySlice interface.
0000000000000000000000000000000000000000;;	type decSliceHelper struct {
0000000000000000000000000000000000000000;;		d *Decoder
0000000000000000000000000000000000000000;;		// ct valueType
0000000000000000000000000000000000000000;;		array bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decSliceHelperStart() (x decSliceHelper, clen int) {
0000000000000000000000000000000000000000;;		dd := d.d
0000000000000000000000000000000000000000;;		ctyp := dd.ContainerType()
0000000000000000000000000000000000000000;;		if ctyp == valueTypeArray {
0000000000000000000000000000000000000000;;			x.array = true
0000000000000000000000000000000000000000;;			clen = dd.ReadArrayStart()
0000000000000000000000000000000000000000;;		} else if ctyp == valueTypeMap {
0000000000000000000000000000000000000000;;			clen = dd.ReadMapStart() * 2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.errorf("only encoded map or array can be decoded into a slice (%d)", ctyp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// x.ct = ctyp
0000000000000000000000000000000000000000;;		x.d = d
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x decSliceHelper) End() {
0000000000000000000000000000000000000000;;		cr := x.d.cr
0000000000000000000000000000000000000000;;		if cr == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x.array {
0000000000000000000000000000000000000000;;			cr.sendContainerState(containerArrayEnd)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			cr.sendContainerState(containerMapEnd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x decSliceHelper) ElemContainerState(index int) {
0000000000000000000000000000000000000000;;		cr := x.d.cr
0000000000000000000000000000000000000000;;		if cr == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x.array {
0000000000000000000000000000000000000000;;			cr.sendContainerState(containerArrayElem)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if index%2 == 0 {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapKey)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cr.sendContainerState(containerMapValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decByteSlice(r decReader, clen int, bs []byte) (bsOut []byte) {
0000000000000000000000000000000000000000;;		if clen == 0 {
0000000000000000000000000000000000000000;;			return zeroByteSlice
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(bs) == clen {
0000000000000000000000000000000000000000;;			bsOut = bs
0000000000000000000000000000000000000000;;		} else if cap(bs) >= clen {
0000000000000000000000000000000000000000;;			bsOut = bs[:clen]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bsOut = make([]byte, clen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.readb(bsOut)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func detachZeroCopyBytes(isBytesReader bool, dest []byte, in []byte) (out []byte) {
0000000000000000000000000000000000000000;;		if xlen := len(in); xlen > 0 {
0000000000000000000000000000000000000000;;			if isBytesReader || xlen <= scratchByteArrayLen {
0000000000000000000000000000000000000000;;				if cap(dest) >= xlen {
0000000000000000000000000000000000000000;;					out = dest[:xlen]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					out = make([]byte, xlen)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				copy(out, in)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return in
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decInferLen will infer a sensible length, given the following:
0000000000000000000000000000000000000000;;	//    - clen: length wanted.
0000000000000000000000000000000000000000;;	//    - maxlen: max length to be returned.
0000000000000000000000000000000000000000;;	//      if <= 0, it is unset, and we infer it based on the unit size
0000000000000000000000000000000000000000;;	//    - unit: number of bytes for each element of the collection
0000000000000000000000000000000000000000;;	func decInferLen(clen, maxlen, unit int) (rvlen int, truncated bool) {
0000000000000000000000000000000000000000;;		// handle when maxlen is not set i.e. <= 0
0000000000000000000000000000000000000000;;		if clen <= 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if maxlen <= 0 {
0000000000000000000000000000000000000000;;			// no maxlen defined. Use maximum of 256K memory, with a floor of 4K items.
0000000000000000000000000000000000000000;;			// maxlen = 256 * 1024 / unit
0000000000000000000000000000000000000000;;			// if maxlen < (4 * 1024) {
0000000000000000000000000000000000000000;;			// 	maxlen = 4 * 1024
0000000000000000000000000000000000000000;;			// }
0000000000000000000000000000000000000000;;			if unit < (256 / 4) {
0000000000000000000000000000000000000000;;				maxlen = 256 * 1024 / unit
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				maxlen = 4 * 1024
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if clen > maxlen {
0000000000000000000000000000000000000000;;			rvlen = maxlen
0000000000000000000000000000000000000000;;			truncated = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rvlen = clen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;		// if clen <= 0 {
0000000000000000000000000000000000000000;;		// 	rvlen = 0
0000000000000000000000000000000000000000;;		// } else if maxlen > 0 && clen > maxlen {
0000000000000000000000000000000000000000;;		// 	rvlen = maxlen
0000000000000000000000000000000000000000;;		// 	truncated = true
0000000000000000000000000000000000000000;;		// } else {
0000000000000000000000000000000000000000;;		// 	rvlen = clen
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		// return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// // implement overall decReader wrapping both, for possible use inline:
0000000000000000000000000000000000000000;;	// type decReaderT struct {
0000000000000000000000000000000000000000;;	// 	bytes bool
0000000000000000000000000000000000000000;;	// 	rb    *bytesDecReader
0000000000000000000000000000000000000000;;	// 	ri    *ioDecReader
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// // implement *Decoder as a decReader.
0000000000000000000000000000000000000000;;	// // Using decReaderT (defined just above) caused performance degradation
0000000000000000000000000000000000000000;;	// // possibly because of constant copying the value,
0000000000000000000000000000000000000000;;	// // and some value->interface conversion causing allocation.
0000000000000000000000000000000000000000;;	// func (d *Decoder) unreadn1() {
0000000000000000000000000000000000000000;;	// 	if d.bytes {
0000000000000000000000000000000000000000;;	// 		d.rb.unreadn1()
0000000000000000000000000000000000000000;;	// 	} else {
0000000000000000000000000000000000000000;;	// 		d.ri.unreadn1()
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	// ... for other methods of decReader.
0000000000000000000000000000000000000000;;	// Testing showed that performance improvement was negligible.
