0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/json.go[Godeps/_workspace/src/github.com/ugorji/go/codec/json.go][vendor/github.com/ugorji/go/codec/json.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// By default, this json support uses base64 encoding for bytes, because you cannot
0000000000000000000000000000000000000000;;	// store and read any arbitrary string in json (only unicode).
0000000000000000000000000000000000000000;;	// However, the user can configre how to encode/decode bytes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This library specifically supports UTF-8 for encoding and decoding only.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that the library will happily encode/decode things which are not valid
0000000000000000000000000000000000000000;;	// json e.g. a map[int64]string. We do it for consistency. With valid json,
0000000000000000000000000000000000000000;;	// we will encode and decode appropriately.
0000000000000000000000000000000000000000;;	// Users can specify their map type if necessary to force it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	//   - we cannot use strconv.Quote and strconv.Unquote because json quotes/unquotes differently.
0000000000000000000000000000000000000000;;	//     We implement it here.
0000000000000000000000000000000000000000;;	//   - Also, strconv.ParseXXX for floats and integers
0000000000000000000000000000000000000000;;	//     - only works on strings resulting in unnecessary allocation and []byte-string conversion.
0000000000000000000000000000000000000000;;	//     - it does a lot of redundant checks, because json numbers are simpler that what it supports.
0000000000000000000000000000000000000000;;	//   - We parse numbers (floats and integers) directly here.
0000000000000000000000000000000000000000;;	//     We only delegate parsing floats if it is a hairy float which could cause a loss of precision.
0000000000000000000000000000000000000000;;	//     In that case, we delegate to strconv.ParseFloat.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note:
0000000000000000000000000000000000000000;;	//   - encode does not beautify. There is no whitespace when encoding.
0000000000000000000000000000000000000000;;	//   - rpc calls which take single integer arguments or write single numeric arguments will need care.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Top-level methods of json(End|Dec)Driver (which are implementations of (en|de)cDriver
0000000000000000000000000000000000000000;;	// MUST not call one-another.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"unicode/utf16"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//--------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		jsonLiterals = [...]byte{'t', 'r', 'u', 'e', 'f', 'a', 'l', 's', 'e', 'n', 'u', 'l', 'l'}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonFloat64Pow10 = [...]float64{
0000000000000000000000000000000000000000;;			1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
0000000000000000000000000000000000000000;;			1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
0000000000000000000000000000000000000000;;			1e20, 1e21, 1e22,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonUint64Pow10 = [...]uint64{
0000000000000000000000000000000000000000;;			1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9,
0000000000000000000000000000000000000000;;			1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// jsonTabs and jsonSpaces are used as caches for indents
0000000000000000000000000000000000000000;;		jsonTabs, jsonSpaces string
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// jsonUnreadAfterDecNum controls whether we unread after decoding a number.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// instead of unreading, just update d.tok (iff it's not a whitespace char)
0000000000000000000000000000000000000000;;		// However, doing this means that we may HOLD onto some data which belongs to another stream.
0000000000000000000000000000000000000000;;		// Thus, it is safest to unread the data when done.
0000000000000000000000000000000000000000;;		// keep behind a constant flag for now.
0000000000000000000000000000000000000000;;		jsonUnreadAfterDecNum = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If !jsonValidateSymbols, decoding will be faster, by skipping some checks:
0000000000000000000000000000000000000000;;		//   - If we see first character of null, false or true,
0000000000000000000000000000000000000000;;		//     do not validate subsequent characters.
0000000000000000000000000000000000000000;;		//   - e.g. if we see a n, assume null and skip next 3 characters,
0000000000000000000000000000000000000000;;		//     and do not validate they are ull.
0000000000000000000000000000000000000000;;		// P.S. Do not expect a significant decoding boost from this.
0000000000000000000000000000000000000000;;		jsonValidateSymbols = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if jsonTruncateMantissa, truncate mantissa if trailing 0's.
0000000000000000000000000000000000000000;;		// This is important because it could allow some floats to be decoded without
0000000000000000000000000000000000000000;;		// deferring to strconv.ParseFloat.
0000000000000000000000000000000000000000;;		jsonTruncateMantissa = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if mantissa >= jsonNumUintCutoff before multiplying by 10, this is an overflow
0000000000000000000000000000000000000000;;		jsonNumUintCutoff = (1<<64-1)/uint64(10) + 1 // cutoff64(base)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if mantissa >= jsonNumUintMaxVal, this is an overflow
0000000000000000000000000000000000000000;;		jsonNumUintMaxVal = 1<<uint64(64) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// jsonNumDigitsUint64Largest = 19
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonSpacesOrTabsLen = 128
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		var bs [jsonSpacesOrTabsLen]byte
0000000000000000000000000000000000000000;;		for i := 0; i < jsonSpacesOrTabsLen; i++ {
0000000000000000000000000000000000000000;;			bs[i] = ' '
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jsonSpaces = string(bs[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < jsonSpacesOrTabsLen; i++ {
0000000000000000000000000000000000000000;;			bs[i] = '\t'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		jsonTabs = string(bs[:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jsonEncDriver struct {
0000000000000000000000000000000000000000;;		e  *Encoder
0000000000000000000000000000000000000000;;		w  encWriter
0000000000000000000000000000000000000000;;		h  *JsonHandle
0000000000000000000000000000000000000000;;		b  [64]byte // scratch
0000000000000000000000000000000000000000;;		bs []byte   // scratch
0000000000000000000000000000000000000000;;		se setExtWrapper
0000000000000000000000000000000000000000;;		ds string // indent string
0000000000000000000000000000000000000000;;		dl uint16 // indent level
0000000000000000000000000000000000000000;;		dt bool   // indent using tabs
0000000000000000000000000000000000000000;;		d  bool   // indent
0000000000000000000000000000000000000000;;		c  containerState
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// indent is done as below:
0000000000000000000000000000000000000000;;	//   - newline and indent are added before each mapKey or arrayElem
0000000000000000000000000000000000000000;;	//   - newline and indent are added before each ending,
0000000000000000000000000000000000000000;;	//     except there was no entry (so we can have {} or [])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) sendContainerState(c containerState) {
0000000000000000000000000000000000000000;;		// determine whether to output separators
0000000000000000000000000000000000000000;;		if c == containerMapKey {
0000000000000000000000000000000000000000;;			if e.c != containerMapStart {
0000000000000000000000000000000000000000;;				e.w.writen1(',')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e.d {
0000000000000000000000000000000000000000;;				e.writeIndent()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c == containerMapValue {
0000000000000000000000000000000000000000;;			if e.d {
0000000000000000000000000000000000000000;;				e.w.writen2(':', ' ')
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.w.writen1(':')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c == containerMapEnd {
0000000000000000000000000000000000000000;;			if e.d {
0000000000000000000000000000000000000000;;				e.dl--
0000000000000000000000000000000000000000;;				if e.c != containerMapStart {
0000000000000000000000000000000000000000;;					e.writeIndent()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.w.writen1('}')
0000000000000000000000000000000000000000;;		} else if c == containerArrayElem {
0000000000000000000000000000000000000000;;			if e.c != containerArrayStart {
0000000000000000000000000000000000000000;;				e.w.writen1(',')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e.d {
0000000000000000000000000000000000000000;;				e.writeIndent()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c == containerArrayEnd {
0000000000000000000000000000000000000000;;			if e.d {
0000000000000000000000000000000000000000;;				e.dl--
0000000000000000000000000000000000000000;;				if e.c != containerArrayStart {
0000000000000000000000000000000000000000;;					e.writeIndent()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.w.writen1(']')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.c = c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) writeIndent() {
0000000000000000000000000000000000000000;;		e.w.writen1('\n')
0000000000000000000000000000000000000000;;		if x := len(e.ds) * int(e.dl); x <= jsonSpacesOrTabsLen {
0000000000000000000000000000000000000000;;			if e.dt {
0000000000000000000000000000000000000000;;				e.w.writestr(jsonTabs[:x])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.w.writestr(jsonSpaces[:x])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for i := uint16(0); i < e.dl; i++ {
0000000000000000000000000000000000000000;;				e.w.writestr(e.ds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeNil() {
0000000000000000000000000000000000000000;;		e.w.writeb(jsonLiterals[9:13]) // null
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeBool(b bool) {
0000000000000000000000000000000000000000;;		if b {
0000000000000000000000000000000000000000;;			e.w.writeb(jsonLiterals[0:4]) // true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e.w.writeb(jsonLiterals[4:9]) // false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeFloat32(f float32) {
0000000000000000000000000000000000000000;;		e.encodeFloat(float64(f), 32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeFloat64(f float64) {
0000000000000000000000000000000000000000;;		// e.w.writestr(strconv.FormatFloat(f, 'E', -1, 64))
0000000000000000000000000000000000000000;;		e.encodeFloat(f, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) encodeFloat(f float64, numbits int) {
0000000000000000000000000000000000000000;;		x := strconv.AppendFloat(e.b[:0], f, 'G', -1, numbits)
0000000000000000000000000000000000000000;;		e.w.writeb(x)
0000000000000000000000000000000000000000;;		if bytes.IndexByte(x, 'E') == -1 && bytes.IndexByte(x, '.') == -1 {
0000000000000000000000000000000000000000;;			e.w.writen2('.', '0')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeInt(v int64) {
0000000000000000000000000000000000000000;;		if x := e.h.IntegerAsString; x == 'A' || x == 'L' && (v > 1<<53 || v < -(1<<53)) {
0000000000000000000000000000000000000000;;			e.w.writen1('"')
0000000000000000000000000000000000000000;;			e.w.writeb(strconv.AppendInt(e.b[:0], v, 10))
0000000000000000000000000000000000000000;;			e.w.writen1('"')
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w.writeb(strconv.AppendInt(e.b[:0], v, 10))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeUint(v uint64) {
0000000000000000000000000000000000000000;;		if x := e.h.IntegerAsString; x == 'A' || x == 'L' && v > 1<<53 {
0000000000000000000000000000000000000000;;			e.w.writen1('"')
0000000000000000000000000000000000000000;;			e.w.writeb(strconv.AppendUint(e.b[:0], v, 10))
0000000000000000000000000000000000000000;;			e.w.writen1('"')
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w.writeb(strconv.AppendUint(e.b[:0], v, 10))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeExt(rv interface{}, xtag uint64, ext Ext, en *Encoder) {
0000000000000000000000000000000000000000;;		if v := ext.ConvertExt(rv); v == nil {
0000000000000000000000000000000000000000;;			e.w.writeb(jsonLiterals[9:13]) // null // e.EncodeNil()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			en.encode(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeRawExt(re *RawExt, en *Encoder) {
0000000000000000000000000000000000000000;;		// only encodes re.Value (never re.Data)
0000000000000000000000000000000000000000;;		if re.Value == nil {
0000000000000000000000000000000000000000;;			e.w.writeb(jsonLiterals[9:13]) // null // e.EncodeNil()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			en.encode(re.Value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeArrayStart(length int) {
0000000000000000000000000000000000000000;;		if e.d {
0000000000000000000000000000000000000000;;			e.dl++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w.writen1('[')
0000000000000000000000000000000000000000;;		e.c = containerArrayStart
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeMapStart(length int) {
0000000000000000000000000000000000000000;;		if e.d {
0000000000000000000000000000000000000000;;			e.dl++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.w.writen1('{')
0000000000000000000000000000000000000000;;		e.c = containerMapStart
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeString(c charEncoding, v string) {
0000000000000000000000000000000000000000;;		// e.w.writestr(strconv.Quote(v))
0000000000000000000000000000000000000000;;		e.quoteStr(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeSymbol(v string) {
0000000000000000000000000000000000000000;;		// e.EncodeString(c_UTF8, v)
0000000000000000000000000000000000000000;;		e.quoteStr(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeStringBytes(c charEncoding, v []byte) {
0000000000000000000000000000000000000000;;		// if encoding raw bytes and RawBytesExt is configured, use it to encode
0000000000000000000000000000000000000000;;		if c == c_RAW && e.se.i != nil {
0000000000000000000000000000000000000000;;			e.EncodeExt(v, 0, &e.se, e.e)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == c_RAW {
0000000000000000000000000000000000000000;;			slen := base64.StdEncoding.EncodedLen(len(v))
0000000000000000000000000000000000000000;;			if cap(e.bs) >= slen {
0000000000000000000000000000000000000000;;				e.bs = e.bs[:slen]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				e.bs = make([]byte, slen)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			base64.StdEncoding.Encode(e.bs, v)
0000000000000000000000000000000000000000;;			e.w.writen1('"')
0000000000000000000000000000000000000000;;			e.w.writeb(e.bs)
0000000000000000000000000000000000000000;;			e.w.writen1('"')
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// e.EncodeString(c, string(v))
0000000000000000000000000000000000000000;;			e.quoteStr(stringView(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) EncodeAsis(v []byte) {
0000000000000000000000000000000000000000;;		e.w.writeb(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) quoteStr(s string) {
0000000000000000000000000000000000000000;;		// adapted from std pkg encoding/json
0000000000000000000000000000000000000000;;		const hex = "0123456789abcdef"
0000000000000000000000000000000000000000;;		w := e.w
0000000000000000000000000000000000000000;;		w.writen1('"')
0000000000000000000000000000000000000000;;		start := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); {
0000000000000000000000000000000000000000;;			if b := s[i]; b < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				if 0x20 <= b && b != '\\' && b != '"' && b != '<' && b != '>' && b != '&' {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					w.writestr(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch b {
0000000000000000000000000000000000000000;;				case '\\', '"':
0000000000000000000000000000000000000000;;					w.writen2('\\', b)
0000000000000000000000000000000000000000;;				case '\n':
0000000000000000000000000000000000000000;;					w.writen2('\\', 'n')
0000000000000000000000000000000000000000;;				case '\r':
0000000000000000000000000000000000000000;;					w.writen2('\\', 'r')
0000000000000000000000000000000000000000;;				case '\b':
0000000000000000000000000000000000000000;;					w.writen2('\\', 'b')
0000000000000000000000000000000000000000;;				case '\f':
0000000000000000000000000000000000000000;;					w.writen2('\\', 'f')
0000000000000000000000000000000000000000;;				case '\t':
0000000000000000000000000000000000000000;;					w.writen2('\\', 't')
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// encode all bytes < 0x20 (except \r, \n).
0000000000000000000000000000000000000000;;					// also encode < > & to prevent security holes when served to some browsers.
0000000000000000000000000000000000000000;;					w.writestr(`\u00`)
0000000000000000000000000000000000000000;;					w.writen2(hex[b>>4], hex[b&0xF])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c, size := utf8.DecodeRuneInString(s[i:])
0000000000000000000000000000000000000000;;			if c == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					w.writestr(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.writestr(`\ufffd`)
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// U+2028 is LINE SEPARATOR. U+2029 is PARAGRAPH SEPARATOR.
0000000000000000000000000000000000000000;;			// Both technically valid JSON, but bomb on JSONP, so fix here.
0000000000000000000000000000000000000000;;			if c == '\u2028' || c == '\u2029' {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					w.writestr(s[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.writestr(`\u202`)
0000000000000000000000000000000000000000;;				w.writen1(hex[c&0xF])
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;				start = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start < len(s) {
0000000000000000000000000000000000000000;;			w.writestr(s[start:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.writen1('"')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//--------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jsonNum struct {
0000000000000000000000000000000000000000;;		// bytes            []byte // may have [+-.eE0-9]
0000000000000000000000000000000000000000;;		mantissa         uint64 // where mantissa ends, and maybe dot begins.
0000000000000000000000000000000000000000;;		exponent         int16  // exponent value.
0000000000000000000000000000000000000000;;		manOverflow      bool
0000000000000000000000000000000000000000;;		neg              bool // started with -. No initial sign in the bytes above.
0000000000000000000000000000000000000000;;		dot              bool // has dot
0000000000000000000000000000000000000000;;		explicitExponent bool // explicit exponent
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *jsonNum) reset() {
0000000000000000000000000000000000000000;;		x.manOverflow = false
0000000000000000000000000000000000000000;;		x.neg = false
0000000000000000000000000000000000000000;;		x.dot = false
0000000000000000000000000000000000000000;;		x.explicitExponent = false
0000000000000000000000000000000000000000;;		x.mantissa = 0
0000000000000000000000000000000000000000;;		x.exponent = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// uintExp is called only if exponent > 0.
0000000000000000000000000000000000000000;;	func (x *jsonNum) uintExp() (n uint64, overflow bool) {
0000000000000000000000000000000000000000;;		n = x.mantissa
0000000000000000000000000000000000000000;;		e := x.exponent
0000000000000000000000000000000000000000;;		if e >= int16(len(jsonUint64Pow10)) {
0000000000000000000000000000000000000000;;			overflow = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n *= jsonUint64Pow10[e]
0000000000000000000000000000000000000000;;		if n < x.mantissa || n > jsonNumUintMaxVal {
0000000000000000000000000000000000000000;;			overflow = true
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;		// for i := int16(0); i < e; i++ {
0000000000000000000000000000000000000000;;		// 	if n >= jsonNumUintCutoff {
0000000000000000000000000000000000000000;;		// 		overflow = true
0000000000000000000000000000000000000000;;		// 		return
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		// 	n *= 10
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		// return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// these constants are only used withn floatVal.
0000000000000000000000000000000000000000;;	// They are brought out, so that floatVal can be inlined.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		jsonUint64MantissaBits = 52
0000000000000000000000000000000000000000;;		jsonMaxExponent        = int16(len(jsonFloat64Pow10)) - 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *jsonNum) floatVal() (f float64, parseUsingStrConv bool) {
0000000000000000000000000000000000000000;;		// We do not want to lose precision.
0000000000000000000000000000000000000000;;		// Consequently, we will delegate to strconv.ParseFloat if any of the following happen:
0000000000000000000000000000000000000000;;		//    - There are more digits than in math.MaxUint64: 18446744073709551615 (20 digits)
0000000000000000000000000000000000000000;;		//      We expect up to 99.... (19 digits)
0000000000000000000000000000000000000000;;		//    - The mantissa cannot fit into a 52 bits of uint64
0000000000000000000000000000000000000000;;		//    - The exponent is beyond our scope ie beyong 22.
0000000000000000000000000000000000000000;;		parseUsingStrConv = x.manOverflow ||
0000000000000000000000000000000000000000;;			x.exponent > jsonMaxExponent ||
0000000000000000000000000000000000000000;;			(x.exponent < 0 && -(x.exponent) > jsonMaxExponent) ||
0000000000000000000000000000000000000000;;			x.mantissa>>jsonUint64MantissaBits != 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parseUsingStrConv {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// all good. so handle parse here.
0000000000000000000000000000000000000000;;		f = float64(x.mantissa)
0000000000000000000000000000000000000000;;		// fmt.Printf(".Float: uint64 value: %v, float: %v\n", m, f)
0000000000000000000000000000000000000000;;		if x.neg {
0000000000000000000000000000000000000000;;			f = -f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if x.exponent > 0 {
0000000000000000000000000000000000000000;;			f *= jsonFloat64Pow10[x.exponent]
0000000000000000000000000000000000000000;;		} else if x.exponent < 0 {
0000000000000000000000000000000000000000;;			f /= jsonFloat64Pow10[-x.exponent]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type jsonDecDriver struct {
0000000000000000000000000000000000000000;;		noBuiltInTypes
0000000000000000000000000000000000000000;;		d *Decoder
0000000000000000000000000000000000000000;;		h *JsonHandle
0000000000000000000000000000000000000000;;		r decReader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c containerState
0000000000000000000000000000000000000000;;		// tok is used to store the token read right after skipWhiteSpace.
0000000000000000000000000000000000000000;;		tok uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bstr [8]byte  // scratch used for string \UXXX parsing
0000000000000000000000000000000000000000;;		b    [64]byte // scratch, used for parsing strings or numbers
0000000000000000000000000000000000000000;;		b2   [64]byte // scratch, used only for decodeBytes (after base64)
0000000000000000000000000000000000000000;;		bs   []byte   // scratch. Initialized from b. Used for parsing strings or numbers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		se setExtWrapper
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n jsonNum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func jsonIsWS(b byte) bool {
0000000000000000000000000000000000000000;;		return b == ' ' || b == '\t' || b == '\r' || b == '\n'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// // This will skip whitespace characters and return the next byte to read.
0000000000000000000000000000000000000000;;	// // The next byte determines what the value will be one of.
0000000000000000000000000000000000000000;;	// func (d *jsonDecDriver) skipWhitespace() {
0000000000000000000000000000000000000000;;	// 	// fast-path: do not enter loop. Just check first (in case no whitespace).
0000000000000000000000000000000000000000;;	// 	b := d.r.readn1()
0000000000000000000000000000000000000000;;	// 	if jsonIsWS(b) {
0000000000000000000000000000000000000000;;	// 		r := d.r
0000000000000000000000000000000000000000;;	// 		for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;	// 		}
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	d.tok = b
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) uncacheRead() {
0000000000000000000000000000000000000000;;		if d.tok != 0 {
0000000000000000000000000000000000000000;;			d.r.unreadn1()
0000000000000000000000000000000000000000;;			d.tok = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) sendContainerState(c containerState) {
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var xc uint8 // char expected
0000000000000000000000000000000000000000;;		if c == containerMapKey {
0000000000000000000000000000000000000000;;			if d.c != containerMapStart {
0000000000000000000000000000000000000000;;				xc = ','
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c == containerMapValue {
0000000000000000000000000000000000000000;;			xc = ':'
0000000000000000000000000000000000000000;;		} else if c == containerMapEnd {
0000000000000000000000000000000000000000;;			xc = '}'
0000000000000000000000000000000000000000;;		} else if c == containerArrayElem {
0000000000000000000000000000000000000000;;			if d.c != containerArrayStart {
0000000000000000000000000000000000000000;;				xc = ','
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if c == containerArrayEnd {
0000000000000000000000000000000000000000;;			xc = ']'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if xc != 0 {
0000000000000000000000000000000000000000;;			if d.tok != xc {
0000000000000000000000000000000000000000;;				d.d.errorf("json: expect char '%c' but got char '%c'", xc, d.tok)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.c = c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) CheckBreak() bool {
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.tok == '}' || d.tok == ']' {
0000000000000000000000000000000000000000;;			// d.tok = 0 // only checking, not consuming
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) readStrIdx(fromIdx, toIdx uint8) {
0000000000000000000000000000000000000000;;		bs := d.r.readx(int(toIdx - fromIdx))
0000000000000000000000000000000000000000;;		d.tok = 0
0000000000000000000000000000000000000000;;		if jsonValidateSymbols {
0000000000000000000000000000000000000000;;			if !bytes.Equal(bs, jsonLiterals[fromIdx:toIdx]) {
0000000000000000000000000000000000000000;;				d.d.errorf("json: expecting %s: got %s", jsonLiterals[fromIdx:toIdx], bs)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) TryDecodeAsNil() bool {
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.tok == 'n' {
0000000000000000000000000000000000000000;;			d.readStrIdx(10, 13) // ull
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeBool() bool {
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.tok == 'f' {
0000000000000000000000000000000000000000;;			d.readStrIdx(5, 9) // alse
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.tok == 't' {
0000000000000000000000000000000000000000;;			d.readStrIdx(1, 4) // rue
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.d.errorf("json: decode bool: got first char %c", d.tok)
0000000000000000000000000000000000000000;;		return false // "unreachable"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) ReadMapStart() int {
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.tok != '{' {
0000000000000000000000000000000000000000;;			d.d.errorf("json: expect char '%c' but got char '%c'", '{', d.tok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.tok = 0
0000000000000000000000000000000000000000;;		d.c = containerMapStart
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) ReadArrayStart() int {
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d.tok != '[' {
0000000000000000000000000000000000000000;;			d.d.errorf("json: expect char '%c' but got char '%c'", '[', d.tok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.tok = 0
0000000000000000000000000000000000000000;;		d.c = containerArrayStart
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) ContainerType() (vt valueType) {
0000000000000000000000000000000000000000;;		// check container type by checking the first char
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b := d.tok; b == '{' {
0000000000000000000000000000000000000000;;			return valueTypeMap
0000000000000000000000000000000000000000;;		} else if b == '[' {
0000000000000000000000000000000000000000;;			return valueTypeArray
0000000000000000000000000000000000000000;;		} else if b == 'n' {
0000000000000000000000000000000000000000;;			return valueTypeNil
0000000000000000000000000000000000000000;;		} else if b == '"' {
0000000000000000000000000000000000000000;;			return valueTypeString
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return valueTypeUnset
0000000000000000000000000000000000000000;;		// d.d.errorf("isContainerType: unsupported parameter: %v", vt)
0000000000000000000000000000000000000000;;		// return false // "unreachable"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) decNum(storeBytes bool) {
0000000000000000000000000000000000000000;;		// If it is has a . or an e|E, decode as a float; else decode as an int.
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := d.tok
0000000000000000000000000000000000000000;;		var str bool
0000000000000000000000000000000000000000;;		if b == '"' {
0000000000000000000000000000000000000000;;			str = true
0000000000000000000000000000000000000000;;			b = d.r.readn1()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !(b == '+' || b == '-' || b == '.' || (b >= '0' && b <= '9')) {
0000000000000000000000000000000000000000;;			d.d.errorf("json: decNum: got first char '%c'", b)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.tok = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const cutoff = (1<<64-1)/uint64(10) + 1 // cutoff64(base)
0000000000000000000000000000000000000000;;		const jsonNumUintMaxVal = 1<<uint64(64) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := &d.n
0000000000000000000000000000000000000000;;		r := d.r
0000000000000000000000000000000000000000;;		n.reset()
0000000000000000000000000000000000000000;;		d.bs = d.bs[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if str && storeBytes {
0000000000000000000000000000000000000000;;			d.bs = append(d.bs, '"')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The format of a number is as below:
0000000000000000000000000000000000000000;;		// parsing:     sign? digit* dot? digit* e?  sign? digit*
0000000000000000000000000000000000000000;;		// states:  0   1*    2      3*   4      5*  6     7
0000000000000000000000000000000000000000;;		// We honor this state so we can break correctly.
0000000000000000000000000000000000000000;;		var state uint8 = 0
0000000000000000000000000000000000000000;;		var eNeg bool
0000000000000000000000000000000000000000;;		var e int16
0000000000000000000000000000000000000000;;		var eof bool
0000000000000000000000000000000000000000;;	LOOP:
0000000000000000000000000000000000000000;;		for !eof {
0000000000000000000000000000000000000000;;			// fmt.Printf("LOOP: b: %q\n", b)
0000000000000000000000000000000000000000;;			switch b {
0000000000000000000000000000000000000000;;			case '+':
0000000000000000000000000000000000000000;;				switch state {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					state = 2
0000000000000000000000000000000000000000;;					// do not add sign to the slice ...
0000000000000000000000000000000000000000;;					b, eof = r.readn1eof()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case 6: // typ = jsonNumFloat
0000000000000000000000000000000000000000;;					state = 7
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					break LOOP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '-':
0000000000000000000000000000000000000000;;				switch state {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					state = 2
0000000000000000000000000000000000000000;;					n.neg = true
0000000000000000000000000000000000000000;;					// do not add sign to the slice ...
0000000000000000000000000000000000000000;;					b, eof = r.readn1eof()
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case 6: // typ = jsonNumFloat
0000000000000000000000000000000000000000;;					eNeg = true
0000000000000000000000000000000000000000;;					state = 7
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					break LOOP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '.':
0000000000000000000000000000000000000000;;				switch state {
0000000000000000000000000000000000000000;;				case 0, 2: // typ = jsonNumFloat
0000000000000000000000000000000000000000;;					state = 4
0000000000000000000000000000000000000000;;					n.dot = true
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					break LOOP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case 'e', 'E':
0000000000000000000000000000000000000000;;				switch state {
0000000000000000000000000000000000000000;;				case 0, 2, 4: // typ = jsonNumFloat
0000000000000000000000000000000000000000;;					state = 6
0000000000000000000000000000000000000000;;					// n.mantissaEndIndex = int16(len(n.bytes))
0000000000000000000000000000000000000000;;					n.explicitExponent = true
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					break LOOP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
0000000000000000000000000000000000000000;;				switch state {
0000000000000000000000000000000000000000;;				case 0:
0000000000000000000000000000000000000000;;					state = 2
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case 2:
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case 4:
0000000000000000000000000000000000000000;;					if n.dot {
0000000000000000000000000000000000000000;;						n.exponent--
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if n.mantissa >= jsonNumUintCutoff {
0000000000000000000000000000000000000000;;						n.manOverflow = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v := uint64(b - '0')
0000000000000000000000000000000000000000;;					n.mantissa *= 10
0000000000000000000000000000000000000000;;					if v != 0 {
0000000000000000000000000000000000000000;;						n1 := n.mantissa + v
0000000000000000000000000000000000000000;;						if n1 < n.mantissa || n1 > jsonNumUintMaxVal {
0000000000000000000000000000000000000000;;							n.manOverflow = true // n+v overflows
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						n.mantissa = n1
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case 6:
0000000000000000000000000000000000000000;;					state = 7
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case 7:
0000000000000000000000000000000000000000;;					if !(b == '0' && e == 0) {
0000000000000000000000000000000000000000;;						e = e*10 + int16(b-'0')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					break LOOP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				if str {
0000000000000000000000000000000000000000;;					if storeBytes {
0000000000000000000000000000000000000000;;						d.bs = append(d.bs, '"')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					b, eof = r.readn1eof()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break LOOP
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				break LOOP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if storeBytes {
0000000000000000000000000000000000000000;;				d.bs = append(d.bs, b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b, eof = r.readn1eof()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if jsonTruncateMantissa && n.mantissa != 0 {
0000000000000000000000000000000000000000;;			for n.mantissa%10 == 0 {
0000000000000000000000000000000000000000;;				n.mantissa /= 10
0000000000000000000000000000000000000000;;				n.exponent++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e != 0 {
0000000000000000000000000000000000000000;;			if eNeg {
0000000000000000000000000000000000000000;;				n.exponent -= e
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n.exponent += e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// d.n = n
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !eof {
0000000000000000000000000000000000000000;;			if jsonUnreadAfterDecNum {
0000000000000000000000000000000000000000;;				r.unreadn1()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if !jsonIsWS(b) {
0000000000000000000000000000000000000000;;					d.tok = b
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// fmt.Printf("1: n: bytes: %s, neg: %v, dot: %v, exponent: %v, mantissaEndIndex: %v\n",
0000000000000000000000000000000000000000;;		// 	n.bytes, n.neg, n.dot, n.exponent, n.mantissaEndIndex)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeInt(bitsize uint8) (i int64) {
0000000000000000000000000000000000000000;;		d.decNum(false)
0000000000000000000000000000000000000000;;		n := &d.n
0000000000000000000000000000000000000000;;		if n.manOverflow {
0000000000000000000000000000000000000000;;			d.d.errorf("json: overflow integer after: %v", n.mantissa)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var u uint64
0000000000000000000000000000000000000000;;		if n.exponent == 0 {
0000000000000000000000000000000000000000;;			u = n.mantissa
0000000000000000000000000000000000000000;;		} else if n.exponent < 0 {
0000000000000000000000000000000000000000;;			d.d.errorf("json: fractional integer")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if n.exponent > 0 {
0000000000000000000000000000000000000000;;			var overflow bool
0000000000000000000000000000000000000000;;			if u, overflow = n.uintExp(); overflow {
0000000000000000000000000000000000000000;;				d.d.errorf("json: overflow integer")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i = int64(u)
0000000000000000000000000000000000000000;;		if n.neg {
0000000000000000000000000000000000000000;;			i = -i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOvf.Int(i, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("json: overflow %v bits: %s", bitsize, d.bs)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// fmt.Printf("DecodeInt: %v\n", i)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// floatVal MUST only be called after a decNum, as d.bs now contains the bytes of the number
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) floatVal() (f float64) {
0000000000000000000000000000000000000000;;		f, useStrConv := d.n.floatVal()
0000000000000000000000000000000000000000;;		if useStrConv {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if f, err = strconv.ParseFloat(stringView(d.bs), 64); err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Errorf("parse float: %s, %v", d.bs, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if d.n.neg {
0000000000000000000000000000000000000000;;				f = -f
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeUint(bitsize uint8) (u uint64) {
0000000000000000000000000000000000000000;;		d.decNum(false)
0000000000000000000000000000000000000000;;		n := &d.n
0000000000000000000000000000000000000000;;		if n.neg {
0000000000000000000000000000000000000000;;			d.d.errorf("json: unsigned integer cannot be negative")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.manOverflow {
0000000000000000000000000000000000000000;;			d.d.errorf("json: overflow integer after: %v", n.mantissa)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.exponent == 0 {
0000000000000000000000000000000000000000;;			u = n.mantissa
0000000000000000000000000000000000000000;;		} else if n.exponent < 0 {
0000000000000000000000000000000000000000;;			d.d.errorf("json: fractional integer")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if n.exponent > 0 {
0000000000000000000000000000000000000000;;			var overflow bool
0000000000000000000000000000000000000000;;			if u, overflow = n.uintExp(); overflow {
0000000000000000000000000000000000000000;;				d.d.errorf("json: overflow integer")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if chkOvf.Uint(u, bitsize) {
0000000000000000000000000000000000000000;;			d.d.errorf("json: overflow %v bits: %s", bitsize, d.bs)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// fmt.Printf("DecodeUint: %v\n", u)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeFloat(chkOverflow32 bool) (f float64) {
0000000000000000000000000000000000000000;;		d.decNum(true)
0000000000000000000000000000000000000000;;		f = d.floatVal()
0000000000000000000000000000000000000000;;		if chkOverflow32 && chkOvf.Float32(f) {
0000000000000000000000000000000000000000;;			d.d.errorf("json: overflow float32: %v, %s", f, d.bs)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeExt(rv interface{}, xtag uint64, ext Ext) (realxtag uint64) {
0000000000000000000000000000000000000000;;		if ext == nil {
0000000000000000000000000000000000000000;;			re := rv.(*RawExt)
0000000000000000000000000000000000000000;;			re.Tag = xtag
0000000000000000000000000000000000000000;;			d.d.decode(&re.Value)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			var v interface{}
0000000000000000000000000000000000000000;;			d.d.decode(&v)
0000000000000000000000000000000000000000;;			ext.UpdateExt(rv, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeBytes(bs []byte, isstring, zerocopy bool) (bsOut []byte) {
0000000000000000000000000000000000000000;;		// if decoding into raw bytes, and the RawBytesExt is configured, use it to decode.
0000000000000000000000000000000000000000;;		if !isstring && d.se.i != nil {
0000000000000000000000000000000000000000;;			bsOut = bs
0000000000000000000000000000000000000000;;			d.DecodeExt(&bsOut, 0, &d.se)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.appendStringAsBytes()
0000000000000000000000000000000000000000;;		// if isstring, then just return the bytes, even if it is using the scratch buffer.
0000000000000000000000000000000000000000;;		// the bytes will be converted to a string as needed.
0000000000000000000000000000000000000000;;		if isstring {
0000000000000000000000000000000000000000;;			return d.bs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if appendStringAsBytes returned a zero-len slice, then treat as nil.
0000000000000000000000000000000000000000;;		// This should only happen for null, and "".
0000000000000000000000000000000000000000;;		if len(d.bs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bs0 := d.bs
0000000000000000000000000000000000000000;;		slen := base64.StdEncoding.DecodedLen(len(bs0))
0000000000000000000000000000000000000000;;		if slen <= cap(bs) {
0000000000000000000000000000000000000000;;			bsOut = bs[:slen]
0000000000000000000000000000000000000000;;		} else if zerocopy && slen <= cap(d.b2) {
0000000000000000000000000000000000000000;;			bsOut = d.b2[:slen]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			bsOut = make([]byte, slen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slen2, err := base64.StdEncoding.Decode(bsOut, bs0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			d.d.errorf("json: error decoding base64 binary '%s': %v", bs0, err)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if slen != slen2 {
0000000000000000000000000000000000000000;;			bsOut = bsOut[:slen2]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeString() (s string) {
0000000000000000000000000000000000000000;;		d.appendStringAsBytes()
0000000000000000000000000000000000000000;;		// if x := d.s.sc; x != nil && x.so && x.st == '}' { // map key
0000000000000000000000000000000000000000;;		if d.c == containerMapKey {
0000000000000000000000000000000000000000;;			return d.d.string(d.bs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(d.bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) appendStringAsBytes() {
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle null as a string
0000000000000000000000000000000000000000;;		if d.tok == 'n' {
0000000000000000000000000000000000000000;;			d.readStrIdx(10, 13) // ull
0000000000000000000000000000000000000000;;			d.bs = d.bs[:0]
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.tok != '"' {
0000000000000000000000000000000000000000;;			d.d.errorf("json: expect char '%c' but got char '%c'", '"', d.tok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.tok = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := d.bs[:0]
0000000000000000000000000000000000000000;;		var c uint8
0000000000000000000000000000000000000000;;		r := d.r
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c = r.readn1()
0000000000000000000000000000000000000000;;			if c == '"' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if c == '\\' {
0000000000000000000000000000000000000000;;				c = r.readn1()
0000000000000000000000000000000000000000;;				switch c {
0000000000000000000000000000000000000000;;				case '"', '\\', '/', '\'':
0000000000000000000000000000000000000000;;					v = append(v, c)
0000000000000000000000000000000000000000;;				case 'b':
0000000000000000000000000000000000000000;;					v = append(v, '\b')
0000000000000000000000000000000000000000;;				case 'f':
0000000000000000000000000000000000000000;;					v = append(v, '\f')
0000000000000000000000000000000000000000;;				case 'n':
0000000000000000000000000000000000000000;;					v = append(v, '\n')
0000000000000000000000000000000000000000;;				case 'r':
0000000000000000000000000000000000000000;;					v = append(v, '\r')
0000000000000000000000000000000000000000;;				case 't':
0000000000000000000000000000000000000000;;					v = append(v, '\t')
0000000000000000000000000000000000000000;;				case 'u':
0000000000000000000000000000000000000000;;					rr := d.jsonU4(false)
0000000000000000000000000000000000000000;;					// fmt.Printf("$$$$$$$$$: is surrogate: %v\n", utf16.IsSurrogate(rr))
0000000000000000000000000000000000000000;;					if utf16.IsSurrogate(rr) {
0000000000000000000000000000000000000000;;						rr = utf16.DecodeRune(rr, d.jsonU4(true))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w2 := utf8.EncodeRune(d.bstr[:], rr)
0000000000000000000000000000000000000000;;					v = append(v, d.bstr[:w2]...)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					d.d.errorf("json: unsupported escaped value: %c", c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				v = append(v, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.bs = v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) jsonU4(checkSlashU bool) rune {
0000000000000000000000000000000000000000;;		r := d.r
0000000000000000000000000000000000000000;;		if checkSlashU && !(r.readn1() == '\\' && r.readn1() == 'u') {
0000000000000000000000000000000000000000;;			d.d.errorf(`json: unquoteStr: invalid unicode sequence. Expecting \u`)
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// u, _ := strconv.ParseUint(string(d.bstr[:4]), 16, 64)
0000000000000000000000000000000000000000;;		var u uint32
0000000000000000000000000000000000000000;;		for i := 0; i < 4; i++ {
0000000000000000000000000000000000000000;;			v := r.readn1()
0000000000000000000000000000000000000000;;			if '0' <= v && v <= '9' {
0000000000000000000000000000000000000000;;				v = v - '0'
0000000000000000000000000000000000000000;;			} else if 'a' <= v && v <= 'z' {
0000000000000000000000000000000000000000;;				v = v - 'a' + 10
0000000000000000000000000000000000000000;;			} else if 'A' <= v && v <= 'Z' {
0000000000000000000000000000000000000000;;				v = v - 'A' + 10
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.d.errorf(`json: unquoteStr: invalid hex char in \u unicode sequence: %q`, v)
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			u = u*16 + uint32(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rune(u)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) DecodeNaked() {
0000000000000000000000000000000000000000;;		z := &d.d.n
0000000000000000000000000000000000000000;;		// var decodeFurther bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.tok == 0 {
0000000000000000000000000000000000000000;;			var b byte
0000000000000000000000000000000000000000;;			r := d.r
0000000000000000000000000000000000000000;;			for b = r.readn1(); jsonIsWS(b); b = r.readn1() {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.tok = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch d.tok {
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			d.readStrIdx(10, 13) // ull
0000000000000000000000000000000000000000;;			z.v = valueTypeNil
0000000000000000000000000000000000000000;;		case 'f':
0000000000000000000000000000000000000000;;			d.readStrIdx(5, 9) // alse
0000000000000000000000000000000000000000;;			z.v = valueTypeBool
0000000000000000000000000000000000000000;;			z.b = false
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			d.readStrIdx(1, 4) // rue
0000000000000000000000000000000000000000;;			z.v = valueTypeBool
0000000000000000000000000000000000000000;;			z.b = true
0000000000000000000000000000000000000000;;		case '{':
0000000000000000000000000000000000000000;;			z.v = valueTypeMap
0000000000000000000000000000000000000000;;			// d.tok = 0 // don't consume. kInterfaceNaked will call ReadMapStart
0000000000000000000000000000000000000000;;			// decodeFurther = true
0000000000000000000000000000000000000000;;		case '[':
0000000000000000000000000000000000000000;;			z.v = valueTypeArray
0000000000000000000000000000000000000000;;			// d.tok = 0 // don't consume. kInterfaceNaked will call ReadArrayStart
0000000000000000000000000000000000000000;;			// decodeFurther = true
0000000000000000000000000000000000000000;;		case '"':
0000000000000000000000000000000000000000;;			z.v = valueTypeString
0000000000000000000000000000000000000000;;			z.s = d.DecodeString()
0000000000000000000000000000000000000000;;		default: // number
0000000000000000000000000000000000000000;;			d.decNum(true)
0000000000000000000000000000000000000000;;			n := &d.n
0000000000000000000000000000000000000000;;			// if the string had a any of [.eE], then decode as float.
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case n.explicitExponent, n.dot, n.exponent < 0, n.manOverflow:
0000000000000000000000000000000000000000;;				z.v = valueTypeFloat
0000000000000000000000000000000000000000;;				z.f = d.floatVal()
0000000000000000000000000000000000000000;;			case n.exponent == 0:
0000000000000000000000000000000000000000;;				u := n.mantissa
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case n.neg:
0000000000000000000000000000000000000000;;					z.v = valueTypeInt
0000000000000000000000000000000000000000;;					z.i = -int64(u)
0000000000000000000000000000000000000000;;				case d.h.SignedInteger:
0000000000000000000000000000000000000000;;					z.v = valueTypeInt
0000000000000000000000000000000000000000;;					z.i = int64(u)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					z.v = valueTypeUint
0000000000000000000000000000000000000000;;					z.u = u
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				u, overflow := n.uintExp()
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case overflow:
0000000000000000000000000000000000000000;;					z.v = valueTypeFloat
0000000000000000000000000000000000000000;;					z.f = d.floatVal()
0000000000000000000000000000000000000000;;				case n.neg:
0000000000000000000000000000000000000000;;					z.v = valueTypeInt
0000000000000000000000000000000000000000;;					z.i = -int64(u)
0000000000000000000000000000000000000000;;				case d.h.SignedInteger:
0000000000000000000000000000000000000000;;					z.v = valueTypeInt
0000000000000000000000000000000000000000;;					z.i = int64(u)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					z.v = valueTypeUint
0000000000000000000000000000000000000000;;					z.u = u
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// fmt.Printf("DecodeNaked: Number: %T, %v\n", v, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if decodeFurther {
0000000000000000000000000000000000000000;;		// 	d.s.sc.retryRead()
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//----------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JsonHandle is a handle for JSON encoding format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Json is comprehensively supported:
0000000000000000000000000000000000000000;;	//    - decodes numbers into interface{} as int, uint or float64
0000000000000000000000000000000000000000;;	//    - configurable way to encode/decode []byte .
0000000000000000000000000000000000000000;;	//      by default, encodes and decodes []byte using base64 Std Encoding
0000000000000000000000000000000000000000;;	//    - UTF-8 support for encoding and decoding
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It has better performance than the json library in the standard library,
0000000000000000000000000000000000000000;;	// by leveraging the performance improvements of the codec library and
0000000000000000000000000000000000000000;;	// minimizing allocations.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In addition, it doesn't read more bytes than necessary during a decode, which allows
0000000000000000000000000000000000000000;;	// reading multiple values from a stream containing json and non-json content.
0000000000000000000000000000000000000000;;	// For example, a user can read a json value, then a cbor value, then a msgpack value,
0000000000000000000000000000000000000000;;	// all from the same stream in sequence.
0000000000000000000000000000000000000000;;	type JsonHandle struct {
0000000000000000000000000000000000000000;;		textEncodingType
0000000000000000000000000000000000000000;;		BasicHandle
0000000000000000000000000000000000000000;;		// RawBytesExt, if configured, is used to encode and decode raw bytes in a custom way.
0000000000000000000000000000000000000000;;		// If not configured, raw bytes are encoded to/from base64 text.
0000000000000000000000000000000000000000;;		RawBytesExt InterfaceExt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Indent indicates how a value is encoded.
0000000000000000000000000000000000000000;;		//   - If positive, indent by that number of spaces.
0000000000000000000000000000000000000000;;		//   - If negative, indent by that number of tabs.
0000000000000000000000000000000000000000;;		Indent int8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IntegerAsString controls how integers (signed and unsigned) are encoded.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Per the JSON Spec, JSON numbers are 64-bit floating point numbers.
0000000000000000000000000000000000000000;;		// Consequently, integers > 2^53 cannot be represented as a JSON number without losing precision.
0000000000000000000000000000000000000000;;		// This can be mitigated by configuring how to encode integers.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// IntegerAsString interpretes the following values:
0000000000000000000000000000000000000000;;		//   - if 'L', then encode integers > 2^53 as a json string.
0000000000000000000000000000000000000000;;		//   - if 'A', then encode all integers as a json string
0000000000000000000000000000000000000000;;		//             containing the exact integer representation as a decimal.
0000000000000000000000000000000000000000;;		//   - else    encode all integers as a json number (default)
0000000000000000000000000000000000000000;;		IntegerAsString uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *JsonHandle) SetInterfaceExt(rt reflect.Type, tag uint64, ext InterfaceExt) (err error) {
0000000000000000000000000000000000000000;;		return h.SetExt(rt, tag, &setExtWrapper{i: ext})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *JsonHandle) newEncDriver(e *Encoder) encDriver {
0000000000000000000000000000000000000000;;		hd := jsonEncDriver{e: e, h: h}
0000000000000000000000000000000000000000;;		hd.bs = hd.b[:0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hd.reset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &hd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *JsonHandle) newDecDriver(d *Decoder) decDriver {
0000000000000000000000000000000000000000;;		// d := jsonDecDriver{r: r.(*bytesDecReader), h: h}
0000000000000000000000000000000000000000;;		hd := jsonDecDriver{d: d, h: h}
0000000000000000000000000000000000000000;;		hd.bs = hd.b[:0]
0000000000000000000000000000000000000000;;		hd.reset()
0000000000000000000000000000000000000000;;		return &hd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *jsonEncDriver) reset() {
0000000000000000000000000000000000000000;;		e.w = e.e.w
0000000000000000000000000000000000000000;;		e.se.i = e.h.RawBytesExt
0000000000000000000000000000000000000000;;		if e.bs != nil {
0000000000000000000000000000000000000000;;			e.bs = e.bs[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.d, e.dt, e.dl, e.ds = false, false, 0, ""
0000000000000000000000000000000000000000;;		e.c = 0
0000000000000000000000000000000000000000;;		if e.h.Indent > 0 {
0000000000000000000000000000000000000000;;			e.d = true
0000000000000000000000000000000000000000;;			e.ds = jsonSpaces[:e.h.Indent]
0000000000000000000000000000000000000000;;		} else if e.h.Indent < 0 {
0000000000000000000000000000000000000000;;			e.d = true
0000000000000000000000000000000000000000;;			e.dt = true
0000000000000000000000000000000000000000;;			e.ds = jsonTabs[:-(e.h.Indent)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *jsonDecDriver) reset() {
0000000000000000000000000000000000000000;;		d.r = d.d.r
0000000000000000000000000000000000000000;;		d.se.i = d.h.RawBytesExt
0000000000000000000000000000000000000000;;		if d.bs != nil {
0000000000000000000000000000000000000000;;			d.bs = d.bs[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.c, d.tok = 0, 0
0000000000000000000000000000000000000000;;		d.n.reset()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var jsonEncodeTerminate = []byte{' '}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *JsonHandle) rpcEncodeTerminate() []byte {
0000000000000000000000000000000000000000;;		return jsonEncodeTerminate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ decDriver = (*jsonDecDriver)(nil)
0000000000000000000000000000000000000000;;	var _ encDriver = (*jsonEncDriver)(nil)
