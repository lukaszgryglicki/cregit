0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/helper.go[Godeps/_workspace/src/github.com/ugorji/go/codec/helper.go][vendor/github.com/ugorji/go/codec/helper.go];	
0000000000000000000000000000000000000000;;	package codec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains code shared by both encode and decode.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Some shared ideas around encoding/decoding
0000000000000000000000000000000000000000;;	// ------------------------------------------
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If an interface{} is passed, we first do a type assertion to see if it is
0000000000000000000000000000000000000000;;	// a primitive type or a map/slice of primitive types, and use a fastpath to handle it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If we start with a reflect.Value, we are already in reflect.Value land and
0000000000000000000000000000000000000000;;	// will try to grab the function for the underlying Type and directly call that function.
0000000000000000000000000000000000000000;;	// This is more performant than calling reflect.Value.Interface().
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This still helps us bypass many layers of reflection, and give best performance.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Containers
0000000000000000000000000000000000000000;;	// ------------
0000000000000000000000000000000000000000;;	// Containers in the stream are either associative arrays (key-value pairs) or
0000000000000000000000000000000000000000;;	// regular arrays (indexed by incrementing integers).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some streams support indefinite-length containers, and use a breaking
0000000000000000000000000000000000000000;;	// byte-sequence to denote that the container has come to an end.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Some streams also are text-based, and use explicit separators to denote the
0000000000000000000000000000000000000000;;	// end/beginning of different values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// During encode, we use a high-level condition to determine how to iterate through
0000000000000000000000000000000000000000;;	// the container. That decision is based on whether the container is text-based (with
0000000000000000000000000000000000000000;;	// separators) or binary (without separators). If binary, we do not even call the
0000000000000000000000000000000000000000;;	// encoding of separators.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// During decode, we use a different high-level condition to determine how to iterate
0000000000000000000000000000000000000000;;	// through the containers. That decision is based on whether the stream contained
0000000000000000000000000000000000000000;;	// a length prefix, or if it used explicit breaks. If length-prefixed, we assume that
0000000000000000000000000000000000000000;;	// it has to be binary, and we do not even try to read separators.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Philosophy
0000000000000000000000000000000000000000;;	// ------------
0000000000000000000000000000000000000000;;	// On decode, this codec will update containers appropriately:
0000000000000000000000000000000000000000;;	//    - If struct, update fields from stream into fields of struct.
0000000000000000000000000000000000000000;;	//      If field in stream not found in struct, handle appropriately (based on option).
0000000000000000000000000000000000000000;;	//      If a struct field has no corresponding value in the stream, leave it AS IS.
0000000000000000000000000000000000000000;;	//      If nil in stream, set value to nil/zero value.
0000000000000000000000000000000000000000;;	//    - If map, update map from stream.
0000000000000000000000000000000000000000;;	//      If the stream value is NIL, set the map to nil.
0000000000000000000000000000000000000000;;	//    - if slice, try to update up to length of array in stream.
0000000000000000000000000000000000000000;;	//      if container len is less than stream array length,
0000000000000000000000000000000000000000;;	//      and container cannot be expanded, handled (based on option).
0000000000000000000000000000000000000000;;	//      This means you can decode 4-element stream array into 1-element array.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ------------------------------------
0000000000000000000000000000000000000000;;	// On encode, user can specify omitEmpty. This means that the value will be omitted
0000000000000000000000000000000000000000;;	// if the zero value. The problem may occur during decode, where omitted values do not affect
0000000000000000000000000000000000000000;;	// the value being decoded into. This means that if decoding into a struct with an
0000000000000000000000000000000000000000;;	// int field with current value=5, and the field is omitted in the stream, then after
0000000000000000000000000000000000000000;;	// decoding, the value will still be 5 (not 0).
0000000000000000000000000000000000000000;;	// omitEmpty only works if you guarantee that you always decode into zero-values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ------------------------------------
0000000000000000000000000000000000000000;;	// We could have truncated a map to remove keys not available in the stream,
0000000000000000000000000000000000000000;;	// or set values in the struct which are not in the stream to their zero values.
0000000000000000000000000000000000000000;;	// We decided against it because there is no efficient way to do it.
0000000000000000000000000000000000000000;;	// We may introduce it as an option later.
0000000000000000000000000000000000000000;;	// However, that will require enabling it for both runtime and code generation modes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To support truncate, we need to do 2 passes over the container:
0000000000000000000000000000000000000000;;	//   map
0000000000000000000000000000000000000000;;	//   - first collect all keys (e.g. in k1)
0000000000000000000000000000000000000000;;	//   - for each key in stream, mark k1 that the key should not be removed
0000000000000000000000000000000000000000;;	//   - after updating map, do second pass and call delete for all keys in k1 which are not marked
0000000000000000000000000000000000000000;;	//   struct:
0000000000000000000000000000000000000000;;	//   - for each field, track the *typeInfo s1
0000000000000000000000000000000000000000;;	//   - iterate through all s1, and for each one not marked, set value to zero
0000000000000000000000000000000000000000;;	//   - this involves checking the possible anonymous fields which are nil ptrs.
0000000000000000000000000000000000000000;;	//     too much work.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ------------------------------------------
0000000000000000000000000000000000000000;;	// Error Handling is done within the library using panic.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This way, the code doesn't have to keep checking if an error has happened,
0000000000000000000000000000000000000000;;	// and we don't have to keep sending the error value along with each call
0000000000000000000000000000000000000000;;	// or storing it in the En|Decoder and checking it constantly along the way.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The disadvantage is that small functions which use panics cannot be inlined.
0000000000000000000000000000000000000000;;	// The code accounts for that by only using panics behind an interface;
0000000000000000000000000000000000000000;;	// since interface calls cannot be inlined, this is irrelevant.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// We considered storing the error is En|Decoder.
0000000000000000000000000000000000000000;;	//   - once it has its err field set, it cannot be used again.
0000000000000000000000000000000000000000;;	//   - panicing will be optional, controlled by const flag.
0000000000000000000000000000000000000000;;	//   - code should always check error first and return early.
0000000000000000000000000000000000000000;;	// We eventually decided against it as it makes the code clumsier to always
0000000000000000000000000000000000000000;;	// check for these error conditions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		scratchByteArrayLen = 32
0000000000000000000000000000000000000000;;		initCollectionCap   = 32 // 32 is defensive. 16 is preferred.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Support encoding.(Binary|Text)(Unm|M)arshaler.
0000000000000000000000000000000000000000;;		// This constant flag will enable or disable it.
0000000000000000000000000000000000000000;;		supportMarshalInterfaces = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Each Encoder or Decoder uses a cache of functions based on conditionals,
0000000000000000000000000000000000000000;;		// so that the conditionals are not run every time.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Either a map or a slice is used to keep track of the functions.
0000000000000000000000000000000000000000;;		// The map is more natural, but has a higher cost than a slice/array.
0000000000000000000000000000000000000000;;		// This flag (useMapForCodecCache) controls which is used.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// From benchmarks, slices with linear search perform better with < 32 entries.
0000000000000000000000000000000000000000;;		// We have typically seen a high threshold of about 24 entries.
0000000000000000000000000000000000000000;;		useMapForCodecCache = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// for debugging, set this to false, to catch panic traces.
0000000000000000000000000000000000000000;;		// Note that this will always cause rpc tests to fail, since they need io.EOF sent via panic.
0000000000000000000000000000000000000000;;		recoverPanicToErr = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if resetSliceElemToZeroValue, then on decoding a slice, reset the element to a zero value first.
0000000000000000000000000000000000000000;;		// Only concern is that, if the slice already contained some garbage, we will decode into that garbage.
0000000000000000000000000000000000000000;;		// The chances of this are slim, so leave this "optimization".
0000000000000000000000000000000000000000;;		// TODO: should this be true, to ensure that we always decode into a "zero" "empty" value?
0000000000000000000000000000000000000000;;		resetSliceElemToZeroValue bool = false
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oneByteArr    = [1]byte{0}
0000000000000000000000000000000000000000;;		zeroByteSlice = oneByteArr[:0:0]
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type charEncoding uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		c_RAW charEncoding = iota
0000000000000000000000000000000000000000;;		c_UTF8
0000000000000000000000000000000000000000;;		c_UTF16LE
0000000000000000000000000000000000000000;;		c_UTF16BE
0000000000000000000000000000000000000000;;		c_UTF32LE
0000000000000000000000000000000000000000;;		c_UTF32BE
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valueType is the stream type
0000000000000000000000000000000000000000;;	type valueType uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		valueTypeUnset valueType = iota
0000000000000000000000000000000000000000;;		valueTypeNil
0000000000000000000000000000000000000000;;		valueTypeInt
0000000000000000000000000000000000000000;;		valueTypeUint
0000000000000000000000000000000000000000;;		valueTypeFloat
0000000000000000000000000000000000000000;;		valueTypeBool
0000000000000000000000000000000000000000;;		valueTypeString
0000000000000000000000000000000000000000;;		valueTypeSymbol
0000000000000000000000000000000000000000;;		valueTypeBytes
0000000000000000000000000000000000000000;;		valueTypeMap
0000000000000000000000000000000000000000;;		valueTypeArray
0000000000000000000000000000000000000000;;		valueTypeTimestamp
0000000000000000000000000000000000000000;;		valueTypeExt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// valueTypeInvalid = 0xff
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type seqType uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_ seqType = iota
0000000000000000000000000000000000000000;;		seqTypeArray
0000000000000000000000000000000000000000;;		seqTypeSlice
0000000000000000000000000000000000000000;;		seqTypeChan
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// note that containerMapStart and containerArraySend are not sent.
0000000000000000000000000000000000000000;;	// This is because the ReadXXXStart and EncodeXXXStart already does these.
0000000000000000000000000000000000000000;;	type containerState uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_ containerState = iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerMapStart // slot left open, since Driver method already covers it
0000000000000000000000000000000000000000;;		containerMapKey
0000000000000000000000000000000000000000;;		containerMapValue
0000000000000000000000000000000000000000;;		containerMapEnd
0000000000000000000000000000000000000000;;		containerArrayStart // slot left open, since Driver methods already cover it
0000000000000000000000000000000000000000;;		containerArrayElem
0000000000000000000000000000000000000000;;		containerArrayEnd
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sfiIdx used for tracking where a (field/enc)Name is seen in a []*structFieldInfo
0000000000000000000000000000000000000000;;	type sfiIdx struct {
0000000000000000000000000000000000000000;;		name  string
0000000000000000000000000000000000000000;;		index int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// do not recurse if a containing type refers to an embedded type
0000000000000000000000000000000000000000;;	// which refers back to its containing type (via a pointer).
0000000000000000000000000000000000000000;;	// The second time this back-reference happens, break out,
0000000000000000000000000000000000000000;;	// so as not to cause an infinite loop.
0000000000000000000000000000000000000000;;	const rgetMaxRecursion = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Anecdotally, we believe most types have <= 12 fields.
0000000000000000000000000000000000000000;;	// Java's PMD rules set TooManyFields threshold to 15.
0000000000000000000000000000000000000000;;	const rgetPoolTArrayLen = 12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rgetT struct {
0000000000000000000000000000000000000000;;		fNames   []string
0000000000000000000000000000000000000000;;		encNames []string
0000000000000000000000000000000000000000;;		etypes   []uintptr
0000000000000000000000000000000000000000;;		sfis     []*structFieldInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rgetPoolT struct {
0000000000000000000000000000000000000000;;		fNames   [rgetPoolTArrayLen]string
0000000000000000000000000000000000000000;;		encNames [rgetPoolTArrayLen]string
0000000000000000000000000000000000000000;;		etypes   [rgetPoolTArrayLen]uintptr
0000000000000000000000000000000000000000;;		sfis     [rgetPoolTArrayLen]*structFieldInfo
0000000000000000000000000000000000000000;;		sfiidx   [rgetPoolTArrayLen]sfiIdx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var rgetPool = sync.Pool{
0000000000000000000000000000000000000000;;		New: func() interface{} { return new(rgetPoolT) },
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerStateRecv interface {
0000000000000000000000000000000000000000;;		sendContainerState(containerState)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mirror json.Marshaler and json.Unmarshaler here,
0000000000000000000000000000000000000000;;	// so we don't import the encoding/json package
0000000000000000000000000000000000000000;;	type jsonMarshaler interface {
0000000000000000000000000000000000000000;;		MarshalJSON() ([]byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type jsonUnmarshaler interface {
0000000000000000000000000000000000000000;;		UnmarshalJSON([]byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		bigen               = binary.BigEndian
0000000000000000000000000000000000000000;;		structInfoFieldName = "_struct"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapStrIntfTyp  = reflect.TypeOf(map[string]interface{}(nil))
0000000000000000000000000000000000000000;;		mapIntfIntfTyp = reflect.TypeOf(map[interface{}]interface{}(nil))
0000000000000000000000000000000000000000;;		intfSliceTyp   = reflect.TypeOf([]interface{}(nil))
0000000000000000000000000000000000000000;;		intfTyp        = intfSliceTyp.Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stringTyp     = reflect.TypeOf("")
0000000000000000000000000000000000000000;;		timeTyp       = reflect.TypeOf(time.Time{})
0000000000000000000000000000000000000000;;		rawExtTyp     = reflect.TypeOf(RawExt{})
0000000000000000000000000000000000000000;;		rawTyp        = reflect.TypeOf(Raw{})
0000000000000000000000000000000000000000;;		uint8SliceTyp = reflect.TypeOf([]uint8(nil))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapBySliceTyp = reflect.TypeOf((*MapBySlice)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binaryMarshalerTyp   = reflect.TypeOf((*encoding.BinaryMarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		binaryUnmarshalerTyp = reflect.TypeOf((*encoding.BinaryUnmarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		textMarshalerTyp   = reflect.TypeOf((*encoding.TextMarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		textUnmarshalerTyp = reflect.TypeOf((*encoding.TextUnmarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonMarshalerTyp   = reflect.TypeOf((*jsonMarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		jsonUnmarshalerTyp = reflect.TypeOf((*jsonUnmarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		selferTyp = reflect.TypeOf((*Selfer)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uint8SliceTypId = reflect.ValueOf(uint8SliceTyp).Pointer()
0000000000000000000000000000000000000000;;		rawExtTypId     = reflect.ValueOf(rawExtTyp).Pointer()
0000000000000000000000000000000000000000;;		rawTypId        = reflect.ValueOf(rawTyp).Pointer()
0000000000000000000000000000000000000000;;		intfTypId       = reflect.ValueOf(intfTyp).Pointer()
0000000000000000000000000000000000000000;;		timeTypId       = reflect.ValueOf(timeTyp).Pointer()
0000000000000000000000000000000000000000;;		stringTypId     = reflect.ValueOf(stringTyp).Pointer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mapStrIntfTypId  = reflect.ValueOf(mapStrIntfTyp).Pointer()
0000000000000000000000000000000000000000;;		mapIntfIntfTypId = reflect.ValueOf(mapIntfIntfTyp).Pointer()
0000000000000000000000000000000000000000;;		intfSliceTypId   = reflect.ValueOf(intfSliceTyp).Pointer()
0000000000000000000000000000000000000000;;		// mapBySliceTypId  = reflect.ValueOf(mapBySliceTyp).Pointer()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		intBitsize  uint8 = uint8(reflect.TypeOf(int(0)).Bits())
0000000000000000000000000000000000000000;;		uintBitsize uint8 = uint8(reflect.TypeOf(uint(0)).Bits())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bsAll0x00 = []byte{0, 0, 0, 0, 0, 0, 0, 0}
0000000000000000000000000000000000000000;;		bsAll0xff = []byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chkOvf checkOverflow
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noFieldNameToStructFieldInfoErr = errors.New("no field name passed to parseStructFieldInfo")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defTypeInfos = NewTypeInfos([]string{"codec", "json"})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Selfer defines methods by which a value can encode or decode itself.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Any type which implements Selfer will be able to encode or decode itself.
0000000000000000000000000000000000000000;;	// Consequently, during (en|de)code, this takes precedence over
0000000000000000000000000000000000000000;;	// (text|binary)(M|Unm)arshal or extension support.
0000000000000000000000000000000000000000;;	type Selfer interface {
0000000000000000000000000000000000000000;;		CodecEncodeSelf(*Encoder)
0000000000000000000000000000000000000000;;		CodecDecodeSelf(*Decoder)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapBySlice represents a slice which should be encoded as a map in the stream.
0000000000000000000000000000000000000000;;	// The slice contains a sequence of key-value pairs.
0000000000000000000000000000000000000000;;	// This affords storing a map in a specific sequence in the stream.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The support of MapBySlice affords the following:
0000000000000000000000000000000000000000;;	//   - A slice type which implements MapBySlice will be encoded as a map
0000000000000000000000000000000000000000;;	//   - A slice can be decoded from a map in the stream
0000000000000000000000000000000000000000;;	type MapBySlice interface {
0000000000000000000000000000000000000000;;		MapBySlice()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WARNING: DO NOT USE DIRECTLY. EXPORTED FOR GODOC BENEFIT. WILL BE REMOVED.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// BasicHandle encapsulates the common options and extension functions.
0000000000000000000000000000000000000000;;	type BasicHandle struct {
0000000000000000000000000000000000000000;;		// TypeInfos is used to get the type info for any type.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If not configured, the default TypeInfos is used, which uses struct tag keys: codec, json
0000000000000000000000000000000000000000;;		TypeInfos *TypeInfos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extHandle
0000000000000000000000000000000000000000;;		EncodeOptions
0000000000000000000000000000000000000000;;		DecodeOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *BasicHandle) getBasicHandle() *BasicHandle {
0000000000000000000000000000000000000000;;		return x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *BasicHandle) getTypeInfo(rtid uintptr, rt reflect.Type) (pti *typeInfo) {
0000000000000000000000000000000000000000;;		if x.TypeInfos != nil {
0000000000000000000000000000000000000000;;			return x.TypeInfos.get(rtid, rt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return defTypeInfos.get(rtid, rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle is the interface for a specific encoding format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Typically, a Handle is pre-configured before first time use,
0000000000000000000000000000000000000000;;	// and not modified while in use. Such a pre-configured Handle
0000000000000000000000000000000000000000;;	// is safe for concurrent access.
0000000000000000000000000000000000000000;;	type Handle interface {
0000000000000000000000000000000000000000;;		getBasicHandle() *BasicHandle
0000000000000000000000000000000000000000;;		newEncDriver(w *Encoder) encDriver
0000000000000000000000000000000000000000;;		newDecDriver(r *Decoder) decDriver
0000000000000000000000000000000000000000;;		isBinary() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw represents raw formatted bytes.
0000000000000000000000000000000000000000;;	// We "blindly" store it during encode and store the raw bytes during decode.
0000000000000000000000000000000000000000;;	// Note: it is dangerous during encode, so we may gate the behaviour behind an Encode flag which must be explicitly set.
0000000000000000000000000000000000000000;;	type Raw []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RawExt represents raw unprocessed extension data.
0000000000000000000000000000000000000000;;	// Some codecs will decode extension data as a *RawExt if there is no registered extension for the tag.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Only one of Data or Value is nil. If Data is nil, then the content of the RawExt is in the Value.
0000000000000000000000000000000000000000;;	type RawExt struct {
0000000000000000000000000000000000000000;;		Tag uint64
0000000000000000000000000000000000000000;;		// Data is the []byte which represents the raw ext. If Data is nil, ext is exposed in Value.
0000000000000000000000000000000000000000;;		// Data is used by codecs (e.g. binc, msgpack, simple) which do custom serialization of the types
0000000000000000000000000000000000000000;;		Data []byte
0000000000000000000000000000000000000000;;		// Value represents the extension, if Data is nil.
0000000000000000000000000000000000000000;;		// Value is used by codecs (e.g. cbor, json) which use the format to do custom serialization of the types.
0000000000000000000000000000000000000000;;		Value interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BytesExt handles custom (de)serialization of types to/from []byte.
0000000000000000000000000000000000000000;;	// It is used by codecs (e.g. binc, msgpack, simple) which do custom serialization of the types.
0000000000000000000000000000000000000000;;	type BytesExt interface {
0000000000000000000000000000000000000000;;		// WriteExt converts a value to a []byte.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note: v *may* be a pointer to the extension type, if the extension type was a struct or array.
0000000000000000000000000000000000000000;;		WriteExt(v interface{}) []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadExt updates a value from a []byte.
0000000000000000000000000000000000000000;;		ReadExt(dst interface{}, src []byte)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InterfaceExt handles custom (de)serialization of types to/from another interface{} value.
0000000000000000000000000000000000000000;;	// The Encoder or Decoder will then handle the further (de)serialization of that known type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is used by codecs (e.g. cbor, json) which use the format to do custom serialization of the types.
0000000000000000000000000000000000000000;;	type InterfaceExt interface {
0000000000000000000000000000000000000000;;		// ConvertExt converts a value into a simpler interface for easy encoding e.g. convert time.Time to int64.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note: v *may* be a pointer to the extension type, if the extension type was a struct or array.
0000000000000000000000000000000000000000;;		ConvertExt(v interface{}) interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UpdateExt updates a value from a simpler interface for easy decoding e.g. convert int64 to time.Time.
0000000000000000000000000000000000000000;;		UpdateExt(dst interface{}, src interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ext handles custom (de)serialization of custom types / extensions.
0000000000000000000000000000000000000000;;	type Ext interface {
0000000000000000000000000000000000000000;;		BytesExt
0000000000000000000000000000000000000000;;		InterfaceExt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addExtWrapper is a wrapper implementation to support former AddExt exported method.
0000000000000000000000000000000000000000;;	type addExtWrapper struct {
0000000000000000000000000000000000000000;;		encFn func(reflect.Value) ([]byte, error)
0000000000000000000000000000000000000000;;		decFn func(reflect.Value, []byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x addExtWrapper) WriteExt(v interface{}) []byte {
0000000000000000000000000000000000000000;;		bs, err := x.encFn(reflect.ValueOf(v))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x addExtWrapper) ReadExt(v interface{}, bs []byte) {
0000000000000000000000000000000000000000;;		if err := x.decFn(reflect.ValueOf(v), bs); err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x addExtWrapper) ConvertExt(v interface{}) interface{} {
0000000000000000000000000000000000000000;;		return x.WriteExt(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x addExtWrapper) UpdateExt(dest interface{}, v interface{}) {
0000000000000000000000000000000000000000;;		x.ReadExt(dest, v.([]byte))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type setExtWrapper struct {
0000000000000000000000000000000000000000;;		b BytesExt
0000000000000000000000000000000000000000;;		i InterfaceExt
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *setExtWrapper) WriteExt(v interface{}) []byte {
0000000000000000000000000000000000000000;;		if x.b == nil {
0000000000000000000000000000000000000000;;			panic("BytesExt.WriteExt is not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x.b.WriteExt(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *setExtWrapper) ReadExt(v interface{}, bs []byte) {
0000000000000000000000000000000000000000;;		if x.b == nil {
0000000000000000000000000000000000000000;;			panic("BytesExt.WriteExt is not supported")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.b.ReadExt(v, bs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *setExtWrapper) ConvertExt(v interface{}) interface{} {
0000000000000000000000000000000000000000;;		if x.i == nil {
0000000000000000000000000000000000000000;;			panic("InterfaceExt.ConvertExt is not supported")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return x.i.ConvertExt(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *setExtWrapper) UpdateExt(dest interface{}, v interface{}) {
0000000000000000000000000000000000000000;;		if x.i == nil {
0000000000000000000000000000000000000000;;			panic("InterfaceExxt.UpdateExt is not supported")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.i.UpdateExt(dest, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// type errorString string
0000000000000000000000000000000000000000;;	// func (x errorString) Error() string { return string(x) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type binaryEncodingType struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ binaryEncodingType) isBinary() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type textEncodingType struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ textEncodingType) isBinary() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// noBuiltInTypes is embedded into many types which do not support builtins
0000000000000000000000000000000000000000;;	// e.g. msgpack, simple, cbor.
0000000000000000000000000000000000000000;;	type noBuiltInTypes struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noBuiltInTypes) IsBuiltinType(rt uintptr) bool           { return false }
0000000000000000000000000000000000000000;;	func (_ noBuiltInTypes) EncodeBuiltin(rt uintptr, v interface{}) {}
0000000000000000000000000000000000000000;;	func (_ noBuiltInTypes) DecodeBuiltin(rt uintptr, v interface{}) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type noStreamingCodec struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ noStreamingCodec) CheckBreak() bool { return false }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bigenHelper.
0000000000000000000000000000000000000000;;	// Users must already slice the x completely, because we will not reslice.
0000000000000000000000000000000000000000;;	type bigenHelper struct {
0000000000000000000000000000000000000000;;		x []byte // must be correctly sliced to appropriate len. slicing is a cost.
0000000000000000000000000000000000000000;;		w encWriter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z bigenHelper) writeUint16(v uint16) {
0000000000000000000000000000000000000000;;		bigen.PutUint16(z.x, v)
0000000000000000000000000000000000000000;;		z.w.writeb(z.x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z bigenHelper) writeUint32(v uint32) {
0000000000000000000000000000000000000000;;		bigen.PutUint32(z.x, v)
0000000000000000000000000000000000000000;;		z.w.writeb(z.x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (z bigenHelper) writeUint64(v uint64) {
0000000000000000000000000000000000000000;;		bigen.PutUint64(z.x, v)
0000000000000000000000000000000000000000;;		z.w.writeb(z.x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type extTypeTagFn struct {
0000000000000000000000000000000000000000;;		rtid uintptr
0000000000000000000000000000000000000000;;		rt   reflect.Type
0000000000000000000000000000000000000000;;		tag  uint64
0000000000000000000000000000000000000000;;		ext  Ext
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type extHandle []extTypeTagFn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DEPRECATED: Use SetBytesExt or SetInterfaceExt on the Handle instead.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// AddExt registes an encode and decode function for a reflect.Type.
0000000000000000000000000000000000000000;;	// AddExt internally calls SetExt.
0000000000000000000000000000000000000000;;	// To deregister an Ext, call AddExt with nil encfn and/or nil decfn.
0000000000000000000000000000000000000000;;	func (o *extHandle) AddExt(
0000000000000000000000000000000000000000;;		rt reflect.Type, tag byte,
0000000000000000000000000000000000000000;;		encfn func(reflect.Value) ([]byte, error), decfn func(reflect.Value, []byte) error,
0000000000000000000000000000000000000000;;	) (err error) {
0000000000000000000000000000000000000000;;		if encfn == nil || decfn == nil {
0000000000000000000000000000000000000000;;			return o.SetExt(rt, uint64(tag), nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o.SetExt(rt, uint64(tag), addExtWrapper{encfn, decfn})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DEPRECATED: Use SetBytesExt or SetInterfaceExt on the Handle instead.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that the type must be a named type, and specifically not
0000000000000000000000000000000000000000;;	// a pointer or Interface. An error is returned if that is not honored.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To Deregister an ext, call SetExt with nil Ext
0000000000000000000000000000000000000000;;	func (o *extHandle) SetExt(rt reflect.Type, tag uint64, ext Ext) (err error) {
0000000000000000000000000000000000000000;;		// o is a pointer, because we may need to initialize it
0000000000000000000000000000000000000000;;		if rt.PkgPath() == "" || rt.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("codec.Handle.AddExt: Takes named type, not a pointer or interface: %T",
0000000000000000000000000000000000000000;;				reflect.Zero(rt).Interface())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rtid := reflect.ValueOf(rt).Pointer()
0000000000000000000000000000000000000000;;		for _, v := range *o {
0000000000000000000000000000000000000000;;			if v.rtid == rtid {
0000000000000000000000000000000000000000;;				v.tag, v.ext = tag, ext
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *o == nil {
0000000000000000000000000000000000000000;;			*o = make([]extTypeTagFn, 0, 4)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*o = append(*o, extTypeTagFn{rtid, rt, tag, ext})
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o extHandle) getExt(rtid uintptr) *extTypeTagFn {
0000000000000000000000000000000000000000;;		var v *extTypeTagFn
0000000000000000000000000000000000000000;;		for i := range o {
0000000000000000000000000000000000000000;;			v = &o[i]
0000000000000000000000000000000000000000;;			if v.rtid == rtid {
0000000000000000000000000000000000000000;;				return v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o extHandle) getExtForTag(tag uint64) *extTypeTagFn {
0000000000000000000000000000000000000000;;		var v *extTypeTagFn
0000000000000000000000000000000000000000;;		for i := range o {
0000000000000000000000000000000000000000;;			v = &o[i]
0000000000000000000000000000000000000000;;			if v.tag == tag {
0000000000000000000000000000000000000000;;				return v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type structFieldInfo struct {
0000000000000000000000000000000000000000;;		encName   string // encode name
0000000000000000000000000000000000000000;;		fieldName string // field name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only one of 'i' or 'is' can be set. If 'i' is -1, then 'is' has been set.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		is        []int // (recursive/embedded) field index in struct
0000000000000000000000000000000000000000;;		i         int16 // field index in struct
0000000000000000000000000000000000000000;;		omitEmpty bool
0000000000000000000000000000000000000000;;		toArray   bool // if field is _struct, is the toArray set?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func (si *structFieldInfo) isZero() bool {
0000000000000000000000000000000000000000;;	// 	return si.encName == "" && len(si.is) == 0 && si.i == 0 && !si.omitEmpty && !si.toArray
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rv returns the field of the struct.
0000000000000000000000000000000000000000;;	// If anonymous, it returns an Invalid
0000000000000000000000000000000000000000;;	func (si *structFieldInfo) field(v reflect.Value, update bool) (rv2 reflect.Value) {
0000000000000000000000000000000000000000;;		if si.i != -1 {
0000000000000000000000000000000000000000;;			v = v.Field(int(si.i))
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// replicate FieldByIndex
0000000000000000000000000000000000000000;;		for _, x := range si.is {
0000000000000000000000000000000000000000;;			for v.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;				if v.IsNil() {
0000000000000000000000000000000000000000;;					if !update {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v.Set(reflect.New(v.Type().Elem()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = v.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = v.Field(x)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (si *structFieldInfo) setToZeroValue(v reflect.Value) {
0000000000000000000000000000000000000000;;		if si.i != -1 {
0000000000000000000000000000000000000000;;			v = v.Field(int(si.i))
0000000000000000000000000000000000000000;;			v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;			// v.Set(reflect.New(v.Type()).Elem())
0000000000000000000000000000000000000000;;			// v.Set(reflect.New(v.Type()))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// replicate FieldByIndex
0000000000000000000000000000000000000000;;			for _, x := range si.is {
0000000000000000000000000000000000000000;;				for v.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;					if v.IsNil() {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v = v.Elem()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = v.Field(x)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseStructFieldInfo(fname string, stag string) *structFieldInfo {
0000000000000000000000000000000000000000;;		// if fname == "" {
0000000000000000000000000000000000000000;;		// 	panic(noFieldNameToStructFieldInfoErr)
0000000000000000000000000000000000000000;;		// }
0000000000000000000000000000000000000000;;		si := structFieldInfo{
0000000000000000000000000000000000000000;;			encName: fname,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if stag != "" {
0000000000000000000000000000000000000000;;			for i, s := range strings.Split(stag, ",") {
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					if s != "" {
0000000000000000000000000000000000000000;;						si.encName = s
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if s == "omitempty" {
0000000000000000000000000000000000000000;;						si.omitEmpty = true
0000000000000000000000000000000000000000;;					} else if s == "toarray" {
0000000000000000000000000000000000000000;;						si.toArray = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// si.encNameBs = []byte(si.encName)
0000000000000000000000000000000000000000;;		return &si
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sfiSortedByEncName []*structFieldInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sfiSortedByEncName) Len() int {
0000000000000000000000000000000000000000;;		return len(p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sfiSortedByEncName) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return p[i].encName < p[j].encName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sfiSortedByEncName) Swap(i, j int) {
0000000000000000000000000000000000000000;;		p[i], p[j] = p[j], p[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typeInfo keeps information about each type referenced in the encode/decode sequence.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// During an encode/decode sequence, we work as below:
0000000000000000000000000000000000000000;;	//   - If base is a built in type, en/decode base value
0000000000000000000000000000000000000000;;	//   - If base is registered as an extension, en/decode base value
0000000000000000000000000000000000000000;;	//   - If type is binary(M/Unm)arshaler, call Binary(M/Unm)arshal method
0000000000000000000000000000000000000000;;	//   - If type is text(M/Unm)arshaler, call Text(M/Unm)arshal method
0000000000000000000000000000000000000000;;	//   - Else decode appropriately based on the reflect.Kind
0000000000000000000000000000000000000000;;	type typeInfo struct {
0000000000000000000000000000000000000000;;		sfi  []*structFieldInfo // sorted. Used when enc/dec struct to map.
0000000000000000000000000000000000000000;;		sfip []*structFieldInfo // unsorted. Used when enc/dec struct to array.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rt   reflect.Type
0000000000000000000000000000000000000000;;		rtid uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numMeth uint16 // number of methods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// baseId gives pointer to the base reflect.Type, after deferencing
0000000000000000000000000000000000000000;;		// the pointers. E.g. base type of ***time.Time is time.Time.
0000000000000000000000000000000000000000;;		base      reflect.Type
0000000000000000000000000000000000000000;;		baseId    uintptr
0000000000000000000000000000000000000000;;		baseIndir int8 // number of indirections to get to base
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mbs bool // base type (T or *T) is a MapBySlice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bm        bool // base type (T or *T) is a binaryMarshaler
0000000000000000000000000000000000000000;;		bunm      bool // base type (T or *T) is a binaryUnmarshaler
0000000000000000000000000000000000000000;;		bmIndir   int8 // number of indirections to get to binaryMarshaler type
0000000000000000000000000000000000000000;;		bunmIndir int8 // number of indirections to get to binaryUnmarshaler type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tm        bool // base type (T or *T) is a textMarshaler
0000000000000000000000000000000000000000;;		tunm      bool // base type (T or *T) is a textUnmarshaler
0000000000000000000000000000000000000000;;		tmIndir   int8 // number of indirections to get to textMarshaler type
0000000000000000000000000000000000000000;;		tunmIndir int8 // number of indirections to get to textUnmarshaler type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jm        bool // base type (T or *T) is a jsonMarshaler
0000000000000000000000000000000000000000;;		junm      bool // base type (T or *T) is a jsonUnmarshaler
0000000000000000000000000000000000000000;;		jmIndir   int8 // number of indirections to get to jsonMarshaler type
0000000000000000000000000000000000000000;;		junmIndir int8 // number of indirections to get to jsonUnmarshaler type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cs      bool // base type (T or *T) is a Selfer
0000000000000000000000000000000000000000;;		csIndir int8 // number of indirections to get to Selfer type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		toArray bool // whether this (struct) type should be encoded as an array
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ti *typeInfo) indexForEncName(name string) int {
0000000000000000000000000000000000000000;;		// NOTE: name may be a stringView, so don't pass it to another function.
0000000000000000000000000000000000000000;;		//tisfi := ti.sfi
0000000000000000000000000000000000000000;;		const binarySearchThreshold = 16
0000000000000000000000000000000000000000;;		if sfilen := len(ti.sfi); sfilen < binarySearchThreshold {
0000000000000000000000000000000000000000;;			// linear search. faster than binary search in my testing up to 16-field structs.
0000000000000000000000000000000000000000;;			for i, si := range ti.sfi {
0000000000000000000000000000000000000000;;				if si.encName == name {
0000000000000000000000000000000000000000;;					return i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// binary search. adapted from sort/search.go.
0000000000000000000000000000000000000000;;			h, i, j := 0, 0, sfilen
0000000000000000000000000000000000000000;;			for i < j {
0000000000000000000000000000000000000000;;				h = i + (j-i)/2
0000000000000000000000000000000000000000;;				if ti.sfi[h].encName < name {
0000000000000000000000000000000000000000;;					i = h + 1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					j = h
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i < sfilen && ti.sfi[i].encName == name {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeInfos caches typeInfo for each type on first inspection.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is configured with a set of tag keys, which are used to get
0000000000000000000000000000000000000000;;	// configuration for the type.
0000000000000000000000000000000000000000;;	type TypeInfos struct {
0000000000000000000000000000000000000000;;		infos map[uintptr]*typeInfo
0000000000000000000000000000000000000000;;		mu    sync.RWMutex
0000000000000000000000000000000000000000;;		tags  []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTypeInfos creates a TypeInfos given a set of struct tags keys.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This allows users customize the struct tag keys which contain configuration
0000000000000000000000000000000000000000;;	// of their types.
0000000000000000000000000000000000000000;;	func NewTypeInfos(tags []string) *TypeInfos {
0000000000000000000000000000000000000000;;		return &TypeInfos{tags: tags, infos: make(map[uintptr]*typeInfo, 64)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *TypeInfos) structTag(t reflect.StructTag) (s string) {
0000000000000000000000000000000000000000;;		// check for tags: codec, json, in that order.
0000000000000000000000000000000000000000;;		// this allows seamless support for many configured structs.
0000000000000000000000000000000000000000;;		for _, x := range x.tags {
0000000000000000000000000000000000000000;;			s = t.Get(x)
0000000000000000000000000000000000000000;;			if s != "" {
0000000000000000000000000000000000000000;;				return s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *TypeInfos) get(rtid uintptr, rt reflect.Type) (pti *typeInfo) {
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		x.mu.RLock()
0000000000000000000000000000000000000000;;		pti, ok = x.infos[rtid]
0000000000000000000000000000000000000000;;		x.mu.RUnlock()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do not hold lock while computing this.
0000000000000000000000000000000000000000;;		// it may lead to duplication, but that's ok.
0000000000000000000000000000000000000000;;		ti := typeInfo{rt: rt, rtid: rtid}
0000000000000000000000000000000000000000;;		ti.numMeth = uint16(rt.NumMethod())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var indir int8
0000000000000000000000000000000000000000;;		if ok, indir = implementsIntf(rt, binaryMarshalerTyp); ok {
0000000000000000000000000000000000000000;;			ti.bm, ti.bmIndir = true, indir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, indir = implementsIntf(rt, binaryUnmarshalerTyp); ok {
0000000000000000000000000000000000000000;;			ti.bunm, ti.bunmIndir = true, indir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, indir = implementsIntf(rt, textMarshalerTyp); ok {
0000000000000000000000000000000000000000;;			ti.tm, ti.tmIndir = true, indir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, indir = implementsIntf(rt, textUnmarshalerTyp); ok {
0000000000000000000000000000000000000000;;			ti.tunm, ti.tunmIndir = true, indir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, indir = implementsIntf(rt, jsonMarshalerTyp); ok {
0000000000000000000000000000000000000000;;			ti.jm, ti.jmIndir = true, indir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, indir = implementsIntf(rt, jsonUnmarshalerTyp); ok {
0000000000000000000000000000000000000000;;			ti.junm, ti.junmIndir = true, indir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, indir = implementsIntf(rt, selferTyp); ok {
0000000000000000000000000000000000000000;;			ti.cs, ti.csIndir = true, indir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, _ = implementsIntf(rt, mapBySliceTyp); ok {
0000000000000000000000000000000000000000;;			ti.mbs = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pt := rt
0000000000000000000000000000000000000000;;		var ptIndir int8
0000000000000000000000000000000000000000;;		// for ; pt.Kind() == reflect.Ptr; pt, ptIndir = pt.Elem(), ptIndir+1 { }
0000000000000000000000000000000000000000;;		for pt.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			pt = pt.Elem()
0000000000000000000000000000000000000000;;			ptIndir++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ptIndir == 0 {
0000000000000000000000000000000000000000;;			ti.base = rt
0000000000000000000000000000000000000000;;			ti.baseId = rtid
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ti.base = pt
0000000000000000000000000000000000000000;;			ti.baseId = reflect.ValueOf(pt).Pointer()
0000000000000000000000000000000000000000;;			ti.baseIndir = ptIndir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rt.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			var omitEmpty bool
0000000000000000000000000000000000000000;;			if f, ok := rt.FieldByName(structInfoFieldName); ok {
0000000000000000000000000000000000000000;;				siInfo := parseStructFieldInfo(structInfoFieldName, x.structTag(f.Tag))
0000000000000000000000000000000000000000;;				ti.toArray = siInfo.toArray
0000000000000000000000000000000000000000;;				omitEmpty = siInfo.omitEmpty
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pi := rgetPool.Get()
0000000000000000000000000000000000000000;;			pv := pi.(*rgetPoolT)
0000000000000000000000000000000000000000;;			pv.etypes[0] = ti.baseId
0000000000000000000000000000000000000000;;			vv := rgetT{pv.fNames[:0], pv.encNames[:0], pv.etypes[:1], pv.sfis[:0]}
0000000000000000000000000000000000000000;;			x.rget(rt, rtid, omitEmpty, nil, &vv)
0000000000000000000000000000000000000000;;			ti.sfip, ti.sfi = rgetResolveSFI(vv.sfis, pv.sfiidx[:0])
0000000000000000000000000000000000000000;;			rgetPool.Put(pi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// sfi = sfip
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x.mu.Lock()
0000000000000000000000000000000000000000;;		if pti, ok = x.infos[rtid]; !ok {
0000000000000000000000000000000000000000;;			pti = &ti
0000000000000000000000000000000000000000;;			x.infos[rtid] = pti
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.mu.Unlock()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x *TypeInfos) rget(rt reflect.Type, rtid uintptr, omitEmpty bool,
0000000000000000000000000000000000000000;;		indexstack []int, pv *rgetT,
0000000000000000000000000000000000000000;;	) {
0000000000000000000000000000000000000000;;		// Read up fields and store how to access the value.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// It uses go's rules for message selectors,
0000000000000000000000000000000000000000;;		// which say that the field with the shallowest depth is selected.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Note: we consciously use slices, not a map, to simulate a set.
0000000000000000000000000000000000000000;;		//       Typically, types have < 16 fields,
0000000000000000000000000000000000000000;;		//       and iteration using equals is faster than maps there
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	LOOP:
0000000000000000000000000000000000000000;;		for j, jlen := 0, rt.NumField(); j < jlen; j++ {
0000000000000000000000000000000000000000;;			f := rt.Field(j)
0000000000000000000000000000000000000000;;			fkind := f.Type.Kind()
0000000000000000000000000000000000000000;;			// skip if a func type, or is unexported, or structTag value == "-"
0000000000000000000000000000000000000000;;			switch fkind {
0000000000000000000000000000000000000000;;			case reflect.Func, reflect.Complex64, reflect.Complex128, reflect.UnsafePointer:
0000000000000000000000000000000000000000;;				continue LOOP
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if r1, _ := utf8.DecodeRuneInString(f.Name);
0000000000000000000000000000000000000000;;			// r1 == utf8.RuneError || !unicode.IsUpper(r1) {
0000000000000000000000000000000000000000;;			if f.PkgPath != "" && !f.Anonymous { // unexported, not embedded
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stag := x.structTag(f.Tag)
0000000000000000000000000000000000000000;;			if stag == "-" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var si *structFieldInfo
0000000000000000000000000000000000000000;;			// if anonymous and no struct tag (or it's blank),
0000000000000000000000000000000000000000;;			// and a struct (or pointer to struct), inline it.
0000000000000000000000000000000000000000;;			if f.Anonymous && fkind != reflect.Interface {
0000000000000000000000000000000000000000;;				doInline := stag == ""
0000000000000000000000000000000000000000;;				if !doInline {
0000000000000000000000000000000000000000;;					si = parseStructFieldInfo("", stag)
0000000000000000000000000000000000000000;;					doInline = si.encName == ""
0000000000000000000000000000000000000000;;					// doInline = si.isZero()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if doInline {
0000000000000000000000000000000000000000;;					ft := f.Type
0000000000000000000000000000000000000000;;					for ft.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;						ft = ft.Elem()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if ft.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;						// if etypes contains this, don't call rget again (as fields are already seen here)
0000000000000000000000000000000000000000;;						ftid := reflect.ValueOf(ft).Pointer()
0000000000000000000000000000000000000000;;						// We cannot recurse forever, but we need to track other field depths.
0000000000000000000000000000000000000000;;						// So - we break if we see a type twice (not the first time).
0000000000000000000000000000000000000000;;						// This should be sufficient to handle an embedded type that refers to its
0000000000000000000000000000000000000000;;						// owning type, which then refers to its embedded type.
0000000000000000000000000000000000000000;;						processIt := true
0000000000000000000000000000000000000000;;						numk := 0
0000000000000000000000000000000000000000;;						for _, k := range pv.etypes {
0000000000000000000000000000000000000000;;							if k == ftid {
0000000000000000000000000000000000000000;;								numk++
0000000000000000000000000000000000000000;;								if numk == rgetMaxRecursion {
0000000000000000000000000000000000000000;;									processIt = false
0000000000000000000000000000000000000000;;									break
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if processIt {
0000000000000000000000000000000000000000;;							pv.etypes = append(pv.etypes, ftid)
0000000000000000000000000000000000000000;;							indexstack2 := make([]int, len(indexstack)+1)
0000000000000000000000000000000000000000;;							copy(indexstack2, indexstack)
0000000000000000000000000000000000000000;;							indexstack2[len(indexstack)] = j
0000000000000000000000000000000000000000;;							// indexstack2 := append(append(make([]int, 0, len(indexstack)+4), indexstack...), j)
0000000000000000000000000000000000000000;;							x.rget(ft, ftid, omitEmpty, indexstack2, pv)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// after the anonymous dance: if an unexported field, skip
0000000000000000000000000000000000000000;;			if f.PkgPath != "" { // unexported
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if f.Name == "" {
0000000000000000000000000000000000000000;;				panic(noFieldNameToStructFieldInfoErr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pv.fNames = append(pv.fNames, f.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if si == nil {
0000000000000000000000000000000000000000;;				si = parseStructFieldInfo(f.Name, stag)
0000000000000000000000000000000000000000;;			} else if si.encName == "" {
0000000000000000000000000000000000000000;;				si.encName = f.Name
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			si.fieldName = f.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pv.encNames = append(pv.encNames, si.encName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// si.ikind = int(f.Type.Kind())
0000000000000000000000000000000000000000;;			if len(indexstack) == 0 {
0000000000000000000000000000000000000000;;				si.i = int16(j)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				si.i = -1
0000000000000000000000000000000000000000;;				si.is = make([]int, len(indexstack)+1)
0000000000000000000000000000000000000000;;				copy(si.is, indexstack)
0000000000000000000000000000000000000000;;				si.is[len(indexstack)] = j
0000000000000000000000000000000000000000;;				// si.is = append(append(make([]int, 0, len(indexstack)+4), indexstack...), j)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if omitEmpty {
0000000000000000000000000000000000000000;;				si.omitEmpty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pv.sfis = append(pv.sfis, si)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resolves the struct field info got from a call to rget.
0000000000000000000000000000000000000000;;	// Returns a trimmed, unsorted and sorted []*structFieldInfo.
0000000000000000000000000000000000000000;;	func rgetResolveSFI(x []*structFieldInfo, pv []sfiIdx) (y, z []*structFieldInfo) {
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		for i, v := range x {
0000000000000000000000000000000000000000;;			xn := v.encName //TODO: fieldName or encName? use encName for now.
0000000000000000000000000000000000000000;;			var found bool
0000000000000000000000000000000000000000;;			for j, k := range pv {
0000000000000000000000000000000000000000;;				if k.name == xn {
0000000000000000000000000000000000000000;;					// one of them must be reset to nil, and the index updated appropriately to the other one
0000000000000000000000000000000000000000;;					if len(v.is) == len(x[k.index].is) {
0000000000000000000000000000000000000000;;					} else if len(v.is) < len(x[k.index].is) {
0000000000000000000000000000000000000000;;						pv[j].index = i
0000000000000000000000000000000000000000;;						if x[k.index] != nil {
0000000000000000000000000000000000000000;;							x[k.index] = nil
0000000000000000000000000000000000000000;;							n++
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if x[i] != nil {
0000000000000000000000000000000000000000;;							x[i] = nil
0000000000000000000000000000000000000000;;							n++
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				pv = append(pv, sfiIdx{xn, i})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove all the nils
0000000000000000000000000000000000000000;;		y = make([]*structFieldInfo, len(x)-n)
0000000000000000000000000000000000000000;;		n = 0
0000000000000000000000000000000000000000;;		for _, v := range x {
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			y[n] = v
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		z = make([]*structFieldInfo, len(y))
0000000000000000000000000000000000000000;;		copy(z, y)
0000000000000000000000000000000000000000;;		sort.Sort(sfiSortedByEncName(z))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func panicToErr(err *error) {
0000000000000000000000000000000000000000;;		if recoverPanicToErr {
0000000000000000000000000000000000000000;;			if x := recover(); x != nil {
0000000000000000000000000000000000000000;;				//debug.PrintStack()
0000000000000000000000000000000000000000;;				panicValToErr(x, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// func doPanic(tag string, format string, params ...interface{}) {
0000000000000000000000000000000000000000;;	// 	params2 := make([]interface{}, len(params)+1)
0000000000000000000000000000000000000000;;	// 	params2[0] = tag
0000000000000000000000000000000000000000;;	// 	copy(params2[1:], params)
0000000000000000000000000000000000000000;;	// 	panic(fmt.Errorf("%s: "+format, params2...))
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isImmutableKind(k reflect.Kind) (v bool) {
0000000000000000000000000000000000000000;;		return false ||
0000000000000000000000000000000000000000;;			k == reflect.Int ||
0000000000000000000000000000000000000000;;			k == reflect.Int8 ||
0000000000000000000000000000000000000000;;			k == reflect.Int16 ||
0000000000000000000000000000000000000000;;			k == reflect.Int32 ||
0000000000000000000000000000000000000000;;			k == reflect.Int64 ||
0000000000000000000000000000000000000000;;			k == reflect.Uint ||
0000000000000000000000000000000000000000;;			k == reflect.Uint8 ||
0000000000000000000000000000000000000000;;			k == reflect.Uint16 ||
0000000000000000000000000000000000000000;;			k == reflect.Uint32 ||
0000000000000000000000000000000000000000;;			k == reflect.Uint64 ||
0000000000000000000000000000000000000000;;			k == reflect.Uintptr ||
0000000000000000000000000000000000000000;;			k == reflect.Float32 ||
0000000000000000000000000000000000000000;;			k == reflect.Float64 ||
0000000000000000000000000000000000000000;;			k == reflect.Bool ||
0000000000000000000000000000000000000000;;			k == reflect.String
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// these functions must be inlinable, and not call anybody
0000000000000000000000000000000000000000;;	type checkOverflow struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ checkOverflow) Float32(f float64) (overflow bool) {
0000000000000000000000000000000000000000;;		if f < 0 {
0000000000000000000000000000000000000000;;			f = -f
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return math.MaxFloat32 < f && f <= math.MaxFloat64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ checkOverflow) Uint(v uint64, bitsize uint8) (overflow bool) {
0000000000000000000000000000000000000000;;		if bitsize == 0 || bitsize >= 64 || v == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trunc := (v << (64 - bitsize)) >> (64 - bitsize); v != trunc {
0000000000000000000000000000000000000000;;			overflow = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ checkOverflow) Int(v int64, bitsize uint8) (overflow bool) {
0000000000000000000000000000000000000000;;		if bitsize == 0 || bitsize >= 64 || v == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if trunc := (v << (64 - bitsize)) >> (64 - bitsize); v != trunc {
0000000000000000000000000000000000000000;;			overflow = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (_ checkOverflow) SignedInt(v uint64) (i int64, overflow bool) {
0000000000000000000000000000000000000000;;		//e.g. -127 to 128 for int8
0000000000000000000000000000000000000000;;		pos := (v >> 63) == 0
0000000000000000000000000000000000000000;;		ui2 := v & 0x7fffffffffffffff
0000000000000000000000000000000000000000;;		if pos {
0000000000000000000000000000000000000000;;			if ui2 > math.MaxInt64 {
0000000000000000000000000000000000000000;;				overflow = true
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if ui2 > math.MaxInt64-1 {
0000000000000000000000000000000000000000;;				overflow = true
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i = int64(v)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ------------------ SORT -----------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isNaN(f float64) bool { return f != f }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type intSlice []int64
0000000000000000000000000000000000000000;;	type uintSlice []uint64
0000000000000000000000000000000000000000;;	type floatSlice []float64
0000000000000000000000000000000000000000;;	type boolSlice []bool
0000000000000000000000000000000000000000;;	type stringSlice []string
0000000000000000000000000000000000000000;;	type bytesSlice [][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p intSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p intSlice) Less(i, j int) bool { return p[i] < p[j] }
0000000000000000000000000000000000000000;;	func (p intSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p uintSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p uintSlice) Less(i, j int) bool { return p[i] < p[j] }
0000000000000000000000000000000000000000;;	func (p uintSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p floatSlice) Len() int { return len(p) }
0000000000000000000000000000000000000000;;	func (p floatSlice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return p[i] < p[j] || isNaN(p[i]) && !isNaN(p[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (p floatSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p stringSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p stringSlice) Less(i, j int) bool { return p[i] < p[j] }
0000000000000000000000000000000000000000;;	func (p stringSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p bytesSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p bytesSlice) Less(i, j int) bool { return bytes.Compare(p[i], p[j]) == -1 }
0000000000000000000000000000000000000000;;	func (p bytesSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p boolSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p boolSlice) Less(i, j int) bool { return !p[i] && p[j] }
0000000000000000000000000000000000000000;;	func (p boolSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ---------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type intRv struct {
0000000000000000000000000000000000000000;;		v int64
0000000000000000000000000000000000000000;;		r reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type intRvSlice []intRv
0000000000000000000000000000000000000000;;	type uintRv struct {
0000000000000000000000000000000000000000;;		v uint64
0000000000000000000000000000000000000000;;		r reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type uintRvSlice []uintRv
0000000000000000000000000000000000000000;;	type floatRv struct {
0000000000000000000000000000000000000000;;		v float64
0000000000000000000000000000000000000000;;		r reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type floatRvSlice []floatRv
0000000000000000000000000000000000000000;;	type boolRv struct {
0000000000000000000000000000000000000000;;		v bool
0000000000000000000000000000000000000000;;		r reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type boolRvSlice []boolRv
0000000000000000000000000000000000000000;;	type stringRv struct {
0000000000000000000000000000000000000000;;		v string
0000000000000000000000000000000000000000;;		r reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type stringRvSlice []stringRv
0000000000000000000000000000000000000000;;	type bytesRv struct {
0000000000000000000000000000000000000000;;		v []byte
0000000000000000000000000000000000000000;;		r reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type bytesRvSlice []bytesRv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p intRvSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p intRvSlice) Less(i, j int) bool { return p[i].v < p[j].v }
0000000000000000000000000000000000000000;;	func (p intRvSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p uintRvSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p uintRvSlice) Less(i, j int) bool { return p[i].v < p[j].v }
0000000000000000000000000000000000000000;;	func (p uintRvSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p floatRvSlice) Len() int { return len(p) }
0000000000000000000000000000000000000000;;	func (p floatRvSlice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return p[i].v < p[j].v || isNaN(p[i].v) && !isNaN(p[j].v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (p floatRvSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p stringRvSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p stringRvSlice) Less(i, j int) bool { return p[i].v < p[j].v }
0000000000000000000000000000000000000000;;	func (p stringRvSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p bytesRvSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p bytesRvSlice) Less(i, j int) bool { return bytes.Compare(p[i].v, p[j].v) == -1 }
0000000000000000000000000000000000000000;;	func (p bytesRvSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p boolRvSlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p boolRvSlice) Less(i, j int) bool { return !p[i].v && p[j].v }
0000000000000000000000000000000000000000;;	func (p boolRvSlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bytesI struct {
0000000000000000000000000000000000000000;;		v []byte
0000000000000000000000000000000000000000;;		i interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bytesISlice []bytesI
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p bytesISlice) Len() int           { return len(p) }
0000000000000000000000000000000000000000;;	func (p bytesISlice) Less(i, j int) bool { return bytes.Compare(p[i].v, p[j].v) == -1 }
0000000000000000000000000000000000000000;;	func (p bytesISlice) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type set []uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *set) add(v uintptr) (exists bool) {
0000000000000000000000000000000000000000;;		// e.ci is always nil, or len >= 1
0000000000000000000000000000000000000000;;		// defer func() { fmt.Printf("$$$$$$$$$$$ cirRef Add: %v, exists: %v\n", v, exists) }()
0000000000000000000000000000000000000000;;		x := *s
0000000000000000000000000000000000000000;;		if x == nil {
0000000000000000000000000000000000000000;;			x = make([]uintptr, 1, 8)
0000000000000000000000000000000000000000;;			x[0] = v
0000000000000000000000000000000000000000;;			*s = x
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// typically, length will be 1. make this perform.
0000000000000000000000000000000000000000;;		if len(x) == 1 {
0000000000000000000000000000000000000000;;			if j := x[0]; j == 0 {
0000000000000000000000000000000000000000;;				x[0] = v
0000000000000000000000000000000000000000;;			} else if j == v {
0000000000000000000000000000000000000000;;				exists = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				x = append(x, v)
0000000000000000000000000000000000000000;;				*s = x
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// check if it exists
0000000000000000000000000000000000000000;;		for _, j := range x {
0000000000000000000000000000000000000000;;			if j == v {
0000000000000000000000000000000000000000;;				exists = true
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// try to replace a "deleted" slot
0000000000000000000000000000000000000000;;		for i, j := range x {
0000000000000000000000000000000000000000;;			if j == 0 {
0000000000000000000000000000000000000000;;				x[i] = v
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if unable to replace deleted slot, just append it.
0000000000000000000000000000000000000000;;		x = append(x, v)
0000000000000000000000000000000000000000;;		*s = x
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *set) remove(v uintptr) (exists bool) {
0000000000000000000000000000000000000000;;		// defer func() { fmt.Printf("$$$$$$$$$$$ cirRef Rm: %v, exists: %v\n", v, exists) }()
0000000000000000000000000000000000000000;;		x := *s
0000000000000000000000000000000000000000;;		if len(x) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(x) == 1 {
0000000000000000000000000000000000000000;;			if x[0] == v {
0000000000000000000000000000000000000000;;				x[0] = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, j := range x {
0000000000000000000000000000000000000000;;			if j == v {
0000000000000000000000000000000000000000;;				exists = true
0000000000000000000000000000000000000000;;				x[i] = 0 // set it to 0, as way to delete it.
0000000000000000000000000000000000000000;;				// copy(x[i:], x[i+1:])
0000000000000000000000000000000000000000;;				// x = x[:len(x)-1]
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
