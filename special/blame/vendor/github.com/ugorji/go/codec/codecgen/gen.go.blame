0000000000000000000000000000000000000000;;	// Copyright (c) 2012-2015 Ugorji Nwoke. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a MIT license found in the LICENSE file.
d889ac23bcdf2804cc23257941dbc2c4eda70036;Godeps/_workspace/src/github.com/ugorji/go/codec/codecgen/gen.go[Godeps/_workspace/src/github.com/ugorji/go/codec/codecgen/gen.go][vendor/github.com/ugorji/go/codec/codecgen/gen.go];	
0000000000000000000000000000000000000000;;	// codecgen generates codec.Selfer implementations for a set of types.
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/ast"
0000000000000000000000000000000000000000;;		"go/build"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"text/template"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const genCodecPkg = "codec1978" // keep this in sync with codec.genCodecPkg
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const genFrunMainTmpl = `//+build ignore
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	{{ if .Types }}import "{{ .ImportPath }}"{{ end }}
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		{{ $.PackageName }}.CodecGenTempWrite{{ .RandString }}()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// const genFrunPkgTmpl = `//+build codecgen
0000000000000000000000000000000000000000;;	const genFrunPkgTmpl = `
0000000000000000000000000000000000000000;;	package {{ $.PackageName }}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		{{ if not .CodecPkgFiles }}{{ .CodecPkgName }} "{{ .CodecImportPath }}"{{ end }}
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"go/format"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CodecGenTempWrite{{ .RandString }}() {
0000000000000000000000000000000000000000;;		fout, err := os.Create("{{ .OutFile }}")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer fout.Close()
0000000000000000000000000000000000000000;;		var out bytes.Buffer
0000000000000000000000000000000000000000;;		
0000000000000000000000000000000000000000;;		var typs []reflect.Type 
0000000000000000000000000000000000000000;;	{{ range $index, $element := .Types }}
0000000000000000000000000000000000000000;;		var t{{ $index }} {{ . }}
0000000000000000000000000000000000000000;;		typs = append(typs, reflect.TypeOf(t{{ $index }}))
0000000000000000000000000000000000000000;;	{{ end }}
0000000000000000000000000000000000000000;;		{{ if not .CodecPkgFiles }}{{ .CodecPkgName }}.{{ end }}Gen(&out, "{{ .BuildTag }}", "{{ .PackageName }}", "{{ .RandString }}", {{ .UseUnsafe }}, {{ if not .CodecPkgFiles }}{{ .CodecPkgName }}.{{ end }}NewTypeInfos(strings.Split("{{ .StructTags }}", ",")), typs...)
0000000000000000000000000000000000000000;;		bout, err := format.Source(out.Bytes())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fout.Write(out.Bytes())
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fout.Write(bout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate is given a list of *.go files to parse, and an output file (fout).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It finds all types T in the files, and it creates 2 tmp files (frun).
0000000000000000000000000000000000000000;;	//   - main package file passed to 'go run'
0000000000000000000000000000000000000000;;	//   - package level file which calls *genRunner.Selfer to write Selfer impls for each T.
0000000000000000000000000000000000000000;;	// We use a package level file so that it can reference unexported types in the package being worked on.
0000000000000000000000000000000000000000;;	// Tool then executes: "go run __frun__" which creates fout.
0000000000000000000000000000000000000000;;	// fout contains Codec(En|De)codeSelf implementations for every type T.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Generate(outfile, buildTag, codecPkgPath string, uid int64, useUnsafe bool, goRunTag string,
0000000000000000000000000000000000000000;;		st string, regexName *regexp.Regexp, notRegexName *regexp.Regexp, deleteTempFile bool, infiles ...string) (err error) {
0000000000000000000000000000000000000000;;		// For each file, grab AST, find each type, and write a call to it.
0000000000000000000000000000000000000000;;		if len(infiles) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if outfile == "" || codecPkgPath == "" {
0000000000000000000000000000000000000000;;			err = errors.New("outfile and codec package path cannot be blank")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if uid < 0 {
0000000000000000000000000000000000000000;;			uid = -uid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if uid == 0 {
0000000000000000000000000000000000000000;;			rr := rand.New(rand.NewSource(time.Now().UnixNano()))
0000000000000000000000000000000000000000;;			uid = 101 + rr.Int63n(9777)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We have to parse dir for package, before opening the temp file for writing (else ImportDir fails).
0000000000000000000000000000000000000000;;		// Also, ImportDir(...) must take an absolute path.
0000000000000000000000000000000000000000;;		lastdir := filepath.Dir(outfile)
0000000000000000000000000000000000000000;;		absdir, err := filepath.Abs(lastdir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pkg, err := build.Default.ImportDir(absdir, build.AllowBinary)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		type tmplT struct {
0000000000000000000000000000000000000000;;			CodecPkgName    string
0000000000000000000000000000000000000000;;			CodecImportPath string
0000000000000000000000000000000000000000;;			ImportPath      string
0000000000000000000000000000000000000000;;			OutFile         string
0000000000000000000000000000000000000000;;			PackageName     string
0000000000000000000000000000000000000000;;			RandString      string
0000000000000000000000000000000000000000;;			BuildTag        string
0000000000000000000000000000000000000000;;			StructTags      string
0000000000000000000000000000000000000000;;			Types           []string
0000000000000000000000000000000000000000;;			CodecPkgFiles   bool
0000000000000000000000000000000000000000;;			UseUnsafe       bool
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tv := tmplT{
0000000000000000000000000000000000000000;;			CodecPkgName:    genCodecPkg,
0000000000000000000000000000000000000000;;			OutFile:         outfile,
0000000000000000000000000000000000000000;;			CodecImportPath: codecPkgPath,
0000000000000000000000000000000000000000;;			BuildTag:        buildTag,
0000000000000000000000000000000000000000;;			UseUnsafe:       useUnsafe,
0000000000000000000000000000000000000000;;			RandString:      strconv.FormatInt(uid, 10),
0000000000000000000000000000000000000000;;			StructTags:      st,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tv.ImportPath = pkg.ImportPath
0000000000000000000000000000000000000000;;		if tv.ImportPath == tv.CodecImportPath {
0000000000000000000000000000000000000000;;			tv.CodecPkgFiles = true
0000000000000000000000000000000000000000;;			tv.CodecPkgName = "codec"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// HACK: always handle vendoring. It should be typically on in go 1.6, 1.7
0000000000000000000000000000000000000000;;			s := tv.ImportPath
0000000000000000000000000000000000000000;;			const vendorStart = "vendor/"
0000000000000000000000000000000000000000;;			const vendorInline = "/vendor/"
0000000000000000000000000000000000000000;;			if i := strings.LastIndex(s, vendorInline); i >= 0 {
0000000000000000000000000000000000000000;;				tv.ImportPath = s[i+len(vendorInline):]
0000000000000000000000000000000000000000;;			} else if strings.HasPrefix(s, vendorStart) {
0000000000000000000000000000000000000000;;				tv.ImportPath = s[len(vendorStart):]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		astfiles := make([]*ast.File, len(infiles))
0000000000000000000000000000000000000000;;		for i, infile := range infiles {
0000000000000000000000000000000000000000;;			if filepath.Dir(infile) != lastdir {
0000000000000000000000000000000000000000;;				err = errors.New("in files must all be in same directory as outfile")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fset := token.NewFileSet()
0000000000000000000000000000000000000000;;			astfiles[i], err = parser.ParseFile(fset, infile, nil, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				tv.PackageName = astfiles[i].Name.Name
0000000000000000000000000000000000000000;;				if tv.PackageName == "main" {
0000000000000000000000000000000000000000;;					// codecgen cannot be run on types in the 'main' package.
0000000000000000000000000000000000000000;;					// A temporary 'main' package must be created, and should reference the fully built
0000000000000000000000000000000000000000;;					// package containing the types.
0000000000000000000000000000000000000000;;					// Also, the temporary main package will conflict with the main package which already has a main method.
0000000000000000000000000000000000000000;;					err = errors.New("codecgen cannot be run on types in the 'main' package")
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keep track of types with selfer methods
0000000000000000000000000000000000000000;;		// selferMethods := []string{"CodecEncodeSelf", "CodecDecodeSelf"}
0000000000000000000000000000000000000000;;		selferEncTyps := make(map[string]bool)
0000000000000000000000000000000000000000;;		selferDecTyps := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, f := range astfiles {
0000000000000000000000000000000000000000;;			for _, d := range f.Decls {
0000000000000000000000000000000000000000;;				// if fd, ok := d.(*ast.FuncDecl); ok && fd.Recv != nil && fd.Recv.NumFields() == 1 {
0000000000000000000000000000000000000000;;				if fd, ok := d.(*ast.FuncDecl); ok && fd.Recv != nil && len(fd.Recv.List) == 1 {
0000000000000000000000000000000000000000;;					recvType := fd.Recv.List[0].Type
0000000000000000000000000000000000000000;;					if ptr, ok := recvType.(*ast.StarExpr); ok {
0000000000000000000000000000000000000000;;						recvType = ptr.X
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if id, ok := recvType.(*ast.Ident); ok {
0000000000000000000000000000000000000000;;						switch fd.Name.Name {
0000000000000000000000000000000000000000;;						case "CodecEncodeSelf":
0000000000000000000000000000000000000000;;							selferEncTyps[id.Name] = true
0000000000000000000000000000000000000000;;						case "CodecDecodeSelf":
0000000000000000000000000000000000000000;;							selferDecTyps[id.Name] = true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now find types
0000000000000000000000000000000000000000;;		for _, f := range astfiles {
0000000000000000000000000000000000000000;;			for _, d := range f.Decls {
0000000000000000000000000000000000000000;;				if gd, ok := d.(*ast.GenDecl); ok {
0000000000000000000000000000000000000000;;					for _, dd := range gd.Specs {
0000000000000000000000000000000000000000;;						if td, ok := dd.(*ast.TypeSpec); ok {
0000000000000000000000000000000000000000;;							// if len(td.Name.Name) == 0 || td.Name.Name[0] > 'Z' || td.Name.Name[0] < 'A' {
0000000000000000000000000000000000000000;;							if len(td.Name.Name) == 0 {
0000000000000000000000000000000000000000;;								continue
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							// only generate for:
0000000000000000000000000000000000000000;;							//   struct: StructType
0000000000000000000000000000000000000000;;							//   primitives (numbers, bool, string): Ident
0000000000000000000000000000000000000000;;							//   map: MapType
0000000000000000000000000000000000000000;;							//   slice, array: ArrayType
0000000000000000000000000000000000000000;;							//   chan: ChanType
0000000000000000000000000000000000000000;;							// do not generate:
0000000000000000000000000000000000000000;;							//   FuncType, InterfaceType, StarExpr (ptr), etc
0000000000000000000000000000000000000000;;							switch td.Type.(type) {
0000000000000000000000000000000000000000;;							case *ast.StructType, *ast.Ident, *ast.MapType, *ast.ArrayType, *ast.ChanType:
0000000000000000000000000000000000000000;;								// only add to tv.Types iff
0000000000000000000000000000000000000000;;								//   - it matches per the -r parameter
0000000000000000000000000000000000000000;;								//   - it doesn't match per the -nr parameter
0000000000000000000000000000000000000000;;								//   - it doesn't have any of the Selfer methods in the file
0000000000000000000000000000000000000000;;								if regexName.FindStringIndex(td.Name.Name) != nil &&
0000000000000000000000000000000000000000;;									notRegexName.FindStringIndex(td.Name.Name) == nil &&
0000000000000000000000000000000000000000;;									!selferEncTyps[td.Name.Name] &&
0000000000000000000000000000000000000000;;									!selferDecTyps[td.Name.Name] {
0000000000000000000000000000000000000000;;									tv.Types = append(tv.Types, td.Name.Name)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(tv.Types) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we cannot use ioutil.TempFile, because we cannot guarantee the file suffix (.go).
0000000000000000000000000000000000000000;;		// Also, we cannot create file in temp directory,
0000000000000000000000000000000000000000;;		// because go run will not work (as it needs to see the types here).
0000000000000000000000000000000000000000;;		// Consequently, create the temp file in the current directory, and remove when done.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// frun, err = ioutil.TempFile("", "codecgen-")
0000000000000000000000000000000000000000;;		// frunName := filepath.Join(os.TempDir(), "codecgen-"+strconv.FormatInt(time.Now().UnixNano(), 10)+".go")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		frunMainName := "codecgen-main-" + tv.RandString + ".generated.go"
0000000000000000000000000000000000000000;;		frunPkgName := "codecgen-pkg-" + tv.RandString + ".generated.go"
0000000000000000000000000000000000000000;;		if deleteTempFile {
0000000000000000000000000000000000000000;;			defer os.Remove(frunMainName)
0000000000000000000000000000000000000000;;			defer os.Remove(frunPkgName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// var frunMain, frunPkg *os.File
0000000000000000000000000000000000000000;;		if _, err = gen1(frunMainName, genFrunMainTmpl, &tv); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = gen1(frunPkgName, genFrunPkgTmpl, &tv); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove outfile, so "go run ..." will not think that types in outfile already exist.
0000000000000000000000000000000000000000;;		os.Remove(outfile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// execute go run frun
0000000000000000000000000000000000000000;;		cmd := exec.Command("go", "run", "-tags="+goRunTag, frunMainName) //, frunPkg.Name())
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		cmd.Stdout = &buf
0000000000000000000000000000000000000000;;		cmd.Stderr = &buf
0000000000000000000000000000000000000000;;		if err = cmd.Run(); err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("error running 'go run %s': %v, console: %s",
0000000000000000000000000000000000000000;;				frunMainName, err, buf.Bytes())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		os.Stdout.Write(buf.Bytes())
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func gen1(frunName, tmplStr string, tv interface{}) (frun *os.File, err error) {
0000000000000000000000000000000000000000;;		os.Remove(frunName)
0000000000000000000000000000000000000000;;		if frun, err = os.Create(frunName); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer frun.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := template.New("")
0000000000000000000000000000000000000000;;		if t, err = t.Parse(tmplStr); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bw := bufio.NewWriter(frun)
0000000000000000000000000000000000000000;;		if err = t.Execute(bw, tv); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = bw.Flush(); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		o := flag.String("o", "", "out file")
0000000000000000000000000000000000000000;;		c := flag.String("c", genCodecPath, "codec path")
0000000000000000000000000000000000000000;;		t := flag.String("t", "", "build tag to put in file")
0000000000000000000000000000000000000000;;		r := flag.String("r", ".*", "regex for type name to match")
0000000000000000000000000000000000000000;;		nr := flag.String("nr", "^$", "regex for type name to exclude")
0000000000000000000000000000000000000000;;		rt := flag.String("rt", "", "tags for go run")
0000000000000000000000000000000000000000;;		st := flag.String("st", "codec,json", "struct tag keys to introspect")
0000000000000000000000000000000000000000;;		x := flag.Bool("x", false, "keep temp file")
0000000000000000000000000000000000000000;;		u := flag.Bool("u", false, "Use unsafe, e.g. to avoid unnecessary allocation on []byte->string")
0000000000000000000000000000000000000000;;		d := flag.Int64("d", 0, "random identifier for use in generated code")
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;		if err := Generate(*o, *t, *c, *d, *u, *rt, *st,
0000000000000000000000000000000000000000;;			regexp.MustCompile(*r), regexp.MustCompile(*nr), !*x, flag.Args()...); err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "codecgen error: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
