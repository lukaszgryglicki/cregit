0000000000000000000000000000000000000000;;	// Copyright 2016 Frank Schroeder. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package properties
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encoding specifies encoding of the input data.
0000000000000000000000000000000000000000;;	type Encoding uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// UTF8 interprets the input data as UTF-8.
0000000000000000000000000000000000000000;;		UTF8 Encoding = 1 << iota
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ISO_8859_1 interprets the input data as ISO-8859-1.
0000000000000000000000000000000000000000;;		ISO_8859_1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load reads a buffer into a Properties struct.
0000000000000000000000000000000000000000;;	func Load(buf []byte, enc Encoding) (*Properties, error) {
0000000000000000000000000000000000000000;;		return loadBuf(buf, enc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadString reads an UTF8 string into a properties struct.
0000000000000000000000000000000000000000;;	func LoadString(s string) (*Properties, error) {
0000000000000000000000000000000000000000;;		return loadBuf([]byte(s), UTF8)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadFile reads a file into a Properties struct.
0000000000000000000000000000000000000000;;	func LoadFile(filename string, enc Encoding) (*Properties, error) {
0000000000000000000000000000000000000000;;		return loadAll([]string{filename}, enc, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadFiles reads multiple files in the given order into
0000000000000000000000000000000000000000;;	// a Properties struct. If 'ignoreMissing' is true then
0000000000000000000000000000000000000000;;	// non-existent files will not be reported as error.
0000000000000000000000000000000000000000;;	func LoadFiles(filenames []string, enc Encoding, ignoreMissing bool) (*Properties, error) {
0000000000000000000000000000000000000000;;		return loadAll(filenames, enc, ignoreMissing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadURL reads the content of the URL into a Properties struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The encoding is determined via the Content-Type header which
0000000000000000000000000000000000000000;;	// should be set to 'text/plain'. If the 'charset' parameter is
0000000000000000000000000000000000000000;;	// missing, 'iso-8859-1' or 'latin1' the encoding is set to
0000000000000000000000000000000000000000;;	// ISO-8859-1. If the 'charset' parameter is set to 'utf-8' the
0000000000000000000000000000000000000000;;	// encoding is set to UTF-8. A missing content type header is
0000000000000000000000000000000000000000;;	// interpreted as 'text/plain; charset=utf-8'.
0000000000000000000000000000000000000000;;	func LoadURL(url string) (*Properties, error) {
0000000000000000000000000000000000000000;;		return loadAll([]string{url}, UTF8, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadURLs reads the content of multiple URLs in the given order into a
0000000000000000000000000000000000000000;;	// Properties struct. If 'ignoreMissing' is true then a 404 status code will
0000000000000000000000000000000000000000;;	// not be reported as error. See LoadURL for the Content-Type header
0000000000000000000000000000000000000000;;	// and the encoding.
0000000000000000000000000000000000000000;;	func LoadURLs(urls []string, ignoreMissing bool) (*Properties, error) {
0000000000000000000000000000000000000000;;		return loadAll(urls, UTF8, ignoreMissing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadAll reads the content of multiple URLs or files in the given order into a
0000000000000000000000000000000000000000;;	// Properties struct. If 'ignoreMissing' is true then a 404 status code or missing file will
0000000000000000000000000000000000000000;;	// not be reported as error. Encoding sets the encoding for files. For the URLs please see
0000000000000000000000000000000000000000;;	// LoadURL for the Content-Type header and the encoding.
0000000000000000000000000000000000000000;;	func LoadAll(names []string, enc Encoding, ignoreMissing bool) (*Properties, error) {
0000000000000000000000000000000000000000;;		return loadAll(names, enc, ignoreMissing)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustLoadString reads an UTF8 string into a Properties struct and
0000000000000000000000000000000000000000;;	// panics on error.
0000000000000000000000000000000000000000;;	func MustLoadString(s string) *Properties {
0000000000000000000000000000000000000000;;		return must(LoadString(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustLoadFile reads a file into a Properties struct and
0000000000000000000000000000000000000000;;	// panics on error.
0000000000000000000000000000000000000000;;	func MustLoadFile(filename string, enc Encoding) *Properties {
0000000000000000000000000000000000000000;;		return must(LoadFile(filename, enc))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustLoadFiles reads multiple files in the given order into
0000000000000000000000000000000000000000;;	// a Properties struct and panics on error. If 'ignoreMissing'
0000000000000000000000000000000000000000;;	// is true then non-existent files will not be reported as error.
0000000000000000000000000000000000000000;;	func MustLoadFiles(filenames []string, enc Encoding, ignoreMissing bool) *Properties {
0000000000000000000000000000000000000000;;		return must(LoadFiles(filenames, enc, ignoreMissing))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustLoadURL reads the content of a URL into a Properties struct and
0000000000000000000000000000000000000000;;	// panics on error.
0000000000000000000000000000000000000000;;	func MustLoadURL(url string) *Properties {
0000000000000000000000000000000000000000;;		return must(LoadURL(url))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustLoadFiles reads the content of multiple URLs in the given order into a
0000000000000000000000000000000000000000;;	// Properties struct and panics on error. If 'ignoreMissing' is true then a 404
0000000000000000000000000000000000000000;;	// status code will not be reported as error.
0000000000000000000000000000000000000000;;	func MustLoadURLs(urls []string, ignoreMissing bool) *Properties {
0000000000000000000000000000000000000000;;		return must(LoadURLs(urls, ignoreMissing))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustLoadAll reads the content of multiple URLs or files in the given order into a
0000000000000000000000000000000000000000;;	// Properties struct. If 'ignoreMissing' is true then a 404 status code or missing file will
0000000000000000000000000000000000000000;;	// not be reported as error. Encoding sets the encoding for files. For the URLs please see
0000000000000000000000000000000000000000;;	// LoadURL for the Content-Type header and the encoding. It panics on error.
0000000000000000000000000000000000000000;;	func MustLoadAll(names []string, enc Encoding, ignoreMissing bool) *Properties {
0000000000000000000000000000000000000000;;		return must(LoadAll(names, enc, ignoreMissing))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadBuf(buf []byte, enc Encoding) (*Properties, error) {
0000000000000000000000000000000000000000;;		p, err := parse(convert(buf, enc))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, p.check()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadAll(names []string, enc Encoding, ignoreMissing bool) (*Properties, error) {
0000000000000000000000000000000000000000;;		result := NewProperties()
0000000000000000000000000000000000000000;;		for _, name := range names {
0000000000000000000000000000000000000000;;			n, err := expandName(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var p *Properties
0000000000000000000000000000000000000000;;			if strings.HasPrefix(n, "http://") || strings.HasPrefix(n, "https://") {
0000000000000000000000000000000000000000;;				p, err = loadURL(n, ignoreMissing)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p, err = loadFile(n, enc, ignoreMissing)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.Merge(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, result.check()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadFile(filename string, enc Encoding, ignoreMissing bool) (*Properties, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if ignoreMissing && os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				LogPrintf("properties: %s not found. skipping", filename)
0000000000000000000000000000000000000000;;				return NewProperties(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err := parse(convert(data, enc))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func loadURL(url string, ignoreMissing bool) (*Properties, error) {
0000000000000000000000000000000000000000;;		resp, err := http.Get(url)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("properties: error fetching %q. %s", url, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode == 404 && ignoreMissing {
0000000000000000000000000000000000000000;;			LogPrintf("properties: %s returned %d. skipping", url, resp.StatusCode)
0000000000000000000000000000000000000000;;			return NewProperties(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("properties: %s returned %d", url, resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		body, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;		resp.Body.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("properties: %s error reading response. %s", url, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ct := resp.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;		var enc Encoding
0000000000000000000000000000000000000000;;		switch strings.ToLower(ct) {
0000000000000000000000000000000000000000;;		case "text/plain", "text/plain; charset=iso-8859-1", "text/plain; charset=latin1":
0000000000000000000000000000000000000000;;			enc = ISO_8859_1
0000000000000000000000000000000000000000;;		case "", "text/plain; charset=utf-8":
0000000000000000000000000000000000000000;;			enc = UTF8
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("properties: invalid content type %s", ct)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p, err := parse(convert(body, enc))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func must(p *Properties, err error) *Properties {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expandName expands ${ENV_VAR} expressions in a name.
0000000000000000000000000000000000000000;;	// If the environment variable does not exist then it will be replaced
0000000000000000000000000000000000000000;;	// with an empty string. Malformed expressions like "${ENV_VAR" will
0000000000000000000000000000000000000000;;	// be reported as error.
0000000000000000000000000000000000000000;;	func expandName(name string) (string, error) {
0000000000000000000000000000000000000000;;		return expand(name, make(map[string]bool), "${", "}", make(map[string]string))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interprets a byte buffer either as an ISO-8859-1 or UTF-8 encoded string.
0000000000000000000000000000000000000000;;	// For ISO-8859-1 we can convert each byte straight into a rune since the
0000000000000000000000000000000000000000;;	// first 256 unicode code points cover ISO-8859-1.
0000000000000000000000000000000000000000;;	func convert(buf []byte, enc Encoding) string {
0000000000000000000000000000000000000000;;		switch enc {
0000000000000000000000000000000000000000;;		case UTF8:
0000000000000000000000000000000000000000;;			return string(buf)
0000000000000000000000000000000000000000;;		case ISO_8859_1:
0000000000000000000000000000000000000000;;			runes := make([]rune, len(buf))
0000000000000000000000000000000000000000;;			for i, b := range buf {
0000000000000000000000000000000000000000;;				runes[i] = rune(b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string(runes)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			ErrorHandler(fmt.Errorf("unsupported encoding %v", enc))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("ErrorHandler should exit")
0000000000000000000000000000000000000000;;	}
