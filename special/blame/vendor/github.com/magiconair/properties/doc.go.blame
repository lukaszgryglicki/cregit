0000000000000000000000000000000000000000;;	// Copyright 2016 Frank Schroeder. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// Package properties provides functions for reading and writing
0000000000000000000000000000000000000000;;	// ISO-8859-1 and UTF-8 encoded .properties files and has
0000000000000000000000000000000000000000;;	// support for recursive property expansion.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Java properties files are ISO-8859-1 encoded and use Unicode
0000000000000000000000000000000000000000;;	// literals for characters outside the ISO character set. Unicode
0000000000000000000000000000000000000000;;	// literals can be used in UTF-8 encoded properties files but
0000000000000000000000000000000000000000;;	// aren't necessary.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To load a single properties file use MustLoadFile():
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   p := properties.MustLoadFile(filename, properties.UTF8)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To load multiple properties files use MustLoadFiles()
0000000000000000000000000000000000000000;;	// which loads the files in the given order and merges the
0000000000000000000000000000000000000000;;	// result. Missing properties files can be ignored if the
0000000000000000000000000000000000000000;;	// 'ignoreMissing' flag is set to true.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Filenames can contain environment variables which are expanded
0000000000000000000000000000000000000000;;	// before loading.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   f1 := "/etc/myapp/myapp.conf"
0000000000000000000000000000000000000000;;	//   f2 := "/home/${USER}/myapp.conf"
0000000000000000000000000000000000000000;;	//   p := MustLoadFiles([]string{f1, f2}, properties.UTF8, true)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All of the different key/value delimiters ' ', ':' and '=' are
0000000000000000000000000000000000000000;;	// supported as well as the comment characters '!' and '#' and
0000000000000000000000000000000000000000;;	// multi-line values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   ! this is a comment
0000000000000000000000000000000000000000;;	//   # and so is this
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # the following expressions are equal
0000000000000000000000000000000000000000;;	//   key value
0000000000000000000000000000000000000000;;	//   key=value
0000000000000000000000000000000000000000;;	//   key:value
0000000000000000000000000000000000000000;;	//   key = value
0000000000000000000000000000000000000000;;	//   key : value
0000000000000000000000000000000000000000;;	//   key = val\
0000000000000000000000000000000000000000;;	//         ue
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Properties stores all comments preceding a key and provides
0000000000000000000000000000000000000000;;	// GetComments() and SetComments() methods to retrieve and
0000000000000000000000000000000000000000;;	// update them. The convenience functions GetComment() and
0000000000000000000000000000000000000000;;	// SetComment() allow access to the last comment. The
0000000000000000000000000000000000000000;;	// WriteComment() method writes properties files including
0000000000000000000000000000000000000000;;	// the comments and with the keys in the original order.
0000000000000000000000000000000000000000;;	// This can be used for sanitizing properties files.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Property expansion is recursive and circular references
0000000000000000000000000000000000000000;;	// and malformed expressions are not allowed and cause an
0000000000000000000000000000000000000000;;	// error. Expansion of environment variables is supported.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # standard property
0000000000000000000000000000000000000000;;	//   key = value
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # property expansion: key2 = value
0000000000000000000000000000000000000000;;	//   key2 = ${key}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # recursive expansion: key3 = value
0000000000000000000000000000000000000000;;	//   key3 = ${key2}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # circular reference (error)
0000000000000000000000000000000000000000;;	//   key = ${key}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # malformed expression (error)
0000000000000000000000000000000000000000;;	//   key = ${ke
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # refers to the users' home dir
0000000000000000000000000000000000000000;;	//   home = ${HOME}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # local key takes precendence over env var: u = foo
0000000000000000000000000000000000000000;;	//   USER = foo
0000000000000000000000000000000000000000;;	//   u = ${USER}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The default property expansion format is ${key} but can be
0000000000000000000000000000000000000000;;	// changed by setting different pre- and postfix values on the
0000000000000000000000000000000000000000;;	// Properties object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   p := properties.NewProperties()
0000000000000000000000000000000000000000;;	//   p.Prefix = "#["
0000000000000000000000000000000000000000;;	//   p.Postfix = "]#"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Properties provides convenience functions for getting typed
0000000000000000000000000000000000000000;;	// values with default values if the key does not exist or the
0000000000000000000000000000000000000000;;	// type conversion failed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # Returns true if the value is either "1", "on", "yes" or "true"
0000000000000000000000000000000000000000;;	//   # Returns false for every other value and the default value if
0000000000000000000000000000000000000000;;	//   # the key does not exist.
0000000000000000000000000000000000000000;;	//   v = p.GetBool("key", false)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # Returns the value if the key exists and the format conversion
0000000000000000000000000000000000000000;;	//   # was successful. Otherwise, the default value is returned.
0000000000000000000000000000000000000000;;	//   v = p.GetInt64("key", 999)
0000000000000000000000000000000000000000;;	//   v = p.GetUint64("key", 999)
0000000000000000000000000000000000000000;;	//   v = p.GetFloat64("key", 123.0)
0000000000000000000000000000000000000000;;	//   v = p.GetString("key", "def")
0000000000000000000000000000000000000000;;	//   v = p.GetDuration("key", 999)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As an alterantive properties may be applied with the standard
0000000000000000000000000000000000000000;;	// library's flag implementation at any time.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # Standard configuration
0000000000000000000000000000000000000000;;	//   v = flag.Int("key", 999, "help message")
0000000000000000000000000000000000000000;;	//   flag.Parse()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # Merge p into the flag set
0000000000000000000000000000000000000000;;	//   p.MustFlag(flag.CommandLine)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Properties provides several MustXXX() convenience functions
0000000000000000000000000000000000000000;;	// which will terminate the app if an error occurs. The behavior
0000000000000000000000000000000000000000;;	// of the failure is configurable and the default is to call
0000000000000000000000000000000000000000;;	// log.Fatal(err). To have the MustXXX() functions panic instead
0000000000000000000000000000000000000000;;	// of logging the error set a different ErrorHandler before
0000000000000000000000000000000000000000;;	// you use the Properties package.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   properties.ErrorHandler = properties.PanicHandler
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # Will panic instead of logging an error
0000000000000000000000000000000000000000;;	//   p := properties.MustLoadFile("config.properties")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// You can also provide your own ErrorHandler function. The only requirement
0000000000000000000000000000000000000000;;	// is that the error handler function must exit after handling the error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   properties.ErrorHandler = func(err error) {
0000000000000000000000000000000000000000;;	//	     fmt.Println(err)
0000000000000000000000000000000000000000;;	//       os.Exit(1)
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   # Will write to stdout and then exit
0000000000000000000000000000000000000000;;	//   p := properties.MustLoadFile("config.properties")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Properties can also be loaded into a struct via the `Decode`
0000000000000000000000000000000000000000;;	// method, e.g.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   type S struct {
0000000000000000000000000000000000000000;;	//       A string        `properties:"a,default=foo"`
0000000000000000000000000000000000000000;;	//       D time.Duration `properties:"timeout,default=5s"`
0000000000000000000000000000000000000000;;	//       E time.Time     `properties:"expires,layout=2006-01-02,default=2015-01-01"`
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See `Decode()` method for the full documentation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following documents provide a description of the properties
0000000000000000000000000000000000000000;;	// file format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://en.wikipedia.org/wiki/.properties
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// http://docs.oracle.com/javase/7/docs/api/java/util/Properties.html#load%28java.io.Reader%29
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package properties
