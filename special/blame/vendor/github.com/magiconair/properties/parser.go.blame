0000000000000000000000000000000000000000;;	// Copyright 2016 Frank Schroeder. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package properties
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parser struct {
0000000000000000000000000000000000000000;;		lex *lexer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parse(input string) (properties *Properties, err error) {
0000000000000000000000000000000000000000;;		p := &parser{lex: lex(input)}
0000000000000000000000000000000000000000;;		defer p.recover(&err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		properties = NewProperties()
0000000000000000000000000000000000000000;;		key := ""
0000000000000000000000000000000000000000;;		comments := []string{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			token := p.expectOneOf(itemComment, itemKey, itemEOF)
0000000000000000000000000000000000000000;;			switch token.typ {
0000000000000000000000000000000000000000;;			case itemEOF:
0000000000000000000000000000000000000000;;				goto done
0000000000000000000000000000000000000000;;			case itemComment:
0000000000000000000000000000000000000000;;				comments = append(comments, token.val)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case itemKey:
0000000000000000000000000000000000000000;;				key = token.val
0000000000000000000000000000000000000000;;				if _, ok := properties.m[key]; !ok {
0000000000000000000000000000000000000000;;					properties.k = append(properties.k, key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			token = p.expectOneOf(itemValue, itemEOF)
0000000000000000000000000000000000000000;;			if len(comments) > 0 {
0000000000000000000000000000000000000000;;				properties.c[key] = comments
0000000000000000000000000000000000000000;;				comments = []string{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch token.typ {
0000000000000000000000000000000000000000;;			case itemEOF:
0000000000000000000000000000000000000000;;				properties.m[key] = ""
0000000000000000000000000000000000000000;;				goto done
0000000000000000000000000000000000000000;;			case itemValue:
0000000000000000000000000000000000000000;;				properties.m[key] = token.val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	done:
0000000000000000000000000000000000000000;;		return properties, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) errorf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		format = fmt.Sprintf("properties: Line %d: %s", p.lex.lineNumber(), format)
0000000000000000000000000000000000000000;;		panic(fmt.Errorf(format, args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) expect(expected itemType) (token item) {
0000000000000000000000000000000000000000;;		token = p.lex.nextItem()
0000000000000000000000000000000000000000;;		if token.typ != expected {
0000000000000000000000000000000000000000;;			p.unexpected(token)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) expectOneOf(expected ...itemType) (token item) {
0000000000000000000000000000000000000000;;		token = p.lex.nextItem()
0000000000000000000000000000000000000000;;		for _, v := range expected {
0000000000000000000000000000000000000000;;			if token.typ == v {
0000000000000000000000000000000000000000;;				return token
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.unexpected(token)
0000000000000000000000000000000000000000;;		panic("unexpected token")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) unexpected(token item) {
0000000000000000000000000000000000000000;;		p.errorf(token.String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recover is the handler that turns panics into returns from the top level of Parse.
0000000000000000000000000000000000000000;;	func (p *parser) recover(errp *error) {
0000000000000000000000000000000000000000;;		e := recover()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			if _, ok := e.(runtime.Error); ok {
0000000000000000000000000000000000000000;;				panic(e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*errp = e.(error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
