0000000000000000000000000000000000000000;;	// Copyright 2016 Frank Schroeder. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package properties
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode assigns property values to exported fields of a struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Decode traverses v recursively and returns an error if a value cannot be
0000000000000000000000000000000000000000;;	// converted to the field type or a required value is missing for a field.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following type dependent decodings are used:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// String, boolean, numeric fields have the value of the property key assigned.
0000000000000000000000000000000000000000;;	// The property key name is the name of the field. A different key and a default
0000000000000000000000000000000000000000;;	// value can be set in the field's tag. Fields without default value are
0000000000000000000000000000000000000000;;	// required. If the value cannot be converted to the field type an error is
0000000000000000000000000000000000000000;;	// returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// time.Duration fields have the result of time.ParseDuration() assigned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// time.Time fields have the vaule of time.Parse() assigned. The default layout
0000000000000000000000000000000000000000;;	// is time.RFC3339 but can be set in the field's tag.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Arrays and slices of string, boolean, numeric, time.Duration and time.Time
0000000000000000000000000000000000000000;;	// fields have the value interpreted as a comma separated list of values. The
0000000000000000000000000000000000000000;;	// individual values are trimmed of whitespace and empty values are ignored. A
0000000000000000000000000000000000000000;;	// default value can be provided as a semicolon separated list in the field's
0000000000000000000000000000000000000000;;	// tag.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Struct fields are decoded recursively using the field name plus "." as
0000000000000000000000000000000000000000;;	// prefix. The prefix (without dot) can be overridden in the field's tag.
0000000000000000000000000000000000000000;;	// Default values are not supported in the field's tag. Specify them on the
0000000000000000000000000000000000000000;;	// fields of the inner struct instead.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Map fields must have a key of type string and are decoded recursively by
0000000000000000000000000000000000000000;;	// using the field's name plus ".' as prefix and the next element of the key
0000000000000000000000000000000000000000;;	// name as map key. The prefix (without dot) can be overridden in the field's
0000000000000000000000000000000000000000;;	// tag. Default values are not supported.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Examples:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is ignored.
0000000000000000000000000000000000000000;;	//     Field int `properties:"-"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is assigned value of 'Field'.
0000000000000000000000000000000000000000;;	//     Field int
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is assigned value of 'myName'.
0000000000000000000000000000000000000000;;	//     Field int `properties:"myName"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is assigned value of key 'myName' and has a default
0000000000000000000000000000000000000000;;	//     // value 15 if the key does not exist.
0000000000000000000000000000000000000000;;	//     Field int `properties:"myName,default=15"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is assigned value of key 'Field' and has a default
0000000000000000000000000000000000000000;;	//     // value 15 if the key does not exist.
0000000000000000000000000000000000000000;;	//     Field int `properties:",default=15"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is assigned value of key 'date' and the date
0000000000000000000000000000000000000000;;	//     // is in format 2006-01-02
0000000000000000000000000000000000000000;;	//     Field time.Time `properties:"date,layout=2006-01-02"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is assigned the non-empty and whitespace trimmed
0000000000000000000000000000000000000000;;	//     // values of key 'Field' split by commas.
0000000000000000000000000000000000000000;;	//     Field []string
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is assigned the non-empty and whitespace trimmed
0000000000000000000000000000000000000000;;	//     // values of key 'Field' split by commas and has a default
0000000000000000000000000000000000000000;;	//     // value ["a", "b", "c"] if the key does not exist.
0000000000000000000000000000000000000000;;	//     Field []string `properties:",default=a;b;c"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is decoded recursively with "Field." as key prefix.
0000000000000000000000000000000000000000;;	//     Field SomeStruct
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is decoded recursively with "myName." as key prefix.
0000000000000000000000000000000000000000;;	//     Field SomeStruct `properties:"myName"`
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is decoded recursively with "Field." as key prefix
0000000000000000000000000000000000000000;;	//     // and the next dotted element of the key as map key.
0000000000000000000000000000000000000000;;	//     Field map[string]string
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // Field is decoded recursively with "myName." as key prefix
0000000000000000000000000000000000000000;;	//     // and the next dotted element of the key as map key.
0000000000000000000000000000000000000000;;	//     Field map[string]string `properties:"myName"`
0000000000000000000000000000000000000000;;	func (p *Properties) Decode(x interface{}) error {
0000000000000000000000000000000000000000;;		t, v := reflect.TypeOf(x), reflect.ValueOf(x)
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Ptr || v.Elem().Type().Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return fmt.Errorf("not a pointer to struct: %s", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := dec(p, "", nil, nil, v); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dec(p *Properties, key string, def *string, opts map[string]string, v reflect.Value) error {
0000000000000000000000000000000000000000;;		t := v.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// value returns the property value for key or the default if provided.
0000000000000000000000000000000000000000;;		value := func() (string, error) {
0000000000000000000000000000000000000000;;			if val, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;				return val, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if def != nil {
0000000000000000000000000000000000000000;;				return *def, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("missing required key %s", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// conv converts a string to a value of the given type.
0000000000000000000000000000000000000000;;		conv := func(s string, t reflect.Type) (val reflect.Value, err error) {
0000000000000000000000000000000000000000;;			var v interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case isDuration(t):
0000000000000000000000000000000000000000;;				v, err = time.ParseDuration(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case isTime(t):
0000000000000000000000000000000000000000;;				layout := opts["layout"]
0000000000000000000000000000000000000000;;				if layout == "" {
0000000000000000000000000000000000000000;;					layout = time.RFC3339
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v, err = time.Parse(layout, s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case isBool(t):
0000000000000000000000000000000000000000;;				v, err = boolVal(s), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case isString(t):
0000000000000000000000000000000000000000;;				v, err = s, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case isFloat(t):
0000000000000000000000000000000000000000;;				v, err = strconv.ParseFloat(s, 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case isInt(t):
0000000000000000000000000000000000000000;;				v, err = strconv.ParseInt(s, 10, 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case isUint(t):
0000000000000000000000000000000000000000;;				v, err = strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return reflect.Zero(t), fmt.Errorf("unsupported type %s", t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return reflect.Zero(t), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return reflect.ValueOf(v).Convert(t), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keydef returns the property key and the default value based on the
0000000000000000000000000000000000000000;;		// name of the struct field and the options in the tag.
0000000000000000000000000000000000000000;;		keydef := func(f reflect.StructField) (string, *string, map[string]string) {
0000000000000000000000000000000000000000;;			key, opts := parseTag(f.Tag.Get("properties"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var def *string
0000000000000000000000000000000000000000;;			if d, ok := opts["default"]; ok {
0000000000000000000000000000000000000000;;				def = &d
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if key != "" {
0000000000000000000000000000000000000000;;				return key, def, opts
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return f.Name, def, opts
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isDuration(t) || isTime(t) || isBool(t) || isString(t) || isFloat(t) || isInt(t) || isUint(t):
0000000000000000000000000000000000000000;;			s, err := value()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val, err := conv(s, t)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(val)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case isPtr(t):
0000000000000000000000000000000000000000;;			return dec(p, key, def, opts, v.Elem())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case isStruct(t):
0000000000000000000000000000000000000000;;			for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;				fv := v.Field(i)
0000000000000000000000000000000000000000;;				fk, def, opts := keydef(t.Field(i))
0000000000000000000000000000000000000000;;				if !fv.CanSet() {
0000000000000000000000000000000000000000;;					return fmt.Errorf("cannot set %s", t.Field(i).Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if fk == "-" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if key != "" {
0000000000000000000000000000000000000000;;					fk = key + "." + fk
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err := dec(p, fk, def, opts, fv); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case isArray(t):
0000000000000000000000000000000000000000;;			val, err := value()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			vals := split(val, ";")
0000000000000000000000000000000000000000;;			a := reflect.MakeSlice(t, 0, len(vals))
0000000000000000000000000000000000000000;;			for _, s := range vals {
0000000000000000000000000000000000000000;;				val, err := conv(s, t.Elem())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				a = reflect.Append(a, val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(a)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case isMap(t):
0000000000000000000000000000000000000000;;			valT := t.Elem()
0000000000000000000000000000000000000000;;			m := reflect.MakeMap(t)
0000000000000000000000000000000000000000;;			for postfix, _ := range p.FilterStripPrefix(key + ".").m {
0000000000000000000000000000000000000000;;				pp := strings.SplitN(postfix, ".", 2)
0000000000000000000000000000000000000000;;				mk, mv := pp[0], reflect.New(valT)
0000000000000000000000000000000000000000;;				if err := dec(p, key+"."+mk, nil, nil, mv); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m.SetMapIndex(reflect.ValueOf(mk), mv.Elem())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(m)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported type %s", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// split splits a string on sep, trims whitespace of elements
0000000000000000000000000000000000000000;;	// and omits empty elements
0000000000000000000000000000000000000000;;	func split(s string, sep string) []string {
0000000000000000000000000000000000000000;;		var a []string
0000000000000000000000000000000000000000;;		for _, v := range strings.Split(s, sep) {
0000000000000000000000000000000000000000;;			if v = strings.TrimSpace(v); v != "" {
0000000000000000000000000000000000000000;;				a = append(a, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseTag parses a "key,k=v,k=v,..."
0000000000000000000000000000000000000000;;	func parseTag(tag string) (key string, opts map[string]string) {
0000000000000000000000000000000000000000;;		opts = map[string]string{}
0000000000000000000000000000000000000000;;		for i, s := range strings.Split(tag, ",") {
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				key = s
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pp := strings.SplitN(s, "=", 2)
0000000000000000000000000000000000000000;;			if len(pp) == 1 {
0000000000000000000000000000000000000000;;				opts[pp[0]] = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				opts[pp[0]] = pp[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key, opts
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isArray(t reflect.Type) bool    { return t.Kind() == reflect.Array || t.Kind() == reflect.Slice }
0000000000000000000000000000000000000000;;	func isBool(t reflect.Type) bool     { return t.Kind() == reflect.Bool }
0000000000000000000000000000000000000000;;	func isDuration(t reflect.Type) bool { return t == reflect.TypeOf(time.Second) }
0000000000000000000000000000000000000000;;	func isMap(t reflect.Type) bool      { return t.Kind() == reflect.Map }
0000000000000000000000000000000000000000;;	func isNumeric(t reflect.Type) bool  { return isInt(t) || isUint(t) || isFloat(t) }
0000000000000000000000000000000000000000;;	func isPtr(t reflect.Type) bool      { return t.Kind() == reflect.Ptr }
0000000000000000000000000000000000000000;;	func isString(t reflect.Type) bool   { return t.Kind() == reflect.String }
0000000000000000000000000000000000000000;;	func isStruct(t reflect.Type) bool   { return t.Kind() == reflect.Struct }
0000000000000000000000000000000000000000;;	func isTime(t reflect.Type) bool     { return t == reflect.TypeOf(time.Time{}) }
0000000000000000000000000000000000000000;;	func isFloat(t reflect.Type) bool {
0000000000000000000000000000000000000000;;		return t.Kind() == reflect.Float32 || t.Kind() == reflect.Float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func isInt(t reflect.Type) bool {
0000000000000000000000000000000000000000;;		return t.Kind() == reflect.Int || t.Kind() == reflect.Int8 || t.Kind() == reflect.Int16 || t.Kind() == reflect.Int32 || t.Kind() == reflect.Int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func isUint(t reflect.Type) bool {
0000000000000000000000000000000000000000;;		return t.Kind() == reflect.Uint || t.Kind() == reflect.Uint8 || t.Kind() == reflect.Uint16 || t.Kind() == reflect.Uint32 || t.Kind() == reflect.Uint64
0000000000000000000000000000000000000000;;	}
