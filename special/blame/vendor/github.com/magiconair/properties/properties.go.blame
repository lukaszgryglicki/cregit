0000000000000000000000000000000000000000;;	// Copyright 2016 Frank Schroeder. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package properties
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BUG(frank): Set() does not check for invalid unicode literals since this is currently handled by the lexer.
0000000000000000000000000000000000000000;;	// BUG(frank): Write() does not allow to configure the newline character. Therefore, on Windows LF is used.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorHandlerFunc defines the type of function which handles failures
0000000000000000000000000000000000000000;;	// of the MustXXX() functions. An error handler function must exit
0000000000000000000000000000000000000000;;	// the application after handling the error.
0000000000000000000000000000000000000000;;	type ErrorHandlerFunc func(error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorHandler is the function which handles failures of the MustXXX()
0000000000000000000000000000000000000000;;	// functions. The default is LogFatalHandler.
0000000000000000000000000000000000000000;;	var ErrorHandler ErrorHandlerFunc = LogFatalHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LogHandlerFunc func(fmt string, args ...interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var LogPrintf LogHandlerFunc = log.Printf
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogFatalHandler handles the error by logging a fatal error and exiting.
0000000000000000000000000000000000000000;;	func LogFatalHandler(err error) {
0000000000000000000000000000000000000000;;		log.Fatal(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PanicHandler handles the error by panicking.
0000000000000000000000000000000000000000;;	func PanicHandler(err error) {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// -----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Properties contains the key/value pairs from the properties input.
0000000000000000000000000000000000000000;;	// All values are stored in unexpanded form and are expanded at runtime
0000000000000000000000000000000000000000;;	type Properties struct {
0000000000000000000000000000000000000000;;		// Pre-/Postfix for property expansion.
0000000000000000000000000000000000000000;;		Prefix  string
0000000000000000000000000000000000000000;;		Postfix string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DisableExpansion controls the expansion of properties on Get()
0000000000000000000000000000000000000000;;		// and the check for circular references on Set(). When set to
0000000000000000000000000000000000000000;;		// true Properties behaves like a simple key/value store and does
0000000000000000000000000000000000000000;;		// not check for circular references on Get() or on Set().
0000000000000000000000000000000000000000;;		DisableExpansion bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stores the key/value pairs
0000000000000000000000000000000000000000;;		m map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stores the comments per key.
0000000000000000000000000000000000000000;;		c map[string][]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stores the keys in order of appearance.
0000000000000000000000000000000000000000;;		k []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewProperties creates a new Properties struct with the default
0000000000000000000000000000000000000000;;	// configuration for "${key}" expressions.
0000000000000000000000000000000000000000;;	func NewProperties() *Properties {
0000000000000000000000000000000000000000;;		return &Properties{
0000000000000000000000000000000000000000;;			Prefix:  "${",
0000000000000000000000000000000000000000;;			Postfix: "}",
0000000000000000000000000000000000000000;;			m:       map[string]string{},
0000000000000000000000000000000000000000;;			c:       map[string][]string{},
0000000000000000000000000000000000000000;;			k:       []string{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns the expanded value for the given key if exists.
0000000000000000000000000000000000000000;;	// Otherwise, ok is false.
0000000000000000000000000000000000000000;;	func (p *Properties) Get(key string) (value string, ok bool) {
0000000000000000000000000000000000000000;;		v, ok := p.m[key]
0000000000000000000000000000000000000000;;		if p.DisableExpansion {
0000000000000000000000000000000000000000;;			return v, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expanded, err := p.expand(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we guarantee that the expanded value is free of
0000000000000000000000000000000000000000;;		// circular references and malformed expressions
0000000000000000000000000000000000000000;;		// so we panic if we still get an error here.
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(fmt.Errorf("%s in %q", err, key+" = "+v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expanded, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGet returns the expanded value for the given key if exists.
0000000000000000000000000000000000000000;;	// Otherwise, it panics.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGet(key string) string {
0000000000000000000000000000000000000000;;		if v, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ErrorHandler(invalidKeyError(key))
0000000000000000000000000000000000000000;;		panic("ErrorHandler should exit")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClearComments removes the comments for all keys.
0000000000000000000000000000000000000000;;	func (p *Properties) ClearComments() {
0000000000000000000000000000000000000000;;		p.c = map[string][]string{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetComment returns the last comment before the given key or an empty string.
0000000000000000000000000000000000000000;;	func (p *Properties) GetComment(key string) string {
0000000000000000000000000000000000000000;;		comments, ok := p.c[key]
0000000000000000000000000000000000000000;;		if !ok || len(comments) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return comments[len(comments)-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetComments returns all comments that appeared before the given key or nil.
0000000000000000000000000000000000000000;;	func (p *Properties) GetComments(key string) []string {
0000000000000000000000000000000000000000;;		if comments, ok := p.c[key]; ok {
0000000000000000000000000000000000000000;;			return comments
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetComment sets the comment for the key.
0000000000000000000000000000000000000000;;	func (p *Properties) SetComment(key, comment string) {
0000000000000000000000000000000000000000;;		p.c[key] = []string{comment}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetComments sets the comments for the key. If the comments are nil then
0000000000000000000000000000000000000000;;	// all comments for this key are deleted.
0000000000000000000000000000000000000000;;	func (p *Properties) SetComments(key string, comments []string) {
0000000000000000000000000000000000000000;;		if comments == nil {
0000000000000000000000000000000000000000;;			delete(p.c, key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.c[key] = comments
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBool checks if the expanded value is one of '1', 'yes',
0000000000000000000000000000000000000000;;	// 'true' or 'on' if the key exists. The comparison is case-insensitive.
0000000000000000000000000000000000000000;;	// If the key does not exist the default value is returned.
0000000000000000000000000000000000000000;;	func (p *Properties) GetBool(key string, def bool) bool {
0000000000000000000000000000000000000000;;		v, err := p.getBool(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetBool checks if the expanded value is one of '1', 'yes',
0000000000000000000000000000000000000000;;	// 'true' or 'on' if the key exists. The comparison is case-insensitive.
0000000000000000000000000000000000000000;;	// If the key does not exist the function panics.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetBool(key string) bool {
0000000000000000000000000000000000000000;;		v, err := p.getBool(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Properties) getBool(key string) (value bool, err error) {
0000000000000000000000000000000000000000;;		if v, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;			return boolVal(v), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, invalidKeyError(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func boolVal(v string) bool {
0000000000000000000000000000000000000000;;		v = strings.ToLower(v)
0000000000000000000000000000000000000000;;		return v == "1" || v == "true" || v == "yes" || v == "on"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDuration parses the expanded value as an time.Duration (in ns) if the
0000000000000000000000000000000000000000;;	// key exists. If key does not exist or the value cannot be parsed the default
0000000000000000000000000000000000000000;;	// value is returned. In almost all cases you want to use GetParsedDuration().
0000000000000000000000000000000000000000;;	func (p *Properties) GetDuration(key string, def time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		v, err := p.getInt64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Duration(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetDuration parses the expanded value as an time.Duration (in ns) if
0000000000000000000000000000000000000000;;	// the key exists. If key does not exist or the value cannot be parsed the
0000000000000000000000000000000000000000;;	// function panics. In almost all cases you want to use MustGetParsedDuration().
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetDuration(key string) time.Duration {
0000000000000000000000000000000000000000;;		v, err := p.getInt64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return time.Duration(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetParsedDuration parses the expanded value with time.ParseDuration() if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the default
0000000000000000000000000000000000000000;;	// value is returned.
0000000000000000000000000000000000000000;;	func (p *Properties) GetParsedDuration(key string, def time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		s, ok := p.Get(key)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := time.ParseDuration(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetParsedDuration parses the expanded value with time.ParseDuration() if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the function panics.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetParsedDuration(key string) time.Duration {
0000000000000000000000000000000000000000;;		s, ok := p.Get(key)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			ErrorHandler(invalidKeyError(key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v, err := time.ParseDuration(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFloat64 parses the expanded value as a float64 if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the default
0000000000000000000000000000000000000000;;	// value is returned.
0000000000000000000000000000000000000000;;	func (p *Properties) GetFloat64(key string, def float64) float64 {
0000000000000000000000000000000000000000;;		v, err := p.getFloat64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetFloat64 parses the expanded value as a float64 if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the function panics.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetFloat64(key string) float64 {
0000000000000000000000000000000000000000;;		v, err := p.getFloat64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Properties) getFloat64(key string) (value float64, err error) {
0000000000000000000000000000000000000000;;		if v, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;			value, err = strconv.ParseFloat(v, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, invalidKeyError(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetInt parses the expanded value as an int if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the default
0000000000000000000000000000000000000000;;	// value is returned. If the value does not fit into an int the
0000000000000000000000000000000000000000;;	// function panics with an out of range error.
0000000000000000000000000000000000000000;;	func (p *Properties) GetInt(key string, def int) int {
0000000000000000000000000000000000000000;;		v, err := p.getInt64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return intRangeCheck(key, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetInt parses the expanded value as an int if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the function panics.
0000000000000000000000000000000000000000;;	// If the value does not fit into an int the function panics with
0000000000000000000000000000000000000000;;	// an out of range error.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetInt(key string) int {
0000000000000000000000000000000000000000;;		v, err := p.getInt64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return intRangeCheck(key, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetInt64 parses the expanded value as an int64 if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the default
0000000000000000000000000000000000000000;;	// value is returned.
0000000000000000000000000000000000000000;;	func (p *Properties) GetInt64(key string, def int64) int64 {
0000000000000000000000000000000000000000;;		v, err := p.getInt64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetInt64 parses the expanded value as an int if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the function panics.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetInt64(key string) int64 {
0000000000000000000000000000000000000000;;		v, err := p.getInt64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Properties) getInt64(key string) (value int64, err error) {
0000000000000000000000000000000000000000;;		if v, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;			value, err = strconv.ParseInt(v, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, invalidKeyError(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUint parses the expanded value as an uint if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the default
0000000000000000000000000000000000000000;;	// value is returned. If the value does not fit into an int the
0000000000000000000000000000000000000000;;	// function panics with an out of range error.
0000000000000000000000000000000000000000;;	func (p *Properties) GetUint(key string, def uint) uint {
0000000000000000000000000000000000000000;;		v, err := p.getUint64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uintRangeCheck(key, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetUint parses the expanded value as an int if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the function panics.
0000000000000000000000000000000000000000;;	// If the value does not fit into an int the function panics with
0000000000000000000000000000000000000000;;	// an out of range error.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetUint(key string) uint {
0000000000000000000000000000000000000000;;		v, err := p.getUint64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uintRangeCheck(key, v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUint64 parses the expanded value as an uint64 if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the default
0000000000000000000000000000000000000000;;	// value is returned.
0000000000000000000000000000000000000000;;	func (p *Properties) GetUint64(key string, def uint64) uint64 {
0000000000000000000000000000000000000000;;		v, err := p.getUint64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetUint64 parses the expanded value as an int if the key exists.
0000000000000000000000000000000000000000;;	// If key does not exist or the value cannot be parsed the function panics.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetUint64(key string) uint64 {
0000000000000000000000000000000000000000;;		v, err := p.getUint64(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Properties) getUint64(key string) (value uint64, err error) {
0000000000000000000000000000000000000000;;		if v, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;			value, err = strconv.ParseUint(v, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return value, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, invalidKeyError(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetString returns the expanded value for the given key if exists or
0000000000000000000000000000000000000000;;	// the default value otherwise.
0000000000000000000000000000000000000000;;	func (p *Properties) GetString(key, def string) string {
0000000000000000000000000000000000000000;;		if v, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return def
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustGetString returns the expanded value for the given key if exists or
0000000000000000000000000000000000000000;;	// panics otherwise.
0000000000000000000000000000000000000000;;	func (p *Properties) MustGetString(key string) string {
0000000000000000000000000000000000000000;;		if v, ok := p.Get(key); ok {
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ErrorHandler(invalidKeyError(key))
0000000000000000000000000000000000000000;;		panic("ErrorHandler should exit")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter returns a new properties object which contains all properties
0000000000000000000000000000000000000000;;	// for which the key matches the pattern.
0000000000000000000000000000000000000000;;	func (p *Properties) Filter(pattern string) (*Properties, error) {
0000000000000000000000000000000000000000;;		re, err := regexp.Compile(pattern)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.FilterRegexp(re), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterRegexp returns a new properties object which contains all properties
0000000000000000000000000000000000000000;;	// for which the key matches the regular expression.
0000000000000000000000000000000000000000;;	func (p *Properties) FilterRegexp(re *regexp.Regexp) *Properties {
0000000000000000000000000000000000000000;;		pp := NewProperties()
0000000000000000000000000000000000000000;;		for _, k := range p.k {
0000000000000000000000000000000000000000;;			if re.MatchString(k) {
0000000000000000000000000000000000000000;;				pp.Set(k, p.m[k])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterPrefix returns a new properties object with a subset of all keys
0000000000000000000000000000000000000000;;	// with the given prefix.
0000000000000000000000000000000000000000;;	func (p *Properties) FilterPrefix(prefix string) *Properties {
0000000000000000000000000000000000000000;;		pp := NewProperties()
0000000000000000000000000000000000000000;;		for _, k := range p.k {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(k, prefix) {
0000000000000000000000000000000000000000;;				pp.Set(k, p.m[k])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FilterStripPrefix returns a new properties object with a subset of all keys
0000000000000000000000000000000000000000;;	// with the given prefix and the prefix removed from the keys.
0000000000000000000000000000000000000000;;	func (p *Properties) FilterStripPrefix(prefix string) *Properties {
0000000000000000000000000000000000000000;;		pp := NewProperties()
0000000000000000000000000000000000000000;;		n := len(prefix)
0000000000000000000000000000000000000000;;		for _, k := range p.k {
0000000000000000000000000000000000000000;;			if len(k) > len(prefix) && strings.HasPrefix(k, prefix) {
0000000000000000000000000000000000000000;;				pp.Set(k[n:], p.m[k])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of keys.
0000000000000000000000000000000000000000;;	func (p *Properties) Len() int {
0000000000000000000000000000000000000000;;		return len(p.m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns all keys in the same order as in the input.
0000000000000000000000000000000000000000;;	func (p *Properties) Keys() []string {
0000000000000000000000000000000000000000;;		keys := make([]string, len(p.k))
0000000000000000000000000000000000000000;;		for i, k := range p.k {
0000000000000000000000000000000000000000;;			keys[i] = k
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets the property key to the corresponding value.
0000000000000000000000000000000000000000;;	// If a value for key existed before then ok is true and prev
0000000000000000000000000000000000000000;;	// contains the previous value. If the value contains a
0000000000000000000000000000000000000000;;	// circular reference or a malformed expression then
0000000000000000000000000000000000000000;;	// an error is returned.
0000000000000000000000000000000000000000;;	// An empty key is silently ignored.
0000000000000000000000000000000000000000;;	func (p *Properties) Set(key, value string) (prev string, ok bool, err error) {
0000000000000000000000000000000000000000;;		if key == "" {
0000000000000000000000000000000000000000;;			return "", false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if expansion is disabled we allow circular references
0000000000000000000000000000000000000000;;		if p.DisableExpansion {
0000000000000000000000000000000000000000;;			prev, ok = p.Get(key)
0000000000000000000000000000000000000000;;			p.m[key] = value
0000000000000000000000000000000000000000;;			return prev, ok, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// to check for a circular reference we temporarily need
0000000000000000000000000000000000000000;;		// to set the new value. If there is an error then revert
0000000000000000000000000000000000000000;;		// to the previous state. Only if all tests are successful
0000000000000000000000000000000000000000;;		// then we add the key to the p.k list.
0000000000000000000000000000000000000000;;		prev, ok = p.Get(key)
0000000000000000000000000000000000000000;;		p.m[key] = value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// now check for a circular reference
0000000000000000000000000000000000000000;;		_, err = p.expand(value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// revert to the previous state
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				p.m[key] = prev
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				delete(p.m, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return "", false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			p.k = append(p.k, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return prev, ok, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustSet sets the property key to the corresponding value.
0000000000000000000000000000000000000000;;	// If a value for key existed before then ok is true and prev
0000000000000000000000000000000000000000;;	// contains the previous value. An empty key is silently ignored.
0000000000000000000000000000000000000000;;	func (p *Properties) MustSet(key, value string) (prev string, ok bool) {
0000000000000000000000000000000000000000;;		prev, ok, err := p.Set(key, value)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ErrorHandler(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return prev, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a string of all expanded 'key = value' pairs.
0000000000000000000000000000000000000000;;	func (p *Properties) String() string {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for _, key := range p.k {
0000000000000000000000000000000000000000;;			value, _ := p.Get(key)
0000000000000000000000000000000000000000;;			s = fmt.Sprintf("%s%s = %s\n", s, key, value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes all unexpanded 'key = value' pairs to the given writer.
0000000000000000000000000000000000000000;;	// Write returns the number of bytes written and any write error encountered.
0000000000000000000000000000000000000000;;	func (p *Properties) Write(w io.Writer, enc Encoding) (n int, err error) {
0000000000000000000000000000000000000000;;		return p.WriteComment(w, "", enc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteComment writes all unexpanced 'key = value' pairs to the given writer.
0000000000000000000000000000000000000000;;	// If prefix is not empty then comments are written with a blank line and the
0000000000000000000000000000000000000000;;	// given prefix. The prefix should be either "# " or "! " to be compatible with
0000000000000000000000000000000000000000;;	// the properties file format. Otherwise, the properties parser will not be
0000000000000000000000000000000000000000;;	// able to read the file back in. It returns the number of bytes written and
0000000000000000000000000000000000000000;;	// any write error encountered.
0000000000000000000000000000000000000000;;	func (p *Properties) WriteComment(w io.Writer, prefix string, enc Encoding) (n int, err error) {
0000000000000000000000000000000000000000;;		var x int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, key := range p.k {
0000000000000000000000000000000000000000;;			value := p.m[key]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if prefix != "" {
0000000000000000000000000000000000000000;;				if comments, ok := p.c[key]; ok {
0000000000000000000000000000000000000000;;					// don't print comments if they are all empty
0000000000000000000000000000000000000000;;					allEmpty := true
0000000000000000000000000000000000000000;;					for _, c := range comments {
0000000000000000000000000000000000000000;;						if c != "" {
0000000000000000000000000000000000000000;;							allEmpty = false
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !allEmpty {
0000000000000000000000000000000000000000;;						// add a blank line between entries but not at the top
0000000000000000000000000000000000000000;;						if len(comments) > 0 && n > 0 {
0000000000000000000000000000000000000000;;							x, err = fmt.Fprintln(w)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							n += x
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						for _, c := range comments {
0000000000000000000000000000000000000000;;							x, err = fmt.Fprintf(w, "%s%s\n", prefix, encode(c, "", enc))
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								return
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							n += x
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			x, err = fmt.Fprintf(w, "%s = %s\n", encode(key, " :", enc), encode(value, "", enc))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += x
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes the key and its comments.
0000000000000000000000000000000000000000;;	func (p *Properties) Delete(key string) {
0000000000000000000000000000000000000000;;		delete(p.m, key)
0000000000000000000000000000000000000000;;		delete(p.c, key)
0000000000000000000000000000000000000000;;		newKeys := []string{}
0000000000000000000000000000000000000000;;		for _, k := range p.k {
0000000000000000000000000000000000000000;;			if k != key {
0000000000000000000000000000000000000000;;				newKeys = append(newKeys, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.k = newKeys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge merges properties, comments and keys from other *Properties into p
0000000000000000000000000000000000000000;;	func (p *Properties) Merge(other *Properties) {
0000000000000000000000000000000000000000;;		for k,v := range other.m {
0000000000000000000000000000000000000000;;			p.m[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k,v := range other.c {
0000000000000000000000000000000000000000;;			p.c[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		outer:
0000000000000000000000000000000000000000;;		for _, otherKey := range other.k {
0000000000000000000000000000000000000000;;			for _, key := range p.k {
0000000000000000000000000000000000000000;;				if otherKey == key {
0000000000000000000000000000000000000000;;					continue outer
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.k = append(p.k, otherKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// check expands all values and returns an error if a circular reference or
0000000000000000000000000000000000000000;;	// a malformed expression was found.
0000000000000000000000000000000000000000;;	func (p *Properties) check() error {
0000000000000000000000000000000000000000;;		for _, value := range p.m {
0000000000000000000000000000000000000000;;			if _, err := p.expand(value); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Properties) expand(input string) (string, error) {
0000000000000000000000000000000000000000;;		// no pre/postfix -> nothing to expand
0000000000000000000000000000000000000000;;		if p.Prefix == "" && p.Postfix == "" {
0000000000000000000000000000000000000000;;			return input, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expand(input, make(map[string]bool), p.Prefix, p.Postfix, p.m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// expand recursively expands expressions of '(prefix)key(postfix)' to their corresponding values.
0000000000000000000000000000000000000000;;	// The function keeps track of the keys that were already expanded and stops if it
0000000000000000000000000000000000000000;;	// detects a circular reference or a malformed expression of the form '(prefix)key'.
0000000000000000000000000000000000000000;;	func expand(s string, keys map[string]bool, prefix, postfix string, values map[string]string) (string, error) {
0000000000000000000000000000000000000000;;		start := strings.Index(s, prefix)
0000000000000000000000000000000000000000;;		if start == -1 {
0000000000000000000000000000000000000000;;			return s, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyStart := start + len(prefix)
0000000000000000000000000000000000000000;;		keyLen := strings.Index(s[keyStart:], postfix)
0000000000000000000000000000000000000000;;		if keyLen == -1 {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("malformed expression")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end := keyStart + keyLen + len(postfix) - 1
0000000000000000000000000000000000000000;;		key := s[keyStart : keyStart+keyLen]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fmt.Printf("s:%q pp:%q start:%d end:%d keyStart:%d keyLen:%d key:%q\n", s, prefix + "..." + postfix, start, end, keyStart, keyLen, key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := keys[key]; ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("circular reference")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, ok := values[key]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			val = os.Getenv(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remember that we've seen the key
0000000000000000000000000000000000000000;;		keys[key] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return expand(s[:start]+val+s[end+1:], keys, prefix, postfix, values)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encode encodes a UTF-8 string to ISO-8859-1 and escapes some characters.
0000000000000000000000000000000000000000;;	func encode(s string, special string, enc Encoding) string {
0000000000000000000000000000000000000000;;		switch enc {
0000000000000000000000000000000000000000;;		case UTF8:
0000000000000000000000000000000000000000;;			return encodeUtf8(s, special)
0000000000000000000000000000000000000000;;		case ISO_8859_1:
0000000000000000000000000000000000000000;;			return encodeIso(s, special)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unsupported encoding %v", enc))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeUtf8(s string, special string) string {
0000000000000000000000000000000000000000;;		v := ""
0000000000000000000000000000000000000000;;		for pos := 0; pos < len(s); {
0000000000000000000000000000000000000000;;			r, w := utf8.DecodeRuneInString(s[pos:])
0000000000000000000000000000000000000000;;			pos += w
0000000000000000000000000000000000000000;;			v += escape(r, special)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeIso(s string, special string) string {
0000000000000000000000000000000000000000;;		var r rune
0000000000000000000000000000000000000000;;		var w int
0000000000000000000000000000000000000000;;		var v string
0000000000000000000000000000000000000000;;		for pos := 0; pos < len(s); {
0000000000000000000000000000000000000000;;			switch r, w = utf8.DecodeRuneInString(s[pos:]); {
0000000000000000000000000000000000000000;;			case r < 1<<8: // single byte rune -> escape special chars only
0000000000000000000000000000000000000000;;				v += escape(r, special)
0000000000000000000000000000000000000000;;			case r < 1<<16: // two byte rune -> unicode literal
0000000000000000000000000000000000000000;;				v += fmt.Sprintf("\\u%04x", r)
0000000000000000000000000000000000000000;;			default: // more than two bytes per rune -> can't encode
0000000000000000000000000000000000000000;;				v += "?"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pos += w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escape(r rune, special string) string {
0000000000000000000000000000000000000000;;		switch r {
0000000000000000000000000000000000000000;;		case '\f':
0000000000000000000000000000000000000000;;			return "\\f"
0000000000000000000000000000000000000000;;		case '\n':
0000000000000000000000000000000000000000;;			return "\\n"
0000000000000000000000000000000000000000;;		case '\r':
0000000000000000000000000000000000000000;;			return "\\r"
0000000000000000000000000000000000000000;;		case '\t':
0000000000000000000000000000000000000000;;			return "\\t"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if strings.ContainsRune(special, r) {
0000000000000000000000000000000000000000;;				return "\\" + string(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return string(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func invalidKeyError(key string) error {
0000000000000000000000000000000000000000;;		return fmt.Errorf("unknown property: %s", key)
0000000000000000000000000000000000000000;;	}
