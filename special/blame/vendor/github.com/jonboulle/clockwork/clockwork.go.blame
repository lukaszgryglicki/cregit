0000000000000000000000000000000000000000;;	package clockwork
d9a6899387940336fd1a655128b4b3486f75c7ee;Godeps/_workspace/src/github.com/jonboulle/clockwork/clockwork.go[Godeps/_workspace/src/github.com/jonboulle/clockwork/clockwork.go][vendor/github.com/jonboulle/clockwork/clockwork.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clock provides an interface that packages can use instead of directly
0000000000000000000000000000000000000000;;	// using the time module, so that chronology-related behavior can be tested
0000000000000000000000000000000000000000;;	type Clock interface {
0000000000000000000000000000000000000000;;		After(d time.Duration) <-chan time.Time
0000000000000000000000000000000000000000;;		Sleep(d time.Duration)
0000000000000000000000000000000000000000;;		Now() time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeClock provides an interface for a clock which can be
0000000000000000000000000000000000000000;;	// manually advanced through time
0000000000000000000000000000000000000000;;	type FakeClock interface {
0000000000000000000000000000000000000000;;		Clock
0000000000000000000000000000000000000000;;		// Advance advances the FakeClock to a new point in time, ensuring any existing
0000000000000000000000000000000000000000;;		// sleepers are notified appropriately before returning
0000000000000000000000000000000000000000;;		Advance(d time.Duration)
0000000000000000000000000000000000000000;;		// BlockUntil will block until the FakeClock has the given number of
0000000000000000000000000000000000000000;;		// sleepers (callers of Sleep or After)
0000000000000000000000000000000000000000;;		BlockUntil(n int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRealClock returns a Clock which simply delegates calls to the actual time
0000000000000000000000000000000000000000;;	// package; it should be used by packages in production.
0000000000000000000000000000000000000000;;	func NewRealClock() Clock {
0000000000000000000000000000000000000000;;		return &realClock{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFakeClock returns a FakeClock implementation which can be
0000000000000000000000000000000000000000;;	// manually advanced through time for testing.
0000000000000000000000000000000000000000;;	func NewFakeClock() FakeClock {
0000000000000000000000000000000000000000;;		return &fakeClock{
0000000000000000000000000000000000000000;;			l: sync.RWMutex{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realClock struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *realClock) After(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		return time.After(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *realClock) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		time.Sleep(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rc *realClock) Now() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fakeClock struct {
0000000000000000000000000000000000000000;;		sleepers []*sleeper
0000000000000000000000000000000000000000;;		blockers []*blocker
0000000000000000000000000000000000000000;;		time     time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sleeper represents a caller of After or Sleep
0000000000000000000000000000000000000000;;	type sleeper struct {
0000000000000000000000000000000000000000;;		until time.Time
0000000000000000000000000000000000000000;;		done  chan time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// blocker represents a caller of BlockUntil
0000000000000000000000000000000000000000;;	type blocker struct {
0000000000000000000000000000000000000000;;		count int
0000000000000000000000000000000000000000;;		ch    chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// After mimics time.After; it waits for the given duration to elapse on the
0000000000000000000000000000000000000000;;	// fakeClock, then sends the current time on the returned channel.
0000000000000000000000000000000000000000;;	func (fc *fakeClock) After(d time.Duration) <-chan time.Time {
0000000000000000000000000000000000000000;;		fc.l.Lock()
0000000000000000000000000000000000000000;;		defer fc.l.Unlock()
0000000000000000000000000000000000000000;;		now := fc.time
0000000000000000000000000000000000000000;;		done := make(chan time.Time, 1)
0000000000000000000000000000000000000000;;		if d.Nanoseconds() == 0 {
0000000000000000000000000000000000000000;;			// special case - trigger immediately
0000000000000000000000000000000000000000;;			done <- now
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// otherwise, add to the set of sleepers
0000000000000000000000000000000000000000;;			s := &sleeper{
0000000000000000000000000000000000000000;;				until: now.Add(d),
0000000000000000000000000000000000000000;;				done:  done,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fc.sleepers = append(fc.sleepers, s)
0000000000000000000000000000000000000000;;			// and notify any blockers
0000000000000000000000000000000000000000;;			fc.blockers = notifyBlockers(fc.blockers, len(fc.sleepers))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return done
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// notifyBlockers notifies all the blockers waiting until the
0000000000000000000000000000000000000000;;	// given number of sleepers are waiting on the fakeClock. It
0000000000000000000000000000000000000000;;	// returns an updated slice of blockers (i.e. those still waiting)
0000000000000000000000000000000000000000;;	func notifyBlockers(blockers []*blocker, count int) (newBlockers []*blocker) {
0000000000000000000000000000000000000000;;		for _, b := range blockers {
0000000000000000000000000000000000000000;;			if b.count == count {
0000000000000000000000000000000000000000;;				close(b.ch)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newBlockers = append(newBlockers, b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sleep blocks until the given duration has passed on the fakeClock
0000000000000000000000000000000000000000;;	func (fc *fakeClock) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		<-fc.After(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time returns the current time of the fakeClock
0000000000000000000000000000000000000000;;	func (fc *fakeClock) Now() time.Time {
0000000000000000000000000000000000000000;;		fc.l.Lock()
0000000000000000000000000000000000000000;;		defer fc.l.Unlock()
0000000000000000000000000000000000000000;;		return fc.time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Advance advances fakeClock to a new point in time, ensuring channels from any
0000000000000000000000000000000000000000;;	// previous invocations of After are notified appropriately before returning
0000000000000000000000000000000000000000;;	func (fc *fakeClock) Advance(d time.Duration) {
0000000000000000000000000000000000000000;;		fc.l.Lock()
0000000000000000000000000000000000000000;;		defer fc.l.Unlock()
0000000000000000000000000000000000000000;;		end := fc.time.Add(d)
0000000000000000000000000000000000000000;;		var newSleepers []*sleeper
0000000000000000000000000000000000000000;;		for _, s := range fc.sleepers {
0000000000000000000000000000000000000000;;			if end.Sub(s.until) >= 0 {
0000000000000000000000000000000000000000;;				s.done <- end
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newSleepers = append(newSleepers, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fc.sleepers = newSleepers
0000000000000000000000000000000000000000;;		fc.blockers = notifyBlockers(fc.blockers, len(fc.sleepers))
0000000000000000000000000000000000000000;;		fc.time = end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlockUntil will block until the fakeClock has the given number of sleepers
0000000000000000000000000000000000000000;;	// (callers of Sleep or After)
0000000000000000000000000000000000000000;;	func (fc *fakeClock) BlockUntil(n int) {
0000000000000000000000000000000000000000;;		fc.l.Lock()
0000000000000000000000000000000000000000;;		// Fast path: current number of sleepers is what we're looking for
0000000000000000000000000000000000000000;;		if len(fc.sleepers) == n {
0000000000000000000000000000000000000000;;			fc.l.Unlock()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Otherwise, set up a new blocker
0000000000000000000000000000000000000000;;		b := &blocker{
0000000000000000000000000000000000000000;;			count: n,
0000000000000000000000000000000000000000;;			ch:    make(chan struct{}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fc.blockers = append(fc.blockers, b)
0000000000000000000000000000000000000000;;		fc.l.Unlock()
0000000000000000000000000000000000000000;;		<-b.ch
0000000000000000000000000000000000000000;;	}
