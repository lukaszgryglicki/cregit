0000000000000000000000000000000000000000;;	// Copyright 2015 CNI authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
350b88069342129c4911863376c2eff9fa6f8b94;Godeps/_workspace/src/github.com/appc/cni/pkg/types/types.go[Godeps/_workspace/src/github.com/appc/cni/pkg/types/types.go][vendor/github.com/containernetworking/cni/pkg/types/types.go];	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// like net.IPNet but adds JSON marshalling and unmarshalling
0000000000000000000000000000000000000000;;	type IPNet net.IPNet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCIDR takes a string like "10.2.3.1/24" and
0000000000000000000000000000000000000000;;	// return IPNet with "10.2.3.1" and /24 mask
0000000000000000000000000000000000000000;;	func ParseCIDR(s string) (*net.IPNet, error) {
0000000000000000000000000000000000000000;;		ip, ipn, err := net.ParseCIDR(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ipn.IP = ip
0000000000000000000000000000000000000000;;		return ipn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n IPNet) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return json.Marshal((*net.IPNet)(&n).String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *IPNet) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmp, err := ParseCIDR(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*n = IPNet(*tmp)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetConf describes a network.
0000000000000000000000000000000000000000;;	type NetConf struct {
0000000000000000000000000000000000000000;;		CNIVersion string `json:"cniVersion,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Name         string          `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		Type         string          `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		Capabilities map[string]bool `json:"capabilities,omitempty"`
0000000000000000000000000000000000000000;;		IPAM         struct {
0000000000000000000000000000000000000000;;			Type string `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		} `json:"ipam,omitempty"`
0000000000000000000000000000000000000000;;		DNS DNS `json:"dns"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetConfList describes an ordered list of networks.
0000000000000000000000000000000000000000;;	type NetConfList struct {
0000000000000000000000000000000000000000;;		CNIVersion string `json:"cniVersion,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Name    string     `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		Plugins []*NetConf `json:"plugins,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ResultFactoryFunc func([]byte) (Result, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Result is an interface that provides the result of plugin execution
0000000000000000000000000000000000000000;;	type Result interface {
0000000000000000000000000000000000000000;;		// The highest CNI specification result verison the result supports
0000000000000000000000000000000000000000;;		// without having to convert
0000000000000000000000000000000000000000;;		Version() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns the result converted into the requested CNI specification
0000000000000000000000000000000000000000;;		// result version, or an error if conversion failed
0000000000000000000000000000000000000000;;		GetAsVersion(version string) (Result, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prints the result in JSON format to stdout
0000000000000000000000000000000000000000;;		Print() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns a JSON string representation of the result
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func PrintResult(result Result, version string) error {
0000000000000000000000000000000000000000;;		newResult, err := result.GetAsVersion(version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newResult.Print()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DNS contains values interesting for DNS resolvers
0000000000000000000000000000000000000000;;	type DNS struct {
0000000000000000000000000000000000000000;;		Nameservers []string `json:"nameservers,omitempty"`
0000000000000000000000000000000000000000;;		Domain      string   `json:"domain,omitempty"`
0000000000000000000000000000000000000000;;		Search      []string `json:"search,omitempty"`
0000000000000000000000000000000000000000;;		Options     []string `json:"options,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Route struct {
0000000000000000000000000000000000000000;;		Dst net.IPNet
0000000000000000000000000000000000000000;;		GW  net.IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Route) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%+v", *r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Well known error codes
0000000000000000000000000000000000000000;;	// see https://github.com/containernetworking/cni/blob/master/SPEC.md#well-known-error-codes
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ErrUnknown                uint = iota // 0
0000000000000000000000000000000000000000;;		ErrIncompatibleCNIVersion             // 1
0000000000000000000000000000000000000000;;		ErrUnsupportedField                   // 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Code    uint   `json:"code"`
0000000000000000000000000000000000000000;;		Msg     string `json:"msg"`
0000000000000000000000000000000000000000;;		Details string `json:"details,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Error) Error() string {
0000000000000000000000000000000000000000;;		return e.Msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Error) Print() error {
0000000000000000000000000000000000000000;;		return prettyPrint(e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// net.IPNet is not JSON (un)marshallable so this duality is needed
0000000000000000000000000000000000000000;;	// for our custom IPNet type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSON (un)marshallable types
0000000000000000000000000000000000000000;;	type route struct {
0000000000000000000000000000000000000000;;		Dst IPNet  `json:"dst"`
0000000000000000000000000000000000000000;;		GW  net.IP `json:"gw,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Route) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		rt := route{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &rt); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Dst = net.IPNet(rt.Dst)
0000000000000000000000000000000000000000;;		r.GW = rt.GW
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Route) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		rt := route{
0000000000000000000000000000000000000000;;			Dst: IPNet(r.Dst),
0000000000000000000000000000000000000000;;			GW:  r.GW,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prettyPrint(obj interface{}) error {
0000000000000000000000000000000000000000;;		data, err := json.MarshalIndent(obj, "", "    ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = os.Stdout.Write(data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotImplementedError is used to indicate that a method is not implemented for the given platform
0000000000000000000000000000000000000000;;	var NotImplementedError = errors.New("Not Implemented")
