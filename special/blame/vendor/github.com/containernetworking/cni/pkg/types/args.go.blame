0000000000000000000000000000000000000000;;	// Copyright 2015 CNI authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
900edf0545237db12cf362651d31490934637d69;;	
0000000000000000000000000000000000000000;;	package types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshallableBool typedef for builtin bool
0000000000000000000000000000000000000000;;	// because builtin type's methods can't be declared
0000000000000000000000000000000000000000;;	type UnmarshallableBool bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText implements the encoding.TextUnmarshaler interface.
0000000000000000000000000000000000000000;;	// Returns boolean true if the string is "1" or "[Tt]rue"
0000000000000000000000000000000000000000;;	// Returns boolean false if the string is "0" or "[Ff]alse"
0000000000000000000000000000000000000000;;	func (b *UnmarshallableBool) UnmarshalText(data []byte) error {
0000000000000000000000000000000000000000;;		s := strings.ToLower(string(data))
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case "1", "true":
0000000000000000000000000000000000000000;;			*b = true
0000000000000000000000000000000000000000;;		case "0", "false":
0000000000000000000000000000000000000000;;			*b = false
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("Boolean unmarshal error: invalid input %s", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshallableString typedef for builtin string
0000000000000000000000000000000000000000;;	type UnmarshallableString string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText implements the encoding.TextUnmarshaler interface.
0000000000000000000000000000000000000000;;	// Returns the string
0000000000000000000000000000000000000000;;	func (s *UnmarshallableString) UnmarshalText(data []byte) error {
0000000000000000000000000000000000000000;;		*s = UnmarshallableString(data)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CommonArgs contains the IgnoreUnknown argument
0000000000000000000000000000000000000000;;	// and must be embedded by all Arg structs
0000000000000000000000000000000000000000;;	type CommonArgs struct {
0000000000000000000000000000000000000000;;		IgnoreUnknown UnmarshallableBool `json:"ignoreunknown,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetKeyField is a helper function to receive Values
0000000000000000000000000000000000000000;;	// Values that represent a pointer to a struct
0000000000000000000000000000000000000000;;	func GetKeyField(keyString string, v reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		return v.Elem().FieldByName(keyString)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadArgs parses args from a string in the form "K=V;K2=V2;..."
0000000000000000000000000000000000000000;;	func LoadArgs(args string, container interface{}) error {
0000000000000000000000000000000000000000;;		if args == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containerValue := reflect.ValueOf(container)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pairs := strings.Split(args, ";")
0000000000000000000000000000000000000000;;		unknownArgs := []string{}
0000000000000000000000000000000000000000;;		for _, pair := range pairs {
0000000000000000000000000000000000000000;;			kv := strings.Split(pair, "=")
0000000000000000000000000000000000000000;;			if len(kv) != 2 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ARGS: invalid pair %q", pair)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keyString := kv[0]
0000000000000000000000000000000000000000;;			valueString := kv[1]
0000000000000000000000000000000000000000;;			keyField := GetKeyField(keyString, containerValue)
0000000000000000000000000000000000000000;;			if !keyField.IsValid() {
0000000000000000000000000000000000000000;;				unknownArgs = append(unknownArgs, pair)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			u := keyField.Addr().Interface().(encoding.TextUnmarshaler)
0000000000000000000000000000000000000000;;			err := u.UnmarshalText([]byte(valueString))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("ARGS: error parsing value of pair %q: %v)", pair, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isIgnoreUnknown := GetKeyField("IgnoreUnknown", containerValue).Bool()
0000000000000000000000000000000000000000;;		if len(unknownArgs) > 0 && !isIgnoreUnknown {
0000000000000000000000000000000000000000;;			return fmt.Errorf("ARGS: unknown args %q", unknownArgs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
