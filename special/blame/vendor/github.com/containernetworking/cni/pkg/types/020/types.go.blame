0000000000000000000000000000000000000000;;	// Copyright 2016 CNI authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b470e88e0f5adf62765f30d82b8bad5206a3b19d;;	
0000000000000000000000000000000000000000;;	package types020
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/pkg/types"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const implementedSpecVersion string = "0.2.0"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var SupportedVersions = []string{"", "0.1.0", implementedSpecVersion}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compatibility types for CNI version 0.1.0 and 0.2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResult(data []byte) (types.Result, error) {
0000000000000000000000000000000000000000;;		result := &Result{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, result); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetResult(r types.Result) (*Result, error) {
0000000000000000000000000000000000000000;;		// We expect version 0.1.0/0.2.0 results
0000000000000000000000000000000000000000;;		result020, err := r.GetAsVersion(implementedSpecVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, ok := result020.(*Result)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to convert result")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Result is what gets returned from the plugin (via stdout) to the caller
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		IP4 *IPConfig `json:"ip4,omitempty"`
0000000000000000000000000000000000000000;;		IP6 *IPConfig `json:"ip6,omitempty"`
0000000000000000000000000000000000000000;;		DNS types.DNS `json:"dns,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Result) Version() string {
0000000000000000000000000000000000000000;;		return implementedSpecVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Result) GetAsVersion(version string) (types.Result, error) {
0000000000000000000000000000000000000000;;		for _, supportedVersion := range SupportedVersions {
0000000000000000000000000000000000000000;;			if version == supportedVersion {
0000000000000000000000000000000000000000;;				return r, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("cannot convert version %q to %s", SupportedVersions, version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Result) Print() error {
0000000000000000000000000000000000000000;;		data, err := json.MarshalIndent(r, "", "    ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = os.Stdout.Write(data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a formatted string in the form of "[IP4: $1,][ IP6: $2,] DNS: $3" where
0000000000000000000000000000000000000000;;	// $1 represents the receiver's IPv4, $2 represents the receiver's IPv6 and $3 the
0000000000000000000000000000000000000000;;	// receiver's DNS. If $1 or $2 are nil, they won't be present in the returned string.
0000000000000000000000000000000000000000;;	func (r *Result) String() string {
0000000000000000000000000000000000000000;;		var str string
0000000000000000000000000000000000000000;;		if r.IP4 != nil {
0000000000000000000000000000000000000000;;			str = fmt.Sprintf("IP4:%+v, ", *r.IP4)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.IP6 != nil {
0000000000000000000000000000000000000000;;			str += fmt.Sprintf("IP6:%+v, ", *r.IP6)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%sDNS:%+v", str, r.DNS)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPConfig contains values necessary to configure an interface
0000000000000000000000000000000000000000;;	type IPConfig struct {
0000000000000000000000000000000000000000;;		IP      net.IPNet
0000000000000000000000000000000000000000;;		Gateway net.IP
0000000000000000000000000000000000000000;;		Routes  []types.Route
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// net.IPNet is not JSON (un)marshallable so this duality is needed
0000000000000000000000000000000000000000;;	// for our custom IPNet type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSON (un)marshallable types
0000000000000000000000000000000000000000;;	type ipConfig struct {
0000000000000000000000000000000000000000;;		IP      types.IPNet   `json:"ip"`
0000000000000000000000000000000000000000;;		Gateway net.IP        `json:"gateway,omitempty"`
0000000000000000000000000000000000000000;;		Routes  []types.Route `json:"routes,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *IPConfig) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		ipc := ipConfig{
0000000000000000000000000000000000000000;;			IP:      types.IPNet(c.IP),
0000000000000000000000000000000000000000;;			Gateway: c.Gateway,
0000000000000000000000000000000000000000;;			Routes:  c.Routes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(ipc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *IPConfig) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		ipc := ipConfig{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &ipc); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.IP = net.IPNet(ipc.IP)
0000000000000000000000000000000000000000;;		c.Gateway = ipc.Gateway
0000000000000000000000000000000000000000;;		c.Routes = ipc.Routes
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
