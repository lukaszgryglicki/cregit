0000000000000000000000000000000000000000;;	// Copyright 2016 CNI authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
b470e88e0f5adf62765f30d82b8bad5206a3b19d;;	
0000000000000000000000000000000000000000;;	package current
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/pkg/types/020"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const implementedSpecVersion string = "0.3.1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var SupportedVersions = []string{"0.3.0", implementedSpecVersion}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResult(data []byte) (types.Result, error) {
0000000000000000000000000000000000000000;;		result := &Result{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, result); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetResult(r types.Result) (*Result, error) {
0000000000000000000000000000000000000000;;		resultCurrent, err := r.GetAsVersion(implementedSpecVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result, ok := resultCurrent.(*Result)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to convert result")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var resultConverters = []struct {
0000000000000000000000000000000000000000;;		versions []string
0000000000000000000000000000000000000000;;		convert  func(types.Result) (*Result, error)
0000000000000000000000000000000000000000;;	}{
0000000000000000000000000000000000000000;;		{types020.SupportedVersions, convertFrom020},
0000000000000000000000000000000000000000;;		{SupportedVersions, convertFrom030},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertFrom020(result types.Result) (*Result, error) {
0000000000000000000000000000000000000000;;		oldResult, err := types020.GetResult(result)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newResult := &Result{
0000000000000000000000000000000000000000;;			DNS:    oldResult.DNS,
0000000000000000000000000000000000000000;;			Routes: []*types.Route{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldResult.IP4 != nil {
0000000000000000000000000000000000000000;;			newResult.IPs = append(newResult.IPs, &IPConfig{
0000000000000000000000000000000000000000;;				Version:   "4",
0000000000000000000000000000000000000000;;				Interface: -1,
0000000000000000000000000000000000000000;;				Address:   oldResult.IP4.IP,
0000000000000000000000000000000000000000;;				Gateway:   oldResult.IP4.Gateway,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			for _, route := range oldResult.IP4.Routes {
0000000000000000000000000000000000000000;;				gw := route.GW
0000000000000000000000000000000000000000;;				if gw == nil {
0000000000000000000000000000000000000000;;					gw = oldResult.IP4.Gateway
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newResult.Routes = append(newResult.Routes, &types.Route{
0000000000000000000000000000000000000000;;					Dst: route.Dst,
0000000000000000000000000000000000000000;;					GW:  gw,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldResult.IP6 != nil {
0000000000000000000000000000000000000000;;			newResult.IPs = append(newResult.IPs, &IPConfig{
0000000000000000000000000000000000000000;;				Version:   "6",
0000000000000000000000000000000000000000;;				Interface: -1,
0000000000000000000000000000000000000000;;				Address:   oldResult.IP6.IP,
0000000000000000000000000000000000000000;;				Gateway:   oldResult.IP6.Gateway,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			for _, route := range oldResult.IP6.Routes {
0000000000000000000000000000000000000000;;				gw := route.GW
0000000000000000000000000000000000000000;;				if gw == nil {
0000000000000000000000000000000000000000;;					gw = oldResult.IP6.Gateway
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newResult.Routes = append(newResult.Routes, &types.Route{
0000000000000000000000000000000000000000;;					Dst: route.Dst,
0000000000000000000000000000000000000000;;					GW:  gw,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(newResult.IPs) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot convert: no valid IP addresses")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newResult, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func convertFrom030(result types.Result) (*Result, error) {
0000000000000000000000000000000000000000;;		newResult, ok := result.(*Result)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to convert result")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newResult, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResultFromResult(result types.Result) (*Result, error) {
0000000000000000000000000000000000000000;;		version := result.Version()
0000000000000000000000000000000000000000;;		for _, converter := range resultConverters {
0000000000000000000000000000000000000000;;			for _, supportedVersion := range converter.versions {
0000000000000000000000000000000000000000;;				if version == supportedVersion {
0000000000000000000000000000000000000000;;					return converter.convert(result)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("unsupported CNI result22 version %q", version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Result is what gets returned from the plugin (via stdout) to the caller
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		Interfaces []*Interface   `json:"interfaces,omitempty"`
0000000000000000000000000000000000000000;;		IPs        []*IPConfig    `json:"ips,omitempty"`
0000000000000000000000000000000000000000;;		Routes     []*types.Route `json:"routes,omitempty"`
0000000000000000000000000000000000000000;;		DNS        types.DNS      `json:"dns,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert to the older 0.2.0 CNI spec Result type
0000000000000000000000000000000000000000;;	func (r *Result) convertTo020() (*types020.Result, error) {
0000000000000000000000000000000000000000;;		oldResult := &types020.Result{
0000000000000000000000000000000000000000;;			DNS: r.DNS,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ip := range r.IPs {
0000000000000000000000000000000000000000;;			// Only convert the first IP address of each version as 0.2.0
0000000000000000000000000000000000000000;;			// and earlier cannot handle multiple IP addresses
0000000000000000000000000000000000000000;;			if ip.Version == "4" && oldResult.IP4 == nil {
0000000000000000000000000000000000000000;;				oldResult.IP4 = &types020.IPConfig{
0000000000000000000000000000000000000000;;					IP:      ip.Address,
0000000000000000000000000000000000000000;;					Gateway: ip.Gateway,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if ip.Version == "6" && oldResult.IP6 == nil {
0000000000000000000000000000000000000000;;				oldResult.IP6 = &types020.IPConfig{
0000000000000000000000000000000000000000;;					IP:      ip.Address,
0000000000000000000000000000000000000000;;					Gateway: ip.Gateway,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if oldResult.IP4 != nil && oldResult.IP6 != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, route := range r.Routes {
0000000000000000000000000000000000000000;;			is4 := route.Dst.IP.To4() != nil
0000000000000000000000000000000000000000;;			if is4 && oldResult.IP4 != nil {
0000000000000000000000000000000000000000;;				oldResult.IP4.Routes = append(oldResult.IP4.Routes, types.Route{
0000000000000000000000000000000000000000;;					Dst: route.Dst,
0000000000000000000000000000000000000000;;					GW:  route.GW,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			} else if !is4 && oldResult.IP6 != nil {
0000000000000000000000000000000000000000;;				oldResult.IP6.Routes = append(oldResult.IP6.Routes, types.Route{
0000000000000000000000000000000000000000;;					Dst: route.Dst,
0000000000000000000000000000000000000000;;					GW:  route.GW,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if oldResult.IP4 == nil && oldResult.IP6 == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cannot convert: no valid IP addresses")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return oldResult, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Result) Version() string {
0000000000000000000000000000000000000000;;		return implementedSpecVersion
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Result) GetAsVersion(version string) (types.Result, error) {
0000000000000000000000000000000000000000;;		switch version {
0000000000000000000000000000000000000000;;		case "0.3.0", implementedSpecVersion:
0000000000000000000000000000000000000000;;			return r, nil
0000000000000000000000000000000000000000;;		case types020.SupportedVersions[0], types020.SupportedVersions[1], types020.SupportedVersions[2]:
0000000000000000000000000000000000000000;;			return r.convertTo020()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("cannot convert version 0.3.x to %q", version)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Result) Print() error {
0000000000000000000000000000000000000000;;		data, err := json.MarshalIndent(r, "", "    ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = os.Stdout.Write(data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns a formatted string in the form of "[Interfaces: $1,][ IP: $2,] DNS: $3" where
0000000000000000000000000000000000000000;;	// $1 represents the receiver's Interfaces, $2 represents the receiver's IP addresses and $3 the
0000000000000000000000000000000000000000;;	// receiver's DNS. If $1 or $2 are nil, they won't be present in the returned string.
0000000000000000000000000000000000000000;;	func (r *Result) String() string {
0000000000000000000000000000000000000000;;		var str string
0000000000000000000000000000000000000000;;		if len(r.Interfaces) > 0 {
0000000000000000000000000000000000000000;;			str += fmt.Sprintf("Interfaces:%+v, ", r.Interfaces)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.IPs) > 0 {
0000000000000000000000000000000000000000;;			str += fmt.Sprintf("IP:%+v, ", r.IPs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(r.Routes) > 0 {
0000000000000000000000000000000000000000;;			str += fmt.Sprintf("Routes:%+v, ", r.Routes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%sDNS:%+v", str, r.DNS)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert this old version result to the current CNI version result
0000000000000000000000000000000000000000;;	func (r *Result) Convert() (*Result, error) {
0000000000000000000000000000000000000000;;		return r, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface contains values about the created interfaces
0000000000000000000000000000000000000000;;	type Interface struct {
0000000000000000000000000000000000000000;;		Name    string `json:"name"`
0000000000000000000000000000000000000000;;		Mac     string `json:"mac,omitempty"`
0000000000000000000000000000000000000000;;		Sandbox string `json:"sandbox,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *Interface) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%+v", *i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPConfig contains values necessary to configure an IP address on an interface
0000000000000000000000000000000000000000;;	type IPConfig struct {
0000000000000000000000000000000000000000;;		// IP version, either "4" or "6"
0000000000000000000000000000000000000000;;		Version string
0000000000000000000000000000000000000000;;		// Index into Result structs Interfaces list
0000000000000000000000000000000000000000;;		Interface int
0000000000000000000000000000000000000000;;		Address   net.IPNet
0000000000000000000000000000000000000000;;		Gateway   net.IP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *IPConfig) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%+v", *i)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSON (un)marshallable types
0000000000000000000000000000000000000000;;	type ipConfig struct {
0000000000000000000000000000000000000000;;		Version   string      `json:"version"`
0000000000000000000000000000000000000000;;		Interface int         `json:"interface,omitempty"`
0000000000000000000000000000000000000000;;		Address   types.IPNet `json:"address"`
0000000000000000000000000000000000000000;;		Gateway   net.IP      `json:"gateway,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *IPConfig) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		ipc := ipConfig{
0000000000000000000000000000000000000000;;			Version:   c.Version,
0000000000000000000000000000000000000000;;			Interface: c.Interface,
0000000000000000000000000000000000000000;;			Address:   types.IPNet(c.Address),
0000000000000000000000000000000000000000;;			Gateway:   c.Gateway,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(ipc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *IPConfig) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		ipc := ipConfig{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &ipc); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Version = ipc.Version
0000000000000000000000000000000000000000;;		c.Interface = ipc.Interface
0000000000000000000000000000000000000000;;		c.Address = net.IPNet(ipc.Address)
0000000000000000000000000000000000000000;;		c.Gateway = ipc.Gateway
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
