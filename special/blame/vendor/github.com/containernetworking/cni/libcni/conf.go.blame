0000000000000000000000000000000000000000;;	// Copyright 2015 CNI authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
350b88069342129c4911863376c2eff9fa6f8b94;Godeps/_workspace/src/github.com/appc/cni/libcni/conf.go[Godeps/_workspace/src/github.com/appc/cni/libcni/conf.go][vendor/github.com/containernetworking/cni/libcni/conf.go];	
0000000000000000000000000000000000000000;;	package libcni
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NotFoundError struct {
0000000000000000000000000000000000000000;;		Dir  string
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e NotFoundError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(`no net configuration with name "%s" in %s`, e.Name, e.Dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NoConfigsFoundError struct {
0000000000000000000000000000000000000000;;		Dir string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e NoConfigsFoundError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(`no net configurations found in %s`, e.Dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ConfFromBytes(bytes []byte) (*NetworkConfig, error) {
0000000000000000000000000000000000000000;;		conf := &NetworkConfig{Bytes: bytes}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(bytes, &conf.Network); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing configuration: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ConfFromFile(filename string) (*NetworkConfig, error) {
0000000000000000000000000000000000000000;;		bytes, err := ioutil.ReadFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading %s: %s", filename, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ConfFromBytes(bytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ConfListFromBytes(bytes []byte) (*NetworkConfigList, error) {
0000000000000000000000000000000000000000;;		rawList := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(bytes, &rawList); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing configuration list: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawName, ok := rawList["name"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing configuration list: no name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name, ok := rawName.(string)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing configuration list: invalid name type %T", rawName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cniVersion string
0000000000000000000000000000000000000000;;		rawVersion, ok := rawList["cniVersion"]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			cniVersion, ok = rawVersion.(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error parsing configuration list: invalid cniVersion type %T", rawVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list := &NetworkConfigList{
0000000000000000000000000000000000000000;;			Name:       name,
0000000000000000000000000000000000000000;;			CNIVersion: cniVersion,
0000000000000000000000000000000000000000;;			Bytes:      bytes,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var plugins []interface{}
0000000000000000000000000000000000000000;;		plug, ok := rawList["plugins"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing configuration list: no 'plugins' key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		plugins, ok = plug.([]interface{})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing configuration list: invalid 'plugins' type %T", plug)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(plugins) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error parsing configuration list: no plugins in list")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, conf := range plugins {
0000000000000000000000000000000000000000;;			newBytes, err := json.Marshal(conf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to marshal plugin config %d: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			netConf, err := ConfFromBytes(newBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Failed to parse plugin config %d: %v", i, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			list.Plugins = append(list.Plugins, netConf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return list, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ConfListFromFile(filename string) (*NetworkConfigList, error) {
0000000000000000000000000000000000000000;;		bytes, err := ioutil.ReadFile(filename)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("error reading %s: %s", filename, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ConfListFromBytes(bytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ConfFiles(dir string, extensions []string) ([]string, error) {
0000000000000000000000000000000000000000;;		// In part, adapted from rkt/networking/podenv.go#listFiles
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(dir)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err == nil: // break
0000000000000000000000000000000000000000;;		case os.IsNotExist(err):
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		confFiles := []string{}
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			if f.IsDir() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fileExt := filepath.Ext(f.Name())
0000000000000000000000000000000000000000;;			for _, ext := range extensions {
0000000000000000000000000000000000000000;;				if fileExt == ext {
0000000000000000000000000000000000000000;;					confFiles = append(confFiles, filepath.Join(dir, f.Name()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return confFiles, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadConf(dir, name string) (*NetworkConfig, error) {
0000000000000000000000000000000000000000;;		files, err := ConfFiles(dir, []string{".conf", ".json"})
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case err != nil:
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		case len(files) == 0:
0000000000000000000000000000000000000000;;			return nil, NoConfigsFoundError{Dir: dir}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(files)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, confFile := range files {
0000000000000000000000000000000000000000;;			conf, err := ConfFromFile(confFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if conf.Network.Name == name {
0000000000000000000000000000000000000000;;				return conf, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, NotFoundError{dir, name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func LoadConfList(dir, name string) (*NetworkConfigList, error) {
0000000000000000000000000000000000000000;;		files, err := ConfFiles(dir, []string{".conflist"})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Strings(files)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, confFile := range files {
0000000000000000000000000000000000000000;;			conf, err := ConfListFromFile(confFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if conf.Name == name {
0000000000000000000000000000000000000000;;				return conf, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Try and load a network configuration file (instead of list)
0000000000000000000000000000000000000000;;		// from the same name, then upconvert.
0000000000000000000000000000000000000000;;		singleConf, err := LoadConf(dir, name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// A little extra logic so the error makes sense
0000000000000000000000000000000000000000;;			if _, ok := err.(NoConfigsFoundError); len(files) != 0 && ok {
0000000000000000000000000000000000000000;;				// Config lists found but no config files found
0000000000000000000000000000000000000000;;				return nil, NotFoundError{dir, name}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ConfListFromConf(singleConf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func InjectConf(original *NetworkConfig, newValues map[string]interface{}) (*NetworkConfig, error) {
0000000000000000000000000000000000000000;;		config := make(map[string]interface{})
0000000000000000000000000000000000000000;;		err := json.Unmarshal(original.Bytes, &config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unmarshal existing network bytes: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range newValues {
0000000000000000000000000000000000000000;;			if key == "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("keys cannot be empty")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if value == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("key '%s' value must not be nil", key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			config[key] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newBytes, err := json.Marshal(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ConfFromBytes(newBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfListFromConf "upconverts" a network config in to a NetworkConfigList,
0000000000000000000000000000000000000000;;	// with the single network as the only entry in the list.
0000000000000000000000000000000000000000;;	func ConfListFromConf(original *NetworkConfig) (*NetworkConfigList, error) {
0000000000000000000000000000000000000000;;		// Re-deserialize the config's json, then make a raw map configlist.
0000000000000000000000000000000000000000;;		// This may seem a bit strange, but it's to make the Bytes fields
0000000000000000000000000000000000000000;;		// actually make sense. Otherwise, the generated json is littered with
0000000000000000000000000000000000000000;;		// golang default values.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawConfig := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(original.Bytes, &rawConfig); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawConfigList := map[string]interface{}{
0000000000000000000000000000000000000000;;			"name":       original.Network.Name,
0000000000000000000000000000000000000000;;			"cniVersion": original.Network.CNIVersion,
0000000000000000000000000000000000000000;;			"plugins":    []interface{}{rawConfig},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(rawConfigList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ConfListFromBytes(b)
0000000000000000000000000000000000000000;;	}
