0000000000000000000000000000000000000000;;	// Copyright 2015 CNI authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
350b88069342129c4911863376c2eff9fa6f8b94;Godeps/_workspace/src/github.com/appc/cni/libcni/api.go[Godeps/_workspace/src/github.com/appc/cni/libcni/api.go][vendor/github.com/containernetworking/cni/libcni/api.go];	
0000000000000000000000000000000000000000;;	package libcni
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/pkg/invoke"
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/pkg/types"
0000000000000000000000000000000000000000;;		"github.com/containernetworking/cni/pkg/version"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RuntimeConf struct {
0000000000000000000000000000000000000000;;		ContainerID string
0000000000000000000000000000000000000000;;		NetNS       string
0000000000000000000000000000000000000000;;		IfName      string
0000000000000000000000000000000000000000;;		Args        [][2]string
0000000000000000000000000000000000000000;;		// A dictionary of capability-specific data passed by the runtime
0000000000000000000000000000000000000000;;		// to plugins as top-level keys in the 'runtimeConfig' dictionary
0000000000000000000000000000000000000000;;		// of the plugin's stdin data.  libcni will ensure that only keys
0000000000000000000000000000000000000000;;		// in this map which match the capabilities of the plugin are passed
0000000000000000000000000000000000000000;;		// to the plugin
0000000000000000000000000000000000000000;;		CapabilityArgs map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetworkConfig struct {
0000000000000000000000000000000000000000;;		Network *types.NetConf
0000000000000000000000000000000000000000;;		Bytes   []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetworkConfigList struct {
0000000000000000000000000000000000000000;;		Name       string
0000000000000000000000000000000000000000;;		CNIVersion string
0000000000000000000000000000000000000000;;		Plugins    []*NetworkConfig
0000000000000000000000000000000000000000;;		Bytes      []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CNI interface {
0000000000000000000000000000000000000000;;		AddNetworkList(net *NetworkConfigList, rt *RuntimeConf) (types.Result, error)
0000000000000000000000000000000000000000;;		DelNetworkList(net *NetworkConfigList, rt *RuntimeConf) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AddNetwork(net *NetworkConfig, rt *RuntimeConf) (types.Result, error)
0000000000000000000000000000000000000000;;		DelNetwork(net *NetworkConfig, rt *RuntimeConf) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CNIConfig struct {
0000000000000000000000000000000000000000;;		Path []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CNIConfig implements the CNI interface
0000000000000000000000000000000000000000;;	var _ CNI = &CNIConfig{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildOneConfig(list *NetworkConfigList, orig *NetworkConfig, prevResult types.Result, rt *RuntimeConf) (*NetworkConfig, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inject := map[string]interface{}{
0000000000000000000000000000000000000000;;			"name":       list.Name,
0000000000000000000000000000000000000000;;			"cniVersion": list.CNIVersion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add previous plugin result
0000000000000000000000000000000000000000;;		if prevResult != nil {
0000000000000000000000000000000000000000;;			inject["prevResult"] = prevResult
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure every config uses the same name and version
0000000000000000000000000000000000000000;;		orig, err = InjectConf(orig, inject)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return injectRuntimeConfig(orig, rt)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function takes a libcni RuntimeConf structure and injects values into
0000000000000000000000000000000000000000;;	// a "runtimeConfig" dictionary in the CNI network configuration JSON that
0000000000000000000000000000000000000000;;	// will be passed to the plugin on stdin.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Only "capabilities arguments" passed by the runtime are currently injected.
0000000000000000000000000000000000000000;;	// These capabilities arguments are filtered through the plugin's advertised
0000000000000000000000000000000000000000;;	// capabilities from its config JSON, and any keys in the CapabilityArgs
0000000000000000000000000000000000000000;;	// matching plugin capabilities are added to the "runtimeConfig" dictionary
0000000000000000000000000000000000000000;;	// sent to the plugin via JSON on stdin.  For exmaple, if the plugin's
0000000000000000000000000000000000000000;;	// capabilities include "portMappings", and the CapabilityArgs map includes a
0000000000000000000000000000000000000000;;	// "portMappings" key, that key and its value are added to the "runtimeConfig"
0000000000000000000000000000000000000000;;	// dictionary to be passed to the plugin's stdin.
0000000000000000000000000000000000000000;;	func injectRuntimeConfig(orig *NetworkConfig, rt *RuntimeConf) (*NetworkConfig, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rc := make(map[string]interface{})
0000000000000000000000000000000000000000;;		for capability, supported := range orig.Network.Capabilities {
0000000000000000000000000000000000000000;;			if !supported {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if data, ok := rt.CapabilityArgs[capability]; ok {
0000000000000000000000000000000000000000;;				rc[capability] = data
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(rc) > 0 {
0000000000000000000000000000000000000000;;			orig, err = InjectConf(orig, map[string]interface{}{"runtimeConfig": rc})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return orig, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddNetworkList executes a sequence of plugins with the ADD command
0000000000000000000000000000000000000000;;	func (c *CNIConfig) AddNetworkList(list *NetworkConfigList, rt *RuntimeConf) (types.Result, error) {
0000000000000000000000000000000000000000;;		var prevResult types.Result
0000000000000000000000000000000000000000;;		for _, net := range list.Plugins {
0000000000000000000000000000000000000000;;			pluginPath, err := invoke.FindInPath(net.Network.Type, c.Path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newConf, err := buildOneConfig(list, net, prevResult, rt)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			prevResult, err = invoke.ExecPluginWithResult(pluginPath, newConf.Bytes, c.args("ADD", rt))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return prevResult, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelNetworkList executes a sequence of plugins with the DEL command
0000000000000000000000000000000000000000;;	func (c *CNIConfig) DelNetworkList(list *NetworkConfigList, rt *RuntimeConf) error {
0000000000000000000000000000000000000000;;		for i := len(list.Plugins) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			net := list.Plugins[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pluginPath, err := invoke.FindInPath(net.Network.Type, c.Path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			newConf, err := buildOneConfig(list, net, nil, rt)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := invoke.ExecPluginWithoutResult(pluginPath, newConf.Bytes, c.args("DEL", rt)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddNetwork executes the plugin with the ADD command
0000000000000000000000000000000000000000;;	func (c *CNIConfig) AddNetwork(net *NetworkConfig, rt *RuntimeConf) (types.Result, error) {
0000000000000000000000000000000000000000;;		pluginPath, err := invoke.FindInPath(net.Network.Type, c.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		net, err = injectRuntimeConfig(net, rt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return invoke.ExecPluginWithResult(pluginPath, net.Bytes, c.args("ADD", rt))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelNetwork executes the plugin with the DEL command
0000000000000000000000000000000000000000;;	func (c *CNIConfig) DelNetwork(net *NetworkConfig, rt *RuntimeConf) error {
0000000000000000000000000000000000000000;;		pluginPath, err := invoke.FindInPath(net.Network.Type, c.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		net, err = injectRuntimeConfig(net, rt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return invoke.ExecPluginWithoutResult(pluginPath, net.Bytes, c.args("DEL", rt))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetVersionInfo reports which versions of the CNI spec are supported by
0000000000000000000000000000000000000000;;	// the given plugin.
0000000000000000000000000000000000000000;;	func (c *CNIConfig) GetVersionInfo(pluginType string) (version.PluginInfo, error) {
0000000000000000000000000000000000000000;;		pluginPath, err := invoke.FindInPath(pluginType, c.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return invoke.GetVersionInfo(pluginPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// =====
0000000000000000000000000000000000000000;;	func (c *CNIConfig) args(action string, rt *RuntimeConf) *invoke.Args {
0000000000000000000000000000000000000000;;		return &invoke.Args{
0000000000000000000000000000000000000000;;			Command:     action,
0000000000000000000000000000000000000000;;			ContainerID: rt.ContainerID,
0000000000000000000000000000000000000000;;			NetNS:       rt.NetNS,
0000000000000000000000000000000000000000;;			PluginArgs:  rt.Args,
0000000000000000000000000000000000000000;;			IfName:      rt.IfName,
0000000000000000000000000000000000000000;;			Path:        strings.Join(c.Path, string(os.PathListSeparator)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
