0000000000000000000000000000000000000000;;	package jsonpath
3bc88e1d995d86a78861e2f0fa2b69f7b765b388;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyString is returned from Decoder.Token to represent each key in a JSON object value.
0000000000000000000000000000000000000000;;	type KeyString string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decoder extends the Go runtime's encoding/json.Decoder to support navigating in a stream of JSON tokens.
0000000000000000000000000000000000000000;;	type Decoder struct {
0000000000000000000000000000000000000000;;		json.Decoder
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path    JsonPath
0000000000000000000000000000000000000000;;		context jsonContext
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder creates a new instance of the extended JSON Decoder.
0000000000000000000000000000000000000000;;	func NewDecoder(r io.Reader) *Decoder {
0000000000000000000000000000000000000000;;		return &Decoder{Decoder: *json.NewDecoder(r)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SeekTo causes the Decoder to move forward to a given path in the JSON structure.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The path argument must consist of strings or integers. Each string specifies an JSON object key, and
0000000000000000000000000000000000000000;;	// each integer specifies an index into a JSON array.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Consider the JSON structure
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  { "a": [0,"s",12e4,{"b":0,"v":35} ] }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// SeekTo("a",3,"v") will move to the value referenced by the "a" key in the current object,
0000000000000000000000000000000000000000;;	// followed by a move to the 4th value (index 3) in the array, followed by a move to the value at key "v".
0000000000000000000000000000000000000000;;	// In this example, a subsequent call to the decoder's Decode() would unmarshal the value 35.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// SeekTo returns a boolean value indicating whether a match was found.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Decoder is intended to be used with a stream of tokens. As a result it navigates forward only.
0000000000000000000000000000000000000000;;	func (d *Decoder) SeekTo(path ...interface{}) (bool, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			return len(d.path) == 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		last := len(path) - 1
0000000000000000000000000000000000000000;;		if i, ok := path[last].(int); ok {
0000000000000000000000000000000000000000;;			path[last] = i - 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if d.path.Equal(path) {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_, err := d.Token()
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode reads the next JSON-encoded value from its input and stores it in the value pointed to by v. This is
0000000000000000000000000000000000000000;;	// equivalent to encoding/json.Decode().
0000000000000000000000000000000000000000;;	func (d *Decoder) Decode(v interface{}) error {
0000000000000000000000000000000000000000;;		switch d.context {
0000000000000000000000000000000000000000;;		case objValue:
0000000000000000000000000000000000000000;;			d.context = objKey
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case arrValue:
0000000000000000000000000000000000000000;;			d.path.incTop()
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.Decoder.Decode(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path returns a slice of string and/or int values representing the path from the root of the JSON object to the
0000000000000000000000000000000000000000;;	// position of the most-recently parsed token.
0000000000000000000000000000000000000000;;	func (d *Decoder) Path() JsonPath {
0000000000000000000000000000000000000000;;		p := make(JsonPath, len(d.path))
0000000000000000000000000000000000000000;;		copy(p, d.path)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token is equivalent to the Token() method on json.Decoder. The primary difference is that it distinguishes
0000000000000000000000000000000000000000;;	// between strings that are keys and and strings that are values. String tokens that are object keys are returned as a
0000000000000000000000000000000000000000;;	// KeyString rather than as a native string.
0000000000000000000000000000000000000000;;	func (d *Decoder) Token() (json.Token, error) {
0000000000000000000000000000000000000000;;		t, err := d.Decoder.Token()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return t, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t == nil {
0000000000000000000000000000000000000000;;			switch d.context {
0000000000000000000000000000000000000000;;			case objValue:
0000000000000000000000000000000000000000;;				d.context = objKey
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case arrValue:
0000000000000000000000000000000000000000;;				d.path.incTop()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return t, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := t.(type) {
0000000000000000000000000000000000000000;;		case json.Delim:
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case json.Delim('{'):
0000000000000000000000000000000000000000;;				if d.context == arrValue {
0000000000000000000000000000000000000000;;					d.path.incTop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.path.push("")
0000000000000000000000000000000000000000;;				d.context = objKey
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case json.Delim('}'):
0000000000000000000000000000000000000000;;				d.path.pop()
0000000000000000000000000000000000000000;;				d.context = d.path.inferContext()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case json.Delim('['):
0000000000000000000000000000000000000000;;				if d.context == arrValue {
0000000000000000000000000000000000000000;;					d.path.incTop()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.path.push(-1)
0000000000000000000000000000000000000000;;				d.context = arrValue
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case json.Delim(']'):
0000000000000000000000000000000000000000;;				d.path.pop()
0000000000000000000000000000000000000000;;				d.context = d.path.inferContext()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case float64, json.Number, bool:
0000000000000000000000000000000000000000;;			switch d.context {
0000000000000000000000000000000000000000;;			case objValue:
0000000000000000000000000000000000000000;;				d.context = objKey
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case arrValue:
0000000000000000000000000000000000000000;;				d.path.incTop()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			switch d.context {
0000000000000000000000000000000000000000;;			case objKey:
0000000000000000000000000000000000000000;;				d.path.nameTop(t)
0000000000000000000000000000000000000000;;				d.context = objValue
0000000000000000000000000000000000000000;;				return KeyString(t), err
0000000000000000000000000000000000000000;;			case objValue:
0000000000000000000000000000000000000000;;				d.context = objKey
0000000000000000000000000000000000000000;;			case arrValue:
0000000000000000000000000000000000000000;;				d.path.incTop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan moves forward over the JSON stream consuming all the tokens at the current level (current object, current array)
0000000000000000000000000000000000000000;;	// invoking each matching PathAction along the way.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Scan returns true if there are more contiguous values to scan (for example in an array).
0000000000000000000000000000000000000000;;	func (d *Decoder) Scan(ext *PathActions) (bool, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootPath := d.Path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If this is an array path, increment the root path in our local copy.
0000000000000000000000000000000000000000;;		if rootPath.inferContext() == arrValue {
0000000000000000000000000000000000000000;;			rootPath.incTop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// advance the token position
0000000000000000000000000000000000000000;;			_, err := d.Token()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match:
0000000000000000000000000000000000000000;;			var relPath JsonPath
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// capture the new JSON path
0000000000000000000000000000000000000000;;			path := d.Path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(path) > len(rootPath) {
0000000000000000000000000000000000000000;;				// capture the path relative to where the scan started
0000000000000000000000000000000000000000;;				relPath = path[len(rootPath):]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// if the path is not longer than the root, then we are done with this scan
0000000000000000000000000000000000000000;;				// return boolean flag indicating if there are more items to scan at the same level
0000000000000000000000000000000000000000;;				return d.Decoder.More(), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// match the relative path against the path actions
0000000000000000000000000000000000000000;;			if node := ext.node.match(relPath); node != nil {
0000000000000000000000000000000000000000;;				if node.action != nil {
0000000000000000000000000000000000000000;;					// we have a match so execute the action
0000000000000000000000000000000000000000;;					err = node.action(d)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return d.Decoder.More(), err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// The action may have advanced the decoder. If we are in an array, advancing it further would
0000000000000000000000000000000000000000;;					// skip tokens. So, if we are scanning an array, jump to the top without advancing the token.
0000000000000000000000000000000000000000;;					if d.path.inferContext() == arrValue && d.Decoder.More() {
0000000000000000000000000000000000000000;;						goto match
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
