0000000000000000000000000000000000000000;;	// Copyright 2013 ChaiShushan <chaishushan{AT}gmail.com>. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
64247eb69ec8b8707eb5c766a35ff8a3cd455896;;	
0000000000000000000000000000000000000000;;	package mo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodePoString(text string) string {
0000000000000000000000000000000000000000;;		lines := strings.Split(text, "\n")
0000000000000000000000000000000000000000;;		for i := 0; i < len(lines); i++ {
0000000000000000000000000000000000000000;;			left := strings.Index(lines[i], `"`)
0000000000000000000000000000000000000000;;			right := strings.LastIndex(lines[i], `"`)
0000000000000000000000000000000000000000;;			if left < 0 || right < 0 || left == right {
0000000000000000000000000000000000000000;;				lines[i] = ""
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := lines[i][left+1 : right]
0000000000000000000000000000000000000000;;			data := make([]byte, 0, len(line))
0000000000000000000000000000000000000000;;			for i := 0; i < len(line); i++ {
0000000000000000000000000000000000000000;;				if line[i] != '\\' {
0000000000000000000000000000000000000000;;					data = append(data, line[i])
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i+1 >= len(line) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch line[i+1] {
0000000000000000000000000000000000000000;;				case 'n': // \\n -> \n
0000000000000000000000000000000000000000;;					data = append(data, '\n')
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				case 't': // \\t -> \n
0000000000000000000000000000000000000000;;					data = append(data, '\t')
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				case '\\': // \\\ -> ?
0000000000000000000000000000000000000000;;					data = append(data, '\\')
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lines[i] = string(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(lines, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodePoString(text string) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		lines := strings.Split(text, "\n")
0000000000000000000000000000000000000000;;		for i := 0; i < len(lines); i++ {
0000000000000000000000000000000000000000;;			if lines[i] == "" {
0000000000000000000000000000000000000000;;				if i != len(lines)-1 {
0000000000000000000000000000000000000000;;					buf.WriteString(`"\n"` + "\n")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteRune('"')
0000000000000000000000000000000000000000;;			for _, r := range lines[i] {
0000000000000000000000000000000000000000;;				switch r {
0000000000000000000000000000000000000000;;				case '\\':
0000000000000000000000000000000000000000;;					buf.WriteString(`\\`)
0000000000000000000000000000000000000000;;				case '"':
0000000000000000000000000000000000000000;;					buf.WriteString(`\"`)
0000000000000000000000000000000000000000;;				case '\n':
0000000000000000000000000000000000000000;;					buf.WriteString(`\n`)
0000000000000000000000000000000000000000;;				case '\t':
0000000000000000000000000000000000000000;;					buf.WriteString(`\t`)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					buf.WriteRune(r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteString(`\n"` + "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeCommentPoString(text string) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		lines := strings.Split(text, "\n")
0000000000000000000000000000000000000000;;		if len(lines) > 1 {
0000000000000000000000000000000000000000;;			buf.WriteString(`""` + "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(lines); i++ {
0000000000000000000000000000000000000000;;			if len(lines) > 0 {
0000000000000000000000000000000000000000;;				buf.WriteString("#| ")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteRune('"')
0000000000000000000000000000000000000000;;			for _, r := range lines[i] {
0000000000000000000000000000000000000000;;				switch r {
0000000000000000000000000000000000000000;;				case '\\':
0000000000000000000000000000000000000000;;					buf.WriteString(`\\`)
0000000000000000000000000000000000000000;;				case '"':
0000000000000000000000000000000000000000;;					buf.WriteString(`\"`)
0000000000000000000000000000000000000000;;				case '\n':
0000000000000000000000000000000000000000;;					buf.WriteString(`\n`)
0000000000000000000000000000000000000000;;				case '\t':
0000000000000000000000000000000000000000;;					buf.WriteString(`\t`)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					buf.WriteRune(r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i < len(lines)-1 {
0000000000000000000000000000000000000000;;				buf.WriteString(`\n"` + "\n")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				buf.WriteString(`"`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
