0000000000000000000000000000000000000000;;	// Copyright 2013 ChaiShushan <chaishushan{AT}gmail.com>. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
64247eb69ec8b8707eb5c766a35ff8a3cd455896;;	
0000000000000000000000000000000000000000;;	package mo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type moHeader struct {
0000000000000000000000000000000000000000;;		MagicNumber  uint32
0000000000000000000000000000000000000000;;		MajorVersion uint16
0000000000000000000000000000000000000000;;		MinorVersion uint16
0000000000000000000000000000000000000000;;		MsgIdCount   uint32
0000000000000000000000000000000000000000;;		MsgIdOffset  uint32
0000000000000000000000000000000000000000;;		MsgStrOffset uint32
0000000000000000000000000000000000000000;;		HashSize     uint32
0000000000000000000000000000000000000000;;		HashOffset   uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type moStrPos struct {
0000000000000000000000000000000000000000;;		Size uint32 // must keep fields order
0000000000000000000000000000000000000000;;		Addr uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeFile(f *File) []byte {
0000000000000000000000000000000000000000;;		hdr := &moHeader{
0000000000000000000000000000000000000000;;			MagicNumber: MoMagicLittleEndian,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := encodeData(hdr, f)
0000000000000000000000000000000000000000;;		data = append(encodeHeader(hdr), data...)
0000000000000000000000000000000000000000;;		return data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encode data and init moHeader
0000000000000000000000000000000000000000;;	func encodeData(hdr *moHeader, f *File) []byte {
0000000000000000000000000000000000000000;;		msgList := []Message{f.MimeHeader.toMessage()}
0000000000000000000000000000000000000000;;		for _, v := range f.Messages {
0000000000000000000000000000000000000000;;			if len(v.MsgId) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(v.MsgStr) == 0 && len(v.MsgStrPlural) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msgList = append(msgList, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(byMessages(msgList))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		var msgIdPosList = make([]moStrPos, len(msgList))
0000000000000000000000000000000000000000;;		var msgStrPosList = make([]moStrPos, len(msgList))
0000000000000000000000000000000000000000;;		for i, v := range msgList {
0000000000000000000000000000000000000000;;			// write msgid
0000000000000000000000000000000000000000;;			msgId := encodeMsgId(v)
0000000000000000000000000000000000000000;;			msgIdPosList[i].Addr = uint32(buf.Len() + MoHeaderSize)
0000000000000000000000000000000000000000;;			msgIdPosList[i].Size = uint32(len(msgId))
0000000000000000000000000000000000000000;;			buf.WriteString(msgId)
0000000000000000000000000000000000000000;;			// write msgstr
0000000000000000000000000000000000000000;;			msgStr := encodeMsgStr(v)
0000000000000000000000000000000000000000;;			msgStrPosList[i].Addr = uint32(buf.Len() + MoHeaderSize)
0000000000000000000000000000000000000000;;			msgStrPosList[i].Size = uint32(len(msgStr))
0000000000000000000000000000000000000000;;			buf.WriteString(msgStr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hdr.MsgIdOffset = uint32(buf.Len() + MoHeaderSize)
0000000000000000000000000000000000000000;;		binary.Write(&buf, binary.LittleEndian, msgIdPosList)
0000000000000000000000000000000000000000;;		hdr.MsgStrOffset = uint32(buf.Len() + MoHeaderSize)
0000000000000000000000000000000000000000;;		binary.Write(&buf, binary.LittleEndian, msgStrPosList)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hdr.MsgIdCount = uint32(len(msgList))
0000000000000000000000000000000000000000;;		return buf.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// must called after encodeData
0000000000000000000000000000000000000000;;	func encodeHeader(hdr *moHeader) []byte {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		binary.Write(&buf, binary.LittleEndian, hdr)
0000000000000000000000000000000000000000;;		return buf.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeMsgId(v Message) string {
0000000000000000000000000000000000000000;;		if v.MsgContext != "" && v.MsgIdPlural != "" {
0000000000000000000000000000000000000000;;			return v.MsgContext + EotSeparator + v.MsgId + NulSeparator + v.MsgIdPlural
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.MsgContext != "" && v.MsgIdPlural == "" {
0000000000000000000000000000000000000000;;			return v.MsgContext + EotSeparator + v.MsgId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.MsgContext == "" && v.MsgIdPlural != "" {
0000000000000000000000000000000000000000;;			return v.MsgId + NulSeparator + v.MsgIdPlural
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.MsgId
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeMsgStr(v Message) string {
0000000000000000000000000000000000000000;;		if v.MsgIdPlural != "" {
0000000000000000000000000000000000000000;;			return strings.Join(v.MsgStrPlural, NulSeparator)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v.MsgStr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byMessages []Message
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d byMessages) Len() int {
0000000000000000000000000000000000000000;;		return len(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (d byMessages) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if a, b := d[i].MsgContext, d[j].MsgContext; a != b {
0000000000000000000000000000000000000000;;			return a < b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a, b := d[i].MsgId, d[j].MsgId; a != b {
0000000000000000000000000000000000000000;;			return a < b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a, b := d[i].MsgIdPlural, d[j].MsgIdPlural; a != b {
0000000000000000000000000000000000000000;;			return a < b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (d byMessages) Swap(i, j int) {
0000000000000000000000000000000000000000;;		d[i], d[j] = d[j], d[i]
0000000000000000000000000000000000000000;;	}
