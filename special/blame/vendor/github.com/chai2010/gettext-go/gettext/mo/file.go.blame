0000000000000000000000000000000000000000;;	// Copyright 2013 ChaiShushan <chaishushan{AT}gmail.com>. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
64247eb69ec8b8707eb5c766a35ff8a3cd455896;;	
0000000000000000000000000000000000000000;;	package mo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MoHeaderSize        = 28
0000000000000000000000000000000000000000;;		MoMagicLittleEndian = 0x950412de
0000000000000000000000000000000000000000;;		MoMagicBigEndian    = 0xde120495
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EotSeparator = "\x04" // msgctxt and msgid separator
0000000000000000000000000000000000000000;;		NulSeparator = "\x00" // msgid and msgstr separator
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File represents an MO File.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See http://www.gnu.org/software/gettext/manual/html_node/MO-Files.html
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		MagicNumber  uint32
0000000000000000000000000000000000000000;;		MajorVersion uint16
0000000000000000000000000000000000000000;;		MinorVersion uint16
0000000000000000000000000000000000000000;;		MsgIdCount   uint32
0000000000000000000000000000000000000000;;		MsgIdOffset  uint32
0000000000000000000000000000000000000000;;		MsgStrOffset uint32
0000000000000000000000000000000000000000;;		HashSize     uint32
0000000000000000000000000000000000000000;;		HashOffset   uint32
0000000000000000000000000000000000000000;;		MimeHeader   Header
0000000000000000000000000000000000000000;;		Messages     []Message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load loads a named mo file.
0000000000000000000000000000000000000000;;	func Load(name string) (*File, error) {
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return LoadData(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadData loads mo file format data.
0000000000000000000000000000000000000000;;	func LoadData(data []byte) (*File, error) {
0000000000000000000000000000000000000000;;		r := bytes.NewReader(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var magicNumber uint32
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.LittleEndian, &magicNumber); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var bo binary.ByteOrder
0000000000000000000000000000000000000000;;		switch magicNumber {
0000000000000000000000000000000000000000;;		case MoMagicLittleEndian:
0000000000000000000000000000000000000000;;			bo = binary.LittleEndian
0000000000000000000000000000000000000000;;		case MoMagicBigEndian:
0000000000000000000000000000000000000000;;			bo = binary.BigEndian
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("gettext: %v", "invalid magic number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var header struct {
0000000000000000000000000000000000000000;;			MajorVersion uint16
0000000000000000000000000000000000000000;;			MinorVersion uint16
0000000000000000000000000000000000000000;;			MsgIdCount   uint32
0000000000000000000000000000000000000000;;			MsgIdOffset  uint32
0000000000000000000000000000000000000000;;			MsgStrOffset uint32
0000000000000000000000000000000000000000;;			HashSize     uint32
0000000000000000000000000000000000000000;;			HashOffset   uint32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Read(r, bo, &header); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v := header.MajorVersion; v != 0 && v != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("gettext: %v", "invalid version number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v := header.MinorVersion; v != 0 && v != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("gettext: %v", "invalid version number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgIdStart := make([]uint32, header.MsgIdCount)
0000000000000000000000000000000000000000;;		msgIdLen := make([]uint32, header.MsgIdCount)
0000000000000000000000000000000000000000;;		if _, err := r.Seek(int64(header.MsgIdOffset), 0); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < int(header.MsgIdCount); i++ {
0000000000000000000000000000000000000000;;			if err := binary.Read(r, bo, &msgIdLen[i]); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := binary.Read(r, bo, &msgIdStart[i]); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgStrStart := make([]int32, header.MsgIdCount)
0000000000000000000000000000000000000000;;		msgStrLen := make([]int32, header.MsgIdCount)
0000000000000000000000000000000000000000;;		if _, err := r.Seek(int64(header.MsgStrOffset), 0); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < int(header.MsgIdCount); i++ {
0000000000000000000000000000000000000000;;			if err := binary.Read(r, bo, &msgStrLen[i]); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := binary.Read(r, bo, &msgStrStart[i]); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		file := &File{
0000000000000000000000000000000000000000;;			MagicNumber:  magicNumber,
0000000000000000000000000000000000000000;;			MajorVersion: header.MajorVersion,
0000000000000000000000000000000000000000;;			MinorVersion: header.MinorVersion,
0000000000000000000000000000000000000000;;			MsgIdCount:   header.MsgIdCount,
0000000000000000000000000000000000000000;;			MsgIdOffset:  header.MsgIdOffset,
0000000000000000000000000000000000000000;;			MsgStrOffset: header.MsgStrOffset,
0000000000000000000000000000000000000000;;			HashSize:     header.HashSize,
0000000000000000000000000000000000000000;;			HashOffset:   header.HashOffset,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < int(header.MsgIdCount); i++ {
0000000000000000000000000000000000000000;;			if _, err := r.Seek(int64(msgIdStart[i]), 0); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msgIdData := make([]byte, msgIdLen[i])
0000000000000000000000000000000000000000;;			if _, err := r.Read(msgIdData); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, err := r.Seek(int64(msgStrStart[i]), 0); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msgStrData := make([]byte, msgStrLen[i])
0000000000000000000000000000000000000000;;			if _, err := r.Read(msgStrData); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("gettext: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(msgIdData) == 0 {
0000000000000000000000000000000000000000;;				var msg = Message{
0000000000000000000000000000000000000000;;					MsgId:  string(msgIdData),
0000000000000000000000000000000000000000;;					MsgStr: string(msgStrData),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				file.MimeHeader.fromMessage(&msg)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var msg = Message{
0000000000000000000000000000000000000000;;					MsgId:  string(msgIdData),
0000000000000000000000000000000000000000;;					MsgStr: string(msgStrData),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Is this a context message?
0000000000000000000000000000000000000000;;				if idx := strings.Index(msg.MsgId, EotSeparator); idx != -1 {
0000000000000000000000000000000000000000;;					msg.MsgContext, msg.MsgId = msg.MsgId[:idx], msg.MsgId[idx+1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Is this a plural message?
0000000000000000000000000000000000000000;;				if idx := strings.Index(msg.MsgId, NulSeparator); idx != -1 {
0000000000000000000000000000000000000000;;					msg.MsgId, msg.MsgIdPlural = msg.MsgId[:idx], msg.MsgId[idx+1:]
0000000000000000000000000000000000000000;;					msg.MsgStrPlural = strings.Split(msg.MsgStr, NulSeparator)
0000000000000000000000000000000000000000;;					msg.MsgStr = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				file.Messages = append(file.Messages, msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return file, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Save saves a mo file.
0000000000000000000000000000000000000000;;	func (f *File) Save(name string) error {
0000000000000000000000000000000000000000;;		return ioutil.WriteFile(name, f.Data(), 0666)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Save returns a mo file format data.
0000000000000000000000000000000000000000;;	func (f *File) Data() []byte {
0000000000000000000000000000000000000000;;		return encodeFile(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the po format file string.
0000000000000000000000000000000000000000;;	func (f *File) String() string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "# version: %d.%d\n", f.MajorVersion, f.MinorVersion)
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "%s\n", f.MimeHeader.String())
0000000000000000000000000000000000000000;;		fmt.Fprintf(&buf, "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range f.Messages {
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, `msgid "%v"`+"\n", k)
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, `msgstr "%s"`+"\n", v.MsgStr)
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
