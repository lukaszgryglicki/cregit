0000000000000000000000000000000000000000;;	// Copyright 2013 ChaiShushan <chaishushan{AT}gmail.com>. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
64247eb69ec8b8707eb5c766a35ff8a3cd455896;;	
0000000000000000000000000000000000000000;;	package po
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Comment represents every message's comments.
0000000000000000000000000000000000000000;;	type Comment struct {
0000000000000000000000000000000000000000;;		StartLine         int      // comment start line
0000000000000000000000000000000000000000;;		TranslatorComment string   // #  translator-comments // TrimSpace
0000000000000000000000000000000000000000;;		ExtractedComment  string   // #. extracted-comments
0000000000000000000000000000000000000000;;		ReferenceFile     []string // #: src/msgcmp.c:338 src/po-lex.c:699
0000000000000000000000000000000000000000;;		ReferenceLine     []int    // #: src/msgcmp.c:338 src/po-lex.c:699
0000000000000000000000000000000000000000;;		Flags             []string // #, fuzzy,c-format,range:0..10
0000000000000000000000000000000000000000;;		PrevMsgContext    string   // #| msgctxt previous-context
0000000000000000000000000000000000000000;;		PrevMsgId         string   // #| msgid previous-untranslated-string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) less(q *Comment) bool {
0000000000000000000000000000000000000000;;		if p.StartLine != 0 || q.StartLine != 0 {
0000000000000000000000000000000000000000;;			return p.StartLine < q.StartLine
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a, b := len(p.ReferenceFile), len(q.ReferenceFile); a != b {
0000000000000000000000000000000000000000;;			return a < b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(p.ReferenceFile); i++ {
0000000000000000000000000000000000000000;;			if a, b := p.ReferenceFile[i], q.ReferenceFile[i]; a != b {
0000000000000000000000000000000000000000;;				return a < b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if a, b := p.ReferenceLine[i], q.ReferenceLine[i]; a != b {
0000000000000000000000000000000000000000;;				return a < b
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readPoComment(r *lineReader) (err error) {
0000000000000000000000000000000000000000;;		*p = Comment{}
0000000000000000000000000000000000000000;;		if err = r.skipBlankLine(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func(oldPos int) {
0000000000000000000000000000000000000000;;			newPos := r.currentPos()
0000000000000000000000000000000000000000;;			if newPos != oldPos && err == io.EOF {
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}(r.currentPos())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.StartLine = r.currentPos() + 1
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var s string
0000000000000000000000000000000000000000;;			if s, _, err = r.currentLine(); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) == 0 || s[0] != '#' {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = p.readTranslatorComment(r); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = p.readExtractedComment(r); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = p.readReferenceComment(r); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = p.readFlagsComment(r); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = p.readPrevMsgContext(r); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = p.readPrevMsgId(r); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readTranslatorComment(r *lineReader) (err error) {
0000000000000000000000000000000000000000;;		const prefix = "# " // .,:|
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var s string
0000000000000000000000000000000000000000;;			if s, _, err = r.readLine(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) < 1 || s[0] != '#' {
0000000000000000000000000000000000000000;;				r.unreadLine()
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) >= 2 {
0000000000000000000000000000000000000000;;				switch s[1] {
0000000000000000000000000000000000000000;;				case '.', ',', ':', '|':
0000000000000000000000000000000000000000;;					r.unreadLine()
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.TranslatorComment != "" {
0000000000000000000000000000000000000000;;				p.TranslatorComment += "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.TranslatorComment += strings.TrimSpace(s[1:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readExtractedComment(r *lineReader) (err error) {
0000000000000000000000000000000000000000;;		const prefix = "#."
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var s string
0000000000000000000000000000000000000000;;			if s, _, err = r.readLine(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) < len(prefix) || s[:len(prefix)] != prefix {
0000000000000000000000000000000000000000;;				r.unreadLine()
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.ExtractedComment != "" {
0000000000000000000000000000000000000000;;				p.ExtractedComment += "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.ExtractedComment += strings.TrimSpace(s[len(prefix):])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readReferenceComment(r *lineReader) (err error) {
0000000000000000000000000000000000000000;;		const prefix = "#:"
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var s string
0000000000000000000000000000000000000000;;			if s, _, err = r.readLine(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) < len(prefix) || s[:len(prefix)] != prefix {
0000000000000000000000000000000000000000;;				r.unreadLine()
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ss := strings.Split(strings.TrimSpace(s[len(prefix):]), " ")
0000000000000000000000000000000000000000;;			for i := 0; i < len(ss); i++ {
0000000000000000000000000000000000000000;;				idx := strings.Index(ss[i], ":")
0000000000000000000000000000000000000000;;				if idx <= 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				name := strings.TrimSpace(ss[i][:idx])
0000000000000000000000000000000000000000;;				line, _ := strconv.Atoi(strings.TrimSpace(ss[i][idx+1:]))
0000000000000000000000000000000000000000;;				p.ReferenceFile = append(p.ReferenceFile, name)
0000000000000000000000000000000000000000;;				p.ReferenceLine = append(p.ReferenceLine, line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readFlagsComment(r *lineReader) (err error) {
0000000000000000000000000000000000000000;;		const prefix = "#,"
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var s string
0000000000000000000000000000000000000000;;			if s, _, err = r.readLine(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(s) < len(prefix) || s[:len(prefix)] != prefix {
0000000000000000000000000000000000000000;;				r.unreadLine()
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ss := strings.Split(strings.TrimSpace(s[len(prefix):]), ",")
0000000000000000000000000000000000000000;;			for i := 0; i < len(ss); i++ {
0000000000000000000000000000000000000000;;				p.Flags = append(p.Flags, strings.TrimSpace(ss[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readPrevMsgContext(r *lineReader) (err error) {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if s, _, err = r.currentLine(); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !rePrevMsgContextComments.MatchString(s) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.PrevMsgContext, err = p.readString(r)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readPrevMsgId(r *lineReader) (err error) {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if s, _, err = r.currentLine(); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !rePrevMsgIdComments.MatchString(s) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.PrevMsgId, err = p.readString(r)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Comment) readString(r *lineReader) (msg string, err error) {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if s, _, err = r.readLine(); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg += decodePoString(s)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if s, _, err = r.readLine(); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !reStringLineComments.MatchString(s) {
0000000000000000000000000000000000000000;;				r.unreadLine()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg += decodePoString(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetFuzzy gets the fuzzy flag.
0000000000000000000000000000000000000000;;	func (p *Comment) GetFuzzy() bool {
0000000000000000000000000000000000000000;;		for _, s := range p.Flags {
0000000000000000000000000000000000000000;;			if s == "fuzzy" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetFuzzy sets the fuzzy flag.
0000000000000000000000000000000000000000;;	func (p *Comment) SetFuzzy(fuzzy bool) {
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the po format comment string.
0000000000000000000000000000000000000000;;	func (p Comment) String() string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		if p.TranslatorComment != "" {
0000000000000000000000000000000000000000;;			ss := strings.Split(p.TranslatorComment, "\n")
0000000000000000000000000000000000000000;;			for i := 0; i < len(ss); i++ {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, "# %s\n", ss[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.ExtractedComment != "" {
0000000000000000000000000000000000000000;;			ss := strings.Split(p.ExtractedComment, "\n")
0000000000000000000000000000000000000000;;			for i := 0; i < len(ss); i++ {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, "#. %s\n", ss[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if a, b := len(p.ReferenceFile), len(p.ReferenceLine); a != 0 && a == b {
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "#:")
0000000000000000000000000000000000000000;;			for i := 0; i < len(p.ReferenceFile); i++ {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, " %s:%d", p.ReferenceFile[i], p.ReferenceLine[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.Flags) != 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "#, %s", p.Flags[0])
0000000000000000000000000000000000000000;;			for i := 1; i < len(p.Flags); i++ {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&buf, ", %s", p.Flags[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.PrevMsgContext != "" {
0000000000000000000000000000000000000000;;			s := encodeCommentPoString(p.PrevMsgContext)
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "#| msgctxt %s\n", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.PrevMsgId != "" {
0000000000000000000000000000000000000000;;			s := encodeCommentPoString(p.PrevMsgId)
0000000000000000000000000000000000000000;;			fmt.Fprintf(&buf, "#| msgid %s\n", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
