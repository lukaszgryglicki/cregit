0000000000000000000000000000000000000000;;	// Copyright 2013 ChaiShushan <chaishushan{AT}gmail.com>. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
64247eb69ec8b8707eb5c766a35ff8a3cd455896;;	
0000000000000000000000000000000000000000;;	package gettext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/chai2010/gettext-go/gettext/mo"
0000000000000000000000000000000000000000;;		"github.com/chai2010/gettext-go/gettext/plural"
0000000000000000000000000000000000000000;;		"github.com/chai2010/gettext-go/gettext/po"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nilTranslator = &translator{
0000000000000000000000000000000000000000;;		MessageMap:    make(map[string]mo.Message),
0000000000000000000000000000000000000000;;		PluralFormula: plural.Formula("??"),
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type translator struct {
0000000000000000000000000000000000000000;;		MessageMap    map[string]mo.Message
0000000000000000000000000000000000000000;;		PluralFormula func(n int) int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMoTranslator(name string, data []byte) (*translator, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			f   *mo.File
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if len(data) != 0 {
0000000000000000000000000000000000000000;;			f, err = mo.LoadData(data)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f, err = mo.Load(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var tr = &translator{
0000000000000000000000000000000000000000;;			MessageMap: make(map[string]mo.Message),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range f.Messages {
0000000000000000000000000000000000000000;;			tr.MessageMap[tr.makeMapKey(v.MsgContext, v.MsgId)] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lang := f.MimeHeader.Language; lang != "" {
0000000000000000000000000000000000000000;;			tr.PluralFormula = plural.Formula(lang)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tr.PluralFormula = plural.Formula("??")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPoTranslator(name string, data []byte) (*translator, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			f   *po.File
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if len(data) != 0 {
0000000000000000000000000000000000000000;;			f, err = po.LoadData(data)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			f, err = po.Load(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var tr = &translator{
0000000000000000000000000000000000000000;;			MessageMap: make(map[string]mo.Message),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, v := range f.Messages {
0000000000000000000000000000000000000000;;			tr.MessageMap[tr.makeMapKey(v.MsgContext, v.MsgId)] = mo.Message{
0000000000000000000000000000000000000000;;				MsgContext:   v.MsgContext,
0000000000000000000000000000000000000000;;				MsgId:        v.MsgId,
0000000000000000000000000000000000000000;;				MsgIdPlural:  v.MsgIdPlural,
0000000000000000000000000000000000000000;;				MsgStr:       v.MsgStr,
0000000000000000000000000000000000000000;;				MsgStrPlural: v.MsgStrPlural,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lang := f.MimeHeader.Language; lang != "" {
0000000000000000000000000000000000000000;;			tr.PluralFormula = plural.Formula(lang)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tr.PluralFormula = plural.Formula("??")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *translator) PGettext(msgctxt, msgid string) string {
0000000000000000000000000000000000000000;;		return p.PNGettext(msgctxt, msgid, "", 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *translator) PNGettext(msgctxt, msgid, msgidPlural string, n int) string {
0000000000000000000000000000000000000000;;		n = p.PluralFormula(n)
0000000000000000000000000000000000000000;;		if ss := p.findMsgStrPlural(msgctxt, msgid, msgidPlural); len(ss) != 0 {
0000000000000000000000000000000000000000;;			if n >= len(ss) {
0000000000000000000000000000000000000000;;				n = len(ss) - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ss[n] != "" {
0000000000000000000000000000000000000000;;				return ss[n]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msgidPlural != "" && n > 0 {
0000000000000000000000000000000000000000;;			return msgidPlural
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msgid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *translator) findMsgStrPlural(msgctxt, msgid, msgidPlural string) []string {
0000000000000000000000000000000000000000;;		key := p.makeMapKey(msgctxt, msgid)
0000000000000000000000000000000000000000;;		if v, ok := p.MessageMap[key]; ok {
0000000000000000000000000000000000000000;;			if len(v.MsgIdPlural) != 0 {
0000000000000000000000000000000000000000;;				if len(v.MsgStrPlural) != 0 {
0000000000000000000000000000000000000000;;					return v.MsgStrPlural
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if len(v.MsgStr) != 0 {
0000000000000000000000000000000000000000;;					return []string{v.MsgStr}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *translator) makeMapKey(msgctxt, msgid string) string {
0000000000000000000000000000000000000000;;		if msgctxt != "" {
0000000000000000000000000000000000000000;;			return msgctxt + mo.EotSeparator + msgid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msgid
0000000000000000000000000000000000000000;;	}
