0000000000000000000000000000000000000000;;	// Copyright 2013 ChaiShushan <chaishushan{AT}gmail.com>. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
64247eb69ec8b8707eb5c766a35ff8a3cd455896;;	
0000000000000000000000000000000000000000;;	package gettext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"archive/zip"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fileSystem struct {
0000000000000000000000000000000000000000;;		FsName    string
0000000000000000000000000000000000000000;;		FsRoot    string
0000000000000000000000000000000000000000;;		FsZipData []byte
0000000000000000000000000000000000000000;;		LocaleMap map[string]bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFileSystem(path string, data []byte) *fileSystem {
0000000000000000000000000000000000000000;;		fs := &fileSystem{
0000000000000000000000000000000000000000;;			FsName:    path,
0000000000000000000000000000000000000000;;			FsZipData: data,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := fs.init(); err != nil {
0000000000000000000000000000000000000000;;			log.Printf("gettext-go: invalid domain, err = %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fileSystem) init() error {
0000000000000000000000000000000000000000;;		zipName := func(name string) string {
0000000000000000000000000000000000000000;;			if x := strings.LastIndexAny(name, `\/`); x != -1 {
0000000000000000000000000000000000000000;;				name = name[x+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name = strings.TrimSuffix(name, ".zip")
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// zip data
0000000000000000000000000000000000000000;;		if len(p.FsZipData) != 0 {
0000000000000000000000000000000000000000;;			p.FsRoot = zipName(p.FsName)
0000000000000000000000000000000000000000;;			p.LocaleMap = p.lsZip(p.FsZipData)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// local dir or zip file
0000000000000000000000000000000000000000;;		fi, err := os.Stat(p.FsName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// local dir
0000000000000000000000000000000000000000;;		if fi.IsDir() {
0000000000000000000000000000000000000000;;			p.FsRoot = p.FsName
0000000000000000000000000000000000000000;;			p.LocaleMap = p.lsDir(p.FsName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// local zip file
0000000000000000000000000000000000000000;;		p.FsZipData, err = ioutil.ReadFile(p.FsName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.FsRoot = zipName(p.FsName)
0000000000000000000000000000000000000000;;		p.LocaleMap = p.lsZip(p.FsZipData)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fileSystem) LoadMessagesFile(domain, local, ext string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(p.FsZipData) == 0 {
0000000000000000000000000000000000000000;;			trName := p.makeMessagesFileName(domain, local, ext)
0000000000000000000000000000000000000000;;			rcData, err := ioutil.ReadFile(trName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rcData, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r, err := zip.NewReader(bytes.NewReader(p.FsZipData), int64(len(p.FsZipData)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			trName := p.makeMessagesFileName(domain, local, ext)
0000000000000000000000000000000000000000;;			for _, f := range r.File {
0000000000000000000000000000000000000000;;				if f.Name != trName {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rc, err := f.Open()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rcData, err := ioutil.ReadAll(rc)
0000000000000000000000000000000000000000;;				rc.Close()
0000000000000000000000000000000000000000;;				return rcData, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fileSystem) LoadResourceFile(domain, local, name string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(p.FsZipData) == 0 {
0000000000000000000000000000000000000000;;			rcName := p.makeResourceFileName(domain, local, name)
0000000000000000000000000000000000000000;;			rcData, err := ioutil.ReadFile(rcName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rcData, nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r, err := zip.NewReader(bytes.NewReader(p.FsZipData), int64(len(p.FsZipData)))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rcName := p.makeResourceFileName(domain, local, name)
0000000000000000000000000000000000000000;;			for _, f := range r.File {
0000000000000000000000000000000000000000;;				if f.Name != rcName {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rc, err := f.Open()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rcData, err := ioutil.ReadAll(rc)
0000000000000000000000000000000000000000;;				rc.Close()
0000000000000000000000000000000000000000;;				return rcData, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("not found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fileSystem) makeMessagesFileName(domain, local, ext string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s/LC_MESSAGES/%s%s", p.FsRoot, local, domain, ext)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fileSystem) makeResourceFileName(domain, local, name string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s/%s/LC_RESOURCE/%s/%s", p.FsRoot, local, domain, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fileSystem) lsZip(data []byte) map[string]bool {
0000000000000000000000000000000000000000;;		r, err := zip.NewReader(bytes.NewReader(data), int64(len(data)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ssMap := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, f := range r.File {
0000000000000000000000000000000000000000;;			if x := strings.Index(f.Name, "LC_MESSAGES"); x != -1 {
0000000000000000000000000000000000000000;;				s := strings.TrimRight(f.Name[:x], `\/`)
0000000000000000000000000000000000000000;;				if x = strings.LastIndexAny(s, `\/`); x != -1 {
0000000000000000000000000000000000000000;;					s = s[x+1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if s != "" {
0000000000000000000000000000000000000000;;					ssMap[s] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if x := strings.Index(f.Name, "LC_RESOURCE"); x != -1 {
0000000000000000000000000000000000000000;;				s := strings.TrimRight(f.Name[:x], `\/`)
0000000000000000000000000000000000000000;;				if x = strings.LastIndexAny(s, `\/`); x != -1 {
0000000000000000000000000000000000000000;;					s = s[x+1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if s != "" {
0000000000000000000000000000000000000000;;					ssMap[s] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ssMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *fileSystem) lsDir(path string) map[string]bool {
0000000000000000000000000000000000000000;;		list, err := ioutil.ReadDir(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ssMap := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, dir := range list {
0000000000000000000000000000000000000000;;			if dir.IsDir() {
0000000000000000000000000000000000000000;;				ssMap[dir.Name()] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ssMap
0000000000000000000000000000000000000000;;	}
