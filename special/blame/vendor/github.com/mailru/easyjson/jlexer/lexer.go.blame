0000000000000000000000000000000000000000;;	// Package jlexer contains a JSON lexer implementation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is expected that it is mostly used with generated parser code, so the interface is tuned
0000000000000000000000000000000000000000;;	// for a parser that knows what kind of data is expected.
0000000000000000000000000000000000000000;;	package jlexer
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tokenKind determines type of a token.
0000000000000000000000000000000000000000;;	type tokenKind byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tokenUndef  tokenKind = iota // No token.
0000000000000000000000000000000000000000;;		tokenDelim                   // Delimiter: one of '{', '}', '[' or ']'.
0000000000000000000000000000000000000000;;		tokenString                  // A string literal, e.g. "abc\u1234"
0000000000000000000000000000000000000000;;		tokenNumber                  // Number literal, e.g. 1.5e5
0000000000000000000000000000000000000000;;		tokenBool                    // Boolean literal: true or false.
0000000000000000000000000000000000000000;;		tokenNull                    // null keyword.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// token describes a single token: type, position in the input and value.
0000000000000000000000000000000000000000;;	type token struct {
0000000000000000000000000000000000000000;;		kind tokenKind // Type of a token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		boolValue  bool   // Value if a boolean literal token.
0000000000000000000000000000000000000000;;		byteValue  []byte // Raw value of a token.
0000000000000000000000000000000000000000;;		delimValue byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lexer is a JSON lexer: it iterates over JSON tokens in a byte slice.
0000000000000000000000000000000000000000;;	type Lexer struct {
0000000000000000000000000000000000000000;;		Data []byte // Input data given to the lexer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		start int   // Start of the current token.
0000000000000000000000000000000000000000;;		pos   int   // Current unscanned position in the input stream.
0000000000000000000000000000000000000000;;		token token // Last scanned token, if token.kind != tokenUndef.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		firstElement bool // Whether current element is the first in array or an object.
0000000000000000000000000000000000000000;;		wantSep      byte // A comma or a colon character, which need to occur before a token.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err error // Error encountered during lexing, if any.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fetchToken scans the input for the next token.
0000000000000000000000000000000000000000;;	func (r *Lexer) fetchToken() {
0000000000000000000000000000000000000000;;		r.token.kind = tokenUndef
0000000000000000000000000000000000000000;;		r.start = r.pos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if r.Data has r.pos element
0000000000000000000000000000000000000000;;		// If it doesn't, it mean corrupted input data
0000000000000000000000000000000000000000;;		if len(r.Data) < r.pos {
0000000000000000000000000000000000000000;;			r.errParse("Unexpected end of data")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Determine the type of a token by skipping whitespace and reading the
0000000000000000000000000000000000000000;;		// first character.
0000000000000000000000000000000000000000;;		for _, c := range r.Data[r.pos:] {
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case ':', ',':
0000000000000000000000000000000000000000;;				if r.wantSep == c {
0000000000000000000000000000000000000000;;					r.pos++
0000000000000000000000000000000000000000;;					r.start++
0000000000000000000000000000000000000000;;					r.wantSep = 0
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ' ', '\t', '\r', '\n':
0000000000000000000000000000000000000000;;				r.pos++
0000000000000000000000000000000000000000;;				r.start++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				if r.wantSep != 0 {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r.token.kind = tokenString
0000000000000000000000000000000000000000;;				r.fetchString()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '{', '[':
0000000000000000000000000000000000000000;;				if r.wantSep != 0 {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.firstElement = true
0000000000000000000000000000000000000000;;				r.token.kind = tokenDelim
0000000000000000000000000000000000000000;;				r.token.delimValue = r.Data[r.pos]
0000000000000000000000000000000000000000;;				r.pos++
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '}', ']':
0000000000000000000000000000000000000000;;				if !r.firstElement && (r.wantSep != ',') {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.wantSep = 0
0000000000000000000000000000000000000000;;				r.token.kind = tokenDelim
0000000000000000000000000000000000000000;;				r.token.delimValue = r.Data[r.pos]
0000000000000000000000000000000000000000;;				r.pos++
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-':
0000000000000000000000000000000000000000;;				if r.wantSep != 0 {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.token.kind = tokenNumber
0000000000000000000000000000000000000000;;				r.fetchNumber()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case 'n':
0000000000000000000000000000000000000000;;				if r.wantSep != 0 {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r.token.kind = tokenNull
0000000000000000000000000000000000000000;;				r.fetchNull()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case 't':
0000000000000000000000000000000000000000;;				if r.wantSep != 0 {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r.token.kind = tokenBool
0000000000000000000000000000000000000000;;				r.token.boolValue = true
0000000000000000000000000000000000000000;;				r.fetchTrue()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case 'f':
0000000000000000000000000000000000000000;;				if r.wantSep != 0 {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				r.token.kind = tokenBool
0000000000000000000000000000000000000000;;				r.token.boolValue = false
0000000000000000000000000000000000000000;;				r.fetchFalse()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				r.errSyntax()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.err = io.EOF
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTokenEnd returns true if the char can follow a non-delimiter token
0000000000000000000000000000000000000000;;	func isTokenEnd(c byte) bool {
0000000000000000000000000000000000000000;;		return c == ' ' || c == '\t' || c == '\r' || c == '\n' || c == '[' || c == ']' || c == '{' || c == '}' || c == ',' || c == ':'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fetchNull fetches and checks remaining bytes of null keyword.
0000000000000000000000000000000000000000;;	func (r *Lexer) fetchNull() {
0000000000000000000000000000000000000000;;		r.pos += 4
0000000000000000000000000000000000000000;;		if r.pos > len(r.Data) ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-3] != 'u' ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-2] != 'l' ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-1] != 'l' ||
0000000000000000000000000000000000000000;;			(r.pos != len(r.Data) && !isTokenEnd(r.Data[r.pos])) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.pos -= 4
0000000000000000000000000000000000000000;;			r.errSyntax()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fetchTrue fetches and checks remaining bytes of true keyword.
0000000000000000000000000000000000000000;;	func (r *Lexer) fetchTrue() {
0000000000000000000000000000000000000000;;		r.pos += 4
0000000000000000000000000000000000000000;;		if r.pos > len(r.Data) ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-3] != 'r' ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-2] != 'u' ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-1] != 'e' ||
0000000000000000000000000000000000000000;;			(r.pos != len(r.Data) && !isTokenEnd(r.Data[r.pos])) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.pos -= 4
0000000000000000000000000000000000000000;;			r.errSyntax()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fetchFalse fetches and checks remaining bytes of false keyword.
0000000000000000000000000000000000000000;;	func (r *Lexer) fetchFalse() {
0000000000000000000000000000000000000000;;		r.pos += 5
0000000000000000000000000000000000000000;;		if r.pos > len(r.Data) ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-4] != 'a' ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-3] != 'l' ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-2] != 's' ||
0000000000000000000000000000000000000000;;			r.Data[r.pos-1] != 'e' ||
0000000000000000000000000000000000000000;;			(r.pos != len(r.Data) && !isTokenEnd(r.Data[r.pos])) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r.pos -= 5
0000000000000000000000000000000000000000;;			r.errSyntax()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bytesToStr creates a string pointing at the slice to avoid copying.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Warning: the string returned by the function should be used with care, as the whole input data
0000000000000000000000000000000000000000;;	// chunk may be either blocked from being freed by GC because of a single string or the buffer.Data
0000000000000000000000000000000000000000;;	// may be garbage-collected even when the string exists.
0000000000000000000000000000000000000000;;	func bytesToStr(data []byte) string {
0000000000000000000000000000000000000000;;		h := (*reflect.SliceHeader)(unsafe.Pointer(&data))
0000000000000000000000000000000000000000;;		shdr := reflect.StringHeader{h.Data, h.Len}
0000000000000000000000000000000000000000;;		return *(*string)(unsafe.Pointer(&shdr))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fetchNumber scans a number literal token.
0000000000000000000000000000000000000000;;	func (r *Lexer) fetchNumber() {
0000000000000000000000000000000000000000;;		hasE := false
0000000000000000000000000000000000000000;;		afterE := false
0000000000000000000000000000000000000000;;		hasDot := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.pos++
0000000000000000000000000000000000000000;;		for i, c := range r.Data[r.pos:] {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case c >= '0' && c <= '9':
0000000000000000000000000000000000000000;;				afterE = false
0000000000000000000000000000000000000000;;			case c == '.' && !hasDot:
0000000000000000000000000000000000000000;;				hasDot = true
0000000000000000000000000000000000000000;;			case (c == 'e' || c == 'E') && !hasE:
0000000000000000000000000000000000000000;;				hasE = true
0000000000000000000000000000000000000000;;				hasDot = true
0000000000000000000000000000000000000000;;				afterE = true
0000000000000000000000000000000000000000;;			case (c == '+' || c == '-') && afterE:
0000000000000000000000000000000000000000;;				afterE = false
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				r.pos += i
0000000000000000000000000000000000000000;;				if !isTokenEnd(c) {
0000000000000000000000000000000000000000;;					r.errSyntax()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					r.token.byteValue = r.Data[r.start:r.pos]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.pos = len(r.Data)
0000000000000000000000000000000000000000;;		r.token.byteValue = r.Data[r.start:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findStringLen tries to scan into the string literal for ending quote char to determine required size.
0000000000000000000000000000000000000000;;	// The size will be exact if no escapes are present and may be inexact if there are escaped chars.
0000000000000000000000000000000000000000;;	func findStringLen(data []byte) (hasEscapes bool, length int) {
0000000000000000000000000000000000000000;;		delta := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(data); i++ {
0000000000000000000000000000000000000000;;			switch data[i] {
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				delta++
0000000000000000000000000000000000000000;;				if i < len(data) && data[i] == 'u' {
0000000000000000000000000000000000000000;;					delta++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				return (delta > 0), (i - delta)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, len(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// processEscape processes a single escape sequence and returns number of bytes processed.
0000000000000000000000000000000000000000;;	func (r *Lexer) processEscape(data []byte) (int, error) {
0000000000000000000000000000000000000000;;		if len(data) < 2 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("syntax error at %v", string(data))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := data[1]
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '"', '/', '\\':
0000000000000000000000000000000000000000;;			r.token.byteValue = append(r.token.byteValue, c)
0000000000000000000000000000000000000000;;			return 2, nil
0000000000000000000000000000000000000000;;		case 'b':
0000000000000000000000000000000000000000;;			r.token.byteValue = append(r.token.byteValue, '\b')
0000000000000000000000000000000000000000;;			return 2, nil
0000000000000000000000000000000000000000;;		case 'f':
0000000000000000000000000000000000000000;;			r.token.byteValue = append(r.token.byteValue, '\f')
0000000000000000000000000000000000000000;;			return 2, nil
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			r.token.byteValue = append(r.token.byteValue, '\n')
0000000000000000000000000000000000000000;;			return 2, nil
0000000000000000000000000000000000000000;;		case 'r':
0000000000000000000000000000000000000000;;			r.token.byteValue = append(r.token.byteValue, '\r')
0000000000000000000000000000000000000000;;			return 2, nil
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			r.token.byteValue = append(r.token.byteValue, '\t')
0000000000000000000000000000000000000000;;			return 2, nil
0000000000000000000000000000000000000000;;		case 'u':
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("syntax error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var val rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 2; i < len(data) && i < 6; i++ {
0000000000000000000000000000000000000000;;			var v byte
0000000000000000000000000000000000000000;;			c = data[i]
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
0000000000000000000000000000000000000000;;				v = c - '0'
0000000000000000000000000000000000000000;;			case 'a', 'b', 'c', 'd', 'e', 'f':
0000000000000000000000000000000000000000;;				v = c - 'a' + 10
0000000000000000000000000000000000000000;;			case 'A', 'B', 'C', 'D', 'E', 'F':
0000000000000000000000000000000000000000;;				v = c - 'A' + 10
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("syntax error")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			val <<= 4
0000000000000000000000000000000000000000;;			val |= rune(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := utf8.RuneLen(val)
0000000000000000000000000000000000000000;;		if l == -1 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid unicode escape")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var d [4]byte
0000000000000000000000000000000000000000;;		utf8.EncodeRune(d[:], val)
0000000000000000000000000000000000000000;;		r.token.byteValue = append(r.token.byteValue, d[:l]...)
0000000000000000000000000000000000000000;;		return 6, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fetchString scans a string literal token.
0000000000000000000000000000000000000000;;	func (r *Lexer) fetchString() {
0000000000000000000000000000000000000000;;		r.pos++
0000000000000000000000000000000000000000;;		data := r.Data[r.pos:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasEscapes, length := findStringLen(data)
0000000000000000000000000000000000000000;;		if !hasEscapes {
0000000000000000000000000000000000000000;;			r.token.byteValue = data[:length]
0000000000000000000000000000000000000000;;			r.pos += length + 1
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.token.byteValue = make([]byte, 0, length)
0000000000000000000000000000000000000000;;		p := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(data); {
0000000000000000000000000000000000000000;;			switch data[i] {
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				r.pos += i + 1
0000000000000000000000000000000000000000;;				r.token.byteValue = append(r.token.byteValue, data[p:i]...)
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				r.token.byteValue = append(r.token.byteValue, data[p:i]...)
0000000000000000000000000000000000000000;;				off, err := r.processEscape(data[i:])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					r.errParse(err.Error())
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i += off
0000000000000000000000000000000000000000;;				p = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.errParse("unterminated string literal")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanToken scans the next token if no token is currently available in the lexer.
0000000000000000000000000000000000000000;;	func (r *Lexer) scanToken() {
0000000000000000000000000000000000000000;;		if r.token.kind != tokenUndef || r.err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.fetchToken()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// consume resets the current token to allow scanning the next one.
0000000000000000000000000000000000000000;;	func (r *Lexer) consume() {
0000000000000000000000000000000000000000;;		r.token.kind = tokenUndef
0000000000000000000000000000000000000000;;		r.token.delimValue = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ok returns true if no error (including io.EOF) was encountered during scanning.
0000000000000000000000000000000000000000;;	func (r *Lexer) Ok() bool {
0000000000000000000000000000000000000000;;		return r.err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxErrorContextLen = 13
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) errParse(what string) {
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			var str string
0000000000000000000000000000000000000000;;			if len(r.Data)-r.pos <= maxErrorContextLen {
0000000000000000000000000000000000000000;;				str = string(r.Data)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				str = string(r.Data[r.pos:r.pos+maxErrorContextLen-3]) + "..."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: what,
0000000000000000000000000000000000000000;;				Offset: r.pos,
0000000000000000000000000000000000000000;;				Data:   str,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) errSyntax() {
0000000000000000000000000000000000000000;;		r.errParse("syntax error")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) errInvalidToken(expected string) {
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			var str string
0000000000000000000000000000000000000000;;			if len(r.token.byteValue) <= maxErrorContextLen {
0000000000000000000000000000000000000000;;				str = string(r.token.byteValue)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				str = string(r.token.byteValue[:maxErrorContextLen-3]) + "..."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: fmt.Sprintf("expected %s", expected),
0000000000000000000000000000000000000000;;				Offset: r.pos,
0000000000000000000000000000000000000000;;				Data:   str,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delim consumes a token and verifies that it is the given delimiter.
0000000000000000000000000000000000000000;;	func (r *Lexer) Delim(c byte) {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.Ok() || r.token.delimValue != c {
0000000000000000000000000000000000000000;;			r.errInvalidToken(string([]byte{c}))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDelim returns true if there was no scanning error and next token is the given delimiter.
0000000000000000000000000000000000000000;;	func (r *Lexer) IsDelim(c byte) bool {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return !r.Ok() || r.token.delimValue == c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Null verifies that the next token is null and consumes it.
0000000000000000000000000000000000000000;;	func (r *Lexer) Null() {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.Ok() || r.token.kind != tokenNull {
0000000000000000000000000000000000000000;;			r.errInvalidToken("null")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNull returns true if the next token is a null keyword.
0000000000000000000000000000000000000000;;	func (r *Lexer) IsNull() bool {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.Ok() && r.token.kind == tokenNull
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Skip skips a single token.
0000000000000000000000000000000000000000;;	func (r *Lexer) Skip() {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SkipRecursive skips next array or object completely, or just skips a single token if not
0000000000000000000000000000000000000000;;	// an array/object.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: no syntax validation is performed on the skipped data.
0000000000000000000000000000000000000000;;	func (r *Lexer) SkipRecursive() {
0000000000000000000000000000000000000000;;		r.scanToken()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var start, end byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.token.delimValue == '{' {
0000000000000000000000000000000000000000;;			start, end = '{', '}'
0000000000000000000000000000000000000000;;		} else if r.token.delimValue == '[' {
0000000000000000000000000000000000000000;;			start, end = '[', ']'
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r.consume()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		level := 1
0000000000000000000000000000000000000000;;		inQuotes := false
0000000000000000000000000000000000000000;;		wasEscape := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, c := range r.Data[r.pos:] {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case c == start && !inQuotes:
0000000000000000000000000000000000000000;;				level++
0000000000000000000000000000000000000000;;			case c == end && !inQuotes:
0000000000000000000000000000000000000000;;				level--
0000000000000000000000000000000000000000;;				if level == 0 {
0000000000000000000000000000000000000000;;					r.pos += i + 1
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case c == '\\' && inQuotes:
0000000000000000000000000000000000000000;;				wasEscape = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case c == '"' && inQuotes:
0000000000000000000000000000000000000000;;				inQuotes = wasEscape
0000000000000000000000000000000000000000;;			case c == '"':
0000000000000000000000000000000000000000;;				inQuotes = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wasEscape = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.pos = len(r.Data)
0000000000000000000000000000000000000000;;		r.err = io.EOF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw fetches the next item recursively as a data slice
0000000000000000000000000000000000000000;;	func (r *Lexer) Raw() []byte {
0000000000000000000000000000000000000000;;		r.SkipRecursive()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.Data[r.start:r.pos]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsafeString returns the string value if the token is a string literal.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Warning: returned string may point to the input buffer, so the string should not outlive
0000000000000000000000000000000000000000;;	// the input buffer. Intended pattern of usage is as an argument to a switch statement.
0000000000000000000000000000000000000000;;	func (r *Lexer) UnsafeString() string {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.Ok() || r.token.kind != tokenString {
0000000000000000000000000000000000000000;;			r.errInvalidToken("string")
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := bytesToStr(r.token.byteValue)
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String reads a string literal.
0000000000000000000000000000000000000000;;	func (r *Lexer) String() string {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.Ok() || r.token.kind != tokenString {
0000000000000000000000000000000000000000;;			r.errInvalidToken("string")
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := string(r.token.byteValue)
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bool reads a true or false boolean keyword.
0000000000000000000000000000000000000000;;	func (r *Lexer) Bool() bool {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.Ok() || r.token.kind != tokenBool {
0000000000000000000000000000000000000000;;			r.errInvalidToken("bool")
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := r.token.boolValue
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) number() string {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.Ok() || r.token.kind != tokenNumber {
0000000000000000000000000000000000000000;;			r.errInvalidToken("number")
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := bytesToStr(r.token.byteValue)
0000000000000000000000000000000000000000;;		r.consume()
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint8() uint8 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 8)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint8(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint16() uint16 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint16(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint32() uint32 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint32(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint64() uint64 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint() uint {
0000000000000000000000000000000000000000;;		return uint(r.Uint64())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int8() int8 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 8)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int8(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int16() int16 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int16(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int32() int32 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int32(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int64() int64 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int() int {
0000000000000000000000000000000000000000;;		return int(r.Int64())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint8Str() uint8 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 8)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint8(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint16Str() uint16 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint16(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint32Str() uint32 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint32(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Uint64Str() uint64 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) UintStr() uint {
0000000000000000000000000000000000000000;;		return uint(r.Uint64Str())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int8Str() int8 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 8)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int8(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int16Str() int16 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 16)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int16(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int32Str() int32 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int32(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Int64Str() int64 {
0000000000000000000000000000000000000000;;		s := r.UnsafeString()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseInt(s, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) IntStr() int {
0000000000000000000000000000000000000000;;		return int(r.Int64Str())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Float32() float32 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseFloat(s, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return float32(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Float64() float64 {
0000000000000000000000000000000000000000;;		s := r.number()
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := strconv.ParseFloat(s, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.err = &LexerError{
0000000000000000000000000000000000000000;;				Reason: err.Error(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) Error() error {
0000000000000000000000000000000000000000;;		return r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Lexer) AddError(e error) {
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			r.err = e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface fetches an interface{} analogous to the 'encoding/json' package.
0000000000000000000000000000000000000000;;	func (r *Lexer) Interface() interface{} {
0000000000000000000000000000000000000000;;		if r.token.kind == tokenUndef && r.Ok() {
0000000000000000000000000000000000000000;;			r.fetchToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !r.Ok() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch r.token.kind {
0000000000000000000000000000000000000000;;		case tokenString:
0000000000000000000000000000000000000000;;			return r.String()
0000000000000000000000000000000000000000;;		case tokenNumber:
0000000000000000000000000000000000000000;;			return r.Float64()
0000000000000000000000000000000000000000;;		case tokenBool:
0000000000000000000000000000000000000000;;			return r.Bool()
0000000000000000000000000000000000000000;;		case tokenNull:
0000000000000000000000000000000000000000;;			r.Null()
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.token.delimValue == '{' {
0000000000000000000000000000000000000000;;			r.consume()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret := map[string]interface{}{}
0000000000000000000000000000000000000000;;			for !r.IsDelim('}') {
0000000000000000000000000000000000000000;;				key := r.String()
0000000000000000000000000000000000000000;;				r.WantColon()
0000000000000000000000000000000000000000;;				ret[key] = r.Interface()
0000000000000000000000000000000000000000;;				r.WantComma()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Delim('}')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.Ok() {
0000000000000000000000000000000000000000;;				return ret
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if r.token.delimValue == '[' {
0000000000000000000000000000000000000000;;			r.consume()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var ret []interface{}
0000000000000000000000000000000000000000;;			for !r.IsDelim(']') {
0000000000000000000000000000000000000000;;				ret = append(ret, r.Interface())
0000000000000000000000000000000000000000;;				r.WantComma()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.Delim(']')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.Ok() {
0000000000000000000000000000000000000000;;				return ret
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.errSyntax()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WantComma requires a comma to be present before fetching next token.
0000000000000000000000000000000000000000;;	func (r *Lexer) WantComma() {
0000000000000000000000000000000000000000;;		r.wantSep = ','
0000000000000000000000000000000000000000;;		r.firstElement = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WantColon requires a colon to be present before fetching next token.
0000000000000000000000000000000000000000;;	func (r *Lexer) WantColon() {
0000000000000000000000000000000000000000;;		r.wantSep = ':'
0000000000000000000000000000000000000000;;		r.firstElement = false
0000000000000000000000000000000000000000;;	}
