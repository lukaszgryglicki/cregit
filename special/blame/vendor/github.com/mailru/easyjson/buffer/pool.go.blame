0000000000000000000000000000000000000000;;	// Package buffer implements a buffer for serialization, consisting of a chain of []byte-s to
0000000000000000000000000000000000000000;;	// reduce copying and to allow reuse of individual chunks.
0000000000000000000000000000000000000000;;	package buffer
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PoolConfig contains configuration for the allocation and reuse strategy.
0000000000000000000000000000000000000000;;	type PoolConfig struct {
0000000000000000000000000000000000000000;;		StartSize  int // Minimum chunk size that is allocated.
0000000000000000000000000000000000000000;;		PooledSize int // Minimum chunk size that is reused, reusing chunks too small will result in overhead.
0000000000000000000000000000000000000000;;		MaxSize    int // Maximum chunk size that will be allocated.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var config = PoolConfig{
0000000000000000000000000000000000000000;;		StartSize:  128,
0000000000000000000000000000000000000000;;		PooledSize: 512,
0000000000000000000000000000000000000000;;		MaxSize:    32768,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reuse pool: chunk size -> pool.
0000000000000000000000000000000000000000;;	var buffers = map[int]*sync.Pool{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initBuffers() {
0000000000000000000000000000000000000000;;		for l := config.PooledSize; l <= config.MaxSize; l *= 2 {
0000000000000000000000000000000000000000;;			buffers[l] = new(sync.Pool)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		initBuffers()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init sets up a non-default pooling and allocation strategy. Should be run before serialization is done.
0000000000000000000000000000000000000000;;	func Init(cfg PoolConfig) {
0000000000000000000000000000000000000000;;		config = cfg
0000000000000000000000000000000000000000;;		initBuffers()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// putBuf puts a chunk to reuse pool if it can be reused.
0000000000000000000000000000000000000000;;	func putBuf(buf []byte) {
0000000000000000000000000000000000000000;;		size := cap(buf)
0000000000000000000000000000000000000000;;		if size < config.PooledSize {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c := buffers[size]; c != nil {
0000000000000000000000000000000000000000;;			c.Put(buf[:0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getBuf gets a chunk from reuse pool or creates a new one if reuse failed.
0000000000000000000000000000000000000000;;	func getBuf(size int) []byte {
0000000000000000000000000000000000000000;;		if size < config.PooledSize {
0000000000000000000000000000000000000000;;			return make([]byte, 0, size)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c := buffers[size]; c != nil {
0000000000000000000000000000000000000000;;			v := c.Get()
0000000000000000000000000000000000000000;;			if v != nil {
0000000000000000000000000000000000000000;;				return v.([]byte)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return make([]byte, 0, size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Buffer is a buffer optimized for serialization without extra copying.
0000000000000000000000000000000000000000;;	type Buffer struct {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Buf is the current chunk that can be used for serialization.
0000000000000000000000000000000000000000;;		Buf []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		toPool []byte
0000000000000000000000000000000000000000;;		bufs   [][]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnsureSpace makes sure that the current chunk contains at least s free bytes,
0000000000000000000000000000000000000000;;	// possibly creating a new chunk.
0000000000000000000000000000000000000000;;	func (b *Buffer) EnsureSpace(s int) {
0000000000000000000000000000000000000000;;		if cap(b.Buf)-len(b.Buf) >= s {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := len(b.Buf)
0000000000000000000000000000000000000000;;		if l > 0 {
0000000000000000000000000000000000000000;;			if cap(b.toPool) != cap(b.Buf) {
0000000000000000000000000000000000000000;;				// Chunk was reallocated, toPool can be pooled.
0000000000000000000000000000000000000000;;				putBuf(b.toPool)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cap(b.bufs) == 0 {
0000000000000000000000000000000000000000;;				b.bufs = make([][]byte, 0, 8)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.bufs = append(b.bufs, b.Buf)
0000000000000000000000000000000000000000;;			l = cap(b.toPool) * 2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			l = config.StartSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l > config.MaxSize {
0000000000000000000000000000000000000000;;			l = config.MaxSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.Buf = getBuf(l)
0000000000000000000000000000000000000000;;		b.toPool = b.Buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendByte appends a single byte to buffer.
0000000000000000000000000000000000000000;;	func (b *Buffer) AppendByte(data byte) {
0000000000000000000000000000000000000000;;		if cap(b.Buf) == len(b.Buf) { // EnsureSpace won't be inlined.
0000000000000000000000000000000000000000;;			b.EnsureSpace(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.Buf = append(b.Buf, data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendBytes appends a byte slice to buffer.
0000000000000000000000000000000000000000;;	func (b *Buffer) AppendBytes(data []byte) {
0000000000000000000000000000000000000000;;		for len(data) > 0 {
0000000000000000000000000000000000000000;;			if cap(b.Buf) == len(b.Buf) { // EnsureSpace won't be inlined.
0000000000000000000000000000000000000000;;				b.EnsureSpace(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sz := cap(b.Buf) - len(b.Buf)
0000000000000000000000000000000000000000;;			if sz > len(data) {
0000000000000000000000000000000000000000;;				sz = len(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b.Buf = append(b.Buf, data[:sz]...)
0000000000000000000000000000000000000000;;			data = data[sz:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendBytes appends a string to buffer.
0000000000000000000000000000000000000000;;	func (b *Buffer) AppendString(data string) {
0000000000000000000000000000000000000000;;		for len(data) > 0 {
0000000000000000000000000000000000000000;;			if cap(b.Buf) == len(b.Buf) { // EnsureSpace won't be inlined.
0000000000000000000000000000000000000000;;				b.EnsureSpace(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sz := cap(b.Buf) - len(b.Buf)
0000000000000000000000000000000000000000;;			if sz > len(data) {
0000000000000000000000000000000000000000;;				sz = len(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b.Buf = append(b.Buf, data[:sz]...)
0000000000000000000000000000000000000000;;			data = data[sz:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size computes the size of a buffer by adding sizes of every chunk.
0000000000000000000000000000000000000000;;	func (b *Buffer) Size() int {
0000000000000000000000000000000000000000;;		size := len(b.Buf)
0000000000000000000000000000000000000000;;		for _, buf := range b.bufs {
0000000000000000000000000000000000000000;;			size += len(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DumpTo outputs the contents of a buffer to a writer and resets the buffer.
0000000000000000000000000000000000000000;;	func (b *Buffer) DumpTo(w io.Writer) (written int, err error) {
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		for _, buf := range b.bufs {
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				n, err = w.Write(buf)
0000000000000000000000000000000000000000;;				written += n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			putBuf(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			n, err = w.Write(b.Buf)
0000000000000000000000000000000000000000;;			written += n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		putBuf(b.toPool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.bufs = nil
0000000000000000000000000000000000000000;;		b.Buf = nil
0000000000000000000000000000000000000000;;		b.toPool = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildBytes creates a single byte slice with all the contents of the buffer. Data is
0000000000000000000000000000000000000000;;	// copied if it does not fit in a single chunk.
0000000000000000000000000000000000000000;;	func (b *Buffer) BuildBytes() []byte {
0000000000000000000000000000000000000000;;		if len(b.bufs) == 0 {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret := b.Buf
0000000000000000000000000000000000000000;;			b.toPool = nil
0000000000000000000000000000000000000000;;			b.Buf = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := make([]byte, 0, b.Size())
0000000000000000000000000000000000000000;;		for _, buf := range b.bufs {
0000000000000000000000000000000000000000;;			ret = append(ret, buf...)
0000000000000000000000000000000000000000;;			putBuf(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret = append(ret, b.Buf...)
0000000000000000000000000000000000000000;;		putBuf(b.toPool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.bufs = nil
0000000000000000000000000000000000000000;;		b.toPool = nil
0000000000000000000000000000000000000000;;		b.Buf = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
