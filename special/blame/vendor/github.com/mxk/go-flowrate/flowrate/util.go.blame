0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Written by Maxim Khitrov (November 2012)
0000000000000000000000000000000000000000;;	//
6b5b8837ca67322e3cfdf691ba47d2abdd617d8a;Godeps/_workspace/src/github.com/mxk/go-flowrate/flowrate/util.go[Godeps/_workspace/src/github.com/mxk/go-flowrate/flowrate/util.go][vendor/github.com/mxk/go-flowrate/flowrate/util.go];	
0000000000000000000000000000000000000000;;	package flowrate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clockRate is the resolution and precision of clock().
0000000000000000000000000000000000000000;;	const clockRate = 20 * time.Millisecond
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// czero is the process start time rounded down to the nearest clockRate
0000000000000000000000000000000000000000;;	// increment.
0000000000000000000000000000000000000000;;	var czero = time.Duration(time.Now().UnixNano()) / clockRate * clockRate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clock returns a low resolution timestamp relative to the process start time.
0000000000000000000000000000000000000000;;	func clock() time.Duration {
0000000000000000000000000000000000000000;;		return time.Duration(time.Now().UnixNano())/clockRate*clockRate - czero
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clockToTime converts a clock() timestamp to an absolute time.Time value.
0000000000000000000000000000000000000000;;	func clockToTime(c time.Duration) time.Time {
0000000000000000000000000000000000000000;;		return time.Unix(0, int64(czero+c))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// clockRound returns d rounded to the nearest clockRate increment.
0000000000000000000000000000000000000000;;	func clockRound(d time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		return (d + clockRate>>1) / clockRate * clockRate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// round returns x rounded to the nearest int64 (non-negative values only).
0000000000000000000000000000000000000000;;	func round(x float64) int64 {
0000000000000000000000000000000000000000;;		if _, frac := math.Modf(x); frac >= 0.5 {
0000000000000000000000000000000000000000;;			return int64(math.Ceil(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(math.Floor(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Percent represents a percentage in increments of 1/1000th of a percent.
0000000000000000000000000000000000000000;;	type Percent uint32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// percentOf calculates what percent of the total is x.
0000000000000000000000000000000000000000;;	func percentOf(x, total float64) Percent {
0000000000000000000000000000000000000000;;		if x < 0 || total <= 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		} else if p := round(x / total * 1e5); p <= math.MaxUint32 {
0000000000000000000000000000000000000000;;			return Percent(p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Percent(math.MaxUint32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Percent) Float() float64 {
0000000000000000000000000000000000000000;;		return float64(p) * 1e-3
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Percent) String() string {
0000000000000000000000000000000000000000;;		var buf [12]byte
0000000000000000000000000000000000000000;;		b := strconv.AppendUint(buf[:0], uint64(p)/1000, 10)
0000000000000000000000000000000000000000;;		n := len(b)
0000000000000000000000000000000000000000;;		b = strconv.AppendUint(b, 1000+uint64(p)%1000, 10)
0000000000000000000000000000000000000000;;		b[n] = '.'
0000000000000000000000000000000000000000;;		return string(append(b, '%'))
0000000000000000000000000000000000000000;;	}
