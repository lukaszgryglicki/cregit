0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Written by Maxim Khitrov (November 2012)
0000000000000000000000000000000000000000;;	//
6b5b8837ca67322e3cfdf691ba47d2abdd617d8a;Godeps/_workspace/src/github.com/mxk/go-flowrate/flowrate/flowrate.go[Godeps/_workspace/src/github.com/mxk/go-flowrate/flowrate/flowrate.go][vendor/github.com/mxk/go-flowrate/flowrate/flowrate.go];	
0000000000000000000000000000000000000000;;	// Package flowrate provides the tools for monitoring and limiting the flow rate
0000000000000000000000000000000000000000;;	// of an arbitrary data stream.
0000000000000000000000000000000000000000;;	package flowrate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Monitor monitors and limits the transfer rate of a data stream.
0000000000000000000000000000000000000000;;	type Monitor struct {
0000000000000000000000000000000000000000;;		mu      sync.Mutex    // Mutex guarding access to all internal fields
0000000000000000000000000000000000000000;;		active  bool          // Flag indicating an active transfer
0000000000000000000000000000000000000000;;		start   time.Duration // Transfer start time (clock() value)
0000000000000000000000000000000000000000;;		bytes   int64         // Total number of bytes transferred
0000000000000000000000000000000000000000;;		samples int64         // Total number of samples taken
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rSample float64 // Most recent transfer rate sample (bytes per second)
0000000000000000000000000000000000000000;;		rEMA    float64 // Exponential moving average of rSample
0000000000000000000000000000000000000000;;		rPeak   float64 // Peak transfer rate (max of all rSamples)
0000000000000000000000000000000000000000;;		rWindow float64 // rEMA window (seconds)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sBytes int64         // Number of bytes transferred since sLast
0000000000000000000000000000000000000000;;		sLast  time.Duration // Most recent sample time (stop time when inactive)
0000000000000000000000000000000000000000;;		sRate  time.Duration // Sampling rate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tBytes int64         // Number of bytes expected in the current transfer
0000000000000000000000000000000000000000;;		tLast  time.Duration // Time of the most recent transfer of at least 1 byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new flow control monitor. Instantaneous transfer rate is
0000000000000000000000000000000000000000;;	// measured and updated for each sampleRate interval. windowSize determines the
0000000000000000000000000000000000000000;;	// weight of each sample in the exponential moving average (EMA) calculation.
0000000000000000000000000000000000000000;;	// The exact formulas are:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	sampleTime = currentTime - prevSampleTime
0000000000000000000000000000000000000000;;	// 	sampleRate = byteCount / sampleTime
0000000000000000000000000000000000000000;;	// 	weight     = 1 - exp(-sampleTime/windowSize)
0000000000000000000000000000000000000000;;	// 	newRate    = weight*sampleRate + (1-weight)*oldRate
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The default values for sampleRate and windowSize (if <= 0) are 100ms and 1s,
0000000000000000000000000000000000000000;;	// respectively.
0000000000000000000000000000000000000000;;	func New(sampleRate, windowSize time.Duration) *Monitor {
0000000000000000000000000000000000000000;;		if sampleRate = clockRound(sampleRate); sampleRate <= 0 {
0000000000000000000000000000000000000000;;			sampleRate = 5 * clockRate
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if windowSize <= 0 {
0000000000000000000000000000000000000000;;			windowSize = 1 * time.Second
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := clock()
0000000000000000000000000000000000000000;;		return &Monitor{
0000000000000000000000000000000000000000;;			active:  true,
0000000000000000000000000000000000000000;;			start:   now,
0000000000000000000000000000000000000000;;			rWindow: windowSize.Seconds(),
0000000000000000000000000000000000000000;;			sLast:   now,
0000000000000000000000000000000000000000;;			sRate:   sampleRate,
0000000000000000000000000000000000000000;;			tLast:   now,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update records the transfer of n bytes and returns n. It should be called
0000000000000000000000000000000000000000;;	// after each Read/Write operation, even if n is 0.
0000000000000000000000000000000000000000;;	func (m *Monitor) Update(n int) int {
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		m.update(n)
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IO is a convenience method intended to wrap io.Reader and io.Writer method
0000000000000000000000000000000000000000;;	// execution. It calls m.Update(n) and then returns (n, err) unmodified.
0000000000000000000000000000000000000000;;	func (m *Monitor) IO(n int, err error) (int, error) {
0000000000000000000000000000000000000000;;		return m.Update(n), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Done marks the transfer as finished and prevents any further updates or
0000000000000000000000000000000000000000;;	// limiting. Instantaneous and current transfer rates drop to 0. Update, IO, and
0000000000000000000000000000000000000000;;	// Limit methods become NOOPs. It returns the total number of bytes transferred.
0000000000000000000000000000000000000000;;	func (m *Monitor) Done() int64 {
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		if now := m.update(0); m.sBytes > 0 {
0000000000000000000000000000000000000000;;			m.reset(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.active = false
0000000000000000000000000000000000000000;;		m.tLast = 0
0000000000000000000000000000000000000000;;		n := m.bytes
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// timeRemLimit is the maximum Status.TimeRem value.
0000000000000000000000000000000000000000;;	const timeRemLimit = 999*time.Hour + 59*time.Minute + 59*time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status represents the current Monitor status. All transfer rates are in bytes
0000000000000000000000000000000000000000;;	// per second rounded to the nearest byte.
0000000000000000000000000000000000000000;;	type Status struct {
0000000000000000000000000000000000000000;;		Active   bool          // Flag indicating an active transfer
0000000000000000000000000000000000000000;;		Start    time.Time     // Transfer start time
0000000000000000000000000000000000000000;;		Duration time.Duration // Time period covered by the statistics
0000000000000000000000000000000000000000;;		Idle     time.Duration // Time since the last transfer of at least 1 byte
0000000000000000000000000000000000000000;;		Bytes    int64         // Total number of bytes transferred
0000000000000000000000000000000000000000;;		Samples  int64         // Total number of samples taken
0000000000000000000000000000000000000000;;		InstRate int64         // Instantaneous transfer rate
0000000000000000000000000000000000000000;;		CurRate  int64         // Current transfer rate (EMA of InstRate)
0000000000000000000000000000000000000000;;		AvgRate  int64         // Average transfer rate (Bytes / Duration)
0000000000000000000000000000000000000000;;		PeakRate int64         // Maximum instantaneous transfer rate
0000000000000000000000000000000000000000;;		BytesRem int64         // Number of bytes remaining in the transfer
0000000000000000000000000000000000000000;;		TimeRem  time.Duration // Estimated time to completion
0000000000000000000000000000000000000000;;		Progress Percent       // Overall transfer progress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Status returns current transfer status information. The returned value
0000000000000000000000000000000000000000;;	// becomes static after a call to Done.
0000000000000000000000000000000000000000;;	func (m *Monitor) Status() Status {
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		now := m.update(0)
0000000000000000000000000000000000000000;;		s := Status{
0000000000000000000000000000000000000000;;			Active:   m.active,
0000000000000000000000000000000000000000;;			Start:    clockToTime(m.start),
0000000000000000000000000000000000000000;;			Duration: m.sLast - m.start,
0000000000000000000000000000000000000000;;			Idle:     now - m.tLast,
0000000000000000000000000000000000000000;;			Bytes:    m.bytes,
0000000000000000000000000000000000000000;;			Samples:  m.samples,
0000000000000000000000000000000000000000;;			PeakRate: round(m.rPeak),
0000000000000000000000000000000000000000;;			BytesRem: m.tBytes - m.bytes,
0000000000000000000000000000000000000000;;			Progress: percentOf(float64(m.bytes), float64(m.tBytes)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.BytesRem < 0 {
0000000000000000000000000000000000000000;;			s.BytesRem = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Duration > 0 {
0000000000000000000000000000000000000000;;			rAvg := float64(s.Bytes) / s.Duration.Seconds()
0000000000000000000000000000000000000000;;			s.AvgRate = round(rAvg)
0000000000000000000000000000000000000000;;			if s.Active {
0000000000000000000000000000000000000000;;				s.InstRate = round(m.rSample)
0000000000000000000000000000000000000000;;				s.CurRate = round(m.rEMA)
0000000000000000000000000000000000000000;;				if s.BytesRem > 0 {
0000000000000000000000000000000000000000;;					if tRate := 0.8*m.rEMA + 0.2*rAvg; tRate > 0 {
0000000000000000000000000000000000000000;;						ns := float64(s.BytesRem) / tRate * 1e9
0000000000000000000000000000000000000000;;						if ns > float64(timeRemLimit) {
0000000000000000000000000000000000000000;;							ns = float64(timeRemLimit)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						s.TimeRem = clockRound(time.Duration(ns))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Limit restricts the instantaneous (per-sample) data flow to rate bytes per
0000000000000000000000000000000000000000;;	// second. It returns the maximum number of bytes (0 <= n <= want) that may be
0000000000000000000000000000000000000000;;	// transferred immediately without exceeding the limit. If block == true, the
0000000000000000000000000000000000000000;;	// call blocks until n > 0. want is returned unmodified if want < 1, rate < 1,
0000000000000000000000000000000000000000;;	// or the transfer is inactive (after a call to Done).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// At least one byte is always allowed to be transferred in any given sampling
0000000000000000000000000000000000000000;;	// period. Thus, if the sampling rate is 100ms, the lowest achievable flow rate
0000000000000000000000000000000000000000;;	// is 10 bytes per second.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For usage examples, see the implementation of Reader and Writer in io.go.
0000000000000000000000000000000000000000;;	func (m *Monitor) Limit(want int, rate int64, block bool) (n int) {
0000000000000000000000000000000000000000;;		if want < 1 || rate < 1 {
0000000000000000000000000000000000000000;;			return want
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the maximum number of bytes that can be sent in one sample
0000000000000000000000000000000000000000;;		limit := round(float64(rate) * m.sRate.Seconds())
0000000000000000000000000000000000000000;;		if limit <= 0 {
0000000000000000000000000000000000000000;;			limit = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If block == true, wait until m.sBytes < limit
0000000000000000000000000000000000000000;;		if now := m.update(0); block {
0000000000000000000000000000000000000000;;			for m.sBytes >= limit && m.active {
0000000000000000000000000000000000000000;;				now = m.waitNextSample(now)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make limit <= want (unlimited if the transfer is no longer active)
0000000000000000000000000000000000000000;;		if limit -= m.sBytes; limit > int64(want) || !m.active {
0000000000000000000000000000000000000000;;			limit = int64(want)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if limit < 0 {
0000000000000000000000000000000000000000;;			limit = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(limit)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTransferSize specifies the total size of the data transfer, which allows
0000000000000000000000000000000000000000;;	// the Monitor to calculate the overall progress and time to completion.
0000000000000000000000000000000000000000;;	func (m *Monitor) SetTransferSize(bytes int64) {
0000000000000000000000000000000000000000;;		if bytes < 0 {
0000000000000000000000000000000000000000;;			bytes = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.mu.Lock()
0000000000000000000000000000000000000000;;		m.tBytes = bytes
0000000000000000000000000000000000000000;;		m.mu.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// update accumulates the transferred byte count for the current sample until
0000000000000000000000000000000000000000;;	// clock() - m.sLast >= m.sRate. The monitor status is updated once the current
0000000000000000000000000000000000000000;;	// sample is done.
0000000000000000000000000000000000000000;;	func (m *Monitor) update(n int) (now time.Duration) {
0000000000000000000000000000000000000000;;		if !m.active {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if now = clock(); n > 0 {
0000000000000000000000000000000000000000;;			m.tLast = now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.sBytes += int64(n)
0000000000000000000000000000000000000000;;		if sTime := now - m.sLast; sTime >= m.sRate {
0000000000000000000000000000000000000000;;			t := sTime.Seconds()
0000000000000000000000000000000000000000;;			if m.rSample = float64(m.sBytes) / t; m.rSample > m.rPeak {
0000000000000000000000000000000000000000;;				m.rPeak = m.rSample
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Exponential moving average using a method similar to *nix load
0000000000000000000000000000000000000000;;			// average calculation. Longer sampling periods carry greater weight.
0000000000000000000000000000000000000000;;			if m.samples > 0 {
0000000000000000000000000000000000000000;;				w := math.Exp(-t / m.rWindow)
0000000000000000000000000000000000000000;;				m.rEMA = m.rSample + w*(m.rEMA-m.rSample)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				m.rEMA = m.rSample
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.reset(now)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reset clears the current sample state in preparation for the next sample.
0000000000000000000000000000000000000000;;	func (m *Monitor) reset(sampleTime time.Duration) {
0000000000000000000000000000000000000000;;		m.bytes += m.sBytes
0000000000000000000000000000000000000000;;		m.samples++
0000000000000000000000000000000000000000;;		m.sBytes = 0
0000000000000000000000000000000000000000;;		m.sLast = sampleTime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// waitNextSample sleeps for the remainder of the current sample. The lock is
0000000000000000000000000000000000000000;;	// released and reacquired during the actual sleep period, so it's possible for
0000000000000000000000000000000000000000;;	// the transfer to be inactive when this method returns.
0000000000000000000000000000000000000000;;	func (m *Monitor) waitNextSample(now time.Duration) time.Duration {
0000000000000000000000000000000000000000;;		const minWait = 5 * time.Millisecond
0000000000000000000000000000000000000000;;		current := m.sLast
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// sleep until the last sample time changes (ideally, just one iteration)
0000000000000000000000000000000000000000;;		for m.sLast == current && m.active {
0000000000000000000000000000000000000000;;			d := current + m.sRate - now
0000000000000000000000000000000000000000;;			m.mu.Unlock()
0000000000000000000000000000000000000000;;			if d < minWait {
0000000000000000000000000000000000000000;;				d = minWait
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			time.Sleep(d)
0000000000000000000000000000000000000000;;			m.mu.Lock()
0000000000000000000000000000000000000000;;			now = m.update(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return now
0000000000000000000000000000000000000000;;	}
