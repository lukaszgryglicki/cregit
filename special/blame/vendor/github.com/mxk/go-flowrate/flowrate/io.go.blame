0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Written by Maxim Khitrov (November 2012)
0000000000000000000000000000000000000000;;	//
6b5b8837ca67322e3cfdf691ba47d2abdd617d8a;Godeps/_workspace/src/github.com/mxk/go-flowrate/flowrate/io.go[Godeps/_workspace/src/github.com/mxk/go-flowrate/flowrate/io.go][vendor/github.com/mxk/go-flowrate/flowrate/io.go];	
0000000000000000000000000000000000000000;;	package flowrate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrLimit is returned by the Writer when a non-blocking write is short due to
0000000000000000000000000000000000000000;;	// the transfer rate limit.
0000000000000000000000000000000000000000;;	var ErrLimit = errors.New("flowrate: flow rate limit exceeded")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Limiter is implemented by the Reader and Writer to provide a consistent
0000000000000000000000000000000000000000;;	// interface for monitoring and controlling data transfer.
0000000000000000000000000000000000000000;;	type Limiter interface {
0000000000000000000000000000000000000000;;		Done() int64
0000000000000000000000000000000000000000;;		Status() Status
0000000000000000000000000000000000000000;;		SetTransferSize(bytes int64)
0000000000000000000000000000000000000000;;		SetLimit(new int64) (old int64)
0000000000000000000000000000000000000000;;		SetBlocking(new bool) (old bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reader implements io.ReadCloser with a restriction on the rate of data
0000000000000000000000000000000000000000;;	// transfer.
0000000000000000000000000000000000000000;;	type Reader struct {
0000000000000000000000000000000000000000;;		io.Reader // Data source
0000000000000000000000000000000000000000;;		*Monitor  // Flow control monitor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		limit int64 // Rate limit in bytes per second (unlimited when <= 0)
0000000000000000000000000000000000000000;;		block bool  // What to do when no new bytes can be read due to the limit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReader restricts all Read operations on r to limit bytes per second.
0000000000000000000000000000000000000000;;	func NewReader(r io.Reader, limit int64) *Reader {
0000000000000000000000000000000000000000;;		return &Reader{r, New(0, 0), limit, true}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads up to len(p) bytes into p without exceeding the current transfer
0000000000000000000000000000000000000000;;	// rate limit. It returns (0, nil) immediately if r is non-blocking and no new
0000000000000000000000000000000000000000;;	// bytes can be read at this time.
0000000000000000000000000000000000000000;;	func (r *Reader) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		p = p[:r.Limit(len(p), r.limit, r.block)]
0000000000000000000000000000000000000000;;		if len(p) > 0 {
0000000000000000000000000000000000000000;;			n, err = r.IO(r.Reader.Read(p))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLimit changes the transfer rate limit to new bytes per second and returns
0000000000000000000000000000000000000000;;	// the previous setting.
0000000000000000000000000000000000000000;;	func (r *Reader) SetLimit(new int64) (old int64) {
0000000000000000000000000000000000000000;;		old, r.limit = r.limit, new
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBlocking changes the blocking behavior and returns the previous setting. A
0000000000000000000000000000000000000000;;	// Read call on a non-blocking reader returns immediately if no additional bytes
0000000000000000000000000000000000000000;;	// may be read at this time due to the rate limit.
0000000000000000000000000000000000000000;;	func (r *Reader) SetBlocking(new bool) (old bool) {
0000000000000000000000000000000000000000;;		old, r.block = r.block, new
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the underlying reader if it implements the io.Closer interface.
0000000000000000000000000000000000000000;;	func (r *Reader) Close() error {
0000000000000000000000000000000000000000;;		defer r.Done()
0000000000000000000000000000000000000000;;		if c, ok := r.Reader.(io.Closer); ok {
0000000000000000000000000000000000000000;;			return c.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writer implements io.WriteCloser with a restriction on the rate of data
0000000000000000000000000000000000000000;;	// transfer.
0000000000000000000000000000000000000000;;	type Writer struct {
0000000000000000000000000000000000000000;;		io.Writer // Data destination
0000000000000000000000000000000000000000;;		*Monitor  // Flow control monitor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		limit int64 // Rate limit in bytes per second (unlimited when <= 0)
0000000000000000000000000000000000000000;;		block bool  // What to do when no new bytes can be written due to the limit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWriter restricts all Write operations on w to limit bytes per second. The
0000000000000000000000000000000000000000;;	// transfer rate and the default blocking behavior (true) can be changed
0000000000000000000000000000000000000000;;	// directly on the returned *Writer.
0000000000000000000000000000000000000000;;	func NewWriter(w io.Writer, limit int64) *Writer {
0000000000000000000000000000000000000000;;		return &Writer{w, New(0, 0), limit, true}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes len(p) bytes from p to the underlying data stream without
0000000000000000000000000000000000000000;;	// exceeding the current transfer rate limit. It returns (n, ErrLimit) if w is
0000000000000000000000000000000000000000;;	// non-blocking and no additional bytes can be written at this time.
0000000000000000000000000000000000000000;;	func (w *Writer) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		var c int
0000000000000000000000000000000000000000;;		for len(p) > 0 && err == nil {
0000000000000000000000000000000000000000;;			s := p[:w.Limit(len(p), w.limit, w.block)]
0000000000000000000000000000000000000000;;			if len(s) > 0 {
0000000000000000000000000000000000000000;;				c, err = w.IO(w.Writer.Write(s))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return n, ErrLimit
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p = p[c:]
0000000000000000000000000000000000000000;;			n += c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetLimit changes the transfer rate limit to new bytes per second and returns
0000000000000000000000000000000000000000;;	// the previous setting.
0000000000000000000000000000000000000000;;	func (w *Writer) SetLimit(new int64) (old int64) {
0000000000000000000000000000000000000000;;		old, w.limit = w.limit, new
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetBlocking changes the blocking behavior and returns the previous setting. A
0000000000000000000000000000000000000000;;	// Write call on a non-blocking writer returns as soon as no additional bytes
0000000000000000000000000000000000000000;;	// may be written at this time due to the rate limit.
0000000000000000000000000000000000000000;;	func (w *Writer) SetBlocking(new bool) (old bool) {
0000000000000000000000000000000000000000;;		old, w.block = w.block, new
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the underlying writer if it implements the io.Closer interface.
0000000000000000000000000000000000000000;;	func (w *Writer) Close() error {
0000000000000000000000000000000000000000;;		defer w.Done()
0000000000000000000000000000000000000000;;		if c, ok := w.Writer.(io.Closer); ok {
0000000000000000000000000000000000000000;;			return c.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
