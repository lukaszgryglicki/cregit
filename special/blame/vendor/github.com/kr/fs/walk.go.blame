0000000000000000000000000000000000000000;;	// Package fs provides filesystem-related functions.
0000000000000000000000000000000000000000;;	package fs
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Walker provides a convenient interface for iterating over the
0000000000000000000000000000000000000000;;	// descendants of a filesystem path.
0000000000000000000000000000000000000000;;	// Successive calls to the Step method will step through each
0000000000000000000000000000000000000000;;	// file or directory in the tree, including the root. The files
0000000000000000000000000000000000000000;;	// are walked in lexical order, which makes the output deterministic
0000000000000000000000000000000000000000;;	// but means that for very large directories Walker can be inefficient.
0000000000000000000000000000000000000000;;	// Walker does not follow symbolic links.
0000000000000000000000000000000000000000;;	type Walker struct {
0000000000000000000000000000000000000000;;		fs      FileSystem
0000000000000000000000000000000000000000;;		cur     item
0000000000000000000000000000000000000000;;		stack   []item
0000000000000000000000000000000000000000;;		descend bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type item struct {
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		info os.FileInfo
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Walk returns a new Walker rooted at root.
0000000000000000000000000000000000000000;;	func Walk(root string) *Walker {
0000000000000000000000000000000000000000;;		return WalkFS(root, new(fs))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WalkFS returns a new Walker rooted at root on the FileSystem fs.
0000000000000000000000000000000000000000;;	func WalkFS(root string, fs FileSystem) *Walker {
0000000000000000000000000000000000000000;;		info, err := fs.Lstat(root)
0000000000000000000000000000000000000000;;		return &Walker{
0000000000000000000000000000000000000000;;			fs:    fs,
0000000000000000000000000000000000000000;;			stack: []item{{root, info, err}},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Step advances the Walker to the next file or directory,
0000000000000000000000000000000000000000;;	// which will then be available through the Path, Stat,
0000000000000000000000000000000000000000;;	// and Err methods.
0000000000000000000000000000000000000000;;	// It returns false when the walk stops at the end of the tree.
0000000000000000000000000000000000000000;;	func (w *Walker) Step() bool {
0000000000000000000000000000000000000000;;		if w.descend && w.cur.err == nil && w.cur.info.IsDir() {
0000000000000000000000000000000000000000;;			list, err := w.fs.ReadDir(w.cur.path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				w.cur.err = err
0000000000000000000000000000000000000000;;				w.stack = append(w.stack, w.cur)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for i := len(list) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;					path := w.fs.Join(w.cur.path, list[i].Name())
0000000000000000000000000000000000000000;;					w.stack = append(w.stack, item{path, list[i], nil})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(w.stack) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := len(w.stack) - 1
0000000000000000000000000000000000000000;;		w.cur = w.stack[i]
0000000000000000000000000000000000000000;;		w.stack = w.stack[:i]
0000000000000000000000000000000000000000;;		w.descend = true
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path returns the path to the most recent file or directory
0000000000000000000000000000000000000000;;	// visited by a call to Step. It contains the argument to Walk
0000000000000000000000000000000000000000;;	// as a prefix; that is, if Walk is called with "dir", which is
0000000000000000000000000000000000000000;;	// a directory containing the file "a", Path will return "dir/a".
0000000000000000000000000000000000000000;;	func (w *Walker) Path() string {
0000000000000000000000000000000000000000;;		return w.cur.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stat returns info for the most recent file or directory
0000000000000000000000000000000000000000;;	// visited by a call to Step.
0000000000000000000000000000000000000000;;	func (w *Walker) Stat() os.FileInfo {
0000000000000000000000000000000000000000;;		return w.cur.info
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Err returns the error, if any, for the most recent attempt
0000000000000000000000000000000000000000;;	// by Step to visit a file or directory. If a directory has
0000000000000000000000000000000000000000;;	// an error, w will not descend into that directory.
0000000000000000000000000000000000000000;;	func (w *Walker) Err() error {
0000000000000000000000000000000000000000;;		return w.cur.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SkipDir causes the currently visited directory to be skipped.
0000000000000000000000000000000000000000;;	// If w is not on a directory, SkipDir has no effect.
0000000000000000000000000000000000000000;;	func (w *Walker) SkipDir() {
0000000000000000000000000000000000000000;;		w.descend = false
0000000000000000000000000000000000000000;;	}
