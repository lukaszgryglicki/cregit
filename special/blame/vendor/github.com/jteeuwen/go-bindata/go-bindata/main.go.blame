0000000000000000000000000000000000000000;;	// This work is subject to the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
0000000000000000000000000000000000000000;;	// license. Its contents can be found at:
0000000000000000000000000000000000000000;;	// http://creativecommons.org/publicdomain/zero/1.0/
ecec4da416f813f03bad36da050c53fcd4444152;;	
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/jteeuwen/go-bindata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		cfg := parseArgs()
0000000000000000000000000000000000000000;;		err := bindata.Translate(cfg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "bindata: %v\n", err)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseArgs create s a new, filled configuration instance
0000000000000000000000000000000000000000;;	// by reading and parsing command line options.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function exits the program with an error, if
0000000000000000000000000000000000000000;;	// any of the command line options are incorrect.
0000000000000000000000000000000000000000;;	func parseArgs() *bindata.Config {
0000000000000000000000000000000000000000;;		var version bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := bindata.NewConfig()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag.Usage = func() {
0000000000000000000000000000000000000000;;			fmt.Printf("Usage: %s [options] <input directories>\n\n", os.Args[0])
0000000000000000000000000000000000000000;;			flag.PrintDefaults()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag.BoolVar(&c.Debug, "debug", c.Debug, "Do not embed the assets, but provide the embedding API. Contents will still be loaded from disk.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&c.Dev, "dev", c.Dev, "Similar to debug, but does not emit absolute paths. Expects a rootDir variable to already exist in the generated code's package.")
0000000000000000000000000000000000000000;;		flag.StringVar(&c.Tags, "tags", c.Tags, "Optional set of build tags to include.")
0000000000000000000000000000000000000000;;		flag.StringVar(&c.Prefix, "prefix", c.Prefix, "Optional path prefix to strip off asset names.")
0000000000000000000000000000000000000000;;		flag.StringVar(&c.Package, "pkg", c.Package, "Package name to use in the generated code.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&c.NoMemCopy, "nomemcopy", c.NoMemCopy, "Use a .rodata hack to get rid of unnecessary memcopies. Refer to the documentation to see what implications this carries.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&c.NoCompress, "nocompress", c.NoCompress, "Assets will *not* be GZIP compressed when this flag is specified.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&c.NoMetadata, "nometadata", c.NoMetadata, "Assets will not preserve size, mode, and modtime info.")
0000000000000000000000000000000000000000;;		flag.UintVar(&c.Mode, "mode", c.Mode, "Optional file mode override for all files.")
0000000000000000000000000000000000000000;;		flag.Int64Var(&c.ModTime, "modtime", c.ModTime, "Optional modification unix timestamp override for all files.")
0000000000000000000000000000000000000000;;		flag.StringVar(&c.Output, "o", c.Output, "Optional name of the output file to be generated.")
0000000000000000000000000000000000000000;;		flag.BoolVar(&version, "version", false, "Displays version information.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ignore := make([]string, 0)
0000000000000000000000000000000000000000;;		flag.Var((*AppendSliceValue)(&ignore), "ignore", "Regex pattern to ignore")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag.Parse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patterns := make([]*regexp.Regexp, 0)
0000000000000000000000000000000000000000;;		for _, pattern := range ignore {
0000000000000000000000000000000000000000;;			patterns = append(patterns, regexp.MustCompile(pattern))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Ignore = patterns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if version {
0000000000000000000000000000000000000000;;			fmt.Printf("%s\n", Version())
0000000000000000000000000000000000000000;;			os.Exit(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we have input paths.
0000000000000000000000000000000000000000;;		if flag.NArg() == 0 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "Missing <input dir>\n\n")
0000000000000000000000000000000000000000;;			flag.Usage()
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create input configurations.
0000000000000000000000000000000000000000;;		c.Input = make([]bindata.InputConfig, flag.NArg())
0000000000000000000000000000000000000000;;		for i := range c.Input {
0000000000000000000000000000000000000000;;			c.Input[i] = parseInput(flag.Arg(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseRecursive determines whether the given path has a recrusive indicator and
0000000000000000000000000000000000000000;;	// returns a new path with the recursive indicator chopped off if it does.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  ex:
0000000000000000000000000000000000000000;;	//      /path/to/foo/...    -> (/path/to/foo, true)
0000000000000000000000000000000000000000;;	//      /path/to/bar        -> (/path/to/bar, false)
0000000000000000000000000000000000000000;;	func parseInput(path string) bindata.InputConfig {
0000000000000000000000000000000000000000;;		if strings.HasSuffix(path, "/...") {
0000000000000000000000000000000000000000;;			return bindata.InputConfig{
0000000000000000000000000000000000000000;;				Path:      filepath.Clean(path[:len(path)-4]),
0000000000000000000000000000000000000000;;				Recursive: true,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return bindata.InputConfig{
0000000000000000000000000000000000000000;;				Path:      filepath.Clean(path),
0000000000000000000000000000000000000000;;				Recursive: false,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
