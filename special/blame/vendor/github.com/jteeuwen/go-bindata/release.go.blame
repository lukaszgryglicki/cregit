0000000000000000000000000000000000000000;;	// This work is subject to the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
0000000000000000000000000000000000000000;;	// license. Its contents can be found at:
0000000000000000000000000000000000000000;;	// http://creativecommons.org/publicdomain/zero/1.0/
ecec4da416f813f03bad36da050c53fcd4444152;;	
0000000000000000000000000000000000000000;;	package bindata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeRelease writes the release code file.
0000000000000000000000000000000000000000;;	func writeRelease(w io.Writer, c *Config, toc []Asset) error {
0000000000000000000000000000000000000000;;		err := writeReleaseHeader(w, c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range toc {
0000000000000000000000000000000000000000;;			err = writeReleaseAsset(w, c, &toc[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeReleaseHeader writes output file headers.
0000000000000000000000000000000000000000;;	// This targets release builds.
0000000000000000000000000000000000000000;;	func writeReleaseHeader(w io.Writer, c *Config) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if c.NoCompress {
0000000000000000000000000000000000000000;;			if c.NoMemCopy {
0000000000000000000000000000000000000000;;				err = header_uncompressed_nomemcopy(w)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = header_uncompressed_memcopy(w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if c.NoMemCopy {
0000000000000000000000000000000000000000;;				err = header_compressed_nomemcopy(w)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = header_compressed_memcopy(w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return header_release_common(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeReleaseAsset write a release entry for the given asset.
0000000000000000000000000000000000000000;;	// A release entry is a function which embeds and returns
0000000000000000000000000000000000000000;;	// the file's byte content.
0000000000000000000000000000000000000000;;	func writeReleaseAsset(w io.Writer, c *Config, asset *Asset) error {
0000000000000000000000000000000000000000;;		fd, err := os.Open(asset.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer fd.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.NoCompress {
0000000000000000000000000000000000000000;;			if c.NoMemCopy {
0000000000000000000000000000000000000000;;				err = uncompressed_nomemcopy(w, asset, fd)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = uncompressed_memcopy(w, asset, fd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if c.NoMemCopy {
0000000000000000000000000000000000000000;;				err = compressed_nomemcopy(w, asset, fd)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = compressed_memcopy(w, asset, fd)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return asset_release_common(w, c, asset)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sanitize prepares a valid UTF-8 string as a raw string constant.
0000000000000000000000000000000000000000;;	// Based on https://code.google.com/p/go/source/browse/godoc/static/makestatic.go?repo=tools
0000000000000000000000000000000000000000;;	func sanitize(b []byte) []byte {
0000000000000000000000000000000000000000;;		// Replace ` with `+"`"+`
0000000000000000000000000000000000000000;;		b = bytes.Replace(b, []byte("`"), []byte("`+\"`\"+`"), -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Replace BOM with `+"\xEF\xBB\xBF"+`
0000000000000000000000000000000000000000;;		// (A BOM is valid UTF-8 but not permitted in Go source files.
0000000000000000000000000000000000000000;;		// I wouldn't bother handling this, but for some insane reason
0000000000000000000000000000000000000000;;		// jquery.js has a BOM somewhere in the middle.)
0000000000000000000000000000000000000000;;		return bytes.Replace(b, []byte("\xEF\xBB\xBF"), []byte("`+\"\\xEF\\xBB\\xBF\"+`"), -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func header_compressed_nomemcopy(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bindataRead(data, name string) ([]byte, error) {
0000000000000000000000000000000000000000;;		gz, err := gzip.NewReader(strings.NewReader(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Read %%q: %%v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		_, err = io.Copy(&buf, gz)
0000000000000000000000000000000000000000;;		clErr := gz.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Read %%q: %%v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if clErr != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func header_compressed_memcopy(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bindataRead(data []byte, name string) ([]byte, error) {
0000000000000000000000000000000000000000;;		gz, err := gzip.NewReader(bytes.NewBuffer(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Read %%q: %%v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		_, err = io.Copy(&buf, gz)
0000000000000000000000000000000000000000;;		clErr := gz.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Read %%q: %%v", name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if clErr != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func header_uncompressed_nomemcopy(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bindataRead(data, name string) ([]byte, error) {
0000000000000000000000000000000000000000;;		var empty [0]byte
0000000000000000000000000000000000000000;;		sx := (*reflect.StringHeader)(unsafe.Pointer(&data))
0000000000000000000000000000000000000000;;		b := empty[:]
0000000000000000000000000000000000000000;;		bx := (*reflect.SliceHeader)(unsafe.Pointer(&b))
0000000000000000000000000000000000000000;;		bx.Data = sx.Data
0000000000000000000000000000000000000000;;		bx.Len = len(data)
0000000000000000000000000000000000000000;;		bx.Cap = bx.Len
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func header_uncompressed_memcopy(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func header_release_common(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `type asset struct {
0000000000000000000000000000000000000000;;		bytes []byte
0000000000000000000000000000000000000000;;		info  os.FileInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type bindataFileInfo struct {
0000000000000000000000000000000000000000;;		name    string
0000000000000000000000000000000000000000;;		size    int64
0000000000000000000000000000000000000000;;		mode    os.FileMode
0000000000000000000000000000000000000000;;		modTime time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fi bindataFileInfo) Name() string {
0000000000000000000000000000000000000000;;		return fi.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi bindataFileInfo) Size() int64 {
0000000000000000000000000000000000000000;;		return fi.size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi bindataFileInfo) Mode() os.FileMode {
0000000000000000000000000000000000000000;;		return fi.mode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi bindataFileInfo) ModTime() time.Time {
0000000000000000000000000000000000000000;;		return fi.modTime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi bindataFileInfo) IsDir() bool {
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (fi bindataFileInfo) Sys() interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compressed_nomemcopy(w io.Writer, asset *Asset, r io.Reader) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `var _%s = "`, asset.Func)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gz := gzip.NewWriter(&StringWriter{Writer: w})
0000000000000000000000000000000000000000;;		_, err = io.Copy(gz, r)
0000000000000000000000000000000000000000;;		gz.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintf(w, `"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func %sBytes() ([]byte, error) {
0000000000000000000000000000000000000000;;		return bindataRead(
0000000000000000000000000000000000000000;;			_%s,
0000000000000000000000000000000000000000;;			%q,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`, asset.Func, asset.Func, asset.Name)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compressed_memcopy(w io.Writer, asset *Asset, r io.Reader) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `var _%s = []byte("`, asset.Func)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		gz := gzip.NewWriter(&StringWriter{Writer: w})
0000000000000000000000000000000000000000;;		_, err = io.Copy(gz, r)
0000000000000000000000000000000000000000;;		gz.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintf(w, `")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func %sBytes() ([]byte, error) {
0000000000000000000000000000000000000000;;		return bindataRead(
0000000000000000000000000000000000000000;;			_%s,
0000000000000000000000000000000000000000;;			%q,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`, asset.Func, asset.Func, asset.Name)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func uncompressed_nomemcopy(w io.Writer, asset *Asset, r io.Reader) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `var _%s = "`, asset.Func)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = io.Copy(&StringWriter{Writer: w}, r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintf(w, `"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func %sBytes() ([]byte, error) {
0000000000000000000000000000000000000000;;		return bindataRead(
0000000000000000000000000000000000000000;;			_%s,
0000000000000000000000000000000000000000;;			%q,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`, asset.Func, asset.Func, asset.Name)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func uncompressed_memcopy(w io.Writer, asset *Asset, r io.Reader) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `var _%s = []byte(`, asset.Func)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if utf8.Valid(b) && !bytes.Contains(b, []byte{0}) {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "`%s`", sanitize(b))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%+q", b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintf(w, `)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func %sBytes() ([]byte, error) {
0000000000000000000000000000000000000000;;		return _%s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`, asset.Func, asset.Func)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func asset_release_common(w io.Writer, c *Config, asset *Asset) error {
0000000000000000000000000000000000000000;;		fi, err := os.Stat(asset.Path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mode := uint(fi.Mode())
0000000000000000000000000000000000000000;;		modTime := fi.ModTime().Unix()
0000000000000000000000000000000000000000;;		size := fi.Size()
0000000000000000000000000000000000000000;;		if c.NoMetadata {
0000000000000000000000000000000000000000;;			mode = 0
0000000000000000000000000000000000000000;;			modTime = 0
0000000000000000000000000000000000000000;;			size = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.Mode > 0 {
0000000000000000000000000000000000000000;;			mode = uint(os.ModePerm) & c.Mode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.ModTime > 0 {
0000000000000000000000000000000000000000;;			modTime = c.ModTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintf(w, `func %s() (*asset, error) {
0000000000000000000000000000000000000000;;		bytes, err := %sBytes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info := bindataFileInfo{name: %q, size: %d, mode: os.FileMode(%d), modTime: time.Unix(%d, 0)}
0000000000000000000000000000000000000000;;		a := &asset{bytes: bytes, info: info}
0000000000000000000000000000000000000000;;		return a, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`, asset.Func, asset.Func, asset.Name, size, mode, modTime)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
