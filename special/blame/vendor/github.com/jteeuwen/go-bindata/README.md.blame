0000000000000000000000000000000000000000;;	## bindata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This package converts any file into managable Go source code. Useful for
0000000000000000000000000000000000000000;;	embedding binary data into a go program. The file data is optionally gzip
0000000000000000000000000000000000000000;;	compressed before being converted to a raw byte slice.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It comes with a command line tool in the `go-bindata` sub directory.
0000000000000000000000000000000000000000;;	This tool offers a set of command line options, used to customize the
0000000000000000000000000000000000000000;;	output being generated.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Installation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To install the library and command line program, use the following:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go get -u github.com/jteeuwen/go-bindata/...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Conversion is done on one or more sets of files. They are all embedded in a new
0000000000000000000000000000000000000000;;	Go source file, along with a table of contents and an `Asset` function,
0000000000000000000000000000000000000000;;	which allows quick access to the asset, based on its name.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The simplest invocation generates a `bindata.go` file in the current
0000000000000000000000000000000000000000;;	working directory. It includes all assets from the `data` directory.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata data/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To include all input sub-directories recursively, use the elipsis postfix
0000000000000000000000000000000000000000;;	as defined for Go import paths. Otherwise it will only consider assets in the
0000000000000000000000000000000000000000;;	input directory itself.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata data/...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To specify the name of the output file being generated, we use the following:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata -o myfile.go data/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Multiple input directories can be specified if necessary.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata dir1/... /path/to/dir2/... dir3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following paragraphs detail some of the command line options which can be 
0000000000000000000000000000000000000000;;	supplied to `go-bindata`. Refer to the `testdata/out` directory for various
0000000000000000000000000000000000000000;;	output examples from the assets in `testdata/in`. Each example uses different
0000000000000000000000000000000000000000;;	command line options.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To ignore files, pass in regexes using -ignore, for example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    $ go-bindata -ignore=\\.gitignore data/...
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Accessing an asset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To access asset data, we use the `Asset(string) ([]byte, error)` function which
0000000000000000000000000000000000000000;;	is included in the generated output.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := Asset("pub/style/foo.css")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Asset was not found.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// use asset data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Debug vs Release builds
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When invoking the program with the `-debug` flag, the generated code does
0000000000000000000000000000000000000000;;	not actually include the asset data. Instead, it generates function stubs
0000000000000000000000000000000000000000;;	which load the data from the original file on disk. The asset API remains
0000000000000000000000000000000000000000;;	identical between debug and release builds, so your code will not have to
0000000000000000000000000000000000000000;;	change.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This is useful during development when you expect the assets to change often.
0000000000000000000000000000000000000000;;	The host application using these assets uses the same API in both cases and
0000000000000000000000000000000000000000;;	will not have to care where the actual data comes from.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	An example is a Go webserver with some embedded, static web content like
0000000000000000000000000000000000000000;;	HTML, JS and CSS files. While developing it, you do not want to rebuild the
0000000000000000000000000000000000000000;;	whole server and restart it every time you make a change to a bit of
0000000000000000000000000000000000000000;;	javascript. You just want to build and launch the server once. Then just press
0000000000000000000000000000000000000000;;	refresh in the browser to see those changes. Embedding the assets with the
0000000000000000000000000000000000000000;;	`debug` flag allows you to do just that. When you are finished developing and
0000000000000000000000000000000000000000;;	ready for deployment, just re-invoke `go-bindata` without the `-debug` flag.
0000000000000000000000000000000000000000;;	It will now embed the latest version of the assets.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Lower memory footprint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Using the `-nomemcopy` flag, will alter the way the output file is generated.
0000000000000000000000000000000000000000;;	It will employ a hack that allows us to read the file data directly from
0000000000000000000000000000000000000000;;	the compiled program's `.rodata` section. This ensures that when we call
0000000000000000000000000000000000000000;;	call our generated function, we omit unnecessary memcopies.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The downside of this, is that it requires dependencies on the `reflect` and
0000000000000000000000000000000000000000;;	`unsafe` packages. These may be restricted on platforms like AppEngine and
0000000000000000000000000000000000000000;;	thus prevent you from using this mode.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Another disadvantage is that the byte slice we create, is strictly read-only.
0000000000000000000000000000000000000000;;	For most use-cases this is not a problem, but if you ever try to alter the
0000000000000000000000000000000000000000;;	returned byte slice, a runtime panic is thrown. Use this mode only on target
0000000000000000000000000000000000000000;;	platforms where memory constraints are an issue.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default behaviour is to use the old code generation method. This
0000000000000000000000000000000000000000;;	prevents the two previously mentioned issues, but will employ at least one
0000000000000000000000000000000000000000;;	extra memcopy and thus increase memory requirements.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For instance, consider the following two examples:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This would be the default mode, using an extra memcopy but gives a safe
0000000000000000000000000000000000000000;;	implementation without dependencies on `reflect` and `unsafe`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func myfile() []byte {
0000000000000000000000000000000000000000;;	    return []byte{0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here is the same functionality, but uses the `.rodata` hack.
0000000000000000000000000000000000000000;;	The byte slice returned from this example can not be written to without
0000000000000000000000000000000000000000;;	generating a runtime error.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	var _myfile = "\x89\x50\x4e\x47\x0d\x0a\x1a"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func myfile() []byte {
0000000000000000000000000000000000000000;;	    var empty [0]byte
0000000000000000000000000000000000000000;;	    sx := (*reflect.StringHeader)(unsafe.Pointer(&_myfile))
0000000000000000000000000000000000000000;;	    b := empty[:]
0000000000000000000000000000000000000000;;	    bx := (*reflect.SliceHeader)(unsafe.Pointer(&b))
0000000000000000000000000000000000000000;;	    bx.Data = sx.Data
0000000000000000000000000000000000000000;;	    bx.Len = len(_myfile)
0000000000000000000000000000000000000000;;	    bx.Cap = bx.Len
0000000000000000000000000000000000000000;;	    return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Optional compression
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When the `-nocompress` flag is given, the supplied resource is *not* GZIP
0000000000000000000000000000000000000000;;	compressed before being turned into Go code. The data should still be accessed
0000000000000000000000000000000000000000;;	through a function call, so nothing changes in the usage of the generated file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This feature is useful if you do not care for compression, or the supplied
0000000000000000000000000000000000000000;;	resource is already compressed. Doing it again would not add any value and may
0000000000000000000000000000000000000000;;	even increase the size of the data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default behaviour of the program is to use compression.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Path prefix stripping
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The keys used in the `_bindata` map, are the same as the input file name
0000000000000000000000000000000000000000;;	passed to `go-bindata`. This includes the path. In most cases, this is not
0000000000000000000000000000000000000000;;	desireable, as it puts potentially sensitive information in your code base.
0000000000000000000000000000000000000000;;	For this purpose, the tool supplies another command line flag `-prefix`.
0000000000000000000000000000000000000000;;	This accepts a portion of a path name, which should be stripped off from
0000000000000000000000000000000000000000;;	the map keys and function names.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example, running without the `-prefix` flag, we get:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata /path/to/templates/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_bindata["/path/to/templates/foo.html"] = path_to_templates_foo_html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Running with the `-prefix` flag, we get:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata -prefix "/path/to/" /path/to/templates/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_bindata["templates/foo.html"] = templates_foo_html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Build tags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	With the optional `-tags` flag, you can specify any go build tags that
0000000000000000000000000000000000000000;;	must be fulfilled for the output file to be included in a build. This
0000000000000000000000000000000000000000;;	is useful when including binary data in multiple formats, where the desired
0000000000000000000000000000000000000000;;	format is specified at build time with the appropriate tags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The tags are appended to a `// +build` line in the beginning of the output file
0000000000000000000000000000000000000000;;	and must follow the build tags syntax specified by the go tool.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Related projects
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[go-bindata-assetfs](https://github.com/elazarl/go-bindata-assetfs#readme) - 
0000000000000000000000000000000000000000;;	implements `http.FileSystem` interface. Allows you to serve assets with `net/http`.
0000000000000000000000000000000000000000;;	
