0000000000000000000000000000000000000000;;	// This work is subject to the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
0000000000000000000000000000000000000000;;	// license. Its contents can be found at:
0000000000000000000000000000000000000000;;	// http://creativecommons.org/publicdomain/zero/1.0/
ecec4da416f813f03bad36da050c53fcd4444152;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	bindata converts any file into managable Go source code. Useful for
0000000000000000000000000000000000000000;;	embedding binary data into a go program. The file data is optionally gzip
0000000000000000000000000000000000000000;;	compressed before being converted to a raw byte slice.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following paragraphs cover some of the customization options
0000000000000000000000000000000000000000;;	which can be specified in the Config struct, which must be passed into
0000000000000000000000000000000000000000;;	the Translate() call.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Debug vs Release builds
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When used with the `Debug` option, the generated code does not actually include
0000000000000000000000000000000000000000;;	the asset data. Instead, it generates function stubs which load the data from
0000000000000000000000000000000000000000;;	the original file on disk. The asset API remains identical between debug and
0000000000000000000000000000000000000000;;	release builds, so your code will not have to change.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This is useful during development when you expect the assets to change often.
0000000000000000000000000000000000000000;;	The host application using these assets uses the same API in both cases and
0000000000000000000000000000000000000000;;	will not have to care where the actual data comes from.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	An example is a Go webserver with some embedded, static web content like
0000000000000000000000000000000000000000;;	HTML, JS and CSS files. While developing it, you do not want to rebuild the
0000000000000000000000000000000000000000;;	whole server and restart it every time you make a change to a bit of
0000000000000000000000000000000000000000;;	javascript. You just want to build and launch the server once. Then just press
0000000000000000000000000000000000000000;;	refresh in the browser to see those changes. Embedding the assets with the
0000000000000000000000000000000000000000;;	`debug` flag allows you to do just that. When you are finished developing and
0000000000000000000000000000000000000000;;	ready for deployment, just re-invoke `go-bindata` without the `-debug` flag.
0000000000000000000000000000000000000000;;	It will now embed the latest version of the assets.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Lower memory footprint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `NoMemCopy` option will alter the way the output file is generated.
0000000000000000000000000000000000000000;;	It will employ a hack that allows us to read the file data directly from
0000000000000000000000000000000000000000;;	the compiled program's `.rodata` section. This ensures that when we call
0000000000000000000000000000000000000000;;	call our generated function, we omit unnecessary memcopies.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The downside of this, is that it requires dependencies on the `reflect` and
0000000000000000000000000000000000000000;;	`unsafe` packages. These may be restricted on platforms like AppEngine and
0000000000000000000000000000000000000000;;	thus prevent you from using this mode.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Another disadvantage is that the byte slice we create, is strictly read-only.
0000000000000000000000000000000000000000;;	For most use-cases this is not a problem, but if you ever try to alter the
0000000000000000000000000000000000000000;;	returned byte slice, a runtime panic is thrown. Use this mode only on target
0000000000000000000000000000000000000000;;	platforms where memory constraints are an issue.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default behaviour is to use the old code generation method. This
0000000000000000000000000000000000000000;;	prevents the two previously mentioned issues, but will employ at least one
0000000000000000000000000000000000000000;;	extra memcopy and thus increase memory requirements.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For instance, consider the following two examples:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This would be the default mode, using an extra memcopy but gives a safe
0000000000000000000000000000000000000000;;	implementation without dependencies on `reflect` and `unsafe`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func myfile() []byte {
0000000000000000000000000000000000000000;;			return []byte{0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here is the same functionality, but uses the `.rodata` hack.
0000000000000000000000000000000000000000;;	The byte slice returned from this example can not be written to without
0000000000000000000000000000000000000000;;	generating a runtime error.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var _myfile = "\x89\x50\x4e\x47\x0d\x0a\x1a"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func myfile() []byte {
0000000000000000000000000000000000000000;;			var empty [0]byte
0000000000000000000000000000000000000000;;			sx := (*reflect.StringHeader)(unsafe.Pointer(&_myfile))
0000000000000000000000000000000000000000;;			b := empty[:]
0000000000000000000000000000000000000000;;			bx := (*reflect.SliceHeader)(unsafe.Pointer(&b))
0000000000000000000000000000000000000000;;			bx.Data = sx.Data
0000000000000000000000000000000000000000;;			bx.Len = len(_myfile)
0000000000000000000000000000000000000000;;			bx.Cap = bx.Len
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Optional compression
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The NoCompress option indicates that the supplied assets are *not* GZIP
0000000000000000000000000000000000000000;;	compressed before being turned into Go code. The data should still be accessed
0000000000000000000000000000000000000000;;	through a function call, so nothing changes in the API.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This feature is useful if you do not care for compression, or the supplied
0000000000000000000000000000000000000000;;	resource is already compressed. Doing it again would not add any value and may
0000000000000000000000000000000000000000;;	even increase the size of the data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The default behaviour of the program is to use compression.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Path prefix stripping
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The keys used in the `_bindata` map are the same as the input file name
0000000000000000000000000000000000000000;;	passed to `go-bindata`. This includes the path. In most cases, this is not
0000000000000000000000000000000000000000;;	desireable, as it puts potentially sensitive information in your code base.
0000000000000000000000000000000000000000;;	For this purpose, the tool supplies another command line flag `-prefix`.
0000000000000000000000000000000000000000;;	This accepts a portion of a path name, which should be stripped off from
0000000000000000000000000000000000000000;;	the map keys and function names.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example, running without the `-prefix` flag, we get:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata /path/to/templates/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_bindata["/path/to/templates/foo.html"] = path_to_templates_foo_html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Running with the `-prefix` flag, we get:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		$ go-bindata -prefix "/path/to/" /path/to/templates/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_bindata["templates/foo.html"] = templates_foo_html
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Build tags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	With the optional Tags field, you can specify any go build tags that
0000000000000000000000000000000000000000;;	must be fulfilled for the output file to be included in a build. This
0000000000000000000000000000000000000000;;	is useful when including binary data in multiple formats, where the desired
0000000000000000000000000000000000000000;;	format is specified at build time with the appropriate tags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The tags are appended to a `// +build` line in the beginning of the output file
0000000000000000000000000000000000000000;;	and must follow the build tags syntax specified by the go tool.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package bindata
