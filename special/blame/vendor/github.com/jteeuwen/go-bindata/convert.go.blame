0000000000000000000000000000000000000000;;	// This work is subject to the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
0000000000000000000000000000000000000000;;	// license. Its contents can be found at:
0000000000000000000000000000000000000000;;	// http://creativecommons.org/publicdomain/zero/1.0/
ecec4da416f813f03bad36da050c53fcd4444152;;	
0000000000000000000000000000000000000000;;	package bindata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Translate reads assets from an input directory, converts them
0000000000000000000000000000000000000000;;	// to Go code and writes new files to the output specified
0000000000000000000000000000000000000000;;	// in the given configuration.
0000000000000000000000000000000000000000;;	func Translate(c *Config) error {
0000000000000000000000000000000000000000;;		var toc []Asset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure our configuration has sane values.
0000000000000000000000000000000000000000;;		err := c.validate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var knownFuncs = make(map[string]int)
0000000000000000000000000000000000000000;;		var visitedPaths = make(map[string]bool)
0000000000000000000000000000000000000000;;		// Locate all the assets.
0000000000000000000000000000000000000000;;		for _, input := range c.Input {
0000000000000000000000000000000000000000;;			err = findFiles(input.Path, c.Prefix, input.Recursive, &toc, c.Ignore, knownFuncs, visitedPaths)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create output file.
0000000000000000000000000000000000000000;;		fd, err := os.Create(c.Output)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer fd.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a buffered writer for better performance.
0000000000000000000000000000000000000000;;		bfd := bufio.NewWriter(fd)
0000000000000000000000000000000000000000;;		defer bfd.Flush()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the header. This makes e.g. Github ignore diffs in generated files.
0000000000000000000000000000000000000000;;		if _, err = fmt.Fprint(bfd, "// Code generated by go-bindata.\n"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = fmt.Fprint(bfd, "// sources:\n"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		wd, err := os.Getwd()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, asset := range toc {
0000000000000000000000000000000000000000;;			relative, _ := filepath.Rel(wd, asset.Path)
0000000000000000000000000000000000000000;;			if _, err = fmt.Fprintf(bfd, "// %s\n", filepath.ToSlash(relative)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = fmt.Fprint(bfd, "// DO NOT EDIT!\n\n"); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write build tags, if applicable.
0000000000000000000000000000000000000000;;		if len(c.Tags) > 0 {
0000000000000000000000000000000000000000;;			if _, err = fmt.Fprintf(bfd, "// +build %s\n\n", c.Tags); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write package declaration.
0000000000000000000000000000000000000000;;		_, err = fmt.Fprintf(bfd, "package %s\n\n", c.Package)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write assets.
0000000000000000000000000000000000000000;;		if c.Debug || c.Dev {
0000000000000000000000000000000000000000;;			err = writeDebug(bfd, c, toc)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = writeRelease(bfd, c, toc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write table of contents
0000000000000000000000000000000000000000;;		if err := writeTOC(bfd, toc); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Write hierarchical tree of assets
0000000000000000000000000000000000000000;;		if err := writeTOCTree(bfd, toc); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write restore procedure
0000000000000000000000000000000000000000;;		return writeRestore(bfd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement sort.Interface for []os.FileInfo based on Name()
0000000000000000000000000000000000000000;;	type ByName []os.FileInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v ByName) Len() int           { return len(v) }
0000000000000000000000000000000000000000;;	func (v ByName) Swap(i, j int)      { v[i], v[j] = v[j], v[i] }
0000000000000000000000000000000000000000;;	func (v ByName) Less(i, j int) bool { return v[i].Name() < v[j].Name() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findFiles recursively finds all the file paths in the given directory tree.
0000000000000000000000000000000000000000;;	// They are added to the given map as keys. Values will be safe function names
0000000000000000000000000000000000000000;;	// for each file, which will be used when generating the output code.
0000000000000000000000000000000000000000;;	func findFiles(dir, prefix string, recursive bool, toc *[]Asset, ignore []*regexp.Regexp, knownFuncs map[string]int, visitedPaths map[string]bool) error {
0000000000000000000000000000000000000000;;		dirpath := dir
0000000000000000000000000000000000000000;;		if len(prefix) > 0 {
0000000000000000000000000000000000000000;;			dirpath, _ = filepath.Abs(dirpath)
0000000000000000000000000000000000000000;;			prefix, _ = filepath.Abs(prefix)
0000000000000000000000000000000000000000;;			prefix = filepath.ToSlash(prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fi, err := os.Stat(dirpath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var list []os.FileInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !fi.IsDir() {
0000000000000000000000000000000000000000;;			dirpath = filepath.Dir(dirpath)
0000000000000000000000000000000000000000;;			list = []os.FileInfo{fi}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			visitedPaths[dirpath] = true
0000000000000000000000000000000000000000;;			fd, err := os.Open(dirpath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			defer fd.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			list, err = fd.Readdir(0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Sort to make output stable between invocations
0000000000000000000000000000000000000000;;			sort.Sort(ByName(list))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, file := range list {
0000000000000000000000000000000000000000;;			var asset Asset
0000000000000000000000000000000000000000;;			asset.Path = filepath.Join(dirpath, file.Name())
0000000000000000000000000000000000000000;;			asset.Name = filepath.ToSlash(asset.Path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ignoring := false
0000000000000000000000000000000000000000;;			for _, re := range ignore {
0000000000000000000000000000000000000000;;				if re.MatchString(asset.Path) {
0000000000000000000000000000000000000000;;					ignoring = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ignoring {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if file.IsDir() {
0000000000000000000000000000000000000000;;				if recursive {
0000000000000000000000000000000000000000;;					recursivePath := filepath.Join(dir, file.Name())
0000000000000000000000000000000000000000;;					visitedPaths[asset.Path] = true
0000000000000000000000000000000000000000;;					findFiles(recursivePath, prefix, recursive, toc, ignore, knownFuncs, visitedPaths)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if file.Mode()&os.ModeSymlink == os.ModeSymlink {
0000000000000000000000000000000000000000;;				var linkPath string
0000000000000000000000000000000000000000;;				if linkPath, err = os.Readlink(asset.Path); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !filepath.IsAbs(linkPath) {
0000000000000000000000000000000000000000;;					if linkPath, err = filepath.Abs(dirpath + "/" + linkPath); err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := visitedPaths[linkPath]; !ok {
0000000000000000000000000000000000000000;;					visitedPaths[linkPath] = true
0000000000000000000000000000000000000000;;					findFiles(asset.Path, prefix, recursive, toc, ignore, knownFuncs, visitedPaths)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.HasPrefix(asset.Name, prefix) {
0000000000000000000000000000000000000000;;				asset.Name = asset.Name[len(prefix):]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				asset.Name = filepath.Join(dir, file.Name())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we have a leading slash, get rid of it.
0000000000000000000000000000000000000000;;			if len(asset.Name) > 0 && asset.Name[0] == '/' {
0000000000000000000000000000000000000000;;				asset.Name = asset.Name[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This shouldn't happen.
0000000000000000000000000000000000000000;;			if len(asset.Name) == 0 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Invalid file: %v", asset.Path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			asset.Func = safeFunctionName(asset.Name, knownFuncs)
0000000000000000000000000000000000000000;;			asset.Path, _ = filepath.Abs(asset.Path)
0000000000000000000000000000000000000000;;			*toc = append(*toc, asset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var regFuncName = regexp.MustCompile(`[^a-zA-Z0-9_]`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// safeFunctionName converts the given name into a name
0000000000000000000000000000000000000000;;	// which qualifies as a valid function identifier. It
0000000000000000000000000000000000000000;;	// also compares against a known list of functions to
0000000000000000000000000000000000000000;;	// prevent conflict based on name translation.
0000000000000000000000000000000000000000;;	func safeFunctionName(name string, knownFuncs map[string]int) string {
0000000000000000000000000000000000000000;;		var inBytes, outBytes []byte
0000000000000000000000000000000000000000;;		var toUpper bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name = strings.ToLower(name)
0000000000000000000000000000000000000000;;		inBytes = []byte(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(inBytes); i++ {
0000000000000000000000000000000000000000;;			if regFuncName.Match([]byte{inBytes[i]}) {
0000000000000000000000000000000000000000;;				toUpper = true
0000000000000000000000000000000000000000;;			} else if toUpper {
0000000000000000000000000000000000000000;;				outBytes = append(outBytes, []byte(strings.ToUpper(string(inBytes[i])))...)
0000000000000000000000000000000000000000;;				toUpper = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				outBytes = append(outBytes, inBytes[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name = string(outBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Identifier can't start with a digit.
0000000000000000000000000000000000000000;;		if unicode.IsDigit(rune(name[0])) {
0000000000000000000000000000000000000000;;			name = "_" + name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if num, ok := knownFuncs[name]; ok {
0000000000000000000000000000000000000000;;			knownFuncs[name] = num + 1
0000000000000000000000000000000000000000;;			name = fmt.Sprintf("%s%d", name, num)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			knownFuncs[name] = 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
