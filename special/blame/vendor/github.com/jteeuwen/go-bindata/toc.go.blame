0000000000000000000000000000000000000000;;	// This work is subject to the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
0000000000000000000000000000000000000000;;	// license. Its contents can be found at:
0000000000000000000000000000000000000000;;	// http://creativecommons.org/publicdomain/zero/1.0/
ecec4da416f813f03bad36da050c53fcd4444152;;	
0000000000000000000000000000000000000000;;	package bindata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type assetTree struct {
0000000000000000000000000000000000000000;;		Asset    Asset
0000000000000000000000000000000000000000;;		Children map[string]*assetTree
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newAssetTree() *assetTree {
0000000000000000000000000000000000000000;;		tree := &assetTree{}
0000000000000000000000000000000000000000;;		tree.Children = make(map[string]*assetTree)
0000000000000000000000000000000000000000;;		return tree
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (node *assetTree) child(name string) *assetTree {
0000000000000000000000000000000000000000;;		rv, ok := node.Children[name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			rv = newAssetTree()
0000000000000000000000000000000000000000;;			node.Children[name] = rv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (root *assetTree) Add(route []string, asset Asset) {
0000000000000000000000000000000000000000;;		for _, name := range route {
0000000000000000000000000000000000000000;;			root = root.child(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		root.Asset = asset
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ident(w io.Writer, n int) {
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			w.Write([]byte{'\t'})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (root *assetTree) funcOrNil() string {
0000000000000000000000000000000000000000;;		if root.Asset.Func == "" {
0000000000000000000000000000000000000000;;			return "nil"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return root.Asset.Func
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (root *assetTree) writeGoMap(w io.Writer, nident int) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "&bintree{%s, map[string]*bintree{", root.funcOrNil())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(root.Children) > 0 {
0000000000000000000000000000000000000000;;			io.WriteString(w, "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Sort to make output stable between invocations
0000000000000000000000000000000000000000;;			filenames := make([]string, len(root.Children))
0000000000000000000000000000000000000000;;			i := 0
0000000000000000000000000000000000000000;;			for filename, _ := range root.Children {
0000000000000000000000000000000000000000;;				filenames[i] = filename
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(filenames)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, p := range filenames {
0000000000000000000000000000000000000000;;				ident(w, nident+1)
0000000000000000000000000000000000000000;;				fmt.Fprintf(w, `"%s": `, p)
0000000000000000000000000000000000000000;;				root.Children[p].writeGoMap(w, nident+1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ident(w, nident)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		io.WriteString(w, "}}")
0000000000000000000000000000000000000000;;		if nident > 0 {
0000000000000000000000000000000000000000;;			io.WriteString(w, ",")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		io.WriteString(w, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (root *assetTree) WriteAsGoMap(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprint(w, `type bintree struct {
0000000000000000000000000000000000000000;;		Func     func() (*asset, error)
0000000000000000000000000000000000000000;;		Children map[string]*bintree
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	var _bintree = `)
0000000000000000000000000000000000000000;;		root.writeGoMap(w, 0)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeTOCTree(w io.Writer, toc []Asset) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `// AssetDir returns the file names below a certain
0000000000000000000000000000000000000000;;	// directory embedded in the file by go-bindata.
0000000000000000000000000000000000000000;;	// For example if you run go-bindata on data/... and data contains the
0000000000000000000000000000000000000000;;	// following hierarchy:
0000000000000000000000000000000000000000;;	//     data/
0000000000000000000000000000000000000000;;	//       foo.txt
0000000000000000000000000000000000000000;;	//       img/
0000000000000000000000000000000000000000;;	//         a.png
0000000000000000000000000000000000000000;;	//         b.png
0000000000000000000000000000000000000000;;	// then AssetDir("data") would return []string{"foo.txt", "img"}
0000000000000000000000000000000000000000;;	// AssetDir("data/img") would return []string{"a.png", "b.png"}
0000000000000000000000000000000000000000;;	// AssetDir("foo.txt") and AssetDir("notexist") would return an error
0000000000000000000000000000000000000000;;	// AssetDir("") will return []string{"data"}.
0000000000000000000000000000000000000000;;	func AssetDir(name string) ([]string, error) {
0000000000000000000000000000000000000000;;		node := _bintree
0000000000000000000000000000000000000000;;		if len(name) != 0 {
0000000000000000000000000000000000000000;;			cannonicalName := strings.Replace(name, "\\", "/", -1)
0000000000000000000000000000000000000000;;			pathList := strings.Split(cannonicalName, "/")
0000000000000000000000000000000000000000;;			for _, p := range pathList {
0000000000000000000000000000000000000000;;				node = node.Children[p]
0000000000000000000000000000000000000000;;				if node == nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("Asset %%s not found", name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if node.Func != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Asset %%s not found", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rv := make([]string, 0, len(node.Children))
0000000000000000000000000000000000000000;;		for childName := range node.Children {
0000000000000000000000000000000000000000;;			rv = append(rv, childName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tree := newAssetTree()
0000000000000000000000000000000000000000;;		for i := range toc {
0000000000000000000000000000000000000000;;			pathList := strings.Split(toc[i].Name, "/")
0000000000000000000000000000000000000000;;			tree.Add(pathList, toc[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tree.WriteAsGoMap(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeTOC writes the table of contents file.
0000000000000000000000000000000000000000;;	func writeTOC(w io.Writer, toc []Asset) error {
0000000000000000000000000000000000000000;;		err := writeTOCHeader(w)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range toc {
0000000000000000000000000000000000000000;;			err = writeTOCAsset(w, &toc[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return writeTOCFooter(w)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeTOCHeader writes the table of contents file header.
0000000000000000000000000000000000000000;;	func writeTOCHeader(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `// Asset loads and returns the asset for the given name.
0000000000000000000000000000000000000000;;	// It returns an error if the asset could not be found or
0000000000000000000000000000000000000000;;	// could not be loaded.
0000000000000000000000000000000000000000;;	func Asset(name string) ([]byte, error) {
0000000000000000000000000000000000000000;;		cannonicalName := strings.Replace(name, "\\", "/", -1)
0000000000000000000000000000000000000000;;		if f, ok := _bindata[cannonicalName]; ok {
0000000000000000000000000000000000000000;;			a, err := f()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Asset %%s can't read by error: %%v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return a.bytes, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Asset %%s not found", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustAsset is like Asset but panics when Asset would return an error.
0000000000000000000000000000000000000000;;	// It simplifies safe initialization of global variables.
0000000000000000000000000000000000000000;;	func MustAsset(name string) []byte {
0000000000000000000000000000000000000000;;		a, err := Asset(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("asset: Asset(" + name + "): " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssetInfo loads and returns the asset info for the given name.
0000000000000000000000000000000000000000;;	// It returns an error if the asset could not be found or
0000000000000000000000000000000000000000;;	// could not be loaded.
0000000000000000000000000000000000000000;;	func AssetInfo(name string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		cannonicalName := strings.Replace(name, "\\", "/", -1)
0000000000000000000000000000000000000000;;		if f, ok := _bindata[cannonicalName]; ok {
0000000000000000000000000000000000000000;;			a, err := f()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("AssetInfo %%s can't read by error: %%v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return a.info, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("AssetInfo %%s not found", name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssetNames returns the names of the assets.
0000000000000000000000000000000000000000;;	func AssetNames() []string {
0000000000000000000000000000000000000000;;		names := make([]string, 0, len(_bindata))
0000000000000000000000000000000000000000;;		for name := range _bindata {
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// _bindata is a table, holding each asset generator, mapped to its name.
0000000000000000000000000000000000000000;;	var _bindata = map[string]func() (*asset, error){
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeTOCAsset write a TOC entry for the given asset.
0000000000000000000000000000000000000000;;	func writeTOCAsset(w io.Writer, asset *Asset) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, "\t%q: %s,\n", asset.Name, asset.Func)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeTOCFooter writes the table of contents file footer.
0000000000000000000000000000000000000000;;	func writeTOCFooter(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := fmt.Fprintf(w, `}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	`)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
