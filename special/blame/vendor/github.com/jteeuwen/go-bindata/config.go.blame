0000000000000000000000000000000000000000;;	// This work is subject to the CC0 1.0 Universal (CC0 1.0) Public Domain Dedication
0000000000000000000000000000000000000000;;	// license. Its contents can be found at:
0000000000000000000000000000000000000000;;	// http://creativecommons.org/publicdomain/zero/1.0/
ecec4da416f813f03bad36da050c53fcd4444152;;	
0000000000000000000000000000000000000000;;	package bindata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InputConfig defines options on a asset directory to be convert.
0000000000000000000000000000000000000000;;	type InputConfig struct {
0000000000000000000000000000000000000000;;		// Path defines a directory containing asset files to be included
0000000000000000000000000000000000000000;;		// in the generated output.
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recusive defines whether subdirectories of Path
0000000000000000000000000000000000000000;;		// should be recursively included in the conversion.
0000000000000000000000000000000000000000;;		Recursive bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Config defines a set of options for the asset conversion.
0000000000000000000000000000000000000000;;	type Config struct {
0000000000000000000000000000000000000000;;		// Name of the package to use. Defaults to 'main'.
0000000000000000000000000000000000000000;;		Package string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tags specify a set of optional build tags, which should be
0000000000000000000000000000000000000000;;		// included in the generated output. The tags are appended to a
0000000000000000000000000000000000000000;;		// `// +build` line in the beginning of the output file
0000000000000000000000000000000000000000;;		// and must follow the build tags syntax specified by the go tool.
0000000000000000000000000000000000000000;;		Tags string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Input defines the directory path, containing all asset files as
0000000000000000000000000000000000000000;;		// well as whether to recursively process assets in any sub directories.
0000000000000000000000000000000000000000;;		Input []InputConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Output defines the output file for the generated code.
0000000000000000000000000000000000000000;;		// If left empty, this defaults to 'bindata.go' in the current
0000000000000000000000000000000000000000;;		// working directory.
0000000000000000000000000000000000000000;;		Output string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prefix defines a path prefix which should be stripped from all
0000000000000000000000000000000000000000;;		// file names when generating the keys in the table of contents.
0000000000000000000000000000000000000000;;		// For example, running without the `-prefix` flag, we get:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	$ go-bindata /path/to/templates
0000000000000000000000000000000000000000;;		// 	go_bindata["/path/to/templates/foo.html"] = _path_to_templates_foo_html
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Running with the `-prefix` flag, we get:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	$ go-bindata -prefix "/path/to/" /path/to/templates/foo.html
0000000000000000000000000000000000000000;;		// 	go_bindata["templates/foo.html"] = templates_foo_html
0000000000000000000000000000000000000000;;		Prefix string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoMemCopy will alter the way the output file is generated.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// It will employ a hack that allows us to read the file data directly from
0000000000000000000000000000000000000000;;		// the compiled program's `.rodata` section. This ensures that when we call
0000000000000000000000000000000000000000;;		// call our generated function, we omit unnecessary mem copies.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The downside of this, is that it requires dependencies on the `reflect` and
0000000000000000000000000000000000000000;;		// `unsafe` packages. These may be restricted on platforms like AppEngine and
0000000000000000000000000000000000000000;;		// thus prevent you from using this mode.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Another disadvantage is that the byte slice we create, is strictly read-only.
0000000000000000000000000000000000000000;;		// For most use-cases this is not a problem, but if you ever try to alter the
0000000000000000000000000000000000000000;;		// returned byte slice, a runtime panic is thrown. Use this mode only on target
0000000000000000000000000000000000000000;;		// platforms where memory constraints are an issue.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The default behaviour is to use the old code generation method. This
0000000000000000000000000000000000000000;;		// prevents the two previously mentioned issues, but will employ at least one
0000000000000000000000000000000000000000;;		// extra memcopy and thus increase memory requirements.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// For instance, consider the following two examples:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This would be the default mode, using an extra memcopy but gives a safe
0000000000000000000000000000000000000000;;		// implementation without dependencies on `reflect` and `unsafe`:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	func myfile() []byte {
0000000000000000000000000000000000000000;;		// 		return []byte{0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a}
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Here is the same functionality, but uses the `.rodata` hack.
0000000000000000000000000000000000000000;;		// The byte slice returned from this example can not be written to without
0000000000000000000000000000000000000000;;		// generating a runtime error.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	var _myfile = "\x89\x50\x4e\x47\x0d\x0a\x1a"
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// 	func myfile() []byte {
0000000000000000000000000000000000000000;;		// 		var empty [0]byte
0000000000000000000000000000000000000000;;		// 		sx := (*reflect.StringHeader)(unsafe.Pointer(&_myfile))
0000000000000000000000000000000000000000;;		// 		b := empty[:]
0000000000000000000000000000000000000000;;		// 		bx := (*reflect.SliceHeader)(unsafe.Pointer(&b))
0000000000000000000000000000000000000000;;		// 		bx.Data = sx.Data
0000000000000000000000000000000000000000;;		// 		bx.Len = len(_myfile)
0000000000000000000000000000000000000000;;		// 		bx.Cap = bx.Len
0000000000000000000000000000000000000000;;		// 		return b
0000000000000000000000000000000000000000;;		// 	}
0000000000000000000000000000000000000000;;		NoMemCopy bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NoCompress means the assets are /not/ GZIP compressed before being turned
0000000000000000000000000000000000000000;;		// into Go code. The generated function will automatically unzip
0000000000000000000000000000000000000000;;		// the file data when called. Defaults to false.
0000000000000000000000000000000000000000;;		NoCompress bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a debug build. This generates an asset file, which
0000000000000000000000000000000000000000;;		// loads the asset contents directly from disk at their original
0000000000000000000000000000000000000000;;		// location, instead of embedding the contents in the code.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This is mostly useful if you anticipate that the assets are
0000000000000000000000000000000000000000;;		// going to change during your development cycle. You will always
0000000000000000000000000000000000000000;;		// want your code to access the latest version of the asset.
0000000000000000000000000000000000000000;;		// Only in release mode, will the assets actually be embedded
0000000000000000000000000000000000000000;;		// in the code. The default behaviour is Release mode.
0000000000000000000000000000000000000000;;		Debug bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform a dev build, which is nearly identical to the debug option. The
0000000000000000000000000000000000000000;;		// only difference is that instead of absolute file paths in generated code,
0000000000000000000000000000000000000000;;		// it expects a variable, `rootDir`, to be set in the generated code's
0000000000000000000000000000000000000000;;		// package (the author needs to do this manually), which it then prepends to
0000000000000000000000000000000000000000;;		// an asset's name to construct the file path on disk.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This is mainly so you can push the generated code file to a shared
0000000000000000000000000000000000000000;;		// repository.
0000000000000000000000000000000000000000;;		Dev bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When true, size, mode and modtime are not preserved from files
0000000000000000000000000000000000000000;;		NoMetadata bool
0000000000000000000000000000000000000000;;		// When nonzero, use this as mode for all files.
0000000000000000000000000000000000000000;;		Mode uint
0000000000000000000000000000000000000000;;		// When nonzero, use this as unix timestamp for all files.
0000000000000000000000000000000000000000;;		ModTime int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignores any filenames matching the regex pattern specified, e.g.
0000000000000000000000000000000000000000;;		// path/to/file.ext will ignore only that file, or \\.gitignore
0000000000000000000000000000000000000000;;		// will match any .gitignore file.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This parameter can be provided multiple times.
0000000000000000000000000000000000000000;;		Ignore []*regexp.Regexp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewConfig returns a default configuration struct.
0000000000000000000000000000000000000000;;	func NewConfig() *Config {
0000000000000000000000000000000000000000;;		c := new(Config)
0000000000000000000000000000000000000000;;		c.Package = "main"
0000000000000000000000000000000000000000;;		c.NoMemCopy = false
0000000000000000000000000000000000000000;;		c.NoCompress = false
0000000000000000000000000000000000000000;;		c.Debug = false
0000000000000000000000000000000000000000;;		c.Output = "./bindata.go"
0000000000000000000000000000000000000000;;		c.Ignore = make([]*regexp.Regexp, 0)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validate ensures the config has sane values.
0000000000000000000000000000000000000000;;	// Part of which means checking if certain file/directory paths exist.
0000000000000000000000000000000000000000;;	func (c *Config) validate() error {
0000000000000000000000000000000000000000;;		if len(c.Package) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Missing package name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, input := range c.Input {
0000000000000000000000000000000000000000;;			_, err := os.Lstat(input.Path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Failed to stat input path '%s': %v", input.Path, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.Output) == 0 {
0000000000000000000000000000000000000000;;			cwd, err := os.Getwd()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Unable to determine current working directory.")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.Output = filepath.Join(cwd, "bindata.go")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stat, err := os.Lstat(c.Output)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if !os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				return fmt.Errorf("Output path: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// File does not exist. This is fine, just make
0000000000000000000000000000000000000000;;			// sure the directory it is to be in exists.
0000000000000000000000000000000000000000;;			dir, _ := filepath.Split(c.Output)
0000000000000000000000000000000000000000;;			if dir != "" {
0000000000000000000000000000000000000000;;				err = os.MkdirAll(dir, 0744)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("Create output directory: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if stat != nil && stat.IsDir() {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Output path is a directory.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
