0000000000000000000000000000000000000000;;	// Package to work with VHD images
0000000000000000000000000000000000000000;;	// See https://technet.microsoft.com/en-us/virtualization/bb676673.aspx
0000000000000000000000000000000000000000;;	package vhd
bf119e8337b916a81932389e376d77629c43bfe3;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const VHD_COOKIE = "636f6e6563746978"     // conectix
0000000000000000000000000000000000000000;;	const VHD_DYN_COOKIE = "6378737061727365" // cxsparse
0000000000000000000000000000000000000000;;	const VHD_CREATOR_APP = "676f2d766864"    // go-vhd
0000000000000000000000000000000000000000;;	const VHD_CREATOR_HOST_OS = "5769326B"    // Win2k
0000000000000000000000000000000000000000;;	const VHD_BLOCK_SIZE = 2 * 1024 * 1024    // 2MB
0000000000000000000000000000000000000000;;	const VHD_HEADER_SIZE = 512
0000000000000000000000000000000000000000;;	const SECTOR_SIZE = 512
0000000000000000000000000000000000000000;;	const FOURK_SECTOR_SIZE = 4096
0000000000000000000000000000000000000000;;	const VHD_EXTRA_HEADER_SIZE = 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A VDH file
0000000000000000000000000000000000000000;;	type VHD struct {
0000000000000000000000000000000000000000;;		Footer      VHDHeader
0000000000000000000000000000000000000000;;		ExtraHeader VHDExtraHeader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VHD Header
0000000000000000000000000000000000000000;;	type VHDHeader struct {
0000000000000000000000000000000000000000;;		Cookie             [8]byte
0000000000000000000000000000000000000000;;		Features           [4]byte
0000000000000000000000000000000000000000;;		FileFormatVersion  [4]byte
0000000000000000000000000000000000000000;;		DataOffset         [8]byte
0000000000000000000000000000000000000000;;		Timestamp          [4]byte
0000000000000000000000000000000000000000;;		CreatorApplication [4]byte
0000000000000000000000000000000000000000;;		CreatorVersion     [4]byte
0000000000000000000000000000000000000000;;		CreatorHostOS      [4]byte
0000000000000000000000000000000000000000;;		OriginalSize       [8]byte
0000000000000000000000000000000000000000;;		CurrentSize        [8]byte
0000000000000000000000000000000000000000;;		DiskGeometry       [4]byte
0000000000000000000000000000000000000000;;		DiskType           [4]byte
0000000000000000000000000000000000000000;;		Checksum           [4]byte
0000000000000000000000000000000000000000;;		UniqueId           [16]byte
0000000000000000000000000000000000000000;;		SavedState         [1]byte
0000000000000000000000000000000000000000;;		Reserved           [427]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VHD extra header, for dynamic and differential disks
0000000000000000000000000000000000000000;;	type VHDExtraHeader struct {
0000000000000000000000000000000000000000;;		Cookie              [8]byte
0000000000000000000000000000000000000000;;		DataOffset          [8]byte
0000000000000000000000000000000000000000;;		TableOffset         [8]byte
0000000000000000000000000000000000000000;;		HeaderVersion       [4]byte
0000000000000000000000000000000000000000;;		MaxTableEntries     [4]byte
0000000000000000000000000000000000000000;;		BlockSize           [4]byte
0000000000000000000000000000000000000000;;		Checksum            [4]byte
0000000000000000000000000000000000000000;;		ParentUUID          [16]byte
0000000000000000000000000000000000000000;;		ParentTimestamp     [4]byte
0000000000000000000000000000000000000000;;		Reserved            [4]byte
0000000000000000000000000000000000000000;;		ParentUnicodeName   [512]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry1 [24]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry2 [24]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry3 [24]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry4 [24]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry5 [24]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry6 [24]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry7 [24]byte
0000000000000000000000000000000000000000;;		ParentLocatorEntry8 [24]byte
0000000000000000000000000000000000000000;;		Reserved2           [256]byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options for the CreateSparseVHD function
0000000000000000000000000000000000000000;;	type VHDOptions struct {
0000000000000000000000000000000000000000;;		UUID      string
0000000000000000000000000000000000000000;;		Timestamp int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 *  VHDExtraHeader methods
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (header *VHDExtraHeader) CookieString() string {
0000000000000000000000000000000000000000;;		return string(header.Cookie[:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calculate and add the VHD dynamic/differential header checksum
0000000000000000000000000000000000000000;;	func (h *VHDExtraHeader) addChecksum() {
0000000000000000000000000000000000000000;;		buffer := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		binary.Write(buffer, binary.BigEndian, h)
0000000000000000000000000000000000000000;;		checksum := 0
0000000000000000000000000000000000000000;;		bb := buffer.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for counter := 0; counter < VHD_EXTRA_HEADER_SIZE; counter++ {
0000000000000000000000000000000000000000;;			checksum += int(bb[counter])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(h.Checksum[:], uint32(^checksum))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * VHDHeader methods
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *VHDHeader) DiskTypeStr() (dt string) {
0000000000000000000000000000000000000000;;		switch h.DiskType[3] {
0000000000000000000000000000000000000000;;		case 0x00:
0000000000000000000000000000000000000000;;			dt = "None"
0000000000000000000000000000000000000000;;		case 0x01:
0000000000000000000000000000000000000000;;			dt = "Deprecated"
0000000000000000000000000000000000000000;;		case 0x02:
0000000000000000000000000000000000000000;;			dt = "Fixed"
0000000000000000000000000000000000000000;;		case 0x03:
0000000000000000000000000000000000000000;;			dt = "Dynamic"
0000000000000000000000000000000000000000;;		case 0x04:
0000000000000000000000000000000000000000;;			dt = "Differential"
0000000000000000000000000000000000000000;;		case 0x05:
0000000000000000000000000000000000000000;;			dt = "Reserved"
0000000000000000000000000000000000000000;;		case 0x06:
0000000000000000000000000000000000000000;;			dt = "Reserved"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("Invalid disk type detected!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the timestamp of the header
0000000000000000000000000000000000000000;;	func (h *VHDHeader) TimestampTime() time.Time {
0000000000000000000000000000000000000000;;		tstamp := binary.BigEndian.Uint32(h.Timestamp[:])
0000000000000000000000000000000000000000;;		return time.Unix(int64(946684800+tstamp), 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calculate and add the VHD header checksum
0000000000000000000000000000000000000000;;	func (h *VHDHeader) addChecksum() {
0000000000000000000000000000000000000000;;		buffer := new(bytes.Buffer)
0000000000000000000000000000000000000000;;		binary.Write(buffer, binary.BigEndian, h)
0000000000000000000000000000000000000000;;		checksum := 0
0000000000000000000000000000000000000000;;		bb := buffer.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for counter := 0; counter < VHD_HEADER_SIZE; counter++ {
0000000000000000000000000000000000000000;;			checksum += int(bb[counter])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(h.Checksum[:], uint32(^checksum))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CreateFixedHeader(size uint64, options *VHDOptions) VHDHeader {
0000000000000000000000000000000000000000;;		header := VHDHeader{}
0000000000000000000000000000000000000000;;		hexToField(VHD_COOKIE, header.Cookie[:])
0000000000000000000000000000000000000000;;		hexToField("00000002", header.Features[:])
0000000000000000000000000000000000000000;;		hexToField("00010000", header.FileFormatVersion[:])
0000000000000000000000000000000000000000;;		hexToField("ffffffffffffffff", header.DataOffset[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LOL Y2038
0000000000000000000000000000000000000000;;		if options.Timestamp != 0 {
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(header.Timestamp[:], uint32(options.Timestamp))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t := uint32(time.Now().Unix() - 946684800)
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(header.Timestamp[:], t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hexToField(VHD_CREATOR_APP, header.CreatorApplication[:])
0000000000000000000000000000000000000000;;		hexToField(VHD_CREATOR_HOST_OS, header.CreatorHostOS[:])
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(header.OriginalSize[:], size)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(header.CurrentSize[:], size)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// total sectors = disk size / 512b sector size
0000000000000000000000000000000000000000;;		totalSectors := math.Floor(float64(size / 512))
0000000000000000000000000000000000000000;;		// [C, H, S]
0000000000000000000000000000000000000000;;		geometry := calculateCHS(uint64(totalSectors))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(header.DiskGeometry[:2], uint16(geometry[0]))
0000000000000000000000000000000000000000;;		header.DiskGeometry[2] = uint8(geometry[1])
0000000000000000000000000000000000000000;;		header.DiskGeometry[3] = uint8(geometry[2])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hexToField("00000002", header.DiskType[:]) // Fixed 0x00000002
0000000000000000000000000000000000000000;;		hexToField("00000000", header.Checksum[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.UUID != "" {
0000000000000000000000000000000000000000;;			copy(header.UniqueId[:], uuidToBytes(options.UUID))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			copy(header.UniqueId[:], uuidgenBytes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header.addChecksum()
0000000000000000000000000000000000000000;;		return header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RawToFixed(f *os.File, options *VHDOptions) {
0000000000000000000000000000000000000000;;		info, err := f.Stat()
0000000000000000000000000000000000000000;;		check(err)
0000000000000000000000000000000000000000;;		size := uint64(info.Size())
0000000000000000000000000000000000000000;;		header := CreateFixedHeader(size, options)
0000000000000000000000000000000000000000;;		binary.Write(f, binary.BigEndian, header)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VHDCreateSparse(size uint64, name string, options VHDOptions) VHD {
0000000000000000000000000000000000000000;;		header := VHDHeader{}
0000000000000000000000000000000000000000;;		hexToField(VHD_COOKIE, header.Cookie[:])
0000000000000000000000000000000000000000;;		hexToField("00000002", header.Features[:])
0000000000000000000000000000000000000000;;		hexToField("00010000", header.FileFormatVersion[:])
0000000000000000000000000000000000000000;;		hexToField("0000000000000200", header.DataOffset[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// LOL Y2038
0000000000000000000000000000000000000000;;		if options.Timestamp != 0 {
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(header.Timestamp[:], uint32(options.Timestamp))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t := uint32(time.Now().Unix() - 946684800)
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint32(header.Timestamp[:], t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hexToField(VHD_CREATOR_APP, header.CreatorApplication[:])
0000000000000000000000000000000000000000;;		hexToField(VHD_CREATOR_HOST_OS, header.CreatorHostOS[:])
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(header.OriginalSize[:], size)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(header.CurrentSize[:], size)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// total sectors = disk size / 512b sector size
0000000000000000000000000000000000000000;;		totalSectors := math.Floor(float64(size / 512))
0000000000000000000000000000000000000000;;		// [C, H, S]
0000000000000000000000000000000000000000;;		geometry := calculateCHS(uint64(totalSectors))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(header.DiskGeometry[:2], uint16(geometry[0]))
0000000000000000000000000000000000000000;;		header.DiskGeometry[2] = uint8(geometry[1])
0000000000000000000000000000000000000000;;		header.DiskGeometry[3] = uint8(geometry[2])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hexToField("00000003", header.DiskType[:]) // Sparse 0x00000003
0000000000000000000000000000000000000000;;		hexToField("00000000", header.Checksum[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.UUID != "" {
0000000000000000000000000000000000000000;;			copy(header.UniqueId[:], uuidToBytes(options.UUID))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			copy(header.UniqueId[:], uuidgenBytes())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		header.addChecksum()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill the sparse header
0000000000000000000000000000000000000000;;		header2 := VHDExtraHeader{}
0000000000000000000000000000000000000000;;		hexToField(VHD_DYN_COOKIE, header2.Cookie[:])
0000000000000000000000000000000000000000;;		hexToField("ffffffffffffffff", header2.DataOffset[:])
0000000000000000000000000000000000000000;;		// header size + sparse header size
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(header2.TableOffset[:], uint64(VHD_EXTRA_HEADER_SIZE+VHD_HEADER_SIZE))
0000000000000000000000000000000000000000;;		hexToField("00010000", header2.HeaderVersion[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxTableSize := uint32(size / (VHD_BLOCK_SIZE))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(header2.MaxTableEntries[:], maxTableSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(header2.BlockSize[:], VHD_BLOCK_SIZE)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(header2.ParentTimestamp[:], uint32(0))
0000000000000000000000000000000000000000;;		header2.addChecksum()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Create(name)
0000000000000000000000000000000000000000;;		check(err)
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.Write(f, binary.BigEndian, header)
0000000000000000000000000000000000000000;;		binary.Write(f, binary.BigEndian, header2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			Write BAT entries
0000000000000000000000000000000000000000;;			The BAT is always extended to a sector (4K) boundary
0000000000000000000000000000000000000000;;			1536 = 512 + 1024 (the VHD Header + VHD Sparse header size)
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;		for count := uint32(0); count < (FOURK_SECTOR_SIZE - 1536); count += 1 {
0000000000000000000000000000000000000000;;			f.Write([]byte{0xff})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/* Windows creates 8K VHDs by default */
0000000000000000000000000000000000000000;;		for i := 0; i < (FOURK_SECTOR_SIZE - VHD_HEADER_SIZE); i += 1 {
0000000000000000000000000000000000000000;;			f.Write([]byte{0x0})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.Write(f, binary.BigEndian, header)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return VHD{
0000000000000000000000000000000000000000;;			Footer:      header,
0000000000000000000000000000000000000000;;			ExtraHeader: header2,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * VHD
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FromFile(f *os.File) (vhd VHD) {
0000000000000000000000000000000000000000;;		vhd = VHD{}
0000000000000000000000000000000000000000;;		vhd.Footer = readVHDFooter(f)
0000000000000000000000000000000000000000;;		vhd.ExtraHeader = readVHDExtraHeader(f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vhd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vhd *VHD) PrintInfo() {
0000000000000000000000000000000000000000;;		fmt.Println("\nVHD footer")
0000000000000000000000000000000000000000;;		fmt.Println("==========")
0000000000000000000000000000000000000000;;		vhd.PrintFooter()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vhd.Footer.DiskType[3] == 0x3 || vhd.Footer.DiskType[3] == 0x04 {
0000000000000000000000000000000000000000;;			fmt.Println("\nVHD sparse/differential header")
0000000000000000000000000000000000000000;;			fmt.Println("===============================")
0000000000000000000000000000000000000000;;			vhd.PrintExtraHeader()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vhd *VHD) PrintExtraHeader() {
0000000000000000000000000000000000000000;;		header := vhd.ExtraHeader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmtField("Cookie", fmt.Sprintf("%s (%s)",
0000000000000000000000000000000000000000;;			hexs(header.Cookie[:]), header.CookieString()))
0000000000000000000000000000000000000000;;		fmtField("Data offset", hexs(header.DataOffset[:]))
0000000000000000000000000000000000000000;;		fmtField("Table offset", hexs(header.TableOffset[:]))
0000000000000000000000000000000000000000;;		fmtField("Header version", hexs(header.HeaderVersion[:]))
0000000000000000000000000000000000000000;;		fmtField("Max table entries", hexs(header.MaxTableEntries[:]))
0000000000000000000000000000000000000000;;		fmtField("Block size", hexs(header.BlockSize[:]))
0000000000000000000000000000000000000000;;		fmtField("Checksum", hexs(header.Checksum[:]))
0000000000000000000000000000000000000000;;		fmtField("Parent UUID", uuid(header.ParentUUID[:]))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Seconds since January 1, 1970 12:00:00 AM in UTC/GMT.
0000000000000000000000000000000000000000;;		// 946684800 = January 1, 2000 12:00:00 AM in UTC/GMT.
0000000000000000000000000000000000000000;;		tstamp := binary.BigEndian.Uint32(header.ParentTimestamp[:])
0000000000000000000000000000000000000000;;		t := time.Unix(int64(946684800+tstamp), 0)
0000000000000000000000000000000000000000;;		fmtField("Parent timestamp", fmt.Sprintf("%s", t))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmtField("Reserved", hexs(header.Reserved[:]))
0000000000000000000000000000000000000000;;		parentName := utf16BytesToString(header.ParentUnicodeName[:],
0000000000000000000000000000000000000000;;			binary.BigEndian)
0000000000000000000000000000000000000000;;		fmtField("Parent Name", parentName)
0000000000000000000000000000000000000000;;		// Parent locator entries ignored since it's a dynamic disk
0000000000000000000000000000000000000000;;		sum := 0
0000000000000000000000000000000000000000;;		for _, b := range header.Reserved2 {
0000000000000000000000000000000000000000;;			sum += int(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fmtField("Reserved2", strconv.Itoa(sum))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (vhd *VHD) PrintFooter() {
0000000000000000000000000000000000000000;;		header := vhd.Footer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//fmtField("Cookie", string(header.Cookie[:]))
0000000000000000000000000000000000000000;;		fmtField("Cookie", fmt.Sprintf("%s (%s)",
0000000000000000000000000000000000000000;;			hexs(header.Cookie[:]), string(header.Cookie[:])))
0000000000000000000000000000000000000000;;		fmtField("Features", hexs(header.Features[:]))
0000000000000000000000000000000000000000;;		fmtField("File format version", hexs(header.FileFormatVersion[:]))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataOffset := binary.BigEndian.Uint64(header.DataOffset[:])
0000000000000000000000000000000000000000;;		fmtField("Data offset",
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s (%d bytes)", hexs(header.DataOffset[:]), dataOffset))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//// Seconds since January 1, 1970 12:00:00 AM in UTC/GMT.
0000000000000000000000000000000000000000;;		//// 946684800 = January 1, 2000 12:00:00 AM in UTC/GMT.
0000000000000000000000000000000000000000;;		t := time.Unix(int64(946684800+binary.BigEndian.Uint32(header.Timestamp[:])), 0)
0000000000000000000000000000000000000000;;		fmtField("Timestamp", fmt.Sprintf("%s", t))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmtField("Creator application", string(header.CreatorApplication[:]))
0000000000000000000000000000000000000000;;		fmtField("Creator version", hexs(header.CreatorVersion[:]))
0000000000000000000000000000000000000000;;		fmtField("Creator OS", string(header.CreatorHostOS[:]))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		originalSize := binary.BigEndian.Uint64(header.OriginalSize[:])
0000000000000000000000000000000000000000;;		fmtField("Original size",
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s ( %d bytes )", hexs(header.OriginalSize[:]), originalSize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentSize := binary.BigEndian.Uint64(header.OriginalSize[:])
0000000000000000000000000000000000000000;;		fmtField("Current size",
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s ( %d bytes )", hexs(header.CurrentSize[:]), currentSize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cilinders := int64(binary.BigEndian.Uint16(header.DiskGeometry[:2]))
0000000000000000000000000000000000000000;;		heads := int64(header.DiskGeometry[2])
0000000000000000000000000000000000000000;;		sectors := int64(header.DiskGeometry[3])
0000000000000000000000000000000000000000;;		dsize := cilinders * heads * sectors * 512
0000000000000000000000000000000000000000;;		fmtField("Disk geometry",
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s (c: %d, h: %d, s: %d) (%d bytes)",
0000000000000000000000000000000000000000;;				hexs(header.DiskGeometry[:]),
0000000000000000000000000000000000000000;;				cilinders,
0000000000000000000000000000000000000000;;				heads,
0000000000000000000000000000000000000000;;				sectors,
0000000000000000000000000000000000000000;;				dsize))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmtField("Disk type",
0000000000000000000000000000000000000000;;			fmt.Sprintf("%s (%s)", hexs(header.DiskType[:]), header.DiskTypeStr()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmtField("Checksum", hexs(header.Checksum[:]))
0000000000000000000000000000000000000000;;		fmtField("UUID", uuid(header.UniqueId[:]))
0000000000000000000000000000000000000000;;		fmtField("Saved state", fmt.Sprintf("%d", header.SavedState[0]))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		Utility functions
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func calculateCHS(ts uint64) []uint {
0000000000000000000000000000000000000000;;		var sectorsPerTrack,
0000000000000000000000000000000000000000;;			heads,
0000000000000000000000000000000000000000;;			cylinderTimesHeads,
0000000000000000000000000000000000000000;;			cylinders float64
0000000000000000000000000000000000000000;;		totalSectors := float64(ts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := make([]uint, 3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if totalSectors > 65535*16*255 {
0000000000000000000000000000000000000000;;			totalSectors = 65535 * 16 * 255
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if totalSectors >= 65535*16*63 {
0000000000000000000000000000000000000000;;			sectorsPerTrack = 255
0000000000000000000000000000000000000000;;			heads = 16
0000000000000000000000000000000000000000;;			cylinderTimesHeads = math.Floor(totalSectors / sectorsPerTrack)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sectorsPerTrack = 17
0000000000000000000000000000000000000000;;			cylinderTimesHeads = math.Floor(totalSectors / sectorsPerTrack)
0000000000000000000000000000000000000000;;			heads = math.Floor((cylinderTimesHeads + 1023) / 1024)
0000000000000000000000000000000000000000;;			if heads < 4 {
0000000000000000000000000000000000000000;;				heads = 4
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (cylinderTimesHeads >= (heads * 1024)) || heads > 16 {
0000000000000000000000000000000000000000;;				sectorsPerTrack = 31
0000000000000000000000000000000000000000;;				heads = 16
0000000000000000000000000000000000000000;;				cylinderTimesHeads = math.Floor(totalSectors / sectorsPerTrack)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cylinderTimesHeads >= (heads * 1024) {
0000000000000000000000000000000000000000;;				sectorsPerTrack = 63
0000000000000000000000000000000000000000;;				heads = 16
0000000000000000000000000000000000000000;;				cylinderTimesHeads = math.Floor(totalSectors / sectorsPerTrack)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cylinders = cylinderTimesHeads / heads
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This will floor the values
0000000000000000000000000000000000000000;;		ret[0] = uint(cylinders)
0000000000000000000000000000000000000000;;		ret[1] = uint(heads)
0000000000000000000000000000000000000000;;		ret[2] = uint(sectorsPerTrack)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hexToField(hexs string, field []byte) {
0000000000000000000000000000000000000000;;		h, err := hex.DecodeString(hexs)
0000000000000000000000000000000000000000;;		check(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(field, h)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the number of blocks in the disk, diskSize in bytes
0000000000000000000000000000000000000000;;	func getMaxTableEntries(diskSize uint64) uint64 {
0000000000000000000000000000000000000000;;		return diskSize * (2 * 1024 * 1024) // block size is 2M
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readVHDExtraHeader(f *os.File) (header VHDExtraHeader) {
0000000000000000000000000000000000000000;;		buff := make([]byte, 1024)
0000000000000000000000000000000000000000;;		_, err := f.ReadAt(buff, 512)
0000000000000000000000000000000000000000;;		check(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.Read(bytes.NewBuffer(buff[:]), binary.BigEndian, &header)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readVHDFooter(f *os.File) (header VHDHeader) {
0000000000000000000000000000000000000000;;		info, err := f.Stat()
0000000000000000000000000000000000000000;;		check(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buff := make([]byte, 512)
0000000000000000000000000000000000000000;;		_, err = f.ReadAt(buff, info.Size()-512)
0000000000000000000000000000000000000000;;		check(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.Read(bytes.NewBuffer(buff[:]), binary.BigEndian, &header)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return header
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readVHDHeader(f *os.File) (header VHDHeader) {
0000000000000000000000000000000000000000;;		buff := make([]byte, 512)
0000000000000000000000000000000000000000;;		_, err := f.ReadAt(buff, 0)
0000000000000000000000000000000000000000;;		check(err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.Read(bytes.NewBuffer(buff[:]), binary.BigEndian, &header)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return header
0000000000000000000000000000000000000000;;	}
