0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8329b5f94b1a4a7919ce36cf38e5a9fa0715aaf4;Godeps/_workspace/src/github.com/gogo/protobuf/proto/pointer_unsafe_gogo.go[Godeps/_workspace/src/github.com/gogo/protobuf/proto/pointer_unsafe_gogo.go][vendor/github.com/gogo/protobuf/proto/pointer_unsafe_gogo.go];	
0000000000000000000000000000000000000000;;	// +build !appengine,!js
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains the implementation of the proto field accesses using package unsafe.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_InterfaceAt(p structPointer, f field, t reflect.Type) interface{} {
0000000000000000000000000000000000000000;;		point := unsafe.Pointer(uintptr(p) + uintptr(f))
0000000000000000000000000000000000000000;;		r := reflect.NewAt(t, point)
0000000000000000000000000000000000000000;;		return r.Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_InterfaceRef(p structPointer, f field, t reflect.Type) interface{} {
0000000000000000000000000000000000000000;;		point := unsafe.Pointer(uintptr(p) + uintptr(f))
0000000000000000000000000000000000000000;;		r := reflect.NewAt(t, point)
0000000000000000000000000000000000000000;;		if r.Elem().IsNil() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.Elem().Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyUintPtr(oldptr, newptr uintptr, size int) {
0000000000000000000000000000000000000000;;		oldbytes := make([]byte, 0)
0000000000000000000000000000000000000000;;		oldslice := (*reflect.SliceHeader)(unsafe.Pointer(&oldbytes))
0000000000000000000000000000000000000000;;		oldslice.Data = oldptr
0000000000000000000000000000000000000000;;		oldslice.Len = size
0000000000000000000000000000000000000000;;		oldslice.Cap = size
0000000000000000000000000000000000000000;;		newbytes := make([]byte, 0)
0000000000000000000000000000000000000000;;		newslice := (*reflect.SliceHeader)(unsafe.Pointer(&newbytes))
0000000000000000000000000000000000000000;;		newslice.Data = newptr
0000000000000000000000000000000000000000;;		newslice.Len = size
0000000000000000000000000000000000000000;;		newslice.Cap = size
0000000000000000000000000000000000000000;;		copy(newbytes, oldbytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_Copy(oldptr structPointer, newptr structPointer, size int) {
0000000000000000000000000000000000000000;;		copyUintPtr(uintptr(oldptr), uintptr(newptr), size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendStructPointer(base structPointer, f field, typ reflect.Type) structPointer {
0000000000000000000000000000000000000000;;		size := typ.Elem().Size()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldHeader := structPointer_GetSliceHeader(base, f)
0000000000000000000000000000000000000000;;		oldSlice := reflect.NewAt(typ, unsafe.Pointer(oldHeader)).Elem()
0000000000000000000000000000000000000000;;		newLen := oldHeader.Len + 1
0000000000000000000000000000000000000000;;		newSlice := reflect.MakeSlice(typ, newLen, newLen)
0000000000000000000000000000000000000000;;		reflect.Copy(newSlice, oldSlice)
0000000000000000000000000000000000000000;;		bas := toStructPointer(newSlice)
0000000000000000000000000000000000000000;;		oldHeader.Data = uintptr(bas)
0000000000000000000000000000000000000000;;		oldHeader.Len = newLen
0000000000000000000000000000000000000000;;		oldHeader.Cap = newLen
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return structPointer(unsafe.Pointer(uintptr(unsafe.Pointer(bas)) + uintptr(uintptr(newLen-1)*size)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_FieldPointer(p structPointer, f field) structPointer {
0000000000000000000000000000000000000000;;		return structPointer(unsafe.Pointer(uintptr(p) + uintptr(f)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_GetRefStructPointer(p structPointer, f field) structPointer {
0000000000000000000000000000000000000000;;		return structPointer((*structPointer)(unsafe.Pointer(uintptr(p) + uintptr(f))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_GetSliceHeader(p structPointer, f field) *reflect.SliceHeader {
0000000000000000000000000000000000000000;;		return (*reflect.SliceHeader)(unsafe.Pointer(uintptr(p) + uintptr(f)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_Add(p structPointer, size field) structPointer {
0000000000000000000000000000000000000000;;		return structPointer(unsafe.Pointer(uintptr(p) + uintptr(size)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_Len(p structPointer, f field) int {
0000000000000000000000000000000000000000;;		return len(*(*[]interface{})(unsafe.Pointer(structPointer_GetRefStructPointer(p, f))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_StructRefSlice(p structPointer, f field, size uintptr) *structRefSlice {
0000000000000000000000000000000000000000;;		return &structRefSlice{p: p, f: f, size: size}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A structRefSlice represents a slice of structs (themselves submessages or groups).
0000000000000000000000000000000000000000;;	type structRefSlice struct {
0000000000000000000000000000000000000000;;		p    structPointer
0000000000000000000000000000000000000000;;		f    field
0000000000000000000000000000000000000000;;		size uintptr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *structRefSlice) Len() int {
0000000000000000000000000000000000000000;;		return structPointer_Len(v.p, v.f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *structRefSlice) Index(i int) structPointer {
0000000000000000000000000000000000000000;;		ss := structPointer_GetStructPointer(v.p, v.f)
0000000000000000000000000000000000000000;;		ss1 := structPointer_GetRefStructPointer(ss, 0)
0000000000000000000000000000000000000000;;		return structPointer_Add(ss1, field(uintptr(i)*v.size))
0000000000000000000000000000000000000000;;	}
