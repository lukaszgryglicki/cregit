0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8329b5f94b1a4a7919ce36cf38e5a9fa0715aaf4;Godeps/_workspace/src/github.com/gogo/protobuf/proto/properties.go[Godeps/_workspace/src/github.com/gogo/protobuf/proto/properties.go][vendor/github.com/gogo/protobuf/proto/properties.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Routines for encoding data into the wire format for protocol buffers.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const debug bool = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constants that identify the encoding of a value on the wire.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		WireVarint     = 0
0000000000000000000000000000000000000000;;		WireFixed64    = 1
0000000000000000000000000000000000000000;;		WireBytes      = 2
0000000000000000000000000000000000000000;;		WireStartGroup = 3
0000000000000000000000000000000000000000;;		WireEndGroup   = 4
0000000000000000000000000000000000000000;;		WireFixed32    = 5
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const startSize = 10 // initial slice/string sizes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encoders are defined in encode.go
0000000000000000000000000000000000000000;;	// An encoder outputs the full representation of a field, including its
0000000000000000000000000000000000000000;;	// tag and encoder type.
0000000000000000000000000000000000000000;;	type encoder func(p *Buffer, prop *Properties, base structPointer) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A valueEncoder encodes a single integer in a particular encoding.
0000000000000000000000000000000000000000;;	type valueEncoder func(o *Buffer, x uint64) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sizers are defined in encode.go
0000000000000000000000000000000000000000;;	// A sizer returns the encoded size of a field, including its tag and encoder
0000000000000000000000000000000000000000;;	// type.
0000000000000000000000000000000000000000;;	type sizer func(prop *Properties, base structPointer) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A valueSizer returns the encoded size of a single integer in a particular
0000000000000000000000000000000000000000;;	// encoding.
0000000000000000000000000000000000000000;;	type valueSizer func(x uint64) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decoders are defined in decode.go
0000000000000000000000000000000000000000;;	// A decoder creates a value from its wire representation.
0000000000000000000000000000000000000000;;	// Unrecognized subelements are saved in unrec.
0000000000000000000000000000000000000000;;	type decoder func(p *Buffer, prop *Properties, base structPointer) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A valueDecoder decodes a single integer in a particular encoding.
0000000000000000000000000000000000000000;;	type valueDecoder func(o *Buffer) (x uint64, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A oneofMarshaler does the marshaling for all oneof fields in a message.
0000000000000000000000000000000000000000;;	type oneofMarshaler func(Message, *Buffer) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A oneofUnmarshaler does the unmarshaling for a oneof field in a message.
0000000000000000000000000000000000000000;;	type oneofUnmarshaler func(Message, int, int, *Buffer) (bool, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A oneofSizer does the sizing for all oneof fields in a message.
0000000000000000000000000000000000000000;;	type oneofSizer func(Message) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagMap is an optimization over map[int]int for typical protocol buffer
0000000000000000000000000000000000000000;;	// use-cases. Encoded protocol buffers are often in tag order with small tag
0000000000000000000000000000000000000000;;	// numbers.
0000000000000000000000000000000000000000;;	type tagMap struct {
0000000000000000000000000000000000000000;;		fastTags []int
0000000000000000000000000000000000000000;;		slowTags map[int]int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagMapFastLimit is the upper bound on the tag number that will be stored in
0000000000000000000000000000000000000000;;	// the tagMap slice rather than its map.
0000000000000000000000000000000000000000;;	const tagMapFastLimit = 1024
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tagMap) get(t int) (int, bool) {
0000000000000000000000000000000000000000;;		if t > 0 && t < tagMapFastLimit {
0000000000000000000000000000000000000000;;			if t >= len(p.fastTags) {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fi := p.fastTags[t]
0000000000000000000000000000000000000000;;			return fi, fi >= 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fi, ok := p.slowTags[t]
0000000000000000000000000000000000000000;;		return fi, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tagMap) put(t int, fi int) {
0000000000000000000000000000000000000000;;		if t > 0 && t < tagMapFastLimit {
0000000000000000000000000000000000000000;;			for len(p.fastTags) < t+1 {
0000000000000000000000000000000000000000;;				p.fastTags = append(p.fastTags, -1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.fastTags[t] = fi
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.slowTags == nil {
0000000000000000000000000000000000000000;;			p.slowTags = make(map[int]int)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.slowTags[t] = fi
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StructProperties represents properties for all the fields of a struct.
0000000000000000000000000000000000000000;;	// decoderTags and decoderOrigNames should only be used by the decoder.
0000000000000000000000000000000000000000;;	type StructProperties struct {
0000000000000000000000000000000000000000;;		Prop             []*Properties  // properties for each field
0000000000000000000000000000000000000000;;		reqCount         int            // required count
0000000000000000000000000000000000000000;;		decoderTags      tagMap         // map from proto tag to struct field number
0000000000000000000000000000000000000000;;		decoderOrigNames map[string]int // map from original name to struct field number
0000000000000000000000000000000000000000;;		order            []int          // list of struct field numbers in tag order
0000000000000000000000000000000000000000;;		unrecField       field          // field id of the XXX_unrecognized []byte field
0000000000000000000000000000000000000000;;		extendable       bool           // is this an extendable proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oneofMarshaler   oneofMarshaler
0000000000000000000000000000000000000000;;		oneofUnmarshaler oneofUnmarshaler
0000000000000000000000000000000000000000;;		oneofSizer       oneofSizer
0000000000000000000000000000000000000000;;		stype            reflect.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OneofTypes contains information about the oneof fields in this message.
0000000000000000000000000000000000000000;;		// It is keyed by the original name of a field.
0000000000000000000000000000000000000000;;		OneofTypes map[string]*OneofProperties
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OneofProperties represents information about a specific field in a oneof.
0000000000000000000000000000000000000000;;	type OneofProperties struct {
0000000000000000000000000000000000000000;;		Type  reflect.Type // pointer to generated struct type for this oneof field
0000000000000000000000000000000000000000;;		Field int          // struct field number of the containing oneof in the message
0000000000000000000000000000000000000000;;		Prop  *Properties
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implement the sorting interface so we can sort the fields in tag order, as recommended by the spec.
0000000000000000000000000000000000000000;;	// See encode.go, (*Buffer).enc_struct.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sp *StructProperties) Len() int { return len(sp.order) }
0000000000000000000000000000000000000000;;	func (sp *StructProperties) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return sp.Prop[sp.order[i]].Tag < sp.Prop[sp.order[j]].Tag
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (sp *StructProperties) Swap(i, j int) { sp.order[i], sp.order[j] = sp.order[j], sp.order[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Properties represents the protocol-specific behavior of a single struct field.
0000000000000000000000000000000000000000;;	type Properties struct {
0000000000000000000000000000000000000000;;		Name     string // name of the field, for error messages
0000000000000000000000000000000000000000;;		OrigName string // original name before protocol compiler (always set)
0000000000000000000000000000000000000000;;		JSONName string // name to use for JSON; determined by protoc
0000000000000000000000000000000000000000;;		Wire     string
0000000000000000000000000000000000000000;;		WireType int
0000000000000000000000000000000000000000;;		Tag      int
0000000000000000000000000000000000000000;;		Required bool
0000000000000000000000000000000000000000;;		Optional bool
0000000000000000000000000000000000000000;;		Repeated bool
0000000000000000000000000000000000000000;;		Packed   bool   // relevant for repeated primitives only
0000000000000000000000000000000000000000;;		Enum     string // set for enum types only
0000000000000000000000000000000000000000;;		proto3   bool   // whether this is known to be a proto3 field; set for []byte only
0000000000000000000000000000000000000000;;		oneof    bool   // whether this is a oneof field
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Default     string // default value
0000000000000000000000000000000000000000;;		HasDefault  bool   // whether an explicit default was provided
0000000000000000000000000000000000000000;;		CustomType  string
0000000000000000000000000000000000000000;;		StdTime     bool
0000000000000000000000000000000000000000;;		StdDuration bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enc           encoder
0000000000000000000000000000000000000000;;		valEnc        valueEncoder // set for bool and numeric types only
0000000000000000000000000000000000000000;;		field         field
0000000000000000000000000000000000000000;;		tagcode       []byte // encoding of EncodeVarint((Tag<<3)|WireType)
0000000000000000000000000000000000000000;;		tagbuf        [8]byte
0000000000000000000000000000000000000000;;		stype         reflect.Type      // set for struct types only
0000000000000000000000000000000000000000;;		sstype        reflect.Type      // set for slices of structs types only
0000000000000000000000000000000000000000;;		ctype         reflect.Type      // set for custom types only
0000000000000000000000000000000000000000;;		sprop         *StructProperties // set for struct types only
0000000000000000000000000000000000000000;;		isMarshaler   bool
0000000000000000000000000000000000000000;;		isUnmarshaler bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mtype    reflect.Type // set for map types only
0000000000000000000000000000000000000000;;		mkeyprop *Properties  // set for map types only
0000000000000000000000000000000000000000;;		mvalprop *Properties  // set for map types only
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size    sizer
0000000000000000000000000000000000000000;;		valSize valueSizer // set for bool and numeric types only
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec    decoder
0000000000000000000000000000000000000000;;		valDec valueDecoder // set for bool and numeric types only
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If this is a packable field, this will be the decoder for the packed version of the field.
0000000000000000000000000000000000000000;;		packedDec decoder
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String formats the properties in the protobuf struct field tag style.
0000000000000000000000000000000000000000;;	func (p *Properties) String() string {
0000000000000000000000000000000000000000;;		s := p.Wire
0000000000000000000000000000000000000000;;		s = ","
0000000000000000000000000000000000000000;;		s += strconv.Itoa(p.Tag)
0000000000000000000000000000000000000000;;		if p.Required {
0000000000000000000000000000000000000000;;			s += ",req"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Optional {
0000000000000000000000000000000000000000;;			s += ",opt"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Repeated {
0000000000000000000000000000000000000000;;			s += ",rep"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Packed {
0000000000000000000000000000000000000000;;			s += ",packed"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s += ",name=" + p.OrigName
0000000000000000000000000000000000000000;;		if p.JSONName != p.OrigName {
0000000000000000000000000000000000000000;;			s += ",json=" + p.JSONName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.proto3 {
0000000000000000000000000000000000000000;;			s += ",proto3"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.oneof {
0000000000000000000000000000000000000000;;			s += ",oneof"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p.Enum) > 0 {
0000000000000000000000000000000000000000;;			s += ",enum=" + p.Enum
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.HasDefault {
0000000000000000000000000000000000000000;;			s += ",def=" + p.Default
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse populates p by parsing a string in the protobuf struct field tag style.
0000000000000000000000000000000000000000;;	func (p *Properties) Parse(s string) {
0000000000000000000000000000000000000000;;		// "bytes,49,opt,name=foo,def=hello!"
0000000000000000000000000000000000000000;;		fields := strings.Split(s, ",") // breaks def=, but handled below.
0000000000000000000000000000000000000000;;		if len(fields) < 2 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "proto: tag has too few fields: %q\n", s)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.Wire = fields[0]
0000000000000000000000000000000000000000;;		switch p.Wire {
0000000000000000000000000000000000000000;;		case "varint":
0000000000000000000000000000000000000000;;			p.WireType = WireVarint
0000000000000000000000000000000000000000;;			p.valEnc = (*Buffer).EncodeVarint
0000000000000000000000000000000000000000;;			p.valDec = (*Buffer).DecodeVarint
0000000000000000000000000000000000000000;;			p.valSize = sizeVarint
0000000000000000000000000000000000000000;;		case "fixed32":
0000000000000000000000000000000000000000;;			p.WireType = WireFixed32
0000000000000000000000000000000000000000;;			p.valEnc = (*Buffer).EncodeFixed32
0000000000000000000000000000000000000000;;			p.valDec = (*Buffer).DecodeFixed32
0000000000000000000000000000000000000000;;			p.valSize = sizeFixed32
0000000000000000000000000000000000000000;;		case "fixed64":
0000000000000000000000000000000000000000;;			p.WireType = WireFixed64
0000000000000000000000000000000000000000;;			p.valEnc = (*Buffer).EncodeFixed64
0000000000000000000000000000000000000000;;			p.valDec = (*Buffer).DecodeFixed64
0000000000000000000000000000000000000000;;			p.valSize = sizeFixed64
0000000000000000000000000000000000000000;;		case "zigzag32":
0000000000000000000000000000000000000000;;			p.WireType = WireVarint
0000000000000000000000000000000000000000;;			p.valEnc = (*Buffer).EncodeZigzag32
0000000000000000000000000000000000000000;;			p.valDec = (*Buffer).DecodeZigzag32
0000000000000000000000000000000000000000;;			p.valSize = sizeZigzag32
0000000000000000000000000000000000000000;;		case "zigzag64":
0000000000000000000000000000000000000000;;			p.WireType = WireVarint
0000000000000000000000000000000000000000;;			p.valEnc = (*Buffer).EncodeZigzag64
0000000000000000000000000000000000000000;;			p.valDec = (*Buffer).DecodeZigzag64
0000000000000000000000000000000000000000;;			p.valSize = sizeZigzag64
0000000000000000000000000000000000000000;;		case "bytes", "group":
0000000000000000000000000000000000000000;;			p.WireType = WireBytes
0000000000000000000000000000000000000000;;			// no numeric converter for non-numeric types
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "proto: tag has unknown wire type: %q\n", s)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		p.Tag, err = strconv.Atoi(fields[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 2; i < len(fields); i++ {
0000000000000000000000000000000000000000;;			f := fields[i]
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case f == "req":
0000000000000000000000000000000000000000;;				p.Required = true
0000000000000000000000000000000000000000;;			case f == "opt":
0000000000000000000000000000000000000000;;				p.Optional = true
0000000000000000000000000000000000000000;;			case f == "rep":
0000000000000000000000000000000000000000;;				p.Repeated = true
0000000000000000000000000000000000000000;;			case f == "packed":
0000000000000000000000000000000000000000;;				p.Packed = true
0000000000000000000000000000000000000000;;			case strings.HasPrefix(f, "name="):
0000000000000000000000000000000000000000;;				p.OrigName = f[5:]
0000000000000000000000000000000000000000;;			case strings.HasPrefix(f, "json="):
0000000000000000000000000000000000000000;;				p.JSONName = f[5:]
0000000000000000000000000000000000000000;;			case strings.HasPrefix(f, "enum="):
0000000000000000000000000000000000000000;;				p.Enum = f[5:]
0000000000000000000000000000000000000000;;			case f == "proto3":
0000000000000000000000000000000000000000;;				p.proto3 = true
0000000000000000000000000000000000000000;;			case f == "oneof":
0000000000000000000000000000000000000000;;				p.oneof = true
0000000000000000000000000000000000000000;;			case strings.HasPrefix(f, "def="):
0000000000000000000000000000000000000000;;				p.HasDefault = true
0000000000000000000000000000000000000000;;				p.Default = f[4:] // rest of string
0000000000000000000000000000000000000000;;				if i+1 < len(fields) {
0000000000000000000000000000000000000000;;					// Commas aren't escaped, and def is always last.
0000000000000000000000000000000000000000;;					p.Default += "," + strings.Join(fields[i+1:], ",")
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case strings.HasPrefix(f, "embedded="):
0000000000000000000000000000000000000000;;				p.OrigName = strings.Split(f, "=")[1]
0000000000000000000000000000000000000000;;			case strings.HasPrefix(f, "customtype="):
0000000000000000000000000000000000000000;;				p.CustomType = strings.Split(f, "=")[1]
0000000000000000000000000000000000000000;;			case f == "stdtime":
0000000000000000000000000000000000000000;;				p.StdTime = true
0000000000000000000000000000000000000000;;			case f == "stdduration":
0000000000000000000000000000000000000000;;				p.StdDuration = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logNoSliceEnc(t1, t2 reflect.Type) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "proto: no slice oenc for %T = []%T\n", t1, t2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var protoMessageType = reflect.TypeOf((*Message)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initialize the fields for encoding and decoding.
0000000000000000000000000000000000000000;;	func (p *Properties) setEncAndDec(typ reflect.Type, f *reflect.StructField, lockGetProp bool) {
0000000000000000000000000000000000000000;;		p.enc = nil
0000000000000000000000000000000000000000;;		p.dec = nil
0000000000000000000000000000000000000000;;		p.size = nil
0000000000000000000000000000000000000000;;		isMap := typ.Kind() == reflect.Map
0000000000000000000000000000000000000000;;		if len(p.CustomType) > 0 && !isMap {
0000000000000000000000000000000000000000;;			p.setCustomEncAndDec(typ)
0000000000000000000000000000000000000000;;			p.setTag(lockGetProp)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.StdTime && !isMap {
0000000000000000000000000000000000000000;;			p.setTimeEncAndDec(typ)
0000000000000000000000000000000000000000;;			p.setTag(lockGetProp)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.StdDuration && !isMap {
0000000000000000000000000000000000000000;;			p.setDurationEncAndDec(typ)
0000000000000000000000000000000000000000;;			p.setTag(lockGetProp)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t1 := typ; t1.Kind() {
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "proto: no coders for %v\n", t1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// proto3 scalar types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			if p.proto3 {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_proto3_bool
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_bool
0000000000000000000000000000000000000000;;				p.size = size_proto3_bool
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_bool
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_bool
0000000000000000000000000000000000000000;;				p.size = size_ref_bool
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			if p.proto3 {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_proto3_int32
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int32
0000000000000000000000000000000000000000;;				p.size = size_proto3_int32
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_int32
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int32
0000000000000000000000000000000000000000;;				p.size = size_ref_int32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			if p.proto3 {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_proto3_uint32
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int32 // can reuse
0000000000000000000000000000000000000000;;				p.size = size_proto3_uint32
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_uint32
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int32 // can reuse
0000000000000000000000000000000000000000;;				p.size = size_ref_uint32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Int64, reflect.Uint64:
0000000000000000000000000000000000000000;;			if p.proto3 {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_proto3_int64
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int64
0000000000000000000000000000000000000000;;				p.size = size_proto3_int64
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_int64
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int64
0000000000000000000000000000000000000000;;				p.size = size_ref_int64
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			if p.proto3 {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_proto3_uint32 // can just treat them as bits
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int32
0000000000000000000000000000000000000000;;				p.size = size_proto3_uint32
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_uint32 // can just treat them as bits
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int32
0000000000000000000000000000000000000000;;				p.size = size_ref_uint32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			if p.proto3 {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_proto3_int64 // can just treat them as bits
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int64
0000000000000000000000000000000000000000;;				p.size = size_proto3_int64
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_int64 // can just treat them as bits
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_int64
0000000000000000000000000000000000000000;;				p.size = size_ref_int64
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			if p.proto3 {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_proto3_string
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_string
0000000000000000000000000000000000000000;;				p.size = size_proto3_string
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_string
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_proto3_string
0000000000000000000000000000000000000000;;				p.size = size_ref_string
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			p.stype = typ
0000000000000000000000000000000000000000;;			p.isMarshaler = isMarshaler(typ)
0000000000000000000000000000000000000000;;			p.isUnmarshaler = isUnmarshaler(typ)
0000000000000000000000000000000000000000;;			if p.Wire == "bytes" {
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_ref_struct_message
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_ref_struct_message
0000000000000000000000000000000000000000;;				p.size = size_ref_struct_message
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "proto: no coders for struct %T\n", typ)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			switch t2 := t1.Elem(); t2.Kind() {
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "proto: no encoder function for %v -> %v\n", t1, t2)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_bool
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_bool
0000000000000000000000000000000000000000;;				p.size = size_bool
0000000000000000000000000000000000000000;;			case reflect.Int32:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_int32
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_int32
0000000000000000000000000000000000000000;;				p.size = size_int32
0000000000000000000000000000000000000000;;			case reflect.Uint32:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_uint32
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_int32 // can reuse
0000000000000000000000000000000000000000;;				p.size = size_uint32
0000000000000000000000000000000000000000;;			case reflect.Int64, reflect.Uint64:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_int64
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_int64
0000000000000000000000000000000000000000;;				p.size = size_int64
0000000000000000000000000000000000000000;;			case reflect.Float32:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_uint32 // can just treat them as bits
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_int32
0000000000000000000000000000000000000000;;				p.size = size_uint32
0000000000000000000000000000000000000000;;			case reflect.Float64:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_int64 // can just treat them as bits
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_int64
0000000000000000000000000000000000000000;;				p.size = size_int64
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_string
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_string
0000000000000000000000000000000000000000;;				p.size = size_string
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				p.stype = t1.Elem()
0000000000000000000000000000000000000000;;				p.isMarshaler = isMarshaler(t1)
0000000000000000000000000000000000000000;;				p.isUnmarshaler = isUnmarshaler(t1)
0000000000000000000000000000000000000000;;				if p.Wire == "bytes" {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_struct_message
0000000000000000000000000000000000000000;;					p.dec = (*Buffer).dec_struct_message
0000000000000000000000000000000000000000;;					p.size = size_struct_message
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_struct_group
0000000000000000000000000000000000000000;;					p.dec = (*Buffer).dec_struct_group
0000000000000000000000000000000000000000;;					p.size = size_struct_group
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			switch t2 := t1.Elem(); t2.Kind() {
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				logNoSliceEnc(t1, t2)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				if p.Packed {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_packed_bool
0000000000000000000000000000000000000000;;					p.size = size_slice_packed_bool
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_bool
0000000000000000000000000000000000000000;;					p.size = size_slice_bool
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_slice_bool
0000000000000000000000000000000000000000;;				p.packedDec = (*Buffer).dec_slice_packed_bool
0000000000000000000000000000000000000000;;			case reflect.Int32:
0000000000000000000000000000000000000000;;				if p.Packed {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_packed_int32
0000000000000000000000000000000000000000;;					p.size = size_slice_packed_int32
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_int32
0000000000000000000000000000000000000000;;					p.size = size_slice_int32
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_slice_int32
0000000000000000000000000000000000000000;;				p.packedDec = (*Buffer).dec_slice_packed_int32
0000000000000000000000000000000000000000;;			case reflect.Uint32:
0000000000000000000000000000000000000000;;				if p.Packed {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_packed_uint32
0000000000000000000000000000000000000000;;					p.size = size_slice_packed_uint32
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_uint32
0000000000000000000000000000000000000000;;					p.size = size_slice_uint32
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_slice_int32
0000000000000000000000000000000000000000;;				p.packedDec = (*Buffer).dec_slice_packed_int32
0000000000000000000000000000000000000000;;			case reflect.Int64, reflect.Uint64:
0000000000000000000000000000000000000000;;				if p.Packed {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_packed_int64
0000000000000000000000000000000000000000;;					p.size = size_slice_packed_int64
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_int64
0000000000000000000000000000000000000000;;					p.size = size_slice_int64
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_slice_int64
0000000000000000000000000000000000000000;;				p.packedDec = (*Buffer).dec_slice_packed_int64
0000000000000000000000000000000000000000;;			case reflect.Uint8:
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_slice_byte
0000000000000000000000000000000000000000;;				if p.proto3 {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_proto3_slice_byte
0000000000000000000000000000000000000000;;					p.size = size_proto3_slice_byte
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_byte
0000000000000000000000000000000000000000;;					p.size = size_slice_byte
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;				switch t2.Bits() {
0000000000000000000000000000000000000000;;				case 32:
0000000000000000000000000000000000000000;;					// can just treat them as bits
0000000000000000000000000000000000000000;;					if p.Packed {
0000000000000000000000000000000000000000;;						p.enc = (*Buffer).enc_slice_packed_uint32
0000000000000000000000000000000000000000;;						p.size = size_slice_packed_uint32
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.enc = (*Buffer).enc_slice_uint32
0000000000000000000000000000000000000000;;						p.size = size_slice_uint32
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.dec = (*Buffer).dec_slice_int32
0000000000000000000000000000000000000000;;					p.packedDec = (*Buffer).dec_slice_packed_int32
0000000000000000000000000000000000000000;;				case 64:
0000000000000000000000000000000000000000;;					// can just treat them as bits
0000000000000000000000000000000000000000;;					if p.Packed {
0000000000000000000000000000000000000000;;						p.enc = (*Buffer).enc_slice_packed_int64
0000000000000000000000000000000000000000;;						p.size = size_slice_packed_int64
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.enc = (*Buffer).enc_slice_int64
0000000000000000000000000000000000000000;;						p.size = size_slice_int64
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.dec = (*Buffer).dec_slice_int64
0000000000000000000000000000000000000000;;					p.packedDec = (*Buffer).dec_slice_packed_int64
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					logNoSliceEnc(t1, t2)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_slice_string
0000000000000000000000000000000000000000;;				p.dec = (*Buffer).dec_slice_string
0000000000000000000000000000000000000000;;				p.size = size_slice_string
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;				switch t3 := t2.Elem(); t3.Kind() {
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					fmt.Fprintf(os.Stderr, "proto: no ptr oenc for %T -> %T -> %T\n", t1, t2, t3)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				case reflect.Struct:
0000000000000000000000000000000000000000;;					p.stype = t2.Elem()
0000000000000000000000000000000000000000;;					p.isMarshaler = isMarshaler(t2)
0000000000000000000000000000000000000000;;					p.isUnmarshaler = isUnmarshaler(t2)
0000000000000000000000000000000000000000;;					if p.Wire == "bytes" {
0000000000000000000000000000000000000000;;						p.enc = (*Buffer).enc_slice_struct_message
0000000000000000000000000000000000000000;;						p.dec = (*Buffer).dec_slice_struct_message
0000000000000000000000000000000000000000;;						p.size = size_slice_struct_message
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.enc = (*Buffer).enc_slice_struct_group
0000000000000000000000000000000000000000;;						p.dec = (*Buffer).dec_slice_struct_group
0000000000000000000000000000000000000000;;						p.size = size_slice_struct_group
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				switch t2.Elem().Kind() {
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					fmt.Fprintf(os.Stderr, "proto: no slice elem oenc for %T -> %T -> %T\n", t1, t2, t2.Elem())
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				case reflect.Uint8:
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_slice_slice_byte
0000000000000000000000000000000000000000;;					p.dec = (*Buffer).dec_slice_slice_byte
0000000000000000000000000000000000000000;;					p.size = size_slice_slice_byte
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				p.setSliceOfNonPointerStructs(t1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			p.enc = (*Buffer).enc_new_map
0000000000000000000000000000000000000000;;			p.dec = (*Buffer).dec_new_map
0000000000000000000000000000000000000000;;			p.size = size_new_map
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.mtype = t1
0000000000000000000000000000000000000000;;			p.mkeyprop = &Properties{}
0000000000000000000000000000000000000000;;			p.mkeyprop.init(reflect.PtrTo(p.mtype.Key()), "Key", f.Tag.Get("protobuf_key"), nil, lockGetProp)
0000000000000000000000000000000000000000;;			p.mvalprop = &Properties{}
0000000000000000000000000000000000000000;;			vtype := p.mtype.Elem()
0000000000000000000000000000000000000000;;			if vtype.Kind() != reflect.Ptr && vtype.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;				// The value type is not a message (*T) or bytes ([]byte),
0000000000000000000000000000000000000000;;				// so we need encoders for the pointer to this type.
0000000000000000000000000000000000000000;;				vtype = reflect.PtrTo(vtype)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.mvalprop.CustomType = p.CustomType
0000000000000000000000000000000000000000;;			p.mvalprop.StdDuration = p.StdDuration
0000000000000000000000000000000000000000;;			p.mvalprop.StdTime = p.StdTime
0000000000000000000000000000000000000000;;			p.mvalprop.init(vtype, "Value", f.Tag.Get("protobuf_val"), nil, lockGetProp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.setTag(lockGetProp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Properties) setTag(lockGetProp bool) {
0000000000000000000000000000000000000000;;		// precalculate tag code
0000000000000000000000000000000000000000;;		wire := p.WireType
0000000000000000000000000000000000000000;;		if p.Packed {
0000000000000000000000000000000000000000;;			wire = WireBytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := uint32(p.Tag)<<3 | uint32(wire)
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i = 0; x > 127; i++ {
0000000000000000000000000000000000000000;;			p.tagbuf[i] = 0x80 | uint8(x&0x7F)
0000000000000000000000000000000000000000;;			x >>= 7
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.tagbuf[i] = uint8(x)
0000000000000000000000000000000000000000;;		p.tagcode = p.tagbuf[0 : i+1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.stype != nil {
0000000000000000000000000000000000000000;;			if lockGetProp {
0000000000000000000000000000000000000000;;				p.sprop = GetProperties(p.stype)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.sprop = getPropertiesLocked(p.stype)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		marshalerType   = reflect.TypeOf((*Marshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;		unmarshalerType = reflect.TypeOf((*Unmarshaler)(nil)).Elem()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isMarshaler reports whether type t implements Marshaler.
0000000000000000000000000000000000000000;;	func isMarshaler(t reflect.Type) bool {
0000000000000000000000000000000000000000;;		return t.Implements(marshalerType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isUnmarshaler reports whether type t implements Unmarshaler.
0000000000000000000000000000000000000000;;	func isUnmarshaler(t reflect.Type) bool {
0000000000000000000000000000000000000000;;		return t.Implements(unmarshalerType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Init populates the properties from a protocol buffer struct tag.
0000000000000000000000000000000000000000;;	func (p *Properties) Init(typ reflect.Type, name, tag string, f *reflect.StructField) {
0000000000000000000000000000000000000000;;		p.init(typ, name, tag, f, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Properties) init(typ reflect.Type, name, tag string, f *reflect.StructField, lockGetProp bool) {
0000000000000000000000000000000000000000;;		// "bytes,49,opt,def=hello!"
0000000000000000000000000000000000000000;;		p.Name = name
0000000000000000000000000000000000000000;;		p.OrigName = name
0000000000000000000000000000000000000000;;		if f != nil {
0000000000000000000000000000000000000000;;			p.field = toField(f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tag == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Parse(tag)
0000000000000000000000000000000000000000;;		p.setEncAndDec(typ, f, lockGetProp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		propertiesMu  sync.RWMutex
0000000000000000000000000000000000000000;;		propertiesMap = make(map[reflect.Type]*StructProperties)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetProperties returns the list of properties for the type represented by t.
0000000000000000000000000000000000000000;;	// t must represent a generated struct type of a protocol message.
0000000000000000000000000000000000000000;;	func GetProperties(t reflect.Type) *StructProperties {
0000000000000000000000000000000000000000;;		if t.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			panic("proto: type must have kind struct")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Most calls to GetProperties in a long-running program will be
0000000000000000000000000000000000000000;;		// retrieving details for types we have seen before.
0000000000000000000000000000000000000000;;		propertiesMu.RLock()
0000000000000000000000000000000000000000;;		sprop, ok := propertiesMap[t]
0000000000000000000000000000000000000000;;		propertiesMu.RUnlock()
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if collectStats {
0000000000000000000000000000000000000000;;				stats.Chit++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sprop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		propertiesMu.Lock()
0000000000000000000000000000000000000000;;		sprop = getPropertiesLocked(t)
0000000000000000000000000000000000000000;;		propertiesMu.Unlock()
0000000000000000000000000000000000000000;;		return sprop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getPropertiesLocked requires that propertiesMu is held.
0000000000000000000000000000000000000000;;	func getPropertiesLocked(t reflect.Type) *StructProperties {
0000000000000000000000000000000000000000;;		if prop, ok := propertiesMap[t]; ok {
0000000000000000000000000000000000000000;;			if collectStats {
0000000000000000000000000000000000000000;;				stats.Chit++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return prop
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if collectStats {
0000000000000000000000000000000000000000;;			stats.Cmiss++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prop := new(StructProperties)
0000000000000000000000000000000000000000;;		// in case of recursive protos, fill this in now.
0000000000000000000000000000000000000000;;		propertiesMap[t] = prop
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build properties
0000000000000000000000000000000000000000;;		prop.extendable = reflect.PtrTo(t).Implements(extendableProtoType) ||
0000000000000000000000000000000000000000;;			reflect.PtrTo(t).Implements(extendableProtoV1Type) ||
0000000000000000000000000000000000000000;;			reflect.PtrTo(t).Implements(extendableBytesType)
0000000000000000000000000000000000000000;;		prop.unrecField = invalidField
0000000000000000000000000000000000000000;;		prop.Prop = make([]*Properties, t.NumField())
0000000000000000000000000000000000000000;;		prop.order = make([]int, t.NumField())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isOneofMessage := false
0000000000000000000000000000000000000000;;		for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;			f := t.Field(i)
0000000000000000000000000000000000000000;;			p := new(Properties)
0000000000000000000000000000000000000000;;			name := f.Name
0000000000000000000000000000000000000000;;			p.init(f.Type, name, f.Tag.Get("protobuf"), &f, false)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if f.Name == "XXX_InternalExtensions" { // special case
0000000000000000000000000000000000000000;;				p.enc = (*Buffer).enc_exts
0000000000000000000000000000000000000000;;				p.dec = nil // not needed
0000000000000000000000000000000000000000;;				p.size = size_exts
0000000000000000000000000000000000000000;;			} else if f.Name == "XXX_extensions" { // special case
0000000000000000000000000000000000000000;;				if len(f.Tag.Get("protobuf")) > 0 {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_ext_slice_byte
0000000000000000000000000000000000000000;;					p.dec = nil // not needed
0000000000000000000000000000000000000000;;					p.size = size_ext_slice_byte
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.enc = (*Buffer).enc_map
0000000000000000000000000000000000000000;;					p.dec = nil // not needed
0000000000000000000000000000000000000000;;					p.size = size_map
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if f.Name == "XXX_unrecognized" { // special case
0000000000000000000000000000000000000000;;				prop.unrecField = toField(&f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			oneof := f.Tag.Get("protobuf_oneof") // special case
0000000000000000000000000000000000000000;;			if oneof != "" {
0000000000000000000000000000000000000000;;				isOneofMessage = true
0000000000000000000000000000000000000000;;				// Oneof fields don't use the traditional protobuf tag.
0000000000000000000000000000000000000000;;				p.OrigName = oneof
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prop.Prop[i] = p
0000000000000000000000000000000000000000;;			prop.order[i] = i
0000000000000000000000000000000000000000;;			if debug {
0000000000000000000000000000000000000000;;				print(i, " ", f.Name, " ", t.String(), " ")
0000000000000000000000000000000000000000;;				if p.Tag > 0 {
0000000000000000000000000000000000000000;;					print(p.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				print("\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.enc == nil && !strings.HasPrefix(f.Name, "XXX_") && oneof == "" {
0000000000000000000000000000000000000000;;				fmt.Fprintln(os.Stderr, "proto: no encoder for", f.Name, f.Type.String(), "[GetProperties]")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Re-order prop.order.
0000000000000000000000000000000000000000;;		sort.Sort(prop)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type oneofMessage interface {
0000000000000000000000000000000000000000;;			XXX_OneofFuncs() (func(Message, *Buffer) error, func(Message, int, int, *Buffer) (bool, error), func(Message) int, []interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if om, ok := reflect.Zero(reflect.PtrTo(t)).Interface().(oneofMessage); isOneofMessage && ok {
0000000000000000000000000000000000000000;;			var oots []interface{}
0000000000000000000000000000000000000000;;			prop.oneofMarshaler, prop.oneofUnmarshaler, prop.oneofSizer, oots = om.XXX_OneofFuncs()
0000000000000000000000000000000000000000;;			prop.stype = t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Interpret oneof metadata.
0000000000000000000000000000000000000000;;			prop.OneofTypes = make(map[string]*OneofProperties)
0000000000000000000000000000000000000000;;			for _, oot := range oots {
0000000000000000000000000000000000000000;;				oop := &OneofProperties{
0000000000000000000000000000000000000000;;					Type: reflect.ValueOf(oot).Type(), // *T
0000000000000000000000000000000000000000;;					Prop: new(Properties),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sft := oop.Type.Elem().Field(0)
0000000000000000000000000000000000000000;;				oop.Prop.Name = sft.Name
0000000000000000000000000000000000000000;;				oop.Prop.Parse(sft.Tag.Get("protobuf"))
0000000000000000000000000000000000000000;;				// There will be exactly one interface field that
0000000000000000000000000000000000000000;;				// this new value is assignable to.
0000000000000000000000000000000000000000;;				for i := 0; i < t.NumField(); i++ {
0000000000000000000000000000000000000000;;					f := t.Field(i)
0000000000000000000000000000000000000000;;					if f.Type.Kind() != reflect.Interface {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !oop.Type.AssignableTo(f.Type) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					oop.Field = i
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				prop.OneofTypes[oop.Prop.OrigName] = oop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build required counts
0000000000000000000000000000000000000000;;		// build tags
0000000000000000000000000000000000000000;;		reqCount := 0
0000000000000000000000000000000000000000;;		prop.decoderOrigNames = make(map[string]int)
0000000000000000000000000000000000000000;;		for i, p := range prop.Prop {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(p.Name, "XXX_") {
0000000000000000000000000000000000000000;;				// Internal fields should not appear in tags/origNames maps.
0000000000000000000000000000000000000000;;				// They are handled specially when encoding and decoding.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.Required {
0000000000000000000000000000000000000000;;				reqCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prop.decoderTags.put(p.Tag, i)
0000000000000000000000000000000000000000;;			prop.decoderOrigNames[p.OrigName] = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prop.reqCount = reqCount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return prop
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the Properties object for the x[0]'th field of the structure.
0000000000000000000000000000000000000000;;	func propByIndex(t reflect.Type, x []int) *Properties {
0000000000000000000000000000000000000000;;		if len(x) != 1 {
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "proto: field index dimension %d (not 1) for type %s\n", len(x), t)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		prop := GetProperties(t)
0000000000000000000000000000000000000000;;		return prop.Prop[x[0]]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the address and type of a pointer to a struct from an interface.
0000000000000000000000000000000000000000;;	func getbase(pb Message) (t reflect.Type, b structPointer, err error) {
0000000000000000000000000000000000000000;;		if pb == nil {
0000000000000000000000000000000000000000;;			err = ErrNil
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// get the reflect type of the pointer to the struct.
0000000000000000000000000000000000000000;;		t = reflect.TypeOf(pb)
0000000000000000000000000000000000000000;;		// get the address of the struct.
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(pb)
0000000000000000000000000000000000000000;;		b = toStructPointer(value)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A global registry of enum types.
0000000000000000000000000000000000000000;;	// The generated code will register the generated maps by calling RegisterEnum.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var enumValueMaps = make(map[string]map[string]int32)
0000000000000000000000000000000000000000;;	var enumStringMaps = make(map[string]map[int32]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterEnum is called from the generated code to install the enum descriptor
0000000000000000000000000000000000000000;;	// maps into the global table to aid parsing text format protocol buffers.
0000000000000000000000000000000000000000;;	func RegisterEnum(typeName string, unusedNameMap map[int32]string, valueMap map[string]int32) {
0000000000000000000000000000000000000000;;		if _, ok := enumValueMaps[typeName]; ok {
0000000000000000000000000000000000000000;;			panic("proto: duplicate enum registered: " + typeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enumValueMaps[typeName] = valueMap
0000000000000000000000000000000000000000;;		if _, ok := enumStringMaps[typeName]; ok {
0000000000000000000000000000000000000000;;			panic("proto: duplicate enum registered: " + typeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enumStringMaps[typeName] = unusedNameMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnumValueMap returns the mapping from names to integers of the
0000000000000000000000000000000000000000;;	// enum type enumType, or a nil if not found.
0000000000000000000000000000000000000000;;	func EnumValueMap(enumType string) map[string]int32 {
0000000000000000000000000000000000000000;;		return enumValueMaps[enumType]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A registry of all linked message types.
0000000000000000000000000000000000000000;;	// The string is a fully-qualified proto name ("pkg.Message").
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		protoTypes    = make(map[string]reflect.Type)
0000000000000000000000000000000000000000;;		revProtoTypes = make(map[reflect.Type]string)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterType is called from generated code and maps from the fully qualified
0000000000000000000000000000000000000000;;	// proto name to the type (pointer to struct) of the protocol buffer.
0000000000000000000000000000000000000000;;	func RegisterType(x Message, name string) {
0000000000000000000000000000000000000000;;		if _, ok := protoTypes[name]; ok {
0000000000000000000000000000000000000000;;			// TODO: Some day, make this a panic.
0000000000000000000000000000000000000000;;			log.Printf("proto: duplicate proto type registered: %s", name)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(x)
0000000000000000000000000000000000000000;;		protoTypes[name] = t
0000000000000000000000000000000000000000;;		revProtoTypes[t] = name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MessageName returns the fully-qualified proto name for the given message type.
0000000000000000000000000000000000000000;;	func MessageName(x Message) string {
0000000000000000000000000000000000000000;;		type xname interface {
0000000000000000000000000000000000000000;;			XXX_MessageName() string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m, ok := x.(xname); ok {
0000000000000000000000000000000000000000;;			return m.XXX_MessageName()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return revProtoTypes[reflect.TypeOf(x)]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MessageType returns the message type (pointer to struct) for a named message.
0000000000000000000000000000000000000000;;	func MessageType(name string) reflect.Type { return protoTypes[name] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A registry of all linked proto files.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		protoFiles = make(map[string][]byte) // file name => fileDescriptor
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterFile is called from generated code and maps from the
0000000000000000000000000000000000000000;;	// full file name of a .proto file to its compressed FileDescriptorProto.
0000000000000000000000000000000000000000;;	func RegisterFile(filename string, fileDescriptor []byte) {
0000000000000000000000000000000000000000;;		protoFiles[filename] = fileDescriptor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileDescriptor returns the compressed FileDescriptorProto for a .proto file.
0000000000000000000000000000000000000000;;	func FileDescriptor(filename string) []byte { return protoFiles[filename] }
