0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2016, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var durationType = reflect.TypeOf((*time.Duration)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type duration struct {
0000000000000000000000000000000000000000;;		Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
0000000000000000000000000000000000000000;;		Nanos   int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *duration) Reset()       { *m = duration{} }
0000000000000000000000000000000000000000;;	func (*duration) ProtoMessage()  {}
0000000000000000000000000000000000000000;;	func (*duration) String() string { return "duration<string>" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		RegisterType((*duration)(nil), "gogo.protobuf.proto.duration")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) decDuration() (time.Duration, error) {
0000000000000000000000000000000000000000;;		b, err := o.DecodeRawBytes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dproto := &duration{}
0000000000000000000000000000000000000000;;		if err := Unmarshal(b, dproto); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return durationFromProto(dproto)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		d, err := o.decDuration()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		word64_Set(structPointer_Word64(base, p.field), o, uint64(d))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_ref_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		d, err := o.decDuration()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		word64Val_Set(structPointer_Word64Val(base, p.field), o, uint64(d))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		d, err := o.decDuration()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newBas := appendStructPointer(base, p.field, reflect.SliceOf(reflect.PtrTo(durationType)))
0000000000000000000000000000000000000000;;		var zero field
0000000000000000000000000000000000000000;;		setPtrCustomType(newBas, zero, &d)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_ref_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		d, err := o.decDuration()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		structPointer_Word64Slice(base, p.field).Append(uint64(d))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_duration(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		structp := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dur := structPointer_Interface(structp, durationType).(*time.Duration)
0000000000000000000000000000000000000000;;		d := durationProto(*dur)
0000000000000000000000000000000000000000;;		size := Size(d)
0000000000000000000000000000000000000000;;		return size + sizeVarint(uint64(size)) + len(p.tagcode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		structp := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dur := structPointer_Interface(structp, durationType).(*time.Duration)
0000000000000000000000000000000000000000;;		d := durationProto(*dur)
0000000000000000000000000000000000000000;;		data, err := Marshal(d)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_ref_duration(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		dur := structPointer_InterfaceAt(base, p.field, durationType).(*time.Duration)
0000000000000000000000000000000000000000;;		d := durationProto(*dur)
0000000000000000000000000000000000000000;;		size := Size(d)
0000000000000000000000000000000000000000;;		return size + sizeVarint(uint64(size)) + len(p.tagcode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_ref_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		dur := structPointer_InterfaceAt(base, p.field, durationType).(*time.Duration)
0000000000000000000000000000000000000000;;		d := durationProto(*dur)
0000000000000000000000000000000000000000;;		data, err := Marshal(d)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_duration(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		pdurs := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(reflect.PtrTo(durationType))).(*[]*time.Duration)
0000000000000000000000000000000000000000;;		durs := *pdurs
0000000000000000000000000000000000000000;;		for i := 0; i < len(durs); i++ {
0000000000000000000000000000000000000000;;			if durs[i] == nil {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dproto := durationProto(*durs[i])
0000000000000000000000000000000000000000;;			size := Size(dproto)
0000000000000000000000000000000000000000;;			n += len(p.tagcode) + size + sizeVarint(uint64(size))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		pdurs := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(reflect.PtrTo(durationType))).(*[]*time.Duration)
0000000000000000000000000000000000000000;;		durs := *pdurs
0000000000000000000000000000000000000000;;		for i := 0; i < len(durs); i++ {
0000000000000000000000000000000000000000;;			if durs[i] == nil {
0000000000000000000000000000000000000000;;				return errRepeatedHasNil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dproto := durationProto(*durs[i])
0000000000000000000000000000000000000000;;			data, err := Marshal(dproto)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_ref_duration(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		pdurs := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(durationType)).(*[]time.Duration)
0000000000000000000000000000000000000000;;		durs := *pdurs
0000000000000000000000000000000000000000;;		for i := 0; i < len(durs); i++ {
0000000000000000000000000000000000000000;;			dproto := durationProto(durs[i])
0000000000000000000000000000000000000000;;			size := Size(dproto)
0000000000000000000000000000000000000000;;			n += len(p.tagcode) + size + sizeVarint(uint64(size))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_ref_duration(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		pdurs := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(durationType)).(*[]time.Duration)
0000000000000000000000000000000000000000;;		durs := *pdurs
0000000000000000000000000000000000000000;;		for i := 0; i < len(durs); i++ {
0000000000000000000000000000000000000000;;			dproto := durationProto(durs[i])
0000000000000000000000000000000000000000;;			data, err := Marshal(dproto)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
