0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8329b5f94b1a4a7919ce36cf38e5a9fa0715aaf4;Godeps/_workspace/src/github.com/gogo/protobuf/proto/extensions_gogo.go[Godeps/_workspace/src/github.com/gogo/protobuf/proto/extensions_gogo.go][vendor/github.com/gogo/protobuf/proto/extensions_gogo.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetBoolExtension(pb Message, extension *ExtensionDesc, ifnotset bool) bool {
0000000000000000000000000000000000000000;;		if reflect.ValueOf(pb).IsNil() {
0000000000000000000000000000000000000000;;			return ifnotset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value, err := GetExtension(pb, extension)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ifnotset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			return ifnotset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if value.(*bool) == nil {
0000000000000000000000000000000000000000;;			return ifnotset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *(value.(*bool))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *Extension) Equal(that *Extension) bool {
0000000000000000000000000000000000000000;;		return bytes.Equal(this.enc, that.enc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *Extension) Compare(that *Extension) int {
0000000000000000000000000000000000000000;;		return bytes.Compare(this.enc, that.enc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SizeOfInternalExtension(m extendableProto) (n int) {
0000000000000000000000000000000000000000;;		return SizeOfExtensionMap(m.extensionsWrite())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SizeOfExtensionMap(m map[int32]Extension) (n int) {
0000000000000000000000000000000000000000;;		return extensionsMapSize(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortableMapElem struct {
0000000000000000000000000000000000000000;;		field int32
0000000000000000000000000000000000000000;;		ext   Extension
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSortableExtensionsFromMap(m map[int32]Extension) sortableExtensions {
0000000000000000000000000000000000000000;;		s := make(sortableExtensions, 0, len(m))
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			s = append(s, &sortableMapElem{field: k, ext: v})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sortableExtensions []*sortableMapElem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this sortableExtensions) Len() int { return len(this) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this sortableExtensions) Swap(i, j int) { this[i], this[j] = this[j], this[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this sortableExtensions) Less(i, j int) bool { return this[i].field < this[j].field }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this sortableExtensions) String() string {
0000000000000000000000000000000000000000;;		sort.Sort(this)
0000000000000000000000000000000000000000;;		ss := make([]string, len(this))
0000000000000000000000000000000000000000;;		for i := range this {
0000000000000000000000000000000000000000;;			ss[i] = fmt.Sprintf("%d: %v", this[i].field, this[i].ext)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "map[" + strings.Join(ss, ",") + "]"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StringFromInternalExtension(m extendableProto) string {
0000000000000000000000000000000000000000;;		return StringFromExtensionsMap(m.extensionsWrite())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StringFromExtensionsMap(m map[int32]Extension) string {
0000000000000000000000000000000000000000;;		return newSortableExtensionsFromMap(m).String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StringFromExtensionsBytes(ext []byte) string {
0000000000000000000000000000000000000000;;		m, err := BytesToExtensionsMap(ext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return StringFromExtensionsMap(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EncodeInternalExtension(m extendableProto, data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		return EncodeExtensionMap(m.extensionsWrite(), data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EncodeExtensionMap(m map[int32]Extension, data []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if err := encodeExtensionsMap(m); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keys := make([]int, 0, len(m))
0000000000000000000000000000000000000000;;		for k := range m {
0000000000000000000000000000000000000000;;			keys = append(keys, int(k))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Ints(keys)
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			n += copy(data[n:], m[int32(k)].enc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetRawExtension(m map[int32]Extension, id int32) ([]byte, error) {
0000000000000000000000000000000000000000;;		if m[id].value == nil || m[id].desc == nil {
0000000000000000000000000000000000000000;;			return m[id].enc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := encodeExtensionsMap(m); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m[id].enc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size(buf []byte, wire int) (int, error) {
0000000000000000000000000000000000000000;;		switch wire {
0000000000000000000000000000000000000000;;		case WireVarint:
0000000000000000000000000000000000000000;;			_, n := DecodeVarint(buf)
0000000000000000000000000000000000000000;;			return n, nil
0000000000000000000000000000000000000000;;		case WireFixed64:
0000000000000000000000000000000000000000;;			return 8, nil
0000000000000000000000000000000000000000;;		case WireBytes:
0000000000000000000000000000000000000000;;			v, n := DecodeVarint(buf)
0000000000000000000000000000000000000000;;			return int(v) + n, nil
0000000000000000000000000000000000000000;;		case WireFixed32:
0000000000000000000000000000000000000000;;			return 4, nil
0000000000000000000000000000000000000000;;		case WireStartGroup:
0000000000000000000000000000000000000000;;			offset := 0
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				u, n := DecodeVarint(buf[offset:])
0000000000000000000000000000000000000000;;				fwire := int(u & 0x7)
0000000000000000000000000000000000000000;;				offset += n
0000000000000000000000000000000000000000;;				if fwire == WireEndGroup {
0000000000000000000000000000000000000000;;					return offset, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s, err := size(buf[offset:], wire)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				offset += s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("proto: can't get size for unknown wire type %d", wire)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func BytesToExtensionsMap(buf []byte) (map[int32]Extension, error) {
0000000000000000000000000000000000000000;;		m := make(map[int32]Extension)
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < len(buf) {
0000000000000000000000000000000000000000;;			tag, n := DecodeVarint(buf[i:])
0000000000000000000000000000000000000000;;			if n <= 0 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to decode varint")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fieldNum := int32(tag >> 3)
0000000000000000000000000000000000000000;;			wireType := int(tag & 0x7)
0000000000000000000000000000000000000000;;			l, err := size(buf[i+n:], wireType)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end := i + int(l) + n
0000000000000000000000000000000000000000;;			m[int32(fieldNum)] = Extension{enc: buf[i:end]}
0000000000000000000000000000000000000000;;			i = end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewExtension(e []byte) Extension {
0000000000000000000000000000000000000000;;		ee := Extension{enc: make([]byte, len(e))}
0000000000000000000000000000000000000000;;		copy(ee.enc, e)
0000000000000000000000000000000000000000;;		return ee
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func AppendExtension(e Message, tag int32, buf []byte) {
0000000000000000000000000000000000000000;;		if ee, eok := e.(extensionsBytes); eok {
0000000000000000000000000000000000000000;;			ext := ee.GetExtensions()
0000000000000000000000000000000000000000;;			*ext = append(*ext, buf...)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ee, eok := e.(extendableProto); eok {
0000000000000000000000000000000000000000;;			m := ee.extensionsWrite()
0000000000000000000000000000000000000000;;			ext := m[int32(tag)] // may be missing
0000000000000000000000000000000000000000;;			ext.enc = append(ext.enc, buf...)
0000000000000000000000000000000000000000;;			m[int32(tag)] = ext
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodeExtension(e *Extension) error {
0000000000000000000000000000000000000000;;		if e.value == nil || e.desc == nil {
0000000000000000000000000000000000000000;;			// Extension is only in its encoded form.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We don't skip extensions that have an encoded form set,
0000000000000000000000000000000000000000;;		// because the extension value may have been mutated after
0000000000000000000000000000000000000000;;		// the last time this function was called.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		et := reflect.TypeOf(e.desc.ExtensionType)
0000000000000000000000000000000000000000;;		props := extensionProperties(e.desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := NewBuffer(nil)
0000000000000000000000000000000000000000;;		// If e.value has type T, the encoder expects a *struct{ X T }.
0000000000000000000000000000000000000000;;		// Pass a *T with a zero field and hope it all works out.
0000000000000000000000000000000000000000;;		x := reflect.New(et)
0000000000000000000000000000000000000000;;		x.Elem().Set(reflect.ValueOf(e.value))
0000000000000000000000000000000000000000;;		if err := props.enc(p, props, toStructPointer(x)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.enc = p.buf
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this Extension) GoString() string {
0000000000000000000000000000000000000000;;		if this.enc == nil {
0000000000000000000000000000000000000000;;			if err := encodeExtension(&this); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("proto.NewExtension(%#v)", this.enc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func SetUnsafeExtension(pb Message, fieldNum int32, value interface{}) error {
0000000000000000000000000000000000000000;;		typ := reflect.TypeOf(pb).Elem()
0000000000000000000000000000000000000000;;		ext, ok := extensionMaps[typ]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("proto: bad extended type; %s is not extendable", typ.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desc, ok := ext[fieldNum]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("proto: bad extension number; not in declared ranges")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return SetExtension(pb, desc, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetUnsafeExtension(pb Message, fieldNum int32) (interface{}, error) {
0000000000000000000000000000000000000000;;		typ := reflect.TypeOf(pb).Elem()
0000000000000000000000000000000000000000;;		ext, ok := extensionMaps[typ]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("proto: bad extended type; %s is not extendable", typ.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desc, ok := ext[fieldNum]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unregistered field number %d", fieldNum)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return GetExtension(pb, desc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewUnsafeXXX_InternalExtensions(m map[int32]Extension) XXX_InternalExtensions {
0000000000000000000000000000000000000000;;		x := &XXX_InternalExtensions{
0000000000000000000000000000000000000000;;			p: new(struct {
0000000000000000000000000000000000000000;;				mu           sync.Mutex
0000000000000000000000000000000000000000;;				extensionMap map[int32]Extension
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x.p.extensionMap = m
0000000000000000000000000000000000000000;;		return *x
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetUnsafeExtensionsMap(extendable Message) map[int32]Extension {
0000000000000000000000000000000000000000;;		pb := extendable.(extendableProto)
0000000000000000000000000000000000000000;;		return pb.extensionsWrite()
0000000000000000000000000000000000000000;;	}
