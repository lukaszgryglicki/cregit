0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8329b5f94b1a4a7919ce36cf38e5a9fa0715aaf4;Godeps/_workspace/src/github.com/gogo/protobuf/proto/decode_gogo.go[Godeps/_workspace/src/github.com/gogo/protobuf/proto/decode_gogo.go][vendor/github.com/gogo/protobuf/proto/decode_gogo.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a reference to a struct pointer.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_ref_struct_message(p *Properties, base structPointer) (err error) {
0000000000000000000000000000000000000000;;		raw, e := o.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the object can unmarshal itself, let it.
0000000000000000000000000000000000000000;;		if p.isUnmarshaler {
0000000000000000000000000000000000000000;;			panic("not supported, since this is a pointer receiver")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obuf := o.buf
0000000000000000000000000000000000000000;;		oi := o.index
0000000000000000000000000000000000000000;;		o.buf = raw
0000000000000000000000000000000000000000;;		o.index = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bas := structPointer_FieldPointer(base, p.field)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = o.unmarshalType(p.stype, p.sprop, false, bas)
0000000000000000000000000000000000000000;;		o.buf = obuf
0000000000000000000000000000000000000000;;		o.index = oi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of references to struct pointers ([]struct).
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_ref_struct(p *Properties, is_group bool, base structPointer) error {
0000000000000000000000000000000000000000;;		newBas := appendStructPointer(base, p.field, p.sstype)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if is_group {
0000000000000000000000000000000000000000;;			panic("not supported, maybe in future, if requested.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw, err := o.DecodeRawBytes(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the object can unmarshal itself, let it.
0000000000000000000000000000000000000000;;		if p.isUnmarshaler {
0000000000000000000000000000000000000000;;			panic("not supported, since this is not a pointer receiver.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obuf := o.buf
0000000000000000000000000000000000000000;;		oi := o.index
0000000000000000000000000000000000000000;;		o.buf = raw
0000000000000000000000000000000000000000;;		o.index = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = o.unmarshalType(p.stype, p.sprop, is_group, newBas)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = obuf
0000000000000000000000000000000000000000;;		o.index = oi
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of references to struct pointers.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_ref_struct_message(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		return o.dec_slice_ref_struct(p, false, base)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setPtrCustomType(base structPointer, f field, v interface{}) {
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		structPointer_SetStructPointer(base, f, toStructPointer(reflect.ValueOf(v)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCustomType(base structPointer, f field, value interface{}) {
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(value).Elem()
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(value).Elem()
0000000000000000000000000000000000000000;;		kind := t.Kind()
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			slice := reflect.MakeSlice(t, v.Len(), v.Cap())
0000000000000000000000000000000000000000;;			reflect.Copy(slice, v)
0000000000000000000000000000000000000000;;			oldHeader := structPointer_GetSliceHeader(base, f)
0000000000000000000000000000000000000000;;			oldHeader.Data = slice.Pointer()
0000000000000000000000000000000000000000;;			oldHeader.Len = v.Len()
0000000000000000000000000000000000000000;;			oldHeader.Cap = v.Cap()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			size := reflect.TypeOf(value).Elem().Size()
0000000000000000000000000000000000000000;;			structPointer_Copy(toStructPointer(reflect.ValueOf(value)), structPointer_Add(base, f), int(size))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_custom_bytes(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		b, err := o.DecodeRawBytes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := reflect.New(p.ctype.Elem()).Interface()
0000000000000000000000000000000000000000;;		custom := (i).(Unmarshaler)
0000000000000000000000000000000000000000;;		if err := custom.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setPtrCustomType(base, p.field, custom)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_custom_ref_bytes(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		b, err := o.DecodeRawBytes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := reflect.New(p.ctype).Interface()
0000000000000000000000000000000000000000;;		custom := (i).(Unmarshaler)
0000000000000000000000000000000000000000;;		if err := custom.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if custom != nil {
0000000000000000000000000000000000000000;;			setCustomType(base, p.field, custom)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode a slice of bytes ([]byte) into a slice of custom types.
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_custom_slice_bytes(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		b, err := o.DecodeRawBytes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := reflect.New(p.ctype.Elem()).Interface()
0000000000000000000000000000000000000000;;		custom := (i).(Unmarshaler)
0000000000000000000000000000000000000000;;		if err := custom.Unmarshal(b); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newBas := appendStructPointer(base, p.field, p.ctype)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var zero field
0000000000000000000000000000000000000000;;		setCustomType(newBas, zero, custom)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
