0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8329b5f94b1a4a7919ce36cf38e5a9fa0715aaf4;Godeps/_workspace/src/github.com/gogo/protobuf/proto/pointer_reflect.go[Godeps/_workspace/src/github.com/gogo/protobuf/proto/pointer_reflect.go][vendor/github.com/gogo/protobuf/proto/pointer_reflect.go];	
0000000000000000000000000000000000000000;;	// +build appengine js
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This file contains an implementation of proto field accesses using package reflect.
0000000000000000000000000000000000000000;;	// It is slower than the code in pointer_unsafe.go but it avoids package unsafe and can
0000000000000000000000000000000000000000;;	// be used on App Engine.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A structPointer is a pointer to a struct.
0000000000000000000000000000000000000000;;	type structPointer struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toStructPointer returns a structPointer equivalent to the given reflect value.
0000000000000000000000000000000000000000;;	// The reflect value must itself be a pointer to a struct.
0000000000000000000000000000000000000000;;	func toStructPointer(v reflect.Value) structPointer {
0000000000000000000000000000000000000000;;		return structPointer{v}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNil reports whether p is nil.
0000000000000000000000000000000000000000;;	func structPointer_IsNil(p structPointer) bool {
0000000000000000000000000000000000000000;;		return p.v.IsNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface returns the struct pointer as an interface value.
0000000000000000000000000000000000000000;;	func structPointer_Interface(p structPointer, _ reflect.Type) interface{} {
0000000000000000000000000000000000000000;;		return p.v.Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A field identifies a field in a struct, accessible from a structPointer.
0000000000000000000000000000000000000000;;	// In this implementation, a field is identified by the sequence of field indices
0000000000000000000000000000000000000000;;	// passed to reflect's FieldByIndex.
0000000000000000000000000000000000000000;;	type field []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toField returns a field equivalent to the given reflect field.
0000000000000000000000000000000000000000;;	func toField(f *reflect.StructField) field {
0000000000000000000000000000000000000000;;		return f.Index
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// invalidField is an invalid field identifier.
0000000000000000000000000000000000000000;;	var invalidField = field(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValid reports whether the field identifier is valid.
0000000000000000000000000000000000000000;;	func (f field) IsValid() bool { return f != nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// field returns the given field in the struct as a reflect value.
0000000000000000000000000000000000000000;;	func structPointer_field(p structPointer, f field) reflect.Value {
0000000000000000000000000000000000000000;;		// Special case: an extension map entry with a value of type T
0000000000000000000000000000000000000000;;		// passes a *T to the struct-handling code with a zero field,
0000000000000000000000000000000000000000;;		// expecting that it will be treated as equivalent to *struct{ X T },
0000000000000000000000000000000000000000;;		// which has the same memory layout. We have to handle that case
0000000000000000000000000000000000000000;;		// specially, because reflect will panic if we call FieldByIndex on a
0000000000000000000000000000000000000000;;		// non-struct.
0000000000000000000000000000000000000000;;		if f == nil {
0000000000000000000000000000000000000000;;			return p.v.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.v.Elem().FieldByIndex(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ifield returns the given field in the struct as an interface value.
0000000000000000000000000000000000000000;;	func structPointer_ifield(p structPointer, f field) interface{} {
0000000000000000000000000000000000000000;;		return structPointer_field(p, f).Addr().Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bytes returns the address of a []byte field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_Bytes(p structPointer, f field) *[]byte {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*[]byte)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BytesSlice returns the address of a [][]byte field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_BytesSlice(p structPointer, f field) *[][]byte {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*[][]byte)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bool returns the address of a *bool field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_Bool(p structPointer, f field) **bool {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(**bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolVal returns the address of a bool field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_BoolVal(p structPointer, f field) *bool {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolSlice returns the address of a []bool field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_BoolSlice(p structPointer, f field) *[]bool {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*[]bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the address of a *string field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_String(p structPointer, f field) **string {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(**string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringVal returns the address of a string field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_StringVal(p structPointer, f field) *string {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringSlice returns the address of a []string field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_StringSlice(p structPointer, f field) *[]string {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*[]string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extensions returns the address of an extension map field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_Extensions(p structPointer, f field) *XXX_InternalExtensions {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*XXX_InternalExtensions)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtMap returns the address of an extension map field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_ExtMap(p structPointer, f field) *map[int32]Extension {
0000000000000000000000000000000000000000;;		return structPointer_ifield(p, f).(*map[int32]Extension)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAt returns the reflect.Value for a pointer to a field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_NewAt(p structPointer, f field, typ reflect.Type) reflect.Value {
0000000000000000000000000000000000000000;;		return structPointer_field(p, f).Addr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetStructPointer writes a *struct field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_SetStructPointer(p structPointer, f field, q structPointer) {
0000000000000000000000000000000000000000;;		structPointer_field(p, f).Set(q.v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStructPointer reads a *struct field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_GetStructPointer(p structPointer, f field) structPointer {
0000000000000000000000000000000000000000;;		return structPointer{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StructPointerSlice the address of a []*struct field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_StructPointerSlice(p structPointer, f field) structPointerSlice {
0000000000000000000000000000000000000000;;		return structPointerSlice{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A structPointerSlice represents the address of a slice of pointers to structs
0000000000000000000000000000000000000000;;	// (themselves messages or groups). That is, v.Type() is *[]*struct{...}.
0000000000000000000000000000000000000000;;	type structPointerSlice struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p structPointerSlice) Len() int                  { return p.v.Len() }
0000000000000000000000000000000000000000;;	func (p structPointerSlice) Index(i int) structPointer { return structPointer{p.v.Index(i)} }
0000000000000000000000000000000000000000;;	func (p structPointerSlice) Append(q structPointer) {
0000000000000000000000000000000000000000;;		p.v.Set(reflect.Append(p.v, q.v))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		int32Type   = reflect.TypeOf(int32(0))
0000000000000000000000000000000000000000;;		uint32Type  = reflect.TypeOf(uint32(0))
0000000000000000000000000000000000000000;;		float32Type = reflect.TypeOf(float32(0))
0000000000000000000000000000000000000000;;		int64Type   = reflect.TypeOf(int64(0))
0000000000000000000000000000000000000000;;		uint64Type  = reflect.TypeOf(uint64(0))
0000000000000000000000000000000000000000;;		float64Type = reflect.TypeOf(float64(0))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A word32 represents a field of type *int32, *uint32, *float32, or *enum.
0000000000000000000000000000000000000000;;	// That is, v.Type() is *int32, *uint32, *float32, or *enum and v is assignable.
0000000000000000000000000000000000000000;;	type word32 struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNil reports whether p is nil.
0000000000000000000000000000000000000000;;	func word32_IsNil(p word32) bool {
0000000000000000000000000000000000000000;;		return p.v.IsNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets p to point at a newly allocated word with bits set to x.
0000000000000000000000000000000000000000;;	func word32_Set(p word32, o *Buffer, x uint32) {
0000000000000000000000000000000000000000;;		t := p.v.Type().Elem()
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case int32Type:
0000000000000000000000000000000000000000;;			if len(o.int32s) == 0 {
0000000000000000000000000000000000000000;;				o.int32s = make([]int32, uint32PoolSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.int32s[0] = int32(x)
0000000000000000000000000000000000000000;;			p.v.Set(reflect.ValueOf(&o.int32s[0]))
0000000000000000000000000000000000000000;;			o.int32s = o.int32s[1:]
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case uint32Type:
0000000000000000000000000000000000000000;;			if len(o.uint32s) == 0 {
0000000000000000000000000000000000000000;;				o.uint32s = make([]uint32, uint32PoolSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.uint32s[0] = x
0000000000000000000000000000000000000000;;			p.v.Set(reflect.ValueOf(&o.uint32s[0]))
0000000000000000000000000000000000000000;;			o.uint32s = o.uint32s[1:]
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case float32Type:
0000000000000000000000000000000000000000;;			if len(o.float32s) == 0 {
0000000000000000000000000000000000000000;;				o.float32s = make([]float32, uint32PoolSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.float32s[0] = math.Float32frombits(x)
0000000000000000000000000000000000000000;;			p.v.Set(reflect.ValueOf(&o.float32s[0]))
0000000000000000000000000000000000000000;;			o.float32s = o.float32s[1:]
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// must be enum
0000000000000000000000000000000000000000;;		p.v.Set(reflect.New(t))
0000000000000000000000000000000000000000;;		p.v.Elem().SetInt(int64(int32(x)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get gets the bits pointed at by p, as a uint32.
0000000000000000000000000000000000000000;;	func word32_Get(p word32) uint32 {
0000000000000000000000000000000000000000;;		elem := p.v.Elem()
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			return uint32(elem.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			return uint32(elem.Uint())
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			return math.Float32bits(float32(elem.Float()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Word32 returns a reference to a *int32, *uint32, *float32, or *enum field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_Word32(p structPointer, f field) word32 {
0000000000000000000000000000000000000000;;		return word32{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A word32Val represents a field of type int32, uint32, float32, or enum.
0000000000000000000000000000000000000000;;	// That is, v.Type() is int32, uint32, float32, or enum and v is assignable.
0000000000000000000000000000000000000000;;	type word32Val struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set sets *p to x.
0000000000000000000000000000000000000000;;	func word32Val_Set(p word32Val, x uint32) {
0000000000000000000000000000000000000000;;		switch p.v.Type() {
0000000000000000000000000000000000000000;;		case int32Type:
0000000000000000000000000000000000000000;;			p.v.SetInt(int64(x))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case uint32Type:
0000000000000000000000000000000000000000;;			p.v.SetUint(uint64(x))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case float32Type:
0000000000000000000000000000000000000000;;			p.v.SetFloat(float64(math.Float32frombits(x)))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// must be enum
0000000000000000000000000000000000000000;;		p.v.SetInt(int64(int32(x)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get gets the bits pointed at by p, as a uint32.
0000000000000000000000000000000000000000;;	func word32Val_Get(p word32Val) uint32 {
0000000000000000000000000000000000000000;;		elem := p.v
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			return uint32(elem.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			return uint32(elem.Uint())
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			return math.Float32bits(float32(elem.Float()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Word32Val returns a reference to a int32, uint32, float32, or enum field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_Word32Val(p structPointer, f field) word32Val {
0000000000000000000000000000000000000000;;		return word32Val{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A word32Slice is a slice of 32-bit values.
0000000000000000000000000000000000000000;;	// That is, v.Type() is []int32, []uint32, []float32, or []enum.
0000000000000000000000000000000000000000;;	type word32Slice struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p word32Slice) Append(x uint32) {
0000000000000000000000000000000000000000;;		n, m := p.v.Len(), p.v.Cap()
0000000000000000000000000000000000000000;;		if n < m {
0000000000000000000000000000000000000000;;			p.v.SetLen(n + 1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t := p.v.Type().Elem()
0000000000000000000000000000000000000000;;			p.v.Set(reflect.Append(p.v, reflect.Zero(t)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		elem := p.v.Index(n)
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			elem.SetInt(int64(int32(x)))
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			elem.SetUint(uint64(x))
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			elem.SetFloat(float64(math.Float32frombits(x)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p word32Slice) Len() int {
0000000000000000000000000000000000000000;;		return p.v.Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p word32Slice) Index(i int) uint32 {
0000000000000000000000000000000000000000;;		elem := p.v.Index(i)
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int32:
0000000000000000000000000000000000000000;;			return uint32(elem.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint32:
0000000000000000000000000000000000000000;;			return uint32(elem.Uint())
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			return math.Float32bits(float32(elem.Float()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Word32Slice returns a reference to a []int32, []uint32, []float32, or []enum field in the struct.
0000000000000000000000000000000000000000;;	func structPointer_Word32Slice(p structPointer, f field) word32Slice {
0000000000000000000000000000000000000000;;		return word32Slice{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// word64 is like word32 but for 64-bit values.
0000000000000000000000000000000000000000;;	type word64 struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func word64_Set(p word64, o *Buffer, x uint64) {
0000000000000000000000000000000000000000;;		t := p.v.Type().Elem()
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case int64Type:
0000000000000000000000000000000000000000;;			if len(o.int64s) == 0 {
0000000000000000000000000000000000000000;;				o.int64s = make([]int64, uint64PoolSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.int64s[0] = int64(x)
0000000000000000000000000000000000000000;;			p.v.Set(reflect.ValueOf(&o.int64s[0]))
0000000000000000000000000000000000000000;;			o.int64s = o.int64s[1:]
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case uint64Type:
0000000000000000000000000000000000000000;;			if len(o.uint64s) == 0 {
0000000000000000000000000000000000000000;;				o.uint64s = make([]uint64, uint64PoolSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.uint64s[0] = x
0000000000000000000000000000000000000000;;			p.v.Set(reflect.ValueOf(&o.uint64s[0]))
0000000000000000000000000000000000000000;;			o.uint64s = o.uint64s[1:]
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case float64Type:
0000000000000000000000000000000000000000;;			if len(o.float64s) == 0 {
0000000000000000000000000000000000000000;;				o.float64s = make([]float64, uint64PoolSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.float64s[0] = math.Float64frombits(x)
0000000000000000000000000000000000000000;;			p.v.Set(reflect.ValueOf(&o.float64s[0]))
0000000000000000000000000000000000000000;;			o.float64s = o.float64s[1:]
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func word64_IsNil(p word64) bool {
0000000000000000000000000000000000000000;;		return p.v.IsNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func word64_Get(p word64) uint64 {
0000000000000000000000000000000000000000;;		elem := p.v.Elem()
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			return uint64(elem.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			return elem.Uint()
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			return math.Float64bits(elem.Float())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_Word64(p structPointer, f field) word64 {
0000000000000000000000000000000000000000;;		return word64{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// word64Val is like word32Val but for 64-bit values.
0000000000000000000000000000000000000000;;	type word64Val struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func word64Val_Set(p word64Val, o *Buffer, x uint64) {
0000000000000000000000000000000000000000;;		switch p.v.Type() {
0000000000000000000000000000000000000000;;		case int64Type:
0000000000000000000000000000000000000000;;			p.v.SetInt(int64(x))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case uint64Type:
0000000000000000000000000000000000000000;;			p.v.SetUint(x)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case float64Type:
0000000000000000000000000000000000000000;;			p.v.SetFloat(math.Float64frombits(x))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func word64Val_Get(p word64Val) uint64 {
0000000000000000000000000000000000000000;;		elem := p.v
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			return uint64(elem.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			return elem.Uint()
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			return math.Float64bits(elem.Float())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_Word64Val(p structPointer, f field) word64Val {
0000000000000000000000000000000000000000;;		return word64Val{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type word64Slice struct {
0000000000000000000000000000000000000000;;		v reflect.Value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p word64Slice) Append(x uint64) {
0000000000000000000000000000000000000000;;		n, m := p.v.Len(), p.v.Cap()
0000000000000000000000000000000000000000;;		if n < m {
0000000000000000000000000000000000000000;;			p.v.SetLen(n + 1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			t := p.v.Type().Elem()
0000000000000000000000000000000000000000;;			p.v.Set(reflect.Append(p.v, reflect.Zero(t)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		elem := p.v.Index(n)
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			elem.SetInt(int64(int64(x)))
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			elem.SetUint(uint64(x))
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			elem.SetFloat(float64(math.Float64frombits(x)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p word64Slice) Len() int {
0000000000000000000000000000000000000000;;		return p.v.Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p word64Slice) Index(i int) uint64 {
0000000000000000000000000000000000000000;;		elem := p.v.Index(i)
0000000000000000000000000000000000000000;;		switch elem.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int64:
0000000000000000000000000000000000000000;;			return uint64(elem.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint64:
0000000000000000000000000000000000000000;;			return uint64(elem.Uint())
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			return math.Float64bits(float64(elem.Float()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func structPointer_Word64Slice(p structPointer, f field) word64Slice {
0000000000000000000000000000000000000000;;		return word64Slice{structPointer_field(p, f)}
0000000000000000000000000000000000000000;;	}
