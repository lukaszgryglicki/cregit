0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2016, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var timeType = reflect.TypeOf((*time.Time)(nil)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timestamp struct {
0000000000000000000000000000000000000000;;		Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
0000000000000000000000000000000000000000;;		Nanos   int32 `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *timestamp) Reset()       { *m = timestamp{} }
0000000000000000000000000000000000000000;;	func (*timestamp) ProtoMessage()  {}
0000000000000000000000000000000000000000;;	func (*timestamp) String() string { return "timestamp<string>" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		RegisterType((*timestamp)(nil), "gogo.protobuf.proto.timestamp")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) decTimestamp() (time.Time, error) {
0000000000000000000000000000000000000000;;		b, err := o.DecodeRawBytes(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return time.Time{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tproto := &timestamp{}
0000000000000000000000000000000000000000;;		if err := Unmarshal(b, tproto); err != nil {
0000000000000000000000000000000000000000;;			return time.Time{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return timestampFromProto(tproto)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		t, err := o.decTimestamp()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setPtrCustomType(base, p.field, &t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_ref_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		t, err := o.decTimestamp()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		setCustomType(base, p.field, &t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		t, err := o.decTimestamp()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newBas := appendStructPointer(base, p.field, reflect.SliceOf(reflect.PtrTo(timeType)))
0000000000000000000000000000000000000000;;		var zero field
0000000000000000000000000000000000000000;;		setPtrCustomType(newBas, zero, &t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) dec_slice_ref_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		t, err := o.decTimestamp()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newBas := appendStructPointer(base, p.field, reflect.SliceOf(timeType))
0000000000000000000000000000000000000000;;		var zero field
0000000000000000000000000000000000000000;;		setCustomType(newBas, zero, &t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_time(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		structp := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tim := structPointer_Interface(structp, timeType).(*time.Time)
0000000000000000000000000000000000000000;;		t, err := timestampProto(*tim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		size := Size(t)
0000000000000000000000000000000000000000;;		return size + sizeVarint(uint64(size)) + len(p.tagcode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		structp := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tim := structPointer_Interface(structp, timeType).(*time.Time)
0000000000000000000000000000000000000000;;		t, err := timestampProto(*tim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := Marshal(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_ref_time(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		tim := structPointer_InterfaceAt(base, p.field, timeType).(*time.Time)
0000000000000000000000000000000000000000;;		t, err := timestampProto(*tim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		size := Size(t)
0000000000000000000000000000000000000000;;		return size + sizeVarint(uint64(size)) + len(p.tagcode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_ref_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		tim := structPointer_InterfaceAt(base, p.field, timeType).(*time.Time)
0000000000000000000000000000000000000000;;		t, err := timestampProto(*tim)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err := Marshal(t)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_time(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		ptims := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(reflect.PtrTo(timeType))).(*[]*time.Time)
0000000000000000000000000000000000000000;;		tims := *ptims
0000000000000000000000000000000000000000;;		for i := 0; i < len(tims); i++ {
0000000000000000000000000000000000000000;;			if tims[i] == nil {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tproto, err := timestampProto(*tims[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			size := Size(tproto)
0000000000000000000000000000000000000000;;			n += len(p.tagcode) + size + sizeVarint(uint64(size))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		ptims := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(reflect.PtrTo(timeType))).(*[]*time.Time)
0000000000000000000000000000000000000000;;		tims := *ptims
0000000000000000000000000000000000000000;;		for i := 0; i < len(tims); i++ {
0000000000000000000000000000000000000000;;			if tims[i] == nil {
0000000000000000000000000000000000000000;;				return errRepeatedHasNil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tproto, err := timestampProto(*tims[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err := Marshal(tproto)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_ref_time(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		ptims := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(timeType)).(*[]time.Time)
0000000000000000000000000000000000000000;;		tims := *ptims
0000000000000000000000000000000000000000;;		for i := 0; i < len(tims); i++ {
0000000000000000000000000000000000000000;;			tproto, err := timestampProto(tims[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			size := Size(tproto)
0000000000000000000000000000000000000000;;			n += len(p.tagcode) + size + sizeVarint(uint64(size))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_ref_time(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		ptims := structPointer_InterfaceAt(base, p.field, reflect.SliceOf(timeType)).(*[]time.Time)
0000000000000000000000000000000000000000;;		tims := *ptims
0000000000000000000000000000000000000000;;		for i := 0; i < len(tims); i++ {
0000000000000000000000000000000000000000;;			tproto, err := timestampProto(tims[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data, err := Marshal(tproto)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
