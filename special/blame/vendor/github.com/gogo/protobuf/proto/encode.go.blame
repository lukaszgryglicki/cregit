0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
8329b5f94b1a4a7919ce36cf38e5a9fa0715aaf4;Godeps/_workspace/src/github.com/gogo/protobuf/proto/encode.go[Godeps/_workspace/src/github.com/gogo/protobuf/proto/encode.go][vendor/github.com/gogo/protobuf/proto/encode.go];	
0000000000000000000000000000000000000000;;	package proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Routines for encoding data into the wire format for protocol buffers.
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequiredNotSetError is the error returned if Marshal is called with
0000000000000000000000000000000000000000;;	// a protocol buffer struct whose required fields have not
0000000000000000000000000000000000000000;;	// all been initialized. It is also the error returned if Unmarshal is
0000000000000000000000000000000000000000;;	// called with an encoded protocol buffer that does not include all the
0000000000000000000000000000000000000000;;	// required fields.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When printed, RequiredNotSetError reports the first unset required field in a
0000000000000000000000000000000000000000;;	// message. If the field cannot be precisely determined, it is reported as
0000000000000000000000000000000000000000;;	// "{Unknown}".
0000000000000000000000000000000000000000;;	type RequiredNotSetError struct {
0000000000000000000000000000000000000000;;		field string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *RequiredNotSetError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("proto: required field %q not set", e.field)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// errRepeatedHasNil is the error returned if Marshal is called with
0000000000000000000000000000000000000000;;		// a struct with a repeated field containing a nil element.
0000000000000000000000000000000000000000;;		errRepeatedHasNil = errors.New("proto: repeated field has nil element")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// errOneofHasNil is the error returned if Marshal is called with
0000000000000000000000000000000000000000;;		// a struct with a oneof field containing a nil element.
0000000000000000000000000000000000000000;;		errOneofHasNil = errors.New("proto: oneof field has nil value")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNil is the error returned if Marshal is called with nil.
0000000000000000000000000000000000000000;;		ErrNil = errors.New("proto: Marshal called with nil")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrTooLarge is the error returned if Marshal is called with a
0000000000000000000000000000000000000000;;		// message that encodes to >2GB.
0000000000000000000000000000000000000000;;		ErrTooLarge = errors.New("proto: message encodes to over 2 GB")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The fundamental encoders that put bytes on the wire.
0000000000000000000000000000000000000000;;	// Those that take integer types all accept uint64 and are
0000000000000000000000000000000000000000;;	// therefore of type valueEncoder.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxVarintBytes = 10 // maximum length of a varint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxMarshalSize is the largest allowed size of an encoded protobuf,
0000000000000000000000000000000000000000;;	// since C++ and Java use signed int32s for the size.
0000000000000000000000000000000000000000;;	const maxMarshalSize = 1<<31 - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeVarint returns the varint encoding of x.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// int32, int64, uint32, uint64, bool, and enum
0000000000000000000000000000000000000000;;	// protocol buffer types.
0000000000000000000000000000000000000000;;	// Not used by the package itself, but helpful to clients
0000000000000000000000000000000000000000;;	// wishing to use the same encoding.
0000000000000000000000000000000000000000;;	func EncodeVarint(x uint64) []byte {
0000000000000000000000000000000000000000;;		var buf [maxVarintBytes]byte
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		for n = 0; x > 127; n++ {
0000000000000000000000000000000000000000;;			buf[n] = 0x80 | uint8(x&0x7F)
0000000000000000000000000000000000000000;;			x >>= 7
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf[n] = uint8(x)
0000000000000000000000000000000000000000;;		n++
0000000000000000000000000000000000000000;;		return buf[0:n]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeVarint writes a varint-encoded integer to the Buffer.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// int32, int64, uint32, uint64, bool, and enum
0000000000000000000000000000000000000000;;	// protocol buffer types.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeVarint(x uint64) error {
0000000000000000000000000000000000000000;;		for x >= 1<<7 {
0000000000000000000000000000000000000000;;			p.buf = append(p.buf, uint8(x&0x7f|0x80))
0000000000000000000000000000000000000000;;			x >>= 7
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.buf = append(p.buf, uint8(x))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SizeVarint returns the varint encoding size of an integer.
0000000000000000000000000000000000000000;;	func SizeVarint(x uint64) int {
0000000000000000000000000000000000000000;;		return sizeVarint(x)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sizeVarint(x uint64) (n int) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;			x >>= 7
0000000000000000000000000000000000000000;;			if x == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeFixed64 writes a 64-bit integer to the Buffer.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// fixed64, sfixed64, and double protocol buffer types.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeFixed64(x uint64) error {
0000000000000000000000000000000000000000;;		p.buf = append(p.buf,
0000000000000000000000000000000000000000;;			uint8(x),
0000000000000000000000000000000000000000;;			uint8(x>>8),
0000000000000000000000000000000000000000;;			uint8(x>>16),
0000000000000000000000000000000000000000;;			uint8(x>>24),
0000000000000000000000000000000000000000;;			uint8(x>>32),
0000000000000000000000000000000000000000;;			uint8(x>>40),
0000000000000000000000000000000000000000;;			uint8(x>>48),
0000000000000000000000000000000000000000;;			uint8(x>>56))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sizeFixed64(x uint64) int {
0000000000000000000000000000000000000000;;		return 8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeFixed32 writes a 32-bit integer to the Buffer.
0000000000000000000000000000000000000000;;	// This is the format for the
0000000000000000000000000000000000000000;;	// fixed32, sfixed32, and float protocol buffer types.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeFixed32(x uint64) error {
0000000000000000000000000000000000000000;;		p.buf = append(p.buf,
0000000000000000000000000000000000000000;;			uint8(x),
0000000000000000000000000000000000000000;;			uint8(x>>8),
0000000000000000000000000000000000000000;;			uint8(x>>16),
0000000000000000000000000000000000000000;;			uint8(x>>24))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sizeFixed32(x uint64) int {
0000000000000000000000000000000000000000;;		return 4
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeZigzag64 writes a zigzag-encoded 64-bit integer
0000000000000000000000000000000000000000;;	// to the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the sint64 protocol buffer type.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeZigzag64(x uint64) error {
0000000000000000000000000000000000000000;;		// use signed number to get arithmetic right shift.
0000000000000000000000000000000000000000;;		return p.EncodeVarint(uint64((x << 1) ^ uint64((int64(x) >> 63))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sizeZigzag64(x uint64) int {
0000000000000000000000000000000000000000;;		return sizeVarint(uint64((x << 1) ^ uint64((int64(x) >> 63))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeZigzag32 writes a zigzag-encoded 32-bit integer
0000000000000000000000000000000000000000;;	// to the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the sint32 protocol buffer type.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeZigzag32(x uint64) error {
0000000000000000000000000000000000000000;;		// use signed number to get arithmetic right shift.
0000000000000000000000000000000000000000;;		return p.EncodeVarint(uint64((uint32(x) << 1) ^ uint32((int32(x) >> 31))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sizeZigzag32(x uint64) int {
0000000000000000000000000000000000000000;;		return sizeVarint(uint64((uint32(x) << 1) ^ uint32((int32(x) >> 31))))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeRawBytes writes a count-delimited byte buffer to the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the bytes protocol buffer
0000000000000000000000000000000000000000;;	// type and for embedded messages.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeRawBytes(b []byte) error {
0000000000000000000000000000000000000000;;		p.EncodeVarint(uint64(len(b)))
0000000000000000000000000000000000000000;;		p.buf = append(p.buf, b...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sizeRawBytes(b []byte) int {
0000000000000000000000000000000000000000;;		return sizeVarint(uint64(len(b))) +
0000000000000000000000000000000000000000;;			len(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeStringBytes writes an encoded string to the Buffer.
0000000000000000000000000000000000000000;;	// This is the format used for the proto2 string type.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeStringBytes(s string) error {
0000000000000000000000000000000000000000;;		p.EncodeVarint(uint64(len(s)))
0000000000000000000000000000000000000000;;		p.buf = append(p.buf, s...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sizeStringBytes(s string) int {
0000000000000000000000000000000000000000;;		return sizeVarint(uint64(len(s))) +
0000000000000000000000000000000000000000;;			len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshaler is the interface representing objects that can marshal themselves.
0000000000000000000000000000000000000000;;	type Marshaler interface {
0000000000000000000000000000000000000000;;		Marshal() ([]byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal takes the protocol buffer
0000000000000000000000000000000000000000;;	// and encodes it into the wire format, returning the data.
0000000000000000000000000000000000000000;;	func Marshal(pb Message) ([]byte, error) {
0000000000000000000000000000000000000000;;		// Can the object marshal itself?
0000000000000000000000000000000000000000;;		if m, ok := pb.(Marshaler); ok {
0000000000000000000000000000000000000000;;			return m.Marshal()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := NewBuffer(nil)
0000000000000000000000000000000000000000;;		err := p.Marshal(pb)
0000000000000000000000000000000000000000;;		if p.buf == nil && err == nil {
0000000000000000000000000000000000000000;;			// Return a non-nil slice on success.
0000000000000000000000000000000000000000;;			return []byte{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.buf, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeMessage writes the protocol buffer to the Buffer,
0000000000000000000000000000000000000000;;	// prefixed by a varint-encoded length.
0000000000000000000000000000000000000000;;	func (p *Buffer) EncodeMessage(pb Message) error {
0000000000000000000000000000000000000000;;		t, base, err := getbase(pb)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(base) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			var state errorState
0000000000000000000000000000000000000000;;			err = p.enc_len_struct(GetProperties(t.Elem()), base, &state)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Marshal takes the protocol buffer
0000000000000000000000000000000000000000;;	// and encodes it into the wire format, writing the result to the
0000000000000000000000000000000000000000;;	// Buffer.
0000000000000000000000000000000000000000;;	func (p *Buffer) Marshal(pb Message) error {
0000000000000000000000000000000000000000;;		// Can the object marshal itself?
0000000000000000000000000000000000000000;;		if m, ok := pb.(Marshaler); ok {
0000000000000000000000000000000000000000;;			data, err := m.Marshal()
0000000000000000000000000000000000000000;;			p.buf = append(p.buf, data...)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, base, err := getbase(pb)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(base) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			err = p.enc_struct(GetProperties(t.Elem()), base)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if collectStats {
0000000000000000000000000000000000000000;;			(stats).Encode++ // Parens are to work around a goimports bug.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(p.buf) > maxMarshalSize {
0000000000000000000000000000000000000000;;			return ErrTooLarge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns the encoded size of a protocol buffer.
0000000000000000000000000000000000000000;;	func Size(pb Message) (n int) {
0000000000000000000000000000000000000000;;		// Can the object marshal itself?  If so, Size is slow.
0000000000000000000000000000000000000000;;		// TODO: add Size to Marshaler, or add a Sizer interface.
0000000000000000000000000000000000000000;;		if m, ok := pb.(Marshaler); ok {
0000000000000000000000000000000000000000;;			b, _ := m.Marshal()
0000000000000000000000000000000000000000;;			return len(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, base, err := getbase(pb)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(base) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			n = size_struct(GetProperties(t.Elem()), base)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if collectStats {
0000000000000000000000000000000000000000;;			(stats).Size++ // Parens are to work around a goimports bug.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Individual type encoders.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a bool.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := *structPointer_Bool(base, p.field)
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := 0
0000000000000000000000000000000000000000;;		if *v {
0000000000000000000000000000000000000000;;			x = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, uint64(x))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_proto3_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := *structPointer_BoolVal(base, p.field)
0000000000000000000000000000000000000000;;		if !v {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, 1)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_bool(p *Properties, base structPointer) int {
0000000000000000000000000000000000000000;;		v := *structPointer_Bool(base, p.field)
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(p.tagcode) + 1 // each bool takes exactly one byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_proto3_bool(p *Properties, base structPointer) int {
0000000000000000000000000000000000000000;;		v := *structPointer_BoolVal(base, p.field)
0000000000000000000000000000000000000000;;		if !v && !p.oneof {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(p.tagcode) + 1 // each bool takes exactly one byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode an int32.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word32(base, p.field)
0000000000000000000000000000000000000000;;		if word32_IsNil(v) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := int32(word32_Get(v)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, uint64(x))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_proto3_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word32Val(base, p.field)
0000000000000000000000000000000000000000;;		x := int32(word32Val_Get(v)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;		if x == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, uint64(x))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_int32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := structPointer_Word32(base, p.field)
0000000000000000000000000000000000000000;;		if word32_IsNil(v) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := int32(word32_Get(v)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += p.valSize(uint64(x))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_proto3_int32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := structPointer_Word32Val(base, p.field)
0000000000000000000000000000000000000000;;		x := int32(word32Val_Get(v)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;		if x == 0 && !p.oneof {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += p.valSize(uint64(x))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a uint32.
0000000000000000000000000000000000000000;;	// Exactly the same as int32, except for no sign extension.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_uint32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word32(base, p.field)
0000000000000000000000000000000000000000;;		if word32_IsNil(v) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := word32_Get(v)
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, uint64(x))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_proto3_uint32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word32Val(base, p.field)
0000000000000000000000000000000000000000;;		x := word32Val_Get(v)
0000000000000000000000000000000000000000;;		if x == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, uint64(x))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_uint32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := structPointer_Word32(base, p.field)
0000000000000000000000000000000000000000;;		if word32_IsNil(v) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := word32_Get(v)
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += p.valSize(uint64(x))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_proto3_uint32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := structPointer_Word32Val(base, p.field)
0000000000000000000000000000000000000000;;		x := word32Val_Get(v)
0000000000000000000000000000000000000000;;		if x == 0 && !p.oneof {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += p.valSize(uint64(x))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode an int64.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word64(base, p.field)
0000000000000000000000000000000000000000;;		if word64_IsNil(v) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := word64_Get(v)
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, x)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_proto3_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := structPointer_Word64Val(base, p.field)
0000000000000000000000000000000000000000;;		x := word64Val_Get(v)
0000000000000000000000000000000000000000;;		if x == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		p.valEnc(o, x)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_int64(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := structPointer_Word64(base, p.field)
0000000000000000000000000000000000000000;;		if word64_IsNil(v) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := word64_Get(v)
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += p.valSize(x)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_proto3_int64(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := structPointer_Word64Val(base, p.field)
0000000000000000000000000000000000000000;;		x := word64Val_Get(v)
0000000000000000000000000000000000000000;;		if x == 0 && !p.oneof {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += p.valSize(x)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a string.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_string(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := *structPointer_String(base, p.field)
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := *v
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeStringBytes(x)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_proto3_string(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		v := *structPointer_StringVal(base, p.field)
0000000000000000000000000000000000000000;;		if v == "" {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeStringBytes(v)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_string(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := *structPointer_String(base, p.field)
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := *v
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeStringBytes(x)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_proto3_string(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		v := *structPointer_StringVal(base, p.field)
0000000000000000000000000000000000000000;;		if v == "" && !p.oneof {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeStringBytes(v)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All protocol buffer fields are nillable, but be careful.
0000000000000000000000000000000000000000;;	func isNil(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a message struct.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_struct_message(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		var state errorState
0000000000000000000000000000000000000000;;		structp := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Can the object marshal itself?
0000000000000000000000000000000000000000;;		if p.isMarshaler {
0000000000000000000000000000000000000000;;			m := structPointer_Interface(structp, p.stype).(Marshaler)
0000000000000000000000000000000000000000;;			data, err := m.Marshal()
0000000000000000000000000000000000000000;;			if err != nil && !state.shouldContinue(err, nil) {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;			return state.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		return o.enc_len_struct(p.sprop, structp, &state)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_struct_message(p *Properties, base structPointer) int {
0000000000000000000000000000000000000000;;		structp := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Can the object marshal itself?
0000000000000000000000000000000000000000;;		if p.isMarshaler {
0000000000000000000000000000000000000000;;			m := structPointer_Interface(structp, p.stype).(Marshaler)
0000000000000000000000000000000000000000;;			data, _ := m.Marshal()
0000000000000000000000000000000000000000;;			n0 := len(p.tagcode)
0000000000000000000000000000000000000000;;			n1 := sizeRawBytes(data)
0000000000000000000000000000000000000000;;			return n0 + n1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n0 := len(p.tagcode)
0000000000000000000000000000000000000000;;		n1 := size_struct(p.sprop, structp)
0000000000000000000000000000000000000000;;		n2 := sizeVarint(uint64(n1)) // size of encoded length
0000000000000000000000000000000000000000;;		return n0 + n1 + n2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a group struct.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_struct_group(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		var state errorState
0000000000000000000000000000000000000000;;		b := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(b) {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64((p.Tag << 3) | WireStartGroup))
0000000000000000000000000000000000000000;;		err := o.enc_struct(p.sprop, b)
0000000000000000000000000000000000000000;;		if err != nil && !state.shouldContinue(err, nil) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64((p.Tag << 3) | WireEndGroup))
0000000000000000000000000000000000000000;;		return state.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_struct_group(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		b := structPointer_GetStructPointer(base, p.field)
0000000000000000000000000000000000000000;;		if structPointer_IsNil(b) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n += sizeVarint(uint64((p.Tag << 3) | WireStartGroup))
0000000000000000000000000000000000000000;;		n += size_struct(p.sprop, b)
0000000000000000000000000000000000000000;;		n += sizeVarint(uint64((p.Tag << 3) | WireEndGroup))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of bools ([]bool).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := *structPointer_BoolSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(s)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, x := range s {
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			v := uint64(0)
0000000000000000000000000000000000000000;;			if x {
0000000000000000000000000000000000000000;;				v = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.valEnc(o, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_bool(p *Properties, base structPointer) int {
0000000000000000000000000000000000000000;;		s := *structPointer_BoolSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(s)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l * (len(p.tagcode) + 1) // each bool takes exactly one byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of bools ([]bool) in packed format.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_packed_bool(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := *structPointer_BoolSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(s)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64(l)) // each bool takes exactly one byte
0000000000000000000000000000000000000000;;		for _, x := range s {
0000000000000000000000000000000000000000;;			v := uint64(0)
0000000000000000000000000000000000000000;;			if x {
0000000000000000000000000000000000000000;;				v = 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.valEnc(o, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_packed_bool(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := *structPointer_BoolSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(s)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeVarint(uint64(l))
0000000000000000000000000000000000000000;;		n += l // each bool takes exactly one byte
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of bytes ([]byte).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_byte(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := *structPointer_Bytes(base, p.field)
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeRawBytes(s)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_proto3_slice_byte(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := *structPointer_Bytes(base, p.field)
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeRawBytes(s)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_byte(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := *structPointer_Bytes(base, p.field)
0000000000000000000000000000000000000000;;		if s == nil && !p.oneof {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeRawBytes(s)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_proto3_slice_byte(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := *structPointer_Bytes(base, p.field)
0000000000000000000000000000000000000000;;		if len(s) == 0 && !p.oneof {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeRawBytes(s)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of int32s ([]int32).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;			p.valEnc(o, uint64(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_int32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			n += len(p.tagcode)
0000000000000000000000000000000000000000;;			x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;			n += p.valSize(uint64(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of int32s ([]int32) in packed format.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_packed_int32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Reuse a Buffer.
0000000000000000000000000000000000000000;;		buf := NewBuffer(nil)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;			p.valEnc(buf, uint64(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64(len(buf.buf)))
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, buf.buf...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_packed_int32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var bufSize int
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			x := int32(s.Index(i)) // permit sign extension to use full 64-bit range
0000000000000000000000000000000000000000;;			bufSize += p.valSize(uint64(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeVarint(uint64(bufSize))
0000000000000000000000000000000000000000;;		n += bufSize
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of uint32s ([]uint32).
0000000000000000000000000000000000000000;;	// Exactly the same as int32, except for no sign extension.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_uint32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			x := s.Index(i)
0000000000000000000000000000000000000000;;			p.valEnc(o, uint64(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_uint32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			n += len(p.tagcode)
0000000000000000000000000000000000000000;;			x := s.Index(i)
0000000000000000000000000000000000000000;;			n += p.valSize(uint64(x))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of uint32s ([]uint32) in packed format.
0000000000000000000000000000000000000000;;	// Exactly the same as int32, except for no sign extension.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_packed_uint32(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Reuse a Buffer.
0000000000000000000000000000000000000000;;		buf := NewBuffer(nil)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			p.valEnc(buf, uint64(s.Index(i)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64(len(buf.buf)))
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, buf.buf...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_packed_uint32(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_Word32Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var bufSize int
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			bufSize += p.valSize(uint64(s.Index(i)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeVarint(uint64(bufSize))
0000000000000000000000000000000000000000;;		n += bufSize
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of int64s ([]int64).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := structPointer_Word64Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			p.valEnc(o, s.Index(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_int64(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_Word64Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			n += len(p.tagcode)
0000000000000000000000000000000000000000;;			n += p.valSize(s.Index(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of int64s ([]int64) in packed format.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_packed_int64(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		s := structPointer_Word64Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: Reuse a Buffer.
0000000000000000000000000000000000000000;;		buf := NewBuffer(nil)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			p.valEnc(buf, s.Index(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64(len(buf.buf)))
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, buf.buf...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_packed_int64(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_Word64Slice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var bufSize int
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			bufSize += p.valSize(s.Index(i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n += len(p.tagcode)
0000000000000000000000000000000000000000;;		n += sizeVarint(uint64(bufSize))
0000000000000000000000000000000000000000;;		n += bufSize
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of slice of bytes ([][]byte).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_slice_byte(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		ss := *structPointer_BytesSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(ss)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return ErrNil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			o.EncodeRawBytes(ss[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_slice_byte(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		ss := *structPointer_BytesSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(ss)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n += l * len(p.tagcode)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			n += sizeRawBytes(ss[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of strings ([]string).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_string(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		ss := *structPointer_StringSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(ss)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			o.EncodeStringBytes(ss[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_string(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		ss := *structPointer_StringSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := len(ss)
0000000000000000000000000000000000000000;;		n += l * len(p.tagcode)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			n += sizeStringBytes(ss[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of message structs ([]*struct).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_struct_message(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		var state errorState
0000000000000000000000000000000000000000;;		s := structPointer_StructPointerSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			structp := s.Index(i)
0000000000000000000000000000000000000000;;			if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;				return errRepeatedHasNil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Can the object marshal itself?
0000000000000000000000000000000000000000;;			if p.isMarshaler {
0000000000000000000000000000000000000000;;				m := structPointer_Interface(structp, p.stype).(Marshaler)
0000000000000000000000000000000000000000;;				data, err := m.Marshal()
0000000000000000000000000000000000000000;;				if err != nil && !state.shouldContinue(err, nil) {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;				o.EncodeRawBytes(data)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			err := o.enc_len_struct(p.sprop, structp, &state)
0000000000000000000000000000000000000000;;			if err != nil && !state.shouldContinue(err, nil) {
0000000000000000000000000000000000000000;;				if err == ErrNil {
0000000000000000000000000000000000000000;;					return errRepeatedHasNil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_struct_message(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_StructPointerSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;		n += l * len(p.tagcode)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			structp := s.Index(i)
0000000000000000000000000000000000000000;;			if structPointer_IsNil(structp) {
0000000000000000000000000000000000000000;;				return // return the size up to this point
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Can the object marshal itself?
0000000000000000000000000000000000000000;;			if p.isMarshaler {
0000000000000000000000000000000000000000;;				m := structPointer_Interface(structp, p.stype).(Marshaler)
0000000000000000000000000000000000000000;;				data, _ := m.Marshal()
0000000000000000000000000000000000000000;;				n += sizeRawBytes(data)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n0 := size_struct(p.sprop, structp)
0000000000000000000000000000000000000000;;			n1 := sizeVarint(uint64(n0)) // size of encoded length
0000000000000000000000000000000000000000;;			n += n0 + n1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a slice of group structs ([]*struct).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_slice_struct_group(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		var state errorState
0000000000000000000000000000000000000000;;		s := structPointer_StructPointerSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			b := s.Index(i)
0000000000000000000000000000000000000000;;			if structPointer_IsNil(b) {
0000000000000000000000000000000000000000;;				return errRepeatedHasNil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			o.EncodeVarint(uint64((p.Tag << 3) | WireStartGroup))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := o.enc_struct(p.sprop, b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil && !state.shouldContinue(err, nil) {
0000000000000000000000000000000000000000;;				if err == ErrNil {
0000000000000000000000000000000000000000;;					return errRepeatedHasNil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			o.EncodeVarint(uint64((p.Tag << 3) | WireEndGroup))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_slice_struct_group(p *Properties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		s := structPointer_StructPointerSlice(base, p.field)
0000000000000000000000000000000000000000;;		l := s.Len()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n += l * sizeVarint(uint64((p.Tag<<3)|WireStartGroup))
0000000000000000000000000000000000000000;;		n += l * sizeVarint(uint64((p.Tag<<3)|WireEndGroup))
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			b := s.Index(i)
0000000000000000000000000000000000000000;;			if structPointer_IsNil(b) {
0000000000000000000000000000000000000000;;				return // return size up to this point
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n += size_struct(p.sprop, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode an extension map.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_map(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		exts := structPointer_ExtMap(base, p.field)
0000000000000000000000000000000000000000;;		if err := encodeExtensionsMap(*exts); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.enc_map_body(*exts)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_exts(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		exts := structPointer_Extensions(base, p.field)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v, mu := exts.extensionsRead()
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		if err := encodeExtensionsMap(v); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.enc_map_body(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_map_body(v map[int32]Extension) error {
0000000000000000000000000000000000000000;;		// Fast-path for common cases: zero or one extensions.
0000000000000000000000000000000000000000;;		if len(v) <= 1 {
0000000000000000000000000000000000000000;;			for _, e := range v {
0000000000000000000000000000000000000000;;				o.buf = append(o.buf, e.enc...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sort keys to provide a deterministic encoding.
0000000000000000000000000000000000000000;;		keys := make([]int, 0, len(v))
0000000000000000000000000000000000000000;;		for k := range v {
0000000000000000000000000000000000000000;;			keys = append(keys, int(k))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Ints(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, k := range keys {
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, v[int32(k)].enc...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_map(p *Properties, base structPointer) int {
0000000000000000000000000000000000000000;;		v := structPointer_ExtMap(base, p.field)
0000000000000000000000000000000000000000;;		return extensionsMapSize(*v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_exts(p *Properties, base structPointer) int {
0000000000000000000000000000000000000000;;		v := structPointer_Extensions(base, p.field)
0000000000000000000000000000000000000000;;		return extensionsSize(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a map field.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_new_map(p *Properties, base structPointer) error {
0000000000000000000000000000000000000000;;		var state errorState // XXX: or do we need to plumb this through?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			A map defined as
0000000000000000000000000000000000000000;;				map<key_type, value_type> map_field = N;
0000000000000000000000000000000000000000;;			is encoded in the same way as
0000000000000000000000000000000000000000;;				message MapFieldEntry {
0000000000000000000000000000000000000000;;					key_type key = 1;
0000000000000000000000000000000000000000;;					value_type value = 2;
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				repeated MapFieldEntry map_field = N;
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := structPointer_NewAt(base, p.field, p.mtype).Elem() // map[K]V
0000000000000000000000000000000000000000;;		if v.Len() == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keycopy, valcopy, keybase, valbase := mapEncodeScratch(p.mtype)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enc := func() error {
0000000000000000000000000000000000000000;;			if err := p.mkeyprop.enc(o, p.mkeyprop, keybase); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := p.mvalprop.enc(o, p.mvalprop, valbase); err != nil && err != ErrNil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't sort map keys. It is not required by the spec, and C++ doesn't do it.
0000000000000000000000000000000000000000;;		for _, key := range v.MapKeys() {
0000000000000000000000000000000000000000;;			val := v.MapIndex(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keycopy.Set(key)
0000000000000000000000000000000000000000;;			valcopy.Set(val)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, p.tagcode...)
0000000000000000000000000000000000000000;;			if err := o.enc_len_thing(enc, &state); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_new_map(p *Properties, base structPointer) int {
0000000000000000000000000000000000000000;;		v := structPointer_NewAt(base, p.field, p.mtype).Elem() // map[K]V
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keycopy, valcopy, keybase, valbase := mapEncodeScratch(p.mtype)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		for _, key := range v.MapKeys() {
0000000000000000000000000000000000000000;;			val := v.MapIndex(key)
0000000000000000000000000000000000000000;;			keycopy.Set(key)
0000000000000000000000000000000000000000;;			valcopy.Set(val)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Tag codes for key and val are the responsibility of the sub-sizer.
0000000000000000000000000000000000000000;;			keysize := p.mkeyprop.size(p.mkeyprop, keybase)
0000000000000000000000000000000000000000;;			valsize := p.mvalprop.size(p.mvalprop, valbase)
0000000000000000000000000000000000000000;;			entry := keysize + valsize
0000000000000000000000000000000000000000;;			// Add on tag code and length of map entry itself.
0000000000000000000000000000000000000000;;			n += len(p.tagcode) + sizeVarint(uint64(entry)) + entry
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapEncodeScratch returns a new reflect.Value matching the map's value type,
0000000000000000000000000000000000000000;;	// and a structPointer suitable for passing to an encoder or sizer.
0000000000000000000000000000000000000000;;	func mapEncodeScratch(mapType reflect.Type) (keycopy, valcopy reflect.Value, keybase, valbase structPointer) {
0000000000000000000000000000000000000000;;		// Prepare addressable doubly-indirect placeholders for the key and value types.
0000000000000000000000000000000000000000;;		// This is needed because the element-type encoders expect **T, but the map iteration produces T.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keycopy = reflect.New(mapType.Key()).Elem()                 // addressable K
0000000000000000000000000000000000000000;;		keyptr := reflect.New(reflect.PtrTo(keycopy.Type())).Elem() // addressable *K
0000000000000000000000000000000000000000;;		keyptr.Set(keycopy.Addr())                                  //
0000000000000000000000000000000000000000;;		keybase = toStructPointer(keyptr.Addr())                    // **K
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Value types are more varied and require special handling.
0000000000000000000000000000000000000000;;		switch mapType.Elem().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			// []byte
0000000000000000000000000000000000000000;;			var dummy []byte
0000000000000000000000000000000000000000;;			valcopy = reflect.ValueOf(&dummy).Elem() // addressable []byte
0000000000000000000000000000000000000000;;			valbase = toStructPointer(valcopy.Addr())
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			// message; the generated field type is map[K]*Msg (so V is *Msg),
0000000000000000000000000000000000000000;;			// so we only need one level of indirection.
0000000000000000000000000000000000000000;;			valcopy = reflect.New(mapType.Elem()).Elem() // addressable V
0000000000000000000000000000000000000000;;			valbase = toStructPointer(valcopy.Addr())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// everything else
0000000000000000000000000000000000000000;;			valcopy = reflect.New(mapType.Elem()).Elem()                // addressable V
0000000000000000000000000000000000000000;;			valptr := reflect.New(reflect.PtrTo(valcopy.Type())).Elem() // addressable *V
0000000000000000000000000000000000000000;;			valptr.Set(valcopy.Addr())                                  //
0000000000000000000000000000000000000000;;			valbase = toStructPointer(valptr.Addr())                    // **V
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a struct.
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_struct(prop *StructProperties, base structPointer) error {
0000000000000000000000000000000000000000;;		var state errorState
0000000000000000000000000000000000000000;;		// Encode fields in tag order so that decoders may use optimizations
0000000000000000000000000000000000000000;;		// that depend on the ordering.
0000000000000000000000000000000000000000;;		// https://developers.google.com/protocol-buffers/docs/encoding#order
0000000000000000000000000000000000000000;;		for _, i := range prop.order {
0000000000000000000000000000000000000000;;			p := prop.Prop[i]
0000000000000000000000000000000000000000;;			if p.enc != nil {
0000000000000000000000000000000000000000;;				err := p.enc(o, p, base)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if err == ErrNil {
0000000000000000000000000000000000000000;;						if p.Required && state.err == nil {
0000000000000000000000000000000000000000;;							state.err = &RequiredNotSetError{p.Name}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if err == errRepeatedHasNil {
0000000000000000000000000000000000000000;;						// Give more context to nil values in repeated fields.
0000000000000000000000000000000000000000;;						return errors.New("repeated field " + p.OrigName + " has nil element")
0000000000000000000000000000000000000000;;					} else if !state.shouldContinue(err, p) {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(o.buf) > maxMarshalSize {
0000000000000000000000000000000000000000;;					return ErrTooLarge
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Do oneof fields.
0000000000000000000000000000000000000000;;		if prop.oneofMarshaler != nil {
0000000000000000000000000000000000000000;;			m := structPointer_Interface(base, prop.stype).(Message)
0000000000000000000000000000000000000000;;			if err := prop.oneofMarshaler(m, o); err == ErrNil {
0000000000000000000000000000000000000000;;				return errOneofHasNil
0000000000000000000000000000000000000000;;			} else if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add unrecognized fields at the end.
0000000000000000000000000000000000000000;;		if prop.unrecField.IsValid() {
0000000000000000000000000000000000000000;;			v := *structPointer_Bytes(base, prop.unrecField)
0000000000000000000000000000000000000000;;			if len(o.buf)+len(v) > maxMarshalSize {
0000000000000000000000000000000000000000;;				return ErrTooLarge
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(v) > 0 {
0000000000000000000000000000000000000000;;				o.buf = append(o.buf, v...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return state.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func size_struct(prop *StructProperties, base structPointer) (n int) {
0000000000000000000000000000000000000000;;		for _, i := range prop.order {
0000000000000000000000000000000000000000;;			p := prop.Prop[i]
0000000000000000000000000000000000000000;;			if p.size != nil {
0000000000000000000000000000000000000000;;				n += p.size(p, base)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add unrecognized fields at the end.
0000000000000000000000000000000000000000;;		if prop.unrecField.IsValid() {
0000000000000000000000000000000000000000;;			v := *structPointer_Bytes(base, prop.unrecField)
0000000000000000000000000000000000000000;;			n += len(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Factor in any oneof fields.
0000000000000000000000000000000000000000;;		if prop.oneofSizer != nil {
0000000000000000000000000000000000000000;;			m := structPointer_Interface(base, prop.stype).(Message)
0000000000000000000000000000000000000000;;			n += prop.oneofSizer(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var zeroes [20]byte // longer than any conceivable sizeVarint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode a struct, preceded by its encoded length (as a varint).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_len_struct(prop *StructProperties, base structPointer, state *errorState) error {
0000000000000000000000000000000000000000;;		return o.enc_len_thing(func() error { return o.enc_struct(prop, base) }, state)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode something, preceded by its encoded length (as a varint).
0000000000000000000000000000000000000000;;	func (o *Buffer) enc_len_thing(enc func() error, state *errorState) error {
0000000000000000000000000000000000000000;;		iLen := len(o.buf)
0000000000000000000000000000000000000000;;		o.buf = append(o.buf, 0, 0, 0, 0) // reserve four bytes for length
0000000000000000000000000000000000000000;;		iMsg := len(o.buf)
0000000000000000000000000000000000000000;;		err := enc()
0000000000000000000000000000000000000000;;		if err != nil && !state.shouldContinue(err, nil) {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lMsg := len(o.buf) - iMsg
0000000000000000000000000000000000000000;;		lLen := sizeVarint(uint64(lMsg))
0000000000000000000000000000000000000000;;		switch x := lLen - (iMsg - iLen); {
0000000000000000000000000000000000000000;;		case x > 0: // actual length is x bytes larger than the space we reserved
0000000000000000000000000000000000000000;;			// Move msg x bytes right.
0000000000000000000000000000000000000000;;			o.buf = append(o.buf, zeroes[:x]...)
0000000000000000000000000000000000000000;;			copy(o.buf[iMsg+x:], o.buf[iMsg:iMsg+lMsg])
0000000000000000000000000000000000000000;;		case x < 0: // actual length is x bytes smaller than the space we reserved
0000000000000000000000000000000000000000;;			// Move msg x bytes left.
0000000000000000000000000000000000000000;;			copy(o.buf[iMsg+x:], o.buf[iMsg:iMsg+lMsg])
0000000000000000000000000000000000000000;;			o.buf = o.buf[:len(o.buf)+x] // x is negative
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Encode the length in the reserved space.
0000000000000000000000000000000000000000;;		o.buf = o.buf[:iLen]
0000000000000000000000000000000000000000;;		o.EncodeVarint(uint64(lMsg))
0000000000000000000000000000000000000000;;		o.buf = o.buf[:len(o.buf)+lMsg]
0000000000000000000000000000000000000000;;		return state.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errorState maintains the first error that occurs and updates that error
0000000000000000000000000000000000000000;;	// with additional context.
0000000000000000000000000000000000000000;;	type errorState struct {
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// shouldContinue reports whether encoding should continue upon encountering the
0000000000000000000000000000000000000000;;	// given error. If the error is RequiredNotSetError, shouldContinue returns true
0000000000000000000000000000000000000000;;	// and, if this is the first appearance of that error, remembers it for future
0000000000000000000000000000000000000000;;	// reporting.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If prop is not nil, it may update any error with additional context about the
0000000000000000000000000000000000000000;;	// field with the error.
0000000000000000000000000000000000000000;;	func (s *errorState) shouldContinue(err error, prop *Properties) bool {
0000000000000000000000000000000000000000;;		// Ignore unset required fields.
0000000000000000000000000000000000000000;;		reqNotSet, ok := err.(*RequiredNotSetError)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.err == nil {
0000000000000000000000000000000000000000;;			if prop != nil {
0000000000000000000000000000000000000000;;				err = &RequiredNotSetError{prop.Name + "." + reqNotSet.field}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.err = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
