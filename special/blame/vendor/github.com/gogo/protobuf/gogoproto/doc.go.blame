0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
3d29d329cedf26a7a5df80b3b66a105722269e22;Godeps/_workspace/src/github.com/gogo/protobuf/gogoproto/doc.go[Godeps/_workspace/src/github.com/gogo/protobuf/gogoproto/doc.go][vendor/github.com/gogo/protobuf/gogoproto/doc.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package gogoproto provides extensions for protocol buffers to achieve:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - fast marshalling and unmarshalling.
0000000000000000000000000000000000000000;;	  - peace of mind by optionally generating test and benchmark code.
0000000000000000000000000000000000000000;;	  - more canonical Go structures.
0000000000000000000000000000000000000000;;	  - less typing by optionally generating extra helper code.
0000000000000000000000000000000000000000;;	  - goprotobuf compatibility
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	More Canonical Go Structures
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A lot of time working with a goprotobuf struct will lead you to a place where you create another struct that is easier to work with and then have a function to copy the values between the two structs.
0000000000000000000000000000000000000000;;	You might also find that basic structs that started their life as part of an API need to be sent over the wire. With gob, you could just send it. With goprotobuf, you need to make a parallel struct.
0000000000000000000000000000000000000000;;	Gogoprotobuf tries to fix these problems with the nullable, embed, customtype and customname field extensions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - nullable, if false, a field is generated without a pointer (see warning below).
0000000000000000000000000000000000000000;;	  - embed, if true, the field is generated as an embedded field.
0000000000000000000000000000000000000000;;	  - customtype, It works with the Marshal and Unmarshal methods, to allow you to have your own types in your struct, but marshal to bytes. For example, custom.Uuid or custom.Fixed128
0000000000000000000000000000000000000000;;	  - customname (beta), Changes the generated fieldname. This is especially useful when generated methods conflict with fieldnames.
0000000000000000000000000000000000000000;;	  - casttype (beta), Changes the generated fieldtype.  All generated code assumes that this type is castable to the protocol buffer field type.  It does not work for structs or enums.
0000000000000000000000000000000000000000;;	  - castkey (beta), Changes the generated fieldtype for a map key.  All generated code assumes that this type is castable to the protocol buffer field type.  Only supported on maps.
0000000000000000000000000000000000000000;;	  - castvalue (beta), Changes the generated fieldtype for a map value.  All generated code assumes that this type is castable to the protocol buffer field type.  Only supported on maps.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Warning about nullable: According to the Protocol Buffer specification, you should be able to tell whether a field is set or unset. With the option nullable=false this feature is lost, since your non-nullable fields will always be set. It can be seen as a layer on top of Protocol Buffers, where before and after marshalling all non-nullable fields are set and they cannot be unset.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Let us look at:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		github.com/gogo/protobuf/test/example/example.proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	for a quicker overview.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following message:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  package test;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  import "github.com/gogo/protobuf/gogoproto/gogo.proto";
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		message A {
0000000000000000000000000000000000000000;;			optional string Description = 1 [(gogoproto.nullable) = false];
0000000000000000000000000000000000000000;;			optional int64 Number = 2 [(gogoproto.nullable) = false];
0000000000000000000000000000000000000000;;			optional bytes Id = 3 [(gogoproto.customtype) = "github.com/gogo/protobuf/test/custom.Uuid", (gogoproto.nullable) = false];
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Will generate a go struct which looks a lot like this:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type A struct {
0000000000000000000000000000000000000000;;			Description string
0000000000000000000000000000000000000000;;			Number      int64
0000000000000000000000000000000000000000;;			Id          github_com_gogo_protobuf_test_custom.Uuid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You will see there are no pointers, since all fields are non-nullable.
0000000000000000000000000000000000000000;;	You will also see a custom type which marshals to a string.
0000000000000000000000000000000000000000;;	Be warned it is your responsibility to test your custom types thoroughly.
0000000000000000000000000000000000000000;;	You should think of every possible empty and nil case for your marshaling, unmarshaling and size methods.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Next we will embed the message A in message B.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		message B {
0000000000000000000000000000000000000000;;			optional A A = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
0000000000000000000000000000000000000000;;			repeated bytes G = 2 [(gogoproto.customtype) = "github.com/gogo/protobuf/test/custom.Uint128", (gogoproto.nullable) = false];
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See below that A is embedded in B.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type B struct {
0000000000000000000000000000000000000000;;			A
0000000000000000000000000000000000000000;;			G []github_com_gogo_protobuf_test_custom.Uint128
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Also see the repeated custom type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type Uint128 [2]uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Next we will create a custom name for one of our fields.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		message C {
0000000000000000000000000000000000000000;;			optional int64 size = 1 [(gogoproto.customname) = "MySize"];
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See below that the field's name is MySize and not Size.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type C struct {
0000000000000000000000000000000000000000;;			MySize		*int64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The is useful when having a protocol buffer message with a field name which conflicts with a generated method.
0000000000000000000000000000000000000000;;	As an example, having a field name size and using the sizer plugin to generate a Size method will cause a go compiler error.
0000000000000000000000000000000000000000;;	Using customname you can fix this error without changing the field name.
0000000000000000000000000000000000000000;;	This is typically useful when working with a protocol buffer that was designed before these methods and/or the go language were avialable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Gogoprotobuf also has some more subtle changes, these could be changed back:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - the generated package name for imports do not have the extra /filename.pb,
0000000000000000000000000000000000000000;;	  but are actually the imports specified in the .proto file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Gogoprotobuf also has lost some features which should be brought back with time:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - Marshalling and unmarshalling with reflect and without the unsafe package,
0000000000000000000000000000000000000000;;	  this requires work in pointer_reflect.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Why does nullable break protocol buffer specifications:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The protocol buffer specification states, somewhere, that you should be able to tell whether a
0000000000000000000000000000000000000000;;	field is set or unset.  With the option nullable=false this feature is lost,
0000000000000000000000000000000000000000;;	since your non-nullable fields will always be set.  It can be seen as a layer on top of
0000000000000000000000000000000000000000;;	protocol buffers, where before and after marshalling all non-nullable fields are set
0000000000000000000000000000000000000000;;	and they cannot be unset.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Goprotobuf Compatibility:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Gogoprotobuf is compatible with Goprotobuf, because it is compatible with protocol buffers.
0000000000000000000000000000000000000000;;	Gogoprotobuf generates the same code as goprotobuf if no extensions are used.
0000000000000000000000000000000000000000;;	The enumprefix, getters and stringer extensions can be used to remove some of the unnecessary code generated by goprotobuf:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - gogoproto_import, if false, the generated code imports github.com/golang/protobuf/proto instead of github.com/gogo/protobuf/proto.
0000000000000000000000000000000000000000;;	  - goproto_enum_prefix, if false, generates the enum constant names without the messagetype prefix
0000000000000000000000000000000000000000;;	  - goproto_enum_stringer (experimental), if false, the enum is generated without the default string method, this is useful for rather using enum_stringer, or allowing you to write your own string method.
0000000000000000000000000000000000000000;;	  - goproto_getters, if false, the message is generated without get methods, this is useful when you would rather want to use face
0000000000000000000000000000000000000000;;	  - goproto_stringer, if false, the message is generated without the default string method, this is useful for rather using stringer, or allowing you to write your own string method.
0000000000000000000000000000000000000000;;	  - goproto_extensions_map (beta), if false, the extensions field is generated as type []byte instead of type map[int32]proto.Extension
0000000000000000000000000000000000000000;;	  - goproto_unrecognized (beta), if false, XXX_unrecognized field is not generated. This is useful in conjunction with gogoproto.nullable=false, to generate structures completely devoid of pointers and reduce GC pressure at the cost of losing information about unrecognized fields.
0000000000000000000000000000000000000000;;	  - goproto_registration (beta), if true, the generated files will register all messages and types against both gogo/protobuf and golang/protobuf. This is necessary when using third-party packages which read registrations from golang/protobuf (such as the grpc-gateway).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Less Typing and Peace of Mind is explained in their specific plugin folders godoc:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		- github.com/gogo/protobuf/plugin/<extension_name>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you do not use any of these extension the code that is generated
0000000000000000000000000000000000000000;;	will be the same as if goprotobuf has generated it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The most complete way to see examples is to look at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		github.com/gogo/protobuf/test/thetest.proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Gogoprototest is a seperate project,
0000000000000000000000000000000000000000;;	because we want to keep gogoprotobuf independant of goprotobuf,
0000000000000000000000000000000000000000;;	but we still want to test it thoroughly.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package gogoproto
