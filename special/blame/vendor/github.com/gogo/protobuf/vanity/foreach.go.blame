0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2015, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
3d29d329cedf26a7a5df80b3b66a105722269e22;Godeps/_workspace/src/github.com/gogo/protobuf/vanity/foreach.go[Godeps/_workspace/src/github.com/gogo/protobuf/vanity/foreach.go][vendor/github.com/gogo/protobuf/vanity/foreach.go];	
0000000000000000000000000000000000000000;;	package vanity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachFile(files []*descriptor.FileDescriptorProto, f func(file *descriptor.FileDescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			f(file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func OnlyProto2(files []*descriptor.FileDescriptorProto) []*descriptor.FileDescriptorProto {
0000000000000000000000000000000000000000;;		outs := make([]*descriptor.FileDescriptorProto, 0, len(files))
0000000000000000000000000000000000000000;;		for i, file := range files {
0000000000000000000000000000000000000000;;			if file.GetSyntax() == "proto3" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outs = append(outs, files[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return outs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func OnlyProto3(files []*descriptor.FileDescriptorProto) []*descriptor.FileDescriptorProto {
0000000000000000000000000000000000000000;;		outs := make([]*descriptor.FileDescriptorProto, 0, len(files))
0000000000000000000000000000000000000000;;		for i, file := range files {
0000000000000000000000000000000000000000;;			if file.GetSyntax() != "proto3" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outs = append(outs, files[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return outs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachMessageInFiles(files []*descriptor.FileDescriptorProto, f func(msg *descriptor.DescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			ForEachMessage(file.MessageType, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachMessage(msgs []*descriptor.DescriptorProto, f func(msg *descriptor.DescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, msg := range msgs {
0000000000000000000000000000000000000000;;			f(msg)
0000000000000000000000000000000000000000;;			ForEachMessage(msg.NestedType, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachFieldInFilesExcludingExtensions(files []*descriptor.FileDescriptorProto, f func(field *descriptor.FieldDescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			ForEachFieldExcludingExtensions(file.MessageType, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachFieldInFiles(files []*descriptor.FileDescriptorProto, f func(field *descriptor.FieldDescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			for _, ext := range file.Extension {
0000000000000000000000000000000000000000;;				f(ext)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ForEachField(file.MessageType, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachFieldExcludingExtensions(msgs []*descriptor.DescriptorProto, f func(field *descriptor.FieldDescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, msg := range msgs {
0000000000000000000000000000000000000000;;			for _, field := range msg.Field {
0000000000000000000000000000000000000000;;				f(field)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ForEachField(msg.NestedType, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachField(msgs []*descriptor.DescriptorProto, f func(field *descriptor.FieldDescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, msg := range msgs {
0000000000000000000000000000000000000000;;			for _, field := range msg.Field {
0000000000000000000000000000000000000000;;				f(field)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ext := range msg.Extension {
0000000000000000000000000000000000000000;;				f(ext)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ForEachField(msg.NestedType, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachEnumInFiles(files []*descriptor.FileDescriptorProto, f func(enum *descriptor.EnumDescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, file := range files {
0000000000000000000000000000000000000000;;			for _, enum := range file.EnumType {
0000000000000000000000000000000000000000;;				f(enum)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForEachEnum(msgs []*descriptor.DescriptorProto, f func(field *descriptor.EnumDescriptorProto)) {
0000000000000000000000000000000000000000;;		for _, msg := range msgs {
0000000000000000000000000000000000000000;;			for _, field := range msg.EnumType {
0000000000000000000000000000000000000000;;				f(field)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ForEachEnum(msg.NestedType, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
