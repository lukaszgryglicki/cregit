0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
3d29d329cedf26a7a5df80b3b66a105722269e22;Godeps/_workspace/src/github.com/gogo/protobuf/plugin/equal/equal.go[Godeps/_workspace/src/github.com/gogo/protobuf/plugin/equal/equal.go][vendor/github.com/gogo/protobuf/plugin/equal/equal.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	The equal plugin generates an Equal and a VerboseEqual method for each message.
0000000000000000000000000000000000000000;;	These equal methods are quite obvious.
0000000000000000000000000000000000000000;;	The only difference is that VerboseEqual returns a non nil error if it is not equal.
0000000000000000000000000000000000000000;;	This error contains more detail on exactly which part of the message was not equal to the other message.
0000000000000000000000000000000000000000;;	The idea is that this is useful for debugging.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Equal is enabled using the following extensions:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - equal
0000000000000000000000000000000000000000;;	  - equal_all
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	While VerboseEqual is enable dusing the following extensions:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - verbose_equal
0000000000000000000000000000000000000000;;	  - verbose_equal_all
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The equal plugin also generates a test given it is enabled using one of the following extensions:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - testgen
0000000000000000000000000000000000000000;;	  - testgen_all
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Let us look at:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  github.com/gogo/protobuf/test/example/example.proto
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Btw all the output can be seen at:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  github.com/gogo/protobuf/test/example/*
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following message:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  option (gogoproto.equal_all) = true;
0000000000000000000000000000000000000000;;	  option (gogoproto.verbose_equal_all) = true;
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  message B {
0000000000000000000000000000000000000000;;		optional A A = 1 [(gogoproto.nullable) = false, (gogoproto.embed) = true];
0000000000000000000000000000000000000000;;		repeated bytes G = 2 [(gogoproto.customtype) = "github.com/gogo/protobuf/test/custom.Uint128", (gogoproto.nullable) = false];
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	given to the equal plugin, will generate the following code:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (this *B) VerboseEqual(that interface{}) error {
0000000000000000000000000000000000000000;;			if that == nil {
0000000000000000000000000000000000000000;;				if this == nil {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt2.Errorf("that == nil && this != nil")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			that1, ok := that.(*B)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt2.Errorf("that is not of type *B")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if that1 == nil {
0000000000000000000000000000000000000000;;				if this == nil {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return fmt2.Errorf("that is type *B but is nil && this != nil")
0000000000000000000000000000000000000000;;			} else if this == nil {
0000000000000000000000000000000000000000;;				return fmt2.Errorf("that is type *B but is not nil && this == nil")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !this.A.Equal(&that1.A) {
0000000000000000000000000000000000000000;;				return fmt2.Errorf("A this(%v) Not Equal that(%v)", this.A, that1.A)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(this.G) != len(that1.G) {
0000000000000000000000000000000000000000;;				return fmt2.Errorf("G this(%v) Not Equal that(%v)", len(this.G), len(that1.G))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range this.G {
0000000000000000000000000000000000000000;;				if !this.G[i].Equal(that1.G[i]) {
0000000000000000000000000000000000000000;;					return fmt2.Errorf("G this[%v](%v) Not Equal that[%v](%v)", i, this.G[i], i, that1.G[i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
0000000000000000000000000000000000000000;;				return fmt2.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func (this *B) Equal(that interface{}) bool {
0000000000000000000000000000000000000000;;			if that == nil {
0000000000000000000000000000000000000000;;				if this == nil {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			that1, ok := that.(*B)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if that1 == nil {
0000000000000000000000000000000000000000;;				if this == nil {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			} else if this == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !this.A.Equal(&that1.A) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(this.G) != len(that1.G) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range this.G {
0000000000000000000000000000000000000000;;				if !this.G[i].Equal(that1.G[i]) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	and the following test code:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func TestBVerboseEqual(t *testing8.T) {
0000000000000000000000000000000000000000;;			popr := math_rand8.New(math_rand8.NewSource(time8.Now().UnixNano()))
0000000000000000000000000000000000000000;;			p := NewPopulatedB(popr, false)
0000000000000000000000000000000000000000;;			dAtA, err := github_com_gogo_protobuf_proto2.Marshal(p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg := &B{}
0000000000000000000000000000000000000000;;			if err := github_com_gogo_protobuf_proto2.Unmarshal(dAtA, msg); err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := p.VerboseEqual(msg); err != nil {
0000000000000000000000000000000000000000;;				t.Fatalf("%#v !VerboseEqual %#v, since %v", msg, p, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package equal
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/gogoproto"
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/proto"
0000000000000000000000000000000000000000;;		descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/protoc-gen-gogo/generator"
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/vanity"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type plugin struct {
0000000000000000000000000000000000000000;;		*generator.Generator
0000000000000000000000000000000000000000;;		generator.PluginImports
0000000000000000000000000000000000000000;;		fmtPkg   generator.Single
0000000000000000000000000000000000000000;;		bytesPkg generator.Single
0000000000000000000000000000000000000000;;		protoPkg generator.Single
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPlugin() *plugin {
0000000000000000000000000000000000000000;;		return &plugin{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) Name() string {
0000000000000000000000000000000000000000;;		return "equal"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) Init(g *generator.Generator) {
0000000000000000000000000000000000000000;;		p.Generator = g
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) Generate(file *generator.FileDescriptor) {
0000000000000000000000000000000000000000;;		p.PluginImports = generator.NewPluginImports(p.Generator)
0000000000000000000000000000000000000000;;		p.fmtPkg = p.NewImport("fmt")
0000000000000000000000000000000000000000;;		p.bytesPkg = p.NewImport("bytes")
0000000000000000000000000000000000000000;;		p.protoPkg = p.NewImport("github.com/gogo/protobuf/proto")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, msg := range file.Messages() {
0000000000000000000000000000000000000000;;			if msg.DescriptorProto.GetOptions().GetMapEntry() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gogoproto.HasVerboseEqual(file.FileDescriptorProto, msg.DescriptorProto) {
0000000000000000000000000000000000000000;;				p.generateMessage(file, msg, true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gogoproto.HasEqual(file.FileDescriptorProto, msg.DescriptorProto) {
0000000000000000000000000000000000000000;;				p.generateMessage(file, msg, false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) generateNullableField(fieldname string, verbose bool) {
0000000000000000000000000000000000000000;;		p.P(`if this.`, fieldname, ` != nil && that1.`, fieldname, ` != nil {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		p.P(`if *this.`, fieldname, ` != *that1.`, fieldname, `{`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this(%v) Not Equal that(%v)", *this.`, fieldname, `, *that1.`, fieldname, `)`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return false`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`} else if this.`, fieldname, ` != nil {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return `, p.fmtPkg.Use(), `.Errorf("this.`, fieldname, ` == nil && that.`, fieldname, ` != nil")`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return false`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`} else if that1.`, fieldname, ` != nil {`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) generateMsgNullAndTypeCheck(ccTypeName string, verbose bool) {
0000000000000000000000000000000000000000;;		p.P(`if that == nil {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		p.P(`if this == nil {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return nil`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return true`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return `, p.fmtPkg.Use(), `.Errorf("that == nil && this != nil")`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return false`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;		p.P(``)
0000000000000000000000000000000000000000;;		p.P(`that1, ok := that.(*`, ccTypeName, `)`)
0000000000000000000000000000000000000000;;		p.P(`if !ok {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		p.P(`that2, ok := that.(`, ccTypeName, `)`)
0000000000000000000000000000000000000000;;		p.P(`if ok {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		p.P(`that1 = &that2`)
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`} else {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return `, p.fmtPkg.Use(), `.Errorf("that is not of type *`, ccTypeName, `")`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return false`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;		p.P(`if that1 == nil {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		p.P(`if this == nil {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return nil`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return true`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return `, p.fmtPkg.Use(), `.Errorf("that is type *`, ccTypeName, ` but is nil && this != nil")`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return false`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`} else if this == nil {`)
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return `, p.fmtPkg.Use(), `.Errorf("that is type *`, ccTypeName, ` but is not nil && this == nil")`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return false`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) generateField(file *generator.FileDescriptor, message *generator.Descriptor, field *descriptor.FieldDescriptorProto, verbose bool) {
0000000000000000000000000000000000000000;;		proto3 := gogoproto.IsProto3(file.FileDescriptorProto)
0000000000000000000000000000000000000000;;		fieldname := p.GetOneOfFieldName(message, field)
0000000000000000000000000000000000000000;;		repeated := field.IsRepeated()
0000000000000000000000000000000000000000;;		ctype := gogoproto.IsCustomType(field)
0000000000000000000000000000000000000000;;		nullable := gogoproto.IsNullable(field)
0000000000000000000000000000000000000000;;		isDuration := gogoproto.IsStdDuration(field)
0000000000000000000000000000000000000000;;		isTimestamp := gogoproto.IsStdTime(field)
0000000000000000000000000000000000000000;;		// oneof := field.OneofIndex != nil
0000000000000000000000000000000000000000;;		if !repeated {
0000000000000000000000000000000000000000;;			if ctype || isTimestamp {
0000000000000000000000000000000000000000;;				if nullable {
0000000000000000000000000000000000000000;;					p.P(`if that1.`, fieldname, ` == nil {`)
0000000000000000000000000000000000000000;;					p.In()
0000000000000000000000000000000000000000;;					p.P(`if this.`, fieldname, ` != nil {`)
0000000000000000000000000000000000000000;;					p.In()
0000000000000000000000000000000000000000;;					if verbose {
0000000000000000000000000000000000000000;;						p.P(`return `, p.fmtPkg.Use(), `.Errorf("this.`, fieldname, ` != nil && that1.`, fieldname, ` == nil")`)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.P(`return false`)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.Out()
0000000000000000000000000000000000000000;;					p.P(`}`)
0000000000000000000000000000000000000000;;					p.Out()
0000000000000000000000000000000000000000;;					p.P(`} else if !this.`, fieldname, `.Equal(*that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`if !this.`, fieldname, `.Equal(that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this(%v) Not Equal that(%v)", this.`, fieldname, `, that1.`, fieldname, `)`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;			} else if isDuration {
0000000000000000000000000000000000000000;;				if nullable {
0000000000000000000000000000000000000000;;					p.generateNullableField(fieldname, verbose)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`if this.`, fieldname, ` != that1.`, fieldname, `{`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this(%v) Not Equal that(%v)", this.`, fieldname, `, that1.`, fieldname, `)`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if field.IsMessage() || p.IsGroup(field) {
0000000000000000000000000000000000000000;;					if nullable {
0000000000000000000000000000000000000000;;						p.P(`if !this.`, fieldname, `.Equal(that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.P(`if !this.`, fieldname, `.Equal(&that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if field.IsBytes() {
0000000000000000000000000000000000000000;;					p.P(`if !`, p.bytesPkg.Use(), `.Equal(this.`, fieldname, `, that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;				} else if field.IsString() {
0000000000000000000000000000000000000000;;					if nullable && !proto3 {
0000000000000000000000000000000000000000;;						p.generateNullableField(fieldname, verbose)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.P(`if this.`, fieldname, ` != that1.`, fieldname, `{`)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if nullable && !proto3 {
0000000000000000000000000000000000000000;;						p.generateNullableField(fieldname, verbose)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.P(`if this.`, fieldname, ` != that1.`, fieldname, `{`)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this(%v) Not Equal that(%v)", this.`, fieldname, `, that1.`, fieldname, `)`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`if len(this.`, fieldname, `) != len(that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;			p.In()
0000000000000000000000000000000000000000;;			if verbose {
0000000000000000000000000000000000000000;;				p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this(%v) Not Equal that(%v)", len(this.`, fieldname, `), len(that1.`, fieldname, `))`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.P(`return false`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Out()
0000000000000000000000000000000000000000;;			p.P(`}`)
0000000000000000000000000000000000000000;;			p.P(`for i := range this.`, fieldname, ` {`)
0000000000000000000000000000000000000000;;			p.In()
0000000000000000000000000000000000000000;;			if ctype && !p.IsMap(field) {
0000000000000000000000000000000000000000;;				p.P(`if !this.`, fieldname, `[i].Equal(that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;			} else if isTimestamp {
0000000000000000000000000000000000000000;;				if nullable {
0000000000000000000000000000000000000000;;					p.P(`if !this.`, fieldname, `[i].Equal(*that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`if !this.`, fieldname, `[i].Equal(that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if isDuration {
0000000000000000000000000000000000000000;;				if nullable {
0000000000000000000000000000000000000000;;					p.P(`if dthis, dthat := this.`, fieldname, `[i], that1.`, fieldname, `[i]; (dthis != nil && dthat != nil && *dthis != *dthat) || (dthis != nil && dthat == nil) || (dthis == nil && dthat != nil)  {`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`if this.`, fieldname, `[i] != that1.`, fieldname, `[i] {`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if p.IsMap(field) {
0000000000000000000000000000000000000000;;					m := p.GoMapType(nil, field)
0000000000000000000000000000000000000000;;					valuegoTyp, _ := p.GoType(nil, m.ValueField)
0000000000000000000000000000000000000000;;					valuegoAliasTyp, _ := p.GoType(nil, m.ValueAliasField)
0000000000000000000000000000000000000000;;					nullable, valuegoTyp, valuegoAliasTyp = generator.GoMapValueTypes(field, m.ValueField, valuegoTyp, valuegoAliasTyp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					mapValue := m.ValueAliasField
0000000000000000000000000000000000000000;;					if mapValue.IsMessage() || p.IsGroup(mapValue) {
0000000000000000000000000000000000000000;;						if nullable && valuegoTyp == valuegoAliasTyp {
0000000000000000000000000000000000000000;;							p.P(`if !this.`, fieldname, `[i].Equal(that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							// Equal() has a pointer receiver, but map value is a value type
0000000000000000000000000000000000000000;;							a := `this.` + fieldname + `[i]`
0000000000000000000000000000000000000000;;							b := `that1.` + fieldname + `[i]`
0000000000000000000000000000000000000000;;							if valuegoTyp != valuegoAliasTyp {
0000000000000000000000000000000000000000;;								// cast back to the type that has the generated methods on it
0000000000000000000000000000000000000000;;								a = `(` + valuegoTyp + `)(` + a + `)`
0000000000000000000000000000000000000000;;								b = `(` + valuegoTyp + `)(` + b + `)`
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							p.P(`a := `, a)
0000000000000000000000000000000000000000;;							p.P(`b := `, b)
0000000000000000000000000000000000000000;;							if nullable {
0000000000000000000000000000000000000000;;								p.P(`if !a.Equal(b) {`)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								p.P(`if !(&a).Equal(&b) {`)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if mapValue.IsBytes() {
0000000000000000000000000000000000000000;;						if ctype {
0000000000000000000000000000000000000000;;							if nullable {
0000000000000000000000000000000000000000;;								p.P(`if !this.`, fieldname, `[i].Equal(*that1.`, fieldname, `[i]) { //nullable`)
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								p.P(`if !this.`, fieldname, `[i].Equal(that1.`, fieldname, `[i]) { //not nullable`)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							p.P(`if !`, p.bytesPkg.Use(), `.Equal(this.`, fieldname, `[i], that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else if mapValue.IsString() {
0000000000000000000000000000000000000000;;						p.P(`if this.`, fieldname, `[i] != that1.`, fieldname, `[i] {`)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.P(`if this.`, fieldname, `[i] != that1.`, fieldname, `[i] {`)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if field.IsMessage() || p.IsGroup(field) {
0000000000000000000000000000000000000000;;					if nullable {
0000000000000000000000000000000000000000;;						p.P(`if !this.`, fieldname, `[i].Equal(that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.P(`if !this.`, fieldname, `[i].Equal(&that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if field.IsBytes() {
0000000000000000000000000000000000000000;;					p.P(`if !`, p.bytesPkg.Use(), `.Equal(this.`, fieldname, `[i], that1.`, fieldname, `[i]) {`)
0000000000000000000000000000000000000000;;				} else if field.IsString() {
0000000000000000000000000000000000000000;;					p.P(`if this.`, fieldname, `[i] != that1.`, fieldname, `[i] {`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`if this.`, fieldname, `[i] != that1.`, fieldname, `[i] {`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.In()
0000000000000000000000000000000000000000;;			if verbose {
0000000000000000000000000000000000000000;;				p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this[%v](%v) Not Equal that[%v](%v)", i, this.`, fieldname, `[i], i, that1.`, fieldname, `[i])`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.P(`return false`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Out()
0000000000000000000000000000000000000000;;			p.P(`}`)
0000000000000000000000000000000000000000;;			p.Out()
0000000000000000000000000000000000000000;;			p.P(`}`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) generateMessage(file *generator.FileDescriptor, message *generator.Descriptor, verbose bool) {
0000000000000000000000000000000000000000;;		ccTypeName := generator.CamelCaseSlice(message.TypeName())
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`func (this *`, ccTypeName, `) VerboseEqual(that interface{}) error {`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`func (this *`, ccTypeName, `) Equal(that interface{}) bool {`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.In()
0000000000000000000000000000000000000000;;		p.generateMsgNullAndTypeCheck(ccTypeName, verbose)
0000000000000000000000000000000000000000;;		oneofs := make(map[string]struct{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, field := range message.Field {
0000000000000000000000000000000000000000;;			oneof := field.OneofIndex != nil
0000000000000000000000000000000000000000;;			if oneof {
0000000000000000000000000000000000000000;;				fieldname := p.GetFieldName(message, field)
0000000000000000000000000000000000000000;;				if _, ok := oneofs[fieldname]; ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					oneofs[fieldname] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.P(`if that1.`, fieldname, ` == nil {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				p.P(`if this.`, fieldname, ` != nil {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("this.`, fieldname, ` != nil && that1.`, fieldname, ` == nil")`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`} else if this.`, fieldname, ` == nil {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("this.`, fieldname, ` == nil && that1.`, fieldname, ` != nil")`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`} else if err := this.`, fieldname, `.VerboseEqual(that1.`, fieldname, `); err != nil {`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`} else if !this.`, fieldname, `.Equal(that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return err`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.generateField(file, message, field, verbose)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if message.DescriptorProto.HasExtension() {
0000000000000000000000000000000000000000;;			if gogoproto.HasExtensionsMap(file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;				fieldname := "XXX_InternalExtensions"
0000000000000000000000000000000000000000;;				p.P(`thismap := `, p.protoPkg.Use(), `.GetUnsafeExtensionsMap(this)`)
0000000000000000000000000000000000000000;;				p.P(`thatmap := `, p.protoPkg.Use(), `.GetUnsafeExtensionsMap(that1)`)
0000000000000000000000000000000000000000;;				p.P(`for k, v := range thismap {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				p.P(`if v2, ok := thatmap[k]; ok {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				p.P(`if !v.Equal(&v2) {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this[%v](%v) Not Equal that[%v](%v)", k, thismap[k], k, thatmap[k])`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`} else  {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, `[%v] Not In that", k)`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p.P(`for k, _ := range thatmap {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				p.P(`if _, ok := thismap[k]; !ok {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, `[%v] Not In this", k)`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fieldname := "XXX_extensions"
0000000000000000000000000000000000000000;;				p.P(`if !`, p.bytesPkg.Use(), `.Equal(this.`, fieldname, `, that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;				p.In()
0000000000000000000000000000000000000000;;				if verbose {
0000000000000000000000000000000000000000;;					p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this(%v) Not Equal that(%v)", this.`, fieldname, `, that1.`, fieldname, `)`)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					p.P(`return false`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.Out()
0000000000000000000000000000000000000000;;				p.P(`}`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gogoproto.HasUnrecognized(file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;			fieldname := "XXX_unrecognized"
0000000000000000000000000000000000000000;;			p.P(`if !`, p.bytesPkg.Use(), `.Equal(this.`, fieldname, `, that1.`, fieldname, `) {`)
0000000000000000000000000000000000000000;;			p.In()
0000000000000000000000000000000000000000;;			if verbose {
0000000000000000000000000000000000000000;;				p.P(`return `, p.fmtPkg.Use(), `.Errorf("`, fieldname, ` this(%v) Not Equal that(%v)", this.`, fieldname, `, that1.`, fieldname, `)`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.P(`return false`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Out()
0000000000000000000000000000000000000000;;			p.P(`}`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if verbose {
0000000000000000000000000000000000000000;;			p.P(`return nil`)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.P(`return true`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.Out()
0000000000000000000000000000000000000000;;		p.P(`}`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//Generate Equal methods for oneof fields
0000000000000000000000000000000000000000;;		m := proto.Clone(message.DescriptorProto).(*descriptor.DescriptorProto)
0000000000000000000000000000000000000000;;		for _, field := range m.Field {
0000000000000000000000000000000000000000;;			oneof := field.OneofIndex != nil
0000000000000000000000000000000000000000;;			if !oneof {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ccTypeName := p.OneOfTypeName(message, field)
0000000000000000000000000000000000000000;;			if verbose {
0000000000000000000000000000000000000000;;				p.P(`func (this *`, ccTypeName, `) VerboseEqual(that interface{}) error {`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.P(`func (this *`, ccTypeName, `) Equal(that interface{}) bool {`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.In()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.generateMsgNullAndTypeCheck(ccTypeName, verbose)
0000000000000000000000000000000000000000;;			vanity.TurnOffNullableForNativeTypesWithoutDefaultsOnly(field)
0000000000000000000000000000000000000000;;			p.generateField(file, message, field, verbose)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if verbose {
0000000000000000000000000000000000000000;;				p.P(`return nil`)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.P(`return true`)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.Out()
0000000000000000000000000000000000000000;;			p.P(`}`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		generator.RegisterPlugin(NewPlugin())
0000000000000000000000000000000000000000;;	}
