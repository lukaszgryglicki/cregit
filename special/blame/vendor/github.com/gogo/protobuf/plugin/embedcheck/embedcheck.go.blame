0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
3d29d329cedf26a7a5df80b3b66a105722269e22;Godeps/_workspace/src/github.com/gogo/protobuf/plugin/embedcheck/embedcheck.go[Godeps/_workspace/src/github.com/gogo/protobuf/plugin/embedcheck/embedcheck.go][vendor/github.com/gogo/protobuf/plugin/embedcheck/embedcheck.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	The embedcheck plugin is used to check whether embed is not used incorrectly.
0000000000000000000000000000000000000000;;	For instance:
0000000000000000000000000000000000000000;;	An embedded message has a generated string method, but the is a member of a message which does not.
0000000000000000000000000000000000000000;;	This causes a warning.
0000000000000000000000000000000000000000;;	An error is caused by a namespace conflict.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It is enabled by the following extensions:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  - embed
0000000000000000000000000000000000000000;;	  - embed_all
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For incorrect usage of embed with tests see:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  github.com/gogo/protobuf/test/embedconflict
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package embedcheck
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/gogoproto"
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/protoc-gen-gogo/generator"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type plugin struct {
0000000000000000000000000000000000000000;;		*generator.Generator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPlugin() *plugin {
0000000000000000000000000000000000000000;;		return &plugin{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) Name() string {
0000000000000000000000000000000000000000;;		return "embedcheck"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) Init(g *generator.Generator) {
0000000000000000000000000000000000000000;;		p.Generator = g
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var overwriters []map[string]gogoproto.EnableFunc = []map[string]gogoproto.EnableFunc{
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			"stringer": gogoproto.IsStringer,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			"gostring": gogoproto.HasGoString,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			"equal": gogoproto.HasEqual,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			"verboseequal": gogoproto.HasVerboseEqual,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			"size":       gogoproto.IsSizer,
0000000000000000000000000000000000000000;;			"protosizer": gogoproto.IsProtoSizer,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			"unmarshaler":        gogoproto.IsUnmarshaler,
0000000000000000000000000000000000000000;;			"unsafe_unmarshaler": gogoproto.IsUnsafeUnmarshaler,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		{
0000000000000000000000000000000000000000;;			"marshaler":        gogoproto.IsMarshaler,
0000000000000000000000000000000000000000;;			"unsafe_marshaler": gogoproto.IsUnsafeMarshaler,
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) Generate(file *generator.FileDescriptor) {
0000000000000000000000000000000000000000;;		for _, msg := range file.Messages() {
0000000000000000000000000000000000000000;;			for _, os := range overwriters {
0000000000000000000000000000000000000000;;				possible := true
0000000000000000000000000000000000000000;;				for _, overwriter := range os {
0000000000000000000000000000000000000000;;					if overwriter(file.FileDescriptorProto, msg.DescriptorProto) {
0000000000000000000000000000000000000000;;						possible = false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if possible {
0000000000000000000000000000000000000000;;					p.checkOverwrite(msg, os)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.checkNameSpace(msg)
0000000000000000000000000000000000000000;;			for _, field := range msg.GetField() {
0000000000000000000000000000000000000000;;				if gogoproto.IsEmbed(field) && gogoproto.IsCustomName(field) {
0000000000000000000000000000000000000000;;					fmt.Fprintf(os.Stderr, "ERROR: field %v with custom name %v cannot be embedded", *field.Name, gogoproto.GetCustomName(field))
0000000000000000000000000000000000000000;;					os.Exit(1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.checkRepeated(msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, e := range file.GetExtension() {
0000000000000000000000000000000000000000;;			if gogoproto.IsEmbed(e) {
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "ERROR: extended field %v cannot be embedded", generator.CamelCase(*e.Name))
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) checkNameSpace(message *generator.Descriptor) map[string]bool {
0000000000000000000000000000000000000000;;		ccTypeName := generator.CamelCaseSlice(message.TypeName())
0000000000000000000000000000000000000000;;		names := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, field := range message.Field {
0000000000000000000000000000000000000000;;			fieldname := generator.CamelCase(*field.Name)
0000000000000000000000000000000000000000;;			if field.IsMessage() && gogoproto.IsEmbed(field) {
0000000000000000000000000000000000000000;;				desc := p.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;				moreNames := p.checkNameSpace(desc.(*generator.Descriptor))
0000000000000000000000000000000000000000;;				for another := range moreNames {
0000000000000000000000000000000000000000;;					if names[another] {
0000000000000000000000000000000000000000;;						fmt.Fprintf(os.Stderr, "ERROR: duplicate embedded fieldname %v in type %v\n", fieldname, ccTypeName)
0000000000000000000000000000000000000000;;						os.Exit(1)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					names[another] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if names[fieldname] {
0000000000000000000000000000000000000000;;					fmt.Fprintf(os.Stderr, "ERROR: duplicate embedded fieldname %v in type %v\n", fieldname, ccTypeName)
0000000000000000000000000000000000000000;;					os.Exit(1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				names[fieldname] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) checkOverwrite(message *generator.Descriptor, enablers map[string]gogoproto.EnableFunc) {
0000000000000000000000000000000000000000;;		ccTypeName := generator.CamelCaseSlice(message.TypeName())
0000000000000000000000000000000000000000;;		names := []string{}
0000000000000000000000000000000000000000;;		for name := range enablers {
0000000000000000000000000000000000000000;;			names = append(names, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, field := range message.Field {
0000000000000000000000000000000000000000;;			if field.IsMessage() && gogoproto.IsEmbed(field) {
0000000000000000000000000000000000000000;;				fieldname := generator.CamelCase(*field.Name)
0000000000000000000000000000000000000000;;				desc := p.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;				msg := desc.(*generator.Descriptor)
0000000000000000000000000000000000000000;;				for errStr, enabled := range enablers {
0000000000000000000000000000000000000000;;					if enabled(msg.File(), msg.DescriptorProto) {
0000000000000000000000000000000000000000;;						fmt.Fprintf(os.Stderr, "WARNING: found non-%v %v with embedded %v %v\n", names, ccTypeName, errStr, fieldname)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.checkOverwrite(msg, enablers)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) checkRepeated(message *generator.Descriptor) {
0000000000000000000000000000000000000000;;		ccTypeName := generator.CamelCaseSlice(message.TypeName())
0000000000000000000000000000000000000000;;		for _, field := range message.Field {
0000000000000000000000000000000000000000;;			if !gogoproto.IsEmbed(field) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if field.IsBytes() {
0000000000000000000000000000000000000000;;				fieldname := generator.CamelCase(*field.Name)
0000000000000000000000000000000000000000;;				fmt.Fprintf(os.Stderr, "ERROR: found embedded bytes field %s in message %s\n", fieldname, ccTypeName)
0000000000000000000000000000000000000000;;				os.Exit(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !field.IsRepeated() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fieldname := generator.CamelCase(*field.Name)
0000000000000000000000000000000000000000;;			fmt.Fprintf(os.Stderr, "ERROR: found repeated embedded field %s in message %s\n", fieldname, ccTypeName)
0000000000000000000000000000000000000000;;			os.Exit(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *plugin) GenerateImports(*generator.FileDescriptor) {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		generator.RegisterPlugin(NewPlugin())
0000000000000000000000000000000000000000;;	}
