0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
3d29d329cedf26a7a5df80b3b66a105722269e22;Godeps/_workspace/src/github.com/gogo/protobuf/protoc-gen-gogo/generator/generator.go[Godeps/_workspace/src/github.com/gogo/protobuf/protoc-gen-gogo/generator/generator.go][vendor/github.com/gogo/protobuf/protoc-gen-gogo/generator/generator.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;		The code generator for the plugin for the Google protocol buffer compiler.
0000000000000000000000000000000000000000;;		It generates Go code from the protocol buffer description files read by the
0000000000000000000000000000000000000000;;		main routine.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/printer"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/gogoproto"
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/proto"
0000000000000000000000000000000000000000;;		descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
0000000000000000000000000000000000000000;;		plugin "github.com/gogo/protobuf/protoc-gen-gogo/plugin"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generatedCodeVersion indicates a version of the generated code.
0000000000000000000000000000000000000000;;	// It is incremented whenever an incompatibility between the generated code and
0000000000000000000000000000000000000000;;	// proto package is introduced; the generated code references
0000000000000000000000000000000000000000;;	// a constant, proto.ProtoPackageIsVersionN (where N is generatedCodeVersion).
0000000000000000000000000000000000000000;;	const generatedCodeVersion = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Plugin provides functionality to add to the output during Go code generation,
0000000000000000000000000000000000000000;;	// such as to produce RPC stubs.
0000000000000000000000000000000000000000;;	type Plugin interface {
0000000000000000000000000000000000000000;;		// Name identifies the plugin.
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		// Init is called once after data structures are built but before
0000000000000000000000000000000000000000;;		// code generation begins.
0000000000000000000000000000000000000000;;		Init(g *Generator)
0000000000000000000000000000000000000000;;		// Generate produces the code generated by the plugin for this file,
0000000000000000000000000000000000000000;;		// except for the imports, by calling the generator's methods P, In, and Out.
0000000000000000000000000000000000000000;;		Generate(file *FileDescriptor)
0000000000000000000000000000000000000000;;		// GenerateImports produces the import declarations for this file.
0000000000000000000000000000000000000000;;		// It is called after Generate.
0000000000000000000000000000000000000000;;		GenerateImports(file *FileDescriptor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pluginSlice []Plugin
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps pluginSlice) Len() int {
0000000000000000000000000000000000000000;;		return len(ps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps pluginSlice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return ps[i].Name() < ps[j].Name()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ps pluginSlice) Swap(i, j int) {
0000000000000000000000000000000000000000;;		ps[i], ps[j] = ps[j], ps[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var plugins pluginSlice
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RegisterPlugin installs a (second-order) plugin to be run when the Go output is generated.
0000000000000000000000000000000000000000;;	// It is typically called during initialization.
0000000000000000000000000000000000000000;;	func RegisterPlugin(p Plugin) {
0000000000000000000000000000000000000000;;		plugins = append(plugins, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Each type we import as a protocol buffer (other than FileDescriptorProto) needs
0000000000000000000000000000000000000000;;	// a pointer to the FileDescriptorProto that represents it.  These types achieve that
0000000000000000000000000000000000000000;;	// wrapping by placing each Proto inside a struct with the pointer to its File. The
0000000000000000000000000000000000000000;;	// structs have the same names as their contents, with "Proto" removed.
0000000000000000000000000000000000000000;;	// FileDescriptor is used to store the things that it points to.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The file and package name method are common to messages and enums.
0000000000000000000000000000000000000000;;	type common struct {
0000000000000000000000000000000000000000;;		file *descriptor.FileDescriptorProto // File this object comes from.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PackageName is name in the package clause in the generated file.
0000000000000000000000000000000000000000;;	func (c *common) PackageName() string { return uniquePackageOf(c.file) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *common) File() *descriptor.FileDescriptorProto { return c.file }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fileIsProto3(file *descriptor.FileDescriptorProto) bool {
0000000000000000000000000000000000000000;;		return file.GetSyntax() == "proto3"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *common) proto3() bool { return fileIsProto3(c.file) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Descriptor represents a protocol buffer message.
0000000000000000000000000000000000000000;;	type Descriptor struct {
0000000000000000000000000000000000000000;;		common
0000000000000000000000000000000000000000;;		*descriptor.DescriptorProto
0000000000000000000000000000000000000000;;		parent   *Descriptor            // The containing message, if any.
0000000000000000000000000000000000000000;;		nested   []*Descriptor          // Inner messages, if any.
0000000000000000000000000000000000000000;;		enums    []*EnumDescriptor      // Inner enums, if any.
0000000000000000000000000000000000000000;;		ext      []*ExtensionDescriptor // Extensions, if any.
0000000000000000000000000000000000000000;;		typename []string               // Cached typename vector.
0000000000000000000000000000000000000000;;		index    int                    // The index into the container, whether the file or another message.
0000000000000000000000000000000000000000;;		path     string                 // The SourceCodeInfo path as comma-separated integers.
0000000000000000000000000000000000000000;;		group    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeName returns the elements of the dotted type name.
0000000000000000000000000000000000000000;;	// The package name is not part of this name.
0000000000000000000000000000000000000000;;	func (d *Descriptor) TypeName() []string {
0000000000000000000000000000000000000000;;		if d.typename != nil {
0000000000000000000000000000000000000000;;			return d.typename
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		for parent := d; parent != nil; parent = parent.parent {
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := make([]string, n, n)
0000000000000000000000000000000000000000;;		for parent := d; parent != nil; parent = parent.parent {
0000000000000000000000000000000000000000;;			n--
0000000000000000000000000000000000000000;;			s[n] = parent.GetName()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.typename = s
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Descriptor) allowOneof() bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnumDescriptor describes an enum. If it's at top level, its parent will be nil.
0000000000000000000000000000000000000000;;	// Otherwise it will be the descriptor of the message in which it is defined.
0000000000000000000000000000000000000000;;	type EnumDescriptor struct {
0000000000000000000000000000000000000000;;		common
0000000000000000000000000000000000000000;;		*descriptor.EnumDescriptorProto
0000000000000000000000000000000000000000;;		parent   *Descriptor // The containing message, if any.
0000000000000000000000000000000000000000;;		typename []string    // Cached typename vector.
0000000000000000000000000000000000000000;;		index    int         // The index into the container, whether the file or a message.
0000000000000000000000000000000000000000;;		path     string      // The SourceCodeInfo path as comma-separated integers.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeName returns the elements of the dotted type name.
0000000000000000000000000000000000000000;;	// The package name is not part of this name.
0000000000000000000000000000000000000000;;	func (e *EnumDescriptor) TypeName() (s []string) {
0000000000000000000000000000000000000000;;		if e.typename != nil {
0000000000000000000000000000000000000000;;			return e.typename
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := e.GetName()
0000000000000000000000000000000000000000;;		if e.parent == nil {
0000000000000000000000000000000000000000;;			s = make([]string, 1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pname := e.parent.TypeName()
0000000000000000000000000000000000000000;;			s = make([]string, len(pname)+1)
0000000000000000000000000000000000000000;;			copy(s, pname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s[len(s)-1] = name
0000000000000000000000000000000000000000;;		e.typename = s
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// alias provides the TypeName corrected for the application of any naming
0000000000000000000000000000000000000000;;	// extensions on the enum type. It should be used for generating references to
0000000000000000000000000000000000000000;;	// the Go types and for calculating prefixes.
0000000000000000000000000000000000000000;;	func (e *EnumDescriptor) alias() (s []string) {
0000000000000000000000000000000000000000;;		s = e.TypeName()
0000000000000000000000000000000000000000;;		if gogoproto.IsEnumCustomName(e.EnumDescriptorProto) {
0000000000000000000000000000000000000000;;			s[len(s)-1] = gogoproto.GetEnumCustomName(e.EnumDescriptorProto)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Everything but the last element of the full type name, CamelCased.
0000000000000000000000000000000000000000;;	// The values of type Foo.Bar are call Foo_value1... not Foo_Bar_value1... .
0000000000000000000000000000000000000000;;	func (e *EnumDescriptor) prefix() string {
0000000000000000000000000000000000000000;;		typeName := e.alias()
0000000000000000000000000000000000000000;;		if e.parent == nil {
0000000000000000000000000000000000000000;;			// If the enum is not part of a message, the prefix is just the type name.
0000000000000000000000000000000000000000;;			return CamelCase(typeName[len(typeName)-1]) + "_"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return CamelCaseSlice(typeName[0:len(typeName)-1]) + "_"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The integer value of the named constant in this enumerated type.
0000000000000000000000000000000000000000;;	func (e *EnumDescriptor) integerValueAsString(name string) string {
0000000000000000000000000000000000000000;;		for _, c := range e.Value {
0000000000000000000000000000000000000000;;			if c.GetName() == name {
0000000000000000000000000000000000000000;;				return fmt.Sprint(c.GetNumber())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		log.Fatal("cannot find value for enum constant")
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtensionDescriptor describes an extension. If it's at top level, its parent will be nil.
0000000000000000000000000000000000000000;;	// Otherwise it will be the descriptor of the message in which it is defined.
0000000000000000000000000000000000000000;;	type ExtensionDescriptor struct {
0000000000000000000000000000000000000000;;		common
0000000000000000000000000000000000000000;;		*descriptor.FieldDescriptorProto
0000000000000000000000000000000000000000;;		parent *Descriptor // The containing message, if any.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeName returns the elements of the dotted type name.
0000000000000000000000000000000000000000;;	// The package name is not part of this name.
0000000000000000000000000000000000000000;;	func (e *ExtensionDescriptor) TypeName() (s []string) {
0000000000000000000000000000000000000000;;		name := e.GetName()
0000000000000000000000000000000000000000;;		if e.parent == nil {
0000000000000000000000000000000000000000;;			// top-level extension
0000000000000000000000000000000000000000;;			s = make([]string, 1)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pname := e.parent.TypeName()
0000000000000000000000000000000000000000;;			s = make([]string, len(pname)+1)
0000000000000000000000000000000000000000;;			copy(s, pname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s[len(s)-1] = name
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DescName returns the variable name used for the generated descriptor.
0000000000000000000000000000000000000000;;	func (e *ExtensionDescriptor) DescName() string {
0000000000000000000000000000000000000000;;		// The full type name.
0000000000000000000000000000000000000000;;		typeName := e.TypeName()
0000000000000000000000000000000000000000;;		// Each scope of the extension is individually CamelCased, and all are joined with "_" with an "E_" prefix.
0000000000000000000000000000000000000000;;		for i, s := range typeName {
0000000000000000000000000000000000000000;;			typeName[i] = CamelCase(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "E_" + strings.Join(typeName, "_")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ImportedDescriptor describes a type that has been publicly imported from another file.
0000000000000000000000000000000000000000;;	type ImportedDescriptor struct {
0000000000000000000000000000000000000000;;		common
0000000000000000000000000000000000000000;;		o Object
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (id *ImportedDescriptor) TypeName() []string { return id.o.TypeName() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileDescriptor describes an protocol buffer descriptor file (.proto).
0000000000000000000000000000000000000000;;	// It includes slices of all the messages and enums defined within it.
0000000000000000000000000000000000000000;;	// Those slices are constructed by WrapTypes.
0000000000000000000000000000000000000000;;	type FileDescriptor struct {
0000000000000000000000000000000000000000;;		*descriptor.FileDescriptorProto
0000000000000000000000000000000000000000;;		desc []*Descriptor          // All the messages defined in this file.
0000000000000000000000000000000000000000;;		enum []*EnumDescriptor      // All the enums defined in this file.
0000000000000000000000000000000000000000;;		ext  []*ExtensionDescriptor // All the top-level extensions defined in this file.
0000000000000000000000000000000000000000;;		imp  []*ImportedDescriptor  // All types defined in files publicly imported by this file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Comments, stored as a map of path (comma-separated integers) to the comment.
0000000000000000000000000000000000000000;;		comments map[string]*descriptor.SourceCodeInfo_Location
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The full list of symbols that are exported,
0000000000000000000000000000000000000000;;		// as a map from the exported object to its symbols.
0000000000000000000000000000000000000000;;		// This is used for supporting public imports.
0000000000000000000000000000000000000000;;		exported map[Object][]symbol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		index int // The index of this file in the list of files to generate code for
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proto3 bool // whether to generate proto3 code for this file
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PackageName is the package name we'll use in the generated code to refer to this file.
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) PackageName() string { return uniquePackageOf(d.FileDescriptorProto) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VarName is the variable name we'll use in the generated code to refer
0000000000000000000000000000000000000000;;	// to the compressed bytes of this descriptor. It is not exported, so
0000000000000000000000000000000000000000;;	// it is only valid inside the generated package.
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) VarName() string { return fmt.Sprintf("fileDescriptor%v", FileName(d)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goPackageOption interprets the file's go_package option.
0000000000000000000000000000000000000000;;	// If there is no go_package, it returns ("", "", false).
0000000000000000000000000000000000000000;;	// If there's a simple name, it returns ("", pkg, true).
0000000000000000000000000000000000000000;;	// If the option implies an import path, it returns (impPath, pkg, true).
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) goPackageOption() (impPath, pkg string, ok bool) {
0000000000000000000000000000000000000000;;		pkg = d.GetOptions().GetGoPackage()
0000000000000000000000000000000000000000;;		if pkg == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok = true
0000000000000000000000000000000000000000;;		// The presence of a slash implies there's an import path.
0000000000000000000000000000000000000000;;		slash := strings.LastIndex(pkg, "/")
0000000000000000000000000000000000000000;;		if slash < 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		impPath, pkg = pkg, pkg[slash+1:]
0000000000000000000000000000000000000000;;		// A semicolon-delimited suffix overrides the package name.
0000000000000000000000000000000000000000;;		sc := strings.IndexByte(impPath, ';')
0000000000000000000000000000000000000000;;		if sc < 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		impPath, pkg = impPath[:sc], impPath[sc+1:]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goPackageName returns the Go package name to use in the
0000000000000000000000000000000000000000;;	// generated Go file.  The result explicit reports whether the name
0000000000000000000000000000000000000000;;	// came from an option go_package statement.  If explicit is false,
0000000000000000000000000000000000000000;;	// the name was derived from the protocol buffer's package statement
0000000000000000000000000000000000000000;;	// or the input file name.
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) goPackageName() (name string, explicit bool) {
0000000000000000000000000000000000000000;;		// Does the file have a "go_package" option?
0000000000000000000000000000000000000000;;		if _, pkg, ok := d.goPackageOption(); ok {
0000000000000000000000000000000000000000;;			return pkg, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Does the file have a package clause?
0000000000000000000000000000000000000000;;		if pkg := d.GetPackage(); pkg != "" {
0000000000000000000000000000000000000000;;			return pkg, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Use the file base name.
0000000000000000000000000000000000000000;;		return baseName(d.GetName()), false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// goFileName returns the output name for the generated Go file.
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) goFileName() string {
0000000000000000000000000000000000000000;;		name := *d.Name
0000000000000000000000000000000000000000;;		if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
0000000000000000000000000000000000000000;;			name = name[:len(name)-len(ext)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name += ".pb.go"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Does the file have a "go_package" option?
0000000000000000000000000000000000000000;;		// If it does, it may override the filename.
0000000000000000000000000000000000000000;;		if impPath, _, ok := d.goPackageOption(); ok && impPath != "" {
0000000000000000000000000000000000000000;;			// Replace the existing dirname with the declared import path.
0000000000000000000000000000000000000000;;			_, name = path.Split(name)
0000000000000000000000000000000000000000;;			name = path.Join(impPath, name)
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) addExport(obj Object, sym symbol) {
0000000000000000000000000000000000000000;;		d.exported[obj] = append(d.exported[obj], sym)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// symbol is an interface representing an exported Go symbol.
0000000000000000000000000000000000000000;;	type symbol interface {
0000000000000000000000000000000000000000;;		// GenerateAlias should generate an appropriate alias
0000000000000000000000000000000000000000;;		// for the symbol from the named package.
0000000000000000000000000000000000000000;;		GenerateAlias(g *Generator, pkg string)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type messageSymbol struct {
0000000000000000000000000000000000000000;;		sym                         string
0000000000000000000000000000000000000000;;		hasExtensions, isMessageSet bool
0000000000000000000000000000000000000000;;		hasOneof                    bool
0000000000000000000000000000000000000000;;		getters                     []getterSymbol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type getterSymbol struct {
0000000000000000000000000000000000000000;;		name     string
0000000000000000000000000000000000000000;;		typ      string
0000000000000000000000000000000000000000;;		typeName string // canonical name in proto world; empty for proto.Message and similar
0000000000000000000000000000000000000000;;		genType  bool   // whether typ contains a generated type (message/group/enum)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ms *messageSymbol) GenerateAlias(g *Generator, pkg string) {
0000000000000000000000000000000000000000;;		remoteSym := pkg + "." + ms.sym
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.P("type ", ms.sym, " ", remoteSym)
0000000000000000000000000000000000000000;;		g.P("func (m *", ms.sym, ") Reset() { (*", remoteSym, ")(m).Reset() }")
0000000000000000000000000000000000000000;;		g.P("func (m *", ms.sym, ") String() string { return (*", remoteSym, ")(m).String() }")
0000000000000000000000000000000000000000;;		g.P("func (*", ms.sym, ") ProtoMessage() {}")
0000000000000000000000000000000000000000;;		if ms.hasExtensions {
0000000000000000000000000000000000000000;;			g.P("func (*", ms.sym, ") ExtensionRangeArray() []", g.Pkg["proto"], ".ExtensionRange ",
0000000000000000000000000000000000000000;;				"{ return (*", remoteSym, ")(nil).ExtensionRangeArray() }")
0000000000000000000000000000000000000000;;			if ms.isMessageSet {
0000000000000000000000000000000000000000;;				g.P("func (m *", ms.sym, ") Marshal() ([]byte, error) ",
0000000000000000000000000000000000000000;;					"{ return (*", remoteSym, ")(m).Marshal() }")
0000000000000000000000000000000000000000;;				g.P("func (m *", ms.sym, ") Unmarshal(buf []byte) error ",
0000000000000000000000000000000000000000;;					"{ return (*", remoteSym, ")(m).Unmarshal(buf) }")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ms.hasOneof {
0000000000000000000000000000000000000000;;			// Oneofs and public imports do not mix well.
0000000000000000000000000000000000000000;;			// We can make them work okay for the binary format,
0000000000000000000000000000000000000000;;			// but they're going to break weirdly for text/JSON.
0000000000000000000000000000000000000000;;			enc := "_" + ms.sym + "_OneofMarshaler"
0000000000000000000000000000000000000000;;			dec := "_" + ms.sym + "_OneofUnmarshaler"
0000000000000000000000000000000000000000;;			size := "_" + ms.sym + "_OneofSizer"
0000000000000000000000000000000000000000;;			encSig := "(msg " + g.Pkg["proto"] + ".Message, b *" + g.Pkg["proto"] + ".Buffer) error"
0000000000000000000000000000000000000000;;			decSig := "(msg " + g.Pkg["proto"] + ".Message, tag, wire int, b *" + g.Pkg["proto"] + ".Buffer) (bool, error)"
0000000000000000000000000000000000000000;;			sizeSig := "(msg " + g.Pkg["proto"] + ".Message) int"
0000000000000000000000000000000000000000;;			g.P("func (m *", ms.sym, ") XXX_OneofFuncs() (func", encSig, ", func", decSig, ", func", sizeSig, ", []interface{}) {")
0000000000000000000000000000000000000000;;			g.P("return ", enc, ", ", dec, ", ", size, ", nil")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			g.P("func ", enc, encSig, " {")
0000000000000000000000000000000000000000;;			g.P("m := msg.(*", ms.sym, ")")
0000000000000000000000000000000000000000;;			g.P("m0 := (*", remoteSym, ")(m)")
0000000000000000000000000000000000000000;;			g.P("enc, _, _, _ := m0.XXX_OneofFuncs()")
0000000000000000000000000000000000000000;;			g.P("return enc(m0, b)")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			g.P("func ", dec, decSig, " {")
0000000000000000000000000000000000000000;;			g.P("m := msg.(*", ms.sym, ")")
0000000000000000000000000000000000000000;;			g.P("m0 := (*", remoteSym, ")(m)")
0000000000000000000000000000000000000000;;			g.P("_, dec, _, _ := m0.XXX_OneofFuncs()")
0000000000000000000000000000000000000000;;			g.P("return dec(m0, tag, wire, b)")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			g.P("func ", size, sizeSig, " {")
0000000000000000000000000000000000000000;;			g.P("m := msg.(*", ms.sym, ")")
0000000000000000000000000000000000000000;;			g.P("m0 := (*", remoteSym, ")(m)")
0000000000000000000000000000000000000000;;			g.P("_, _, size, _ := m0.XXX_OneofFuncs()")
0000000000000000000000000000000000000000;;			g.P("return size(m0)")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, get := range ms.getters {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if get.typeName != "" {
0000000000000000000000000000000000000000;;				g.RecordTypeUse(get.typeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			typ := get.typ
0000000000000000000000000000000000000000;;			val := "(*" + remoteSym + ")(m)." + get.name + "()"
0000000000000000000000000000000000000000;;			if get.genType {
0000000000000000000000000000000000000000;;				// typ will be "*pkg.T" (message/group) or "pkg.T" (enum)
0000000000000000000000000000000000000000;;				// or "map[t]*pkg.T" (map to message/enum).
0000000000000000000000000000000000000000;;				// The first two of those might have a "[]" prefix if it is repeated.
0000000000000000000000000000000000000000;;				// Drop any package qualifier since we have hoisted the type into this package.
0000000000000000000000000000000000000000;;				rep := strings.HasPrefix(typ, "[]")
0000000000000000000000000000000000000000;;				if rep {
0000000000000000000000000000000000000000;;					typ = typ[2:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				isMap := strings.HasPrefix(typ, "map[")
0000000000000000000000000000000000000000;;				star := typ[0] == '*'
0000000000000000000000000000000000000000;;				if !isMap { // map types handled lower down
0000000000000000000000000000000000000000;;					typ = typ[strings.Index(typ, ".")+1:]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if star {
0000000000000000000000000000000000000000;;					typ = "*" + typ
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if rep {
0000000000000000000000000000000000000000;;					// Go does not permit conversion between slice types where both
0000000000000000000000000000000000000000;;					// element types are named. That means we need to generate a bit
0000000000000000000000000000000000000000;;					// of code in this situation.
0000000000000000000000000000000000000000;;					// typ is the element type.
0000000000000000000000000000000000000000;;					// val is the expression to get the slice from the imported type.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					ctyp := typ // conversion type expression; "Foo" or "(*Foo)"
0000000000000000000000000000000000000000;;					if star {
0000000000000000000000000000000000000000;;						ctyp = "(" + typ + ")"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					g.P("func (m *", ms.sym, ") ", get.name, "() []", typ, " {")
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P("o := ", val)
0000000000000000000000000000000000000000;;					g.P("if o == nil {")
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P("return nil")
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P("}")
0000000000000000000000000000000000000000;;					g.P("s := make([]", typ, ", len(o))")
0000000000000000000000000000000000000000;;					g.P("for i, x := range o {")
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P("s[i] = ", ctyp, "(x)")
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P("}")
0000000000000000000000000000000000000000;;					g.P("return s")
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P("}")
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if isMap {
0000000000000000000000000000000000000000;;					// Split map[keyTyp]valTyp.
0000000000000000000000000000000000000000;;					bra, ket := strings.Index(typ, "["), strings.Index(typ, "]")
0000000000000000000000000000000000000000;;					keyTyp, valTyp := typ[bra+1:ket], typ[ket+1:]
0000000000000000000000000000000000000000;;					// Drop any package qualifier.
0000000000000000000000000000000000000000;;					// Only the value type may be foreign.
0000000000000000000000000000000000000000;;					star := valTyp[0] == '*'
0000000000000000000000000000000000000000;;					valTyp = valTyp[strings.Index(valTyp, ".")+1:]
0000000000000000000000000000000000000000;;					if star {
0000000000000000000000000000000000000000;;						valTyp = "*" + valTyp
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					maptyp := "map[" + keyTyp + "]" + valTyp
0000000000000000000000000000000000000000;;					g.P("func (m *", ms.sym, ") ", get.name, "() ", typ, " {")
0000000000000000000000000000000000000000;;					g.P("o := ", val)
0000000000000000000000000000000000000000;;					g.P("if o == nil { return nil }")
0000000000000000000000000000000000000000;;					g.P("s := make(", maptyp, ", len(o))")
0000000000000000000000000000000000000000;;					g.P("for k, v := range o {")
0000000000000000000000000000000000000000;;					g.P("s[k] = (", valTyp, ")(v)")
0000000000000000000000000000000000000000;;					g.P("}")
0000000000000000000000000000000000000000;;					g.P("return s")
0000000000000000000000000000000000000000;;					g.P("}")
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Convert imported type into the forwarding type.
0000000000000000000000000000000000000000;;				val = "(" + typ + ")(" + val + ")"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			g.P("func (m *", ms.sym, ") ", get.name, "() ", typ, " { return ", val, " }")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type enumSymbol struct {
0000000000000000000000000000000000000000;;		name   string
0000000000000000000000000000000000000000;;		proto3 bool // Whether this came from a proto3 file.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (es enumSymbol) GenerateAlias(g *Generator, pkg string) {
0000000000000000000000000000000000000000;;		s := es.name
0000000000000000000000000000000000000000;;		g.P("type ", s, " ", pkg, ".", s)
0000000000000000000000000000000000000000;;		g.P("var ", s, "_name = ", pkg, ".", s, "_name")
0000000000000000000000000000000000000000;;		g.P("var ", s, "_value = ", pkg, ".", s, "_value")
0000000000000000000000000000000000000000;;		g.P("func (x ", s, ") String() string { return (", pkg, ".", s, ")(x).String() }")
0000000000000000000000000000000000000000;;		if !es.proto3 {
0000000000000000000000000000000000000000;;			g.P("func (x ", s, ") Enum() *", s, "{ return (*", s, ")((", pkg, ".", s, ")(x).Enum()) }")
0000000000000000000000000000000000000000;;			g.P("func (x *", s, ") UnmarshalJSON(data []byte) error { return (*", pkg, ".", s, ")(x).UnmarshalJSON(data) }")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type constOrVarSymbol struct {
0000000000000000000000000000000000000000;;		sym  string
0000000000000000000000000000000000000000;;		typ  string // either "const" or "var"
0000000000000000000000000000000000000000;;		cast string // if non-empty, a type cast is required (used for enums)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (cs constOrVarSymbol) GenerateAlias(g *Generator, pkg string) {
0000000000000000000000000000000000000000;;		v := pkg + "." + cs.sym
0000000000000000000000000000000000000000;;		if cs.cast != "" {
0000000000000000000000000000000000000000;;			v = cs.cast + "(" + v + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P(cs.typ, " ", cs.sym, " = ", v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Object is an interface abstracting the abilities shared by enums, messages, extensions and imported objects.
0000000000000000000000000000000000000000;;	type Object interface {
0000000000000000000000000000000000000000;;		PackageName() string // The name we use in our output (a_b_c), possibly renamed for uniqueness.
0000000000000000000000000000000000000000;;		TypeName() []string
0000000000000000000000000000000000000000;;		File() *descriptor.FileDescriptorProto
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Each package name we generate must be unique. The package we're generating
0000000000000000000000000000000000000000;;	// gets its own name but every other package must have a unique name that does
0000000000000000000000000000000000000000;;	// not conflict in the code we generate.  These names are chosen globally (although
0000000000000000000000000000000000000000;;	// they don't have to be, it simplifies things to do them globally).
0000000000000000000000000000000000000000;;	func uniquePackageOf(fd *descriptor.FileDescriptorProto) string {
0000000000000000000000000000000000000000;;		s, ok := uniquePackageName[fd]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			log.Fatal("internal error: no package name defined for " + fd.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generator is the type whose methods generate the output, stored in the associated response structure.
0000000000000000000000000000000000000000;;	type Generator struct {
0000000000000000000000000000000000000000;;		*bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Request  *plugin.CodeGeneratorRequest  // The input.
0000000000000000000000000000000000000000;;		Response *plugin.CodeGeneratorResponse // The output.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Param             map[string]string // Command-line parameters.
0000000000000000000000000000000000000000;;		PackageImportPath string            // Go import path of the package we're generating code for
0000000000000000000000000000000000000000;;		ImportPrefix      string            // String to prefix to imported package file names.
0000000000000000000000000000000000000000;;		ImportMap         map[string]string // Mapping from .proto file name to import path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Pkg map[string]string // The names under which we import support packages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		packageName      string                     // What we're calling ourselves.
0000000000000000000000000000000000000000;;		allFiles         []*FileDescriptor          // All files in the tree
0000000000000000000000000000000000000000;;		allFilesByName   map[string]*FileDescriptor // All files by filename.
0000000000000000000000000000000000000000;;		genFiles         []*FileDescriptor          // Those files we will generate output for.
0000000000000000000000000000000000000000;;		file             *FileDescriptor            // The file we are compiling now.
0000000000000000000000000000000000000000;;		usedPackages     map[string]bool            // Names of packages used in current file.
0000000000000000000000000000000000000000;;		typeNameToObject map[string]Object          // Key is a fully-qualified name in input syntax.
0000000000000000000000000000000000000000;;		init             []string                   // Lines to emit in the init function.
0000000000000000000000000000000000000000;;		indent           string
0000000000000000000000000000000000000000;;		writeOutput      bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		customImports  []string
0000000000000000000000000000000000000000;;		writtenImports map[string]bool // For de-duplicating written imports
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new generator and allocates the request and response protobufs.
0000000000000000000000000000000000000000;;	func New() *Generator {
0000000000000000000000000000000000000000;;		g := new(Generator)
0000000000000000000000000000000000000000;;		g.Buffer = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		g.Request = new(plugin.CodeGeneratorRequest)
0000000000000000000000000000000000000000;;		g.Response = new(plugin.CodeGeneratorResponse)
0000000000000000000000000000000000000000;;		g.writtenImports = make(map[string]bool)
0000000000000000000000000000000000000000;;		uniquePackageName = make(map[*descriptor.FileDescriptorProto]string)
0000000000000000000000000000000000000000;;		pkgNamesInUse = make(map[string][]*FileDescriptor)
0000000000000000000000000000000000000000;;		return g
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error reports a problem, including an error, and exits the program.
0000000000000000000000000000000000000000;;	func (g *Generator) Error(err error, msgs ...string) {
0000000000000000000000000000000000000000;;		s := strings.Join(msgs, " ") + ":" + err.Error()
0000000000000000000000000000000000000000;;		log.Print("protoc-gen-gogo: error:", s)
0000000000000000000000000000000000000000;;		os.Exit(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fail reports a problem and exits the program.
0000000000000000000000000000000000000000;;	func (g *Generator) Fail(msgs ...string) {
0000000000000000000000000000000000000000;;		s := strings.Join(msgs, " ")
0000000000000000000000000000000000000000;;		log.Print("protoc-gen-gogo: error:", s)
0000000000000000000000000000000000000000;;		os.Exit(1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CommandLineParameters breaks the comma-separated list of key=value pairs
0000000000000000000000000000000000000000;;	// in the parameter (a member of the request protobuf) into a key/value map.
0000000000000000000000000000000000000000;;	// It then sets file name mappings defined by those entries.
0000000000000000000000000000000000000000;;	func (g *Generator) CommandLineParameters(parameter string) {
0000000000000000000000000000000000000000;;		g.Param = make(map[string]string)
0000000000000000000000000000000000000000;;		for _, p := range strings.Split(parameter, ",") {
0000000000000000000000000000000000000000;;			if i := strings.Index(p, "="); i < 0 {
0000000000000000000000000000000000000000;;				g.Param[p] = ""
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				g.Param[p[0:i]] = p[i+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.ImportMap = make(map[string]string)
0000000000000000000000000000000000000000;;		pluginList := "none" // Default list of plugin names to enable (empty means all).
0000000000000000000000000000000000000000;;		for k, v := range g.Param {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case "import_prefix":
0000000000000000000000000000000000000000;;				g.ImportPrefix = v
0000000000000000000000000000000000000000;;			case "import_path":
0000000000000000000000000000000000000000;;				g.PackageImportPath = v
0000000000000000000000000000000000000000;;			case "plugins":
0000000000000000000000000000000000000000;;				pluginList = v
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if len(k) > 0 && k[0] == 'M' {
0000000000000000000000000000000000000000;;					g.ImportMap[k[1:]] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pluginList == "" {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pluginList == "none" {
0000000000000000000000000000000000000000;;			pluginList = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		gogoPluginNames := []string{"unmarshal", "unsafeunmarshaler", "union", "stringer", "size", "protosizer", "populate", "marshalto", "unsafemarshaler", "gostring", "face", "equal", "enumstringer", "embedcheck", "description", "defaultcheck", "oneofcheck", "compare"}
0000000000000000000000000000000000000000;;		pluginList = strings.Join(append(gogoPluginNames, pluginList), "+")
0000000000000000000000000000000000000000;;		if pluginList != "" {
0000000000000000000000000000000000000000;;			// Amend the set of plugins.
0000000000000000000000000000000000000000;;			enabled := make(map[string]bool)
0000000000000000000000000000000000000000;;			for _, name := range strings.Split(pluginList, "+") {
0000000000000000000000000000000000000000;;				enabled[name] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var nplugins pluginSlice
0000000000000000000000000000000000000000;;			for _, p := range plugins {
0000000000000000000000000000000000000000;;				if enabled[p.Name()] {
0000000000000000000000000000000000000000;;					nplugins = append(nplugins, p)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Sort(nplugins)
0000000000000000000000000000000000000000;;			plugins = nplugins
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultPackageName returns the package name printed for the object.
0000000000000000000000000000000000000000;;	// If its file is in a different package, it returns the package name we're using for this file, plus ".".
0000000000000000000000000000000000000000;;	// Otherwise it returns the empty string.
0000000000000000000000000000000000000000;;	func (g *Generator) DefaultPackageName(obj Object) string {
0000000000000000000000000000000000000000;;		pkg := obj.PackageName()
0000000000000000000000000000000000000000;;		if pkg == g.packageName {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pkg + "."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For each input file, the unique package name to use, underscored.
0000000000000000000000000000000000000000;;	var uniquePackageName = make(map[*descriptor.FileDescriptorProto]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Package names already registered.  Key is the name from the .proto file;
0000000000000000000000000000000000000000;;	// value is the name that appears in the generated code.
0000000000000000000000000000000000000000;;	var pkgNamesInUse = make(map[string][]*FileDescriptor)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create and remember a guaranteed unique package name for this file descriptor.
0000000000000000000000000000000000000000;;	// Pkg is the candidate name.  If f is nil, it's a builtin package like "proto" and
0000000000000000000000000000000000000000;;	// has no file descriptor.
0000000000000000000000000000000000000000;;	func RegisterUniquePackageName(pkg string, f *FileDescriptor) string {
0000000000000000000000000000000000000000;;		// Convert dots to underscores before finding a unique alias.
0000000000000000000000000000000000000000;;		pkg = strings.Map(badToUnderscore, pkg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var i = -1
0000000000000000000000000000000000000000;;		var ptr *FileDescriptor = nil
0000000000000000000000000000000000000000;;		for i, ptr = range pkgNamesInUse[pkg] {
0000000000000000000000000000000000000000;;			if ptr == f {
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					return pkg
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return pkg + strconv.Itoa(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pkgNamesInUse[pkg] = append(pkgNamesInUse[pkg], f)
0000000000000000000000000000000000000000;;		i += 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i > 0 {
0000000000000000000000000000000000000000;;			pkg = pkg + strconv.Itoa(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f != nil {
0000000000000000000000000000000000000000;;			uniquePackageName[f.FileDescriptorProto] = pkg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pkg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var isGoKeyword = map[string]bool{
0000000000000000000000000000000000000000;;		"break":       true,
0000000000000000000000000000000000000000;;		"case":        true,
0000000000000000000000000000000000000000;;		"chan":        true,
0000000000000000000000000000000000000000;;		"const":       true,
0000000000000000000000000000000000000000;;		"continue":    true,
0000000000000000000000000000000000000000;;		"default":     true,
0000000000000000000000000000000000000000;;		"else":        true,
0000000000000000000000000000000000000000;;		"defer":       true,
0000000000000000000000000000000000000000;;		"fallthrough": true,
0000000000000000000000000000000000000000;;		"for":         true,
0000000000000000000000000000000000000000;;		"func":        true,
0000000000000000000000000000000000000000;;		"go":          true,
0000000000000000000000000000000000000000;;		"goto":        true,
0000000000000000000000000000000000000000;;		"if":          true,
0000000000000000000000000000000000000000;;		"import":      true,
0000000000000000000000000000000000000000;;		"interface":   true,
0000000000000000000000000000000000000000;;		"map":         true,
0000000000000000000000000000000000000000;;		"package":     true,
0000000000000000000000000000000000000000;;		"range":       true,
0000000000000000000000000000000000000000;;		"return":      true,
0000000000000000000000000000000000000000;;		"select":      true,
0000000000000000000000000000000000000000;;		"struct":      true,
0000000000000000000000000000000000000000;;		"switch":      true,
0000000000000000000000000000000000000000;;		"type":        true,
0000000000000000000000000000000000000000;;		"var":         true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultGoPackage returns the package name to use,
0000000000000000000000000000000000000000;;	// derived from the import path of the package we're building code for.
0000000000000000000000000000000000000000;;	func (g *Generator) defaultGoPackage() string {
0000000000000000000000000000000000000000;;		p := g.PackageImportPath
0000000000000000000000000000000000000000;;		if i := strings.LastIndex(p, "/"); i >= 0 {
0000000000000000000000000000000000000000;;			p = p[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p = strings.Map(badToUnderscore, p)
0000000000000000000000000000000000000000;;		// Identifier must not be keyword: insert _.
0000000000000000000000000000000000000000;;		if isGoKeyword[p] {
0000000000000000000000000000000000000000;;			p = "_" + p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Identifier must not begin with digit: insert _.
0000000000000000000000000000000000000000;;		if r, _ := utf8.DecodeRuneInString(p); unicode.IsDigit(r) {
0000000000000000000000000000000000000000;;			p = "_" + p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPackageNames sets the package name for this run.
0000000000000000000000000000000000000000;;	// The package name must agree across all files being generated.
0000000000000000000000000000000000000000;;	// It also defines unique package names for all imported files.
0000000000000000000000000000000000000000;;	func (g *Generator) SetPackageNames() {
0000000000000000000000000000000000000000;;		// Register the name for this package.  It will be the first name
0000000000000000000000000000000000000000;;		// registered so is guaranteed to be unmodified.
0000000000000000000000000000000000000000;;		pkg, explicit := g.genFiles[0].goPackageName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check all files for an explicit go_package option.
0000000000000000000000000000000000000000;;		for _, f := range g.genFiles {
0000000000000000000000000000000000000000;;			thisPkg, thisExplicit := f.goPackageName()
0000000000000000000000000000000000000000;;			if thisExplicit {
0000000000000000000000000000000000000000;;				if !explicit {
0000000000000000000000000000000000000000;;					// Let this file's go_package option serve for all input files.
0000000000000000000000000000000000000000;;					pkg, explicit = thisPkg, true
0000000000000000000000000000000000000000;;				} else if thisPkg != pkg {
0000000000000000000000000000000000000000;;					g.Fail("inconsistent package names:", thisPkg, pkg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we don't have an explicit go_package option but we have an
0000000000000000000000000000000000000000;;		// import path, use that.
0000000000000000000000000000000000000000;;		if !explicit {
0000000000000000000000000000000000000000;;			p := g.defaultGoPackage()
0000000000000000000000000000000000000000;;			if p != "" {
0000000000000000000000000000000000000000;;				pkg, explicit = p, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there was no go_package and no import path to use,
0000000000000000000000000000000000000000;;		// double-check that all the inputs have the same implicit
0000000000000000000000000000000000000000;;		// Go package name.
0000000000000000000000000000000000000000;;		if !explicit {
0000000000000000000000000000000000000000;;			for _, f := range g.genFiles {
0000000000000000000000000000000000000000;;				thisPkg, _ := f.goPackageName()
0000000000000000000000000000000000000000;;				if thisPkg != pkg {
0000000000000000000000000000000000000000;;					g.Fail("inconsistent package names:", thisPkg, pkg)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.packageName = RegisterUniquePackageName(pkg, g.genFiles[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register the support package names. They might collide with the
0000000000000000000000000000000000000000;;		// name of a package we import.
0000000000000000000000000000000000000000;;		g.Pkg = map[string]string{
0000000000000000000000000000000000000000;;			"fmt":          RegisterUniquePackageName("fmt", nil),
0000000000000000000000000000000000000000;;			"math":         RegisterUniquePackageName("math", nil),
0000000000000000000000000000000000000000;;			"proto":        RegisterUniquePackageName("proto", nil),
0000000000000000000000000000000000000000;;			"golang_proto": RegisterUniquePackageName("golang_proto", nil),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	AllFiles:
0000000000000000000000000000000000000000;;		for _, f := range g.allFiles {
0000000000000000000000000000000000000000;;			for _, genf := range g.genFiles {
0000000000000000000000000000000000000000;;				if f == genf {
0000000000000000000000000000000000000000;;					// In this package already.
0000000000000000000000000000000000000000;;					uniquePackageName[f.FileDescriptorProto] = g.packageName
0000000000000000000000000000000000000000;;					continue AllFiles
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// The file is a dependency, so we want to ignore its go_package option
0000000000000000000000000000000000000000;;			// because that is only relevant for its specific generated output.
0000000000000000000000000000000000000000;;			pkg := f.GetPackage()
0000000000000000000000000000000000000000;;			if pkg == "" {
0000000000000000000000000000000000000000;;				pkg = baseName(*f.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			RegisterUniquePackageName(pkg, f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WrapTypes walks the incoming data, wrapping DescriptorProtos, EnumDescriptorProtos
0000000000000000000000000000000000000000;;	// and FileDescriptorProtos into file-referenced objects within the Generator.
0000000000000000000000000000000000000000;;	// It also creates the list of files to generate and so should be called before GenerateAllFiles.
0000000000000000000000000000000000000000;;	func (g *Generator) WrapTypes() {
0000000000000000000000000000000000000000;;		g.allFiles = make([]*FileDescriptor, 0, len(g.Request.ProtoFile))
0000000000000000000000000000000000000000;;		g.allFilesByName = make(map[string]*FileDescriptor, len(g.allFiles))
0000000000000000000000000000000000000000;;		for _, f := range g.Request.ProtoFile {
0000000000000000000000000000000000000000;;			// We must wrap the descriptors before we wrap the enums
0000000000000000000000000000000000000000;;			descs := wrapDescriptors(f)
0000000000000000000000000000000000000000;;			g.buildNestedDescriptors(descs)
0000000000000000000000000000000000000000;;			enums := wrapEnumDescriptors(f, descs)
0000000000000000000000000000000000000000;;			g.buildNestedEnums(descs, enums)
0000000000000000000000000000000000000000;;			exts := wrapExtensions(f)
0000000000000000000000000000000000000000;;			fd := &FileDescriptor{
0000000000000000000000000000000000000000;;				FileDescriptorProto: f,
0000000000000000000000000000000000000000;;				desc:                descs,
0000000000000000000000000000000000000000;;				enum:                enums,
0000000000000000000000000000000000000000;;				ext:                 exts,
0000000000000000000000000000000000000000;;				exported:            make(map[Object][]symbol),
0000000000000000000000000000000000000000;;				proto3:              fileIsProto3(f),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			extractComments(fd)
0000000000000000000000000000000000000000;;			g.allFiles = append(g.allFiles, fd)
0000000000000000000000000000000000000000;;			g.allFilesByName[f.GetName()] = fd
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, fd := range g.allFiles {
0000000000000000000000000000000000000000;;			fd.imp = wrapImported(fd.FileDescriptorProto, g)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.genFiles = make([]*FileDescriptor, 0, len(g.Request.FileToGenerate))
0000000000000000000000000000000000000000;;		for _, fileName := range g.Request.FileToGenerate {
0000000000000000000000000000000000000000;;			fd := g.allFilesByName[fileName]
0000000000000000000000000000000000000000;;			if fd == nil {
0000000000000000000000000000000000000000;;				g.Fail("could not find file named", fileName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fd.index = len(g.genFiles)
0000000000000000000000000000000000000000;;			g.genFiles = append(g.genFiles, fd)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan the descriptors in this file.  For each one, build the slice of nested descriptors
0000000000000000000000000000000000000000;;	func (g *Generator) buildNestedDescriptors(descs []*Descriptor) {
0000000000000000000000000000000000000000;;		for _, desc := range descs {
0000000000000000000000000000000000000000;;			if len(desc.NestedType) != 0 {
0000000000000000000000000000000000000000;;				for _, nest := range descs {
0000000000000000000000000000000000000000;;					if nest.parent == desc {
0000000000000000000000000000000000000000;;						desc.nested = append(desc.nested, nest)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(desc.nested) != len(desc.NestedType) {
0000000000000000000000000000000000000000;;					g.Fail("internal error: nesting failure for", desc.GetName())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) buildNestedEnums(descs []*Descriptor, enums []*EnumDescriptor) {
0000000000000000000000000000000000000000;;		for _, desc := range descs {
0000000000000000000000000000000000000000;;			if len(desc.EnumType) != 0 {
0000000000000000000000000000000000000000;;				for _, enum := range enums {
0000000000000000000000000000000000000000;;					if enum.parent == desc {
0000000000000000000000000000000000000000;;						desc.enums = append(desc.enums, enum)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(desc.enums) != len(desc.EnumType) {
0000000000000000000000000000000000000000;;					g.Fail("internal error: enum nesting failure for", desc.GetName())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Construct the Descriptor
0000000000000000000000000000000000000000;;	func newDescriptor(desc *descriptor.DescriptorProto, parent *Descriptor, file *descriptor.FileDescriptorProto, index int) *Descriptor {
0000000000000000000000000000000000000000;;		d := &Descriptor{
0000000000000000000000000000000000000000;;			common:          common{file},
0000000000000000000000000000000000000000;;			DescriptorProto: desc,
0000000000000000000000000000000000000000;;			parent:          parent,
0000000000000000000000000000000000000000;;			index:           index,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			d.path = fmt.Sprintf("%d,%d", messagePath, index)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.path = fmt.Sprintf("%s,%d,%d", parent.path, messageMessagePath, index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The only way to distinguish a group from a message is whether
0000000000000000000000000000000000000000;;		// the containing message has a TYPE_GROUP field that matches.
0000000000000000000000000000000000000000;;		if parent != nil {
0000000000000000000000000000000000000000;;			parts := d.TypeName()
0000000000000000000000000000000000000000;;			if file.Package != nil {
0000000000000000000000000000000000000000;;				parts = append([]string{*file.Package}, parts...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			exp := "." + strings.Join(parts, ".")
0000000000000000000000000000000000000000;;			for _, field := range parent.Field {
0000000000000000000000000000000000000000;;				if field.GetType() == descriptor.FieldDescriptorProto_TYPE_GROUP && field.GetTypeName() == exp {
0000000000000000000000000000000000000000;;					d.group = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, field := range desc.Extension {
0000000000000000000000000000000000000000;;			d.ext = append(d.ext, &ExtensionDescriptor{common{file}, field, d})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a slice of all the Descriptors defined within this file
0000000000000000000000000000000000000000;;	func wrapDescriptors(file *descriptor.FileDescriptorProto) []*Descriptor {
0000000000000000000000000000000000000000;;		sl := make([]*Descriptor, 0, len(file.MessageType)+10)
0000000000000000000000000000000000000000;;		for i, desc := range file.MessageType {
0000000000000000000000000000000000000000;;			sl = wrapThisDescriptor(sl, desc, nil, file, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wrap this Descriptor, recursively
0000000000000000000000000000000000000000;;	func wrapThisDescriptor(sl []*Descriptor, desc *descriptor.DescriptorProto, parent *Descriptor, file *descriptor.FileDescriptorProto, index int) []*Descriptor {
0000000000000000000000000000000000000000;;		sl = append(sl, newDescriptor(desc, parent, file, index))
0000000000000000000000000000000000000000;;		me := sl[len(sl)-1]
0000000000000000000000000000000000000000;;		for i, nested := range desc.NestedType {
0000000000000000000000000000000000000000;;			sl = wrapThisDescriptor(sl, nested, me, file, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Construct the EnumDescriptor
0000000000000000000000000000000000000000;;	func newEnumDescriptor(desc *descriptor.EnumDescriptorProto, parent *Descriptor, file *descriptor.FileDescriptorProto, index int) *EnumDescriptor {
0000000000000000000000000000000000000000;;		ed := &EnumDescriptor{
0000000000000000000000000000000000000000;;			common:              common{file},
0000000000000000000000000000000000000000;;			EnumDescriptorProto: desc,
0000000000000000000000000000000000000000;;			parent:              parent,
0000000000000000000000000000000000000000;;			index:               index,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			ed.path = fmt.Sprintf("%d,%d", enumPath, index)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ed.path = fmt.Sprintf("%s,%d,%d", parent.path, messageEnumPath, index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a slice of all the EnumDescriptors defined within this file
0000000000000000000000000000000000000000;;	func wrapEnumDescriptors(file *descriptor.FileDescriptorProto, descs []*Descriptor) []*EnumDescriptor {
0000000000000000000000000000000000000000;;		sl := make([]*EnumDescriptor, 0, len(file.EnumType)+10)
0000000000000000000000000000000000000000;;		// Top-level enums.
0000000000000000000000000000000000000000;;		for i, enum := range file.EnumType {
0000000000000000000000000000000000000000;;			sl = append(sl, newEnumDescriptor(enum, nil, file, i))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Enums within messages. Enums within embedded messages appear in the outer-most message.
0000000000000000000000000000000000000000;;		for _, nested := range descs {
0000000000000000000000000000000000000000;;			for i, enum := range nested.EnumType {
0000000000000000000000000000000000000000;;				sl = append(sl, newEnumDescriptor(enum, nested, file, i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a slice of all the top-level ExtensionDescriptors defined within this file.
0000000000000000000000000000000000000000;;	func wrapExtensions(file *descriptor.FileDescriptorProto) []*ExtensionDescriptor {
0000000000000000000000000000000000000000;;		var sl []*ExtensionDescriptor
0000000000000000000000000000000000000000;;		for _, field := range file.Extension {
0000000000000000000000000000000000000000;;			sl = append(sl, &ExtensionDescriptor{common{file}, field, nil})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sl
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a slice of all the types that are publicly imported into this file.
0000000000000000000000000000000000000000;;	func wrapImported(file *descriptor.FileDescriptorProto, g *Generator) (sl []*ImportedDescriptor) {
0000000000000000000000000000000000000000;;		for _, index := range file.PublicDependency {
0000000000000000000000000000000000000000;;			df := g.fileByName(file.Dependency[index])
0000000000000000000000000000000000000000;;			for _, d := range df.desc {
0000000000000000000000000000000000000000;;				if d.GetOptions().GetMapEntry() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sl = append(sl, &ImportedDescriptor{common{file}, d})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, e := range df.enum {
0000000000000000000000000000000000000000;;				sl = append(sl, &ImportedDescriptor{common{file}, e})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, ext := range df.ext {
0000000000000000000000000000000000000000;;				sl = append(sl, &ImportedDescriptor{common{file}, ext})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractComments(file *FileDescriptor) {
0000000000000000000000000000000000000000;;		file.comments = make(map[string]*descriptor.SourceCodeInfo_Location)
0000000000000000000000000000000000000000;;		for _, loc := range file.GetSourceCodeInfo().GetLocation() {
0000000000000000000000000000000000000000;;			if loc.LeadingComments == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var p []string
0000000000000000000000000000000000000000;;			for _, n := range loc.Path {
0000000000000000000000000000000000000000;;				p = append(p, strconv.Itoa(int(n)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			file.comments[strings.Join(p, ",")] = loc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildTypeNameMap builds the map from fully qualified type names to objects.
0000000000000000000000000000000000000000;;	// The key names for the map come from the input data, which puts a period at the beginning.
0000000000000000000000000000000000000000;;	// It should be called after SetPackageNames and before GenerateAllFiles.
0000000000000000000000000000000000000000;;	func (g *Generator) BuildTypeNameMap() {
0000000000000000000000000000000000000000;;		g.typeNameToObject = make(map[string]Object)
0000000000000000000000000000000000000000;;		for _, f := range g.allFiles {
0000000000000000000000000000000000000000;;			// The names in this loop are defined by the proto world, not us, so the
0000000000000000000000000000000000000000;;			// package name may be empty.  If so, the dotted package name of X will
0000000000000000000000000000000000000000;;			// be ".X"; otherwise it will be ".pkg.X".
0000000000000000000000000000000000000000;;			dottedPkg := "." + f.GetPackage()
0000000000000000000000000000000000000000;;			if dottedPkg != "." {
0000000000000000000000000000000000000000;;				dottedPkg += "."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, enum := range f.enum {
0000000000000000000000000000000000000000;;				name := dottedPkg + dottedSlice(enum.TypeName())
0000000000000000000000000000000000000000;;				g.typeNameToObject[name] = enum
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, desc := range f.desc {
0000000000000000000000000000000000000000;;				name := dottedPkg + dottedSlice(desc.TypeName())
0000000000000000000000000000000000000000;;				g.typeNameToObject[name] = desc
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectNamed, given a fully-qualified input type name as it appears in the input data,
0000000000000000000000000000000000000000;;	// returns the descriptor for the message or enum with that name.
0000000000000000000000000000000000000000;;	func (g *Generator) ObjectNamed(typeName string) Object {
0000000000000000000000000000000000000000;;		o, ok := g.typeNameToObject[typeName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			g.Fail("can't find object with type", typeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the file of this object isn't a direct dependency of the current file,
0000000000000000000000000000000000000000;;		// or in the current file, then this object has been publicly imported into
0000000000000000000000000000000000000000;;		// a dependency of the current file.
0000000000000000000000000000000000000000;;		// We should return the ImportedDescriptor object for it instead.
0000000000000000000000000000000000000000;;		direct := *o.File().Name == *g.file.Name
0000000000000000000000000000000000000000;;		if !direct {
0000000000000000000000000000000000000000;;			for _, dep := range g.file.Dependency {
0000000000000000000000000000000000000000;;				if *g.fileByName(dep).Name == *o.File().Name {
0000000000000000000000000000000000000000;;					direct = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !direct {
0000000000000000000000000000000000000000;;			found := false
0000000000000000000000000000000000000000;;		Loop:
0000000000000000000000000000000000000000;;			for _, dep := range g.file.Dependency {
0000000000000000000000000000000000000000;;				df := g.fileByName(*g.fileByName(dep).Name)
0000000000000000000000000000000000000000;;				for _, td := range df.imp {
0000000000000000000000000000000000000000;;					if td.o == o {
0000000000000000000000000000000000000000;;						// Found it!
0000000000000000000000000000000000000000;;						o = td
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						break Loop
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				log.Printf("protoc-gen-gogo: WARNING: failed finding publicly imported dependency for %v, used in %v", typeName, *g.file.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// P prints the arguments to the generated output.  It handles strings and int32s, plus
0000000000000000000000000000000000000000;;	// handling indirections because they may be *string, etc.
0000000000000000000000000000000000000000;;	func (g *Generator) P(str ...interface{}) {
0000000000000000000000000000000000000000;;		if !g.writeOutput {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.WriteString(g.indent)
0000000000000000000000000000000000000000;;		for _, v := range str {
0000000000000000000000000000000000000000;;			switch s := v.(type) {
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				g.WriteString(s)
0000000000000000000000000000000000000000;;			case *string:
0000000000000000000000000000000000000000;;				g.WriteString(*s)
0000000000000000000000000000000000000000;;			case bool:
0000000000000000000000000000000000000000;;				fmt.Fprintf(g, "%t", s)
0000000000000000000000000000000000000000;;			case *bool:
0000000000000000000000000000000000000000;;				fmt.Fprintf(g, "%t", *s)
0000000000000000000000000000000000000000;;			case int:
0000000000000000000000000000000000000000;;				fmt.Fprintf(g, "%d", s)
0000000000000000000000000000000000000000;;			case *int32:
0000000000000000000000000000000000000000;;				fmt.Fprintf(g, "%d", *s)
0000000000000000000000000000000000000000;;			case *int64:
0000000000000000000000000000000000000000;;				fmt.Fprintf(g, "%d", *s)
0000000000000000000000000000000000000000;;			case float64:
0000000000000000000000000000000000000000;;				fmt.Fprintf(g, "%g", s)
0000000000000000000000000000000000000000;;			case *float64:
0000000000000000000000000000000000000000;;				fmt.Fprintf(g, "%g", *s)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				g.Fail(fmt.Sprintf("unknown type in printer: %T", v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.WriteByte('\n')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addInitf stores the given statement to be printed inside the file's init function.
0000000000000000000000000000000000000000;;	// The statement is given as a format specifier and arguments.
0000000000000000000000000000000000000000;;	func (g *Generator) addInitf(stmt string, a ...interface{}) {
0000000000000000000000000000000000000000;;		g.init = append(g.init, fmt.Sprintf(stmt, a...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) PrintImport(alias, pkg string) {
0000000000000000000000000000000000000000;;		statement := "import " + alias + " " + strconv.Quote(pkg)
0000000000000000000000000000000000000000;;		if g.writtenImports[statement] {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P(statement)
0000000000000000000000000000000000000000;;		g.writtenImports[statement] = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// In Indents the output one tab stop.
0000000000000000000000000000000000000000;;	func (g *Generator) In() { g.indent += "\t" }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Out unindents the output one tab stop.
0000000000000000000000000000000000000000;;	func (g *Generator) Out() {
0000000000000000000000000000000000000000;;		if len(g.indent) > 0 {
0000000000000000000000000000000000000000;;			g.indent = g.indent[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GenerateAllFiles generates the output for all the files we're outputting.
0000000000000000000000000000000000000000;;	func (g *Generator) GenerateAllFiles() {
0000000000000000000000000000000000000000;;		// Initialize the plugins
0000000000000000000000000000000000000000;;		for _, p := range plugins {
0000000000000000000000000000000000000000;;			p.Init(g)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Generate the output. The generator runs for every file, even the files
0000000000000000000000000000000000000000;;		// that we don't generate output for, so that we can collate the full list
0000000000000000000000000000000000000000;;		// of exported symbols to support public imports.
0000000000000000000000000000000000000000;;		genFileMap := make(map[*FileDescriptor]bool, len(g.genFiles))
0000000000000000000000000000000000000000;;		for _, file := range g.genFiles {
0000000000000000000000000000000000000000;;			genFileMap[file] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, file := range g.allFiles {
0000000000000000000000000000000000000000;;			g.Reset()
0000000000000000000000000000000000000000;;			g.writeOutput = genFileMap[file]
0000000000000000000000000000000000000000;;			g.generate(file)
0000000000000000000000000000000000000000;;			if !g.writeOutput {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
0000000000000000000000000000000000000000;;				Name:    proto.String(file.goFileName()),
0000000000000000000000000000000000000000;;				Content: proto.String(g.String()),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Run all the plugins associated with the file.
0000000000000000000000000000000000000000;;	func (g *Generator) runPlugins(file *FileDescriptor) {
0000000000000000000000000000000000000000;;		for _, p := range plugins {
0000000000000000000000000000000000000000;;			p.Generate(file)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FileOf return the FileDescriptor for this FileDescriptorProto.
0000000000000000000000000000000000000000;;	func (g *Generator) FileOf(fd *descriptor.FileDescriptorProto) *FileDescriptor {
0000000000000000000000000000000000000000;;		for _, file := range g.allFiles {
0000000000000000000000000000000000000000;;			if file.FileDescriptorProto == fd {
0000000000000000000000000000000000000000;;				return file
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Fail("could not find file in table:", fd.GetName())
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fill the response protocol buffer with the generated output for all the files we're
0000000000000000000000000000000000000000;;	// supposed to generate.
0000000000000000000000000000000000000000;;	func (g *Generator) generate(file *FileDescriptor) {
0000000000000000000000000000000000000000;;		g.customImports = make([]string, 0)
0000000000000000000000000000000000000000;;		g.file = g.FileOf(file.FileDescriptorProto)
0000000000000000000000000000000000000000;;		g.usedPackages = make(map[string]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.file.index == 0 {
0000000000000000000000000000000000000000;;			// For one file in the package, assert version compatibility.
0000000000000000000000000000000000000000;;			g.P("// This is a compile-time assertion to ensure that this generated file")
0000000000000000000000000000000000000000;;			g.P("// is compatible with the proto package it is being compiled against.")
0000000000000000000000000000000000000000;;			g.P("// A compilation error at this line likely means your copy of the")
0000000000000000000000000000000000000000;;			g.P("// proto package needs to be updated.")
0000000000000000000000000000000000000000;;			if gogoproto.ImportsGoGoProto(file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;				g.P("const _ = ", g.Pkg["proto"], ".GoGoProtoPackageIsVersion", generatedCodeVersion, " // please upgrade the proto package")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				g.P("const _ = ", g.Pkg["proto"], ".ProtoPackageIsVersion", generatedCodeVersion, " // please upgrade the proto package")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Reset on each file
0000000000000000000000000000000000000000;;		g.writtenImports = make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, td := range g.file.imp {
0000000000000000000000000000000000000000;;			g.generateImported(td)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, enum := range g.file.enum {
0000000000000000000000000000000000000000;;			g.generateEnum(enum)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, desc := range g.file.desc {
0000000000000000000000000000000000000000;;			// Don't generate virtual messages for maps.
0000000000000000000000000000000000000000;;			if desc.GetOptions().GetMapEntry() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.generateMessage(desc)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ext := range g.file.ext {
0000000000000000000000000000000000000000;;			g.generateExtension(ext)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.generateInitFunction()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the plugins before the imports so we know which imports are necessary.
0000000000000000000000000000000000000000;;		g.runPlugins(file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.generateFileDescriptor(file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate header and imports last, though they appear first in the output.
0000000000000000000000000000000000000000;;		rem := g.Buffer
0000000000000000000000000000000000000000;;		g.Buffer = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		g.generateHeader()
0000000000000000000000000000000000000000;;		g.generateImports()
0000000000000000000000000000000000000000;;		if !g.writeOutput {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Write(rem.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reformat generated code.
0000000000000000000000000000000000000000;;		fset := token.NewFileSet()
0000000000000000000000000000000000000000;;		raw := g.Bytes()
0000000000000000000000000000000000000000;;		ast, err := parser.ParseFile(fset, "", g, parser.ParseComments)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Print out the bad code with line numbers.
0000000000000000000000000000000000000000;;			// This should never happen in practice, but it can while changing generated code,
0000000000000000000000000000000000000000;;			// so consider this a debugging aid.
0000000000000000000000000000000000000000;;			var src bytes.Buffer
0000000000000000000000000000000000000000;;			s := bufio.NewScanner(bytes.NewReader(raw))
0000000000000000000000000000000000000000;;			for line := 1; s.Scan(); line++ {
0000000000000000000000000000000000000000;;				fmt.Fprintf(&src, "%5d\t%s\n", line, s.Bytes())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if serr := s.Err(); serr != nil {
0000000000000000000000000000000000000000;;				g.Fail("bad Go source code was generated:", err.Error(), "\n"+string(raw))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				g.Fail("bad Go source code was generated:", err.Error(), "\n"+src.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Reset()
0000000000000000000000000000000000000000;;		err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(g, fset, ast)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			g.Fail("generated Go source code could not be reformatted:", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate the header, including package definition
0000000000000000000000000000000000000000;;	func (g *Generator) generateHeader() {
0000000000000000000000000000000000000000;;		g.P("// Code generated by protoc-gen-gogo.")
0000000000000000000000000000000000000000;;		g.P("// source: ", *g.file.Name)
0000000000000000000000000000000000000000;;		g.P("// DO NOT EDIT!")
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name := g.file.PackageName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if g.file.index == 0 {
0000000000000000000000000000000000000000;;			// Generate package docs for the first file in the package.
0000000000000000000000000000000000000000;;			g.P("/*")
0000000000000000000000000000000000000000;;			g.P("Package ", name, " is a generated protocol buffer package.")
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;			if loc, ok := g.file.comments[strconv.Itoa(packagePath)]; ok {
0000000000000000000000000000000000000000;;				// not using g.PrintComments because this is a /* */ comment block.
0000000000000000000000000000000000000000;;				text := strings.TrimSuffix(loc.GetLeadingComments(), "\n")
0000000000000000000000000000000000000000;;				for _, line := range strings.Split(text, "\n") {
0000000000000000000000000000000000000000;;					line = strings.TrimPrefix(line, " ")
0000000000000000000000000000000000000000;;					// ensure we don't escape from the block comment
0000000000000000000000000000000000000000;;					line = strings.Replace(line, "*/", "* /", -1)
0000000000000000000000000000000000000000;;					g.P(line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var topMsgs []string
0000000000000000000000000000000000000000;;			g.P("It is generated from these files:")
0000000000000000000000000000000000000000;;			for _, f := range g.genFiles {
0000000000000000000000000000000000000000;;				g.P("\t", f.Name)
0000000000000000000000000000000000000000;;				for _, msg := range f.desc {
0000000000000000000000000000000000000000;;					if msg.parent != nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					topMsgs = append(topMsgs, CamelCaseSlice(msg.TypeName()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;			g.P("It has these top-level messages:")
0000000000000000000000000000000000000000;;			for _, msg := range topMsgs {
0000000000000000000000000000000000000000;;				g.P("\t", msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P("*/")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.P("package ", name)
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintComments prints any comments from the source .proto file.
0000000000000000000000000000000000000000;;	// The path is a comma-separated list of integers.
0000000000000000000000000000000000000000;;	// It returns an indication of whether any comments were printed.
0000000000000000000000000000000000000000;;	// See descriptor.proto for its format.
0000000000000000000000000000000000000000;;	func (g *Generator) PrintComments(path string) bool {
0000000000000000000000000000000000000000;;		if !g.writeOutput {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if loc, ok := g.file.comments[path]; ok {
0000000000000000000000000000000000000000;;			text := strings.TrimSuffix(loc.GetLeadingComments(), "\n")
0000000000000000000000000000000000000000;;			for _, line := range strings.Split(text, "\n") {
0000000000000000000000000000000000000000;;				g.P("// ", strings.TrimPrefix(line, " "))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Comments returns any comments from the source .proto file and empty string if comments not found.
0000000000000000000000000000000000000000;;	// The path is a comma-separated list of intergers.
0000000000000000000000000000000000000000;;	// See descriptor.proto for its format.
0000000000000000000000000000000000000000;;	func (g *Generator) Comments(path string) string {
0000000000000000000000000000000000000000;;		loc, ok := g.file.comments[path]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		text := strings.TrimSuffix(loc.GetLeadingComments(), "\n")
0000000000000000000000000000000000000000;;		return text
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) fileByName(filename string) *FileDescriptor {
0000000000000000000000000000000000000000;;		return g.allFilesByName[filename]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// weak returns whether the ith import of the current file is a weak import.
0000000000000000000000000000000000000000;;	func (g *Generator) weak(i int32) bool {
0000000000000000000000000000000000000000;;		for _, j := range g.file.WeakDependency {
0000000000000000000000000000000000000000;;			if j == i {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate the imports
0000000000000000000000000000000000000000;;	func (g *Generator) generateImports() {
0000000000000000000000000000000000000000;;		// We almost always need a proto import.  Rather than computing when we
0000000000000000000000000000000000000000;;		// do, which is tricky when there's a plugin, just import it and
0000000000000000000000000000000000000000;;		// reference it later. The same argument applies to the fmt and math packages.
0000000000000000000000000000000000000000;;		if gogoproto.ImportsGoGoProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;			g.PrintImport(g.Pkg["proto"], g.ImportPrefix+"github.com/gogo/protobuf/proto")
0000000000000000000000000000000000000000;;			if gogoproto.RegistersGolangProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;				g.PrintImport(g.Pkg["golang_proto"], g.ImportPrefix+"github.com/golang/protobuf/proto")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			g.PrintImport(g.Pkg["proto"], g.ImportPrefix+"github.com/golang/protobuf/proto")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.PrintImport(g.Pkg["fmt"], "fmt")
0000000000000000000000000000000000000000;;		g.PrintImport(g.Pkg["math"], "math")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, s := range g.file.Dependency {
0000000000000000000000000000000000000000;;			fd := g.fileByName(s)
0000000000000000000000000000000000000000;;			// Do not import our own package.
0000000000000000000000000000000000000000;;			if fd.PackageName() == g.packageName {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filename := fd.goFileName()
0000000000000000000000000000000000000000;;			// By default, import path is the dirname of the Go filename.
0000000000000000000000000000000000000000;;			importPath := path.Dir(filename)
0000000000000000000000000000000000000000;;			if substitution, ok := g.ImportMap[s]; ok {
0000000000000000000000000000000000000000;;				importPath = substitution
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			importPath = g.ImportPrefix + importPath
0000000000000000000000000000000000000000;;			// Skip weak imports.
0000000000000000000000000000000000000000;;			if g.weak(int32(i)) {
0000000000000000000000000000000000000000;;				g.P("// skipping weak import ", fd.PackageName(), " ", strconv.Quote(importPath))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We need to import all the dependencies, even if we don't reference them,
0000000000000000000000000000000000000000;;			// because other code and tools depend on having the full transitive closure
0000000000000000000000000000000000000000;;			// of protocol buffer types in the binary.
0000000000000000000000000000000000000000;;			if _, ok := g.usedPackages[fd.PackageName()]; ok {
0000000000000000000000000000000000000000;;				g.PrintImport(fd.PackageName(), importPath)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				g.P("import _ ", strconv.Quote(importPath))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;		for _, s := range g.customImports {
0000000000000000000000000000000000000000;;			s1 := strings.Map(badToUnderscore, s)
0000000000000000000000000000000000000000;;			g.PrintImport(s1, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;		// TODO: may need to worry about uniqueness across plugins
0000000000000000000000000000000000000000;;		for _, p := range plugins {
0000000000000000000000000000000000000000;;			p.GenerateImports(g.file)
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P("// Reference imports to suppress errors if they are not otherwise used.")
0000000000000000000000000000000000000000;;		g.P("var _ = ", g.Pkg["proto"], ".Marshal")
0000000000000000000000000000000000000000;;		if gogoproto.ImportsGoGoProto(g.file.FileDescriptorProto) && gogoproto.RegistersGolangProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;			g.P("var _ = ", g.Pkg["golang_proto"], ".Marshal")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P("var _ = ", g.Pkg["fmt"], ".Errorf")
0000000000000000000000000000000000000000;;		g.P("var _ = ", g.Pkg["math"], ".Inf")
0000000000000000000000000000000000000000;;		for _, cimport := range g.customImports {
0000000000000000000000000000000000000000;;			if cimport == "time" {
0000000000000000000000000000000000000000;;				g.P("var _ = time.Kitchen")
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) generateImported(id *ImportedDescriptor) {
0000000000000000000000000000000000000000;;		// Don't generate public import symbols for files that we are generating
0000000000000000000000000000000000000000;;		// code for, since those symbols will already be in this package.
0000000000000000000000000000000000000000;;		// We can't simply avoid creating the ImportedDescriptor objects,
0000000000000000000000000000000000000000;;		// because g.genFiles isn't populated at that stage.
0000000000000000000000000000000000000000;;		tn := id.TypeName()
0000000000000000000000000000000000000000;;		sn := tn[len(tn)-1]
0000000000000000000000000000000000000000;;		df := g.FileOf(id.o.File())
0000000000000000000000000000000000000000;;		filename := *df.Name
0000000000000000000000000000000000000000;;		for _, fd := range g.genFiles {
0000000000000000000000000000000000000000;;			if *fd.Name == filename {
0000000000000000000000000000000000000000;;				g.P("// Ignoring public import of ", sn, " from ", filename)
0000000000000000000000000000000000000000;;				g.P()
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P("// ", sn, " from public import ", filename)
0000000000000000000000000000000000000000;;		g.usedPackages[df.PackageName()] = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, sym := range df.exported[id.o] {
0000000000000000000000000000000000000000;;			sym.GenerateAlias(g, df.PackageName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate the enum definitions for this EnumDescriptor.
0000000000000000000000000000000000000000;;	func (g *Generator) generateEnum(enum *EnumDescriptor) {
0000000000000000000000000000000000000000;;		// The full type name
0000000000000000000000000000000000000000;;		typeName := enum.alias()
0000000000000000000000000000000000000000;;		// The full type name, CamelCased.
0000000000000000000000000000000000000000;;		ccTypeName := CamelCaseSlice(typeName)
0000000000000000000000000000000000000000;;		ccPrefix := enum.prefix()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.PrintComments(enum.path)
0000000000000000000000000000000000000000;;		if !gogoproto.EnabledGoEnumPrefix(enum.file, enum.EnumDescriptorProto) {
0000000000000000000000000000000000000000;;			ccPrefix = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gogoproto.HasEnumDecl(enum.file, enum.EnumDescriptorProto) {
0000000000000000000000000000000000000000;;			g.P("type ", ccTypeName, " int32")
0000000000000000000000000000000000000000;;			g.file.addExport(enum, enumSymbol{ccTypeName, enum.proto3()})
0000000000000000000000000000000000000000;;			g.P("const (")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			for i, e := range enum.Value {
0000000000000000000000000000000000000000;;				g.PrintComments(fmt.Sprintf("%s,%d,%d", enum.path, enumValuePath, i))
0000000000000000000000000000000000000000;;				name := *e.Name
0000000000000000000000000000000000000000;;				if gogoproto.IsEnumValueCustomName(e) {
0000000000000000000000000000000000000000;;					name = gogoproto.GetEnumValueCustomName(e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				name = ccPrefix + name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				g.P(name, " ", ccTypeName, " = ", e.Number)
0000000000000000000000000000000000000000;;				g.file.addExport(enum, constOrVarSymbol{name, "const", ccTypeName})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P(")")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.P("var ", ccTypeName, "_name = map[int32]string{")
0000000000000000000000000000000000000000;;		g.In()
0000000000000000000000000000000000000000;;		generated := make(map[int32]bool) // avoid duplicate values
0000000000000000000000000000000000000000;;		for _, e := range enum.Value {
0000000000000000000000000000000000000000;;			duplicate := ""
0000000000000000000000000000000000000000;;			if _, present := generated[*e.Number]; present {
0000000000000000000000000000000000000000;;				duplicate = "// Duplicate value: "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P(duplicate, e.Number, ": ", strconv.Quote(*e.Name), ",")
0000000000000000000000000000000000000000;;			generated[*e.Number] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Out()
0000000000000000000000000000000000000000;;		g.P("}")
0000000000000000000000000000000000000000;;		g.P("var ", ccTypeName, "_value = map[string]int32{")
0000000000000000000000000000000000000000;;		g.In()
0000000000000000000000000000000000000000;;		for _, e := range enum.Value {
0000000000000000000000000000000000000000;;			g.P(strconv.Quote(*e.Name), ": ", e.Number, ",")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Out()
0000000000000000000000000000000000000000;;		g.P("}")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !enum.proto3() {
0000000000000000000000000000000000000000;;			g.P("func (x ", ccTypeName, ") Enum() *", ccTypeName, " {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			g.P("p := new(", ccTypeName, ")")
0000000000000000000000000000000000000000;;			g.P("*p = x")
0000000000000000000000000000000000000000;;			g.P("return p")
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gogoproto.IsGoEnumStringer(g.file.FileDescriptorProto, enum.EnumDescriptorProto) {
0000000000000000000000000000000000000000;;			g.P("func (x ", ccTypeName, ") String() string {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			g.P("return ", g.Pkg["proto"], ".EnumName(", ccTypeName, "_name, int32(x))")
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !enum.proto3() && !gogoproto.IsGoEnumStringer(g.file.FileDescriptorProto, enum.EnumDescriptorProto) {
0000000000000000000000000000000000000000;;			g.P("func (x ", ccTypeName, ") MarshalJSON() ([]byte, error) {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			g.P("return ", g.Pkg["proto"], ".MarshalJSONEnum(", ccTypeName, "_name, int32(x))")
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !enum.proto3() {
0000000000000000000000000000000000000000;;			g.P("func (x *", ccTypeName, ") UnmarshalJSON(data []byte) error {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			g.P("value, err := ", g.Pkg["proto"], ".UnmarshalJSONEnum(", ccTypeName, `_value, data, "`, ccTypeName, `")`)
0000000000000000000000000000000000000000;;			g.P("if err != nil {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			g.P("return err")
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P("*x = ", ccTypeName, "(value)")
0000000000000000000000000000000000000000;;			g.P("return nil")
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var indexes []string
0000000000000000000000000000000000000000;;		for m := enum.parent; m != nil; m = m.parent {
0000000000000000000000000000000000000000;;			// XXX: skip groups?
0000000000000000000000000000000000000000;;			indexes = append([]string{strconv.Itoa(m.index)}, indexes...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		indexes = append(indexes, strconv.Itoa(enum.index))
0000000000000000000000000000000000000000;;		g.P("func (", ccTypeName, ") EnumDescriptor() ([]byte, []int) { return ", g.file.VarName(), ", []int{", strings.Join(indexes, ", "), "} }")
0000000000000000000000000000000000000000;;		if enum.file.GetPackage() == "google.protobuf" && enum.GetName() == "NullValue" {
0000000000000000000000000000000000000000;;			g.P("func (", ccTypeName, `) XXX_WellKnownType() string { return "`, enum.GetName(), `" }`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The tag is a string like "varint,2,opt,name=fieldname,def=7" that
0000000000000000000000000000000000000000;;	// identifies details of the field for the protocol buffer marshaling and unmarshaling
0000000000000000000000000000000000000000;;	// code.  The fields are:
0000000000000000000000000000000000000000;;	//	wire encoding
0000000000000000000000000000000000000000;;	//	protocol tag number
0000000000000000000000000000000000000000;;	//	opt,req,rep for optional, required, or repeated
0000000000000000000000000000000000000000;;	//	packed whether the encoding is "packed" (optional; repeated primitives only)
0000000000000000000000000000000000000000;;	//	name= the original declared name
0000000000000000000000000000000000000000;;	//	enum= the name of the enum type if it is an enum-typed field.
0000000000000000000000000000000000000000;;	//	proto3 if this field is in a proto3 message
0000000000000000000000000000000000000000;;	//	def= string representation of the default value, if any.
0000000000000000000000000000000000000000;;	// The default value must be in a representation that can be used at run-time
0000000000000000000000000000000000000000;;	// to generate the default value. Thus bools become 0 and 1, for instance.
0000000000000000000000000000000000000000;;	func (g *Generator) goTag(message *Descriptor, field *descriptor.FieldDescriptorProto, wiretype string) string {
0000000000000000000000000000000000000000;;		optrepreq := ""
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isOptional(field):
0000000000000000000000000000000000000000;;			optrepreq = "opt"
0000000000000000000000000000000000000000;;		case isRequired(field):
0000000000000000000000000000000000000000;;			optrepreq = "req"
0000000000000000000000000000000000000000;;		case isRepeated(field):
0000000000000000000000000000000000000000;;			optrepreq = "rep"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var defaultValue string
0000000000000000000000000000000000000000;;		if dv := field.DefaultValue; dv != nil { // set means an explicit default
0000000000000000000000000000000000000000;;			defaultValue = *dv
0000000000000000000000000000000000000000;;			// Some types need tweaking.
0000000000000000000000000000000000000000;;			switch *field.Type {
0000000000000000000000000000000000000000;;			case descriptor.FieldDescriptorProto_TYPE_BOOL:
0000000000000000000000000000000000000000;;				if defaultValue == "true" {
0000000000000000000000000000000000000000;;					defaultValue = "1"
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					defaultValue = "0"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case descriptor.FieldDescriptorProto_TYPE_STRING,
0000000000000000000000000000000000000000;;				descriptor.FieldDescriptorProto_TYPE_BYTES:
0000000000000000000000000000000000000000;;				// Nothing to do. Quoting is done for the whole tag.
0000000000000000000000000000000000000000;;			case descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;				// For enums we need to provide the integer constant.
0000000000000000000000000000000000000000;;				obj := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;				if id, ok := obj.(*ImportedDescriptor); ok {
0000000000000000000000000000000000000000;;					// It is an enum that was publicly imported.
0000000000000000000000000000000000000000;;					// We need the underlying type.
0000000000000000000000000000000000000000;;					obj = id.o
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				enum, ok := obj.(*EnumDescriptor)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					log.Printf("obj is a %T", obj)
0000000000000000000000000000000000000000;;					if id, ok := obj.(*ImportedDescriptor); ok {
0000000000000000000000000000000000000000;;						log.Printf("id.o is a %T", id.o)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					g.Fail("unknown enum type", CamelCaseSlice(obj.TypeName()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defaultValue = enum.integerValueAsString(defaultValue)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defaultValue = ",def=" + defaultValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enum := ""
0000000000000000000000000000000000000000;;		if *field.Type == descriptor.FieldDescriptorProto_TYPE_ENUM {
0000000000000000000000000000000000000000;;			// We avoid using obj.PackageName(), because we want to use the
0000000000000000000000000000000000000000;;			// original (proto-world) package name.
0000000000000000000000000000000000000000;;			obj := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;			if id, ok := obj.(*ImportedDescriptor); ok {
0000000000000000000000000000000000000000;;				obj = id.o
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enum = ",enum="
0000000000000000000000000000000000000000;;			if pkg := obj.File().GetPackage(); pkg != "" {
0000000000000000000000000000000000000000;;				enum += pkg + "."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			enum += CamelCaseSlice(obj.TypeName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		packed := ""
0000000000000000000000000000000000000000;;		if (field.Options != nil && field.Options.GetPacked()) ||
0000000000000000000000000000000000000000;;			// Per https://developers.google.com/protocol-buffers/docs/proto3#simple:
0000000000000000000000000000000000000000;;			// "In proto3, repeated fields of scalar numeric types use packed encoding by default."
0000000000000000000000000000000000000000;;			(message.proto3() && (field.Options == nil || field.Options.Packed == nil) &&
0000000000000000000000000000000000000000;;				isRepeated(field) && IsScalar(field)) {
0000000000000000000000000000000000000000;;			packed = ",packed"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fieldName := field.GetName()
0000000000000000000000000000000000000000;;		name := fieldName
0000000000000000000000000000000000000000;;		if *field.Type == descriptor.FieldDescriptorProto_TYPE_GROUP {
0000000000000000000000000000000000000000;;			// We must use the type name for groups instead of
0000000000000000000000000000000000000000;;			// the field name to preserve capitalization.
0000000000000000000000000000000000000000;;			// type_name in FieldDescriptorProto is fully-qualified,
0000000000000000000000000000000000000000;;			// but we only want the local part.
0000000000000000000000000000000000000000;;			name = *field.TypeName
0000000000000000000000000000000000000000;;			if i := strings.LastIndex(name, "."); i >= 0 {
0000000000000000000000000000000000000000;;				name = name[i+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if json := field.GetJsonName(); json != "" && json != name {
0000000000000000000000000000000000000000;;			// TODO: escaping might be needed, in which case
0000000000000000000000000000000000000000;;			// perhaps this should be in its own "json" tag.
0000000000000000000000000000000000000000;;			name += ",json=" + json
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name = ",name=" + name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		embed := ""
0000000000000000000000000000000000000000;;		if gogoproto.IsEmbed(field) {
0000000000000000000000000000000000000000;;			embed = ",embedded=" + fieldName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctype := ""
0000000000000000000000000000000000000000;;		if gogoproto.IsCustomType(field) {
0000000000000000000000000000000000000000;;			ctype = ",customtype=" + gogoproto.GetCustomType(field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		casttype := ""
0000000000000000000000000000000000000000;;		if gogoproto.IsCastType(field) {
0000000000000000000000000000000000000000;;			casttype = ",casttype=" + gogoproto.GetCastType(field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		castkey := ""
0000000000000000000000000000000000000000;;		if gogoproto.IsCastKey(field) {
0000000000000000000000000000000000000000;;			castkey = ",castkey=" + gogoproto.GetCastKey(field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		castvalue := ""
0000000000000000000000000000000000000000;;		if gogoproto.IsCastValue(field) {
0000000000000000000000000000000000000000;;			castvalue = ",castvalue=" + gogoproto.GetCastValue(field)
0000000000000000000000000000000000000000;;			// record the original message type for jsonpb reconstruction
0000000000000000000000000000000000000000;;			desc := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;			if d, ok := desc.(*Descriptor); ok && d.GetOptions().GetMapEntry() {
0000000000000000000000000000000000000000;;				valueField := d.Field[1]
0000000000000000000000000000000000000000;;				if valueField.IsMessage() {
0000000000000000000000000000000000000000;;					castvalue += ",castvaluetype=" + strings.TrimPrefix(valueField.GetTypeName(), ".")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if message.proto3() {
0000000000000000000000000000000000000000;;			// We only need the extra tag for []byte fields;
0000000000000000000000000000000000000000;;			// no need to add noise for the others.
0000000000000000000000000000000000000000;;			if *field.Type != descriptor.FieldDescriptorProto_TYPE_MESSAGE &&
0000000000000000000000000000000000000000;;				*field.Type != descriptor.FieldDescriptorProto_TYPE_GROUP &&
0000000000000000000000000000000000000000;;				!field.IsRepeated() {
0000000000000000000000000000000000000000;;				name += ",proto3"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oneof := ""
0000000000000000000000000000000000000000;;		if field.OneofIndex != nil {
0000000000000000000000000000000000000000;;			oneof = ",oneof"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stdtime := ""
0000000000000000000000000000000000000000;;		if gogoproto.IsStdTime(field) {
0000000000000000000000000000000000000000;;			stdtime = ",stdtime"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stdduration := ""
0000000000000000000000000000000000000000;;		if gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;			stdduration = ",stdduration"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strconv.Quote(fmt.Sprintf("%s,%d,%s%s%s%s%s%s%s%s%s%s%s%s%s",
0000000000000000000000000000000000000000;;			wiretype,
0000000000000000000000000000000000000000;;			field.GetNumber(),
0000000000000000000000000000000000000000;;			optrepreq,
0000000000000000000000000000000000000000;;			packed,
0000000000000000000000000000000000000000;;			name,
0000000000000000000000000000000000000000;;			enum,
0000000000000000000000000000000000000000;;			oneof,
0000000000000000000000000000000000000000;;			defaultValue,
0000000000000000000000000000000000000000;;			embed,
0000000000000000000000000000000000000000;;			ctype,
0000000000000000000000000000000000000000;;			casttype,
0000000000000000000000000000000000000000;;			castkey,
0000000000000000000000000000000000000000;;			castvalue,
0000000000000000000000000000000000000000;;			stdtime,
0000000000000000000000000000000000000000;;			stdduration))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func needsStar(field *descriptor.FieldDescriptorProto, proto3 bool, allowOneOf bool) bool {
0000000000000000000000000000000000000000;;		if isRepeated(field) &&
0000000000000000000000000000000000000000;;			(*field.Type != descriptor.FieldDescriptorProto_TYPE_MESSAGE || gogoproto.IsCustomType(field)) &&
0000000000000000000000000000000000000000;;			(*field.Type != descriptor.FieldDescriptorProto_TYPE_GROUP) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if *field.Type == descriptor.FieldDescriptorProto_TYPE_BYTES && !gogoproto.IsCustomType(field) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !gogoproto.IsNullable(field) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if field.OneofIndex != nil && allowOneOf &&
0000000000000000000000000000000000000000;;			(*field.Type != descriptor.FieldDescriptorProto_TYPE_MESSAGE) &&
0000000000000000000000000000000000000000;;			(*field.Type != descriptor.FieldDescriptorProto_TYPE_GROUP) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if proto3 &&
0000000000000000000000000000000000000000;;			(*field.Type != descriptor.FieldDescriptorProto_TYPE_MESSAGE) &&
0000000000000000000000000000000000000000;;			(*field.Type != descriptor.FieldDescriptorProto_TYPE_GROUP) &&
0000000000000000000000000000000000000000;;			!gogoproto.IsCustomType(field) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeName is the printed name appropriate for an item. If the object is in the current file,
0000000000000000000000000000000000000000;;	// TypeName drops the package name and underscores the rest.
0000000000000000000000000000000000000000;;	// Otherwise the object is from another package; and the result is the underscored
0000000000000000000000000000000000000000;;	// package name followed by the item name.
0000000000000000000000000000000000000000;;	// The result always has an initial capital.
0000000000000000000000000000000000000000;;	func (g *Generator) TypeName(obj Object) string {
0000000000000000000000000000000000000000;;		return g.DefaultPackageName(obj) + CamelCaseSlice(obj.TypeName())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TypeNameWithPackage is like TypeName, but always includes the package
0000000000000000000000000000000000000000;;	// name even if the object is in our own package.
0000000000000000000000000000000000000000;;	func (g *Generator) TypeNameWithPackage(obj Object) string {
0000000000000000000000000000000000000000;;		return obj.PackageName() + CamelCaseSlice(obj.TypeName())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoType returns a string representing the type name, and the wire type
0000000000000000000000000000000000000000;;	func (g *Generator) GoType(message *Descriptor, field *descriptor.FieldDescriptorProto) (typ string, wire string) {
0000000000000000000000000000000000000000;;		// TODO: Options.
0000000000000000000000000000000000000000;;		switch *field.Type {
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
0000000000000000000000000000000000000000;;			typ, wire = "float64", "fixed64"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_FLOAT:
0000000000000000000000000000000000000000;;			typ, wire = "float32", "fixed32"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_INT64:
0000000000000000000000000000000000000000;;			typ, wire = "int64", "varint"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_UINT64:
0000000000000000000000000000000000000000;;			typ, wire = "uint64", "varint"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_INT32:
0000000000000000000000000000000000000000;;			typ, wire = "int32", "varint"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_UINT32:
0000000000000000000000000000000000000000;;			typ, wire = "uint32", "varint"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_FIXED64:
0000000000000000000000000000000000000000;;			typ, wire = "uint64", "fixed64"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_FIXED32:
0000000000000000000000000000000000000000;;			typ, wire = "uint32", "fixed32"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_BOOL:
0000000000000000000000000000000000000000;;			typ, wire = "bool", "varint"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_STRING:
0000000000000000000000000000000000000000;;			typ, wire = "string", "bytes"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_GROUP:
0000000000000000000000000000000000000000;;			desc := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;			typ, wire = g.TypeName(desc), "group"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;			desc := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;			typ, wire = g.TypeName(desc), "bytes"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_BYTES:
0000000000000000000000000000000000000000;;			typ, wire = "[]byte", "bytes"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;			desc := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;			typ, wire = g.TypeName(desc), "varint"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
0000000000000000000000000000000000000000;;			typ, wire = "int32", "fixed32"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
0000000000000000000000000000000000000000;;			typ, wire = "int64", "fixed64"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_SINT32:
0000000000000000000000000000000000000000;;			typ, wire = "int32", "zigzag32"
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_SINT64:
0000000000000000000000000000000000000000;;			typ, wire = "int64", "zigzag64"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			g.Fail("unknown type for", field.GetName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case gogoproto.IsCustomType(field) && gogoproto.IsCastType(field):
0000000000000000000000000000000000000000;;			g.Fail(field.GetName() + " cannot be custom type and cast type")
0000000000000000000000000000000000000000;;		case gogoproto.IsCustomType(field):
0000000000000000000000000000000000000000;;			var packageName string
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			packageName, typ, err = getCustomType(field)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				g.Fail(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(packageName) > 0 {
0000000000000000000000000000000000000000;;				g.customImports = append(g.customImports, packageName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case gogoproto.IsCastType(field):
0000000000000000000000000000000000000000;;			var packageName string
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			packageName, typ, err = getCastType(field)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				g.Fail(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(packageName) > 0 {
0000000000000000000000000000000000000000;;				g.customImports = append(g.customImports, packageName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case gogoproto.IsStdTime(field):
0000000000000000000000000000000000000000;;			g.customImports = append(g.customImports, "time")
0000000000000000000000000000000000000000;;			typ = "time.Time"
0000000000000000000000000000000000000000;;		case gogoproto.IsStdDuration(field):
0000000000000000000000000000000000000000;;			g.customImports = append(g.customImports, "time")
0000000000000000000000000000000000000000;;			typ = "time.Duration"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if needsStar(field, g.file.proto3 && field.Extendee == nil, message != nil && message.allowOneof()) {
0000000000000000000000000000000000000000;;			typ = "*" + typ
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if isRepeated(field) {
0000000000000000000000000000000000000000;;			typ = "[]" + typ
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoMapDescriptor is a full description of the map output struct.
0000000000000000000000000000000000000000;;	type GoMapDescriptor struct {
0000000000000000000000000000000000000000;;		GoType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		KeyField      *descriptor.FieldDescriptorProto
0000000000000000000000000000000000000000;;		KeyAliasField *descriptor.FieldDescriptorProto
0000000000000000000000000000000000000000;;		KeyTag        string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ValueField      *descriptor.FieldDescriptorProto
0000000000000000000000000000000000000000;;		ValueAliasField *descriptor.FieldDescriptorProto
0000000000000000000000000000000000000000;;		ValueTag        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) GoMapType(d *Descriptor, field *descriptor.FieldDescriptorProto) *GoMapDescriptor {
0000000000000000000000000000000000000000;;		if d == nil {
0000000000000000000000000000000000000000;;			byName := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;			desc, ok := byName.(*Descriptor)
0000000000000000000000000000000000000000;;			if byName == nil || !ok || !desc.GetOptions().GetMapEntry() {
0000000000000000000000000000000000000000;;				g.Fail(fmt.Sprintf("field %s is not a map", field.GetTypeName()))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d = desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := &GoMapDescriptor{
0000000000000000000000000000000000000000;;			KeyField:   d.Field[0],
0000000000000000000000000000000000000000;;			ValueField: d.Field[1],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Figure out the Go types and tags for the key and value types.
0000000000000000000000000000000000000000;;		m.KeyAliasField, m.ValueAliasField = g.GetMapKeyField(field, m.KeyField), g.GetMapValueField(field, m.ValueField)
0000000000000000000000000000000000000000;;		keyType, keyWire := g.GoType(d, m.KeyAliasField)
0000000000000000000000000000000000000000;;		valType, valWire := g.GoType(d, m.ValueAliasField)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.KeyTag, m.ValueTag = g.goTag(d, m.KeyField, keyWire), g.goTag(d, m.ValueField, valWire)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gogoproto.IsCastType(field) {
0000000000000000000000000000000000000000;;			var packageName string
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			packageName, typ, err := getCastType(field)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				g.Fail(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(packageName) > 0 {
0000000000000000000000000000000000000000;;				g.customImports = append(g.customImports, packageName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m.GoType = typ
0000000000000000000000000000000000000000;;			return m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We don't use stars, except for message-typed values.
0000000000000000000000000000000000000000;;		// Message and enum types are the only two possibly foreign types used in maps,
0000000000000000000000000000000000000000;;		// so record their use. They are not permitted as map keys.
0000000000000000000000000000000000000000;;		keyType = strings.TrimPrefix(keyType, "*")
0000000000000000000000000000000000000000;;		switch *m.ValueAliasField.Type {
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;			valType = strings.TrimPrefix(valType, "*")
0000000000000000000000000000000000000000;;			g.RecordTypeUse(m.ValueAliasField.GetTypeName())
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;			if !gogoproto.IsNullable(m.ValueAliasField) {
0000000000000000000000000000000000000000;;				valType = strings.TrimPrefix(valType, "*")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !gogoproto.IsStdTime(field) && !gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;				g.RecordTypeUse(m.ValueAliasField.GetTypeName())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if gogoproto.IsCustomType(m.ValueAliasField) {
0000000000000000000000000000000000000000;;				if !gogoproto.IsNullable(m.ValueAliasField) {
0000000000000000000000000000000000000000;;					valType = strings.TrimPrefix(valType, "*")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.RecordTypeUse(m.ValueAliasField.GetTypeName())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				valType = strings.TrimPrefix(valType, "*")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.GoType = fmt.Sprintf("map[%s]%s", keyType, valType)
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) RecordTypeUse(t string) {
0000000000000000000000000000000000000000;;		if obj, ok := g.typeNameToObject[t]; ok {
0000000000000000000000000000000000000000;;			// Call ObjectNamed to get the true object to record the use.
0000000000000000000000000000000000000000;;			obj = g.ObjectNamed(t)
0000000000000000000000000000000000000000;;			g.usedPackages[obj.PackageName()] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Method names that may be generated.  Fields with these names get an
0000000000000000000000000000000000000000;;	// underscore appended. Any change to this set is a potential incompatible
0000000000000000000000000000000000000000;;	// API change because it changes generated field names.
0000000000000000000000000000000000000000;;	var methodNames = [...]string{
0000000000000000000000000000000000000000;;		"Reset",
0000000000000000000000000000000000000000;;		"String",
0000000000000000000000000000000000000000;;		"ProtoMessage",
0000000000000000000000000000000000000000;;		"Marshal",
0000000000000000000000000000000000000000;;		"Unmarshal",
0000000000000000000000000000000000000000;;		"ExtensionRangeArray",
0000000000000000000000000000000000000000;;		"ExtensionMap",
0000000000000000000000000000000000000000;;		"Descriptor",
0000000000000000000000000000000000000000;;		"MarshalTo",
0000000000000000000000000000000000000000;;		"Equal",
0000000000000000000000000000000000000000;;		"VerboseEqual",
0000000000000000000000000000000000000000;;		"GoString",
0000000000000000000000000000000000000000;;		"ProtoSize",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Names of messages in the `google.protobuf` package for which
0000000000000000000000000000000000000000;;	// we will generate XXX_WellKnownType methods.
0000000000000000000000000000000000000000;;	var wellKnownTypes = map[string]bool{
0000000000000000000000000000000000000000;;		"Any":       true,
0000000000000000000000000000000000000000;;		"Duration":  true,
0000000000000000000000000000000000000000;;		"Empty":     true,
0000000000000000000000000000000000000000;;		"Struct":    true,
0000000000000000000000000000000000000000;;		"Timestamp": true,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"Value":       true,
0000000000000000000000000000000000000000;;		"ListValue":   true,
0000000000000000000000000000000000000000;;		"DoubleValue": true,
0000000000000000000000000000000000000000;;		"FloatValue":  true,
0000000000000000000000000000000000000000;;		"Int64Value":  true,
0000000000000000000000000000000000000000;;		"UInt64Value": true,
0000000000000000000000000000000000000000;;		"Int32Value":  true,
0000000000000000000000000000000000000000;;		"UInt32Value": true,
0000000000000000000000000000000000000000;;		"BoolValue":   true,
0000000000000000000000000000000000000000;;		"StringValue": true,
0000000000000000000000000000000000000000;;		"BytesValue":  true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate the type and default constant definitions for this Descriptor.
0000000000000000000000000000000000000000;;	func (g *Generator) generateMessage(message *Descriptor) {
0000000000000000000000000000000000000000;;		// The full type name
0000000000000000000000000000000000000000;;		typeName := message.TypeName()
0000000000000000000000000000000000000000;;		// The full type name, CamelCased.
0000000000000000000000000000000000000000;;		ccTypeName := CamelCaseSlice(typeName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usedNames := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, n := range methodNames {
0000000000000000000000000000000000000000;;			usedNames[n] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !gogoproto.IsProtoSizer(message.file, message.DescriptorProto) {
0000000000000000000000000000000000000000;;			usedNames["Size"] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fieldNames := make(map[*descriptor.FieldDescriptorProto]string)
0000000000000000000000000000000000000000;;		fieldGetterNames := make(map[*descriptor.FieldDescriptorProto]string)
0000000000000000000000000000000000000000;;		fieldTypes := make(map[*descriptor.FieldDescriptorProto]string)
0000000000000000000000000000000000000000;;		mapFieldTypes := make(map[*descriptor.FieldDescriptorProto]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oneofFieldName := make(map[int32]string)                           // indexed by oneof_index field of FieldDescriptorProto
0000000000000000000000000000000000000000;;		oneofDisc := make(map[int32]string)                                // name of discriminator method
0000000000000000000000000000000000000000;;		oneofTypeName := make(map[*descriptor.FieldDescriptorProto]string) // without star
0000000000000000000000000000000000000000;;		oneofInsertPoints := make(map[int32]int)                           // oneof_index => offset of g.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// allocNames finds a conflict-free variation of the given strings,
0000000000000000000000000000000000000000;;		// consistently mutating their suffixes.
0000000000000000000000000000000000000000;;		// It returns the same number of strings.
0000000000000000000000000000000000000000;;		allocNames := func(ns ...string) []string {
0000000000000000000000000000000000000000;;		Loop:
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				for _, n := range ns {
0000000000000000000000000000000000000000;;					if usedNames[n] {
0000000000000000000000000000000000000000;;						for i := range ns {
0000000000000000000000000000000000000000;;							ns[i] += "_"
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue Loop
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, n := range ns {
0000000000000000000000000000000000000000;;					usedNames[n] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return ns
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, field := range message.Field {
0000000000000000000000000000000000000000;;			// Allocate the getter and the field at the same time so name
0000000000000000000000000000000000000000;;			// collisions create field/method consistent names.
0000000000000000000000000000000000000000;;			// TODO: This allocation occurs based on the order of the fields
0000000000000000000000000000000000000000;;			// in the proto file, meaning that a change in the field
0000000000000000000000000000000000000000;;			// ordering can change generated Method/Field names.
0000000000000000000000000000000000000000;;			base := CamelCase(*field.Name)
0000000000000000000000000000000000000000;;			if gogoproto.IsCustomName(field) {
0000000000000000000000000000000000000000;;				base = gogoproto.GetCustomName(field)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ns := allocNames(base, "Get"+base)
0000000000000000000000000000000000000000;;			fieldName, fieldGetterName := ns[0], ns[1]
0000000000000000000000000000000000000000;;			fieldNames[field] = fieldName
0000000000000000000000000000000000000000;;			fieldGetterNames[field] = fieldGetterName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if gogoproto.HasTypeDecl(message.file, message.DescriptorProto) {
0000000000000000000000000000000000000000;;			g.PrintComments(message.path)
0000000000000000000000000000000000000000;;			g.P("type ", ccTypeName, " struct {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i, field := range message.Field {
0000000000000000000000000000000000000000;;				fieldName := fieldNames[field]
0000000000000000000000000000000000000000;;				typename, wiretype := g.GoType(message, field)
0000000000000000000000000000000000000000;;				jsonName := *field.Name
0000000000000000000000000000000000000000;;				jsonTag := jsonName + ",omitempty"
0000000000000000000000000000000000000000;;				repeatedNativeType := (!field.IsMessage() && !gogoproto.IsCustomType(field) && field.IsRepeated())
0000000000000000000000000000000000000000;;				if !gogoproto.IsNullable(field) && !repeatedNativeType {
0000000000000000000000000000000000000000;;					jsonTag = jsonName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gogoJsonTag := gogoproto.GetJsonTag(field)
0000000000000000000000000000000000000000;;				if gogoJsonTag != nil {
0000000000000000000000000000000000000000;;					jsonTag = *gogoJsonTag
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				gogoMoreTags := gogoproto.GetMoreTags(field)
0000000000000000000000000000000000000000;;				moreTags := ""
0000000000000000000000000000000000000000;;				if gogoMoreTags != nil {
0000000000000000000000000000000000000000;;					moreTags = " " + *gogoMoreTags
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				tag := fmt.Sprintf("protobuf:%s json:%q%s", g.goTag(message, field, wiretype), jsonTag, moreTags)
0000000000000000000000000000000000000000;;				if *field.Type == descriptor.FieldDescriptorProto_TYPE_MESSAGE && gogoproto.IsEmbed(field) {
0000000000000000000000000000000000000000;;					fieldName = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				oneof := field.OneofIndex != nil && message.allowOneof()
0000000000000000000000000000000000000000;;				if oneof && oneofFieldName[*field.OneofIndex] == "" {
0000000000000000000000000000000000000000;;					odp := message.OneofDecl[int(*field.OneofIndex)]
0000000000000000000000000000000000000000;;					fname := allocNames(CamelCase(odp.GetName()))[0]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// This is the first field of a oneof we haven't seen before.
0000000000000000000000000000000000000000;;					// Generate the union field.
0000000000000000000000000000000000000000;;					com := g.PrintComments(fmt.Sprintf("%s,%d,%d", message.path, messageOneofPath, *field.OneofIndex))
0000000000000000000000000000000000000000;;					if com {
0000000000000000000000000000000000000000;;						g.P("//")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					g.P("// Types that are valid to be assigned to ", fname, ":")
0000000000000000000000000000000000000000;;					// Generate the rest of this comment later,
0000000000000000000000000000000000000000;;					// when we've computed any disambiguation.
0000000000000000000000000000000000000000;;					oneofInsertPoints[*field.OneofIndex] = g.Buffer.Len()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					dname := "is" + ccTypeName + "_" + fname
0000000000000000000000000000000000000000;;					oneofFieldName[*field.OneofIndex] = fname
0000000000000000000000000000000000000000;;					oneofDisc[*field.OneofIndex] = dname
0000000000000000000000000000000000000000;;					otag := `protobuf_oneof:"` + odp.GetName() + `"`
0000000000000000000000000000000000000000;;					g.P(fname, " ", dname, " `", otag, "`")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if *field.Type == descriptor.FieldDescriptorProto_TYPE_MESSAGE {
0000000000000000000000000000000000000000;;					desc := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;					if d, ok := desc.(*Descriptor); ok && d.GetOptions().GetMapEntry() {
0000000000000000000000000000000000000000;;						m := g.GoMapType(d, field)
0000000000000000000000000000000000000000;;						typename = m.GoType
0000000000000000000000000000000000000000;;						mapFieldTypes[field] = typename // record for the getter generation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						tag += fmt.Sprintf(" protobuf_key:%s protobuf_val:%s", m.KeyTag, m.ValueTag)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				fieldTypes[field] = typename
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if oneof {
0000000000000000000000000000000000000000;;					tname := ccTypeName + "_" + fieldName
0000000000000000000000000000000000000000;;					// It is possible for this to collide with a message or enum
0000000000000000000000000000000000000000;;					// nested in this message. Check for collisions.
0000000000000000000000000000000000000000;;					for {
0000000000000000000000000000000000000000;;						ok := true
0000000000000000000000000000000000000000;;						for _, desc := range message.nested {
0000000000000000000000000000000000000000;;							if CamelCaseSlice(desc.TypeName()) == tname {
0000000000000000000000000000000000000000;;								ok = false
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for _, enum := range message.enums {
0000000000000000000000000000000000000000;;							if CamelCaseSlice(enum.TypeName()) == tname {
0000000000000000000000000000000000000000;;								ok = false
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if !ok {
0000000000000000000000000000000000000000;;							tname += "_"
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					oneofTypeName[field] = tname
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				g.PrintComments(fmt.Sprintf("%s,%d,%d", message.path, messageFieldPath, i))
0000000000000000000000000000000000000000;;				g.P(fieldName, "\t", typename, "\t`", tag, "`")
0000000000000000000000000000000000000000;;				if !gogoproto.IsStdTime(field) && !gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;					g.RecordTypeUse(field.GetTypeName())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(message.ExtensionRange) > 0 {
0000000000000000000000000000000000000000;;				if gogoproto.HasExtensionsMap(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;					g.P(g.Pkg["proto"], ".XXX_InternalExtensions `json:\"-\"`")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					g.P("XXX_extensions\t\t[]byte `protobuf:\"bytes,0,opt\" json:\"-\"`")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gogoproto.HasUnrecognized(g.file.FileDescriptorProto, message.DescriptorProto) && !message.proto3() {
0000000000000000000000000000000000000000;;				g.P("XXX_unrecognized\t[]byte `json:\"-\"`")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update g.Buffer to list valid oneof types.
0000000000000000000000000000000000000000;;		// We do this down here, after we've disambiguated the oneof type names.
0000000000000000000000000000000000000000;;		// We go in reverse order of insertion point to avoid invalidating offsets.
0000000000000000000000000000000000000000;;		for oi := int32(len(message.OneofDecl)); oi >= 0; oi-- {
0000000000000000000000000000000000000000;;			ip := oneofInsertPoints[oi]
0000000000000000000000000000000000000000;;			all := g.Buffer.Bytes()
0000000000000000000000000000000000000000;;			rem := all[ip:]
0000000000000000000000000000000000000000;;			g.Buffer = bytes.NewBuffer(all[:ip:ip]) // set cap so we don't scribble on rem
0000000000000000000000000000000000000000;;			for _, field := range message.Field {
0000000000000000000000000000000000000000;;				if field.OneofIndex == nil || *field.OneofIndex != oi {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P("//\t*", oneofTypeName[field])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Buffer.Write(rem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reset, String and ProtoMessage methods.
0000000000000000000000000000000000000000;;		g.P("func (m *", ccTypeName, ") Reset() { *m = ", ccTypeName, "{} }")
0000000000000000000000000000000000000000;;		if gogoproto.EnabledGoStringer(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;			g.P("func (m *", ccTypeName, ") String() string { return ", g.Pkg["proto"], ".CompactTextString(m) }")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P("func (*", ccTypeName, ") ProtoMessage() {}")
0000000000000000000000000000000000000000;;		var indexes []string
0000000000000000000000000000000000000000;;		for m := message; m != nil; m = m.parent {
0000000000000000000000000000000000000000;;			indexes = append([]string{strconv.Itoa(m.index)}, indexes...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P("func (*", ccTypeName, ") Descriptor() ([]byte, []int) { return ", g.file.VarName(), ", []int{", strings.Join(indexes, ", "), "} }")
0000000000000000000000000000000000000000;;		// TODO: Revisit the decision to use a XXX_WellKnownType method
0000000000000000000000000000000000000000;;		// if we change proto.MessageName to work with multiple equivalents.
0000000000000000000000000000000000000000;;		if message.file.GetPackage() == "google.protobuf" && wellKnownTypes[message.GetName()] {
0000000000000000000000000000000000000000;;			g.P("func (*", ccTypeName, `) XXX_WellKnownType() string { return "`, message.GetName(), `" }`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Extension support methods
0000000000000000000000000000000000000000;;		var hasExtensions, isMessageSet bool
0000000000000000000000000000000000000000;;		if len(message.ExtensionRange) > 0 {
0000000000000000000000000000000000000000;;			hasExtensions = true
0000000000000000000000000000000000000000;;			// message_set_wire_format only makes sense when extensions are defined.
0000000000000000000000000000000000000000;;			if opts := message.Options; opts != nil && opts.GetMessageSetWireFormat() {
0000000000000000000000000000000000000000;;				isMessageSet = true
0000000000000000000000000000000000000000;;				g.P()
0000000000000000000000000000000000000000;;				g.P("func (m *", ccTypeName, ") Marshal() ([]byte, error) {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("return ", g.Pkg["proto"], ".MarshalMessageSet(&m.XXX_InternalExtensions)")
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				g.P("func (m *", ccTypeName, ") Unmarshal(buf []byte) error {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("return ", g.Pkg["proto"], ".UnmarshalMessageSet(buf, &m.XXX_InternalExtensions)")
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				g.P("func (m *", ccTypeName, ") MarshalJSON() ([]byte, error) {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("return ", g.Pkg["proto"], ".MarshalMessageSetJSON(&m.XXX_InternalExtensions)")
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				g.P("func (m *", ccTypeName, ") UnmarshalJSON(buf []byte) error {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("return ", g.Pkg["proto"], ".UnmarshalMessageSetJSON(buf, &m.XXX_InternalExtensions)")
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				g.P("// ensure ", ccTypeName, " satisfies proto.Marshaler and proto.Unmarshaler")
0000000000000000000000000000000000000000;;				g.P("var _ ", g.Pkg["proto"], ".Marshaler = (*", ccTypeName, ")(nil)")
0000000000000000000000000000000000000000;;				g.P("var _ ", g.Pkg["proto"], ".Unmarshaler = (*", ccTypeName, ")(nil)")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;			g.P("var extRange_", ccTypeName, " = []", g.Pkg["proto"], ".ExtensionRange{")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			for _, r := range message.ExtensionRange {
0000000000000000000000000000000000000000;;				end := fmt.Sprint(*r.End - 1) // make range inclusive on both ends
0000000000000000000000000000000000000000;;				g.P("{Start: ", r.Start, ", End: ", end, "},")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P("func (*", ccTypeName, ") ExtensionRangeArray() []", g.Pkg["proto"], ".ExtensionRange {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			g.P("return extRange_", ccTypeName)
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			if !gogoproto.HasExtensionsMap(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;				g.P("func (m *", ccTypeName, ") GetExtensions() *[]byte {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("if m.XXX_extensions == nil {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("m.XXX_extensions = make([]byte, 0)")
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				g.P("return &m.XXX_extensions")
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default constants
0000000000000000000000000000000000000000;;		defNames := make(map[*descriptor.FieldDescriptorProto]string)
0000000000000000000000000000000000000000;;		for _, field := range message.Field {
0000000000000000000000000000000000000000;;			def := field.GetDefaultValue()
0000000000000000000000000000000000000000;;			if def == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !gogoproto.IsNullable(field) {
0000000000000000000000000000000000000000;;				g.Fail("illegal default value: ", field.GetName(), " in ", message.GetName(), " is not nullable and is thus not allowed to have a default value")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fieldname := "Default_" + ccTypeName + "_" + CamelCase(*field.Name)
0000000000000000000000000000000000000000;;			defNames[field] = fieldname
0000000000000000000000000000000000000000;;			typename, _ := g.GoType(message, field)
0000000000000000000000000000000000000000;;			if typename[0] == '*' {
0000000000000000000000000000000000000000;;				typename = typename[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			kind := "const "
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case typename == "bool":
0000000000000000000000000000000000000000;;			case typename == "string":
0000000000000000000000000000000000000000;;				def = strconv.Quote(def)
0000000000000000000000000000000000000000;;			case typename == "[]byte":
0000000000000000000000000000000000000000;;				def = "[]byte(" + strconv.Quote(def) + ")"
0000000000000000000000000000000000000000;;				kind = "var "
0000000000000000000000000000000000000000;;			case def == "inf", def == "-inf", def == "nan":
0000000000000000000000000000000000000000;;				// These names are known to, and defined by, the protocol language.
0000000000000000000000000000000000000000;;				switch def {
0000000000000000000000000000000000000000;;				case "inf":
0000000000000000000000000000000000000000;;					def = "math.Inf(1)"
0000000000000000000000000000000000000000;;				case "-inf":
0000000000000000000000000000000000000000;;					def = "math.Inf(-1)"
0000000000000000000000000000000000000000;;				case "nan":
0000000000000000000000000000000000000000;;					def = "math.NaN()"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if *field.Type == descriptor.FieldDescriptorProto_TYPE_FLOAT {
0000000000000000000000000000000000000000;;					def = "float32(" + def + ")"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				kind = "var "
0000000000000000000000000000000000000000;;			case *field.Type == descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;				// Must be an enum.  Need to construct the prefixed name.
0000000000000000000000000000000000000000;;				obj := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;				var enum *EnumDescriptor
0000000000000000000000000000000000000000;;				if id, ok := obj.(*ImportedDescriptor); ok {
0000000000000000000000000000000000000000;;					// The enum type has been publicly imported.
0000000000000000000000000000000000000000;;					enum, _ = id.o.(*EnumDescriptor)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					enum, _ = obj.(*EnumDescriptor)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if enum == nil {
0000000000000000000000000000000000000000;;					log.Printf("don't know how to generate constant for %s", fieldname)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// hunt down the actual enum corresponding to the default
0000000000000000000000000000000000000000;;				var enumValue *descriptor.EnumValueDescriptorProto
0000000000000000000000000000000000000000;;				for _, ev := range enum.Value {
0000000000000000000000000000000000000000;;					if def == ev.GetName() {
0000000000000000000000000000000000000000;;						enumValue = ev
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if enumValue != nil {
0000000000000000000000000000000000000000;;					if gogoproto.IsEnumValueCustomName(enumValue) {
0000000000000000000000000000000000000000;;						def = gogoproto.GetEnumValueCustomName(enumValue)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					g.Fail(fmt.Sprintf("could not resolve default enum value for %v.%v",
0000000000000000000000000000000000000000;;						g.DefaultPackageName(obj), def))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if gogoproto.EnabledGoEnumPrefix(enum.file, enum.EnumDescriptorProto) {
0000000000000000000000000000000000000000;;					def = g.DefaultPackageName(obj) + enum.prefix() + def
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					def = g.DefaultPackageName(obj) + def
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P(kind, fieldname, " ", typename, " = ", def)
0000000000000000000000000000000000000000;;			g.file.addExport(message, constOrVarSymbol{fieldname, kind, ""})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Oneof per-field types, discriminants and getters.
0000000000000000000000000000000000000000;;		if message.allowOneof() {
0000000000000000000000000000000000000000;;			// Generate unexported named types for the discriminant interfaces.
0000000000000000000000000000000000000000;;			// We shouldn't have to do this, but there was (~19 Aug 2015) a compiler/linker bug
0000000000000000000000000000000000000000;;			// that was triggered by using anonymous interfaces here.
0000000000000000000000000000000000000000;;			// TODO: Revisit this and consider reverting back to anonymous interfaces.
0000000000000000000000000000000000000000;;			for oi := range message.OneofDecl {
0000000000000000000000000000000000000000;;				dname := oneofDisc[int32(oi)]
0000000000000000000000000000000000000000;;				g.P("type ", dname, " interface {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P(dname, "()")
0000000000000000000000000000000000000000;;				if gogoproto.HasEqual(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;					g.P(`Equal(interface{}) bool`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if gogoproto.HasVerboseEqual(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;					g.P(`VerboseEqual(interface{}) error`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if gogoproto.IsMarshaler(g.file.FileDescriptorProto, message.DescriptorProto) ||
0000000000000000000000000000000000000000;;					gogoproto.IsUnsafeMarshaler(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;					g.P(`MarshalTo([]byte) (int, error)`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if gogoproto.IsSizer(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;					g.P(`Size() int`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if gogoproto.IsProtoSizer(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;					g.P(`ProtoSize() int`)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;			for _, field := range message.Field {
0000000000000000000000000000000000000000;;				if field.OneofIndex == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, wiretype := g.GoType(message, field)
0000000000000000000000000000000000000000;;				tag := "protobuf:" + g.goTag(message, field, wiretype)
0000000000000000000000000000000000000000;;				g.P("type ", oneofTypeName[field], " struct{ ", fieldNames[field], " ", fieldTypes[field], " `", tag, "` }")
0000000000000000000000000000000000000000;;				if !gogoproto.IsStdTime(field) && !gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;					g.RecordTypeUse(field.GetTypeName())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;			for _, field := range message.Field {
0000000000000000000000000000000000000000;;				if field.OneofIndex == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P("func (*", oneofTypeName[field], ") ", oneofDisc[*field.OneofIndex], "() {}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;			for oi := range message.OneofDecl {
0000000000000000000000000000000000000000;;				fname := oneofFieldName[int32(oi)]
0000000000000000000000000000000000000000;;				g.P("func (m *", ccTypeName, ") Get", fname, "() ", oneofDisc[int32(oi)], " {")
0000000000000000000000000000000000000000;;				g.P("if m != nil { return m.", fname, " }")
0000000000000000000000000000000000000000;;				g.P("return nil")
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Field getters
0000000000000000000000000000000000000000;;		var getters []getterSymbol
0000000000000000000000000000000000000000;;		for _, field := range message.Field {
0000000000000000000000000000000000000000;;			oneof := field.OneofIndex != nil && message.allowOneof()
0000000000000000000000000000000000000000;;			if !oneof && !gogoproto.HasGoGetters(g.file.FileDescriptorProto, message.DescriptorProto) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if gogoproto.IsEmbed(field) || gogoproto.IsCustomType(field) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fname := fieldNames[field]
0000000000000000000000000000000000000000;;			typename, _ := g.GoType(message, field)
0000000000000000000000000000000000000000;;			if t, ok := mapFieldTypes[field]; ok {
0000000000000000000000000000000000000000;;				typename = t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mname := fieldGetterNames[field]
0000000000000000000000000000000000000000;;			star := ""
0000000000000000000000000000000000000000;;			if (*field.Type != descriptor.FieldDescriptorProto_TYPE_MESSAGE) &&
0000000000000000000000000000000000000000;;				(*field.Type != descriptor.FieldDescriptorProto_TYPE_GROUP) &&
0000000000000000000000000000000000000000;;				needsStar(field, g.file.proto3, message != nil && message.allowOneof()) && typename[0] == '*' {
0000000000000000000000000000000000000000;;				typename = typename[1:]
0000000000000000000000000000000000000000;;				star = "*"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only export getter symbols for basic types,
0000000000000000000000000000000000000000;;			// and for messages and enums in the same package.
0000000000000000000000000000000000000000;;			// Groups are not exported.
0000000000000000000000000000000000000000;;			// Foreign types can't be hoisted through a public import because
0000000000000000000000000000000000000000;;			// the importer may not already be importing the defining .proto.
0000000000000000000000000000000000000000;;			// As an example, imagine we have an import tree like this:
0000000000000000000000000000000000000000;;			//   A.proto -> B.proto -> C.proto
0000000000000000000000000000000000000000;;			// If A publicly imports B, we need to generate the getters from B in A's output,
0000000000000000000000000000000000000000;;			// but if one such getter returns something from C then we cannot do that
0000000000000000000000000000000000000000;;			// because A is not importing C already.
0000000000000000000000000000000000000000;;			var getter, genType bool
0000000000000000000000000000000000000000;;			switch *field.Type {
0000000000000000000000000000000000000000;;			case descriptor.FieldDescriptorProto_TYPE_GROUP:
0000000000000000000000000000000000000000;;				getter = false
0000000000000000000000000000000000000000;;			case descriptor.FieldDescriptorProto_TYPE_MESSAGE, descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;				// Only export getter if its return type is in this package.
0000000000000000000000000000000000000000;;				getter = g.ObjectNamed(field.GetTypeName()).PackageName() == message.PackageName()
0000000000000000000000000000000000000000;;				genType = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				getter = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if getter {
0000000000000000000000000000000000000000;;				getters = append(getters, getterSymbol{
0000000000000000000000000000000000000000;;					name:     mname,
0000000000000000000000000000000000000000;;					typ:      typename,
0000000000000000000000000000000000000000;;					typeName: field.GetTypeName(),
0000000000000000000000000000000000000000;;					genType:  genType,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			g.P("func (m *", ccTypeName, ") "+mname+"() "+typename+" {")
0000000000000000000000000000000000000000;;			g.In()
0000000000000000000000000000000000000000;;			def, hasDef := defNames[field]
0000000000000000000000000000000000000000;;			typeDefaultIsNil := false // whether this field type's default value is a literal nil unless specified
0000000000000000000000000000000000000000;;			switch *field.Type {
0000000000000000000000000000000000000000;;			case descriptor.FieldDescriptorProto_TYPE_BYTES:
0000000000000000000000000000000000000000;;				typeDefaultIsNil = !hasDef
0000000000000000000000000000000000000000;;			case descriptor.FieldDescriptorProto_TYPE_GROUP, descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;				typeDefaultIsNil = gogoproto.IsNullable(field)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isRepeated(field) {
0000000000000000000000000000000000000000;;				typeDefaultIsNil = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if typeDefaultIsNil && !oneof {
0000000000000000000000000000000000000000;;				// A bytes field with no explicit default needs less generated code,
0000000000000000000000000000000000000000;;				// as does a message or group field, or a repeated field.
0000000000000000000000000000000000000000;;				g.P("if m != nil {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("return m." + fname)
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				g.P("return nil")
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				g.P()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !gogoproto.IsNullable(field) {
0000000000000000000000000000000000000000;;				g.P("if m != nil {")
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("return m." + fname)
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			} else if !oneof {
0000000000000000000000000000000000000000;;				if message.proto3() {
0000000000000000000000000000000000000000;;					g.P("if m != nil {")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					g.P("if m != nil && m." + fname + " != nil {")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.In()
0000000000000000000000000000000000000000;;				g.P("return " + star + "m." + fname)
0000000000000000000000000000000000000000;;				g.Out()
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				uname := oneofFieldName[*field.OneofIndex]
0000000000000000000000000000000000000000;;				tname := oneofTypeName[field]
0000000000000000000000000000000000000000;;				g.P("if x, ok := m.Get", uname, "().(*", tname, "); ok {")
0000000000000000000000000000000000000000;;				g.P("return x.", fname)
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasDef {
0000000000000000000000000000000000000000;;				if *field.Type != descriptor.FieldDescriptorProto_TYPE_BYTES {
0000000000000000000000000000000000000000;;					g.P("return " + def)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// The default is a []byte var.
0000000000000000000000000000000000000000;;					// Make a copy when returning it to be safe.
0000000000000000000000000000000000000000;;					g.P("return append([]byte(nil), ", def, "...)")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				switch *field.Type {
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_GROUP,
0000000000000000000000000000000000000000;;					descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;					if field.OneofIndex != nil {
0000000000000000000000000000000000000000;;						g.P(`return nil`)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						goTyp, _ := g.GoType(message, field)
0000000000000000000000000000000000000000;;						goTypName := GoTypeToName(goTyp)
0000000000000000000000000000000000000000;;						if !gogoproto.IsNullable(field) && gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;							g.P("return 0")
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							g.P("return ", goTypName, "{}")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_BOOL:
0000000000000000000000000000000000000000;;					g.P("return false")
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_STRING:
0000000000000000000000000000000000000000;;					g.P(`return ""`)
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_BYTES:
0000000000000000000000000000000000000000;;					// This is only possible for oneof fields.
0000000000000000000000000000000000000000;;					g.P("return nil")
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;					// The default default for an enum is the first value in the enum,
0000000000000000000000000000000000000000;;					// not zero.
0000000000000000000000000000000000000000;;					obj := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;					var enum *EnumDescriptor
0000000000000000000000000000000000000000;;					if id, ok := obj.(*ImportedDescriptor); ok {
0000000000000000000000000000000000000000;;						// The enum type has been publicly imported.
0000000000000000000000000000000000000000;;						enum, _ = id.o.(*EnumDescriptor)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						enum, _ = obj.(*EnumDescriptor)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if enum == nil {
0000000000000000000000000000000000000000;;						log.Printf("don't know how to generate getter for %s", field.GetName())
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if len(enum.Value) == 0 {
0000000000000000000000000000000000000000;;						g.P("return 0 // empty enum")
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						first := enum.Value[0].GetName()
0000000000000000000000000000000000000000;;						if gogoproto.IsEnumValueCustomName(enum.Value[0]) {
0000000000000000000000000000000000000000;;							first = gogoproto.GetEnumValueCustomName(enum.Value[0])
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if gogoproto.EnabledGoEnumPrefix(enum.file, enum.EnumDescriptorProto) {
0000000000000000000000000000000000000000;;							g.P("return ", g.DefaultPackageName(obj)+enum.prefix()+first)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							g.P("return ", g.DefaultPackageName(obj)+first)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					g.P("return 0")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Out()
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !message.group {
0000000000000000000000000000000000000000;;			ms := &messageSymbol{
0000000000000000000000000000000000000000;;				sym:           ccTypeName,
0000000000000000000000000000000000000000;;				hasExtensions: hasExtensions,
0000000000000000000000000000000000000000;;				isMessageSet:  isMessageSet,
0000000000000000000000000000000000000000;;				hasOneof:      len(message.OneofDecl) > 0,
0000000000000000000000000000000000000000;;				getters:       getters,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.file.addExport(message, ms)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Oneof functions
0000000000000000000000000000000000000000;;		if len(message.OneofDecl) > 0 && message.allowOneof() {
0000000000000000000000000000000000000000;;			fieldWire := make(map[*descriptor.FieldDescriptorProto]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// method
0000000000000000000000000000000000000000;;			enc := "_" + ccTypeName + "_OneofMarshaler"
0000000000000000000000000000000000000000;;			dec := "_" + ccTypeName + "_OneofUnmarshaler"
0000000000000000000000000000000000000000;;			size := "_" + ccTypeName + "_OneofSizer"
0000000000000000000000000000000000000000;;			encSig := "(msg " + g.Pkg["proto"] + ".Message, b *" + g.Pkg["proto"] + ".Buffer) error"
0000000000000000000000000000000000000000;;			decSig := "(msg " + g.Pkg["proto"] + ".Message, tag, wire int, b *" + g.Pkg["proto"] + ".Buffer) (bool, error)"
0000000000000000000000000000000000000000;;			sizeSig := "(msg " + g.Pkg["proto"] + ".Message) (n int)"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			g.P("// XXX_OneofFuncs is for the internal use of the proto package.")
0000000000000000000000000000000000000000;;			g.P("func (*", ccTypeName, ") XXX_OneofFuncs() (func", encSig, ", func", decSig, ", func", sizeSig, ", []interface{}) {")
0000000000000000000000000000000000000000;;			g.P("return ", enc, ", ", dec, ", ", size, ", []interface{}{")
0000000000000000000000000000000000000000;;			for _, field := range message.Field {
0000000000000000000000000000000000000000;;				if field.OneofIndex == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P("(*", oneofTypeName[field], ")(nil),")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// marshaler
0000000000000000000000000000000000000000;;			g.P("func ", enc, encSig, " {")
0000000000000000000000000000000000000000;;			g.P("m := msg.(*", ccTypeName, ")")
0000000000000000000000000000000000000000;;			for oi, odp := range message.OneofDecl {
0000000000000000000000000000000000000000;;				g.P("// ", odp.GetName())
0000000000000000000000000000000000000000;;				fname := oneofFieldName[int32(oi)]
0000000000000000000000000000000000000000;;				g.P("switch x := m.", fname, ".(type) {")
0000000000000000000000000000000000000000;;				for _, field := range message.Field {
0000000000000000000000000000000000000000;;					if field.OneofIndex == nil || int(*field.OneofIndex) != oi {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					g.P("case *", oneofTypeName[field], ":")
0000000000000000000000000000000000000000;;					var wire, pre, post string
0000000000000000000000000000000000000000;;					val := "x." + fieldNames[field] // overridden for TYPE_BOOL
0000000000000000000000000000000000000000;;					canFail := false                // only TYPE_MESSAGE and TYPE_GROUP can fail
0000000000000000000000000000000000000000;;					switch *field.Type {
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
0000000000000000000000000000000000000000;;						wire = "WireFixed64"
0000000000000000000000000000000000000000;;						pre = "b.EncodeFixed64(" + g.Pkg["math"] + ".Float64bits("
0000000000000000000000000000000000000000;;						post = "))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_FLOAT:
0000000000000000000000000000000000000000;;						wire = "WireFixed32"
0000000000000000000000000000000000000000;;						pre = "b.EncodeFixed32(uint64(" + g.Pkg["math"] + ".Float32bits("
0000000000000000000000000000000000000000;;						post = ")))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_INT64,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_UINT64:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeVarint(uint64(", "))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_INT32,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_UINT32,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeVarint(uint64(", "))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_FIXED64,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_SFIXED64:
0000000000000000000000000000000000000000;;						wire = "WireFixed64"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeFixed64(uint64(", "))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_FIXED32,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_SFIXED32:
0000000000000000000000000000000000000000;;						wire = "WireFixed32"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeFixed32(uint64(", "))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_BOOL:
0000000000000000000000000000000000000000;;						// bool needs special handling.
0000000000000000000000000000000000000000;;						g.P("t := uint64(0)")
0000000000000000000000000000000000000000;;						g.P("if ", val, " { t = 1 }")
0000000000000000000000000000000000000000;;						val = "t"
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeVarint(", ")"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_STRING:
0000000000000000000000000000000000000000;;						wire = "WireBytes"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeStringBytes(", ")"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_GROUP:
0000000000000000000000000000000000000000;;						wire = "WireStartGroup"
0000000000000000000000000000000000000000;;						pre, post = "b.Marshal(", ")"
0000000000000000000000000000000000000000;;						canFail = true
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;						wire = "WireBytes"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeMessage(", ")"
0000000000000000000000000000000000000000;;						canFail = true
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_BYTES:
0000000000000000000000000000000000000000;;						wire = "WireBytes"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeRawBytes(", ")"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_SINT32:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeZigzag32(uint64(", "))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_SINT64:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeZigzag64(uint64(", "))"
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						g.Fail("unhandled oneof field type ", field.Type.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fieldWire[field] = wire
0000000000000000000000000000000000000000;;					g.P("_ = b.EncodeVarint(", field.Number, "<<3|", g.Pkg["proto"], ".", wire, ")")
0000000000000000000000000000000000000000;;					if *field.Type == descriptor.FieldDescriptorProto_TYPE_BYTES && gogoproto.IsCustomType(field) {
0000000000000000000000000000000000000000;;						g.P(`dAtA, err := `, val, `.Marshal()`)
0000000000000000000000000000000000000000;;						g.P(`if err != nil {`)
0000000000000000000000000000000000000000;;						g.In()
0000000000000000000000000000000000000000;;						g.P(`return err`)
0000000000000000000000000000000000000000;;						g.Out()
0000000000000000000000000000000000000000;;						g.P(`}`)
0000000000000000000000000000000000000000;;						val = "dAtA"
0000000000000000000000000000000000000000;;					} else if gogoproto.IsStdTime(field) {
0000000000000000000000000000000000000000;;						pkg := g.useTypes()
0000000000000000000000000000000000000000;;						if gogoproto.IsNullable(field) {
0000000000000000000000000000000000000000;;							g.P(`dAtA, err := `, pkg, `.StdTimeMarshal(*`, val, `)`)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							g.P(`dAtA, err := `, pkg, `.StdTimeMarshal(`, val, `)`)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						g.P(`if err != nil {`)
0000000000000000000000000000000000000000;;						g.In()
0000000000000000000000000000000000000000;;						g.P(`return err`)
0000000000000000000000000000000000000000;;						g.Out()
0000000000000000000000000000000000000000;;						g.P(`}`)
0000000000000000000000000000000000000000;;						val = "dAtA"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeRawBytes(", ")"
0000000000000000000000000000000000000000;;					} else if gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;						pkg := g.useTypes()
0000000000000000000000000000000000000000;;						if gogoproto.IsNullable(field) {
0000000000000000000000000000000000000000;;							g.P(`dAtA, err := `, pkg, `.StdDurationMarshal(*`, val, `)`)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							g.P(`dAtA, err := `, pkg, `.StdDurationMarshal(`, val, `)`)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						g.P(`if err != nil {`)
0000000000000000000000000000000000000000;;						g.In()
0000000000000000000000000000000000000000;;						g.P(`return err`)
0000000000000000000000000000000000000000;;						g.Out()
0000000000000000000000000000000000000000;;						g.P(`}`)
0000000000000000000000000000000000000000;;						val = "dAtA"
0000000000000000000000000000000000000000;;						pre, post = "b.EncodeRawBytes(", ")"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !canFail {
0000000000000000000000000000000000000000;;						g.P("_ = ", pre, val, post)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						g.P("if err := ", pre, val, post, "; err != nil {")
0000000000000000000000000000000000000000;;						g.In()
0000000000000000000000000000000000000000;;						g.P("return err")
0000000000000000000000000000000000000000;;						g.Out()
0000000000000000000000000000000000000000;;						g.P("}")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if *field.Type == descriptor.FieldDescriptorProto_TYPE_GROUP {
0000000000000000000000000000000000000000;;						g.P("_ = b.EncodeVarint(", field.Number, "<<3|", g.Pkg["proto"], ".WireEndGroup)")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P("case nil:")
0000000000000000000000000000000000000000;;				g.P("default: return ", g.Pkg["fmt"], `.Errorf("`, ccTypeName, ".", fname, ` has unexpected type %T", x)`)
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P("return nil")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// unmarshaler
0000000000000000000000000000000000000000;;			g.P("func ", dec, decSig, " {")
0000000000000000000000000000000000000000;;			g.P("m := msg.(*", ccTypeName, ")")
0000000000000000000000000000000000000000;;			g.P("switch tag {")
0000000000000000000000000000000000000000;;			for _, field := range message.Field {
0000000000000000000000000000000000000000;;				if field.OneofIndex == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				odp := message.OneofDecl[int(*field.OneofIndex)]
0000000000000000000000000000000000000000;;				g.P("case ", field.Number, ": // ", odp.GetName(), ".", *field.Name)
0000000000000000000000000000000000000000;;				g.P("if wire != ", g.Pkg["proto"], ".", fieldWire[field], " {")
0000000000000000000000000000000000000000;;				g.P("return true, ", g.Pkg["proto"], ".ErrInternalBadWireType")
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;				lhs := "x, err" // overridden for TYPE_MESSAGE and TYPE_GROUP
0000000000000000000000000000000000000000;;				var dec, cast, cast2 string
0000000000000000000000000000000000000000;;				switch *field.Type {
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeFixed64()", g.Pkg["math"]+".Float64frombits"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_FLOAT:
0000000000000000000000000000000000000000;;					dec, cast, cast2 = "b.DecodeFixed32()", "uint32", g.Pkg["math"]+".Float32frombits"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_INT64:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeVarint()", "int64"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_UINT64:
0000000000000000000000000000000000000000;;					dec = "b.DecodeVarint()"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_INT32:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeVarint()", "int32"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_FIXED64:
0000000000000000000000000000000000000000;;					dec = "b.DecodeFixed64()"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_FIXED32:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeFixed32()", "uint32"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_BOOL:
0000000000000000000000000000000000000000;;					dec = "b.DecodeVarint()"
0000000000000000000000000000000000000000;;					// handled specially below
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_STRING:
0000000000000000000000000000000000000000;;					dec = "b.DecodeStringBytes()"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_GROUP:
0000000000000000000000000000000000000000;;					g.P("msg := new(", fieldTypes[field][1:], ")") // drop star
0000000000000000000000000000000000000000;;					lhs = "err"
0000000000000000000000000000000000000000;;					dec = "b.DecodeGroup(msg)"
0000000000000000000000000000000000000000;;					// handled specially below
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;					if gogoproto.IsStdTime(field) || gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;						dec = "b.DecodeRawBytes(true)"
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						g.P("msg := new(", fieldTypes[field][1:], ")") // drop star
0000000000000000000000000000000000000000;;						lhs = "err"
0000000000000000000000000000000000000000;;						dec = "b.DecodeMessage(msg)"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// handled specially below
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_BYTES:
0000000000000000000000000000000000000000;;					dec = "b.DecodeRawBytes(true)"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_UINT32:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeVarint()", "uint32"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeVarint()", fieldTypes[field]
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_SFIXED32:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeFixed32()", "int32"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_SFIXED64:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeFixed64()", "int64"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_SINT32:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeZigzag32()", "int32"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_SINT64:
0000000000000000000000000000000000000000;;					dec, cast = "b.DecodeZigzag64()", "int64"
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					g.Fail("unhandled oneof field type ", field.Type.String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P(lhs, " := ", dec)
0000000000000000000000000000000000000000;;				val := "x"
0000000000000000000000000000000000000000;;				if *field.Type == descriptor.FieldDescriptorProto_TYPE_BYTES && gogoproto.IsCustomType(field) {
0000000000000000000000000000000000000000;;					g.P(`if err != nil {`)
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P(`return true, err`)
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P(`}`)
0000000000000000000000000000000000000000;;					_, ctyp, err := GetCustomType(field)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						panic(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					g.P(`var cc `, ctyp)
0000000000000000000000000000000000000000;;					g.P(`c := &cc`)
0000000000000000000000000000000000000000;;					g.P(`err = c.Unmarshal(`, val, `)`)
0000000000000000000000000000000000000000;;					val = "*c"
0000000000000000000000000000000000000000;;				} else if gogoproto.IsStdTime(field) {
0000000000000000000000000000000000000000;;					pkg := g.useTypes()
0000000000000000000000000000000000000000;;					g.P(`if err != nil {`)
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P(`return true, err`)
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P(`}`)
0000000000000000000000000000000000000000;;					g.P(`c := new(time.Time)`)
0000000000000000000000000000000000000000;;					g.P(`if err2 := `, pkg, `.StdTimeUnmarshal(c, `, val, `); err2 != nil {`)
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P(`return true, err`)
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P(`}`)
0000000000000000000000000000000000000000;;					val = "c"
0000000000000000000000000000000000000000;;				} else if gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;					pkg := g.useTypes()
0000000000000000000000000000000000000000;;					g.P(`if err != nil {`)
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P(`return true, err`)
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P(`}`)
0000000000000000000000000000000000000000;;					g.P(`c := new(time.Duration)`)
0000000000000000000000000000000000000000;;					g.P(`if err2 := `, pkg, `.StdDurationUnmarshal(c, `, val, `); err2 != nil {`)
0000000000000000000000000000000000000000;;					g.In()
0000000000000000000000000000000000000000;;					g.P(`return true, err`)
0000000000000000000000000000000000000000;;					g.Out()
0000000000000000000000000000000000000000;;					g.P(`}`)
0000000000000000000000000000000000000000;;					val = "c"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cast != "" {
0000000000000000000000000000000000000000;;					val = cast + "(" + val + ")"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cast2 != "" {
0000000000000000000000000000000000000000;;					val = cast2 + "(" + val + ")"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch *field.Type {
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_BOOL:
0000000000000000000000000000000000000000;;					val += " != 0"
0000000000000000000000000000000000000000;;				case descriptor.FieldDescriptorProto_TYPE_GROUP,
0000000000000000000000000000000000000000;;					descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;					if !gogoproto.IsStdTime(field) && !gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;						val = "msg"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if gogoproto.IsCastType(field) {
0000000000000000000000000000000000000000;;					_, typ, err := getCastType(field)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						g.Fail(err.Error())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					val = typ + "(" + val + ")"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P("m.", oneofFieldName[*field.OneofIndex], " = &", oneofTypeName[field], "{", val, "}")
0000000000000000000000000000000000000000;;				g.P("return true, err")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P("default: return false, nil")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// sizer
0000000000000000000000000000000000000000;;			g.P("func ", size, sizeSig, " {")
0000000000000000000000000000000000000000;;			g.P("m := msg.(*", ccTypeName, ")")
0000000000000000000000000000000000000000;;			for oi, odp := range message.OneofDecl {
0000000000000000000000000000000000000000;;				g.P("// ", odp.GetName())
0000000000000000000000000000000000000000;;				fname := oneofFieldName[int32(oi)]
0000000000000000000000000000000000000000;;				g.P("switch x := m.", fname, ".(type) {")
0000000000000000000000000000000000000000;;				for _, field := range message.Field {
0000000000000000000000000000000000000000;;					if field.OneofIndex == nil || int(*field.OneofIndex) != oi {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					g.P("case *", oneofTypeName[field], ":")
0000000000000000000000000000000000000000;;					val := "x." + fieldNames[field]
0000000000000000000000000000000000000000;;					var wire, varint, fixed string
0000000000000000000000000000000000000000;;					switch *field.Type {
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_DOUBLE:
0000000000000000000000000000000000000000;;						wire = "WireFixed64"
0000000000000000000000000000000000000000;;						fixed = "8"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_FLOAT:
0000000000000000000000000000000000000000;;						wire = "WireFixed32"
0000000000000000000000000000000000000000;;						fixed = "4"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_INT64,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_UINT64,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_INT32,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_UINT32,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_ENUM:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						varint = val
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_FIXED64,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_SFIXED64:
0000000000000000000000000000000000000000;;						wire = "WireFixed64"
0000000000000000000000000000000000000000;;						fixed = "8"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_FIXED32,
0000000000000000000000000000000000000000;;						descriptor.FieldDescriptorProto_TYPE_SFIXED32:
0000000000000000000000000000000000000000;;						wire = "WireFixed32"
0000000000000000000000000000000000000000;;						fixed = "4"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_BOOL:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						fixed = "1"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_STRING:
0000000000000000000000000000000000000000;;						wire = "WireBytes"
0000000000000000000000000000000000000000;;						fixed = "len(" + val + ")"
0000000000000000000000000000000000000000;;						varint = fixed
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_GROUP:
0000000000000000000000000000000000000000;;						wire = "WireStartGroup"
0000000000000000000000000000000000000000;;						fixed = g.Pkg["proto"] + ".Size(" + val + ")"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
0000000000000000000000000000000000000000;;						wire = "WireBytes"
0000000000000000000000000000000000000000;;						if gogoproto.IsStdTime(field) {
0000000000000000000000000000000000000000;;							if gogoproto.IsNullable(field) {
0000000000000000000000000000000000000000;;								val = "*" + val
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							pkg := g.useTypes()
0000000000000000000000000000000000000000;;							g.P("s := ", pkg, ".SizeOfStdTime(", val, ")")
0000000000000000000000000000000000000000;;						} else if gogoproto.IsStdDuration(field) {
0000000000000000000000000000000000000000;;							if gogoproto.IsNullable(field) {
0000000000000000000000000000000000000000;;								val = "*" + val
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							pkg := g.useTypes()
0000000000000000000000000000000000000000;;							g.P("s := ", pkg, ".SizeOfStdDuration(", val, ")")
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							g.P("s := ", g.Pkg["proto"], ".Size(", val, ")")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						fixed = "s"
0000000000000000000000000000000000000000;;						varint = fixed
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_BYTES:
0000000000000000000000000000000000000000;;						wire = "WireBytes"
0000000000000000000000000000000000000000;;						if gogoproto.IsCustomType(field) {
0000000000000000000000000000000000000000;;							fixed = val + ".Size()"
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							fixed = "len(" + val + ")"
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						varint = fixed
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_SINT32:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						varint = "(uint32(" + val + ") << 1) ^ uint32((int32(" + val + ") >> 31))"
0000000000000000000000000000000000000000;;					case descriptor.FieldDescriptorProto_TYPE_SINT64:
0000000000000000000000000000000000000000;;						wire = "WireVarint"
0000000000000000000000000000000000000000;;						varint = "uint64(" + val + " << 1) ^ uint64((int64(" + val + ") >> 63))"
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						g.Fail("unhandled oneof field type ", field.Type.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					g.P("n += ", g.Pkg["proto"], ".SizeVarint(", field.Number, "<<3|", g.Pkg["proto"], ".", wire, ")")
0000000000000000000000000000000000000000;;					if varint != "" {
0000000000000000000000000000000000000000;;						g.P("n += ", g.Pkg["proto"], ".SizeVarint(uint64(", varint, "))")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if fixed != "" {
0000000000000000000000000000000000000000;;						g.P("n += ", fixed)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if *field.Type == descriptor.FieldDescriptorProto_TYPE_GROUP {
0000000000000000000000000000000000000000;;						g.P("n += ", g.Pkg["proto"], ".SizeVarint(", field.Number, "<<3|", g.Pkg["proto"], ".WireEndGroup)")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				g.P("case nil:")
0000000000000000000000000000000000000000;;				g.P("default:")
0000000000000000000000000000000000000000;;				g.P("panic(", g.Pkg["fmt"], ".Sprintf(\"proto: unexpected type %T in oneof\", x))")
0000000000000000000000000000000000000000;;				g.P("}")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P("return n")
0000000000000000000000000000000000000000;;			g.P("}")
0000000000000000000000000000000000000000;;			g.P()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ext := range message.ext {
0000000000000000000000000000000000000000;;			g.generateExtension(ext)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fullName := strings.Join(message.TypeName(), ".")
0000000000000000000000000000000000000000;;		if g.file.Package != nil {
0000000000000000000000000000000000000000;;			fullName = *g.file.Package + "." + fullName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.addInitf("%s.RegisterType((*%s)(nil), %q)", g.Pkg["proto"], ccTypeName, fullName)
0000000000000000000000000000000000000000;;		if gogoproto.ImportsGoGoProto(g.file.FileDescriptorProto) && gogoproto.RegistersGolangProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;			g.addInitf("%s.RegisterType((*%s)(nil), %q)", g.Pkg["golang_proto"], ccTypeName, fullName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) generateExtension(ext *ExtensionDescriptor) {
0000000000000000000000000000000000000000;;		ccTypeName := ext.DescName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extObj := g.ObjectNamed(*ext.Extendee)
0000000000000000000000000000000000000000;;		var extDesc *Descriptor
0000000000000000000000000000000000000000;;		if id, ok := extObj.(*ImportedDescriptor); ok {
0000000000000000000000000000000000000000;;			// This is extending a publicly imported message.
0000000000000000000000000000000000000000;;			// We need the underlying type for goTag.
0000000000000000000000000000000000000000;;			extDesc = id.o.(*Descriptor)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			extDesc = extObj.(*Descriptor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		extendedType := "*" + g.TypeName(extObj) // always use the original
0000000000000000000000000000000000000000;;		field := ext.FieldDescriptorProto
0000000000000000000000000000000000000000;;		fieldType, wireType := g.GoType(ext.parent, field)
0000000000000000000000000000000000000000;;		tag := g.goTag(extDesc, field, wireType)
0000000000000000000000000000000000000000;;		g.RecordTypeUse(*ext.Extendee)
0000000000000000000000000000000000000000;;		if n := ext.FieldDescriptorProto.TypeName; n != nil {
0000000000000000000000000000000000000000;;			// foreign extension type
0000000000000000000000000000000000000000;;			g.RecordTypeUse(*n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeName := ext.TypeName()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Special case for proto2 message sets: If this extension is extending
0000000000000000000000000000000000000000;;		// proto2_bridge.MessageSet, and its final name component is "message_set_extension",
0000000000000000000000000000000000000000;;		// then drop that last component.
0000000000000000000000000000000000000000;;		mset := false
0000000000000000000000000000000000000000;;		if extendedType == "*proto2_bridge.MessageSet" && typeName[len(typeName)-1] == "message_set_extension" {
0000000000000000000000000000000000000000;;			typeName = typeName[:len(typeName)-1]
0000000000000000000000000000000000000000;;			mset = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For text formatting, the package must be exactly what the .proto file declares,
0000000000000000000000000000000000000000;;		// ignoring overrides such as the go_package option, and with no dot/underscore mapping.
0000000000000000000000000000000000000000;;		extName := strings.Join(typeName, ".")
0000000000000000000000000000000000000000;;		if g.file.Package != nil {
0000000000000000000000000000000000000000;;			extName = *g.file.Package + "." + extName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.P("var ", ccTypeName, " = &", g.Pkg["proto"], ".ExtensionDesc{")
0000000000000000000000000000000000000000;;		g.In()
0000000000000000000000000000000000000000;;		g.P("ExtendedType: (", extendedType, ")(nil),")
0000000000000000000000000000000000000000;;		g.P("ExtensionType: (", fieldType, ")(nil),")
0000000000000000000000000000000000000000;;		g.P("Field: ", field.Number, ",")
0000000000000000000000000000000000000000;;		g.P(`Name: "`, extName, `",`)
0000000000000000000000000000000000000000;;		g.P("Tag: ", tag, ",")
0000000000000000000000000000000000000000;;		g.P(`Filename: "`, g.file.GetName(), `",`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.Out()
0000000000000000000000000000000000000000;;		g.P("}")
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mset {
0000000000000000000000000000000000000000;;			// Generate a bit more code to register with message_set.go.
0000000000000000000000000000000000000000;;			g.addInitf("%s.RegisterMessageSetType((%s)(nil), %d, %q)", g.Pkg["proto"], fieldType, *field.Number, extName)
0000000000000000000000000000000000000000;;			if gogoproto.ImportsGoGoProto(g.file.FileDescriptorProto) && gogoproto.RegistersGolangProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;				g.addInitf("%s.RegisterMessageSetType((%s)(nil), %d, %q)", g.Pkg["golang_proto"], fieldType, *field.Number, extName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		g.file.addExport(ext, constOrVarSymbol{ccTypeName, "var", ""})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) generateInitFunction() {
0000000000000000000000000000000000000000;;		for _, enum := range g.file.enum {
0000000000000000000000000000000000000000;;			g.generateEnumRegistration(enum)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, d := range g.file.desc {
0000000000000000000000000000000000000000;;			for _, ext := range d.ext {
0000000000000000000000000000000000000000;;				g.generateExtensionRegistration(ext)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ext := range g.file.ext {
0000000000000000000000000000000000000000;;			g.generateExtensionRegistration(ext)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(g.init) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P("func init() {")
0000000000000000000000000000000000000000;;		g.In()
0000000000000000000000000000000000000000;;		for _, l := range g.init {
0000000000000000000000000000000000000000;;			g.P(l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Out()
0000000000000000000000000000000000000000;;		g.P("}")
0000000000000000000000000000000000000000;;		g.init = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) generateFileDescriptor(file *FileDescriptor) {
0000000000000000000000000000000000000000;;		// Make a copy and trim source_code_info data.
0000000000000000000000000000000000000000;;		// TODO: Trim this more when we know exactly what we need.
0000000000000000000000000000000000000000;;		pb := proto.Clone(file.FileDescriptorProto).(*descriptor.FileDescriptorProto)
0000000000000000000000000000000000000000;;		pb.SourceCodeInfo = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := proto.Marshal(pb)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			g.Fail(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		w, _ := gzip.NewWriterLevel(&buf, gzip.BestCompression)
0000000000000000000000000000000000000000;;		w.Write(b)
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;		b = buf.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := file.VarName()
0000000000000000000000000000000000000000;;		g.P()
0000000000000000000000000000000000000000;;		g.P("func init() { ", g.Pkg["proto"], ".RegisterFile(", strconv.Quote(*file.Name), ", ", v, ") }")
0000000000000000000000000000000000000000;;		if gogoproto.ImportsGoGoProto(g.file.FileDescriptorProto) && gogoproto.RegistersGolangProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;			g.P("func init() { ", g.Pkg["golang_proto"], ".RegisterFile(", strconv.Quote(*file.Name), ", ", v, ") }")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.P("var ", v, " = []byte{")
0000000000000000000000000000000000000000;;		g.In()
0000000000000000000000000000000000000000;;		g.P("// ", len(b), " bytes of a gzipped FileDescriptorProto")
0000000000000000000000000000000000000000;;		for len(b) > 0 {
0000000000000000000000000000000000000000;;			n := 16
0000000000000000000000000000000000000000;;			if n > len(b) {
0000000000000000000000000000000000000000;;				n = len(b)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s := ""
0000000000000000000000000000000000000000;;			for _, c := range b[:n] {
0000000000000000000000000000000000000000;;				s += fmt.Sprintf("0x%02x,", c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.P(s)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b = b[n:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Out()
0000000000000000000000000000000000000000;;		g.P("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) generateEnumRegistration(enum *EnumDescriptor) {
0000000000000000000000000000000000000000;;		// // We always print the full (proto-world) package name here.
0000000000000000000000000000000000000000;;		pkg := enum.File().GetPackage()
0000000000000000000000000000000000000000;;		if pkg != "" {
0000000000000000000000000000000000000000;;			pkg += "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The full type name
0000000000000000000000000000000000000000;;		typeName := enum.TypeName()
0000000000000000000000000000000000000000;;		// The full type name, CamelCased.
0000000000000000000000000000000000000000;;		ccTypeName := CamelCaseSlice(typeName)
0000000000000000000000000000000000000000;;		g.addInitf("%s.RegisterEnum(%q, %[3]s_name, %[3]s_value)", g.Pkg["proto"], pkg+ccTypeName, ccTypeName)
0000000000000000000000000000000000000000;;		if gogoproto.ImportsGoGoProto(g.file.FileDescriptorProto) && gogoproto.RegistersGolangProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;			g.addInitf("%s.RegisterEnum(%q, %[3]s_name, %[3]s_value)", g.Pkg["golang_proto"], pkg+ccTypeName, ccTypeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) generateExtensionRegistration(ext *ExtensionDescriptor) {
0000000000000000000000000000000000000000;;		g.addInitf("%s.RegisterExtension(%s)", g.Pkg["proto"], ext.DescName())
0000000000000000000000000000000000000000;;		if gogoproto.ImportsGoGoProto(g.file.FileDescriptorProto) && gogoproto.RegistersGolangProto(g.file.FileDescriptorProto) {
0000000000000000000000000000000000000000;;			g.addInitf("%s.RegisterExtension(%s)", g.Pkg["golang_proto"], ext.DescName())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// And now lots of helper functions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is c an ASCII lower-case letter?
0000000000000000000000000000000000000000;;	func isASCIILower(c byte) bool {
0000000000000000000000000000000000000000;;		return 'a' <= c && c <= 'z'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is c an ASCII digit?
0000000000000000000000000000000000000000;;	func isASCIIDigit(c byte) bool {
0000000000000000000000000000000000000000;;		return '0' <= c && c <= '9'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CamelCase returns the CamelCased name.
0000000000000000000000000000000000000000;;	// If there is an interior underscore followed by a lower case letter,
0000000000000000000000000000000000000000;;	// drop the underscore and convert the letter to upper case.
0000000000000000000000000000000000000000;;	// There is a remote possibility of this rewrite causing a name collision,
0000000000000000000000000000000000000000;;	// but it's so remote we're prepared to pretend it's nonexistent - since the
0000000000000000000000000000000000000000;;	// C++ generator lowercases names, it's extremely unlikely to have two fields
0000000000000000000000000000000000000000;;	// with different capitalizations.
0000000000000000000000000000000000000000;;	// In short, _my_field_name_2 becomes XMyFieldName_2.
0000000000000000000000000000000000000000;;	func CamelCase(s string) string {
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := make([]byte, 0, 32)
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		if s[0] == '_' {
0000000000000000000000000000000000000000;;			// Need a capital letter; drop the '_'.
0000000000000000000000000000000000000000;;			t = append(t, 'X')
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Invariant: if the next letter is lower case, it must be converted
0000000000000000000000000000000000000000;;		// to upper case.
0000000000000000000000000000000000000000;;		// That is, we process a word at a time, where words are marked by _ or
0000000000000000000000000000000000000000;;		// upper case letter. Digits are treated as words.
0000000000000000000000000000000000000000;;		for ; i < len(s); i++ {
0000000000000000000000000000000000000000;;			c := s[i]
0000000000000000000000000000000000000000;;			if c == '_' && i+1 < len(s) && isASCIILower(s[i+1]) {
0000000000000000000000000000000000000000;;				continue // Skip the underscore in s.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if isASCIIDigit(c) {
0000000000000000000000000000000000000000;;				t = append(t, c)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Assume we have a letter now - if not, it's a bogus identifier.
0000000000000000000000000000000000000000;;			// The next word is a sequence of characters that must start upper case.
0000000000000000000000000000000000000000;;			if isASCIILower(c) {
0000000000000000000000000000000000000000;;				c ^= ' ' // Make it a capital letter.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t = append(t, c) // Guaranteed not lower case.
0000000000000000000000000000000000000000;;			// Accept lower case sequence that follows.
0000000000000000000000000000000000000000;;			for i+1 < len(s) && isASCIILower(s[i+1]) {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				t = append(t, s[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CamelCaseSlice is like CamelCase, but the argument is a slice of strings to
0000000000000000000000000000000000000000;;	// be joined with "_".
0000000000000000000000000000000000000000;;	func CamelCaseSlice(elem []string) string { return CamelCase(strings.Join(elem, "_")) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dottedSlice turns a sliced name into a dotted name.
0000000000000000000000000000000000000000;;	func dottedSlice(elem []string) string { return strings.Join(elem, ".") }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is this field optional?
0000000000000000000000000000000000000000;;	func isOptional(field *descriptor.FieldDescriptorProto) bool {
0000000000000000000000000000000000000000;;		return field.Label != nil && *field.Label == descriptor.FieldDescriptorProto_LABEL_OPTIONAL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is this field required?
0000000000000000000000000000000000000000;;	func isRequired(field *descriptor.FieldDescriptorProto) bool {
0000000000000000000000000000000000000000;;		return field.Label != nil && *field.Label == descriptor.FieldDescriptorProto_LABEL_REQUIRED
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is this field repeated?
0000000000000000000000000000000000000000;;	func isRepeated(field *descriptor.FieldDescriptorProto) bool {
0000000000000000000000000000000000000000;;		return field.Label != nil && *field.Label == descriptor.FieldDescriptorProto_LABEL_REPEATED
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is this field a scalar numeric type?
0000000000000000000000000000000000000000;;	func IsScalar(field *descriptor.FieldDescriptorProto) bool {
0000000000000000000000000000000000000000;;		if field.Type == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch *field.Type {
0000000000000000000000000000000000000000;;		case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_FLOAT,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_INT64,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_UINT64,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_INT32,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_FIXED64,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_FIXED32,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_BOOL,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_UINT32,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_ENUM,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_SFIXED32,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_SFIXED64,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_SINT32,
0000000000000000000000000000000000000000;;			descriptor.FieldDescriptorProto_TYPE_SINT64:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// badToUnderscore is the mapping function used to generate Go names from package names,
0000000000000000000000000000000000000000;;	// which can be dotted in the input .proto file.  It replaces non-identifier characters such as
0000000000000000000000000000000000000000;;	// dot or dash with underscore.
0000000000000000000000000000000000000000;;	func badToUnderscore(r rune) rune {
0000000000000000000000000000000000000000;;		if unicode.IsLetter(r) || unicode.IsDigit(r) || r == '_' {
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return '_'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// baseName returns the last path element of the name, with the last dotted suffix removed.
0000000000000000000000000000000000000000;;	func baseName(name string) string {
0000000000000000000000000000000000000000;;		// First, find the last element
0000000000000000000000000000000000000000;;		if i := strings.LastIndex(name, "/"); i >= 0 {
0000000000000000000000000000000000000000;;			name = name[i+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Now drop the suffix
0000000000000000000000000000000000000000;;		if i := strings.LastIndex(name, "."); i >= 0 {
0000000000000000000000000000000000000000;;			name = name[0:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The SourceCodeInfo message describes the location of elements of a parsed
0000000000000000000000000000000000000000;;	// .proto file by way of a "path", which is a sequence of integers that
0000000000000000000000000000000000000000;;	// describe the route from a FileDescriptorProto to the relevant submessage.
0000000000000000000000000000000000000000;;	// The path alternates between a field number of a repeated field, and an index
0000000000000000000000000000000000000000;;	// into that repeated field. The constants below define the field numbers that
0000000000000000000000000000000000000000;;	// are used.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See descriptor.proto for more information about this.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// tag numbers in FileDescriptorProto
0000000000000000000000000000000000000000;;		packagePath = 2 // package
0000000000000000000000000000000000000000;;		messagePath = 4 // message_type
0000000000000000000000000000000000000000;;		enumPath    = 5 // enum_type
0000000000000000000000000000000000000000;;		// tag numbers in DescriptorProto
0000000000000000000000000000000000000000;;		messageFieldPath   = 2 // field
0000000000000000000000000000000000000000;;		messageMessagePath = 3 // nested_type
0000000000000000000000000000000000000000;;		messageEnumPath    = 4 // enum_type
0000000000000000000000000000000000000000;;		messageOneofPath   = 8 // oneof_decl
0000000000000000000000000000000000000000;;		// tag numbers in EnumDescriptorProto
0000000000000000000000000000000000000000;;		enumValuePath = 2 // value
0000000000000000000000000000000000000000;;	)
