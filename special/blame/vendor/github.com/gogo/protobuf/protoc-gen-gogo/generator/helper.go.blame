0000000000000000000000000000000000000000;;	// Protocol Buffers for Go with Gadgets
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2013, The GoGo Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// http://github.com/gogo/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
3d29d329cedf26a7a5df80b3b66a105722269e22;Godeps/_workspace/src/github.com/gogo/protobuf/protoc-gen-gogo/generator/helper.go[Godeps/_workspace/src/github.com/gogo/protobuf/protoc-gen-gogo/generator/helper.go][vendor/github.com/gogo/protobuf/protoc-gen-gogo/generator/helper.go];	
0000000000000000000000000000000000000000;;	package generator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"go/parser"
0000000000000000000000000000000000000000;;		"go/printer"
0000000000000000000000000000000000000000;;		"go/token"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/gogoproto"
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/proto"
0000000000000000000000000000000000000000;;		descriptor "github.com/gogo/protobuf/protoc-gen-gogo/descriptor"
0000000000000000000000000000000000000000;;		plugin "github.com/gogo/protobuf/protoc-gen-gogo/plugin"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) Messages() []*Descriptor {
0000000000000000000000000000000000000000;;		return d.desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *FileDescriptor) Enums() []*EnumDescriptor {
0000000000000000000000000000000000000000;;		return d.enum
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Descriptor) IsGroup() bool {
0000000000000000000000000000000000000000;;		return d.group
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) IsGroup(field *descriptor.FieldDescriptorProto) bool {
0000000000000000000000000000000000000000;;		if d, ok := g.typeNameToObject[field.GetTypeName()].(*Descriptor); ok {
0000000000000000000000000000000000000000;;			return d.IsGroup()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) TypeNameByObject(typeName string) Object {
0000000000000000000000000000000000000000;;		o, ok := g.typeNameToObject[typeName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			g.Fail("can't find object with type", typeName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return o
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) OneOfTypeName(message *Descriptor, field *descriptor.FieldDescriptorProto) string {
0000000000000000000000000000000000000000;;		typeName := message.TypeName()
0000000000000000000000000000000000000000;;		ccTypeName := CamelCaseSlice(typeName)
0000000000000000000000000000000000000000;;		fieldName := g.GetOneOfFieldName(message, field)
0000000000000000000000000000000000000000;;		tname := ccTypeName + "_" + fieldName
0000000000000000000000000000000000000000;;		// It is possible for this to collide with a message or enum
0000000000000000000000000000000000000000;;		// nested in this message. Check for collisions.
0000000000000000000000000000000000000000;;		ok := true
0000000000000000000000000000000000000000;;		for _, desc := range message.nested {
0000000000000000000000000000000000000000;;			if strings.Join(desc.TypeName(), "_") == tname {
0000000000000000000000000000000000000000;;				ok = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, enum := range message.enums {
0000000000000000000000000000000000000000;;			if strings.Join(enum.TypeName(), "_") == tname {
0000000000000000000000000000000000000000;;				ok = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			tname += "_"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tname
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PluginImports interface {
0000000000000000000000000000000000000000;;		NewImport(pkg string) Single
0000000000000000000000000000000000000000;;		GenerateImports(file *FileDescriptor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pluginImports struct {
0000000000000000000000000000000000000000;;		generator *Generator
0000000000000000000000000000000000000000;;		singles   []Single
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewPluginImports(generator *Generator) *pluginImports {
0000000000000000000000000000000000000000;;		return &pluginImports{generator, make([]Single, 0)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *pluginImports) NewImport(pkg string) Single {
0000000000000000000000000000000000000000;;		imp := newImportedPackage(this.generator.ImportPrefix, pkg)
0000000000000000000000000000000000000000;;		this.singles = append(this.singles, imp)
0000000000000000000000000000000000000000;;		return imp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *pluginImports) GenerateImports(file *FileDescriptor) {
0000000000000000000000000000000000000000;;		for _, s := range this.singles {
0000000000000000000000000000000000000000;;			if s.IsUsed() {
0000000000000000000000000000000000000000;;				this.generator.PrintImport(s.Name(), s.Location())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Single interface {
0000000000000000000000000000000000000000;;		Use() string
0000000000000000000000000000000000000000;;		IsUsed() bool
0000000000000000000000000000000000000000;;		Name() string
0000000000000000000000000000000000000000;;		Location() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type importedPackage struct {
0000000000000000000000000000000000000000;;		used         bool
0000000000000000000000000000000000000000;;		pkg          string
0000000000000000000000000000000000000000;;		name         string
0000000000000000000000000000000000000000;;		importPrefix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newImportedPackage(importPrefix, pkg string) *importedPackage {
0000000000000000000000000000000000000000;;		return &importedPackage{
0000000000000000000000000000000000000000;;			pkg:          pkg,
0000000000000000000000000000000000000000;;			importPrefix: importPrefix,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *importedPackage) Use() string {
0000000000000000000000000000000000000000;;		if !this.used {
0000000000000000000000000000000000000000;;			this.name = RegisterUniquePackageName(this.pkg, nil)
0000000000000000000000000000000000000000;;			this.used = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return this.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *importedPackage) IsUsed() bool {
0000000000000000000000000000000000000000;;		return this.used
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *importedPackage) Name() string {
0000000000000000000000000000000000000000;;		return this.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (this *importedPackage) Location() string {
0000000000000000000000000000000000000000;;		return this.importPrefix + this.pkg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) GetFieldName(message *Descriptor, field *descriptor.FieldDescriptorProto) string {
0000000000000000000000000000000000000000;;		goTyp, _ := g.GoType(message, field)
0000000000000000000000000000000000000000;;		fieldname := CamelCase(*field.Name)
0000000000000000000000000000000000000000;;		if gogoproto.IsCustomName(field) {
0000000000000000000000000000000000000000;;			fieldname = gogoproto.GetCustomName(field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gogoproto.IsEmbed(field) {
0000000000000000000000000000000000000000;;			fieldname = EmbedFieldName(goTyp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if field.OneofIndex != nil {
0000000000000000000000000000000000000000;;			fieldname = message.OneofDecl[int(*field.OneofIndex)].GetName()
0000000000000000000000000000000000000000;;			fieldname = CamelCase(fieldname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, f := range methodNames {
0000000000000000000000000000000000000000;;			if f == fieldname {
0000000000000000000000000000000000000000;;				return fieldname + "_"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !gogoproto.IsProtoSizer(message.file, message.DescriptorProto) {
0000000000000000000000000000000000000000;;			if fieldname == "Size" {
0000000000000000000000000000000000000000;;				return fieldname + "_"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fieldname
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) GetOneOfFieldName(message *Descriptor, field *descriptor.FieldDescriptorProto) string {
0000000000000000000000000000000000000000;;		goTyp, _ := g.GoType(message, field)
0000000000000000000000000000000000000000;;		fieldname := CamelCase(*field.Name)
0000000000000000000000000000000000000000;;		if gogoproto.IsCustomName(field) {
0000000000000000000000000000000000000000;;			fieldname = gogoproto.GetCustomName(field)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if gogoproto.IsEmbed(field) {
0000000000000000000000000000000000000000;;			fieldname = EmbedFieldName(goTyp)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, f := range methodNames {
0000000000000000000000000000000000000000;;			if f == fieldname {
0000000000000000000000000000000000000000;;				return fieldname + "_"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !gogoproto.IsProtoSizer(message.file, message.DescriptorProto) {
0000000000000000000000000000000000000000;;			if fieldname == "Size" {
0000000000000000000000000000000000000000;;				return fieldname + "_"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fieldname
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) IsMap(field *descriptor.FieldDescriptorProto) bool {
0000000000000000000000000000000000000000;;		if !field.IsMessage() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		byName := g.ObjectNamed(field.GetTypeName())
0000000000000000000000000000000000000000;;		desc, ok := byName.(*Descriptor)
0000000000000000000000000000000000000000;;		if byName == nil || !ok || !desc.GetOptions().GetMapEntry() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) GetMapKeyField(field, keyField *descriptor.FieldDescriptorProto) *descriptor.FieldDescriptorProto {
0000000000000000000000000000000000000000;;		if !gogoproto.IsCastKey(field) {
0000000000000000000000000000000000000000;;			return keyField
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyField = proto.Clone(keyField).(*descriptor.FieldDescriptorProto)
0000000000000000000000000000000000000000;;		if keyField.Options == nil {
0000000000000000000000000000000000000000;;			keyField.Options = &descriptor.FieldOptions{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyType := gogoproto.GetCastKey(field)
0000000000000000000000000000000000000000;;		if err := proto.SetExtension(keyField.Options, gogoproto.E_Casttype, &keyType); err != nil {
0000000000000000000000000000000000000000;;			g.Fail(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keyField
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) GetMapValueField(field, valField *descriptor.FieldDescriptorProto) *descriptor.FieldDescriptorProto {
0000000000000000000000000000000000000000;;		if gogoproto.IsCustomType(field) && gogoproto.IsCastValue(field) {
0000000000000000000000000000000000000000;;			g.Fail("cannot have a customtype and casttype: ", field.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		valField = proto.Clone(valField).(*descriptor.FieldDescriptorProto)
0000000000000000000000000000000000000000;;		if valField.Options == nil {
0000000000000000000000000000000000000000;;			valField.Options = &descriptor.FieldOptions{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stdtime := gogoproto.IsStdTime(field)
0000000000000000000000000000000000000000;;		if stdtime {
0000000000000000000000000000000000000000;;			if err := proto.SetExtension(valField.Options, gogoproto.E_Stdtime, &stdtime); err != nil {
0000000000000000000000000000000000000000;;				g.Fail(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stddur := gogoproto.IsStdDuration(field)
0000000000000000000000000000000000000000;;		if stddur {
0000000000000000000000000000000000000000;;			if err := proto.SetExtension(valField.Options, gogoproto.E_Stdduration, &stddur); err != nil {
0000000000000000000000000000000000000000;;				g.Fail(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if valType := gogoproto.GetCastValue(field); len(valType) > 0 {
0000000000000000000000000000000000000000;;			if err := proto.SetExtension(valField.Options, gogoproto.E_Casttype, &valType); err != nil {
0000000000000000000000000000000000000000;;				g.Fail(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if valType := gogoproto.GetCustomType(field); len(valType) > 0 {
0000000000000000000000000000000000000000;;			if err := proto.SetExtension(valField.Options, gogoproto.E_Customtype, &valType); err != nil {
0000000000000000000000000000000000000000;;				g.Fail(err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nullable := gogoproto.IsNullable(field)
0000000000000000000000000000000000000000;;		if err := proto.SetExtension(valField.Options, gogoproto.E_Nullable, &nullable); err != nil {
0000000000000000000000000000000000000000;;			g.Fail(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return valField
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoMapValueTypes returns the map value Go type and the alias map value Go type (for casting), taking into
0000000000000000000000000000000000000000;;	// account whether the map is nullable or the value is a message.
0000000000000000000000000000000000000000;;	func GoMapValueTypes(mapField, valueField *descriptor.FieldDescriptorProto, goValueType, goValueAliasType string) (nullable bool, outGoType string, outGoAliasType string) {
0000000000000000000000000000000000000000;;		nullable = gogoproto.IsNullable(mapField) && (valueField.IsMessage() || gogoproto.IsCustomType(mapField))
0000000000000000000000000000000000000000;;		if nullable {
0000000000000000000000000000000000000000;;			// ensure the non-aliased Go value type is a pointer for consistency
0000000000000000000000000000000000000000;;			if strings.HasPrefix(goValueType, "*") {
0000000000000000000000000000000000000000;;				outGoType = goValueType
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				outGoType = "*" + goValueType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			outGoAliasType = goValueAliasType
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			outGoType = strings.Replace(goValueType, "*", "", 1)
0000000000000000000000000000000000000000;;			outGoAliasType = strings.Replace(goValueAliasType, "*", "", 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GoTypeToName(goTyp string) string {
0000000000000000000000000000000000000000;;		return strings.Replace(strings.Replace(goTyp, "*", "", -1), "[]", "", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func EmbedFieldName(goTyp string) string {
0000000000000000000000000000000000000000;;		goTyp = GoTypeToName(goTyp)
0000000000000000000000000000000000000000;;		goTyps := strings.Split(goTyp, ".")
0000000000000000000000000000000000000000;;		if len(goTyps) == 1 {
0000000000000000000000000000000000000000;;			return goTyp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(goTyps) == 2 {
0000000000000000000000000000000000000000;;			return goTyps[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("unreachable")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) GeneratePlugin(p Plugin) {
0000000000000000000000000000000000000000;;		plugins = []Plugin{p}
0000000000000000000000000000000000000000;;		p.Init(g)
0000000000000000000000000000000000000000;;		// Generate the output. The generator runs for every file, even the files
0000000000000000000000000000000000000000;;		// that we don't generate output for, so that we can collate the full list
0000000000000000000000000000000000000000;;		// of exported symbols to support public imports.
0000000000000000000000000000000000000000;;		genFileMap := make(map[*FileDescriptor]bool, len(g.genFiles))
0000000000000000000000000000000000000000;;		for _, file := range g.genFiles {
0000000000000000000000000000000000000000;;			genFileMap[file] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, file := range g.allFiles {
0000000000000000000000000000000000000000;;			g.Reset()
0000000000000000000000000000000000000000;;			g.writeOutput = genFileMap[file]
0000000000000000000000000000000000000000;;			g.generatePlugin(file, p)
0000000000000000000000000000000000000000;;			if !g.writeOutput {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			g.Response.File = append(g.Response.File, &plugin.CodeGeneratorResponse_File{
0000000000000000000000000000000000000000;;				Name:    proto.String(file.goFileName()),
0000000000000000000000000000000000000000;;				Content: proto.String(g.String()),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) SetFile(file *descriptor.FileDescriptorProto) {
0000000000000000000000000000000000000000;;		g.file = g.FileOf(file)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) generatePlugin(file *FileDescriptor, p Plugin) {
0000000000000000000000000000000000000000;;		g.writtenImports = make(map[string]bool)
0000000000000000000000000000000000000000;;		g.file = g.FileOf(file.FileDescriptorProto)
0000000000000000000000000000000000000000;;		g.usedPackages = make(map[string]bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Run the plugins before the imports so we know which imports are necessary.
0000000000000000000000000000000000000000;;		p.Generate(file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate header and imports last, though they appear first in the output.
0000000000000000000000000000000000000000;;		rem := g.Buffer
0000000000000000000000000000000000000000;;		g.Buffer = new(bytes.Buffer)
0000000000000000000000000000000000000000;;		g.generateHeader()
0000000000000000000000000000000000000000;;		p.GenerateImports(g.file)
0000000000000000000000000000000000000000;;		g.generateImports()
0000000000000000000000000000000000000000;;		if !g.writeOutput {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Write(rem.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reformat generated code.
0000000000000000000000000000000000000000;;		contents := string(g.Buffer.Bytes())
0000000000000000000000000000000000000000;;		fset := token.NewFileSet()
0000000000000000000000000000000000000000;;		ast, err := parser.ParseFile(fset, "", g, parser.ParseComments)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			g.Fail("bad Go source code was generated:", contents, err.Error())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		g.Reset()
0000000000000000000000000000000000000000;;		err = (&printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8}).Fprint(g, fset, ast)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			g.Fail("generated Go source code could not be reformatted:", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetCustomType(field *descriptor.FieldDescriptorProto) (packageName string, typ string, err error) {
0000000000000000000000000000000000000000;;		return getCustomType(field)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCustomType(field *descriptor.FieldDescriptorProto) (packageName string, typ string, err error) {
0000000000000000000000000000000000000000;;		if field.Options != nil {
0000000000000000000000000000000000000000;;			var v interface{}
0000000000000000000000000000000000000000;;			v, err = proto.GetExtension(field.Options, gogoproto.E_Customtype)
0000000000000000000000000000000000000000;;			if err == nil && v.(*string) != nil {
0000000000000000000000000000000000000000;;				ctype := *(v.(*string))
0000000000000000000000000000000000000000;;				packageName, typ = splitCPackageType(ctype)
0000000000000000000000000000000000000000;;				return packageName, typ, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func splitCPackageType(ctype string) (packageName string, typ string) {
0000000000000000000000000000000000000000;;		ss := strings.Split(ctype, ".")
0000000000000000000000000000000000000000;;		if len(ss) == 1 {
0000000000000000000000000000000000000000;;			return "", ctype
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		packageName = strings.Join(ss[0:len(ss)-1], ".")
0000000000000000000000000000000000000000;;		typeName := ss[len(ss)-1]
0000000000000000000000000000000000000000;;		importStr := strings.Map(badToUnderscore, packageName)
0000000000000000000000000000000000000000;;		typ = importStr + "." + typeName
0000000000000000000000000000000000000000;;		return packageName, typ
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCastType(field *descriptor.FieldDescriptorProto) (packageName string, typ string, err error) {
0000000000000000000000000000000000000000;;		if field.Options != nil {
0000000000000000000000000000000000000000;;			var v interface{}
0000000000000000000000000000000000000000;;			v, err = proto.GetExtension(field.Options, gogoproto.E_Casttype)
0000000000000000000000000000000000000000;;			if err == nil && v.(*string) != nil {
0000000000000000000000000000000000000000;;				ctype := *(v.(*string))
0000000000000000000000000000000000000000;;				packageName, typ = splitCPackageType(ctype)
0000000000000000000000000000000000000000;;				return packageName, typ, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FileName(file *FileDescriptor) string {
0000000000000000000000000000000000000000;;		fname := path.Base(file.FileDescriptorProto.GetName())
0000000000000000000000000000000000000000;;		fname = strings.Replace(fname, ".proto", "", -1)
0000000000000000000000000000000000000000;;		fname = strings.Replace(fname, "-", "_", -1)
0000000000000000000000000000000000000000;;		fname = strings.Replace(fname, ".", "_", -1)
0000000000000000000000000000000000000000;;		return CamelCase(fname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) AllFiles() *descriptor.FileDescriptorSet {
0000000000000000000000000000000000000000;;		set := &descriptor.FileDescriptorSet{}
0000000000000000000000000000000000000000;;		set.File = make([]*descriptor.FileDescriptorProto, len(g.allFiles))
0000000000000000000000000000000000000000;;		for i := range g.allFiles {
0000000000000000000000000000000000000000;;			set.File[i] = g.allFiles[i].FileDescriptorProto
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return set
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Descriptor) Path() string {
0000000000000000000000000000000000000000;;		return d.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (g *Generator) useTypes() string {
0000000000000000000000000000000000000000;;		pkg := strings.Map(badToUnderscore, "github.com/gogo/protobuf/types")
0000000000000000000000000000000000000000;;		g.customImports = append(g.customImports, "github.com/gogo/protobuf/types")
0000000000000000000000000000000000000000;;		return pkg
0000000000000000000000000000000000000000;;	}
