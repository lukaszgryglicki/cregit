0000000000000000000000000000000000000000;;	// Go support for Protocol Buffers - Google's data interchange format
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright 2016 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// https://github.com/golang/protobuf
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Redistribution and use in source and binary forms, with or without
0000000000000000000000000000000000000000;;	// modification, are permitted provided that the following conditions are
0000000000000000000000000000000000000000;;	// met:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     * Redistributions of source code must retain the above copyright
0000000000000000000000000000000000000000;;	// notice, this list of conditions and the following disclaimer.
0000000000000000000000000000000000000000;;	//     * Redistributions in binary form must reproduce the above
0000000000000000000000000000000000000000;;	// copyright notice, this list of conditions and the following disclaimer
0000000000000000000000000000000000000000;;	// in the documentation and/or other materials provided with the
0000000000000000000000000000000000000000;;	// distribution.
0000000000000000000000000000000000000000;;	//     * Neither the name of Google Inc. nor the names of its
0000000000000000000000000000000000000000;;	// contributors may be used to endorse or promote products derived from
0000000000000000000000000000000000000000;;	// this software without specific prior written permission.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
0000000000000000000000000000000000000000;;	// "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
0000000000000000000000000000000000000000;;	// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
0000000000000000000000000000000000000000;;	// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
0000000000000000000000000000000000000000;;	// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
0000000000000000000000000000000000000000;;	// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
0000000000000000000000000000000000000000;;	// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
0000000000000000000000000000000000000000;;	// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
0000000000000000000000000000000000000000;;	// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
0000000000000000000000000000000000000000;;	// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	// Package descriptor provides functions for obtaining protocol buffer
0000000000000000000000000000000000000000;;	// descriptors for generated Go types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// These functions cannot go in package proto because they depend on the
0000000000000000000000000000000000000000;;	// generated protobuf descriptor messages, which themselves depend on proto.
0000000000000000000000000000000000000000;;	package descriptor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gogo/protobuf/proto"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractFile extracts a FileDescriptorProto from a gzip'd buffer.
0000000000000000000000000000000000000000;;	func extractFile(gz []byte) (*FileDescriptorProto, error) {
0000000000000000000000000000000000000000;;		r, err := gzip.NewReader(bytes.NewReader(gz))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to open gzip reader: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer r.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := ioutil.ReadAll(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to uncompress descriptor: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fd := new(FileDescriptorProto)
0000000000000000000000000000000000000000;;		if err := proto.Unmarshal(b, fd); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("malformed FileDescriptorProto: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fd, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Message is a proto.Message with a method to return its descriptor.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Message types generated by the protocol compiler always satisfy
0000000000000000000000000000000000000000;;	// the Message interface.
0000000000000000000000000000000000000000;;	type Message interface {
0000000000000000000000000000000000000000;;		proto.Message
0000000000000000000000000000000000000000;;		Descriptor() ([]byte, []int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForMessage returns a FileDescriptorProto and a DescriptorProto from within it
0000000000000000000000000000000000000000;;	// describing the given message.
0000000000000000000000000000000000000000;;	func ForMessage(msg Message) (fd *FileDescriptorProto, md *DescriptorProto) {
0000000000000000000000000000000000000000;;		gz, path := msg.Descriptor()
0000000000000000000000000000000000000000;;		fd, err := extractFile(gz)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("invalid FileDescriptorProto for %T: %v", msg, err))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		md = fd.MessageType[path[0]]
0000000000000000000000000000000000000000;;		for _, i := range path[1:] {
0000000000000000000000000000000000000000;;			md = md.NestedType[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fd, md
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Is this field a scalar numeric type?
0000000000000000000000000000000000000000;;	func (field *FieldDescriptorProto) IsScalar() bool {
0000000000000000000000000000000000000000;;		if field.Type == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch *field.Type {
0000000000000000000000000000000000000000;;		case FieldDescriptorProto_TYPE_DOUBLE,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_FLOAT,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_INT64,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_UINT64,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_INT32,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_FIXED64,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_FIXED32,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_BOOL,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_UINT32,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_ENUM,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_SFIXED32,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_SFIXED64,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_SINT32,
0000000000000000000000000000000000000000;;			FieldDescriptorProto_TYPE_SINT64:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
