0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyAlgorithm represents a key management algorithm.
0000000000000000000000000000000000000000;;	type KeyAlgorithm string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureAlgorithm represents a signature (or MAC) algorithm.
0000000000000000000000000000000000000000;;	type SignatureAlgorithm string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContentEncryption represents a content encryption algorithm.
0000000000000000000000000000000000000000;;	type ContentEncryption string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompressionAlgorithm represents an algorithm used for plaintext compression.
0000000000000000000000000000000000000000;;	type CompressionAlgorithm string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrCryptoFailure represents an error in cryptographic primitive. This
0000000000000000000000000000000000000000;;		// occurs when, for example, a message had an invalid authentication tag or
0000000000000000000000000000000000000000;;		// could not be decrypted.
0000000000000000000000000000000000000000;;		ErrCryptoFailure = errors.New("square/go-jose: error in cryptographic primitive")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrUnsupportedAlgorithm indicates that a selected algorithm is not
0000000000000000000000000000000000000000;;		// supported. This occurs when trying to instantiate an encrypter for an
0000000000000000000000000000000000000000;;		// algorithm that is not yet implemented.
0000000000000000000000000000000000000000;;		ErrUnsupportedAlgorithm = errors.New("square/go-jose: unknown/unsupported algorithm")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrUnsupportedKeyType indicates that the given key type/format is not
0000000000000000000000000000000000000000;;		// supported. This occurs when trying to instantiate an encrypter and passing
0000000000000000000000000000000000000000;;		// it a key of an unrecognized type or with unsupported parameters, such as
0000000000000000000000000000000000000000;;		// an RSA private key with more than two primes.
0000000000000000000000000000000000000000;;		ErrUnsupportedKeyType = errors.New("square/go-jose: unsupported key type/format")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrNotSupported serialization of object is not supported. This occurs when
0000000000000000000000000000000000000000;;		// trying to compact-serialize an object which can't be represented in
0000000000000000000000000000000000000000;;		// compact form.
0000000000000000000000000000000000000000;;		ErrNotSupported = errors.New("square/go-jose: compact serialization not supported for object")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrUnprotectedNonce indicates that while parsing a JWS or JWE object, a
0000000000000000000000000000000000000000;;		// nonce header parameter was included in an unprotected header object.
0000000000000000000000000000000000000000;;		ErrUnprotectedNonce = errors.New("square/go-jose: Nonce parameter included in unprotected header")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key management algorithms
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		RSA1_5             = KeyAlgorithm("RSA1_5")             // RSA-PKCS1v1.5
0000000000000000000000000000000000000000;;		RSA_OAEP           = KeyAlgorithm("RSA-OAEP")           // RSA-OAEP-SHA1
0000000000000000000000000000000000000000;;		RSA_OAEP_256       = KeyAlgorithm("RSA-OAEP-256")       // RSA-OAEP-SHA256
0000000000000000000000000000000000000000;;		A128KW             = KeyAlgorithm("A128KW")             // AES key wrap (128)
0000000000000000000000000000000000000000;;		A192KW             = KeyAlgorithm("A192KW")             // AES key wrap (192)
0000000000000000000000000000000000000000;;		A256KW             = KeyAlgorithm("A256KW")             // AES key wrap (256)
0000000000000000000000000000000000000000;;		DIRECT             = KeyAlgorithm("dir")                // Direct encryption
0000000000000000000000000000000000000000;;		ECDH_ES            = KeyAlgorithm("ECDH-ES")            // ECDH-ES
0000000000000000000000000000000000000000;;		ECDH_ES_A128KW     = KeyAlgorithm("ECDH-ES+A128KW")     // ECDH-ES + AES key wrap (128)
0000000000000000000000000000000000000000;;		ECDH_ES_A192KW     = KeyAlgorithm("ECDH-ES+A192KW")     // ECDH-ES + AES key wrap (192)
0000000000000000000000000000000000000000;;		ECDH_ES_A256KW     = KeyAlgorithm("ECDH-ES+A256KW")     // ECDH-ES + AES key wrap (256)
0000000000000000000000000000000000000000;;		A128GCMKW          = KeyAlgorithm("A128GCMKW")          // AES-GCM key wrap (128)
0000000000000000000000000000000000000000;;		A192GCMKW          = KeyAlgorithm("A192GCMKW")          // AES-GCM key wrap (192)
0000000000000000000000000000000000000000;;		A256GCMKW          = KeyAlgorithm("A256GCMKW")          // AES-GCM key wrap (256)
0000000000000000000000000000000000000000;;		PBES2_HS256_A128KW = KeyAlgorithm("PBES2-HS256+A128KW") // PBES2 + HMAC-SHA256 + AES key wrap (128)
0000000000000000000000000000000000000000;;		PBES2_HS384_A192KW = KeyAlgorithm("PBES2-HS384+A192KW") // PBES2 + HMAC-SHA384 + AES key wrap (192)
0000000000000000000000000000000000000000;;		PBES2_HS512_A256KW = KeyAlgorithm("PBES2-HS512+A256KW") // PBES2 + HMAC-SHA512 + AES key wrap (256)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signature algorithms
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		HS256 = SignatureAlgorithm("HS256") // HMAC using SHA-256
0000000000000000000000000000000000000000;;		HS384 = SignatureAlgorithm("HS384") // HMAC using SHA-384
0000000000000000000000000000000000000000;;		HS512 = SignatureAlgorithm("HS512") // HMAC using SHA-512
0000000000000000000000000000000000000000;;		RS256 = SignatureAlgorithm("RS256") // RSASSA-PKCS-v1.5 using SHA-256
0000000000000000000000000000000000000000;;		RS384 = SignatureAlgorithm("RS384") // RSASSA-PKCS-v1.5 using SHA-384
0000000000000000000000000000000000000000;;		RS512 = SignatureAlgorithm("RS512") // RSASSA-PKCS-v1.5 using SHA-512
0000000000000000000000000000000000000000;;		ES256 = SignatureAlgorithm("ES256") // ECDSA using P-256 and SHA-256
0000000000000000000000000000000000000000;;		ES384 = SignatureAlgorithm("ES384") // ECDSA using P-384 and SHA-384
0000000000000000000000000000000000000000;;		ES512 = SignatureAlgorithm("ES512") // ECDSA using P-521 and SHA-512
0000000000000000000000000000000000000000;;		PS256 = SignatureAlgorithm("PS256") // RSASSA-PSS using SHA256 and MGF1-SHA256
0000000000000000000000000000000000000000;;		PS384 = SignatureAlgorithm("PS384") // RSASSA-PSS using SHA384 and MGF1-SHA384
0000000000000000000000000000000000000000;;		PS512 = SignatureAlgorithm("PS512") // RSASSA-PSS using SHA512 and MGF1-SHA512
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Content encryption algorithms
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		A128CBC_HS256 = ContentEncryption("A128CBC-HS256") // AES-CBC + HMAC-SHA256 (128)
0000000000000000000000000000000000000000;;		A192CBC_HS384 = ContentEncryption("A192CBC-HS384") // AES-CBC + HMAC-SHA384 (192)
0000000000000000000000000000000000000000;;		A256CBC_HS512 = ContentEncryption("A256CBC-HS512") // AES-CBC + HMAC-SHA512 (256)
0000000000000000000000000000000000000000;;		A128GCM       = ContentEncryption("A128GCM")       // AES-GCM (128)
0000000000000000000000000000000000000000;;		A192GCM       = ContentEncryption("A192GCM")       // AES-GCM (192)
0000000000000000000000000000000000000000;;		A256GCM       = ContentEncryption("A256GCM")       // AES-GCM (256)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compression algorithms
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		NONE    = CompressionAlgorithm("")    // No compression
0000000000000000000000000000000000000000;;		DEFLATE = CompressionAlgorithm("DEF") // DEFLATE (RFC 1951)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rawHeader represents the JOSE header for JWE/JWS objects (used for parsing).
0000000000000000000000000000000000000000;;	type rawHeader struct {
0000000000000000000000000000000000000000;;		Alg   string               `json:"alg,omitempty"`
0000000000000000000000000000000000000000;;		Enc   ContentEncryption    `json:"enc,omitempty"`
0000000000000000000000000000000000000000;;		Zip   CompressionAlgorithm `json:"zip,omitempty"`
0000000000000000000000000000000000000000;;		Crit  []string             `json:"crit,omitempty"`
0000000000000000000000000000000000000000;;		Apu   *byteBuffer          `json:"apu,omitempty"`
0000000000000000000000000000000000000000;;		Apv   *byteBuffer          `json:"apv,omitempty"`
0000000000000000000000000000000000000000;;		Epk   *JsonWebKey          `json:"epk,omitempty"`
0000000000000000000000000000000000000000;;		Iv    *byteBuffer          `json:"iv,omitempty"`
0000000000000000000000000000000000000000;;		Tag   *byteBuffer          `json:"tag,omitempty"`
0000000000000000000000000000000000000000;;		Jwk   *JsonWebKey          `json:"jwk,omitempty"`
0000000000000000000000000000000000000000;;		Kid   string               `json:"kid,omitempty"`
0000000000000000000000000000000000000000;;		Nonce string               `json:"nonce,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JoseHeader represents the read-only JOSE header for JWE/JWS objects.
0000000000000000000000000000000000000000;;	type JoseHeader struct {
0000000000000000000000000000000000000000;;		KeyID      string
0000000000000000000000000000000000000000;;		JsonWebKey *JsonWebKey
0000000000000000000000000000000000000000;;		Algorithm  string
0000000000000000000000000000000000000000;;		Nonce      string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sanitized produces a cleaned-up header object from the raw JSON.
0000000000000000000000000000000000000000;;	func (parsed rawHeader) sanitized() JoseHeader {
0000000000000000000000000000000000000000;;		return JoseHeader{
0000000000000000000000000000000000000000;;			KeyID:      parsed.Kid,
0000000000000000000000000000000000000000;;			JsonWebKey: parsed.Jwk,
0000000000000000000000000000000000000000;;			Algorithm:  parsed.Alg,
0000000000000000000000000000000000000000;;			Nonce:      parsed.Nonce,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge headers from src into dst, giving precedence to headers from l.
0000000000000000000000000000000000000000;;	func (dst *rawHeader) merge(src *rawHeader) {
0000000000000000000000000000000000000000;;		if src == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dst.Alg == "" {
0000000000000000000000000000000000000000;;			dst.Alg = src.Alg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Enc == "" {
0000000000000000000000000000000000000000;;			dst.Enc = src.Enc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Zip == "" {
0000000000000000000000000000000000000000;;			dst.Zip = src.Zip
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Crit == nil {
0000000000000000000000000000000000000000;;			dst.Crit = src.Crit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Crit == nil {
0000000000000000000000000000000000000000;;			dst.Crit = src.Crit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Apu == nil {
0000000000000000000000000000000000000000;;			dst.Apu = src.Apu
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Apv == nil {
0000000000000000000000000000000000000000;;			dst.Apv = src.Apv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Epk == nil {
0000000000000000000000000000000000000000;;			dst.Epk = src.Epk
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Iv == nil {
0000000000000000000000000000000000000000;;			dst.Iv = src.Iv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Tag == nil {
0000000000000000000000000000000000000000;;			dst.Tag = src.Tag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Kid == "" {
0000000000000000000000000000000000000000;;			dst.Kid = src.Kid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Jwk == nil {
0000000000000000000000000000000000000000;;			dst.Jwk = src.Jwk
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.Nonce == "" {
0000000000000000000000000000000000000000;;			dst.Nonce = src.Nonce
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get JOSE name of curve
0000000000000000000000000000000000000000;;	func curveName(crv elliptic.Curve) (string, error) {
0000000000000000000000000000000000000000;;		switch crv {
0000000000000000000000000000000000000000;;		case elliptic.P256():
0000000000000000000000000000000000000000;;			return "P-256", nil
0000000000000000000000000000000000000000;;		case elliptic.P384():
0000000000000000000000000000000000000000;;			return "P-384", nil
0000000000000000000000000000000000000000;;		case elliptic.P521():
0000000000000000000000000000000000000000;;			return "P-521", nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("square/go-jose: unsupported/unknown elliptic curve")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get size of curve in bytes
0000000000000000000000000000000000000000;;	func curveSize(crv elliptic.Curve) int {
0000000000000000000000000000000000000000;;		bits := crv.Params().BitSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		div := bits / 8
0000000000000000000000000000000000000000;;		mod := bits % 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mod == 0 {
0000000000000000000000000000000000000000;;			return div
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return div + 1
0000000000000000000000000000000000000000;;	}
