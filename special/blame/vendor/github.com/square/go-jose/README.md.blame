0000000000000000000000000000000000000000;;	# Go JOSE 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![godoc](http://img.shields.io/badge/godoc-reference-blue.svg?style=flat)](https://godoc.org/gopkg.in/square/go-jose.v1) [![license](http://img.shields.io/badge/license-apache_2.0-blue.svg?style=flat)](https://raw.githubusercontent.com/square/go-jose/master/LICENSE)
0000000000000000000000000000000000000000;;	[![release](https://img.shields.io/github/release/square/go-jose.svg?style=flat)](https://github.com/square/go-jose/releases)
0000000000000000000000000000000000000000;;	[![build](https://travis-ci.org/square/go-jose.svg?branch=master)](https://travis-ci.org/square/go-jose)
0000000000000000000000000000000000000000;;	[![coverage](https://coveralls.io/repos/github/square/go-jose/badge.svg?branch=master)](https://coveralls.io/r/square/go-jose)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Package jose aims to provide an implementation of the Javascript Object Signing
0000000000000000000000000000000000000000;;	and Encryption set of standards. For the moment, it mainly focuses on encryption
0000000000000000000000000000000000000000;;	and signing based on the JSON Web Encryption and JSON Web Signature standards.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Disclaimer**: This library contains encryption software that is subject to
0000000000000000000000000000000000000000;;	the U.S. Export Administration Regulations. You may not export, re-export,
0000000000000000000000000000000000000000;;	transfer or download this code or any part of it in violation of any United
0000000000000000000000000000000000000000;;	States law, directive or regulation. In particular this software may not be
0000000000000000000000000000000000000000;;	exported or re-exported in any form or on any media to Iran, North Sudan,
0000000000000000000000000000000000000000;;	Syria, Cuba, or North Korea, or to denied persons or entities mentioned on any
0000000000000000000000000000000000000000;;	US maintained blocked list.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Overview
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The implementation follows the
0000000000000000000000000000000000000000;;	[JSON Web Encryption](http://dx.doi.org/10.17487/RFC7516)
0000000000000000000000000000000000000000;;	standard (RFC 7516) and
0000000000000000000000000000000000000000;;	[JSON Web Signature](http://dx.doi.org/10.17487/RFC7515)
0000000000000000000000000000000000000000;;	standard (RFC 7515). Tables of supported algorithms are shown below.
0000000000000000000000000000000000000000;;	The library supports both the compact and full serialization formats, and has
0000000000000000000000000000000000000000;;	optional support for multiple recipients. It also comes with a small
0000000000000000000000000000000000000000;;	command-line utility
0000000000000000000000000000000000000000;;	([`jose-util`](https://github.com/square/go-jose/tree/master/jose-util))
0000000000000000000000000000000000000000;;	for dealing with JOSE messages in a shell.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	**Note**: We use a forked version of the `encoding/json` package from the Go
0000000000000000000000000000000000000000;;	standard library which uses case-sensitive matching for member names (instead
0000000000000000000000000000000000000000;;	of [case-insensitive matching](https://www.ietf.org/mail-archive/web/json/current/msg03763.html)).
0000000000000000000000000000000000000000;;	This is to avoid differences in interpretation of messages between go-jose and
0000000000000000000000000000000000000000;;	libraries in other languages. If you do not like this behavior, you can use the
0000000000000000000000000000000000000000;;	`std_json` build tag to disable it (though we do not recommend doing so).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Versions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	We use [gopkg.in](https://gopkg.in) for versioning.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[Version 1](https://gopkg.in/square/go-jose.v1) is the current stable version:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    import "gopkg.in/square/go-jose.v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The interface for [go-jose.v1](https://gopkg.in/square/go-jose.v1) will remain
0000000000000000000000000000000000000000;;	backwards compatible. We're currently sketching out ideas for a new version, to
0000000000000000000000000000000000000000;;	clean up the interface a bit. If you have ideas or feature requests [please let
0000000000000000000000000000000000000000;;	us know](https://github.com/square/go-jose/issues/64)!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Supported algorithms
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See below for a table of supported algorithms. Algorithm identifiers match
0000000000000000000000000000000000000000;;	the names in the
0000000000000000000000000000000000000000;;	[JSON Web Algorithms](http://dx.doi.org/10.17487/RFC7518)
0000000000000000000000000000000000000000;;	standard where possible. The
0000000000000000000000000000000000000000;;	[Godoc reference](https://godoc.org/github.com/square/go-jose#pkg-constants)
0000000000000000000000000000000000000000;;	has a list of constants.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 Key encryption             | Algorithm identifier(s)
0000000000000000000000000000000000000000;;	 :------------------------- | :------------------------------
0000000000000000000000000000000000000000;;	 RSA-PKCS#1v1.5             | RSA1_5
0000000000000000000000000000000000000000;;	 RSA-OAEP                   | RSA-OAEP, RSA-OAEP-256
0000000000000000000000000000000000000000;;	 AES key wrap               | A128KW, A192KW, A256KW
0000000000000000000000000000000000000000;;	 AES-GCM key wrap           | A128GCMKW, A192GCMKW, A256GCMKW
0000000000000000000000000000000000000000;;	 ECDH-ES + AES key wrap     | ECDH-ES+A128KW, ECDH-ES+A192KW, ECDH-ES+A256KW
0000000000000000000000000000000000000000;;	 ECDH-ES (direct)           | ECDH-ES<sup>1</sup>
0000000000000000000000000000000000000000;;	 Direct encryption          | dir<sup>1</sup>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	<sup>1. Not supported in multi-recipient mode</sup>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 Signing / MAC              | Algorithm identifier(s)
0000000000000000000000000000000000000000;;	 :------------------------- | :------------------------------
0000000000000000000000000000000000000000;;	 RSASSA-PKCS#1v1.5          | RS256, RS384, RS512
0000000000000000000000000000000000000000;;	 RSASSA-PSS                 | PS256, PS384, PS512
0000000000000000000000000000000000000000;;	 HMAC                       | HS256, HS384, HS512
0000000000000000000000000000000000000000;;	 ECDSA                      | ES256, ES384, ES512
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 Content encryption         | Algorithm identifier(s)
0000000000000000000000000000000000000000;;	 :------------------------- | :------------------------------
0000000000000000000000000000000000000000;;	 AES-CBC+HMAC               | A128CBC-HS256, A192CBC-HS384, A256CBC-HS512
0000000000000000000000000000000000000000;;	 AES-GCM                    | A128GCM, A192GCM, A256GCM 
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 Compression                | Algorithm identifiers(s)
0000000000000000000000000000000000000000;;	 :------------------------- | -------------------------------
0000000000000000000000000000000000000000;;	 DEFLATE (RFC 1951)         | DEF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Supported key types
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See below for a table of supported key types. These are understood by the
0000000000000000000000000000000000000000;;	library, and can be passed to corresponding functions such as `NewEncrypter` or
0000000000000000000000000000000000000000;;	`NewSigner`. Note that if you are creating a new encrypter or signer with a
0000000000000000000000000000000000000000;;	JsonWebKey, the key id of the JsonWebKey (if present) will be added to any
0000000000000000000000000000000000000000;;	resulting messages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 Algorithm(s)               | Corresponding types
0000000000000000000000000000000000000000;;	 :------------------------- | -------------------------------
0000000000000000000000000000000000000000;;	 RSA                        | *[rsa.PublicKey](http://golang.org/pkg/crypto/rsa/#PublicKey), *[rsa.PrivateKey](http://golang.org/pkg/crypto/rsa/#PrivateKey), *[jose.JsonWebKey](https://godoc.org/github.com/square/go-jose#JsonWebKey)
0000000000000000000000000000000000000000;;	 ECDH, ECDSA                | *[ecdsa.PublicKey](http://golang.org/pkg/crypto/ecdsa/#PublicKey), *[ecdsa.PrivateKey](http://golang.org/pkg/crypto/ecdsa/#PrivateKey), *[jose.JsonWebKey](https://godoc.org/github.com/square/go-jose#JsonWebKey)
0000000000000000000000000000000000000000;;	 AES, HMAC                  | []byte, *[jose.JsonWebKey](https://godoc.org/github.com/square/go-jose#JsonWebKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Examples
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Encryption/decryption example using RSA:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```Go
0000000000000000000000000000000000000000;;	// Generate a public/private key pair to use for this example. The library
0000000000000000000000000000000000000000;;	// also provides two utility functions (LoadPublicKey and LoadPrivateKey)
0000000000000000000000000000000000000000;;	// that can be used to load keys from PEM/DER-encoded data.
0000000000000000000000000000000000000000;;	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instantiate an encrypter using RSA-OAEP with AES128-GCM. An error would
0000000000000000000000000000000000000000;;	// indicate that the selected algorithm(s) are not currently supported.
0000000000000000000000000000000000000000;;	publicKey := &privateKey.PublicKey
0000000000000000000000000000000000000000;;	encrypter, err := NewEncrypter(RSA_OAEP, A128GCM, publicKey)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypt a sample plaintext. Calling the encrypter returns an encrypted
0000000000000000000000000000000000000000;;	// JWE object, which can then be serialized for output afterwards. An error
0000000000000000000000000000000000000000;;	// would indicate a problem in an underlying cryptographic primitive.
0000000000000000000000000000000000000000;;	var plaintext = []byte("Lorem ipsum dolor sit amet")
0000000000000000000000000000000000000000;;	object, err := encrypter.Encrypt(plaintext)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serialize the encrypted object using the full serialization format.
0000000000000000000000000000000000000000;;	// Alternatively you can also use the compact format here by calling
0000000000000000000000000000000000000000;;	// object.CompactSerialize() instead.
0000000000000000000000000000000000000000;;	serialized := object.FullSerialize()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the serialized, encrypted JWE object. An error would indicate that
0000000000000000000000000000000000000000;;	// the given input did not represent a valid message.
0000000000000000000000000000000000000000;;	object, err = ParseEncrypted(serialized)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now we can decrypt and get back our original plaintext. An error here
0000000000000000000000000000000000000000;;	// would indicate the the message failed to decrypt, e.g. because the auth
0000000000000000000000000000000000000000;;	// tag was broken or the message was tampered with.
0000000000000000000000000000000000000000;;	decrypted, err := object.Decrypt(privateKey)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	fmt.Printf(string(decrypted))
0000000000000000000000000000000000000000;;	// output: Lorem ipsum dolor sit amet
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Signing/verification example using RSA:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```Go
0000000000000000000000000000000000000000;;	// Generate a public/private key pair to use for this example. The library
0000000000000000000000000000000000000000;;	// also provides two utility functions (LoadPublicKey and LoadPrivateKey)
0000000000000000000000000000000000000000;;	// that can be used to load keys from PEM/DER-encoded data.
0000000000000000000000000000000000000000;;	privateKey, err := rsa.GenerateKey(rand.Reader, 2048)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Instantiate a signer using RSASSA-PSS (SHA512) with the given private key.
0000000000000000000000000000000000000000;;	signer, err := NewSigner(PS512, privateKey)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign a sample payload. Calling the signer returns a protected JWS object,
0000000000000000000000000000000000000000;;	// which can then be serialized for output afterwards. An error would
0000000000000000000000000000000000000000;;	// indicate a problem in an underlying cryptographic primitive.
0000000000000000000000000000000000000000;;	var payload = []byte("Lorem ipsum dolor sit amet")
0000000000000000000000000000000000000000;;	object, err := signer.Sign(payload)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serialize the encrypted object using the full serialization format.
0000000000000000000000000000000000000000;;	// Alternatively you can also use the compact format here by calling
0000000000000000000000000000000000000000;;	// object.CompactSerialize() instead.
0000000000000000000000000000000000000000;;	serialized := object.FullSerialize()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the serialized, protected JWS object. An error would indicate that
0000000000000000000000000000000000000000;;	// the given input did not represent a valid message.
0000000000000000000000000000000000000000;;	object, err = ParseSigned(serialized)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now we can verify the signature on the payload. An error here would
0000000000000000000000000000000000000000;;	// indicate the the message failed to verify, e.g. because the signature was
0000000000000000000000000000000000000000;;	// broken or the message was tampered with.
0000000000000000000000000000000000000000;;	output, err := object.Verify(&privateKey.PublicKey)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	fmt.Printf(string(output))
0000000000000000000000000000000000000000;;	// output: Lorem ipsum dolor sit amet
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	More examples can be found in the [Godoc
0000000000000000000000000000000000000000;;	reference](https://godoc.org/github.com/square/go-jose) for this package. The
0000000000000000000000000000000000000000;;	[`jose-util`](https://github.com/square/go-jose/tree/master/jose-util)
0000000000000000000000000000000000000000;;	subdirectory also contains a small command-line utility which might
0000000000000000000000000000000000000000;;	be useful as an example.
