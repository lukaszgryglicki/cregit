0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/square/go-jose/json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rawJsonWebSignature represents a raw JWS JSON object. Used for parsing/serializing.
0000000000000000000000000000000000000000;;	type rawJsonWebSignature struct {
0000000000000000000000000000000000000000;;		Payload    *byteBuffer        `json:"payload,omitempty"`
0000000000000000000000000000000000000000;;		Signatures []rawSignatureInfo `json:"signatures,omitempty"`
0000000000000000000000000000000000000000;;		Protected  *byteBuffer        `json:"protected,omitempty"`
0000000000000000000000000000000000000000;;		Header     *rawHeader         `json:"header,omitempty"`
0000000000000000000000000000000000000000;;		Signature  *byteBuffer        `json:"signature,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rawSignatureInfo represents a single JWS signature over the JWS payload and protected header.
0000000000000000000000000000000000000000;;	type rawSignatureInfo struct {
0000000000000000000000000000000000000000;;		Protected *byteBuffer `json:"protected,omitempty"`
0000000000000000000000000000000000000000;;		Header    *rawHeader  `json:"header,omitempty"`
0000000000000000000000000000000000000000;;		Signature *byteBuffer `json:"signature,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JsonWebSignature represents a signed JWS object after parsing.
0000000000000000000000000000000000000000;;	type JsonWebSignature struct {
0000000000000000000000000000000000000000;;		payload    []byte
0000000000000000000000000000000000000000;;		Signatures []Signature
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signature represents a single signature over the JWS payload and protected header.
0000000000000000000000000000000000000000;;	type Signature struct {
0000000000000000000000000000000000000000;;		// Header fields, such as the signature algorithm
0000000000000000000000000000000000000000;;		Header JoseHeader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The actual signature value
0000000000000000000000000000000000000000;;		Signature []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		protected *rawHeader
0000000000000000000000000000000000000000;;		header    *rawHeader
0000000000000000000000000000000000000000;;		original  *rawSignatureInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseSigned parses a signed message in compact or full serialization format.
0000000000000000000000000000000000000000;;	func ParseSigned(input string) (*JsonWebSignature, error) {
0000000000000000000000000000000000000000;;		input = stripWhitespace(input)
0000000000000000000000000000000000000000;;		if strings.HasPrefix(input, "{") {
0000000000000000000000000000000000000000;;			return parseSignedFull(input)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseSignedCompact(input)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a header value
0000000000000000000000000000000000000000;;	func (sig Signature) mergedHeaders() rawHeader {
0000000000000000000000000000000000000000;;		out := rawHeader{}
0000000000000000000000000000000000000000;;		out.merge(sig.protected)
0000000000000000000000000000000000000000;;		out.merge(sig.header)
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compute data to be signed
0000000000000000000000000000000000000000;;	func (obj JsonWebSignature) computeAuthData(signature *Signature) []byte {
0000000000000000000000000000000000000000;;		var serializedProtected string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if signature.original != nil && signature.original.Protected != nil {
0000000000000000000000000000000000000000;;			serializedProtected = signature.original.Protected.base64()
0000000000000000000000000000000000000000;;		} else if signature.protected != nil {
0000000000000000000000000000000000000000;;			serializedProtected = base64URLEncode(mustSerializeJSON(signature.protected))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			serializedProtected = ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return []byte(fmt.Sprintf("%s.%s",
0000000000000000000000000000000000000000;;			serializedProtected,
0000000000000000000000000000000000000000;;			base64URLEncode(obj.payload)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseSignedFull parses a message in full format.
0000000000000000000000000000000000000000;;	func parseSignedFull(input string) (*JsonWebSignature, error) {
0000000000000000000000000000000000000000;;		var parsed rawJsonWebSignature
0000000000000000000000000000000000000000;;		err := json.Unmarshal([]byte(input), &parsed)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parsed.sanitized()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sanitized produces a cleaned-up JWS object from the raw JSON.
0000000000000000000000000000000000000000;;	func (parsed *rawJsonWebSignature) sanitized() (*JsonWebSignature, error) {
0000000000000000000000000000000000000000;;		if parsed.Payload == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: missing payload in JWS message")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj := &JsonWebSignature{
0000000000000000000000000000000000000000;;			payload:    parsed.Payload.bytes(),
0000000000000000000000000000000000000000;;			Signatures: make([]Signature, len(parsed.Signatures)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parsed.Signatures) == 0 {
0000000000000000000000000000000000000000;;			// No signatures array, must be flattened serialization
0000000000000000000000000000000000000000;;			signature := Signature{}
0000000000000000000000000000000000000000;;			if parsed.Protected != nil && len(parsed.Protected.bytes()) > 0 {
0000000000000000000000000000000000000000;;				signature.protected = &rawHeader{}
0000000000000000000000000000000000000000;;				err := json.Unmarshal(parsed.Protected.bytes(), signature.protected)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if parsed.Header != nil && parsed.Header.Nonce != "" {
0000000000000000000000000000000000000000;;				return nil, ErrUnprotectedNonce
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			signature.header = parsed.Header
0000000000000000000000000000000000000000;;			signature.Signature = parsed.Signature.bytes()
0000000000000000000000000000000000000000;;			// Make a fake "original" rawSignatureInfo to store the unprocessed
0000000000000000000000000000000000000000;;			// Protected header. This is necessary because the Protected header can
0000000000000000000000000000000000000000;;			// contain arbitrary fields not registered as part of the spec. See
0000000000000000000000000000000000000000;;			// https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-4
0000000000000000000000000000000000000000;;			// If we unmarshal Protected into a rawHeader with its explicit list of fields,
0000000000000000000000000000000000000000;;			// we cannot marshal losslessly. So we have to keep around the original bytes.
0000000000000000000000000000000000000000;;			// This is used in computeAuthData, which will first attempt to use
0000000000000000000000000000000000000000;;			// the original bytes of a protected header, and fall back on marshaling the
0000000000000000000000000000000000000000;;			// header struct only if those bytes are not available.
0000000000000000000000000000000000000000;;			signature.original = &rawSignatureInfo{
0000000000000000000000000000000000000000;;				Protected: parsed.Protected,
0000000000000000000000000000000000000000;;				Header:    parsed.Header,
0000000000000000000000000000000000000000;;				Signature: parsed.Signature,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			signature.Header = signature.mergedHeaders().sanitized()
0000000000000000000000000000000000000000;;			obj.Signatures = append(obj.Signatures, signature)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, sig := range parsed.Signatures {
0000000000000000000000000000000000000000;;			if sig.Protected != nil && len(sig.Protected.bytes()) > 0 {
0000000000000000000000000000000000000000;;				obj.Signatures[i].protected = &rawHeader{}
0000000000000000000000000000000000000000;;				err := json.Unmarshal(sig.Protected.bytes(), obj.Signatures[i].protected)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check that there is not a nonce in the unprotected header
0000000000000000000000000000000000000000;;			if sig.Header != nil && sig.Header.Nonce != "" {
0000000000000000000000000000000000000000;;				return nil, ErrUnprotectedNonce
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj.Signatures[i].Signature = sig.Signature.bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Copy value of sig
0000000000000000000000000000000000000000;;			original := sig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj.Signatures[i].header = sig.Header
0000000000000000000000000000000000000000;;			obj.Signatures[i].original = &original
0000000000000000000000000000000000000000;;			obj.Signatures[i].Header = obj.Signatures[i].mergedHeaders().sanitized()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseSignedCompact parses a message in compact format.
0000000000000000000000000000000000000000;;	func parseSignedCompact(input string) (*JsonWebSignature, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(input, ".")
0000000000000000000000000000000000000000;;		if len(parts) != 3 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: compact JWS format must have three parts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawProtected, err := base64URLDecode(parts[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		payload, err := base64URLDecode(parts[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signature, err := base64URLDecode(parts[2])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw := &rawJsonWebSignature{
0000000000000000000000000000000000000000;;			Payload:   newBuffer(payload),
0000000000000000000000000000000000000000;;			Protected: newBuffer(rawProtected),
0000000000000000000000000000000000000000;;			Signature: newBuffer(signature),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return raw.sanitized()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompactSerialize serializes an object using the compact serialization format.
0000000000000000000000000000000000000000;;	func (obj JsonWebSignature) CompactSerialize() (string, error) {
0000000000000000000000000000000000000000;;		if len(obj.Signatures) != 1 || obj.Signatures[0].header != nil || obj.Signatures[0].protected == nil {
0000000000000000000000000000000000000000;;			return "", ErrNotSupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializedProtected := mustSerializeJSON(obj.Signatures[0].protected)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%s.%s.%s",
0000000000000000000000000000000000000000;;			base64URLEncode(serializedProtected),
0000000000000000000000000000000000000000;;			base64URLEncode(obj.payload),
0000000000000000000000000000000000000000;;			base64URLEncode(obj.Signatures[0].Signature)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FullSerialize serializes an object using the full JSON serialization format.
0000000000000000000000000000000000000000;;	func (obj JsonWebSignature) FullSerialize() string {
0000000000000000000000000000000000000000;;		raw := rawJsonWebSignature{
0000000000000000000000000000000000000000;;			Payload: newBuffer(obj.payload),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(obj.Signatures) == 1 {
0000000000000000000000000000000000000000;;			if obj.Signatures[0].protected != nil {
0000000000000000000000000000000000000000;;				serializedProtected := mustSerializeJSON(obj.Signatures[0].protected)
0000000000000000000000000000000000000000;;				raw.Protected = newBuffer(serializedProtected)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			raw.Header = obj.Signatures[0].header
0000000000000000000000000000000000000000;;			raw.Signature = newBuffer(obj.Signatures[0].Signature)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			raw.Signatures = make([]rawSignatureInfo, len(obj.Signatures))
0000000000000000000000000000000000000000;;			for i, signature := range obj.Signatures {
0000000000000000000000000000000000000000;;				raw.Signatures[i] = rawSignatureInfo{
0000000000000000000000000000000000000000;;					Header:    signature.header,
0000000000000000000000000000000000000000;;					Signature: newBuffer(signature.Signature),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if signature.protected != nil {
0000000000000000000000000000000000000000;;					raw.Signatures[i].Protected = newBuffer(mustSerializeJSON(signature.protected))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(mustSerializeJSON(raw))
0000000000000000000000000000000000000000;;	}
