0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NonceSource represents a source of random nonces to go into JWS objects
0000000000000000000000000000000000000000;;	type NonceSource interface {
0000000000000000000000000000000000000000;;		Nonce() (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signer represents a signer which takes a payload and produces a signed JWS object.
0000000000000000000000000000000000000000;;	type Signer interface {
0000000000000000000000000000000000000000;;		Sign(payload []byte) (*JsonWebSignature, error)
0000000000000000000000000000000000000000;;		SetNonceSource(source NonceSource)
0000000000000000000000000000000000000000;;		SetEmbedJwk(embed bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultiSigner represents a signer which supports multiple recipients.
0000000000000000000000000000000000000000;;	type MultiSigner interface {
0000000000000000000000000000000000000000;;		Sign(payload []byte) (*JsonWebSignature, error)
0000000000000000000000000000000000000000;;		SetNonceSource(source NonceSource)
0000000000000000000000000000000000000000;;		SetEmbedJwk(embed bool)
0000000000000000000000000000000000000000;;		AddRecipient(alg SignatureAlgorithm, signingKey interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type payloadSigner interface {
0000000000000000000000000000000000000000;;		signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type payloadVerifier interface {
0000000000000000000000000000000000000000;;		verifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genericSigner struct {
0000000000000000000000000000000000000000;;		recipients  []recipientSigInfo
0000000000000000000000000000000000000000;;		nonceSource NonceSource
0000000000000000000000000000000000000000;;		embedJwk    bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type recipientSigInfo struct {
0000000000000000000000000000000000000000;;		sigAlg    SignatureAlgorithm
0000000000000000000000000000000000000000;;		keyID     string
0000000000000000000000000000000000000000;;		publicKey *JsonWebKey
0000000000000000000000000000000000000000;;		signer    payloadSigner
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSigner creates an appropriate signer based on the key type
0000000000000000000000000000000000000000;;	func NewSigner(alg SignatureAlgorithm, signingKey interface{}) (Signer, error) {
0000000000000000000000000000000000000000;;		// NewMultiSigner never fails (currently)
0000000000000000000000000000000000000000;;		signer := NewMultiSigner()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := signer.AddRecipient(alg, signingKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return signer, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMultiSigner creates a signer for multiple recipients
0000000000000000000000000000000000000000;;	func NewMultiSigner() MultiSigner {
0000000000000000000000000000000000000000;;		return &genericSigner{
0000000000000000000000000000000000000000;;			recipients: []recipientSigInfo{},
0000000000000000000000000000000000000000;;			embedJwk:   true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newVerifier creates a verifier based on the key type
0000000000000000000000000000000000000000;;	func newVerifier(verificationKey interface{}) (payloadVerifier, error) {
0000000000000000000000000000000000000000;;		switch verificationKey := verificationKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			return &rsaEncrypterVerifier{
0000000000000000000000000000000000000000;;				publicKey: verificationKey,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			return &ecEncrypterVerifier{
0000000000000000000000000000000000000000;;				publicKey: verificationKey,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return &symmetricMac{
0000000000000000000000000000000000000000;;				key: verificationKey,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case *JsonWebKey:
0000000000000000000000000000000000000000;;			return newVerifier(verificationKey.Key)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrUnsupportedKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *genericSigner) AddRecipient(alg SignatureAlgorithm, signingKey interface{}) error {
0000000000000000000000000000000000000000;;		recipient, err := makeJWSRecipient(alg, signingKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.recipients = append(ctx.recipients, recipient)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeJWSRecipient(alg SignatureAlgorithm, signingKey interface{}) (recipientSigInfo, error) {
0000000000000000000000000000000000000000;;		switch signingKey := signingKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			return newRSASigner(alg, signingKey)
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			return newECDSASigner(alg, signingKey)
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return newSymmetricSigner(alg, signingKey)
0000000000000000000000000000000000000000;;		case *JsonWebKey:
0000000000000000000000000000000000000000;;			recipient, err := makeJWSRecipient(alg, signingKey.Key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return recipientSigInfo{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			recipient.keyID = signingKey.KeyID
0000000000000000000000000000000000000000;;			return recipient, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientSigInfo{}, ErrUnsupportedKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *genericSigner) Sign(payload []byte) (*JsonWebSignature, error) {
0000000000000000000000000000000000000000;;		obj := &JsonWebSignature{}
0000000000000000000000000000000000000000;;		obj.payload = payload
0000000000000000000000000000000000000000;;		obj.Signatures = make([]Signature, len(ctx.recipients))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, recipient := range ctx.recipients {
0000000000000000000000000000000000000000;;			protected := &rawHeader{
0000000000000000000000000000000000000000;;				Alg: string(recipient.sigAlg),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if recipient.publicKey != nil && ctx.embedJwk {
0000000000000000000000000000000000000000;;				protected.Jwk = recipient.publicKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if recipient.keyID != "" {
0000000000000000000000000000000000000000;;				protected.Kid = recipient.keyID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ctx.nonceSource != nil {
0000000000000000000000000000000000000000;;				nonce, err := ctx.nonceSource.Nonce()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("square/go-jose: Error generating nonce: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				protected.Nonce = nonce
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			serializedProtected := mustSerializeJSON(protected)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			input := []byte(fmt.Sprintf("%s.%s",
0000000000000000000000000000000000000000;;				base64URLEncode(serializedProtected),
0000000000000000000000000000000000000000;;				base64URLEncode(payload)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			signatureInfo, err := recipient.signer.signPayload(input, recipient.sigAlg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			signatureInfo.protected = protected
0000000000000000000000000000000000000000;;			obj.Signatures[i] = signatureInfo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetNonceSource provides or updates a nonce pool to the first recipients.
0000000000000000000000000000000000000000;;	// After this method is called, the signer will consume one nonce per
0000000000000000000000000000000000000000;;	// signature, returning an error it is unable to get a nonce.
0000000000000000000000000000000000000000;;	func (ctx *genericSigner) SetNonceSource(source NonceSource) {
0000000000000000000000000000000000000000;;		ctx.nonceSource = source
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEmbedJwk specifies if the signing key should be embedded in the protected header,
0000000000000000000000000000000000000000;;	// if any. It defaults to 'true'.
0000000000000000000000000000000000000000;;	func (ctx *genericSigner) SetEmbedJwk(embed bool) {
0000000000000000000000000000000000000000;;		ctx.embedJwk = embed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify validates the signature on the object and returns the payload.
0000000000000000000000000000000000000000;;	func (obj JsonWebSignature) Verify(verificationKey interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		verifier, err := newVerifier(verificationKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, signature := range obj.Signatures {
0000000000000000000000000000000000000000;;			headers := signature.mergedHeaders()
0000000000000000000000000000000000000000;;			if len(headers.Crit) > 0 {
0000000000000000000000000000000000000000;;				// Unsupported crit header
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			input := obj.computeAuthData(&signature)
0000000000000000000000000000000000000000;;			alg := SignatureAlgorithm(headers.Alg)
0000000000000000000000000000000000000000;;			err := verifier.verifyPayload(input, signature.Signature, alg)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return obj.payload, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, ErrCryptoFailure
0000000000000000000000000000000000000000;;	}
