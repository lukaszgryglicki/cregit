0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSON value parser state machine.
0000000000000000000000000000000000000000;;	// Just about at the limit of what is reasonable to write by hand.
0000000000000000000000000000000000000000;;	// Some parts are a bit tedious, but overall it nicely factors out the
0000000000000000000000000000000000000000;;	// otherwise common code from the multiple scanning functions
0000000000000000000000000000000000000000;;	// in this package (Compact, Indent, checkValid, nextValue, etc).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This file starts with two simple examples using the scanner
0000000000000000000000000000000000000000;;	// before diving into the scanner itself.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkValid verifies that data is valid JSON-encoded data.
0000000000000000000000000000000000000000;;	// scan is passed in for use by checkValid to avoid an allocation.
0000000000000000000000000000000000000000;;	func checkValid(data []byte, scan *scanner) error {
0000000000000000000000000000000000000000;;		scan.reset()
0000000000000000000000000000000000000000;;		for _, c := range data {
0000000000000000000000000000000000000000;;			scan.bytes++
0000000000000000000000000000000000000000;;			if scan.step(scan, c) == scanError {
0000000000000000000000000000000000000000;;				return scan.err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scan.eof() == scanError {
0000000000000000000000000000000000000000;;			return scan.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextValue splits data after the next whole JSON value,
0000000000000000000000000000000000000000;;	// returning that value and the bytes that follow it as separate slices.
0000000000000000000000000000000000000000;;	// scan is passed in for use by nextValue to avoid an allocation.
0000000000000000000000000000000000000000;;	func nextValue(data []byte, scan *scanner) (value, rest []byte, err error) {
0000000000000000000000000000000000000000;;		scan.reset()
0000000000000000000000000000000000000000;;		for i, c := range data {
0000000000000000000000000000000000000000;;			v := scan.step(scan, c)
0000000000000000000000000000000000000000;;			if v >= scanEndObject {
0000000000000000000000000000000000000000;;				switch v {
0000000000000000000000000000000000000000;;				// probe the scanner with a space to determine whether we will
0000000000000000000000000000000000000000;;				// get scanEnd on the next character. Otherwise, if the next character
0000000000000000000000000000000000000000;;				// is not a space, scanEndTop allocates a needless error.
0000000000000000000000000000000000000000;;				case scanEndObject, scanEndArray:
0000000000000000000000000000000000000000;;					if scan.step(scan, ' ') == scanEnd {
0000000000000000000000000000000000000000;;						return data[:i+1], data[i+1:], nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case scanError:
0000000000000000000000000000000000000000;;					return nil, nil, scan.err
0000000000000000000000000000000000000000;;				case scanEnd:
0000000000000000000000000000000000000000;;					return data[:i], data[i:], nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scan.eof() == scanError {
0000000000000000000000000000000000000000;;			return nil, nil, scan.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data, nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SyntaxError is a description of a JSON syntax error.
0000000000000000000000000000000000000000;;	type SyntaxError struct {
0000000000000000000000000000000000000000;;		msg    string // description of error
0000000000000000000000000000000000000000;;		Offset int64  // error occurred after reading Offset bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *SyntaxError) Error() string { return e.msg }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A scanner is a JSON scanning state machine.
0000000000000000000000000000000000000000;;	// Callers call scan.reset() and then pass bytes in one at a time
0000000000000000000000000000000000000000;;	// by calling scan.step(&scan, c) for each byte.
0000000000000000000000000000000000000000;;	// The return value, referred to as an opcode, tells the
0000000000000000000000000000000000000000;;	// caller about significant parsing events like beginning
0000000000000000000000000000000000000000;;	// and ending literals, objects, and arrays, so that the
0000000000000000000000000000000000000000;;	// caller can follow along if it wishes.
0000000000000000000000000000000000000000;;	// The return value scanEnd indicates that a single top-level
0000000000000000000000000000000000000000;;	// JSON value has been completed, *before* the byte that
0000000000000000000000000000000000000000;;	// just got passed in.  (The indication must be delayed in order
0000000000000000000000000000000000000000;;	// to recognize the end of numbers: is 123 a whole value or
0000000000000000000000000000000000000000;;	// the beginning of 12345e+6?).
0000000000000000000000000000000000000000;;	type scanner struct {
0000000000000000000000000000000000000000;;		// The step is a func to be called to execute the next transition.
0000000000000000000000000000000000000000;;		// Also tried using an integer constant and a single func
0000000000000000000000000000000000000000;;		// with a switch, but using the func directly was 10% faster
0000000000000000000000000000000000000000;;		// on a 64-bit Mac Mini, and it's nicer to read.
0000000000000000000000000000000000000000;;		step func(*scanner, byte) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Reached end of top-level value.
0000000000000000000000000000000000000000;;		endTop bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stack of what we're in the middle of - array values, object keys, object values.
0000000000000000000000000000000000000000;;		parseState []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error that happened, if any.
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1-byte redo (see undo method)
0000000000000000000000000000000000000000;;		redo      bool
0000000000000000000000000000000000000000;;		redoCode  int
0000000000000000000000000000000000000000;;		redoState func(*scanner, byte) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// total bytes consumed, updated by decoder.Decode
0000000000000000000000000000000000000000;;		bytes int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These values are returned by the state transition functions
0000000000000000000000000000000000000000;;	// assigned to scanner.state and the method scanner.eof.
0000000000000000000000000000000000000000;;	// They give details about the current state of the scan that
0000000000000000000000000000000000000000;;	// callers might be interested to know about.
0000000000000000000000000000000000000000;;	// It is okay to ignore the return value of any particular
0000000000000000000000000000000000000000;;	// call to scanner.state: if one call returns scanError,
0000000000000000000000000000000000000000;;	// every subsequent call will return scanError too.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Continue.
0000000000000000000000000000000000000000;;		scanContinue     = iota // uninteresting byte
0000000000000000000000000000000000000000;;		scanBeginLiteral        // end implied by next result != scanContinue
0000000000000000000000000000000000000000;;		scanBeginObject         // begin object
0000000000000000000000000000000000000000;;		scanObjectKey           // just finished object key (string)
0000000000000000000000000000000000000000;;		scanObjectValue         // just finished non-last object value
0000000000000000000000000000000000000000;;		scanEndObject           // end object (implies scanObjectValue if possible)
0000000000000000000000000000000000000000;;		scanBeginArray          // begin array
0000000000000000000000000000000000000000;;		scanArrayValue          // just finished array value
0000000000000000000000000000000000000000;;		scanEndArray            // end array (implies scanArrayValue if possible)
0000000000000000000000000000000000000000;;		scanSkipSpace           // space byte; can skip; known to be last "continue" result
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop.
0000000000000000000000000000000000000000;;		scanEnd   // top-level value ended *before* this byte; known to be first "stop" result
0000000000000000000000000000000000000000;;		scanError // hit an error, scanner.err.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These values are stored in the parseState stack.
0000000000000000000000000000000000000000;;	// They give the current state of a composite value
0000000000000000000000000000000000000000;;	// being scanned.  If the parser is inside a nested value
0000000000000000000000000000000000000000;;	// the parseState describes the nested state, outermost at entry 0.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		parseObjectKey   = iota // parsing object key (before colon)
0000000000000000000000000000000000000000;;		parseObjectValue        // parsing object value (after colon)
0000000000000000000000000000000000000000;;		parseArrayValue         // parsing array value
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reset prepares the scanner for use.
0000000000000000000000000000000000000000;;	// It must be called before calling s.step.
0000000000000000000000000000000000000000;;	func (s *scanner) reset() {
0000000000000000000000000000000000000000;;		s.step = stateBeginValue
0000000000000000000000000000000000000000;;		s.parseState = s.parseState[0:0]
0000000000000000000000000000000000000000;;		s.err = nil
0000000000000000000000000000000000000000;;		s.redo = false
0000000000000000000000000000000000000000;;		s.endTop = false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// eof tells the scanner that the end of input has been reached.
0000000000000000000000000000000000000000;;	// It returns a scan status just as s.step does.
0000000000000000000000000000000000000000;;	func (s *scanner) eof() int {
0000000000000000000000000000000000000000;;		if s.err != nil {
0000000000000000000000000000000000000000;;			return scanError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.endTop {
0000000000000000000000000000000000000000;;			return scanEnd
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.step(s, ' ')
0000000000000000000000000000000000000000;;		if s.endTop {
0000000000000000000000000000000000000000;;			return scanEnd
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.err == nil {
0000000000000000000000000000000000000000;;			s.err = &SyntaxError{"unexpected end of JSON input", s.bytes}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scanError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pushParseState pushes a new parse state p onto the parse stack.
0000000000000000000000000000000000000000;;	func (s *scanner) pushParseState(p int) {
0000000000000000000000000000000000000000;;		s.parseState = append(s.parseState, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// popParseState pops a parse state (already obtained) off the stack
0000000000000000000000000000000000000000;;	// and updates s.step accordingly.
0000000000000000000000000000000000000000;;	func (s *scanner) popParseState() {
0000000000000000000000000000000000000000;;		n := len(s.parseState) - 1
0000000000000000000000000000000000000000;;		s.parseState = s.parseState[0:n]
0000000000000000000000000000000000000000;;		s.redo = false
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			s.step = stateEndTop
0000000000000000000000000000000000000000;;			s.endTop = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s.step = stateEndValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSpace(c byte) bool {
0000000000000000000000000000000000000000;;		return c == ' ' || c == '\t' || c == '\r' || c == '\n'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateBeginValueOrEmpty is the state after reading `[`.
0000000000000000000000000000000000000000;;	func stateBeginValueOrEmpty(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c <= ' ' && isSpace(c) {
0000000000000000000000000000000000000000;;			return scanSkipSpace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == ']' {
0000000000000000000000000000000000000000;;			return stateEndValue(s, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stateBeginValue(s, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateBeginValue is the state at the beginning of the input.
0000000000000000000000000000000000000000;;	func stateBeginValue(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c <= ' ' && isSpace(c) {
0000000000000000000000000000000000000000;;			return scanSkipSpace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '{':
0000000000000000000000000000000000000000;;			s.step = stateBeginStringOrEmpty
0000000000000000000000000000000000000000;;			s.pushParseState(parseObjectKey)
0000000000000000000000000000000000000000;;			return scanBeginObject
0000000000000000000000000000000000000000;;		case '[':
0000000000000000000000000000000000000000;;			s.step = stateBeginValueOrEmpty
0000000000000000000000000000000000000000;;			s.pushParseState(parseArrayValue)
0000000000000000000000000000000000000000;;			return scanBeginArray
0000000000000000000000000000000000000000;;		case '"':
0000000000000000000000000000000000000000;;			s.step = stateInString
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		case '-':
0000000000000000000000000000000000000000;;			s.step = stateNeg
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		case '0': // beginning of 0.123
0000000000000000000000000000000000000000;;			s.step = state0
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		case 't': // beginning of true
0000000000000000000000000000000000000000;;			s.step = stateT
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		case 'f': // beginning of false
0000000000000000000000000000000000000000;;			s.step = stateF
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		case 'n': // beginning of null
0000000000000000000000000000000000000000;;			s.step = stateN
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if '1' <= c && c <= '9' { // beginning of 1234.5
0000000000000000000000000000000000000000;;			s.step = state1
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "looking for beginning of value")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateBeginStringOrEmpty is the state after reading `{`.
0000000000000000000000000000000000000000;;	func stateBeginStringOrEmpty(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c <= ' ' && isSpace(c) {
0000000000000000000000000000000000000000;;			return scanSkipSpace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '}' {
0000000000000000000000000000000000000000;;			n := len(s.parseState)
0000000000000000000000000000000000000000;;			s.parseState[n-1] = parseObjectValue
0000000000000000000000000000000000000000;;			return stateEndValue(s, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stateBeginString(s, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateBeginString is the state after reading `{"key": value,`.
0000000000000000000000000000000000000000;;	func stateBeginString(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c <= ' ' && isSpace(c) {
0000000000000000000000000000000000000000;;			return scanSkipSpace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '"' {
0000000000000000000000000000000000000000;;			s.step = stateInString
0000000000000000000000000000000000000000;;			return scanBeginLiteral
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "looking for beginning of object key string")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateEndValue is the state after completing a value,
0000000000000000000000000000000000000000;;	// such as after reading `{}` or `true` or `["x"`.
0000000000000000000000000000000000000000;;	func stateEndValue(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		n := len(s.parseState)
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			// Completed top-level before the current byte.
0000000000000000000000000000000000000000;;			s.step = stateEndTop
0000000000000000000000000000000000000000;;			s.endTop = true
0000000000000000000000000000000000000000;;			return stateEndTop(s, c)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c <= ' ' && isSpace(c) {
0000000000000000000000000000000000000000;;			s.step = stateEndValue
0000000000000000000000000000000000000000;;			return scanSkipSpace
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ps := s.parseState[n-1]
0000000000000000000000000000000000000000;;		switch ps {
0000000000000000000000000000000000000000;;		case parseObjectKey:
0000000000000000000000000000000000000000;;			if c == ':' {
0000000000000000000000000000000000000000;;				s.parseState[n-1] = parseObjectValue
0000000000000000000000000000000000000000;;				s.step = stateBeginValue
0000000000000000000000000000000000000000;;				return scanObjectKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.error(c, "after object key")
0000000000000000000000000000000000000000;;		case parseObjectValue:
0000000000000000000000000000000000000000;;			if c == ',' {
0000000000000000000000000000000000000000;;				s.parseState[n-1] = parseObjectKey
0000000000000000000000000000000000000000;;				s.step = stateBeginString
0000000000000000000000000000000000000000;;				return scanObjectValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c == '}' {
0000000000000000000000000000000000000000;;				s.popParseState()
0000000000000000000000000000000000000000;;				return scanEndObject
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.error(c, "after object key:value pair")
0000000000000000000000000000000000000000;;		case parseArrayValue:
0000000000000000000000000000000000000000;;			if c == ',' {
0000000000000000000000000000000000000000;;				s.step = stateBeginValue
0000000000000000000000000000000000000000;;				return scanArrayValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c == ']' {
0000000000000000000000000000000000000000;;				s.popParseState()
0000000000000000000000000000000000000000;;				return scanEndArray
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.error(c, "after array element")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateEndTop is the state after finishing the top-level value,
0000000000000000000000000000000000000000;;	// such as after reading `{}` or `[1,2,3]`.
0000000000000000000000000000000000000000;;	// Only space characters should be seen now.
0000000000000000000000000000000000000000;;	func stateEndTop(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c != ' ' && c != '\t' && c != '\r' && c != '\n' {
0000000000000000000000000000000000000000;;			// Complain about non-space byte on next call.
0000000000000000000000000000000000000000;;			s.error(c, "after top-level value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scanEnd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateInString is the state after reading `"`.
0000000000000000000000000000000000000000;;	func stateInString(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == '"' {
0000000000000000000000000000000000000000;;			s.step = stateEndValue
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '\\' {
0000000000000000000000000000000000000000;;			s.step = stateInStringEsc
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c < 0x20 {
0000000000000000000000000000000000000000;;			return s.error(c, "in string literal")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scanContinue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateInStringEsc is the state after reading `"\` during a quoted string.
0000000000000000000000000000000000000000;;	func stateInStringEsc(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case 'b', 'f', 'n', 'r', 't', '\\', '/', '"':
0000000000000000000000000000000000000000;;			s.step = stateInString
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		case 'u':
0000000000000000000000000000000000000000;;			s.step = stateInStringEscU
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in string escape code")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateInStringEscU is the state after reading `"\u` during a quoted string.
0000000000000000000000000000000000000000;;	func stateInStringEscU(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
0000000000000000000000000000000000000000;;			s.step = stateInStringEscU1
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// numbers
0000000000000000000000000000000000000000;;		return s.error(c, "in \\u hexadecimal character escape")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateInStringEscU1 is the state after reading `"\u1` during a quoted string.
0000000000000000000000000000000000000000;;	func stateInStringEscU1(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
0000000000000000000000000000000000000000;;			s.step = stateInStringEscU12
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// numbers
0000000000000000000000000000000000000000;;		return s.error(c, "in \\u hexadecimal character escape")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateInStringEscU12 is the state after reading `"\u12` during a quoted string.
0000000000000000000000000000000000000000;;	func stateInStringEscU12(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
0000000000000000000000000000000000000000;;			s.step = stateInStringEscU123
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// numbers
0000000000000000000000000000000000000000;;		return s.error(c, "in \\u hexadecimal character escape")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateInStringEscU123 is the state after reading `"\u123` during a quoted string.
0000000000000000000000000000000000000000;;	func stateInStringEscU123(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' || 'a' <= c && c <= 'f' || 'A' <= c && c <= 'F' {
0000000000000000000000000000000000000000;;			s.step = stateInString
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// numbers
0000000000000000000000000000000000000000;;		return s.error(c, "in \\u hexadecimal character escape")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateNeg is the state after reading `-` during a number.
0000000000000000000000000000000000000000;;	func stateNeg(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == '0' {
0000000000000000000000000000000000000000;;			s.step = state0
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if '1' <= c && c <= '9' {
0000000000000000000000000000000000000000;;			s.step = state1
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in numeric literal")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// state1 is the state after reading a non-zero integer during a number,
0000000000000000000000000000000000000000;;	// such as after reading `1` or `100` but not `0`.
0000000000000000000000000000000000000000;;	func state1(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;			s.step = state1
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return state0(s, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// state0 is the state after reading `0` during a number.
0000000000000000000000000000000000000000;;	func state0(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == '.' {
0000000000000000000000000000000000000000;;			s.step = stateDot
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == 'e' || c == 'E' {
0000000000000000000000000000000000000000;;			s.step = stateE
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stateEndValue(s, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateDot is the state after reading the integer and decimal point in a number,
0000000000000000000000000000000000000000;;	// such as after reading `1.`.
0000000000000000000000000000000000000000;;	func stateDot(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;			s.step = stateDot0
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "after decimal point in numeric literal")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateDot0 is the state after reading the integer, decimal point, and subsequent
0000000000000000000000000000000000000000;;	// digits of a number, such as after reading `3.14`.
0000000000000000000000000000000000000000;;	func stateDot0(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == 'e' || c == 'E' {
0000000000000000000000000000000000000000;;			s.step = stateE
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stateEndValue(s, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateE is the state after reading the mantissa and e in a number,
0000000000000000000000000000000000000000;;	// such as after reading `314e` or `0.314e`.
0000000000000000000000000000000000000000;;	func stateE(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == '+' || c == '-' {
0000000000000000000000000000000000000000;;			s.step = stateESign
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stateESign(s, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateESign is the state after reading the mantissa, e, and sign in a number,
0000000000000000000000000000000000000000;;	// such as after reading `314e-` or `0.314e+`.
0000000000000000000000000000000000000000;;	func stateESign(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;			s.step = stateE0
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in exponent of numeric literal")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateE0 is the state after reading the mantissa, e, optional sign,
0000000000000000000000000000000000000000;;	// and at least one digit of the exponent in a number,
0000000000000000000000000000000000000000;;	// such as after reading `314e-2` or `0.314e+1` or `3.14e0`.
0000000000000000000000000000000000000000;;	func stateE0(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stateEndValue(s, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateT is the state after reading `t`.
0000000000000000000000000000000000000000;;	func stateT(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'r' {
0000000000000000000000000000000000000000;;			s.step = stateTr
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal true (expecting 'r')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateTr is the state after reading `tr`.
0000000000000000000000000000000000000000;;	func stateTr(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'u' {
0000000000000000000000000000000000000000;;			s.step = stateTru
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal true (expecting 'u')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateTru is the state after reading `tru`.
0000000000000000000000000000000000000000;;	func stateTru(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'e' {
0000000000000000000000000000000000000000;;			s.step = stateEndValue
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal true (expecting 'e')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateF is the state after reading `f`.
0000000000000000000000000000000000000000;;	func stateF(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'a' {
0000000000000000000000000000000000000000;;			s.step = stateFa
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal false (expecting 'a')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateFa is the state after reading `fa`.
0000000000000000000000000000000000000000;;	func stateFa(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'l' {
0000000000000000000000000000000000000000;;			s.step = stateFal
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal false (expecting 'l')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateFal is the state after reading `fal`.
0000000000000000000000000000000000000000;;	func stateFal(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 's' {
0000000000000000000000000000000000000000;;			s.step = stateFals
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal false (expecting 's')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateFals is the state after reading `fals`.
0000000000000000000000000000000000000000;;	func stateFals(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'e' {
0000000000000000000000000000000000000000;;			s.step = stateEndValue
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal false (expecting 'e')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateN is the state after reading `n`.
0000000000000000000000000000000000000000;;	func stateN(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'u' {
0000000000000000000000000000000000000000;;			s.step = stateNu
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal null (expecting 'u')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateNu is the state after reading `nu`.
0000000000000000000000000000000000000000;;	func stateNu(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'l' {
0000000000000000000000000000000000000000;;			s.step = stateNul
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal null (expecting 'l')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateNul is the state after reading `nul`.
0000000000000000000000000000000000000000;;	func stateNul(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		if c == 'l' {
0000000000000000000000000000000000000000;;			s.step = stateEndValue
0000000000000000000000000000000000000000;;			return scanContinue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.error(c, "in literal null (expecting 'l')")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateError is the state after reaching a syntax error,
0000000000000000000000000000000000000000;;	// such as after reading `[1}` or `5.1.2`.
0000000000000000000000000000000000000000;;	func stateError(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		return scanError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// error records an error and switches to the error state.
0000000000000000000000000000000000000000;;	func (s *scanner) error(c byte, context string) int {
0000000000000000000000000000000000000000;;		s.step = stateError
0000000000000000000000000000000000000000;;		s.err = &SyntaxError{"invalid character " + quoteChar(c) + " " + context, s.bytes}
0000000000000000000000000000000000000000;;		return scanError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// quoteChar formats c as a quoted character literal
0000000000000000000000000000000000000000;;	func quoteChar(c byte) string {
0000000000000000000000000000000000000000;;		// special cases - different from quoted strings
0000000000000000000000000000000000000000;;		if c == '\'' {
0000000000000000000000000000000000000000;;			return `'\''`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c == '"' {
0000000000000000000000000000000000000000;;			return `'"'`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// use quoted string with different quotation marks
0000000000000000000000000000000000000000;;		s := strconv.Quote(string(c))
0000000000000000000000000000000000000000;;		return "'" + s[1:len(s)-1] + "'"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// undo causes the scanner to return scanCode from the next state transition.
0000000000000000000000000000000000000000;;	// This gives callers a simple 1-byte undo mechanism.
0000000000000000000000000000000000000000;;	func (s *scanner) undo(scanCode int) {
0000000000000000000000000000000000000000;;		if s.redo {
0000000000000000000000000000000000000000;;			panic("json: invalid use of scanner")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.redoCode = scanCode
0000000000000000000000000000000000000000;;		s.redoState = s.step
0000000000000000000000000000000000000000;;		s.step = stateRedo
0000000000000000000000000000000000000000;;		s.redo = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stateRedo helps implement the scanner's 1-byte undo.
0000000000000000000000000000000000000000;;	func stateRedo(s *scanner, c byte) int {
0000000000000000000000000000000000000000;;		s.redo = false
0000000000000000000000000000000000000000;;		s.step = s.redoState
0000000000000000000000000000000000000000;;		return s.redoCode
0000000000000000000000000000000000000000;;	}
