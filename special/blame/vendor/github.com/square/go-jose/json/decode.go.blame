0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	// Represents JSON data structure using native Go types: booleans, floats,
0000000000000000000000000000000000000000;;	// strings, arrays, and maps.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf16"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal parses the JSON-encoded data and stores the result
0000000000000000000000000000000000000000;;	// in the value pointed to by v.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unmarshal uses the inverse of the encodings that
0000000000000000000000000000000000000000;;	// Marshal uses, allocating maps, slices, and pointers as necessary,
0000000000000000000000000000000000000000;;	// with the following additional rules:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To unmarshal JSON into a pointer, Unmarshal first handles the case of
0000000000000000000000000000000000000000;;	// the JSON being the JSON literal null.  In that case, Unmarshal sets
0000000000000000000000000000000000000000;;	// the pointer to nil.  Otherwise, Unmarshal unmarshals the JSON into
0000000000000000000000000000000000000000;;	// the value pointed at by the pointer.  If the pointer is nil, Unmarshal
0000000000000000000000000000000000000000;;	// allocates a new value for it to point to.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To unmarshal JSON into a struct, Unmarshal matches incoming object
0000000000000000000000000000000000000000;;	// keys to the keys used by Marshal (either the struct field name or its tag),
0000000000000000000000000000000000000000;;	// preferring an exact match but also accepting a case-insensitive match.
0000000000000000000000000000000000000000;;	// Unmarshal will only set exported fields of the struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To unmarshal JSON into an interface value,
0000000000000000000000000000000000000000;;	// Unmarshal stores one of these in the interface value:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	bool, for JSON booleans
0000000000000000000000000000000000000000;;	//	float64, for JSON numbers
0000000000000000000000000000000000000000;;	//	string, for JSON strings
0000000000000000000000000000000000000000;;	//	[]interface{}, for JSON arrays
0000000000000000000000000000000000000000;;	//	map[string]interface{}, for JSON objects
0000000000000000000000000000000000000000;;	//	nil for JSON null
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To unmarshal a JSON array into a slice, Unmarshal resets the slice length
0000000000000000000000000000000000000000;;	// to zero and then appends each element to the slice.
0000000000000000000000000000000000000000;;	// As a special case, to unmarshal an empty JSON array into a slice,
0000000000000000000000000000000000000000;;	// Unmarshal replaces the slice with a new empty slice.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To unmarshal a JSON array into a Go array, Unmarshal decodes
0000000000000000000000000000000000000000;;	// JSON array elements into corresponding Go array elements.
0000000000000000000000000000000000000000;;	// If the Go array is smaller than the JSON array,
0000000000000000000000000000000000000000;;	// the additional JSON array elements are discarded.
0000000000000000000000000000000000000000;;	// If the JSON array is smaller than the Go array,
0000000000000000000000000000000000000000;;	// the additional Go array elements are set to zero values.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To unmarshal a JSON object into a string-keyed map, Unmarshal first
0000000000000000000000000000000000000000;;	// establishes a map to use, If the map is nil, Unmarshal allocates a new map.
0000000000000000000000000000000000000000;;	// Otherwise Unmarshal reuses the existing map, keeping existing entries.
0000000000000000000000000000000000000000;;	// Unmarshal then stores key-value pairs from the JSON object into the map.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a JSON value is not appropriate for a given target type,
0000000000000000000000000000000000000000;;	// or if a JSON number overflows the target type, Unmarshal
0000000000000000000000000000000000000000;;	// skips that field and completes the unmarshaling as best it can.
0000000000000000000000000000000000000000;;	// If no more serious errors are encountered, Unmarshal returns
0000000000000000000000000000000000000000;;	// an UnmarshalTypeError describing the earliest such error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The JSON null value unmarshals into an interface, map, pointer, or slice
0000000000000000000000000000000000000000;;	// by setting that Go value to nil. Because null is often used in JSON to mean
0000000000000000000000000000000000000000;;	// ``not present,'' unmarshaling a JSON null into any other Go type has no effect
0000000000000000000000000000000000000000;;	// on the value and produces no error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When unmarshaling quoted strings, invalid UTF-8 or
0000000000000000000000000000000000000000;;	// invalid UTF-16 surrogate pairs are not treated as an error.
0000000000000000000000000000000000000000;;	// Instead, they are replaced by the Unicode replacement
0000000000000000000000000000000000000000;;	// character U+FFFD.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func Unmarshal(data []byte, v interface{}) error {
0000000000000000000000000000000000000000;;		// Check for well-formedness.
0000000000000000000000000000000000000000;;		// Avoids filling out half a data structure
0000000000000000000000000000000000000000;;		// before discovering a JSON syntax error.
0000000000000000000000000000000000000000;;		var d decodeState
0000000000000000000000000000000000000000;;		err := checkValid(data, &d.scan)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.init(data)
0000000000000000000000000000000000000000;;		return d.unmarshal(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshaler is the interface implemented by objects
0000000000000000000000000000000000000000;;	// that can unmarshal a JSON description of themselves.
0000000000000000000000000000000000000000;;	// The input can be assumed to be a valid encoding of
0000000000000000000000000000000000000000;;	// a JSON value. UnmarshalJSON must copy the JSON data
0000000000000000000000000000000000000000;;	// if it wishes to retain the data after returning.
0000000000000000000000000000000000000000;;	type Unmarshaler interface {
0000000000000000000000000000000000000000;;		UnmarshalJSON([]byte) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An UnmarshalTypeError describes a JSON value that was
0000000000000000000000000000000000000000;;	// not appropriate for a value of a specific Go type.
0000000000000000000000000000000000000000;;	type UnmarshalTypeError struct {
0000000000000000000000000000000000000000;;		Value  string       // description of JSON value - "bool", "array", "number -5"
0000000000000000000000000000000000000000;;		Type   reflect.Type // type of Go value it could not be assigned to
0000000000000000000000000000000000000000;;		Offset int64        // error occurred after reading Offset bytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *UnmarshalTypeError) Error() string {
0000000000000000000000000000000000000000;;		return "json: cannot unmarshal " + e.Value + " into Go value of type " + e.Type.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An UnmarshalFieldError describes a JSON object key that
0000000000000000000000000000000000000000;;	// led to an unexported (and therefore unwritable) struct field.
0000000000000000000000000000000000000000;;	// (No longer used; kept for compatibility.)
0000000000000000000000000000000000000000;;	type UnmarshalFieldError struct {
0000000000000000000000000000000000000000;;		Key   string
0000000000000000000000000000000000000000;;		Type  reflect.Type
0000000000000000000000000000000000000000;;		Field reflect.StructField
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *UnmarshalFieldError) Error() string {
0000000000000000000000000000000000000000;;		return "json: cannot unmarshal object key " + strconv.Quote(e.Key) + " into unexported field " + e.Field.Name + " of type " + e.Type.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An InvalidUnmarshalError describes an invalid argument passed to Unmarshal.
0000000000000000000000000000000000000000;;	// (The argument to Unmarshal must be a non-nil pointer.)
0000000000000000000000000000000000000000;;	type InvalidUnmarshalError struct {
0000000000000000000000000000000000000000;;		Type reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *InvalidUnmarshalError) Error() string {
0000000000000000000000000000000000000000;;		if e.Type == nil {
0000000000000000000000000000000000000000;;			return "json: Unmarshal(nil)"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if e.Type.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return "json: Unmarshal(non-pointer " + e.Type.String() + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "json: Unmarshal(nil " + e.Type.String() + ")"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decodeState) unmarshal(v interface{}) (err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if r := recover(); r != nil {
0000000000000000000000000000000000000000;;				if _, ok := r.(runtime.Error); ok {
0000000000000000000000000000000000000000;;					panic(r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = r.(error)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rv := reflect.ValueOf(v)
0000000000000000000000000000000000000000;;		if rv.Kind() != reflect.Ptr || rv.IsNil() {
0000000000000000000000000000000000000000;;			return &InvalidUnmarshalError{reflect.TypeOf(v)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.scan.reset()
0000000000000000000000000000000000000000;;		// We decode rv not rv.Elem because the Unmarshaler interface
0000000000000000000000000000000000000000;;		// test must be applied at the top level of the value.
0000000000000000000000000000000000000000;;		d.value(rv)
0000000000000000000000000000000000000000;;		return d.savedError
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Number represents a JSON number literal.
0000000000000000000000000000000000000000;;	type Number string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the literal text of the number.
0000000000000000000000000000000000000000;;	func (n Number) String() string { return string(n) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float64 returns the number as a float64.
0000000000000000000000000000000000000000;;	func (n Number) Float64() (float64, error) {
0000000000000000000000000000000000000000;;		return strconv.ParseFloat(string(n), 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int64 returns the number as an int64.
0000000000000000000000000000000000000000;;	func (n Number) Int64() (int64, error) {
0000000000000000000000000000000000000000;;		return strconv.ParseInt(string(n), 10, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isValidNumber reports whether s is a valid JSON number literal.
0000000000000000000000000000000000000000;;	func isValidNumber(s string) bool {
0000000000000000000000000000000000000000;;		// This function implements the JSON numbers grammar.
0000000000000000000000000000000000000000;;		// See https://tools.ietf.org/html/rfc7159#section-6
0000000000000000000000000000000000000000;;		// and http://json.org/number.gif
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optional -
0000000000000000000000000000000000000000;;		if s[0] == '-' {
0000000000000000000000000000000000000000;;			s = s[1:]
0000000000000000000000000000000000000000;;			if s == "" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Digits
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case s[0] == '0':
0000000000000000000000000000000000000000;;			s = s[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case '1' <= s[0] && s[0] <= '9':
0000000000000000000000000000000000000000;;			s = s[1:]
0000000000000000000000000000000000000000;;			for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
0000000000000000000000000000000000000000;;				s = s[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// . followed by 1 or more digits.
0000000000000000000000000000000000000000;;		if len(s) >= 2 && s[0] == '.' && '0' <= s[1] && s[1] <= '9' {
0000000000000000000000000000000000000000;;			s = s[2:]
0000000000000000000000000000000000000000;;			for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
0000000000000000000000000000000000000000;;				s = s[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// e or E followed by an optional - or + and
0000000000000000000000000000000000000000;;		// 1 or more digits.
0000000000000000000000000000000000000000;;		if len(s) >= 2 && (s[0] == 'e' || s[0] == 'E') {
0000000000000000000000000000000000000000;;			s = s[1:]
0000000000000000000000000000000000000000;;			if s[0] == '+' || s[0] == '-' {
0000000000000000000000000000000000000000;;				s = s[1:]
0000000000000000000000000000000000000000;;				if s == "" {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for len(s) > 0 && '0' <= s[0] && s[0] <= '9' {
0000000000000000000000000000000000000000;;				s = s[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure we are at the end.
0000000000000000000000000000000000000000;;		return s == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// decodeState represents the state while decoding a JSON value.
0000000000000000000000000000000000000000;;	type decodeState struct {
0000000000000000000000000000000000000000;;		data       []byte
0000000000000000000000000000000000000000;;		off        int // read offset in data
0000000000000000000000000000000000000000;;		scan       scanner
0000000000000000000000000000000000000000;;		nextscan   scanner // for calls to nextValue
0000000000000000000000000000000000000000;;		savedError error
0000000000000000000000000000000000000000;;		useNumber  bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// errPhase is used for errors that should not happen unless
0000000000000000000000000000000000000000;;	// there is a bug in the JSON decoder or something is editing
0000000000000000000000000000000000000000;;	// the data slice while the decoder executes.
0000000000000000000000000000000000000000;;	var errPhase = errors.New("JSON decoder out of sync - data changing underfoot?")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decodeState) init(data []byte) *decodeState {
0000000000000000000000000000000000000000;;		d.data = data
0000000000000000000000000000000000000000;;		d.off = 0
0000000000000000000000000000000000000000;;		d.savedError = nil
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// error aborts the decoding by panicking with err.
0000000000000000000000000000000000000000;;	func (d *decodeState) error(err error) {
0000000000000000000000000000000000000000;;		panic(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// saveError saves the first err it is called with,
0000000000000000000000000000000000000000;;	// for reporting at the end of the unmarshal.
0000000000000000000000000000000000000000;;	func (d *decodeState) saveError(err error) {
0000000000000000000000000000000000000000;;		if d.savedError == nil {
0000000000000000000000000000000000000000;;			d.savedError = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// next cuts off and returns the next full JSON value in d.data[d.off:].
0000000000000000000000000000000000000000;;	// The next value is known to be an object or array, not a literal.
0000000000000000000000000000000000000000;;	func (d *decodeState) next() []byte {
0000000000000000000000000000000000000000;;		c := d.data[d.off]
0000000000000000000000000000000000000000;;		item, rest, err := nextValue(d.data[d.off:], &d.nextscan)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			d.error(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.off = len(d.data) - len(rest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Our scanner has seen the opening brace/bracket
0000000000000000000000000000000000000000;;		// and thinks we're still in the middle of the object.
0000000000000000000000000000000000000000;;		// invent a closing brace/bracket to get it out.
0000000000000000000000000000000000000000;;		if c == '{' {
0000000000000000000000000000000000000000;;			d.scan.step(&d.scan, '}')
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			d.scan.step(&d.scan, ']')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanWhile processes bytes in d.data[d.off:] until it
0000000000000000000000000000000000000000;;	// receives a scan code not equal to op.
0000000000000000000000000000000000000000;;	// It updates d.off and returns the new scan code.
0000000000000000000000000000000000000000;;	func (d *decodeState) scanWhile(op int) int {
0000000000000000000000000000000000000000;;		var newOp int
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if d.off >= len(d.data) {
0000000000000000000000000000000000000000;;				newOp = d.scan.eof()
0000000000000000000000000000000000000000;;				d.off = len(d.data) + 1 // mark processed EOF with len+1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c := d.data[d.off]
0000000000000000000000000000000000000000;;				d.off++
0000000000000000000000000000000000000000;;				newOp = d.scan.step(&d.scan, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if newOp != op {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newOp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// value decodes a JSON value from d.data[d.off:] into the value.
0000000000000000000000000000000000000000;;	// it updates d.off to point past the decoded value.
0000000000000000000000000000000000000000;;	func (d *decodeState) value(v reflect.Value) {
0000000000000000000000000000000000000000;;		if !v.IsValid() {
0000000000000000000000000000000000000000;;			_, rest, err := nextValue(d.data[d.off:], &d.nextscan)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.off = len(d.data) - len(rest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// d.scan thinks we're still at the beginning of the item.
0000000000000000000000000000000000000000;;			// Feed in an empty string - the shortest, simplest value -
0000000000000000000000000000000000000000;;			// so that it knows we got to the end of the value.
0000000000000000000000000000000000000000;;			if d.scan.redo {
0000000000000000000000000000000000000000;;				// rewind.
0000000000000000000000000000000000000000;;				d.scan.redo = false
0000000000000000000000000000000000000000;;				d.scan.step = stateBeginValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.scan.step(&d.scan, '"')
0000000000000000000000000000000000000000;;			d.scan.step(&d.scan, '"')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n := len(d.scan.parseState)
0000000000000000000000000000000000000000;;			if n > 0 && d.scan.parseState[n-1] == parseObjectKey {
0000000000000000000000000000000000000000;;				// d.scan thinks we just read an object key; finish the object
0000000000000000000000000000000000000000;;				d.scan.step(&d.scan, ':')
0000000000000000000000000000000000000000;;				d.scan.step(&d.scan, '"')
0000000000000000000000000000000000000000;;				d.scan.step(&d.scan, '"')
0000000000000000000000000000000000000000;;				d.scan.step(&d.scan, '}')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch op := d.scanWhile(scanSkipSpace); op {
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.error(errPhase)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case scanBeginArray:
0000000000000000000000000000000000000000;;			d.array(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case scanBeginObject:
0000000000000000000000000000000000000000;;			d.object(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case scanBeginLiteral:
0000000000000000000000000000000000000000;;			d.literal(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type unquotedValue struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valueQuoted is like value but decodes a
0000000000000000000000000000000000000000;;	// quoted string literal or literal null into an interface value.
0000000000000000000000000000000000000000;;	// If it finds anything other than a quoted string literal or null,
0000000000000000000000000000000000000000;;	// valueQuoted returns unquotedValue{}.
0000000000000000000000000000000000000000;;	func (d *decodeState) valueQuoted() interface{} {
0000000000000000000000000000000000000000;;		switch op := d.scanWhile(scanSkipSpace); op {
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.error(errPhase)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case scanBeginArray:
0000000000000000000000000000000000000000;;			d.array(reflect.Value{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case scanBeginObject:
0000000000000000000000000000000000000000;;			d.object(reflect.Value{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case scanBeginLiteral:
0000000000000000000000000000000000000000;;			switch v := d.literalInterface().(type) {
0000000000000000000000000000000000000000;;			case nil, string:
0000000000000000000000000000000000000000;;				return v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return unquotedValue{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// indirect walks down v allocating pointers as needed,
0000000000000000000000000000000000000000;;	// until it gets to a non-pointer.
0000000000000000000000000000000000000000;;	// if it encounters an Unmarshaler, indirect stops and returns that.
0000000000000000000000000000000000000000;;	// if decodingNull is true, indirect stops at the last pointer so it can be set to nil.
0000000000000000000000000000000000000000;;	func (d *decodeState) indirect(v reflect.Value, decodingNull bool) (Unmarshaler, encoding.TextUnmarshaler, reflect.Value) {
0000000000000000000000000000000000000000;;		// If v is a named type and is addressable,
0000000000000000000000000000000000000000;;		// start with its address, so that if the type has pointer methods,
0000000000000000000000000000000000000000;;		// we find them.
0000000000000000000000000000000000000000;;		if v.Kind() != reflect.Ptr && v.Type().Name() != "" && v.CanAddr() {
0000000000000000000000000000000000000000;;			v = v.Addr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Load value from interface, but only if the result will be
0000000000000000000000000000000000000000;;			// usefully addressable.
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Interface && !v.IsNil() {
0000000000000000000000000000000000000000;;				e := v.Elem()
0000000000000000000000000000000000000000;;				if e.Kind() == reflect.Ptr && !e.IsNil() && (!decodingNull || e.Elem().Kind() == reflect.Ptr) {
0000000000000000000000000000000000000000;;					v = e
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.Elem().Kind() != reflect.Ptr && decodingNull && v.CanSet() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				v.Set(reflect.New(v.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.Type().NumMethod() > 0 {
0000000000000000000000000000000000000000;;				if u, ok := v.Interface().(Unmarshaler); ok {
0000000000000000000000000000000000000000;;					return u, nil, reflect.Value{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if u, ok := v.Interface().(encoding.TextUnmarshaler); ok {
0000000000000000000000000000000000000000;;					return nil, u, reflect.Value{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = v.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil, v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// array consumes an array from d.data[d.off-1:], decoding into the value v.
0000000000000000000000000000000000000000;;	// the first byte of the array ('[') has been read already.
0000000000000000000000000000000000000000;;	func (d *decodeState) array(v reflect.Value) {
0000000000000000000000000000000000000000;;		// Check for unmarshaler.
0000000000000000000000000000000000000000;;		u, ut, pv := d.indirect(v, false)
0000000000000000000000000000000000000000;;		if u != nil {
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			err := u.UnmarshalJSON(d.next())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ut != nil {
0000000000000000000000000000000000000000;;			d.saveError(&UnmarshalTypeError{"array", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			d.next()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v = pv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check type of target.
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if v.NumMethod() == 0 {
0000000000000000000000000000000000000000;;				// Decoding into nil interface?  Switch to non-reflect code.
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(d.arrayInterface()))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Otherwise it's invalid.
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.saveError(&UnmarshalTypeError{"array", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			d.next()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Look ahead for ] - can only happen on first iteration.
0000000000000000000000000000000000000000;;			op := d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndArray {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Back up so d.value can have the byte we just read.
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			d.scan.undo(op)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get element of array, growing if necessary.
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;				// Grow slice if necessary
0000000000000000000000000000000000000000;;				if i >= v.Cap() {
0000000000000000000000000000000000000000;;					newcap := v.Cap() + v.Cap()/2
0000000000000000000000000000000000000000;;					if newcap < 4 {
0000000000000000000000000000000000000000;;						newcap = 4
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					newv := reflect.MakeSlice(v.Type(), v.Len(), newcap)
0000000000000000000000000000000000000000;;					reflect.Copy(newv, v)
0000000000000000000000000000000000000000;;					v.Set(newv)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i >= v.Len() {
0000000000000000000000000000000000000000;;					v.SetLen(i + 1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i < v.Len() {
0000000000000000000000000000000000000000;;				// Decode into element.
0000000000000000000000000000000000000000;;				d.value(v.Index(i))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Ran out of fixed array: skip.
0000000000000000000000000000000000000000;;				d.value(reflect.Value{})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Next token must be , or ].
0000000000000000000000000000000000000000;;			op = d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndArray {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanArrayValue {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i < v.Len() {
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Array {
0000000000000000000000000000000000000000;;				// Array.  Zero the rest.
0000000000000000000000000000000000000000;;				z := reflect.Zero(v.Type().Elem())
0000000000000000000000000000000000000000;;				for ; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;					v.Index(i).Set(z)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				v.SetLen(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i == 0 && v.Kind() == reflect.Slice {
0000000000000000000000000000000000000000;;			v.Set(reflect.MakeSlice(v.Type(), 0, 0))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var nullLiteral = []byte("null")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// object consumes an object from d.data[d.off-1:], decoding into the value v.
0000000000000000000000000000000000000000;;	// the first byte ('{') of the object has been read already.
0000000000000000000000000000000000000000;;	func (d *decodeState) object(v reflect.Value) {
0000000000000000000000000000000000000000;;		// Check for unmarshaler.
0000000000000000000000000000000000000000;;		u, ut, pv := d.indirect(v, false)
0000000000000000000000000000000000000000;;		if u != nil {
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			err := u.UnmarshalJSON(d.next())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ut != nil {
0000000000000000000000000000000000000000;;			d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			d.next() // skip over { } in input
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = pv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decoding into nil interface?  Switch to non-reflect code.
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Interface && v.NumMethod() == 0 {
0000000000000000000000000000000000000000;;			v.Set(reflect.ValueOf(d.objectInterface()))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check type of target: struct or map[string]T
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			// map must have string kind
0000000000000000000000000000000000000000;;			t := v.Type()
0000000000000000000000000000000000000000;;			if t.Key().Kind() != reflect.String {
0000000000000000000000000000000000000000;;				d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;				d.off--
0000000000000000000000000000000000000000;;				d.next() // skip over { } in input
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				v.Set(reflect.MakeMap(t))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.saveError(&UnmarshalTypeError{"object", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			d.next() // skip over { } in input
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var mapElem reflect.Value
0000000000000000000000000000000000000000;;		keys := map[string]bool{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Read opening " of string key or closing }.
0000000000000000000000000000000000000000;;			op := d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndObject {
0000000000000000000000000000000000000000;;				// closing } - can only happen on first iteration.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanBeginLiteral {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read key.
0000000000000000000000000000000000000000;;			start := d.off - 1
0000000000000000000000000000000000000000;;			op = d.scanWhile(scanContinue)
0000000000000000000000000000000000000000;;			item := d.data[start : d.off-1]
0000000000000000000000000000000000000000;;			key, ok := unquote(item)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for duplicate keys.
0000000000000000000000000000000000000000;;			_, ok = keys[key]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				keys[key] = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.error(fmt.Errorf("json: duplicate key '%s' in object", key))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Figure out field corresponding to key.
0000000000000000000000000000000000000000;;			var subv reflect.Value
0000000000000000000000000000000000000000;;			destring := false // whether the value is wrapped in a string to be decoded first
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;				elemType := v.Type().Elem()
0000000000000000000000000000000000000000;;				if !mapElem.IsValid() {
0000000000000000000000000000000000000000;;					mapElem = reflect.New(elemType).Elem()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					mapElem.Set(reflect.Zero(elemType))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subv = mapElem
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var f *field
0000000000000000000000000000000000000000;;				fields := cachedTypeFields(v.Type())
0000000000000000000000000000000000000000;;				for i := range fields {
0000000000000000000000000000000000000000;;					ff := &fields[i]
0000000000000000000000000000000000000000;;					if bytes.Equal(ff.nameBytes, []byte(key)) {
0000000000000000000000000000000000000000;;						f = ff
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if f != nil {
0000000000000000000000000000000000000000;;					subv = v
0000000000000000000000000000000000000000;;					destring = f.quoted
0000000000000000000000000000000000000000;;					for _, i := range f.index {
0000000000000000000000000000000000000000;;						if subv.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;							if subv.IsNil() {
0000000000000000000000000000000000000000;;								subv.Set(reflect.New(subv.Type().Elem()))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							subv = subv.Elem()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						subv = subv.Field(i)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read : before value.
0000000000000000000000000000000000000000;;			if op == scanSkipSpace {
0000000000000000000000000000000000000000;;				op = d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanObjectKey {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read value.
0000000000000000000000000000000000000000;;			if destring {
0000000000000000000000000000000000000000;;				switch qv := d.valueQuoted().(type) {
0000000000000000000000000000000000000000;;				case nil:
0000000000000000000000000000000000000000;;					d.literalStore(nullLiteral, subv, false)
0000000000000000000000000000000000000000;;				case string:
0000000000000000000000000000000000000000;;					d.literalStore([]byte(qv), subv, true)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal unquoted value into %v", subv.Type()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.value(subv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write value back to map;
0000000000000000000000000000000000000000;;			// if using struct, subv points into struct already.
0000000000000000000000000000000000000000;;			if v.Kind() == reflect.Map {
0000000000000000000000000000000000000000;;				kv := reflect.ValueOf(key).Convert(v.Type().Key())
0000000000000000000000000000000000000000;;				v.SetMapIndex(kv, subv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Next token must be , or }.
0000000000000000000000000000000000000000;;			op = d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndObject {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanObjectValue {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// literal consumes a literal from d.data[d.off-1:], decoding into the value v.
0000000000000000000000000000000000000000;;	// The first byte of the literal has been read already
0000000000000000000000000000000000000000;;	// (that's how the caller knows it's a literal).
0000000000000000000000000000000000000000;;	func (d *decodeState) literal(v reflect.Value) {
0000000000000000000000000000000000000000;;		// All bytes inside literal return scanContinue op code.
0000000000000000000000000000000000000000;;		start := d.off - 1
0000000000000000000000000000000000000000;;		op := d.scanWhile(scanContinue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan read one byte too far; back up.
0000000000000000000000000000000000000000;;		d.off--
0000000000000000000000000000000000000000;;		d.scan.undo(op)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.literalStore(d.data[start:d.off], v, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// convertNumber converts the number literal s to a float64 or a Number
0000000000000000000000000000000000000000;;	// depending on the setting of d.useNumber.
0000000000000000000000000000000000000000;;	func (d *decodeState) convertNumber(s string) (interface{}, error) {
0000000000000000000000000000000000000000;;		if d.useNumber {
0000000000000000000000000000000000000000;;			return Number(s), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := strconv.ParseFloat(s, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, &UnmarshalTypeError{"number " + s, reflect.TypeOf(0.0), int64(d.off)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var numberType = reflect.TypeOf(Number(""))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// literalStore decodes a literal stored in item into v.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// fromQuoted indicates whether this literal came from unwrapping a
0000000000000000000000000000000000000000;;	// string from the ",string" struct tag option. this is used only to
0000000000000000000000000000000000000000;;	// produce more helpful error messages.
0000000000000000000000000000000000000000;;	func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) {
0000000000000000000000000000000000000000;;		// Check for unmarshaler.
0000000000000000000000000000000000000000;;		if len(item) == 0 {
0000000000000000000000000000000000000000;;			//Empty string given
0000000000000000000000000000000000000000;;			d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wantptr := item[0] == 'n' // null
0000000000000000000000000000000000000000;;		u, ut, pv := d.indirect(v, wantptr)
0000000000000000000000000000000000000000;;		if u != nil {
0000000000000000000000000000000000000000;;			err := u.UnmarshalJSON(item)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ut != nil {
0000000000000000000000000000000000000000;;			if item[0] != '"' {
0000000000000000000000000000000000000000;;				if fromQuoted {
0000000000000000000000000000000000000000;;					d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s, ok := unquoteBytes(item)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if fromQuoted {
0000000000000000000000000000000000000000;;					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.error(errPhase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := ut.UnmarshalText(s)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.error(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v = pv
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c := item[0]; c {
0000000000000000000000000000000000000000;;		case 'n': // null
0000000000000000000000000000000000000000;;			switch v.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Interface, reflect.Ptr, reflect.Map, reflect.Slice:
0000000000000000000000000000000000000000;;				v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;				// otherwise, ignore null for primitives/string
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 't', 'f': // true, false
0000000000000000000000000000000000000000;;			value := c == 't'
0000000000000000000000000000000000000000;;			switch v.Kind() {
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if fromQuoted {
0000000000000000000000000000000000000000;;					d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"bool", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				v.SetBool(value)
0000000000000000000000000000000000000000;;			case reflect.Interface:
0000000000000000000000000000000000000000;;				if v.NumMethod() == 0 {
0000000000000000000000000000000000000000;;					v.Set(reflect.ValueOf(value))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"bool", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case '"': // string
0000000000000000000000000000000000000000;;			s, ok := unquoteBytes(item)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				if fromQuoted {
0000000000000000000000000000000000000000;;					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.error(errPhase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch v.Kind() {
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				if v.Type().Elem().Kind() != reflect.Uint8 {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b := make([]byte, base64.StdEncoding.DecodedLen(len(s)))
0000000000000000000000000000000000000000;;				n, err := base64.StdEncoding.Decode(b, s)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					d.saveError(err)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.SetBytes(b[:n])
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				v.SetString(string(s))
0000000000000000000000000000000000000000;;			case reflect.Interface:
0000000000000000000000000000000000000000;;				if v.NumMethod() == 0 {
0000000000000000000000000000000000000000;;					v.Set(reflect.ValueOf(string(s)))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"string", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default: // number
0000000000000000000000000000000000000000;;			if c != '-' && (c < '0' || c > '9') {
0000000000000000000000000000000000000000;;				if fromQuoted {
0000000000000000000000000000000000000000;;					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.error(errPhase)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s := string(item)
0000000000000000000000000000000000000000;;			switch v.Kind() {
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if v.Kind() == reflect.String && v.Type() == numberType {
0000000000000000000000000000000000000000;;					v.SetString(s)
0000000000000000000000000000000000000000;;					if !isValidNumber(s) {
0000000000000000000000000000000000000000;;						d.error(fmt.Errorf("json: invalid number literal, trying to unmarshal %q into Number", item))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if fromQuoted {
0000000000000000000000000000000000000000;;					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", item, v.Type()))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					d.error(&UnmarshalTypeError{"number", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Interface:
0000000000000000000000000000000000000000;;				n, err := d.convertNumber(s)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					d.saveError(err)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v.NumMethod() != 0 {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"number", v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(n))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;				n, err := strconv.ParseInt(s, 10, 64)
0000000000000000000000000000000000000000;;				if err != nil || v.OverflowInt(n) {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.SetInt(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;				n, err := strconv.ParseUint(s, 10, 64)
0000000000000000000000000000000000000000;;				if err != nil || v.OverflowUint(n) {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.SetUint(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;				n, err := strconv.ParseFloat(s, v.Type().Bits())
0000000000000000000000000000000000000000;;				if err != nil || v.OverflowFloat(n) {
0000000000000000000000000000000000000000;;					d.saveError(&UnmarshalTypeError{"number " + s, v.Type(), int64(d.off)})
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.SetFloat(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The xxxInterface routines build up a value to be stored
0000000000000000000000000000000000000000;;	// in an empty interface.  They are not strictly necessary,
0000000000000000000000000000000000000000;;	// but they avoid the weight of reflection in this common case.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valueInterface is like value but returns interface{}
0000000000000000000000000000000000000000;;	func (d *decodeState) valueInterface() interface{} {
0000000000000000000000000000000000000000;;		switch d.scanWhile(scanSkipSpace) {
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.error(errPhase)
0000000000000000000000000000000000000000;;			panic("unreachable")
0000000000000000000000000000000000000000;;		case scanBeginArray:
0000000000000000000000000000000000000000;;			return d.arrayInterface()
0000000000000000000000000000000000000000;;		case scanBeginObject:
0000000000000000000000000000000000000000;;			return d.objectInterface()
0000000000000000000000000000000000000000;;		case scanBeginLiteral:
0000000000000000000000000000000000000000;;			return d.literalInterface()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// arrayInterface is like array but returns []interface{}.
0000000000000000000000000000000000000000;;	func (d *decodeState) arrayInterface() []interface{} {
0000000000000000000000000000000000000000;;		var v = make([]interface{}, 0)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Look ahead for ] - can only happen on first iteration.
0000000000000000000000000000000000000000;;			op := d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndArray {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Back up so d.value can have the byte we just read.
0000000000000000000000000000000000000000;;			d.off--
0000000000000000000000000000000000000000;;			d.scan.undo(op)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v = append(v, d.valueInterface())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Next token must be , or ].
0000000000000000000000000000000000000000;;			op = d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndArray {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanArrayValue {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectInterface is like object but returns map[string]interface{}.
0000000000000000000000000000000000000000;;	func (d *decodeState) objectInterface() map[string]interface{} {
0000000000000000000000000000000000000000;;		m := make(map[string]interface{})
0000000000000000000000000000000000000000;;		keys := map[string]bool{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Read opening " of string key or closing }.
0000000000000000000000000000000000000000;;			op := d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndObject {
0000000000000000000000000000000000000000;;				// closing } - can only happen on first iteration.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanBeginLiteral {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read string key.
0000000000000000000000000000000000000000;;			start := d.off - 1
0000000000000000000000000000000000000000;;			op = d.scanWhile(scanContinue)
0000000000000000000000000000000000000000;;			item := d.data[start : d.off-1]
0000000000000000000000000000000000000000;;			key, ok := unquote(item)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for duplicate keys.
0000000000000000000000000000000000000000;;			_, ok = keys[key]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				keys[key] = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.error(fmt.Errorf("json: duplicate key '%s' in object", key))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read : before value.
0000000000000000000000000000000000000000;;			if op == scanSkipSpace {
0000000000000000000000000000000000000000;;				op = d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanObjectKey {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Read value.
0000000000000000000000000000000000000000;;			m[key] = d.valueInterface()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Next token must be , or }.
0000000000000000000000000000000000000000;;			op = d.scanWhile(scanSkipSpace)
0000000000000000000000000000000000000000;;			if op == scanEndObject {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if op != scanObjectValue {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// literalInterface is like literal but returns an interface value.
0000000000000000000000000000000000000000;;	func (d *decodeState) literalInterface() interface{} {
0000000000000000000000000000000000000000;;		// All bytes inside literal return scanContinue op code.
0000000000000000000000000000000000000000;;		start := d.off - 1
0000000000000000000000000000000000000000;;		op := d.scanWhile(scanContinue)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan read one byte too far; back up.
0000000000000000000000000000000000000000;;		d.off--
0000000000000000000000000000000000000000;;		d.scan.undo(op)
0000000000000000000000000000000000000000;;		item := d.data[start:d.off]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c := item[0]; c {
0000000000000000000000000000000000000000;;		case 'n': // null
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case 't', 'f': // true, false
0000000000000000000000000000000000000000;;			return c == 't'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case '"': // string
0000000000000000000000000000000000000000;;			s, ok := unquote(item)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default: // number
0000000000000000000000000000000000000000;;			if c != '-' && (c < '0' || c > '9') {
0000000000000000000000000000000000000000;;				d.error(errPhase)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, err := d.convertNumber(string(item))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				d.saveError(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getu4 decodes \uXXXX from the beginning of s, returning the hex value,
0000000000000000000000000000000000000000;;	// or it returns -1.
0000000000000000000000000000000000000000;;	func getu4(s []byte) rune {
0000000000000000000000000000000000000000;;		if len(s) < 6 || s[0] != '\\' || s[1] != 'u' {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, err := strconv.ParseUint(string(s[2:6]), 16, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rune(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unquote converts a quoted JSON string literal s into an actual string t.
0000000000000000000000000000000000000000;;	// The rules are different than for Go, so cannot use strconv.Unquote.
0000000000000000000000000000000000000000;;	func unquote(s []byte) (t string, ok bool) {
0000000000000000000000000000000000000000;;		s, ok = unquoteBytes(s)
0000000000000000000000000000000000000000;;		t = string(s)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unquoteBytes(s []byte) (t []byte, ok bool) {
0000000000000000000000000000000000000000;;		if len(s) < 2 || s[0] != '"' || s[len(s)-1] != '"' {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = s[1 : len(s)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for unusual characters. If there are none,
0000000000000000000000000000000000000000;;		// then no unquoting is needed, so return a slice of the
0000000000000000000000000000000000000000;;		// original bytes.
0000000000000000000000000000000000000000;;		r := 0
0000000000000000000000000000000000000000;;		for r < len(s) {
0000000000000000000000000000000000000000;;			c := s[r]
0000000000000000000000000000000000000000;;			if c == '\\' || c == '"' || c < ' ' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c < utf8.RuneSelf {
0000000000000000000000000000000000000000;;				r++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rr, size := utf8.DecodeRune(s[r:])
0000000000000000000000000000000000000000;;			if rr == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r += size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r == len(s) {
0000000000000000000000000000000000000000;;			return s, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b := make([]byte, len(s)+2*utf8.UTFMax)
0000000000000000000000000000000000000000;;		w := copy(b, s[0:r])
0000000000000000000000000000000000000000;;		for r < len(s) {
0000000000000000000000000000000000000000;;			// Out of room?  Can only happen if s is full of
0000000000000000000000000000000000000000;;			// malformed UTF-8 and we're replacing each
0000000000000000000000000000000000000000;;			// byte with RuneError.
0000000000000000000000000000000000000000;;			if w >= len(b)-2*utf8.UTFMax {
0000000000000000000000000000000000000000;;				nb := make([]byte, (len(b)+utf8.UTFMax)*2)
0000000000000000000000000000000000000000;;				copy(nb, b[0:w])
0000000000000000000000000000000000000000;;				b = nb
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c := s[r]; {
0000000000000000000000000000000000000000;;			case c == '\\':
0000000000000000000000000000000000000000;;				r++
0000000000000000000000000000000000000000;;				if r >= len(s) {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch s[r] {
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				case '"', '\\', '/', '\'':
0000000000000000000000000000000000000000;;					b[w] = s[r]
0000000000000000000000000000000000000000;;					r++
0000000000000000000000000000000000000000;;					w++
0000000000000000000000000000000000000000;;				case 'b':
0000000000000000000000000000000000000000;;					b[w] = '\b'
0000000000000000000000000000000000000000;;					r++
0000000000000000000000000000000000000000;;					w++
0000000000000000000000000000000000000000;;				case 'f':
0000000000000000000000000000000000000000;;					b[w] = '\f'
0000000000000000000000000000000000000000;;					r++
0000000000000000000000000000000000000000;;					w++
0000000000000000000000000000000000000000;;				case 'n':
0000000000000000000000000000000000000000;;					b[w] = '\n'
0000000000000000000000000000000000000000;;					r++
0000000000000000000000000000000000000000;;					w++
0000000000000000000000000000000000000000;;				case 'r':
0000000000000000000000000000000000000000;;					b[w] = '\r'
0000000000000000000000000000000000000000;;					r++
0000000000000000000000000000000000000000;;					w++
0000000000000000000000000000000000000000;;				case 't':
0000000000000000000000000000000000000000;;					b[w] = '\t'
0000000000000000000000000000000000000000;;					r++
0000000000000000000000000000000000000000;;					w++
0000000000000000000000000000000000000000;;				case 'u':
0000000000000000000000000000000000000000;;					r--
0000000000000000000000000000000000000000;;					rr := getu4(s[r:])
0000000000000000000000000000000000000000;;					if rr < 0 {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					r += 6
0000000000000000000000000000000000000000;;					if utf16.IsSurrogate(rr) {
0000000000000000000000000000000000000000;;						rr1 := getu4(s[r:])
0000000000000000000000000000000000000000;;						if dec := utf16.DecodeRune(rr, rr1); dec != unicode.ReplacementChar {
0000000000000000000000000000000000000000;;							// A valid pair; consume.
0000000000000000000000000000000000000000;;							r += 6
0000000000000000000000000000000000000000;;							w += utf8.EncodeRune(b[w:], dec)
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// Invalid surrogate; fall back to replacement rune.
0000000000000000000000000000000000000000;;						rr = unicode.ReplacementChar
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					w += utf8.EncodeRune(b[w:], rr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Quote, control characters are invalid.
0000000000000000000000000000000000000000;;			case c == '"', c < ' ':
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ASCII
0000000000000000000000000000000000000000;;			case c < utf8.RuneSelf:
0000000000000000000000000000000000000000;;				b[w] = c
0000000000000000000000000000000000000000;;				r++
0000000000000000000000000000000000000000;;				w++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Coerce to well-formed UTF-8.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				rr, size := utf8.DecodeRune(s[r:])
0000000000000000000000000000000000000000;;				r += size
0000000000000000000000000000000000000000;;				w += utf8.EncodeRune(b[w:], rr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b[0:w], true
0000000000000000000000000000000000000000;;	}
