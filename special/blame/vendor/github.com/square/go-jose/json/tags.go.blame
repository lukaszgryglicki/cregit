0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tagOptions is the string following a comma in a struct field's "json"
0000000000000000000000000000000000000000;;	// tag, or the empty string. It does not include the leading comma.
0000000000000000000000000000000000000000;;	type tagOptions string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseTag splits a struct field's json tag into its name and
0000000000000000000000000000000000000000;;	// comma-separated options.
0000000000000000000000000000000000000000;;	func parseTag(tag string) (string, tagOptions) {
0000000000000000000000000000000000000000;;		if idx := strings.Index(tag, ","); idx != -1 {
0000000000000000000000000000000000000000;;			return tag[:idx], tagOptions(tag[idx+1:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tag, tagOptions("")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains reports whether a comma-separated list of options
0000000000000000000000000000000000000000;;	// contains a particular substr flag. substr must be surrounded by a
0000000000000000000000000000000000000000;;	// string boundary or commas.
0000000000000000000000000000000000000000;;	func (o tagOptions) Contains(optionName string) bool {
0000000000000000000000000000000000000000;;		if len(o) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := string(o)
0000000000000000000000000000000000000000;;		for s != "" {
0000000000000000000000000000000000000000;;			var next string
0000000000000000000000000000000000000000;;			i := strings.Index(s, ",")
0000000000000000000000000000000000000000;;			if i >= 0 {
0000000000000000000000000000000000000000;;				s, next = s[:i], s[i+1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s == optionName {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
