0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import "bytes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compact appends to dst the JSON-encoded src with
0000000000000000000000000000000000000000;;	// insignificant space characters elided.
0000000000000000000000000000000000000000;;	func Compact(dst *bytes.Buffer, src []byte) error {
0000000000000000000000000000000000000000;;		return compact(dst, src, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func compact(dst *bytes.Buffer, src []byte, escape bool) error {
0000000000000000000000000000000000000000;;		origLen := dst.Len()
0000000000000000000000000000000000000000;;		var scan scanner
0000000000000000000000000000000000000000;;		scan.reset()
0000000000000000000000000000000000000000;;		start := 0
0000000000000000000000000000000000000000;;		for i, c := range src {
0000000000000000000000000000000000000000;;			if escape && (c == '<' || c == '>' || c == '&') {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					dst.Write(src[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst.WriteString(`\u00`)
0000000000000000000000000000000000000000;;				dst.WriteByte(hex[c>>4])
0000000000000000000000000000000000000000;;				dst.WriteByte(hex[c&0xF])
0000000000000000000000000000000000000000;;				start = i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Convert U+2028 and U+2029 (E2 80 A8 and E2 80 A9).
0000000000000000000000000000000000000000;;			if c == 0xE2 && i+2 < len(src) && src[i+1] == 0x80 && src[i+2]&^1 == 0xA8 {
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					dst.Write(src[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst.WriteString(`\u202`)
0000000000000000000000000000000000000000;;				dst.WriteByte(hex[src[i+2]&0xF])
0000000000000000000000000000000000000000;;				start = i + 3
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v := scan.step(&scan, c)
0000000000000000000000000000000000000000;;			if v >= scanSkipSpace {
0000000000000000000000000000000000000000;;				if v == scanError {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if start < i {
0000000000000000000000000000000000000000;;					dst.Write(src[start:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				start = i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scan.eof() == scanError {
0000000000000000000000000000000000000000;;			dst.Truncate(origLen)
0000000000000000000000000000000000000000;;			return scan.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if start < len(src) {
0000000000000000000000000000000000000000;;			dst.Write(src[start:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newline(dst *bytes.Buffer, prefix, indent string, depth int) {
0000000000000000000000000000000000000000;;		dst.WriteByte('\n')
0000000000000000000000000000000000000000;;		dst.WriteString(prefix)
0000000000000000000000000000000000000000;;		for i := 0; i < depth; i++ {
0000000000000000000000000000000000000000;;			dst.WriteString(indent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Indent appends to dst an indented form of the JSON-encoded src.
0000000000000000000000000000000000000000;;	// Each element in a JSON object or array begins on a new,
0000000000000000000000000000000000000000;;	// indented line beginning with prefix followed by one or more
0000000000000000000000000000000000000000;;	// copies of indent according to the indentation nesting.
0000000000000000000000000000000000000000;;	// The data appended to dst does not begin with the prefix nor
0000000000000000000000000000000000000000;;	// any indentation, to make it easier to embed inside other formatted JSON data.
0000000000000000000000000000000000000000;;	// Although leading space characters (space, tab, carriage return, newline)
0000000000000000000000000000000000000000;;	// at the beginning of src are dropped, trailing space characters
0000000000000000000000000000000000000000;;	// at the end of src are preserved and copied to dst.
0000000000000000000000000000000000000000;;	// For example, if src has no trailing spaces, neither will dst;
0000000000000000000000000000000000000000;;	// if src ends in a trailing newline, so will dst.
0000000000000000000000000000000000000000;;	func Indent(dst *bytes.Buffer, src []byte, prefix, indent string) error {
0000000000000000000000000000000000000000;;		origLen := dst.Len()
0000000000000000000000000000000000000000;;		var scan scanner
0000000000000000000000000000000000000000;;		scan.reset()
0000000000000000000000000000000000000000;;		needIndent := false
0000000000000000000000000000000000000000;;		depth := 0
0000000000000000000000000000000000000000;;		for _, c := range src {
0000000000000000000000000000000000000000;;			scan.bytes++
0000000000000000000000000000000000000000;;			v := scan.step(&scan, c)
0000000000000000000000000000000000000000;;			if v == scanSkipSpace {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v == scanError {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if needIndent && v != scanEndObject && v != scanEndArray {
0000000000000000000000000000000000000000;;				needIndent = false
0000000000000000000000000000000000000000;;				depth++
0000000000000000000000000000000000000000;;				newline(dst, prefix, indent, depth)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Emit semantically uninteresting bytes
0000000000000000000000000000000000000000;;			// (in particular, punctuation in strings) unmodified.
0000000000000000000000000000000000000000;;			if v == scanContinue {
0000000000000000000000000000000000000000;;				dst.WriteByte(c)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add spacing around real punctuation.
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case '{', '[':
0000000000000000000000000000000000000000;;				// delay indent so that empty object and array are formatted as {} and [].
0000000000000000000000000000000000000000;;				needIndent = true
0000000000000000000000000000000000000000;;				dst.WriteByte(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ',':
0000000000000000000000000000000000000000;;				dst.WriteByte(c)
0000000000000000000000000000000000000000;;				newline(dst, prefix, indent, depth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ':':
0000000000000000000000000000000000000000;;				dst.WriteByte(c)
0000000000000000000000000000000000000000;;				dst.WriteByte(' ')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '}', ']':
0000000000000000000000000000000000000000;;				if needIndent {
0000000000000000000000000000000000000000;;					// suppress indent in empty object/array
0000000000000000000000000000000000000000;;					needIndent = false
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					depth--
0000000000000000000000000000000000000000;;					newline(dst, prefix, indent, depth)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dst.WriteByte(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				dst.WriteByte(c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if scan.eof() == scanError {
0000000000000000000000000000000000000000;;			dst.Truncate(origLen)
0000000000000000000000000000000000000000;;			return scan.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
