0000000000000000000000000000000000000000;;	// Copyright 2010 The Go Authors.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package json
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Decoder reads and decodes JSON objects from an input stream.
0000000000000000000000000000000000000000;;	type Decoder struct {
0000000000000000000000000000000000000000;;		r     io.Reader
0000000000000000000000000000000000000000;;		buf   []byte
0000000000000000000000000000000000000000;;		d     decodeState
0000000000000000000000000000000000000000;;		scanp int // start of unread data in buf
0000000000000000000000000000000000000000;;		scan  scanner
0000000000000000000000000000000000000000;;		err   error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokenState int
0000000000000000000000000000000000000000;;		tokenStack []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder returns a new decoder that reads from r.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The decoder introduces its own buffering and may
0000000000000000000000000000000000000000;;	// read data from r beyond the JSON values requested.
0000000000000000000000000000000000000000;;	func NewDecoder(r io.Reader) *Decoder {
0000000000000000000000000000000000000000;;		return &Decoder{r: r}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UseNumber causes the Decoder to unmarshal a number into an interface{} as a
0000000000000000000000000000000000000000;;	// Number instead of as a float64.
0000000000000000000000000000000000000000;;	func (dec *Decoder) UseNumber() { dec.d.useNumber = true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode reads the next JSON-encoded value from its
0000000000000000000000000000000000000000;;	// input and stores it in the value pointed to by v.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the documentation for Unmarshal for details about
0000000000000000000000000000000000000000;;	// the conversion of JSON into a Go value.
0000000000000000000000000000000000000000;;	func (dec *Decoder) Decode(v interface{}) error {
0000000000000000000000000000000000000000;;		if dec.err != nil {
0000000000000000000000000000000000000000;;			return dec.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := dec.tokenPrepareForDecode(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !dec.tokenValueAllowed() {
0000000000000000000000000000000000000000;;			return &SyntaxError{msg: "not at beginning of value"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read whole value into buffer.
0000000000000000000000000000000000000000;;		n, err := dec.readValue()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dec.d.init(dec.buf[dec.scanp : dec.scanp+n])
0000000000000000000000000000000000000000;;		dec.scanp += n
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Don't save err from unmarshal into dec.err:
0000000000000000000000000000000000000000;;		// the connection is still usable since we read a complete JSON
0000000000000000000000000000000000000000;;		// object from it before the error happened.
0000000000000000000000000000000000000000;;		err = dec.d.unmarshal(v)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fixup token streaming state
0000000000000000000000000000000000000000;;		dec.tokenValueEnd()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Buffered returns a reader of the data remaining in the Decoder's
0000000000000000000000000000000000000000;;	// buffer. The reader is valid until the next call to Decode.
0000000000000000000000000000000000000000;;	func (dec *Decoder) Buffered() io.Reader {
0000000000000000000000000000000000000000;;		return bytes.NewReader(dec.buf[dec.scanp:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readValue reads a JSON value into dec.buf.
0000000000000000000000000000000000000000;;	// It returns the length of the encoding.
0000000000000000000000000000000000000000;;	func (dec *Decoder) readValue() (int, error) {
0000000000000000000000000000000000000000;;		dec.scan.reset()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanp := dec.scanp
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	Input:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Look in the buffer for a new value.
0000000000000000000000000000000000000000;;			for i, c := range dec.buf[scanp:] {
0000000000000000000000000000000000000000;;				dec.scan.bytes++
0000000000000000000000000000000000000000;;				v := dec.scan.step(&dec.scan, c)
0000000000000000000000000000000000000000;;				if v == scanEnd {
0000000000000000000000000000000000000000;;					scanp += i
0000000000000000000000000000000000000000;;					break Input
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// scanEnd is delayed one byte.
0000000000000000000000000000000000000000;;				// We might block trying to get that byte from src,
0000000000000000000000000000000000000000;;				// so instead invent a space byte.
0000000000000000000000000000000000000000;;				if (v == scanEndObject || v == scanEndArray) && dec.scan.step(&dec.scan, ' ') == scanEnd {
0000000000000000000000000000000000000000;;					scanp += i + 1
0000000000000000000000000000000000000000;;					break Input
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v == scanError {
0000000000000000000000000000000000000000;;					dec.err = dec.scan.err
0000000000000000000000000000000000000000;;					return 0, dec.scan.err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			scanp = len(dec.buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Did the last read have an error?
0000000000000000000000000000000000000000;;			// Delayed until now to allow buffer scan.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					if dec.scan.step(&dec.scan, ' ') == scanEnd {
0000000000000000000000000000000000000000;;						break Input
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if nonSpace(dec.buf) {
0000000000000000000000000000000000000000;;						err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.err = err
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n := scanp - dec.scanp
0000000000000000000000000000000000000000;;			err = dec.refill()
0000000000000000000000000000000000000000;;			scanp = dec.scanp + n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return scanp - dec.scanp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *Decoder) refill() error {
0000000000000000000000000000000000000000;;		// Make room to read more into the buffer.
0000000000000000000000000000000000000000;;		// First slide down data already consumed.
0000000000000000000000000000000000000000;;		if dec.scanp > 0 {
0000000000000000000000000000000000000000;;			n := copy(dec.buf, dec.buf[dec.scanp:])
0000000000000000000000000000000000000000;;			dec.buf = dec.buf[:n]
0000000000000000000000000000000000000000;;			dec.scanp = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Grow buffer if not large enough.
0000000000000000000000000000000000000000;;		const minRead = 512
0000000000000000000000000000000000000000;;		if cap(dec.buf)-len(dec.buf) < minRead {
0000000000000000000000000000000000000000;;			newBuf := make([]byte, len(dec.buf), 2*cap(dec.buf)+minRead)
0000000000000000000000000000000000000000;;			copy(newBuf, dec.buf)
0000000000000000000000000000000000000000;;			dec.buf = newBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read.  Delay error for next iteration (after scan).
0000000000000000000000000000000000000000;;		n, err := dec.r.Read(dec.buf[len(dec.buf):cap(dec.buf)])
0000000000000000000000000000000000000000;;		dec.buf = dec.buf[0 : len(dec.buf)+n]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nonSpace(b []byte) bool {
0000000000000000000000000000000000000000;;		for _, c := range b {
0000000000000000000000000000000000000000;;			if !isSpace(c) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Encoder writes JSON objects to an output stream.
0000000000000000000000000000000000000000;;	type Encoder struct {
0000000000000000000000000000000000000000;;		w   io.Writer
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncoder returns a new encoder that writes to w.
0000000000000000000000000000000000000000;;	func NewEncoder(w io.Writer) *Encoder {
0000000000000000000000000000000000000000;;		return &Encoder{w: w}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode writes the JSON encoding of v to the stream,
0000000000000000000000000000000000000000;;	// followed by a newline character.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the documentation for Marshal for details about the
0000000000000000000000000000000000000000;;	// conversion of Go values to JSON.
0000000000000000000000000000000000000000;;	func (enc *Encoder) Encode(v interface{}) error {
0000000000000000000000000000000000000000;;		if enc.err != nil {
0000000000000000000000000000000000000000;;			return enc.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := newEncodeState()
0000000000000000000000000000000000000000;;		err := e.marshal(v)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Terminate each value with a newline.
0000000000000000000000000000000000000000;;		// This makes the output look a little nicer
0000000000000000000000000000000000000000;;		// when debugging, and some kind of space
0000000000000000000000000000000000000000;;		// is required if the encoded value was a number,
0000000000000000000000000000000000000000;;		// so that the reader knows there aren't more
0000000000000000000000000000000000000000;;		// digits coming.
0000000000000000000000000000000000000000;;		e.WriteByte('\n')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err = enc.w.Write(e.Bytes()); err != nil {
0000000000000000000000000000000000000000;;			enc.err = err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		encodeStatePool.Put(e)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RawMessage is a raw encoded JSON object.
0000000000000000000000000000000000000000;;	// It implements Marshaler and Unmarshaler and can
0000000000000000000000000000000000000000;;	// be used to delay JSON decoding or precompute a JSON encoding.
0000000000000000000000000000000000000000;;	type RawMessage []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON returns *m as the JSON encoding of m.
0000000000000000000000000000000000000000;;	func (m *RawMessage) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return *m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON sets *m to a copy of data.
0000000000000000000000000000000000000000;;	func (m *RawMessage) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return errors.New("json.RawMessage: UnmarshalJSON on nil pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*m = append((*m)[0:0], data...)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Marshaler = (*RawMessage)(nil)
0000000000000000000000000000000000000000;;	var _ Unmarshaler = (*RawMessage)(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Token holds a value of one of these types:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	Delim, for the four JSON delimiters [ ] { }
0000000000000000000000000000000000000000;;	//	bool, for JSON booleans
0000000000000000000000000000000000000000;;	//	float64, for JSON numbers
0000000000000000000000000000000000000000;;	//	Number, for JSON numbers
0000000000000000000000000000000000000000;;	//	string, for JSON string literals
0000000000000000000000000000000000000000;;	//	nil, for JSON null
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	type Token interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tokenTopValue = iota
0000000000000000000000000000000000000000;;		tokenArrayStart
0000000000000000000000000000000000000000;;		tokenArrayValue
0000000000000000000000000000000000000000;;		tokenArrayComma
0000000000000000000000000000000000000000;;		tokenObjectStart
0000000000000000000000000000000000000000;;		tokenObjectKey
0000000000000000000000000000000000000000;;		tokenObjectColon
0000000000000000000000000000000000000000;;		tokenObjectValue
0000000000000000000000000000000000000000;;		tokenObjectComma
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// advance tokenstate from a separator state to a value state
0000000000000000000000000000000000000000;;	func (dec *Decoder) tokenPrepareForDecode() error {
0000000000000000000000000000000000000000;;		// Note: Not calling peek before switch, to avoid
0000000000000000000000000000000000000000;;		// putting peek into the standard Decode path.
0000000000000000000000000000000000000000;;		// peek is only called when using the Token API.
0000000000000000000000000000000000000000;;		switch dec.tokenState {
0000000000000000000000000000000000000000;;		case tokenArrayComma:
0000000000000000000000000000000000000000;;			c, err := dec.peek()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != ',' {
0000000000000000000000000000000000000000;;				return &SyntaxError{"expected comma after array element", 0}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec.scanp++
0000000000000000000000000000000000000000;;			dec.tokenState = tokenArrayValue
0000000000000000000000000000000000000000;;		case tokenObjectColon:
0000000000000000000000000000000000000000;;			c, err := dec.peek()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c != ':' {
0000000000000000000000000000000000000000;;				return &SyntaxError{"expected colon after object key", 0}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dec.scanp++
0000000000000000000000000000000000000000;;			dec.tokenState = tokenObjectValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *Decoder) tokenValueAllowed() bool {
0000000000000000000000000000000000000000;;		switch dec.tokenState {
0000000000000000000000000000000000000000;;		case tokenTopValue, tokenArrayStart, tokenArrayValue, tokenObjectValue:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *Decoder) tokenValueEnd() {
0000000000000000000000000000000000000000;;		switch dec.tokenState {
0000000000000000000000000000000000000000;;		case tokenArrayStart, tokenArrayValue:
0000000000000000000000000000000000000000;;			dec.tokenState = tokenArrayComma
0000000000000000000000000000000000000000;;		case tokenObjectValue:
0000000000000000000000000000000000000000;;			dec.tokenState = tokenObjectComma
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Delim is a JSON array or object delimiter, one of [ ] { or }.
0000000000000000000000000000000000000000;;	type Delim rune
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Delim) String() string {
0000000000000000000000000000000000000000;;		return string(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token returns the next JSON token in the input stream.
0000000000000000000000000000000000000000;;	// At the end of the input stream, Token returns nil, io.EOF.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Token guarantees that the delimiters [ ] { } it returns are
0000000000000000000000000000000000000000;;	// properly nested and matched: if Token encounters an unexpected
0000000000000000000000000000000000000000;;	// delimiter in the input, it will return an error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The input stream consists of basic JSON values—bool, string,
0000000000000000000000000000000000000000;;	// number, and null—along with delimiters [ ] { } of type Delim
0000000000000000000000000000000000000000;;	// to mark the start and end of arrays and objects.
0000000000000000000000000000000000000000;;	// Commas and colons are elided.
0000000000000000000000000000000000000000;;	func (dec *Decoder) Token() (Token, error) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			c, err := dec.peek()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				if !dec.tokenValueAllowed() {
0000000000000000000000000000000000000000;;					return dec.tokenError(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.scanp++
0000000000000000000000000000000000000000;;				dec.tokenStack = append(dec.tokenStack, dec.tokenState)
0000000000000000000000000000000000000000;;				dec.tokenState = tokenArrayStart
0000000000000000000000000000000000000000;;				return Delim('['), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				if dec.tokenState != tokenArrayStart && dec.tokenState != tokenArrayComma {
0000000000000000000000000000000000000000;;					return dec.tokenError(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.scanp++
0000000000000000000000000000000000000000;;				dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
0000000000000000000000000000000000000000;;				dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
0000000000000000000000000000000000000000;;				dec.tokenValueEnd()
0000000000000000000000000000000000000000;;				return Delim(']'), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '{':
0000000000000000000000000000000000000000;;				if !dec.tokenValueAllowed() {
0000000000000000000000000000000000000000;;					return dec.tokenError(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.scanp++
0000000000000000000000000000000000000000;;				dec.tokenStack = append(dec.tokenStack, dec.tokenState)
0000000000000000000000000000000000000000;;				dec.tokenState = tokenObjectStart
0000000000000000000000000000000000000000;;				return Delim('{'), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '}':
0000000000000000000000000000000000000000;;				if dec.tokenState != tokenObjectStart && dec.tokenState != tokenObjectComma {
0000000000000000000000000000000000000000;;					return dec.tokenError(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.scanp++
0000000000000000000000000000000000000000;;				dec.tokenState = dec.tokenStack[len(dec.tokenStack)-1]
0000000000000000000000000000000000000000;;				dec.tokenStack = dec.tokenStack[:len(dec.tokenStack)-1]
0000000000000000000000000000000000000000;;				dec.tokenValueEnd()
0000000000000000000000000000000000000000;;				return Delim('}'), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ':':
0000000000000000000000000000000000000000;;				if dec.tokenState != tokenObjectColon {
0000000000000000000000000000000000000000;;					return dec.tokenError(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.scanp++
0000000000000000000000000000000000000000;;				dec.tokenState = tokenObjectValue
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ',':
0000000000000000000000000000000000000000;;				if dec.tokenState == tokenArrayComma {
0000000000000000000000000000000000000000;;					dec.scanp++
0000000000000000000000000000000000000000;;					dec.tokenState = tokenArrayValue
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if dec.tokenState == tokenObjectComma {
0000000000000000000000000000000000000000;;					dec.scanp++
0000000000000000000000000000000000000000;;					dec.tokenState = tokenObjectKey
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return dec.tokenError(c)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				if dec.tokenState == tokenObjectStart || dec.tokenState == tokenObjectKey {
0000000000000000000000000000000000000000;;					var x string
0000000000000000000000000000000000000000;;					old := dec.tokenState
0000000000000000000000000000000000000000;;					dec.tokenState = tokenTopValue
0000000000000000000000000000000000000000;;					err := dec.Decode(&x)
0000000000000000000000000000000000000000;;					dec.tokenState = old
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						clearOffset(err)
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dec.tokenState = tokenObjectColon
0000000000000000000000000000000000000000;;					return x, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if !dec.tokenValueAllowed() {
0000000000000000000000000000000000000000;;					return dec.tokenError(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var x interface{}
0000000000000000000000000000000000000000;;				if err := dec.Decode(&x); err != nil {
0000000000000000000000000000000000000000;;					clearOffset(err)
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return x, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clearOffset(err error) {
0000000000000000000000000000000000000000;;		if s, ok := err.(*SyntaxError); ok {
0000000000000000000000000000000000000000;;			s.Offset = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *Decoder) tokenError(c byte) (Token, error) {
0000000000000000000000000000000000000000;;		var context string
0000000000000000000000000000000000000000;;		switch dec.tokenState {
0000000000000000000000000000000000000000;;		case tokenTopValue:
0000000000000000000000000000000000000000;;			context = " looking for beginning of value"
0000000000000000000000000000000000000000;;		case tokenArrayStart, tokenArrayValue, tokenObjectValue:
0000000000000000000000000000000000000000;;			context = " looking for beginning of value"
0000000000000000000000000000000000000000;;		case tokenArrayComma:
0000000000000000000000000000000000000000;;			context = " after array element"
0000000000000000000000000000000000000000;;		case tokenObjectKey:
0000000000000000000000000000000000000000;;			context = " looking for beginning of object key string"
0000000000000000000000000000000000000000;;		case tokenObjectColon:
0000000000000000000000000000000000000000;;			context = " after object key"
0000000000000000000000000000000000000000;;		case tokenObjectComma:
0000000000000000000000000000000000000000;;			context = " after object key:value pair"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, &SyntaxError{"invalid character " + quoteChar(c) + " " + context, 0}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// More reports whether there is another element in the
0000000000000000000000000000000000000000;;	// current array or object being parsed.
0000000000000000000000000000000000000000;;	func (dec *Decoder) More() bool {
0000000000000000000000000000000000000000;;		c, err := dec.peek()
0000000000000000000000000000000000000000;;		return err == nil && c != ']' && c != '}'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dec *Decoder) peek() (byte, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			for i := dec.scanp; i < len(dec.buf); i++ {
0000000000000000000000000000000000000000;;				c := dec.buf[i]
0000000000000000000000000000000000000000;;				if isSpace(c) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dec.scanp = i
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// buffer has been scanned, now report any error
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = dec.refill()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	TODO
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeToken writes the given JSON token to the stream.
0000000000000000000000000000000000000000;;	// It returns an error if the delimiters [ ] { } are not properly used.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// EncodeToken does not call Flush, because usually it is part of
0000000000000000000000000000000000000000;;	// a larger operation such as Encode, and those will call Flush when finished.
0000000000000000000000000000000000000000;;	// Callers that create an Encoder and then invoke EncodeToken directly,
0000000000000000000000000000000000000000;;	// without using Encode, need to call Flush when finished to ensure that
0000000000000000000000000000000000000000;;	// the JSON is written to the underlying writer.
0000000000000000000000000000000000000000;;	func (e *Encoder) EncodeToken(t Token) error  {
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
