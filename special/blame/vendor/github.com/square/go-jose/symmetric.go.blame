0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/hmac"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"crypto/sha512"
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/square/go-jose/cipher"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Random reader (stubbed out in tests)
0000000000000000000000000000000000000000;;	var randReader = rand.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dummy key cipher for shared symmetric key mode
0000000000000000000000000000000000000000;;	type symmetricKeyCipher struct {
0000000000000000000000000000000000000000;;		key []byte // Pre-shared content-encryption key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Signer/verifier for MAC modes
0000000000000000000000000000000000000000;;	type symmetricMac struct {
0000000000000000000000000000000000000000;;		key []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Input/output from an AEAD operation
0000000000000000000000000000000000000000;;	type aeadParts struct {
0000000000000000000000000000000000000000;;		iv, ciphertext, tag []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A content cipher based on an AEAD construction
0000000000000000000000000000000000000000;;	type aeadContentCipher struct {
0000000000000000000000000000000000000000;;		keyBytes     int
0000000000000000000000000000000000000000;;		authtagBytes int
0000000000000000000000000000000000000000;;		getAead      func(key []byte) (cipher.AEAD, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Random key generator
0000000000000000000000000000000000000000;;	type randomKeyGenerator struct {
0000000000000000000000000000000000000000;;		size int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Static key generator
0000000000000000000000000000000000000000;;	type staticKeyGenerator struct {
0000000000000000000000000000000000000000;;		key []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new content cipher based on AES-GCM
0000000000000000000000000000000000000000;;	func newAESGCM(keySize int) contentCipher {
0000000000000000000000000000000000000000;;		return &aeadContentCipher{
0000000000000000000000000000000000000000;;			keyBytes:     keySize,
0000000000000000000000000000000000000000;;			authtagBytes: 16,
0000000000000000000000000000000000000000;;			getAead: func(key []byte) (cipher.AEAD, error) {
0000000000000000000000000000000000000000;;				aes, err := aes.NewCipher(key)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return cipher.NewGCM(aes)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new content cipher based on AES-CBC+HMAC
0000000000000000000000000000000000000000;;	func newAESCBC(keySize int) contentCipher {
0000000000000000000000000000000000000000;;		return &aeadContentCipher{
0000000000000000000000000000000000000000;;			keyBytes:     keySize * 2,
0000000000000000000000000000000000000000;;			authtagBytes: 16,
0000000000000000000000000000000000000000;;			getAead: func(key []byte) (cipher.AEAD, error) {
0000000000000000000000000000000000000000;;				return josecipher.NewCBCHMAC(key, aes.NewCipher)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get an AEAD cipher object for the given content encryption algorithm
0000000000000000000000000000000000000000;;	func getContentCipher(alg ContentEncryption) contentCipher {
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case A128GCM:
0000000000000000000000000000000000000000;;			return newAESGCM(16)
0000000000000000000000000000000000000000;;		case A192GCM:
0000000000000000000000000000000000000000;;			return newAESGCM(24)
0000000000000000000000000000000000000000;;		case A256GCM:
0000000000000000000000000000000000000000;;			return newAESGCM(32)
0000000000000000000000000000000000000000;;		case A128CBC_HS256:
0000000000000000000000000000000000000000;;			return newAESCBC(16)
0000000000000000000000000000000000000000;;		case A192CBC_HS384:
0000000000000000000000000000000000000000;;			return newAESCBC(24)
0000000000000000000000000000000000000000;;		case A256CBC_HS512:
0000000000000000000000000000000000000000;;			return newAESCBC(32)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newSymmetricRecipient creates a JWE encrypter based on AES-GCM key wrap.
0000000000000000000000000000000000000000;;	func newSymmetricRecipient(keyAlg KeyAlgorithm, key []byte) (recipientKeyInfo, error) {
0000000000000000000000000000000000000000;;		switch keyAlg {
0000000000000000000000000000000000000000;;		case DIRECT, A128GCMKW, A192GCMKW, A256GCMKW, A128KW, A192KW, A256KW:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientKeyInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientKeyInfo{
0000000000000000000000000000000000000000;;			keyAlg: keyAlg,
0000000000000000000000000000000000000000;;			keyEncrypter: &symmetricKeyCipher{
0000000000000000000000000000000000000000;;				key: key,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newSymmetricSigner creates a recipientSigInfo based on the given key.
0000000000000000000000000000000000000000;;	func newSymmetricSigner(sigAlg SignatureAlgorithm, key []byte) (recipientSigInfo, error) {
0000000000000000000000000000000000000000;;		// Verify that key management algorithm is supported by this encrypter
0000000000000000000000000000000000000000;;		switch sigAlg {
0000000000000000000000000000000000000000;;		case HS256, HS384, HS512:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientSigInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientSigInfo{
0000000000000000000000000000000000000000;;			sigAlg: sigAlg,
0000000000000000000000000000000000000000;;			signer: &symmetricMac{
0000000000000000000000000000000000000000;;				key: key,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate a random key for the given content cipher
0000000000000000000000000000000000000000;;	func (ctx randomKeyGenerator) genKey() ([]byte, rawHeader, error) {
0000000000000000000000000000000000000000;;		key := make([]byte, ctx.size)
0000000000000000000000000000000000000000;;		_, err := io.ReadFull(randReader, key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, rawHeader{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return key, rawHeader{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key size for random generator
0000000000000000000000000000000000000000;;	func (ctx randomKeyGenerator) keySize() int {
0000000000000000000000000000000000000000;;		return ctx.size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate a static key (for direct mode)
0000000000000000000000000000000000000000;;	func (ctx staticKeyGenerator) genKey() ([]byte, rawHeader, error) {
0000000000000000000000000000000000000000;;		cek := make([]byte, len(ctx.key))
0000000000000000000000000000000000000000;;		copy(cek, ctx.key)
0000000000000000000000000000000000000000;;		return cek, rawHeader{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key size for static generator
0000000000000000000000000000000000000000;;	func (ctx staticKeyGenerator) keySize() int {
0000000000000000000000000000000000000000;;		return len(ctx.key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get key size for this cipher
0000000000000000000000000000000000000000;;	func (ctx aeadContentCipher) keySize() int {
0000000000000000000000000000000000000000;;		return ctx.keyBytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypt some data
0000000000000000000000000000000000000000;;	func (ctx aeadContentCipher) encrypt(key, aad, pt []byte) (*aeadParts, error) {
0000000000000000000000000000000000000000;;		// Get a new AEAD instance
0000000000000000000000000000000000000000;;		aead, err := ctx.getAead(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize a new nonce
0000000000000000000000000000000000000000;;		iv := make([]byte, aead.NonceSize())
0000000000000000000000000000000000000000;;		_, err = io.ReadFull(randReader, iv)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ciphertextAndTag := aead.Seal(nil, iv, pt, aad)
0000000000000000000000000000000000000000;;		offset := len(ciphertextAndTag) - ctx.authtagBytes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &aeadParts{
0000000000000000000000000000000000000000;;			iv:         iv,
0000000000000000000000000000000000000000;;			ciphertext: ciphertextAndTag[:offset],
0000000000000000000000000000000000000000;;			tag:        ciphertextAndTag[offset:],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrypt some data
0000000000000000000000000000000000000000;;	func (ctx aeadContentCipher) decrypt(key, aad []byte, parts *aeadParts) ([]byte, error) {
0000000000000000000000000000000000000000;;		aead, err := ctx.getAead(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return aead.Open(nil, parts.iv, append(parts.ciphertext, parts.tag...), aad)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypt the content encryption key.
0000000000000000000000000000000000000000;;	func (ctx *symmetricKeyCipher) encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) {
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case DIRECT:
0000000000000000000000000000000000000000;;			return recipientInfo{
0000000000000000000000000000000000000000;;				header: &rawHeader{},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case A128GCMKW, A192GCMKW, A256GCMKW:
0000000000000000000000000000000000000000;;			aead := newAESGCM(len(ctx.key))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			parts, err := aead.encrypt(ctx.key, []byte{}, cek)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return recipientInfo{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return recipientInfo{
0000000000000000000000000000000000000000;;				header: &rawHeader{
0000000000000000000000000000000000000000;;					Iv:  newBuffer(parts.iv),
0000000000000000000000000000000000000000;;					Tag: newBuffer(parts.tag),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				encryptedKey: parts.ciphertext,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case A128KW, A192KW, A256KW:
0000000000000000000000000000000000000000;;			block, err := aes.NewCipher(ctx.key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return recipientInfo{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			jek, err := josecipher.KeyWrap(block, cek)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return recipientInfo{}, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return recipientInfo{
0000000000000000000000000000000000000000;;				encryptedKey: jek,
0000000000000000000000000000000000000000;;				header:       &rawHeader{},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrypt the content encryption key.
0000000000000000000000000000000000000000;;	func (ctx *symmetricKeyCipher) decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch KeyAlgorithm(headers.Alg) {
0000000000000000000000000000000000000000;;		case DIRECT:
0000000000000000000000000000000000000000;;			cek := make([]byte, len(ctx.key))
0000000000000000000000000000000000000000;;			copy(cek, ctx.key)
0000000000000000000000000000000000000000;;			return cek, nil
0000000000000000000000000000000000000000;;		case A128GCMKW, A192GCMKW, A256GCMKW:
0000000000000000000000000000000000000000;;			aead := newAESGCM(len(ctx.key))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			parts := &aeadParts{
0000000000000000000000000000000000000000;;				iv:         headers.Iv.bytes(),
0000000000000000000000000000000000000000;;				ciphertext: recipient.encryptedKey,
0000000000000000000000000000000000000000;;				tag:        headers.Tag.bytes(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cek, err := aead.decrypt(ctx.key, []byte{}, parts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return cek, nil
0000000000000000000000000000000000000000;;		case A128KW, A192KW, A256KW:
0000000000000000000000000000000000000000;;			block, err := aes.NewCipher(ctx.key)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cek, err := josecipher.KeyUnwrap(block, recipient.encryptedKey)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return cek, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign the given payload
0000000000000000000000000000000000000000;;	func (ctx symmetricMac) signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error) {
0000000000000000000000000000000000000000;;		mac, err := ctx.hmac(payload, alg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Signature{}, errors.New("square/go-jose: failed to compute hmac")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Signature{
0000000000000000000000000000000000000000;;			Signature: mac,
0000000000000000000000000000000000000000;;			protected: &rawHeader{},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify the given payload
0000000000000000000000000000000000000000;;	func (ctx symmetricMac) verifyPayload(payload []byte, mac []byte, alg SignatureAlgorithm) error {
0000000000000000000000000000000000000000;;		expected, err := ctx.hmac(payload, alg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return errors.New("square/go-jose: failed to compute hmac")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(mac) != len(expected) {
0000000000000000000000000000000000000000;;			return errors.New("square/go-jose: invalid hmac")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match := subtle.ConstantTimeCompare(mac, expected)
0000000000000000000000000000000000000000;;		if match != 1 {
0000000000000000000000000000000000000000;;			return errors.New("square/go-jose: invalid hmac")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compute the HMAC based on the given alg value
0000000000000000000000000000000000000000;;	func (ctx symmetricMac) hmac(payload []byte, alg SignatureAlgorithm) ([]byte, error) {
0000000000000000000000000000000000000000;;		var hash func() hash.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case HS256:
0000000000000000000000000000000000000000;;			hash = sha256.New
0000000000000000000000000000000000000000;;		case HS384:
0000000000000000000000000000000000000000;;			hash = sha512.New384
0000000000000000000000000000000000000000;;		case HS512:
0000000000000000000000000000000000000000;;			hash = sha512.New
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hmac := hmac.New(hash, ctx.key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to documentation, Write() on hash never fails
0000000000000000000000000000000000000000;;		_, _ = hmac.Write(payload)
0000000000000000000000000000000000000000;;		return hmac.Sum(nil), nil
0000000000000000000000000000000000000000;;	}
