0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypter represents an encrypter which produces an encrypted JWE object.
0000000000000000000000000000000000000000;;	type Encrypter interface {
0000000000000000000000000000000000000000;;		Encrypt(plaintext []byte) (*JsonWebEncryption, error)
0000000000000000000000000000000000000000;;		EncryptWithAuthData(plaintext []byte, aad []byte) (*JsonWebEncryption, error)
0000000000000000000000000000000000000000;;		SetCompression(alg CompressionAlgorithm)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultiEncrypter represents an encrypter which supports multiple recipients.
0000000000000000000000000000000000000000;;	type MultiEncrypter interface {
0000000000000000000000000000000000000000;;		Encrypt(plaintext []byte) (*JsonWebEncryption, error)
0000000000000000000000000000000000000000;;		EncryptWithAuthData(plaintext []byte, aad []byte) (*JsonWebEncryption, error)
0000000000000000000000000000000000000000;;		SetCompression(alg CompressionAlgorithm)
0000000000000000000000000000000000000000;;		AddRecipient(alg KeyAlgorithm, encryptionKey interface{}) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic content cipher
0000000000000000000000000000000000000000;;	type contentCipher interface {
0000000000000000000000000000000000000000;;		keySize() int
0000000000000000000000000000000000000000;;		encrypt(cek []byte, aad, plaintext []byte) (*aeadParts, error)
0000000000000000000000000000000000000000;;		decrypt(cek []byte, aad []byte, parts *aeadParts) ([]byte, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A key generator (for generating/getting a CEK)
0000000000000000000000000000000000000000;;	type keyGenerator interface {
0000000000000000000000000000000000000000;;		keySize() int
0000000000000000000000000000000000000000;;		genKey() ([]byte, rawHeader, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic key encrypter
0000000000000000000000000000000000000000;;	type keyEncrypter interface {
0000000000000000000000000000000000000000;;		encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) // Encrypt a key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic key decrypter
0000000000000000000000000000000000000000;;	type keyDecrypter interface {
0000000000000000000000000000000000000000;;		decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) // Decrypt a key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic encrypter based on the given key encrypter and content cipher.
0000000000000000000000000000000000000000;;	type genericEncrypter struct {
0000000000000000000000000000000000000000;;		contentAlg     ContentEncryption
0000000000000000000000000000000000000000;;		compressionAlg CompressionAlgorithm
0000000000000000000000000000000000000000;;		cipher         contentCipher
0000000000000000000000000000000000000000;;		recipients     []recipientKeyInfo
0000000000000000000000000000000000000000;;		keyGenerator   keyGenerator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type recipientKeyInfo struct {
0000000000000000000000000000000000000000;;		keyID        string
0000000000000000000000000000000000000000;;		keyAlg       KeyAlgorithm
0000000000000000000000000000000000000000;;		keyEncrypter keyEncrypter
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetCompression sets a compression algorithm to be applied before encryption.
0000000000000000000000000000000000000000;;	func (ctx *genericEncrypter) SetCompression(compressionAlg CompressionAlgorithm) {
0000000000000000000000000000000000000000;;		ctx.compressionAlg = compressionAlg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewEncrypter creates an appropriate encrypter based on the key type
0000000000000000000000000000000000000000;;	func NewEncrypter(alg KeyAlgorithm, enc ContentEncryption, encryptionKey interface{}) (Encrypter, error) {
0000000000000000000000000000000000000000;;		encrypter := &genericEncrypter{
0000000000000000000000000000000000000000;;			contentAlg:     enc,
0000000000000000000000000000000000000000;;			compressionAlg: NONE,
0000000000000000000000000000000000000000;;			recipients:     []recipientKeyInfo{},
0000000000000000000000000000000000000000;;			cipher:         getContentCipher(enc),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if encrypter.cipher == nil {
0000000000000000000000000000000000000000;;			return nil, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var keyID string
0000000000000000000000000000000000000000;;		var rawKey interface{}
0000000000000000000000000000000000000000;;		switch encryptionKey := encryptionKey.(type) {
0000000000000000000000000000000000000000;;		case *JsonWebKey:
0000000000000000000000000000000000000000;;			keyID = encryptionKey.KeyID
0000000000000000000000000000000000000000;;			rawKey = encryptionKey.Key
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			rawKey = encryptionKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case DIRECT:
0000000000000000000000000000000000000000;;			// Direct encryption mode must be treated differently
0000000000000000000000000000000000000000;;			if reflect.TypeOf(rawKey) != reflect.TypeOf([]byte{}) {
0000000000000000000000000000000000000000;;				return nil, ErrUnsupportedKeyType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encrypter.keyGenerator = staticKeyGenerator{
0000000000000000000000000000000000000000;;				key: rawKey.([]byte),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			recipient, _ := newSymmetricRecipient(alg, rawKey.([]byte))
0000000000000000000000000000000000000000;;			if keyID != "" {
0000000000000000000000000000000000000000;;				recipient.keyID = keyID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encrypter.recipients = []recipientKeyInfo{recipient}
0000000000000000000000000000000000000000;;			return encrypter, nil
0000000000000000000000000000000000000000;;		case ECDH_ES:
0000000000000000000000000000000000000000;;			// ECDH-ES (w/o key wrapping) is similar to DIRECT mode
0000000000000000000000000000000000000000;;			typeOf := reflect.TypeOf(rawKey)
0000000000000000000000000000000000000000;;			if typeOf != reflect.TypeOf(&ecdsa.PublicKey{}) {
0000000000000000000000000000000000000000;;				return nil, ErrUnsupportedKeyType
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encrypter.keyGenerator = ecKeyGenerator{
0000000000000000000000000000000000000000;;				size:      encrypter.cipher.keySize(),
0000000000000000000000000000000000000000;;				algID:     string(enc),
0000000000000000000000000000000000000000;;				publicKey: rawKey.(*ecdsa.PublicKey),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			recipient, _ := newECDHRecipient(alg, rawKey.(*ecdsa.PublicKey))
0000000000000000000000000000000000000000;;			if keyID != "" {
0000000000000000000000000000000000000000;;				recipient.keyID = keyID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			encrypter.recipients = []recipientKeyInfo{recipient}
0000000000000000000000000000000000000000;;			return encrypter, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Can just add a standard recipient
0000000000000000000000000000000000000000;;			encrypter.keyGenerator = randomKeyGenerator{
0000000000000000000000000000000000000000;;				size: encrypter.cipher.keySize(),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := encrypter.AddRecipient(alg, encryptionKey)
0000000000000000000000000000000000000000;;			return encrypter, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMultiEncrypter creates a multi-encrypter based on the given parameters
0000000000000000000000000000000000000000;;	func NewMultiEncrypter(enc ContentEncryption) (MultiEncrypter, error) {
0000000000000000000000000000000000000000;;		cipher := getContentCipher(enc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if cipher == nil {
0000000000000000000000000000000000000000;;			return nil, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encrypter := &genericEncrypter{
0000000000000000000000000000000000000000;;			contentAlg:     enc,
0000000000000000000000000000000000000000;;			compressionAlg: NONE,
0000000000000000000000000000000000000000;;			recipients:     []recipientKeyInfo{},
0000000000000000000000000000000000000000;;			cipher:         cipher,
0000000000000000000000000000000000000000;;			keyGenerator: randomKeyGenerator{
0000000000000000000000000000000000000000;;				size: cipher.keySize(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return encrypter, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *genericEncrypter) AddRecipient(alg KeyAlgorithm, encryptionKey interface{}) (err error) {
0000000000000000000000000000000000000000;;		var recipient recipientKeyInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case DIRECT, ECDH_ES:
0000000000000000000000000000000000000000;;			return fmt.Errorf("square/go-jose: key algorithm '%s' not supported in multi-recipient mode", alg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recipient, err = makeJWERecipient(alg, encryptionKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			ctx.recipients = append(ctx.recipients, recipient)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeJWERecipient(alg KeyAlgorithm, encryptionKey interface{}) (recipientKeyInfo, error) {
0000000000000000000000000000000000000000;;		switch encryptionKey := encryptionKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			return newRSARecipient(alg, encryptionKey)
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			return newECDHRecipient(alg, encryptionKey)
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return newSymmetricRecipient(alg, encryptionKey)
0000000000000000000000000000000000000000;;		case *JsonWebKey:
0000000000000000000000000000000000000000;;			recipient, err := makeJWERecipient(alg, encryptionKey.Key)
0000000000000000000000000000000000000000;;			if err == nil && encryptionKey.KeyID != "" {
0000000000000000000000000000000000000000;;				recipient.keyID = encryptionKey.KeyID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return recipient, err
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientKeyInfo{}, ErrUnsupportedKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newDecrypter creates an appropriate decrypter based on the key type
0000000000000000000000000000000000000000;;	func newDecrypter(decryptionKey interface{}) (keyDecrypter, error) {
0000000000000000000000000000000000000000;;		switch decryptionKey := decryptionKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			return &rsaDecrypterSigner{
0000000000000000000000000000000000000000;;				privateKey: decryptionKey,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			return &ecDecrypterSigner{
0000000000000000000000000000000000000000;;				privateKey: decryptionKey,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return &symmetricKeyCipher{
0000000000000000000000000000000000000000;;				key: decryptionKey,
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case *JsonWebKey:
0000000000000000000000000000000000000000;;			return newDecrypter(decryptionKey.Key)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrUnsupportedKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of encrypt method producing a JWE object.
0000000000000000000000000000000000000000;;	func (ctx *genericEncrypter) Encrypt(plaintext []byte) (*JsonWebEncryption, error) {
0000000000000000000000000000000000000000;;		return ctx.EncryptWithAuthData(plaintext, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implementation of encrypt method producing a JWE object.
0000000000000000000000000000000000000000;;	func (ctx *genericEncrypter) EncryptWithAuthData(plaintext, aad []byte) (*JsonWebEncryption, error) {
0000000000000000000000000000000000000000;;		obj := &JsonWebEncryption{}
0000000000000000000000000000000000000000;;		obj.aad = aad
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj.protected = &rawHeader{
0000000000000000000000000000000000000000;;			Enc: ctx.contentAlg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		obj.recipients = make([]recipientInfo, len(ctx.recipients))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ctx.recipients) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: no recipients to encrypt to")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cek, headers, err := ctx.keyGenerator.genKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj.protected.merge(&headers)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, info := range ctx.recipients {
0000000000000000000000000000000000000000;;			recipient, err := info.keyEncrypter.encryptKey(cek, info.keyAlg)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			recipient.header.Alg = string(info.keyAlg)
0000000000000000000000000000000000000000;;			if info.keyID != "" {
0000000000000000000000000000000000000000;;				recipient.header.Kid = info.keyID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			obj.recipients[i] = recipient
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(ctx.recipients) == 1 {
0000000000000000000000000000000000000000;;			// Move per-recipient headers into main protected header if there's
0000000000000000000000000000000000000000;;			// only a single recipient.
0000000000000000000000000000000000000000;;			obj.protected.merge(obj.recipients[0].header)
0000000000000000000000000000000000000000;;			obj.recipients[0].header = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ctx.compressionAlg != NONE {
0000000000000000000000000000000000000000;;			plaintext, err = compress(ctx.compressionAlg, plaintext)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			obj.protected.Zip = ctx.compressionAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authData := obj.computeAuthData()
0000000000000000000000000000000000000000;;		parts, err := ctx.cipher.encrypt(cek, authData, plaintext)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj.iv = parts.iv
0000000000000000000000000000000000000000;;		obj.ciphertext = parts.ciphertext
0000000000000000000000000000000000000000;;		obj.tag = parts.tag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrypt and validate the object and return the plaintext.
0000000000000000000000000000000000000000;;	func (obj JsonWebEncryption) Decrypt(decryptionKey interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		headers := obj.mergedHeaders(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(headers.Crit) > 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: unsupported crit header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decrypter, err := newDecrypter(decryptionKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cipher := getContentCipher(headers.Enc)
0000000000000000000000000000000000000000;;		if cipher == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: unsupported enc value '%s'", string(headers.Enc))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generator := randomKeyGenerator{
0000000000000000000000000000000000000000;;			size: cipher.keySize(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := &aeadParts{
0000000000000000000000000000000000000000;;			iv:         obj.iv,
0000000000000000000000000000000000000000;;			ciphertext: obj.ciphertext,
0000000000000000000000000000000000000000;;			tag:        obj.tag,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		authData := obj.computeAuthData()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var plaintext []byte
0000000000000000000000000000000000000000;;		for _, recipient := range obj.recipients {
0000000000000000000000000000000000000000;;			recipientHeaders := obj.mergedHeaders(&recipient)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cek, err := decrypter.decryptKey(recipientHeaders, &recipient, generator)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				// Found a valid CEK -- let's try to decrypt.
0000000000000000000000000000000000000000;;				plaintext, err = cipher.decrypt(cek, authData, parts)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if plaintext == nil {
0000000000000000000000000000000000000000;;			return nil, ErrCryptoFailure
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The "zip" header parameter may only be present in the protected header.
0000000000000000000000000000000000000000;;		if obj.protected.Zip != "" {
0000000000000000000000000000000000000000;;			plaintext, err = decompress(obj.protected.Zip, plaintext)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return plaintext, err
0000000000000000000000000000000000000000;;	}
