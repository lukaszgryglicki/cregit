0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package josecipher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultIV = []byte{0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6, 0xA6}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyWrap implements NIST key wrapping; it wraps a content encryption key (cek) with the given block cipher.
0000000000000000000000000000000000000000;;	func KeyWrap(block cipher.Block, cek []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(cek)%8 != 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: key wrap input must be 8 byte blocks")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := len(cek) / 8
0000000000000000000000000000000000000000;;		r := make([][]byte, n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range r {
0000000000000000000000000000000000000000;;			r[i] = make([]byte, 8)
0000000000000000000000000000000000000000;;			copy(r[i], cek[i*8:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buffer := make([]byte, 16)
0000000000000000000000000000000000000000;;		tBytes := make([]byte, 8)
0000000000000000000000000000000000000000;;		copy(buffer, defaultIV)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for t := 0; t < 6*n; t++ {
0000000000000000000000000000000000000000;;			copy(buffer[8:], r[t%n])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			block.Encrypt(buffer, buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint64(tBytes, uint64(t+1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < 8; i++ {
0000000000000000000000000000000000000000;;				buffer[i] = buffer[i] ^ tBytes[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(r[t%n], buffer[8:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := make([]byte, (n+1)*8)
0000000000000000000000000000000000000000;;		copy(out, buffer[:8])
0000000000000000000000000000000000000000;;		for i := range r {
0000000000000000000000000000000000000000;;			copy(out[(i+1)*8:], r[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyUnwrap implements NIST key unwrapping; it unwraps a content encryption key (cek) with the given block cipher.
0000000000000000000000000000000000000000;;	func KeyUnwrap(block cipher.Block, ciphertext []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(ciphertext)%8 != 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: key wrap input must be 8 byte blocks")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := (len(ciphertext) / 8) - 1
0000000000000000000000000000000000000000;;		r := make([][]byte, n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range r {
0000000000000000000000000000000000000000;;			r[i] = make([]byte, 8)
0000000000000000000000000000000000000000;;			copy(r[i], ciphertext[(i+1)*8:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buffer := make([]byte, 16)
0000000000000000000000000000000000000000;;		tBytes := make([]byte, 8)
0000000000000000000000000000000000000000;;		copy(buffer[:8], ciphertext[:8])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for t := 6*n - 1; t >= 0; t-- {
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint64(tBytes, uint64(t+1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < 8; i++ {
0000000000000000000000000000000000000000;;				buffer[i] = buffer[i] ^ tBytes[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(buffer[8:], r[t%n])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			block.Decrypt(buffer, buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			copy(r[t%n], buffer[8:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if subtle.ConstantTimeCompare(buffer[:8], defaultIV) == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: failed to unwrap key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := make([]byte, n*8)
0000000000000000000000000000000000000000;;		for i := range r {
0000000000000000000000000000000000000000;;			copy(out[i*8:], r[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
