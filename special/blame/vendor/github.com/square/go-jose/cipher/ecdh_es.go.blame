0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package josecipher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeriveECDHES derives a shared encryption key using ECDH/ConcatKDF as described in JWE/JWA.
0000000000000000000000000000000000000000;;	// It is an error to call this function with a private/public key that are not on the same
0000000000000000000000000000000000000000;;	// curve. Callers must ensure that the keys are valid before calling this function. Output
0000000000000000000000000000000000000000;;	// size may be at most 1<<16 bytes (64 KiB).
0000000000000000000000000000000000000000;;	func DeriveECDHES(alg string, apuData, apvData []byte, priv *ecdsa.PrivateKey, pub *ecdsa.PublicKey, size int) []byte {
0000000000000000000000000000000000000000;;		if size > 1<<16 {
0000000000000000000000000000000000000000;;			panic("ECDH-ES output size too large, must be less than 1<<16")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// algId, partyUInfo, partyVInfo inputs must be prefixed with the length
0000000000000000000000000000000000000000;;		algID := lengthPrefixed([]byte(alg))
0000000000000000000000000000000000000000;;		ptyUInfo := lengthPrefixed(apuData)
0000000000000000000000000000000000000000;;		ptyVInfo := lengthPrefixed(apvData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// suppPubInfo is the encoded length of the output size in bits
0000000000000000000000000000000000000000;;		supPubInfo := make([]byte, 4)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(supPubInfo, uint32(size)*8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !priv.PublicKey.Curve.IsOnCurve(pub.X, pub.Y) {
0000000000000000000000000000000000000000;;			panic("public key not on same curve as private key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		z, _ := priv.PublicKey.Curve.ScalarMult(pub.X, pub.Y, priv.D.Bytes())
0000000000000000000000000000000000000000;;		reader := NewConcatKDF(crypto.SHA256, z.Bytes(), algID, ptyUInfo, ptyVInfo, supPubInfo, []byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := make([]byte, size)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read on the KDF will never fail
0000000000000000000000000000000000000000;;		_, _ = reader.Read(key)
0000000000000000000000000000000000000000;;		return key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lengthPrefixed(data []byte) []byte {
0000000000000000000000000000000000000000;;		out := make([]byte, len(data)+4)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(out, uint32(len(data)))
0000000000000000000000000000000000000000;;		copy(out[4:], data)
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
