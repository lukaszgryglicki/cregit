0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package josecipher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/hmac"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"crypto/sha512"
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		nonceBytes = 16
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCBCHMAC instantiates a new AEAD based on CBC+HMAC.
0000000000000000000000000000000000000000;;	func NewCBCHMAC(key []byte, newBlockCipher func([]byte) (cipher.Block, error)) (cipher.AEAD, error) {
0000000000000000000000000000000000000000;;		keySize := len(key) / 2
0000000000000000000000000000000000000000;;		integrityKey := key[:keySize]
0000000000000000000000000000000000000000;;		encryptionKey := key[keySize:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		blockCipher, err := newBlockCipher(encryptionKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hash func() hash.Hash
0000000000000000000000000000000000000000;;		switch keySize {
0000000000000000000000000000000000000000;;		case 16:
0000000000000000000000000000000000000000;;			hash = sha256.New
0000000000000000000000000000000000000000;;		case 24:
0000000000000000000000000000000000000000;;			hash = sha512.New384
0000000000000000000000000000000000000000;;		case 32:
0000000000000000000000000000000000000000;;			hash = sha512.New
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &cbcAEAD{
0000000000000000000000000000000000000000;;			hash:         hash,
0000000000000000000000000000000000000000;;			blockCipher:  blockCipher,
0000000000000000000000000000000000000000;;			authtagBytes: keySize,
0000000000000000000000000000000000000000;;			integrityKey: integrityKey,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An AEAD based on CBC+HMAC
0000000000000000000000000000000000000000;;	type cbcAEAD struct {
0000000000000000000000000000000000000000;;		hash         func() hash.Hash
0000000000000000000000000000000000000000;;		authtagBytes int
0000000000000000000000000000000000000000;;		integrityKey []byte
0000000000000000000000000000000000000000;;		blockCipher  cipher.Block
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *cbcAEAD) NonceSize() int {
0000000000000000000000000000000000000000;;		return nonceBytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *cbcAEAD) Overhead() int {
0000000000000000000000000000000000000000;;		// Maximum overhead is block size (for padding) plus auth tag length, where
0000000000000000000000000000000000000000;;		// the length of the auth tag is equivalent to the key size.
0000000000000000000000000000000000000000;;		return ctx.blockCipher.BlockSize() + ctx.authtagBytes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seal encrypts and authenticates the plaintext.
0000000000000000000000000000000000000000;;	func (ctx *cbcAEAD) Seal(dst, nonce, plaintext, data []byte) []byte {
0000000000000000000000000000000000000000;;		// Output buffer -- must take care not to mangle plaintext input.
0000000000000000000000000000000000000000;;		ciphertext := make([]byte, uint64(len(plaintext))+uint64(ctx.Overhead()))[:len(plaintext)]
0000000000000000000000000000000000000000;;		copy(ciphertext, plaintext)
0000000000000000000000000000000000000000;;		ciphertext = padBuffer(ciphertext, ctx.blockCipher.BlockSize())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cbc := cipher.NewCBCEncrypter(ctx.blockCipher, nonce)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cbc.CryptBlocks(ciphertext, ciphertext)
0000000000000000000000000000000000000000;;		authtag := ctx.computeAuthTag(data, nonce, ciphertext)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, out := resize(dst, uint64(len(dst))+uint64(len(ciphertext))+uint64(len(authtag)))
0000000000000000000000000000000000000000;;		copy(out, ciphertext)
0000000000000000000000000000000000000000;;		copy(out[len(ciphertext):], authtag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open decrypts and authenticates the ciphertext.
0000000000000000000000000000000000000000;;	func (ctx *cbcAEAD) Open(dst, nonce, ciphertext, data []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(ciphertext) < ctx.authtagBytes {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid ciphertext (too short)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		offset := len(ciphertext) - ctx.authtagBytes
0000000000000000000000000000000000000000;;		expectedTag := ctx.computeAuthTag(data, nonce, ciphertext[:offset])
0000000000000000000000000000000000000000;;		match := subtle.ConstantTimeCompare(expectedTag, ciphertext[offset:])
0000000000000000000000000000000000000000;;		if match != 1 {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid ciphertext (auth tag mismatch)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cbc := cipher.NewCBCDecrypter(ctx.blockCipher, nonce)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make copy of ciphertext buffer, don't want to modify in place
0000000000000000000000000000000000000000;;		buffer := append([]byte{}, []byte(ciphertext[:offset])...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(buffer)%ctx.blockCipher.BlockSize() > 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid ciphertext (invalid length)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cbc.CryptBlocks(buffer, buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove padding
0000000000000000000000000000000000000000;;		plaintext, err := unpadBuffer(buffer, ctx.blockCipher.BlockSize())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, out := resize(dst, uint64(len(dst))+uint64(len(plaintext)))
0000000000000000000000000000000000000000;;		copy(out, plaintext)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compute an authentication tag
0000000000000000000000000000000000000000;;	func (ctx *cbcAEAD) computeAuthTag(aad, nonce, ciphertext []byte) []byte {
0000000000000000000000000000000000000000;;		buffer := make([]byte, uint64(len(aad))+uint64(len(nonce))+uint64(len(ciphertext))+8)
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		n += copy(buffer, aad)
0000000000000000000000000000000000000000;;		n += copy(buffer[n:], nonce)
0000000000000000000000000000000000000000;;		n += copy(buffer[n:], ciphertext)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(buffer[n:], uint64(len(aad))*8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to documentation, Write() on hash.Hash never fails.
0000000000000000000000000000000000000000;;		hmac := hmac.New(ctx.hash, ctx.integrityKey)
0000000000000000000000000000000000000000;;		_, _ = hmac.Write(buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return hmac.Sum(nil)[:ctx.authtagBytes]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// resize ensures the the given slice has a capacity of at least n bytes.
0000000000000000000000000000000000000000;;	// If the capacity of the slice is less than n, a new slice is allocated
0000000000000000000000000000000000000000;;	// and the existing data will be copied.
0000000000000000000000000000000000000000;;	func resize(in []byte, n uint64) (head, tail []byte) {
0000000000000000000000000000000000000000;;		if uint64(cap(in)) >= n {
0000000000000000000000000000000000000000;;			head = in[:n]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			head = make([]byte, n)
0000000000000000000000000000000000000000;;			copy(head, in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tail = head[len(in):]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Apply padding
0000000000000000000000000000000000000000;;	func padBuffer(buffer []byte, blockSize int) []byte {
0000000000000000000000000000000000000000;;		missing := blockSize - (len(buffer) % blockSize)
0000000000000000000000000000000000000000;;		ret, out := resize(buffer, uint64(len(buffer))+uint64(missing))
0000000000000000000000000000000000000000;;		padding := bytes.Repeat([]byte{byte(missing)}, missing)
0000000000000000000000000000000000000000;;		copy(out, padding)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove padding
0000000000000000000000000000000000000000;;	func unpadBuffer(buffer []byte, blockSize int) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(buffer)%blockSize != 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid padding")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		last := buffer[len(buffer)-1]
0000000000000000000000000000000000000000;;		count := int(last)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if count == 0 || count > blockSize || count > len(buffer) {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid padding")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		padding := bytes.Repeat([]byte{last}, count)
0000000000000000000000000000000000000000;;		if !bytes.HasSuffix(buffer, padding) {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid padding")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buffer[:len(buffer)-count], nil
0000000000000000000000000000000000000000;;	}
