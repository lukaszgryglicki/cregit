0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/square/go-jose/json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rawJsonWebEncryption represents a raw JWE JSON object. Used for parsing/serializing.
0000000000000000000000000000000000000000;;	type rawJsonWebEncryption struct {
0000000000000000000000000000000000000000;;		Protected    *byteBuffer        `json:"protected,omitempty"`
0000000000000000000000000000000000000000;;		Unprotected  *rawHeader         `json:"unprotected,omitempty"`
0000000000000000000000000000000000000000;;		Header       *rawHeader         `json:"header,omitempty"`
0000000000000000000000000000000000000000;;		Recipients   []rawRecipientInfo `json:"recipients,omitempty"`
0000000000000000000000000000000000000000;;		Aad          *byteBuffer        `json:"aad,omitempty"`
0000000000000000000000000000000000000000;;		EncryptedKey *byteBuffer        `json:"encrypted_key,omitempty"`
0000000000000000000000000000000000000000;;		Iv           *byteBuffer        `json:"iv,omitempty"`
0000000000000000000000000000000000000000;;		Ciphertext   *byteBuffer        `json:"ciphertext,omitempty"`
0000000000000000000000000000000000000000;;		Tag          *byteBuffer        `json:"tag,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rawRecipientInfo represents a raw JWE Per-Recipient header JSON object. Used for parsing/serializing.
0000000000000000000000000000000000000000;;	type rawRecipientInfo struct {
0000000000000000000000000000000000000000;;		Header       *rawHeader `json:"header,omitempty"`
0000000000000000000000000000000000000000;;		EncryptedKey string     `json:"encrypted_key,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JsonWebEncryption represents an encrypted JWE object after parsing.
0000000000000000000000000000000000000000;;	type JsonWebEncryption struct {
0000000000000000000000000000000000000000;;		Header                   JoseHeader
0000000000000000000000000000000000000000;;		protected, unprotected   *rawHeader
0000000000000000000000000000000000000000;;		recipients               []recipientInfo
0000000000000000000000000000000000000000;;		aad, iv, ciphertext, tag []byte
0000000000000000000000000000000000000000;;		original                 *rawJsonWebEncryption
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recipientInfo represents a raw JWE Per-Recipient header JSON object after parsing.
0000000000000000000000000000000000000000;;	type recipientInfo struct {
0000000000000000000000000000000000000000;;		header       *rawHeader
0000000000000000000000000000000000000000;;		encryptedKey []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetAuthData retrieves the (optional) authenticated data attached to the object.
0000000000000000000000000000000000000000;;	func (obj JsonWebEncryption) GetAuthData() []byte {
0000000000000000000000000000000000000000;;		if obj.aad != nil {
0000000000000000000000000000000000000000;;			out := make([]byte, len(obj.aad))
0000000000000000000000000000000000000000;;			copy(out, obj.aad)
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the merged header values
0000000000000000000000000000000000000000;;	func (obj JsonWebEncryption) mergedHeaders(recipient *recipientInfo) rawHeader {
0000000000000000000000000000000000000000;;		out := rawHeader{}
0000000000000000000000000000000000000000;;		out.merge(obj.protected)
0000000000000000000000000000000000000000;;		out.merge(obj.unprotected)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if recipient != nil {
0000000000000000000000000000000000000000;;			out.merge(recipient.header)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the additional authenticated data from a JWE object.
0000000000000000000000000000000000000000;;	func (obj JsonWebEncryption) computeAuthData() []byte {
0000000000000000000000000000000000000000;;		var protected string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if obj.original != nil {
0000000000000000000000000000000000000000;;			protected = obj.original.Protected.base64()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			protected = base64URLEncode(mustSerializeJSON((obj.protected)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := []byte(protected)
0000000000000000000000000000000000000000;;		if obj.aad != nil {
0000000000000000000000000000000000000000;;			output = append(output, '.')
0000000000000000000000000000000000000000;;			output = append(output, []byte(base64URLEncode(obj.aad))...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseEncrypted parses an encrypted message in compact or full serialization format.
0000000000000000000000000000000000000000;;	func ParseEncrypted(input string) (*JsonWebEncryption, error) {
0000000000000000000000000000000000000000;;		input = stripWhitespace(input)
0000000000000000000000000000000000000000;;		if strings.HasPrefix(input, "{") {
0000000000000000000000000000000000000000;;			return parseEncryptedFull(input)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseEncryptedCompact(input)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseEncryptedFull parses a message in compact format.
0000000000000000000000000000000000000000;;	func parseEncryptedFull(input string) (*JsonWebEncryption, error) {
0000000000000000000000000000000000000000;;		var parsed rawJsonWebEncryption
0000000000000000000000000000000000000000;;		err := json.Unmarshal([]byte(input), &parsed)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parsed.sanitized()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sanitized produces a cleaned-up JWE object from the raw JSON.
0000000000000000000000000000000000000000;;	func (parsed *rawJsonWebEncryption) sanitized() (*JsonWebEncryption, error) {
0000000000000000000000000000000000000000;;		obj := &JsonWebEncryption{
0000000000000000000000000000000000000000;;			original:    parsed,
0000000000000000000000000000000000000000;;			unprotected: parsed.Unprotected,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that there is not a nonce in the unprotected headers
0000000000000000000000000000000000000000;;		if (parsed.Unprotected != nil && parsed.Unprotected.Nonce != "") ||
0000000000000000000000000000000000000000;;			(parsed.Header != nil && parsed.Header.Nonce != "") {
0000000000000000000000000000000000000000;;			return nil, ErrUnprotectedNonce
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parsed.Protected != nil && len(parsed.Protected.bytes()) > 0 {
0000000000000000000000000000000000000000;;			err := json.Unmarshal(parsed.Protected.bytes(), &obj.protected)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("square/go-jose: invalid protected header: %s, %s", err, parsed.Protected.base64())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Note: this must be called _after_ we parse the protected header,
0000000000000000000000000000000000000000;;		// otherwise fields from the protected header will not get picked up.
0000000000000000000000000000000000000000;;		obj.Header = obj.mergedHeaders(nil).sanitized()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parsed.Recipients) == 0 {
0000000000000000000000000000000000000000;;			obj.recipients = []recipientInfo{
0000000000000000000000000000000000000000;;				recipientInfo{
0000000000000000000000000000000000000000;;					header:       parsed.Header,
0000000000000000000000000000000000000000;;					encryptedKey: parsed.EncryptedKey.bytes(),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			obj.recipients = make([]recipientInfo, len(parsed.Recipients))
0000000000000000000000000000000000000000;;			for r := range parsed.Recipients {
0000000000000000000000000000000000000000;;				encryptedKey, err := base64URLDecode(parsed.Recipients[r].EncryptedKey)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check that there is not a nonce in the unprotected header
0000000000000000000000000000000000000000;;				if parsed.Recipients[r].Header != nil && parsed.Recipients[r].Header.Nonce != "" {
0000000000000000000000000000000000000000;;					return nil, ErrUnprotectedNonce
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				obj.recipients[r].header = parsed.Recipients[r].Header
0000000000000000000000000000000000000000;;				obj.recipients[r].encryptedKey = encryptedKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, recipient := range obj.recipients {
0000000000000000000000000000000000000000;;			headers := obj.mergedHeaders(&recipient)
0000000000000000000000000000000000000000;;			if headers.Alg == "" || headers.Enc == "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("square/go-jose: message is missing alg/enc headers")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		obj.iv = parsed.Iv.bytes()
0000000000000000000000000000000000000000;;		obj.ciphertext = parsed.Ciphertext.bytes()
0000000000000000000000000000000000000000;;		obj.tag = parsed.Tag.bytes()
0000000000000000000000000000000000000000;;		obj.aad = parsed.Aad.bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseEncryptedCompact parses a message in compact format.
0000000000000000000000000000000000000000;;	func parseEncryptedCompact(input string) (*JsonWebEncryption, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(input, ".")
0000000000000000000000000000000000000000;;		if len(parts) != 5 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: compact JWE format must have five parts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawProtected, err := base64URLDecode(parts[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encryptedKey, err := base64URLDecode(parts[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		iv, err := base64URLDecode(parts[2])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ciphertext, err := base64URLDecode(parts[3])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tag, err := base64URLDecode(parts[4])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw := &rawJsonWebEncryption{
0000000000000000000000000000000000000000;;			Protected:    newBuffer(rawProtected),
0000000000000000000000000000000000000000;;			EncryptedKey: newBuffer(encryptedKey),
0000000000000000000000000000000000000000;;			Iv:           newBuffer(iv),
0000000000000000000000000000000000000000;;			Ciphertext:   newBuffer(ciphertext),
0000000000000000000000000000000000000000;;			Tag:          newBuffer(tag),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return raw.sanitized()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompactSerialize serializes an object using the compact serialization format.
0000000000000000000000000000000000000000;;	func (obj JsonWebEncryption) CompactSerialize() (string, error) {
0000000000000000000000000000000000000000;;		if len(obj.recipients) != 1 || obj.unprotected != nil ||
0000000000000000000000000000000000000000;;			obj.protected == nil || obj.recipients[0].header != nil {
0000000000000000000000000000000000000000;;			return "", ErrNotSupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		serializedProtected := mustSerializeJSON(obj.protected)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%s.%s.%s.%s.%s",
0000000000000000000000000000000000000000;;			base64URLEncode(serializedProtected),
0000000000000000000000000000000000000000;;			base64URLEncode(obj.recipients[0].encryptedKey),
0000000000000000000000000000000000000000;;			base64URLEncode(obj.iv),
0000000000000000000000000000000000000000;;			base64URLEncode(obj.ciphertext),
0000000000000000000000000000000000000000;;			base64URLEncode(obj.tag)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FullSerialize serializes an object using the full JSON serialization format.
0000000000000000000000000000000000000000;;	func (obj JsonWebEncryption) FullSerialize() string {
0000000000000000000000000000000000000000;;		raw := rawJsonWebEncryption{
0000000000000000000000000000000000000000;;			Unprotected:  obj.unprotected,
0000000000000000000000000000000000000000;;			Iv:           newBuffer(obj.iv),
0000000000000000000000000000000000000000;;			Ciphertext:   newBuffer(obj.ciphertext),
0000000000000000000000000000000000000000;;			EncryptedKey: newBuffer(obj.recipients[0].encryptedKey),
0000000000000000000000000000000000000000;;			Tag:          newBuffer(obj.tag),
0000000000000000000000000000000000000000;;			Aad:          newBuffer(obj.aad),
0000000000000000000000000000000000000000;;			Recipients:   []rawRecipientInfo{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(obj.recipients) > 1 {
0000000000000000000000000000000000000000;;			for _, recipient := range obj.recipients {
0000000000000000000000000000000000000000;;				info := rawRecipientInfo{
0000000000000000000000000000000000000000;;					Header:       recipient.header,
0000000000000000000000000000000000000000;;					EncryptedKey: base64URLEncode(recipient.encryptedKey),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				raw.Recipients = append(raw.Recipients, info)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Use flattened serialization
0000000000000000000000000000000000000000;;			raw.Header = obj.recipients[0].header
0000000000000000000000000000000000000000;;			raw.EncryptedKey = newBuffer(obj.recipients[0].encryptedKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if obj.protected != nil {
0000000000000000000000000000000000000000;;			raw.Protected = newBuffer(mustSerializeJSON(obj.protected))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(mustSerializeJSON(raw))
0000000000000000000000000000000000000000;;	}
