0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/square/go-jose/cipher"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic RSA-based encrypter/verifier
0000000000000000000000000000000000000000;;	type rsaEncrypterVerifier struct {
0000000000000000000000000000000000000000;;		publicKey *rsa.PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic RSA-based decrypter/signer
0000000000000000000000000000000000000000;;	type rsaDecrypterSigner struct {
0000000000000000000000000000000000000000;;		privateKey *rsa.PrivateKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic EC-based encrypter/verifier
0000000000000000000000000000000000000000;;	type ecEncrypterVerifier struct {
0000000000000000000000000000000000000000;;		publicKey *ecdsa.PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A key generator for ECDH-ES
0000000000000000000000000000000000000000;;	type ecKeyGenerator struct {
0000000000000000000000000000000000000000;;		size      int
0000000000000000000000000000000000000000;;		algID     string
0000000000000000000000000000000000000000;;		publicKey *ecdsa.PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A generic EC-based decrypter/signer
0000000000000000000000000000000000000000;;	type ecDecrypterSigner struct {
0000000000000000000000000000000000000000;;		privateKey *ecdsa.PrivateKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRSARecipient creates recipientKeyInfo based on the given key.
0000000000000000000000000000000000000000;;	func newRSARecipient(keyAlg KeyAlgorithm, publicKey *rsa.PublicKey) (recipientKeyInfo, error) {
0000000000000000000000000000000000000000;;		// Verify that key management algorithm is supported by this encrypter
0000000000000000000000000000000000000000;;		switch keyAlg {
0000000000000000000000000000000000000000;;		case RSA1_5, RSA_OAEP, RSA_OAEP_256:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientKeyInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if publicKey == nil {
0000000000000000000000000000000000000000;;			return recipientKeyInfo{}, errors.New("invalid public key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientKeyInfo{
0000000000000000000000000000000000000000;;			keyAlg: keyAlg,
0000000000000000000000000000000000000000;;			keyEncrypter: &rsaEncrypterVerifier{
0000000000000000000000000000000000000000;;				publicKey: publicKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRSASigner creates a recipientSigInfo based on the given key.
0000000000000000000000000000000000000000;;	func newRSASigner(sigAlg SignatureAlgorithm, privateKey *rsa.PrivateKey) (recipientSigInfo, error) {
0000000000000000000000000000000000000000;;		// Verify that key management algorithm is supported by this encrypter
0000000000000000000000000000000000000000;;		switch sigAlg {
0000000000000000000000000000000000000000;;		case RS256, RS384, RS512, PS256, PS384, PS512:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientSigInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if privateKey == nil {
0000000000000000000000000000000000000000;;			return recipientSigInfo{}, errors.New("invalid private key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientSigInfo{
0000000000000000000000000000000000000000;;			sigAlg: sigAlg,
0000000000000000000000000000000000000000;;			publicKey: &JsonWebKey{
0000000000000000000000000000000000000000;;				Key: &privateKey.PublicKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			signer: &rsaDecrypterSigner{
0000000000000000000000000000000000000000;;				privateKey: privateKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newECDHRecipient creates recipientKeyInfo based on the given key.
0000000000000000000000000000000000000000;;	func newECDHRecipient(keyAlg KeyAlgorithm, publicKey *ecdsa.PublicKey) (recipientKeyInfo, error) {
0000000000000000000000000000000000000000;;		// Verify that key management algorithm is supported by this encrypter
0000000000000000000000000000000000000000;;		switch keyAlg {
0000000000000000000000000000000000000000;;		case ECDH_ES, ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientKeyInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if publicKey == nil || !publicKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) {
0000000000000000000000000000000000000000;;			return recipientKeyInfo{}, errors.New("invalid public key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientKeyInfo{
0000000000000000000000000000000000000000;;			keyAlg: keyAlg,
0000000000000000000000000000000000000000;;			keyEncrypter: &ecEncrypterVerifier{
0000000000000000000000000000000000000000;;				publicKey: publicKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newECDSASigner creates a recipientSigInfo based on the given key.
0000000000000000000000000000000000000000;;	func newECDSASigner(sigAlg SignatureAlgorithm, privateKey *ecdsa.PrivateKey) (recipientSigInfo, error) {
0000000000000000000000000000000000000000;;		// Verify that key management algorithm is supported by this encrypter
0000000000000000000000000000000000000000;;		switch sigAlg {
0000000000000000000000000000000000000000;;		case ES256, ES384, ES512:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientSigInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if privateKey == nil {
0000000000000000000000000000000000000000;;			return recipientSigInfo{}, errors.New("invalid private key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientSigInfo{
0000000000000000000000000000000000000000;;			sigAlg: sigAlg,
0000000000000000000000000000000000000000;;			publicKey: &JsonWebKey{
0000000000000000000000000000000000000000;;				Key: &privateKey.PublicKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			signer: &ecDecrypterSigner{
0000000000000000000000000000000000000000;;				privateKey: privateKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypt the given payload and update the object.
0000000000000000000000000000000000000000;;	func (ctx rsaEncrypterVerifier) encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) {
0000000000000000000000000000000000000000;;		encryptedKey, err := ctx.encrypt(cek, alg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return recipientInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientInfo{
0000000000000000000000000000000000000000;;			encryptedKey: encryptedKey,
0000000000000000000000000000000000000000;;			header:       &rawHeader{},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypt the given payload. Based on the key encryption algorithm,
0000000000000000000000000000000000000000;;	// this will either use RSA-PKCS1v1.5 or RSA-OAEP (with SHA-1 or SHA-256).
0000000000000000000000000000000000000000;;	func (ctx rsaEncrypterVerifier) encrypt(cek []byte, alg KeyAlgorithm) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case RSA1_5:
0000000000000000000000000000000000000000;;			return rsa.EncryptPKCS1v15(randReader, ctx.publicKey, cek)
0000000000000000000000000000000000000000;;		case RSA_OAEP:
0000000000000000000000000000000000000000;;			return rsa.EncryptOAEP(sha1.New(), randReader, ctx.publicKey, cek, []byte{})
0000000000000000000000000000000000000000;;		case RSA_OAEP_256:
0000000000000000000000000000000000000000;;			return rsa.EncryptOAEP(sha256.New(), randReader, ctx.publicKey, cek, []byte{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrypt the given payload and return the content encryption key.
0000000000000000000000000000000000000000;;	func (ctx rsaDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) {
0000000000000000000000000000000000000000;;		return ctx.decrypt(recipient.encryptedKey, KeyAlgorithm(headers.Alg), generator)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrypt the given payload. Based on the key encryption algorithm,
0000000000000000000000000000000000000000;;	// this will either use RSA-PKCS1v1.5 or RSA-OAEP (with SHA-1 or SHA-256).
0000000000000000000000000000000000000000;;	func (ctx rsaDecrypterSigner) decrypt(jek []byte, alg KeyAlgorithm, generator keyGenerator) ([]byte, error) {
0000000000000000000000000000000000000000;;		// Note: The random reader on decrypt operations is only used for blinding,
0000000000000000000000000000000000000000;;		// so stubbing is meanlingless (hence the direct use of rand.Reader).
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case RSA1_5:
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				// DecryptPKCS1v15SessionKey sometimes panics on an invalid payload
0000000000000000000000000000000000000000;;				// because of an index out of bounds error, which we want to ignore.
0000000000000000000000000000000000000000;;				// This has been fixed in Go 1.3.1 (released 2014/08/13), the recover()
0000000000000000000000000000000000000000;;				// only exists for preventing crashes with unpatched versions.
0000000000000000000000000000000000000000;;				// See: https://groups.google.com/forum/#!topic/golang-dev/7ihX6Y6kx9k
0000000000000000000000000000000000000000;;				// See: https://code.google.com/p/go/source/detail?r=58ee390ff31602edb66af41ed10901ec95904d33
0000000000000000000000000000000000000000;;				_ = recover()
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Perform some input validation.
0000000000000000000000000000000000000000;;			keyBytes := ctx.privateKey.PublicKey.N.BitLen() / 8
0000000000000000000000000000000000000000;;			if keyBytes != len(jek) {
0000000000000000000000000000000000000000;;				// Input size is incorrect, the encrypted payload should always match
0000000000000000000000000000000000000000;;				// the size of the public modulus (e.g. using a 2048 bit key will
0000000000000000000000000000000000000000;;				// produce 256 bytes of output). Reject this since it's invalid input.
0000000000000000000000000000000000000000;;				return nil, ErrCryptoFailure
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cek, _, err := generator.genKey()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, ErrCryptoFailure
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// When decrypting an RSA-PKCS1v1.5 payload, we must take precautions to
0000000000000000000000000000000000000000;;			// prevent chosen-ciphertext attacks as described in RFC 3218, "Preventing
0000000000000000000000000000000000000000;;			// the Million Message Attack on Cryptographic Message Syntax". We are
0000000000000000000000000000000000000000;;			// therefore deliberately ignoring errors here.
0000000000000000000000000000000000000000;;			_ = rsa.DecryptPKCS1v15SessionKey(rand.Reader, ctx.privateKey, jek, cek)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return cek, nil
0000000000000000000000000000000000000000;;		case RSA_OAEP:
0000000000000000000000000000000000000000;;			// Use rand.Reader for RSA blinding
0000000000000000000000000000000000000000;;			return rsa.DecryptOAEP(sha1.New(), rand.Reader, ctx.privateKey, jek, []byte{})
0000000000000000000000000000000000000000;;		case RSA_OAEP_256:
0000000000000000000000000000000000000000;;			// Use rand.Reader for RSA blinding
0000000000000000000000000000000000000000;;			return rsa.DecryptOAEP(sha256.New(), rand.Reader, ctx.privateKey, jek, []byte{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign the given payload
0000000000000000000000000000000000000000;;	func (ctx rsaDecrypterSigner) signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error) {
0000000000000000000000000000000000000000;;		var hash crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case RS256, PS256:
0000000000000000000000000000000000000000;;			hash = crypto.SHA256
0000000000000000000000000000000000000000;;		case RS384, PS384:
0000000000000000000000000000000000000000;;			hash = crypto.SHA384
0000000000000000000000000000000000000000;;		case RS512, PS512:
0000000000000000000000000000000000000000;;			hash = crypto.SHA512
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return Signature{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasher := hash.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to documentation, Write() on hash never fails
0000000000000000000000000000000000000000;;		_, _ = hasher.Write(payload)
0000000000000000000000000000000000000000;;		hashed := hasher.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var out []byte
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case RS256, RS384, RS512:
0000000000000000000000000000000000000000;;			out, err = rsa.SignPKCS1v15(randReader, ctx.privateKey, hash, hashed)
0000000000000000000000000000000000000000;;		case PS256, PS384, PS512:
0000000000000000000000000000000000000000;;			out, err = rsa.SignPSS(randReader, ctx.privateKey, hash, hashed, &rsa.PSSOptions{
0000000000000000000000000000000000000000;;				SaltLength: rsa.PSSSaltLengthAuto,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Signature{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Signature{
0000000000000000000000000000000000000000;;			Signature: out,
0000000000000000000000000000000000000000;;			protected: &rawHeader{},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify the given payload
0000000000000000000000000000000000000000;;	func (ctx rsaEncrypterVerifier) verifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error {
0000000000000000000000000000000000000000;;		var hash crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case RS256, PS256:
0000000000000000000000000000000000000000;;			hash = crypto.SHA256
0000000000000000000000000000000000000000;;		case RS384, PS384:
0000000000000000000000000000000000000000;;			hash = crypto.SHA384
0000000000000000000000000000000000000000;;		case RS512, PS512:
0000000000000000000000000000000000000000;;			hash = crypto.SHA512
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasher := hash.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to documentation, Write() on hash never fails
0000000000000000000000000000000000000000;;		_, _ = hasher.Write(payload)
0000000000000000000000000000000000000000;;		hashed := hasher.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case RS256, RS384, RS512:
0000000000000000000000000000000000000000;;			return rsa.VerifyPKCS1v15(ctx.publicKey, hash, hashed, signature)
0000000000000000000000000000000000000000;;		case PS256, PS384, PS512:
0000000000000000000000000000000000000000;;			return rsa.VerifyPSS(ctx.publicKey, hash, hashed, signature, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encrypt the given payload and update the object.
0000000000000000000000000000000000000000;;	func (ctx ecEncrypterVerifier) encryptKey(cek []byte, alg KeyAlgorithm) (recipientInfo, error) {
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case ECDH_ES:
0000000000000000000000000000000000000000;;			// ECDH-ES mode doesn't wrap a key, the shared secret is used directly as the key.
0000000000000000000000000000000000000000;;			return recipientInfo{
0000000000000000000000000000000000000000;;				header: &rawHeader{},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		case ECDH_ES_A128KW, ECDH_ES_A192KW, ECDH_ES_A256KW:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return recipientInfo{}, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		generator := ecKeyGenerator{
0000000000000000000000000000000000000000;;			algID:     string(alg),
0000000000000000000000000000000000000000;;			publicKey: ctx.publicKey,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case ECDH_ES_A128KW:
0000000000000000000000000000000000000000;;			generator.size = 16
0000000000000000000000000000000000000000;;		case ECDH_ES_A192KW:
0000000000000000000000000000000000000000;;			generator.size = 24
0000000000000000000000000000000000000000;;		case ECDH_ES_A256KW:
0000000000000000000000000000000000000000;;			generator.size = 32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kek, header, err := generator.genKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return recipientInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		block, err := aes.NewCipher(kek)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return recipientInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jek, err := josecipher.KeyWrap(block, cek)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return recipientInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return recipientInfo{
0000000000000000000000000000000000000000;;			encryptedKey: jek,
0000000000000000000000000000000000000000;;			header:       &header,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get key size for EC key generator
0000000000000000000000000000000000000000;;	func (ctx ecKeyGenerator) keySize() int {
0000000000000000000000000000000000000000;;		return ctx.size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get a content encryption key for ECDH-ES
0000000000000000000000000000000000000000;;	func (ctx ecKeyGenerator) genKey() ([]byte, rawHeader, error) {
0000000000000000000000000000000000000000;;		priv, err := ecdsa.GenerateKey(ctx.publicKey.Curve, randReader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, rawHeader{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := josecipher.DeriveECDHES(ctx.algID, []byte{}, []byte{}, priv, ctx.publicKey, ctx.size)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		headers := rawHeader{
0000000000000000000000000000000000000000;;			Epk: &JsonWebKey{
0000000000000000000000000000000000000000;;				Key: &priv.PublicKey,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out, headers, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decrypt the given payload and return the content encryption key.
0000000000000000000000000000000000000000;;	func (ctx ecDecrypterSigner) decryptKey(headers rawHeader, recipient *recipientInfo, generator keyGenerator) ([]byte, error) {
0000000000000000000000000000000000000000;;		if headers.Epk == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: missing epk header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		publicKey, ok := headers.Epk.Key.(*ecdsa.PublicKey)
0000000000000000000000000000000000000000;;		if publicKey == nil || !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid epk header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ctx.privateKey.Curve.IsOnCurve(publicKey.X, publicKey.Y) {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid public key in epk header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apuData := headers.Apu.bytes()
0000000000000000000000000000000000000000;;		apvData := headers.Apv.bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deriveKey := func(algID string, size int) []byte {
0000000000000000000000000000000000000000;;			return josecipher.DeriveECDHES(algID, apuData, apvData, ctx.privateKey, publicKey, size)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var keySize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch KeyAlgorithm(headers.Alg) {
0000000000000000000000000000000000000000;;		case ECDH_ES:
0000000000000000000000000000000000000000;;			// ECDH-ES uses direct key agreement, no key unwrapping necessary.
0000000000000000000000000000000000000000;;			return deriveKey(string(headers.Enc), generator.keySize()), nil
0000000000000000000000000000000000000000;;		case ECDH_ES_A128KW:
0000000000000000000000000000000000000000;;			keySize = 16
0000000000000000000000000000000000000000;;		case ECDH_ES_A192KW:
0000000000000000000000000000000000000000;;			keySize = 24
0000000000000000000000000000000000000000;;		case ECDH_ES_A256KW:
0000000000000000000000000000000000000000;;			keySize = 32
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := deriveKey(headers.Alg, keySize)
0000000000000000000000000000000000000000;;		block, err := aes.NewCipher(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return josecipher.KeyUnwrap(block, recipient.encryptedKey)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign the given payload
0000000000000000000000000000000000000000;;	func (ctx ecDecrypterSigner) signPayload(payload []byte, alg SignatureAlgorithm) (Signature, error) {
0000000000000000000000000000000000000000;;		var expectedBitSize int
0000000000000000000000000000000000000000;;		var hash crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case ES256:
0000000000000000000000000000000000000000;;			expectedBitSize = 256
0000000000000000000000000000000000000000;;			hash = crypto.SHA256
0000000000000000000000000000000000000000;;		case ES384:
0000000000000000000000000000000000000000;;			expectedBitSize = 384
0000000000000000000000000000000000000000;;			hash = crypto.SHA384
0000000000000000000000000000000000000000;;		case ES512:
0000000000000000000000000000000000000000;;			expectedBitSize = 521
0000000000000000000000000000000000000000;;			hash = crypto.SHA512
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		curveBits := ctx.privateKey.Curve.Params().BitSize
0000000000000000000000000000000000000000;;		if expectedBitSize != curveBits {
0000000000000000000000000000000000000000;;			return Signature{}, fmt.Errorf("square/go-jose: expected %d bit key, got %d bits instead", expectedBitSize, curveBits)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasher := hash.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to documentation, Write() on hash never fails
0000000000000000000000000000000000000000;;		_, _ = hasher.Write(payload)
0000000000000000000000000000000000000000;;		hashed := hasher.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, s, err := ecdsa.Sign(randReader, ctx.privateKey, hashed)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Signature{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyBytes := curveBits / 8
0000000000000000000000000000000000000000;;		if curveBits%8 > 0 {
0000000000000000000000000000000000000000;;			keyBytes += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We serialize the outpus (r and s) into big-endian byte arrays and pad
0000000000000000000000000000000000000000;;		// them with zeros on the left to make sure the sizes work out. Both arrays
0000000000000000000000000000000000000000;;		// must be keyBytes long, and the output must be 2*keyBytes long.
0000000000000000000000000000000000000000;;		rBytes := r.Bytes()
0000000000000000000000000000000000000000;;		rBytesPadded := make([]byte, keyBytes)
0000000000000000000000000000000000000000;;		copy(rBytesPadded[keyBytes-len(rBytes):], rBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sBytes := s.Bytes()
0000000000000000000000000000000000000000;;		sBytesPadded := make([]byte, keyBytes)
0000000000000000000000000000000000000000;;		copy(sBytesPadded[keyBytes-len(sBytes):], sBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := append(rBytesPadded, sBytesPadded...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Signature{
0000000000000000000000000000000000000000;;			Signature: out,
0000000000000000000000000000000000000000;;			protected: &rawHeader{},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify the given payload
0000000000000000000000000000000000000000;;	func (ctx ecEncrypterVerifier) verifyPayload(payload []byte, signature []byte, alg SignatureAlgorithm) error {
0000000000000000000000000000000000000000;;		var keySize int
0000000000000000000000000000000000000000;;		var hash crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case ES256:
0000000000000000000000000000000000000000;;			keySize = 32
0000000000000000000000000000000000000000;;			hash = crypto.SHA256
0000000000000000000000000000000000000000;;		case ES384:
0000000000000000000000000000000000000000;;			keySize = 48
0000000000000000000000000000000000000000;;			hash = crypto.SHA384
0000000000000000000000000000000000000000;;		case ES512:
0000000000000000000000000000000000000000;;			keySize = 66
0000000000000000000000000000000000000000;;			hash = crypto.SHA512
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(signature) != 2*keySize {
0000000000000000000000000000000000000000;;			return fmt.Errorf("square/go-jose: invalid signature size, have %d bytes, wanted %d", len(signature), 2*keySize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasher := hash.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// According to documentation, Write() on hash never fails
0000000000000000000000000000000000000000;;		_, _ = hasher.Write(payload)
0000000000000000000000000000000000000000;;		hashed := hasher.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := big.NewInt(0).SetBytes(signature[:keySize])
0000000000000000000000000000000000000000;;		s := big.NewInt(0).SetBytes(signature[keySize:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		match := ecdsa.Verify(ctx.publicKey, hashed, r, s)
0000000000000000000000000000000000000000;;		if !match {
0000000000000000000000000000000000000000;;			return errors.New("square/go-jose: ecdsa signature failed to verify")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
