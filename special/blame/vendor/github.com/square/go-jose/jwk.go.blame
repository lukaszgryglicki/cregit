0000000000000000000000000000000000000000;;	/*-
0000000000000000000000000000000000000000;;	 * Copyright 2014 Square Inc.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	 * you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	 * You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 *     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	 * distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	 * limitations under the License.
0000000000000000000000000000000000000000;;	 */
0ba55c488eaa2bd59fa46ecc0263ca44109d2949;;	
0000000000000000000000000000000000000000;;	package jose
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/square/go-jose/json"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rawJsonWebKey represents a public or private key in JWK format, used for parsing/serializing.
0000000000000000000000000000000000000000;;	type rawJsonWebKey struct {
0000000000000000000000000000000000000000;;		Use string      `json:"use,omitempty"`
0000000000000000000000000000000000000000;;		Kty string      `json:"kty,omitempty"`
0000000000000000000000000000000000000000;;		Kid string      `json:"kid,omitempty"`
0000000000000000000000000000000000000000;;		Crv string      `json:"crv,omitempty"`
0000000000000000000000000000000000000000;;		Alg string      `json:"alg,omitempty"`
0000000000000000000000000000000000000000;;		K   *byteBuffer `json:"k,omitempty"`
0000000000000000000000000000000000000000;;		X   *byteBuffer `json:"x,omitempty"`
0000000000000000000000000000000000000000;;		Y   *byteBuffer `json:"y,omitempty"`
0000000000000000000000000000000000000000;;		N   *byteBuffer `json:"n,omitempty"`
0000000000000000000000000000000000000000;;		E   *byteBuffer `json:"e,omitempty"`
0000000000000000000000000000000000000000;;		// -- Following fields are only used for private keys --
0000000000000000000000000000000000000000;;		// RSA uses D, P and Q, while ECDSA uses only D. Fields Dp, Dq, and Qi are
0000000000000000000000000000000000000000;;		// completely optional. Therefore for RSA/ECDSA, D != nil is a contract that
0000000000000000000000000000000000000000;;		// we have a private key whereas D == nil means we have only a public key.
0000000000000000000000000000000000000000;;		D  *byteBuffer `json:"d,omitempty"`
0000000000000000000000000000000000000000;;		P  *byteBuffer `json:"p,omitempty"`
0000000000000000000000000000000000000000;;		Q  *byteBuffer `json:"q,omitempty"`
0000000000000000000000000000000000000000;;		Dp *byteBuffer `json:"dp,omitempty"`
0000000000000000000000000000000000000000;;		Dq *byteBuffer `json:"dq,omitempty"`
0000000000000000000000000000000000000000;;		Qi *byteBuffer `json:"qi,omitempty"`
0000000000000000000000000000000000000000;;		// Certificates
0000000000000000000000000000000000000000;;		X5c []string `json:"x5c,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JsonWebKey represents a public or private key in JWK format.
0000000000000000000000000000000000000000;;	type JsonWebKey struct {
0000000000000000000000000000000000000000;;		Key          interface{}
0000000000000000000000000000000000000000;;		Certificates []*x509.Certificate
0000000000000000000000000000000000000000;;		KeyID        string
0000000000000000000000000000000000000000;;		Algorithm    string
0000000000000000000000000000000000000000;;		Use          string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON serializes the given key to its JSON representation.
0000000000000000000000000000000000000000;;	func (k JsonWebKey) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		var raw *rawJsonWebKey
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch key := k.Key.(type) {
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			raw, err = fromEcPublicKey(key)
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			raw = fromRsaPublicKey(key)
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			raw, err = fromEcPrivateKey(key)
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			raw, err = fromRsaPrivateKey(key)
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			raw, err = fromSymmetricKey(key)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: unknown key type '%s'", reflect.TypeOf(key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw.Kid = k.KeyID
0000000000000000000000000000000000000000;;		raw.Alg = k.Algorithm
0000000000000000000000000000000000000000;;		raw.Use = k.Use
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, cert := range k.Certificates {
0000000000000000000000000000000000000000;;			raw.X5c = append(raw.X5c, base64.StdEncoding.EncodeToString(cert.Raw))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(raw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON reads a key from its JSON representation.
0000000000000000000000000000000000000000;;	func (k *JsonWebKey) UnmarshalJSON(data []byte) (err error) {
0000000000000000000000000000000000000000;;		var raw rawJsonWebKey
0000000000000000000000000000000000000000;;		err = json.Unmarshal(data, &raw)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var key interface{}
0000000000000000000000000000000000000000;;		switch raw.Kty {
0000000000000000000000000000000000000000;;		case "EC":
0000000000000000000000000000000000000000;;			if raw.D != nil {
0000000000000000000000000000000000000000;;				key, err = raw.ecPrivateKey()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				key, err = raw.ecPublicKey()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "RSA":
0000000000000000000000000000000000000000;;			if raw.D != nil {
0000000000000000000000000000000000000000;;				key, err = raw.rsaPrivateKey()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				key, err = raw.rsaPublicKey()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case "oct":
0000000000000000000000000000000000000000;;			key, err = raw.symmetricKey()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = fmt.Errorf("square/go-jose: unknown json web key type '%s'", raw.Kty)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			*k = JsonWebKey{Key: key, KeyID: raw.Kid, Algorithm: raw.Alg, Use: raw.Use}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k.Certificates = make([]*x509.Certificate, len(raw.X5c))
0000000000000000000000000000000000000000;;		for i, cert := range raw.X5c {
0000000000000000000000000000000000000000;;			raw, err := base64.StdEncoding.DecodeString(cert)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k.Certificates[i], err = x509.ParseCertificate(raw)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JsonWebKeySet represents a JWK Set object.
0000000000000000000000000000000000000000;;	type JsonWebKeySet struct {
0000000000000000000000000000000000000000;;		Keys []JsonWebKey `json:"keys"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Key convenience method returns keys by key ID. Specification states
0000000000000000000000000000000000000000;;	// that a JWK Set "SHOULD" use distinct key IDs, but allows for some
0000000000000000000000000000000000000000;;	// cases where they are not distinct. Hence method returns a slice
0000000000000000000000000000000000000000;;	// of JsonWebKeys.
0000000000000000000000000000000000000000;;	func (s *JsonWebKeySet) Key(kid string) []JsonWebKey {
0000000000000000000000000000000000000000;;		var keys []JsonWebKey
0000000000000000000000000000000000000000;;		for _, key := range s.Keys {
0000000000000000000000000000000000000000;;			if key.KeyID == kid {
0000000000000000000000000000000000000000;;				keys = append(keys, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const rsaThumbprintTemplate = `{"e":"%s","kty":"RSA","n":"%s"}`
0000000000000000000000000000000000000000;;	const ecThumbprintTemplate = `{"crv":"%s","kty":"EC","x":"%s","y":"%s"}`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ecThumbprintInput(curve elliptic.Curve, x, y *big.Int) (string, error) {
0000000000000000000000000000000000000000;;		coordLength := curveSize(curve)
0000000000000000000000000000000000000000;;		crv, err := curveName(curve)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Sprintf(ecThumbprintTemplate, crv,
0000000000000000000000000000000000000000;;			newFixedSizeBuffer(x.Bytes(), coordLength).base64(),
0000000000000000000000000000000000000000;;			newFixedSizeBuffer(y.Bytes(), coordLength).base64()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rsaThumbprintInput(n *big.Int, e int) (string, error) {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(rsaThumbprintTemplate,
0000000000000000000000000000000000000000;;			newBufferFromInt(uint64(e)).base64(),
0000000000000000000000000000000000000000;;			newBuffer(n.Bytes()).base64()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Thumbprint computes the JWK Thumbprint of a key using the
0000000000000000000000000000000000000000;;	// indicated hash algorithm.
0000000000000000000000000000000000000000;;	func (k *JsonWebKey) Thumbprint(hash crypto.Hash) ([]byte, error) {
0000000000000000000000000000000000000000;;		var input string
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch key := k.Key.(type) {
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			input, err = ecThumbprintInput(key.Curve, key.X, key.Y)
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			input, err = ecThumbprintInput(key.Curve, key.X, key.Y)
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			input, err = rsaThumbprintInput(key.N, key.E)
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			input, err = rsaThumbprintInput(key.N, key.E)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: unknown key type '%s'", reflect.TypeOf(key))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := hash.New()
0000000000000000000000000000000000000000;;		h.Write([]byte(input))
0000000000000000000000000000000000000000;;		return h.Sum(nil), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Valid checks that the key contains the expected parameters
0000000000000000000000000000000000000000;;	func (k *JsonWebKey) Valid() bool {
0000000000000000000000000000000000000000;;		if k.Key == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch key := k.Key.(type) {
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			if key.Curve == nil || key.X == nil || key.Y == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			if key.Curve == nil || key.X == nil || key.Y == nil || key.D == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			if key.N == nil || key.E == 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			if key.N == nil || key.E == 0 || key.D == nil || len(key.Primes) < 2 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key rawJsonWebKey) rsaPublicKey() (*rsa.PublicKey, error) {
0000000000000000000000000000000000000000;;		if key.N == nil || key.E == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: invalid RSA key, missing n/e values")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rsa.PublicKey{
0000000000000000000000000000000000000000;;			N: key.N.bigInt(),
0000000000000000000000000000000000000000;;			E: key.E.toInt(),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromRsaPublicKey(pub *rsa.PublicKey) *rawJsonWebKey {
0000000000000000000000000000000000000000;;		return &rawJsonWebKey{
0000000000000000000000000000000000000000;;			Kty: "RSA",
0000000000000000000000000000000000000000;;			N:   newBuffer(pub.N.Bytes()),
0000000000000000000000000000000000000000;;			E:   newBufferFromInt(uint64(pub.E)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key rawJsonWebKey) ecPublicKey() (*ecdsa.PublicKey, error) {
0000000000000000000000000000000000000000;;		var curve elliptic.Curve
0000000000000000000000000000000000000000;;		switch key.Crv {
0000000000000000000000000000000000000000;;		case "P-256":
0000000000000000000000000000000000000000;;			curve = elliptic.P256()
0000000000000000000000000000000000000000;;		case "P-384":
0000000000000000000000000000000000000000;;			curve = elliptic.P384()
0000000000000000000000000000000000000000;;		case "P-521":
0000000000000000000000000000000000000000;;			curve = elliptic.P521()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: unsupported elliptic curve '%s'", key.Crv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if key.X == nil || key.Y == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid EC key, missing x/y values")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := key.X.bigInt()
0000000000000000000000000000000000000000;;		y := key.Y.bigInt()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !curve.IsOnCurve(x, y) {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid EC key, X/Y are not on declared curve")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ecdsa.PublicKey{
0000000000000000000000000000000000000000;;			Curve: curve,
0000000000000000000000000000000000000000;;			X:     x,
0000000000000000000000000000000000000000;;			Y:     y,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromEcPublicKey(pub *ecdsa.PublicKey) (*rawJsonWebKey, error) {
0000000000000000000000000000000000000000;;		if pub == nil || pub.X == nil || pub.Y == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: invalid EC key (nil, or X/Y missing)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		name, err := curveName(pub.Curve)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size := curveSize(pub.Curve)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		xBytes := pub.X.Bytes()
0000000000000000000000000000000000000000;;		yBytes := pub.Y.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(xBytes) > size || len(yBytes) > size {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: invalid EC key (X/Y too large)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := &rawJsonWebKey{
0000000000000000000000000000000000000000;;			Kty: "EC",
0000000000000000000000000000000000000000;;			Crv: name,
0000000000000000000000000000000000000000;;			X:   newFixedSizeBuffer(xBytes, size),
0000000000000000000000000000000000000000;;			Y:   newFixedSizeBuffer(yBytes, size),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key rawJsonWebKey) rsaPrivateKey() (*rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		var missing []string
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case key.N == nil:
0000000000000000000000000000000000000000;;			missing = append(missing, "N")
0000000000000000000000000000000000000000;;		case key.E == nil:
0000000000000000000000000000000000000000;;			missing = append(missing, "E")
0000000000000000000000000000000000000000;;		case key.D == nil:
0000000000000000000000000000000000000000;;			missing = append(missing, "D")
0000000000000000000000000000000000000000;;		case key.P == nil:
0000000000000000000000000000000000000000;;			missing = append(missing, "P")
0000000000000000000000000000000000000000;;		case key.Q == nil:
0000000000000000000000000000000000000000;;			missing = append(missing, "Q")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(missing) > 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: invalid RSA private key, missing %s value(s)", strings.Join(missing, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rv := &rsa.PrivateKey{
0000000000000000000000000000000000000000;;			PublicKey: rsa.PublicKey{
0000000000000000000000000000000000000000;;				N: key.N.bigInt(),
0000000000000000000000000000000000000000;;				E: key.E.toInt(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			D: key.D.bigInt(),
0000000000000000000000000000000000000000;;			Primes: []*big.Int{
0000000000000000000000000000000000000000;;				key.P.bigInt(),
0000000000000000000000000000000000000000;;				key.Q.bigInt(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if key.Dp != nil {
0000000000000000000000000000000000000000;;			rv.Precomputed.Dp = key.Dp.bigInt()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if key.Dq != nil {
0000000000000000000000000000000000000000;;			rv.Precomputed.Dq = key.Dq.bigInt()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if key.Qi != nil {
0000000000000000000000000000000000000000;;			rv.Precomputed.Qinv = key.Qi.bigInt()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := rv.Validate()
0000000000000000000000000000000000000000;;		return rv, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromRsaPrivateKey(rsa *rsa.PrivateKey) (*rawJsonWebKey, error) {
0000000000000000000000000000000000000000;;		if len(rsa.Primes) != 2 {
0000000000000000000000000000000000000000;;			return nil, ErrUnsupportedKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw := fromRsaPublicKey(&rsa.PublicKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw.D = newBuffer(rsa.D.Bytes())
0000000000000000000000000000000000000000;;		raw.P = newBuffer(rsa.Primes[0].Bytes())
0000000000000000000000000000000000000000;;		raw.Q = newBuffer(rsa.Primes[1].Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return raw, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key rawJsonWebKey) ecPrivateKey() (*ecdsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		var curve elliptic.Curve
0000000000000000000000000000000000000000;;		switch key.Crv {
0000000000000000000000000000000000000000;;		case "P-256":
0000000000000000000000000000000000000000;;			curve = elliptic.P256()
0000000000000000000000000000000000000000;;		case "P-384":
0000000000000000000000000000000000000000;;			curve = elliptic.P384()
0000000000000000000000000000000000000000;;		case "P-521":
0000000000000000000000000000000000000000;;			curve = elliptic.P521()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: unsupported elliptic curve '%s'", key.Crv)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if key.X == nil || key.Y == nil || key.D == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: invalid EC private key, missing x/y/d values")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		x := key.X.bigInt()
0000000000000000000000000000000000000000;;		y := key.Y.bigInt()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !curve.IsOnCurve(x, y) {
0000000000000000000000000000000000000000;;			return nil, errors.New("square/go-jose: invalid EC key, X/Y are not on declared curve")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ecdsa.PrivateKey{
0000000000000000000000000000000000000000;;			PublicKey: ecdsa.PublicKey{
0000000000000000000000000000000000000000;;				Curve: curve,
0000000000000000000000000000000000000000;;				X:     x,
0000000000000000000000000000000000000000;;				Y:     y,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			D: key.D.bigInt(),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromEcPrivateKey(ec *ecdsa.PrivateKey) (*rawJsonWebKey, error) {
0000000000000000000000000000000000000000;;		raw, err := fromEcPublicKey(&ec.PublicKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ec.D == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: invalid EC private key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		raw.D = newBuffer(ec.D.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return raw, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromSymmetricKey(key []byte) (*rawJsonWebKey, error) {
0000000000000000000000000000000000000000;;		return &rawJsonWebKey{
0000000000000000000000000000000000000000;;			Kty: "oct",
0000000000000000000000000000000000000000;;			K:   newBuffer(key),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (key rawJsonWebKey) symmetricKey() ([]byte, error) {
0000000000000000000000000000000000000000;;		if key.K == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("square/go-jose: invalid OCT (symmetric) key, missing k value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return key.K.bytes(), nil
0000000000000000000000000000000000000000;;	}
