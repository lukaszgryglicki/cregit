0000000000000000000000000000000000000000;;	// Copyright (c) 2014 TSUYUSATO Kitsune
0000000000000000000000000000000000000000;;	// This software is released under the MIT License.
0000000000000000000000000000000000000000;;	// http://opensource.org/licenses/mit-license.php
d724170bb0095021f4df9eadcf86507140d2409c;;	
0000000000000000000000000000000000000000;;	// Package heredoc provides the here-document with keeping indent.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Golang supports raw-string syntax.
0000000000000000000000000000000000000000;;	//     doc := `
0000000000000000000000000000000000000000;;	//     	Foo
0000000000000000000000000000000000000000;;	//     	Bar
0000000000000000000000000000000000000000;;	//     `
0000000000000000000000000000000000000000;;	// But raw-string cannot recognize indent. Thus such content is indented string, equivalent to
0000000000000000000000000000000000000000;;	//     "\n\tFoo\n\tBar\n"
0000000000000000000000000000000000000000;;	// I dont't want this!
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// However this problem is solved by package heredoc.
0000000000000000000000000000000000000000;;	//     doc := heredoc.Doc(`
0000000000000000000000000000000000000000;;	//     	Foo
0000000000000000000000000000000000000000;;	//     	Bar
0000000000000000000000000000000000000000;;	//     `)
0000000000000000000000000000000000000000;;	// It is equivalent to
0000000000000000000000000000000000000000;;	//     "Foo\nBar\n"
0000000000000000000000000000000000000000;;	package heredoc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// heredoc.Doc retutns unindented string as here-document.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Process of making here-document:
0000000000000000000000000000000000000000;;	//     1. Find most little indent size. (Skip empty lines)
0000000000000000000000000000000000000000;;	//     2. Remove this indents of lines.
0000000000000000000000000000000000000000;;	func Doc(raw string) string {
0000000000000000000000000000000000000000;;		skipFirstLine := false
0000000000000000000000000000000000000000;;		if raw[0] == '\n' {
0000000000000000000000000000000000000000;;			raw = raw[1:]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			skipFirstLine = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minIndentSize := int(^uint(0) >> 1) // Max value of type int
0000000000000000000000000000000000000000;;		lines := strings.Split(raw, "\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1.
0000000000000000000000000000000000000000;;		for i, line := range lines {
0000000000000000000000000000000000000000;;			if i == 0 && skipFirstLine {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			indentSize := 0
0000000000000000000000000000000000000000;;			for _, r := range []rune(line) {
0000000000000000000000000000000000000000;;				if unicode.IsSpace(r) {
0000000000000000000000000000000000000000;;					indentSize += 1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(line) == indentSize {
0000000000000000000000000000000000000000;;				if i == len(lines)-1 && indentSize < minIndentSize {
0000000000000000000000000000000000000000;;					lines[i] = ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if indentSize < minIndentSize {
0000000000000000000000000000000000000000;;				minIndentSize = indentSize
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2.
0000000000000000000000000000000000000000;;		for i, line := range lines {
0000000000000000000000000000000000000000;;			if i == 0 && skipFirstLine {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(lines[i]) >= minIndentSize {
0000000000000000000000000000000000000000;;				lines[i] = line[minIndentSize:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(lines, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// heredoc.Docf returns unindented and formatted string as here-document.
0000000000000000000000000000000000000000;;	// This format is same with package fmt's format.
0000000000000000000000000000000000000000;;	func Docf(raw string, args ...interface{}) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf(Doc(raw), args...)
0000000000000000000000000000000000000000;;	}
