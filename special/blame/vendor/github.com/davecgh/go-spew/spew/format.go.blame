0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Copyright (c) 2013 Dave Collins <dave@davec.name>
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Permission to use, copy, modify, and distribute this software for any
0000000000000000000000000000000000000000;;	 * purpose with or without fee is hereby granted, provided that the above
0000000000000000000000000000000000000000;;	 * copyright notice and this permission notice appear in all copies.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
0000000000000000000000000000000000000000;;	 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
0000000000000000000000000000000000000000;;	 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
0000000000000000000000000000000000000000;;	 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
0000000000000000000000000000000000000000;;	 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
0000000000000000000000000000000000000000;;	 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
0000000000000000000000000000000000000000;;	 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
0000000000000000000000000000000000000000;;	 */
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/github.com/davecgh/go-spew/spew/format.go[Godeps/_workspace/src/github.com/davecgh/go-spew/spew/format.go][vendor/github.com/davecgh/go-spew/spew/format.go];	
0000000000000000000000000000000000000000;;	package spew
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// supportedFlags is a list of all the character flags supported by fmt package.
0000000000000000000000000000000000000000;;	const supportedFlags = "0-+# "
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatState implements the fmt.Formatter interface and contains information
0000000000000000000000000000000000000000;;	// about the state of a formatting operation.  The NewFormatter function can
0000000000000000000000000000000000000000;;	// be used to get a new Formatter which can be used directly as arguments
0000000000000000000000000000000000000000;;	// in standard fmt package printing calls.
0000000000000000000000000000000000000000;;	type formatState struct {
0000000000000000000000000000000000000000;;		value          interface{}
0000000000000000000000000000000000000000;;		fs             fmt.State
0000000000000000000000000000000000000000;;		depth          int
0000000000000000000000000000000000000000;;		pointers       map[uintptr]int
0000000000000000000000000000000000000000;;		ignoreNextType bool
0000000000000000000000000000000000000000;;		cs             *ConfigState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// buildDefaultFormat recreates the original format string without precision
0000000000000000000000000000000000000000;;	// and width information to pass in to fmt.Sprintf in the case of an
0000000000000000000000000000000000000000;;	// unrecognized type.  Unless new types are added to the language, this
0000000000000000000000000000000000000000;;	// function won't ever be called.
0000000000000000000000000000000000000000;;	func (f *formatState) buildDefaultFormat() (format string) {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(percentBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, flag := range supportedFlags {
0000000000000000000000000000000000000000;;			if f.fs.Flag(int(flag)) {
0000000000000000000000000000000000000000;;				buf.WriteRune(flag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteRune('v')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		format = buf.String()
0000000000000000000000000000000000000000;;		return format
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// constructOrigFormat recreates the original format string including precision
0000000000000000000000000000000000000000;;	// and width information to pass along to the standard fmt package.  This allows
0000000000000000000000000000000000000000;;	// automatic deferral of all format strings this package doesn't support.
0000000000000000000000000000000000000000;;	func (f *formatState) constructOrigFormat(verb rune) (format string) {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(percentBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, flag := range supportedFlags {
0000000000000000000000000000000000000000;;			if f.fs.Flag(int(flag)) {
0000000000000000000000000000000000000000;;				buf.WriteRune(flag)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if width, ok := f.fs.Width(); ok {
0000000000000000000000000000000000000000;;			buf.WriteString(strconv.Itoa(width))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if precision, ok := f.fs.Precision(); ok {
0000000000000000000000000000000000000000;;			buf.Write(precisionBytes)
0000000000000000000000000000000000000000;;			buf.WriteString(strconv.Itoa(precision))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf.WriteRune(verb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		format = buf.String()
0000000000000000000000000000000000000000;;		return format
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unpackValue returns values inside of non-nil interfaces when possible and
0000000000000000000000000000000000000000;;	// ensures that types for values which have been unpacked from an interface
0000000000000000000000000000000000000000;;	// are displayed when the show types flag is also set.
0000000000000000000000000000000000000000;;	// This is useful for data types like structs, arrays, slices, and maps which
0000000000000000000000000000000000000000;;	// can contain varying types packed inside an interface.
0000000000000000000000000000000000000000;;	func (f *formatState) unpackValue(v reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;			f.ignoreNextType = false
0000000000000000000000000000000000000000;;			if !v.IsNil() {
0000000000000000000000000000000000000000;;				v = v.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// formatPtr handles formatting of pointers by indirecting them as necessary.
0000000000000000000000000000000000000000;;	func (f *formatState) formatPtr(v reflect.Value) {
0000000000000000000000000000000000000000;;		// Display nil if top level pointer is nil.
0000000000000000000000000000000000000000;;		showTypes := f.fs.Flag('#')
0000000000000000000000000000000000000000;;		if v.IsNil() && (!showTypes || f.ignoreNextType) {
0000000000000000000000000000000000000000;;			f.fs.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove pointers at or below the current depth from map used to detect
0000000000000000000000000000000000000000;;		// circular refs.
0000000000000000000000000000000000000000;;		for k, depth := range f.pointers {
0000000000000000000000000000000000000000;;			if depth >= f.depth {
0000000000000000000000000000000000000000;;				delete(f.pointers, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Keep list of all dereferenced pointers to possibly show later.
0000000000000000000000000000000000000000;;		pointerChain := make([]uintptr, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Figure out how many levels of indirection there are by derferencing
0000000000000000000000000000000000000000;;		// pointers and unpacking interfaces down the chain while detecting circular
0000000000000000000000000000000000000000;;		// references.
0000000000000000000000000000000000000000;;		nilFound := false
0000000000000000000000000000000000000000;;		cycleFound := false
0000000000000000000000000000000000000000;;		indirects := 0
0000000000000000000000000000000000000000;;		ve := v
0000000000000000000000000000000000000000;;		for ve.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if ve.IsNil() {
0000000000000000000000000000000000000000;;				nilFound = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			indirects++
0000000000000000000000000000000000000000;;			addr := ve.Pointer()
0000000000000000000000000000000000000000;;			pointerChain = append(pointerChain, addr)
0000000000000000000000000000000000000000;;			if pd, ok := f.pointers[addr]; ok && pd < f.depth {
0000000000000000000000000000000000000000;;				cycleFound = true
0000000000000000000000000000000000000000;;				indirects--
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.pointers[addr] = f.depth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ve = ve.Elem()
0000000000000000000000000000000000000000;;			if ve.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;				if ve.IsNil() {
0000000000000000000000000000000000000000;;					nilFound = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ve = ve.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Display type or indirection level depending on flags.
0000000000000000000000000000000000000000;;		if showTypes && !f.ignoreNextType {
0000000000000000000000000000000000000000;;			f.fs.Write(openParenBytes)
0000000000000000000000000000000000000000;;			f.fs.Write(bytes.Repeat(asteriskBytes, indirects))
0000000000000000000000000000000000000000;;			f.fs.Write([]byte(ve.Type().String()))
0000000000000000000000000000000000000000;;			f.fs.Write(closeParenBytes)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if nilFound || cycleFound {
0000000000000000000000000000000000000000;;				indirects += strings.Count(ve.Type().String(), "*")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.fs.Write(openAngleBytes)
0000000000000000000000000000000000000000;;			f.fs.Write([]byte(strings.Repeat("*", indirects)))
0000000000000000000000000000000000000000;;			f.fs.Write(closeAngleBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Display pointer information depending on flags.
0000000000000000000000000000000000000000;;		if f.fs.Flag('+') && (len(pointerChain) > 0) {
0000000000000000000000000000000000000000;;			f.fs.Write(openParenBytes)
0000000000000000000000000000000000000000;;			for i, addr := range pointerChain {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					f.fs.Write(pointerChainBytes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				printHexPtr(f.fs, addr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.fs.Write(closeParenBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Display dereferenced value.
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case nilFound == true:
0000000000000000000000000000000000000000;;			f.fs.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case cycleFound == true:
0000000000000000000000000000000000000000;;			f.fs.Write(circularShortBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			f.ignoreNextType = true
0000000000000000000000000000000000000000;;			f.format(ve)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// format is the main workhorse for providing the Formatter interface.  It
0000000000000000000000000000000000000000;;	// uses the passed reflect value to figure out what kind of object we are
0000000000000000000000000000000000000000;;	// dealing with and formats it appropriately.  It is a recursive function,
0000000000000000000000000000000000000000;;	// however circular data structures are detected and handled properly.
0000000000000000000000000000000000000000;;	func (f *formatState) format(v reflect.Value) {
0000000000000000000000000000000000000000;;		// Handle invalid reflect values immediately.
0000000000000000000000000000000000000000;;		kind := v.Kind()
0000000000000000000000000000000000000000;;		if kind == reflect.Invalid {
0000000000000000000000000000000000000000;;			f.fs.Write(invalidAngleBytes)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle pointers specially.
0000000000000000000000000000000000000000;;		if kind == reflect.Ptr {
0000000000000000000000000000000000000000;;			f.formatPtr(v)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Print type information unless already handled elsewhere.
0000000000000000000000000000000000000000;;		if !f.ignoreNextType && f.fs.Flag('#') {
0000000000000000000000000000000000000000;;			f.fs.Write(openParenBytes)
0000000000000000000000000000000000000000;;			f.fs.Write([]byte(v.Type().String()))
0000000000000000000000000000000000000000;;			f.fs.Write(closeParenBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.ignoreNextType = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call Stringer/error interfaces if they exist and the handle methods
0000000000000000000000000000000000000000;;		// flag is enabled.
0000000000000000000000000000000000000000;;		if !f.cs.DisableMethods {
0000000000000000000000000000000000000000;;			if (kind != reflect.Invalid) && (kind != reflect.Interface) {
0000000000000000000000000000000000000000;;				if handled := handleMethods(f.cs, f.fs, v); handled {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case reflect.Invalid:
0000000000000000000000000000000000000000;;			// Do nothing.  We should never get here since invalid has already
0000000000000000000000000000000000000000;;			// been handled above.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			printBool(f.fs, v.Bool())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
0000000000000000000000000000000000000000;;			printInt(f.fs, v.Int(), 10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
0000000000000000000000000000000000000000;;			printUint(f.fs, v.Uint(), 10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			printFloat(f.fs, v.Float(), 32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			printFloat(f.fs, v.Float(), 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Complex64:
0000000000000000000000000000000000000000;;			printComplex(f.fs, v.Complex(), 32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Complex128:
0000000000000000000000000000000000000000;;			printComplex(f.fs, v.Complex(), 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				f.fs.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			f.fs.Write(openBracketBytes)
0000000000000000000000000000000000000000;;			f.depth++
0000000000000000000000000000000000000000;;			if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
0000000000000000000000000000000000000000;;				f.fs.Write(maxShortBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numEntries := v.Len()
0000000000000000000000000000000000000000;;				for i := 0; i < numEntries; i++ {
0000000000000000000000000000000000000000;;					if i > 0 {
0000000000000000000000000000000000000000;;						f.fs.Write(spaceBytes)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					f.ignoreNextType = true
0000000000000000000000000000000000000000;;					f.format(f.unpackValue(v.Index(i)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.depth--
0000000000000000000000000000000000000000;;			f.fs.Write(closeBracketBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			f.fs.Write([]byte(v.String()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// The only time we should get here is for nil interfaces due to
0000000000000000000000000000000000000000;;			// unpackValue calls.
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				f.fs.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			// Do nothing.  We should never get here since pointers have already
0000000000000000000000000000000000000000;;			// been handled above.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			// nil maps should be indicated as different than empty maps
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				f.fs.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			f.fs.Write(openMapBytes)
0000000000000000000000000000000000000000;;			f.depth++
0000000000000000000000000000000000000000;;			if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
0000000000000000000000000000000000000000;;				f.fs.Write(maxShortBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				keys := v.MapKeys()
0000000000000000000000000000000000000000;;				if f.cs.SortKeys {
0000000000000000000000000000000000000000;;					sortValues(keys, f.cs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i, key := range keys {
0000000000000000000000000000000000000000;;					if i > 0 {
0000000000000000000000000000000000000000;;						f.fs.Write(spaceBytes)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					f.ignoreNextType = true
0000000000000000000000000000000000000000;;					f.format(f.unpackValue(key))
0000000000000000000000000000000000000000;;					f.fs.Write(colonBytes)
0000000000000000000000000000000000000000;;					f.ignoreNextType = true
0000000000000000000000000000000000000000;;					f.format(f.unpackValue(v.MapIndex(key)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.depth--
0000000000000000000000000000000000000000;;			f.fs.Write(closeMapBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			numFields := v.NumField()
0000000000000000000000000000000000000000;;			f.fs.Write(openBraceBytes)
0000000000000000000000000000000000000000;;			f.depth++
0000000000000000000000000000000000000000;;			if (f.cs.MaxDepth != 0) && (f.depth > f.cs.MaxDepth) {
0000000000000000000000000000000000000000;;				f.fs.Write(maxShortBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vt := v.Type()
0000000000000000000000000000000000000000;;				for i := 0; i < numFields; i++ {
0000000000000000000000000000000000000000;;					if i > 0 {
0000000000000000000000000000000000000000;;						f.fs.Write(spaceBytes)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					vtf := vt.Field(i)
0000000000000000000000000000000000000000;;					if f.fs.Flag('+') || f.fs.Flag('#') {
0000000000000000000000000000000000000000;;						f.fs.Write([]byte(vtf.Name))
0000000000000000000000000000000000000000;;						f.fs.Write(colonBytes)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					f.format(f.unpackValue(v.Field(i)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.depth--
0000000000000000000000000000000000000000;;			f.fs.Write(closeBraceBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Uintptr:
0000000000000000000000000000000000000000;;			printHexPtr(f.fs, uintptr(v.Uint()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.UnsafePointer, reflect.Chan, reflect.Func:
0000000000000000000000000000000000000000;;			printHexPtr(f.fs, v.Pointer())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There were not any other types at the time this code was written, but
0000000000000000000000000000000000000000;;		// fall back to letting the default fmt package handle it if any get added.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			format := f.buildDefaultFormat()
0000000000000000000000000000000000000000;;			if v.CanInterface() {
0000000000000000000000000000000000000000;;				fmt.Fprintf(f.fs, format, v.Interface())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(f.fs, format, v.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Format satisfies the fmt.Formatter interface. See NewFormatter for usage
0000000000000000000000000000000000000000;;	// details.
0000000000000000000000000000000000000000;;	func (f *formatState) Format(fs fmt.State, verb rune) {
0000000000000000000000000000000000000000;;		f.fs = fs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use standard formatting for verbs that are not v.
0000000000000000000000000000000000000000;;		if verb != 'v' {
0000000000000000000000000000000000000000;;			format := f.constructOrigFormat(verb)
0000000000000000000000000000000000000000;;			fmt.Fprintf(fs, format, f.value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.value == nil {
0000000000000000000000000000000000000000;;			if fs.Flag('#') {
0000000000000000000000000000000000000000;;				fs.Write(interfaceBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fs.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.format(reflect.ValueOf(f.value))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newFormatter is a helper function to consolidate the logic from the various
0000000000000000000000000000000000000000;;	// public methods which take varying config states.
0000000000000000000000000000000000000000;;	func newFormatter(cs *ConfigState, v interface{}) fmt.Formatter {
0000000000000000000000000000000000000000;;		fs := &formatState{value: v, cs: cs}
0000000000000000000000000000000000000000;;		fs.pointers = make(map[uintptr]int)
0000000000000000000000000000000000000000;;		return fs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	NewFormatter returns a custom formatter that satisfies the fmt.Formatter
0000000000000000000000000000000000000000;;	interface.  As a result, it integrates cleanly with standard fmt package
0000000000000000000000000000000000000000;;	printing functions.  The formatter is useful for inline printing of smaller data
0000000000000000000000000000000000000000;;	types similar to the standard %v format specifier.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The custom formatter only responds to the %v (most compact), %+v (adds pointer
0000000000000000000000000000000000000000;;	addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
0000000000000000000000000000000000000000;;	combinations.  Any other verbs such as %x and %q will be sent to the the
0000000000000000000000000000000000000000;;	standard fmt package for formatting.  In addition, the custom formatter ignores
0000000000000000000000000000000000000000;;	the width and precision arguments (however they will still work on the format
0000000000000000000000000000000000000000;;	specifiers not handled by the custom formatter).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Typically this function shouldn't be called directly.  It is much easier to make
0000000000000000000000000000000000000000;;	use of the custom formatter by calling one of the convenience functions such as
0000000000000000000000000000000000000000;;	Printf, Println, or Fprintf.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func NewFormatter(v interface{}) fmt.Formatter {
0000000000000000000000000000000000000000;;		return newFormatter(&Config, v)
0000000000000000000000000000000000000000;;	}
