0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Copyright (c) 2013 Dave Collins <dave@davec.name>
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Permission to use, copy, modify, and distribute this software for any
0000000000000000000000000000000000000000;;	 * purpose with or without fee is hereby granted, provided that the above
0000000000000000000000000000000000000000;;	 * copyright notice and this permission notice appear in all copies.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
0000000000000000000000000000000000000000;;	 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
0000000000000000000000000000000000000000;;	 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
0000000000000000000000000000000000000000;;	 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
0000000000000000000000000000000000000000;;	 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
0000000000000000000000000000000000000000;;	 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
0000000000000000000000000000000000000000;;	 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
0000000000000000000000000000000000000000;;	 */
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/github.com/davecgh/go-spew/spew/common.go[Godeps/_workspace/src/github.com/davecgh/go-spew/spew/common.go][vendor/github.com/davecgh/go-spew/spew/common.go];	
0000000000000000000000000000000000000000;;	package spew
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Some constants in the form of bytes to avoid string overhead.  This mirrors
0000000000000000000000000000000000000000;;	// the technique used in the fmt package.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		panicBytes            = []byte("(PANIC=")
0000000000000000000000000000000000000000;;		plusBytes             = []byte("+")
0000000000000000000000000000000000000000;;		iBytes                = []byte("i")
0000000000000000000000000000000000000000;;		trueBytes             = []byte("true")
0000000000000000000000000000000000000000;;		falseBytes            = []byte("false")
0000000000000000000000000000000000000000;;		interfaceBytes        = []byte("(interface {})")
0000000000000000000000000000000000000000;;		commaNewlineBytes     = []byte(",\n")
0000000000000000000000000000000000000000;;		newlineBytes          = []byte("\n")
0000000000000000000000000000000000000000;;		openBraceBytes        = []byte("{")
0000000000000000000000000000000000000000;;		openBraceNewlineBytes = []byte("{\n")
0000000000000000000000000000000000000000;;		closeBraceBytes       = []byte("}")
0000000000000000000000000000000000000000;;		asteriskBytes         = []byte("*")
0000000000000000000000000000000000000000;;		colonBytes            = []byte(":")
0000000000000000000000000000000000000000;;		colonSpaceBytes       = []byte(": ")
0000000000000000000000000000000000000000;;		openParenBytes        = []byte("(")
0000000000000000000000000000000000000000;;		closeParenBytes       = []byte(")")
0000000000000000000000000000000000000000;;		spaceBytes            = []byte(" ")
0000000000000000000000000000000000000000;;		pointerChainBytes     = []byte("->")
0000000000000000000000000000000000000000;;		nilAngleBytes         = []byte("<nil>")
0000000000000000000000000000000000000000;;		maxNewlineBytes       = []byte("<max depth reached>\n")
0000000000000000000000000000000000000000;;		maxShortBytes         = []byte("<max>")
0000000000000000000000000000000000000000;;		circularBytes         = []byte("<already shown>")
0000000000000000000000000000000000000000;;		circularShortBytes    = []byte("<shown>")
0000000000000000000000000000000000000000;;		invalidAngleBytes     = []byte("<invalid>")
0000000000000000000000000000000000000000;;		openBracketBytes      = []byte("[")
0000000000000000000000000000000000000000;;		closeBracketBytes     = []byte("]")
0000000000000000000000000000000000000000;;		percentBytes          = []byte("%")
0000000000000000000000000000000000000000;;		precisionBytes        = []byte(".")
0000000000000000000000000000000000000000;;		openAngleBytes        = []byte("<")
0000000000000000000000000000000000000000;;		closeAngleBytes       = []byte(">")
0000000000000000000000000000000000000000;;		openMapBytes          = []byte("map[")
0000000000000000000000000000000000000000;;		closeMapBytes         = []byte("]")
0000000000000000000000000000000000000000;;		lenEqualsBytes        = []byte("len=")
0000000000000000000000000000000000000000;;		capEqualsBytes        = []byte("cap=")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// hexDigits is used to map a decimal value to a hex digit.
0000000000000000000000000000000000000000;;	var hexDigits = "0123456789abcdef"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// catchPanic handles any panics that might occur during the handleMethods
0000000000000000000000000000000000000000;;	// calls.
0000000000000000000000000000000000000000;;	func catchPanic(w io.Writer, v reflect.Value) {
0000000000000000000000000000000000000000;;		if err := recover(); err != nil {
0000000000000000000000000000000000000000;;			w.Write(panicBytes)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "%v", err)
0000000000000000000000000000000000000000;;			w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handleMethods attempts to call the Error and String methods on the underlying
0000000000000000000000000000000000000000;;	// type the passed reflect.Value represents and outputes the result to Writer w.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It handles panics in any called methods by catching and displaying the error
0000000000000000000000000000000000000000;;	// as the formatted value.
0000000000000000000000000000000000000000;;	func handleMethods(cs *ConfigState, w io.Writer, v reflect.Value) (handled bool) {
0000000000000000000000000000000000000000;;		// We need an interface to check if the type implements the error or
0000000000000000000000000000000000000000;;		// Stringer interface.  However, the reflect package won't give us an
0000000000000000000000000000000000000000;;		// interface on certain things like unexported struct fields in order
0000000000000000000000000000000000000000;;		// to enforce visibility rules.  We use unsafe, when it's available,
0000000000000000000000000000000000000000;;		// to bypass these restrictions since this package does not mutate the
0000000000000000000000000000000000000000;;		// values.
0000000000000000000000000000000000000000;;		if !v.CanInterface() {
0000000000000000000000000000000000000000;;			if UnsafeDisabled {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v = unsafeReflectValue(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Choose whether or not to do error and Stringer interface lookups against
0000000000000000000000000000000000000000;;		// the base type or a pointer to the base type depending on settings.
0000000000000000000000000000000000000000;;		// Technically calling one of these methods with a pointer receiver can
0000000000000000000000000000000000000000;;		// mutate the value, however, types which choose to satisify an error or
0000000000000000000000000000000000000000;;		// Stringer interface with a pointer receiver should not be mutating their
0000000000000000000000000000000000000000;;		// state inside these interface methods.
0000000000000000000000000000000000000000;;		if !cs.DisablePointerMethods && !UnsafeDisabled && !v.CanAddr() {
0000000000000000000000000000000000000000;;			v = unsafeReflectValue(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.CanAddr() {
0000000000000000000000000000000000000000;;			v = v.Addr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it an error or Stringer?
0000000000000000000000000000000000000000;;		switch iface := v.Interface().(type) {
0000000000000000000000000000000000000000;;		case error:
0000000000000000000000000000000000000000;;			defer catchPanic(w, v)
0000000000000000000000000000000000000000;;			if cs.ContinueOnMethod {
0000000000000000000000000000000000000000;;				w.Write(openParenBytes)
0000000000000000000000000000000000000000;;				w.Write([]byte(iface.Error()))
0000000000000000000000000000000000000000;;				w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;				w.Write(spaceBytes)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Write([]byte(iface.Error()))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case fmt.Stringer:
0000000000000000000000000000000000000000;;			defer catchPanic(w, v)
0000000000000000000000000000000000000000;;			if cs.ContinueOnMethod {
0000000000000000000000000000000000000000;;				w.Write(openParenBytes)
0000000000000000000000000000000000000000;;				w.Write([]byte(iface.String()))
0000000000000000000000000000000000000000;;				w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;				w.Write(spaceBytes)
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.Write([]byte(iface.String()))
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printBool outputs a boolean value as true or false to Writer w.
0000000000000000000000000000000000000000;;	func printBool(w io.Writer, val bool) {
0000000000000000000000000000000000000000;;		if val {
0000000000000000000000000000000000000000;;			w.Write(trueBytes)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.Write(falseBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printInt outputs a signed integer value to Writer w.
0000000000000000000000000000000000000000;;	func printInt(w io.Writer, val int64, base int) {
0000000000000000000000000000000000000000;;		w.Write([]byte(strconv.FormatInt(val, base)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printUint outputs an unsigned integer value to Writer w.
0000000000000000000000000000000000000000;;	func printUint(w io.Writer, val uint64, base int) {
0000000000000000000000000000000000000000;;		w.Write([]byte(strconv.FormatUint(val, base)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printFloat outputs a floating point value using the specified precision,
0000000000000000000000000000000000000000;;	// which is expected to be 32 or 64bit, to Writer w.
0000000000000000000000000000000000000000;;	func printFloat(w io.Writer, val float64, precision int) {
0000000000000000000000000000000000000000;;		w.Write([]byte(strconv.FormatFloat(val, 'g', -1, precision)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printComplex outputs a complex value using the specified float precision
0000000000000000000000000000000000000000;;	// for the real and imaginary parts to Writer w.
0000000000000000000000000000000000000000;;	func printComplex(w io.Writer, c complex128, floatPrecision int) {
0000000000000000000000000000000000000000;;		r := real(c)
0000000000000000000000000000000000000000;;		w.Write(openParenBytes)
0000000000000000000000000000000000000000;;		w.Write([]byte(strconv.FormatFloat(r, 'g', -1, floatPrecision)))
0000000000000000000000000000000000000000;;		i := imag(c)
0000000000000000000000000000000000000000;;		if i >= 0 {
0000000000000000000000000000000000000000;;			w.Write(plusBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Write([]byte(strconv.FormatFloat(i, 'g', -1, floatPrecision)))
0000000000000000000000000000000000000000;;		w.Write(iBytes)
0000000000000000000000000000000000000000;;		w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// printHexPtr outputs a uintptr formatted as hexidecimal with a leading '0x'
0000000000000000000000000000000000000000;;	// prefix to Writer w.
0000000000000000000000000000000000000000;;	func printHexPtr(w io.Writer, p uintptr) {
0000000000000000000000000000000000000000;;		// Null pointer.
0000000000000000000000000000000000000000;;		num := uint64(p)
0000000000000000000000000000000000000000;;		if num == 0 {
0000000000000000000000000000000000000000;;			w.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Max uint64 is 16 bytes in hex + 2 bytes for '0x' prefix
0000000000000000000000000000000000000000;;		buf := make([]byte, 18)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It's simpler to construct the hex string right to left.
0000000000000000000000000000000000000000;;		base := uint64(16)
0000000000000000000000000000000000000000;;		i := len(buf) - 1
0000000000000000000000000000000000000000;;		for num >= base {
0000000000000000000000000000000000000000;;			buf[i] = hexDigits[num%base]
0000000000000000000000000000000000000000;;			num /= base
0000000000000000000000000000000000000000;;			i--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf[i] = hexDigits[num]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add '0x' prefix.
0000000000000000000000000000000000000000;;		i--
0000000000000000000000000000000000000000;;		buf[i] = 'x'
0000000000000000000000000000000000000000;;		i--
0000000000000000000000000000000000000000;;		buf[i] = '0'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Strip unused leading bytes.
0000000000000000000000000000000000000000;;		buf = buf[i:]
0000000000000000000000000000000000000000;;		w.Write(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valuesSorter implements sort.Interface to allow a slice of reflect.Value
0000000000000000000000000000000000000000;;	// elements to be sorted.
0000000000000000000000000000000000000000;;	type valuesSorter struct {
0000000000000000000000000000000000000000;;		values  []reflect.Value
0000000000000000000000000000000000000000;;		strings []string // either nil or same len and values
0000000000000000000000000000000000000000;;		cs      *ConfigState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newValuesSorter initializes a valuesSorter instance, which holds a set of
0000000000000000000000000000000000000000;;	// surrogate keys on which the data should be sorted.  It uses flags in
0000000000000000000000000000000000000000;;	// ConfigState to decide if and how to populate those surrogate keys.
0000000000000000000000000000000000000000;;	func newValuesSorter(values []reflect.Value, cs *ConfigState) sort.Interface {
0000000000000000000000000000000000000000;;		vs := &valuesSorter{values: values, cs: cs}
0000000000000000000000000000000000000000;;		if canSortSimply(vs.values[0].Kind()) {
0000000000000000000000000000000000000000;;			return vs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cs.DisableMethods {
0000000000000000000000000000000000000000;;			vs.strings = make([]string, len(values))
0000000000000000000000000000000000000000;;			for i := range vs.values {
0000000000000000000000000000000000000000;;				b := bytes.Buffer{}
0000000000000000000000000000000000000000;;				if !handleMethods(cs, &b, vs.values[i]) {
0000000000000000000000000000000000000000;;					vs.strings = nil
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				vs.strings[i] = b.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vs.strings == nil && cs.SpewKeys {
0000000000000000000000000000000000000000;;			vs.strings = make([]string, len(values))
0000000000000000000000000000000000000000;;			for i := range vs.values {
0000000000000000000000000000000000000000;;				vs.strings[i] = Sprintf("%#v", vs.values[i].Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return vs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// canSortSimply tests whether a reflect.Kind is a primitive that can be sorted
0000000000000000000000000000000000000000;;	// directly, or whether it should be considered for sorting by surrogate keys
0000000000000000000000000000000000000000;;	// (if the ConfigState allows it).
0000000000000000000000000000000000000000;;	func canSortSimply(kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		// This switch parallels valueSortLess, except for the default case.
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Uintptr:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of values in the slice.  It is part of the
0000000000000000000000000000000000000000;;	// sort.Interface implementation.
0000000000000000000000000000000000000000;;	func (s *valuesSorter) Len() int {
0000000000000000000000000000000000000000;;		return len(s.values)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Swap swaps the values at the passed indices.  It is part of the
0000000000000000000000000000000000000000;;	// sort.Interface implementation.
0000000000000000000000000000000000000000;;	func (s *valuesSorter) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s.values[i], s.values[j] = s.values[j], s.values[i]
0000000000000000000000000000000000000000;;		if s.strings != nil {
0000000000000000000000000000000000000000;;			s.strings[i], s.strings[j] = s.strings[j], s.strings[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// valueSortLess returns whether the first value should sort before the second
0000000000000000000000000000000000000000;;	// value.  It is used by valueSorter.Less as part of the sort.Interface
0000000000000000000000000000000000000000;;	// implementation.
0000000000000000000000000000000000000000;;	func valueSortLess(a, b reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch a.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !a.Bool() && b.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
0000000000000000000000000000000000000000;;			return a.Int() < b.Int()
0000000000000000000000000000000000000000;;		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
0000000000000000000000000000000000000000;;			return a.Uint() < b.Uint()
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return a.Float() < b.Float()
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return a.String() < b.String()
0000000000000000000000000000000000000000;;		case reflect.Uintptr:
0000000000000000000000000000000000000000;;			return a.Uint() < b.Uint()
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			// Compare the contents of both arrays.
0000000000000000000000000000000000000000;;			l := a.Len()
0000000000000000000000000000000000000000;;			for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;				av := a.Index(i)
0000000000000000000000000000000000000000;;				bv := b.Index(i)
0000000000000000000000000000000000000000;;				if av.Interface() == bv.Interface() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return valueSortLess(av, bv)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.String() < b.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less returns whether the value at index i should sort before the
0000000000000000000000000000000000000000;;	// value at index j.  It is part of the sort.Interface implementation.
0000000000000000000000000000000000000000;;	func (s *valuesSorter) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		if s.strings == nil {
0000000000000000000000000000000000000000;;			return valueSortLess(s.values[i], s.values[j])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.strings[i] < s.strings[j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sortValues is a sort function that handles both native types and any type that
0000000000000000000000000000000000000000;;	// can be converted to error or Stringer.  Other inputs are sorted according to
0000000000000000000000000000000000000000;;	// their Value.String() value to ensure display stability.
0000000000000000000000000000000000000000;;	func sortValues(values []reflect.Value, cs *ConfigState) {
0000000000000000000000000000000000000000;;		if len(values) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(newValuesSorter(values, cs))
0000000000000000000000000000000000000000;;	}
