0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Copyright (c) 2013 Dave Collins <dave@davec.name>
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Permission to use, copy, modify, and distribute this software for any
0000000000000000000000000000000000000000;;	 * purpose with or without fee is hereby granted, provided that the above
0000000000000000000000000000000000000000;;	 * copyright notice and this permission notice appear in all copies.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
0000000000000000000000000000000000000000;;	 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
0000000000000000000000000000000000000000;;	 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
0000000000000000000000000000000000000000;;	 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
0000000000000000000000000000000000000000;;	 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
0000000000000000000000000000000000000000;;	 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
0000000000000000000000000000000000000000;;	 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
0000000000000000000000000000000000000000;;	 */
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/github.com/davecgh/go-spew/spew/dump.go[Godeps/_workspace/src/github.com/davecgh/go-spew/spew/dump.go][vendor/github.com/davecgh/go-spew/spew/dump.go];	
0000000000000000000000000000000000000000;;	package spew
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// uint8Type is a reflect.Type representing a uint8.  It is used to
0000000000000000000000000000000000000000;;		// convert cgo types to uint8 slices for hexdumping.
0000000000000000000000000000000000000000;;		uint8Type = reflect.TypeOf(uint8(0))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cCharRE is a regular expression that matches a cgo char.
0000000000000000000000000000000000000000;;		// It is used to detect character arrays to hexdump them.
0000000000000000000000000000000000000000;;		cCharRE = regexp.MustCompile("^.*\\._Ctype_char$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cUnsignedCharRE is a regular expression that matches a cgo unsigned
0000000000000000000000000000000000000000;;		// char.  It is used to detect unsigned character arrays to hexdump
0000000000000000000000000000000000000000;;		// them.
0000000000000000000000000000000000000000;;		cUnsignedCharRE = regexp.MustCompile("^.*\\._Ctype_unsignedchar$")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// cUint8tCharRE is a regular expression that matches a cgo uint8_t.
0000000000000000000000000000000000000000;;		// It is used to detect uint8_t arrays to hexdump them.
0000000000000000000000000000000000000000;;		cUint8tCharRE = regexp.MustCompile("^.*\\._Ctype_uint8_t$")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dumpState contains information about the state of a dump operation.
0000000000000000000000000000000000000000;;	type dumpState struct {
0000000000000000000000000000000000000000;;		w                io.Writer
0000000000000000000000000000000000000000;;		depth            int
0000000000000000000000000000000000000000;;		pointers         map[uintptr]int
0000000000000000000000000000000000000000;;		ignoreNextType   bool
0000000000000000000000000000000000000000;;		ignoreNextIndent bool
0000000000000000000000000000000000000000;;		cs               *ConfigState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// indent performs indentation according to the depth level and cs.Indent
0000000000000000000000000000000000000000;;	// option.
0000000000000000000000000000000000000000;;	func (d *dumpState) indent() {
0000000000000000000000000000000000000000;;		if d.ignoreNextIndent {
0000000000000000000000000000000000000000;;			d.ignoreNextIndent = false
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.w.Write(bytes.Repeat([]byte(d.cs.Indent), d.depth))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unpackValue returns values inside of non-nil interfaces when possible.
0000000000000000000000000000000000000000;;	// This is useful for data types like structs, arrays, slices, and maps which
0000000000000000000000000000000000000000;;	// can contain varying types packed inside an interface.
0000000000000000000000000000000000000000;;	func (d *dumpState) unpackValue(v reflect.Value) reflect.Value {
0000000000000000000000000000000000000000;;		if v.Kind() == reflect.Interface && !v.IsNil() {
0000000000000000000000000000000000000000;;			v = v.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dumpPtr handles formatting of pointers by indirecting them as necessary.
0000000000000000000000000000000000000000;;	func (d *dumpState) dumpPtr(v reflect.Value) {
0000000000000000000000000000000000000000;;		// Remove pointers at or below the current depth from map used to detect
0000000000000000000000000000000000000000;;		// circular refs.
0000000000000000000000000000000000000000;;		for k, depth := range d.pointers {
0000000000000000000000000000000000000000;;			if depth >= d.depth {
0000000000000000000000000000000000000000;;				delete(d.pointers, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Keep list of all dereferenced pointers to show later.
0000000000000000000000000000000000000000;;		pointerChain := make([]uintptr, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Figure out how many levels of indirection there are by dereferencing
0000000000000000000000000000000000000000;;		// pointers and unpacking interfaces down the chain while detecting circular
0000000000000000000000000000000000000000;;		// references.
0000000000000000000000000000000000000000;;		nilFound := false
0000000000000000000000000000000000000000;;		cycleFound := false
0000000000000000000000000000000000000000;;		indirects := 0
0000000000000000000000000000000000000000;;		ve := v
0000000000000000000000000000000000000000;;		for ve.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			if ve.IsNil() {
0000000000000000000000000000000000000000;;				nilFound = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			indirects++
0000000000000000000000000000000000000000;;			addr := ve.Pointer()
0000000000000000000000000000000000000000;;			pointerChain = append(pointerChain, addr)
0000000000000000000000000000000000000000;;			if pd, ok := d.pointers[addr]; ok && pd < d.depth {
0000000000000000000000000000000000000000;;				cycleFound = true
0000000000000000000000000000000000000000;;				indirects--
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.pointers[addr] = d.depth
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ve = ve.Elem()
0000000000000000000000000000000000000000;;			if ve.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;				if ve.IsNil() {
0000000000000000000000000000000000000000;;					nilFound = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ve = ve.Elem()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Display type information.
0000000000000000000000000000000000000000;;		d.w.Write(openParenBytes)
0000000000000000000000000000000000000000;;		d.w.Write(bytes.Repeat(asteriskBytes, indirects))
0000000000000000000000000000000000000000;;		d.w.Write([]byte(ve.Type().String()))
0000000000000000000000000000000000000000;;		d.w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Display pointer information.
0000000000000000000000000000000000000000;;		if len(pointerChain) > 0 {
0000000000000000000000000000000000000000;;			d.w.Write(openParenBytes)
0000000000000000000000000000000000000000;;			for i, addr := range pointerChain {
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					d.w.Write(pointerChainBytes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				printHexPtr(d.w, addr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Display dereferenced value.
0000000000000000000000000000000000000000;;		d.w.Write(openParenBytes)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case nilFound == true:
0000000000000000000000000000000000000000;;			d.w.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case cycleFound == true:
0000000000000000000000000000000000000000;;			d.w.Write(circularBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			d.ignoreNextType = true
0000000000000000000000000000000000000000;;			d.dump(ve)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dumpSlice handles formatting of arrays and slices.  Byte (uint8 under
0000000000000000000000000000000000000000;;	// reflection) arrays and slices are dumped in hexdump -C fashion.
0000000000000000000000000000000000000000;;	func (d *dumpState) dumpSlice(v reflect.Value) {
0000000000000000000000000000000000000000;;		// Determine whether this type should be hex dumped or not.  Also,
0000000000000000000000000000000000000000;;		// for types which should be hexdumped, try to use the underlying data
0000000000000000000000000000000000000000;;		// first, then fall back to trying to convert them to a uint8 slice.
0000000000000000000000000000000000000000;;		var buf []uint8
0000000000000000000000000000000000000000;;		doConvert := false
0000000000000000000000000000000000000000;;		doHexDump := false
0000000000000000000000000000000000000000;;		numEntries := v.Len()
0000000000000000000000000000000000000000;;		if numEntries > 0 {
0000000000000000000000000000000000000000;;			vt := v.Index(0).Type()
0000000000000000000000000000000000000000;;			vts := vt.String()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			// C types that need to be converted.
0000000000000000000000000000000000000000;;			case cCharRE.MatchString(vts):
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case cUnsignedCharRE.MatchString(vts):
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case cUint8tCharRE.MatchString(vts):
0000000000000000000000000000000000000000;;				doConvert = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Try to use existing uint8 slices and fall back to converting
0000000000000000000000000000000000000000;;			// and copying if that fails.
0000000000000000000000000000000000000000;;			case vt.Kind() == reflect.Uint8:
0000000000000000000000000000000000000000;;				// We need an addressable interface to convert the type
0000000000000000000000000000000000000000;;				// to a byte slice.  However, the reflect package won't
0000000000000000000000000000000000000000;;				// give us an interface on certain things like
0000000000000000000000000000000000000000;;				// unexported struct fields in order to enforce
0000000000000000000000000000000000000000;;				// visibility rules.  We use unsafe, when available, to
0000000000000000000000000000000000000000;;				// bypass these restrictions since this package does not
0000000000000000000000000000000000000000;;				// mutate the values.
0000000000000000000000000000000000000000;;				vs := v
0000000000000000000000000000000000000000;;				if !vs.CanInterface() || !vs.CanAddr() {
0000000000000000000000000000000000000000;;					vs = unsafeReflectValue(vs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !UnsafeDisabled {
0000000000000000000000000000000000000000;;					vs = vs.Slice(0, numEntries)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Use the existing uint8 slice if it can be
0000000000000000000000000000000000000000;;					// type asserted.
0000000000000000000000000000000000000000;;					iface := vs.Interface()
0000000000000000000000000000000000000000;;					if slice, ok := iface.([]uint8); ok {
0000000000000000000000000000000000000000;;						buf = slice
0000000000000000000000000000000000000000;;						doHexDump = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// The underlying data needs to be converted if it can't
0000000000000000000000000000000000000000;;				// be type asserted to a uint8 slice.
0000000000000000000000000000000000000000;;				doConvert = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Copy and convert the underlying type if needed.
0000000000000000000000000000000000000000;;			if doConvert && vt.ConvertibleTo(uint8Type) {
0000000000000000000000000000000000000000;;				// Convert and copy each element into a uint8 byte
0000000000000000000000000000000000000000;;				// slice.
0000000000000000000000000000000000000000;;				buf = make([]uint8, numEntries)
0000000000000000000000000000000000000000;;				for i := 0; i < numEntries; i++ {
0000000000000000000000000000000000000000;;					vv := v.Index(i)
0000000000000000000000000000000000000000;;					buf[i] = uint8(vv.Convert(uint8Type).Uint())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				doHexDump = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Hexdump the entire slice as needed.
0000000000000000000000000000000000000000;;		if doHexDump {
0000000000000000000000000000000000000000;;			indent := strings.Repeat(d.cs.Indent, d.depth)
0000000000000000000000000000000000000000;;			str := indent + hex.Dump(buf)
0000000000000000000000000000000000000000;;			str = strings.Replace(str, "\n", "\n"+indent, -1)
0000000000000000000000000000000000000000;;			str = strings.TrimRight(str, d.cs.Indent)
0000000000000000000000000000000000000000;;			d.w.Write([]byte(str))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively call dump for each item.
0000000000000000000000000000000000000000;;		for i := 0; i < numEntries; i++ {
0000000000000000000000000000000000000000;;			d.dump(d.unpackValue(v.Index(i)))
0000000000000000000000000000000000000000;;			if i < (numEntries - 1) {
0000000000000000000000000000000000000000;;				d.w.Write(commaNewlineBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.w.Write(newlineBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dump is the main workhorse for dumping a value.  It uses the passed reflect
0000000000000000000000000000000000000000;;	// value to figure out what kind of object we are dealing with and formats it
0000000000000000000000000000000000000000;;	// appropriately.  It is a recursive function, however circular data structures
0000000000000000000000000000000000000000;;	// are detected and handled properly.
0000000000000000000000000000000000000000;;	func (d *dumpState) dump(v reflect.Value) {
0000000000000000000000000000000000000000;;		// Handle invalid reflect values immediately.
0000000000000000000000000000000000000000;;		kind := v.Kind()
0000000000000000000000000000000000000000;;		if kind == reflect.Invalid {
0000000000000000000000000000000000000000;;			d.w.Write(invalidAngleBytes)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle pointers specially.
0000000000000000000000000000000000000000;;		if kind == reflect.Ptr {
0000000000000000000000000000000000000000;;			d.indent()
0000000000000000000000000000000000000000;;			d.dumpPtr(v)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Print type information unless already handled elsewhere.
0000000000000000000000000000000000000000;;		if !d.ignoreNextType {
0000000000000000000000000000000000000000;;			d.indent()
0000000000000000000000000000000000000000;;			d.w.Write(openParenBytes)
0000000000000000000000000000000000000000;;			d.w.Write([]byte(v.Type().String()))
0000000000000000000000000000000000000000;;			d.w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;			d.w.Write(spaceBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.ignoreNextType = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Display length and capacity if the built-in len and cap functions
0000000000000000000000000000000000000000;;		// work with the value's kind and the len/cap itself is non-zero.
0000000000000000000000000000000000000000;;		valueLen, valueCap := 0, 0
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Slice, reflect.Chan:
0000000000000000000000000000000000000000;;			valueLen, valueCap = v.Len(), v.Cap()
0000000000000000000000000000000000000000;;		case reflect.Map, reflect.String:
0000000000000000000000000000000000000000;;			valueLen = v.Len()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if valueLen != 0 || valueCap != 0 {
0000000000000000000000000000000000000000;;			d.w.Write(openParenBytes)
0000000000000000000000000000000000000000;;			if valueLen != 0 {
0000000000000000000000000000000000000000;;				d.w.Write(lenEqualsBytes)
0000000000000000000000000000000000000000;;				printInt(d.w, int64(valueLen), 10)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if valueCap != 0 {
0000000000000000000000000000000000000000;;				if valueLen != 0 {
0000000000000000000000000000000000000000;;					d.w.Write(spaceBytes)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				d.w.Write(capEqualsBytes)
0000000000000000000000000000000000000000;;				printInt(d.w, int64(valueCap), 10)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.w.Write(closeParenBytes)
0000000000000000000000000000000000000000;;			d.w.Write(spaceBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Call Stringer/error interfaces if they exist and the handle methods flag
0000000000000000000000000000000000000000;;		// is enabled
0000000000000000000000000000000000000000;;		if !d.cs.DisableMethods {
0000000000000000000000000000000000000000;;			if (kind != reflect.Invalid) && (kind != reflect.Interface) {
0000000000000000000000000000000000000000;;				if handled := handleMethods(d.cs, d.w, v); handled {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;		case reflect.Invalid:
0000000000000000000000000000000000000000;;			// Do nothing.  We should never get here since invalid has already
0000000000000000000000000000000000000000;;			// been handled above.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			printBool(d.w, v.Bool())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Int:
0000000000000000000000000000000000000000;;			printInt(d.w, v.Int(), 10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uint:
0000000000000000000000000000000000000000;;			printUint(d.w, v.Uint(), 10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			printFloat(d.w, v.Float(), 32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			printFloat(d.w, v.Float(), 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Complex64:
0000000000000000000000000000000000000000;;			printComplex(d.w, v.Complex(), 32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Complex128:
0000000000000000000000000000000000000000;;			printComplex(d.w, v.Complex(), 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				d.w.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			d.w.Write(openBraceNewlineBytes)
0000000000000000000000000000000000000000;;			d.depth++
0000000000000000000000000000000000000000;;			if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
0000000000000000000000000000000000000000;;				d.indent()
0000000000000000000000000000000000000000;;				d.w.Write(maxNewlineBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				d.dumpSlice(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.depth--
0000000000000000000000000000000000000000;;			d.indent()
0000000000000000000000000000000000000000;;			d.w.Write(closeBraceBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			d.w.Write([]byte(strconv.Quote(v.String())))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// The only time we should get here is for nil interfaces due to
0000000000000000000000000000000000000000;;			// unpackValue calls.
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				d.w.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			// Do nothing.  We should never get here since pointers have already
0000000000000000000000000000000000000000;;			// been handled above.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			// nil maps should be indicated as different than empty maps
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				d.w.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			d.w.Write(openBraceNewlineBytes)
0000000000000000000000000000000000000000;;			d.depth++
0000000000000000000000000000000000000000;;			if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
0000000000000000000000000000000000000000;;				d.indent()
0000000000000000000000000000000000000000;;				d.w.Write(maxNewlineBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				numEntries := v.Len()
0000000000000000000000000000000000000000;;				keys := v.MapKeys()
0000000000000000000000000000000000000000;;				if d.cs.SortKeys {
0000000000000000000000000000000000000000;;					sortValues(keys, d.cs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i, key := range keys {
0000000000000000000000000000000000000000;;					d.dump(d.unpackValue(key))
0000000000000000000000000000000000000000;;					d.w.Write(colonSpaceBytes)
0000000000000000000000000000000000000000;;					d.ignoreNextIndent = true
0000000000000000000000000000000000000000;;					d.dump(d.unpackValue(v.MapIndex(key)))
0000000000000000000000000000000000000000;;					if i < (numEntries - 1) {
0000000000000000000000000000000000000000;;						d.w.Write(commaNewlineBytes)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						d.w.Write(newlineBytes)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.depth--
0000000000000000000000000000000000000000;;			d.indent()
0000000000000000000000000000000000000000;;			d.w.Write(closeBraceBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			d.w.Write(openBraceNewlineBytes)
0000000000000000000000000000000000000000;;			d.depth++
0000000000000000000000000000000000000000;;			if (d.cs.MaxDepth != 0) && (d.depth > d.cs.MaxDepth) {
0000000000000000000000000000000000000000;;				d.indent()
0000000000000000000000000000000000000000;;				d.w.Write(maxNewlineBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				vt := v.Type()
0000000000000000000000000000000000000000;;				numFields := v.NumField()
0000000000000000000000000000000000000000;;				for i := 0; i < numFields; i++ {
0000000000000000000000000000000000000000;;					d.indent()
0000000000000000000000000000000000000000;;					vtf := vt.Field(i)
0000000000000000000000000000000000000000;;					d.w.Write([]byte(vtf.Name))
0000000000000000000000000000000000000000;;					d.w.Write(colonSpaceBytes)
0000000000000000000000000000000000000000;;					d.ignoreNextIndent = true
0000000000000000000000000000000000000000;;					d.dump(d.unpackValue(v.Field(i)))
0000000000000000000000000000000000000000;;					if i < (numFields - 1) {
0000000000000000000000000000000000000000;;						d.w.Write(commaNewlineBytes)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						d.w.Write(newlineBytes)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.depth--
0000000000000000000000000000000000000000;;			d.indent()
0000000000000000000000000000000000000000;;			d.w.Write(closeBraceBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Uintptr:
0000000000000000000000000000000000000000;;			printHexPtr(d.w, uintptr(v.Uint()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.UnsafePointer, reflect.Chan, reflect.Func:
0000000000000000000000000000000000000000;;			printHexPtr(d.w, v.Pointer())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There were not any other types at the time this code was written, but
0000000000000000000000000000000000000000;;		// fall back to letting the default fmt package handle it in case any new
0000000000000000000000000000000000000000;;		// types are added.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if v.CanInterface() {
0000000000000000000000000000000000000000;;				fmt.Fprintf(d.w, "%v", v.Interface())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				fmt.Fprintf(d.w, "%v", v.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fdump is a helper function to consolidate the logic from the various public
0000000000000000000000000000000000000000;;	// methods which take varying writers and config states.
0000000000000000000000000000000000000000;;	func fdump(cs *ConfigState, w io.Writer, a ...interface{}) {
0000000000000000000000000000000000000000;;		for _, arg := range a {
0000000000000000000000000000000000000000;;			if arg == nil {
0000000000000000000000000000000000000000;;				w.Write(interfaceBytes)
0000000000000000000000000000000000000000;;				w.Write(spaceBytes)
0000000000000000000000000000000000000000;;				w.Write(nilAngleBytes)
0000000000000000000000000000000000000000;;				w.Write(newlineBytes)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			d := dumpState{w: w, cs: cs}
0000000000000000000000000000000000000000;;			d.pointers = make(map[uintptr]int)
0000000000000000000000000000000000000000;;			d.dump(reflect.ValueOf(arg))
0000000000000000000000000000000000000000;;			d.w.Write(newlineBytes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fdump formats and displays the passed arguments to io.Writer w.  It formats
0000000000000000000000000000000000000000;;	// exactly the same as Dump.
0000000000000000000000000000000000000000;;	func Fdump(w io.Writer, a ...interface{}) {
0000000000000000000000000000000000000000;;		fdump(&Config, w, a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sdump returns a string with the passed arguments formatted exactly the same
0000000000000000000000000000000000000000;;	// as Dump.
0000000000000000000000000000000000000000;;	func Sdump(a ...interface{}) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		fdump(&Config, &buf, a...)
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Dump displays the passed parameters to standard out with newlines, customizable
0000000000000000000000000000000000000000;;	indentation, and additional debug information such as complete types and all
0000000000000000000000000000000000000000;;	pointer addresses used to indirect to the final value.  It provides the
0000000000000000000000000000000000000000;;	following features over the built-in printing facilities provided by the fmt
0000000000000000000000000000000000000000;;	package:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* Pointers are dereferenced and followed
0000000000000000000000000000000000000000;;		* Circular data structures are detected and handled properly
0000000000000000000000000000000000000000;;		* Custom Stringer/error interfaces are optionally invoked, including
0000000000000000000000000000000000000000;;		  on unexported types
0000000000000000000000000000000000000000;;		* Custom types which only implement the Stringer/error interfaces via
0000000000000000000000000000000000000000;;		  a pointer receiver are optionally invoked when passing non-pointer
0000000000000000000000000000000000000000;;		  variables
0000000000000000000000000000000000000000;;		* Byte arrays and slices are dumped like the hexdump -C command which
0000000000000000000000000000000000000000;;		  includes offsets, byte values in hex, and ASCII output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The configuration options are controlled by an exported package global,
0000000000000000000000000000000000000000;;	spew.Config.  See ConfigState for options documentation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See Fdump if you would prefer dumping to an arbitrary io.Writer or Sdump to
0000000000000000000000000000000000000000;;	get the formatted result as a string.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func Dump(a ...interface{}) {
0000000000000000000000000000000000000000;;		fdump(&Config, os.Stdout, a...)
0000000000000000000000000000000000000000;;	}
