0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * Copyright (c) 2013 Dave Collins <dave@davec.name>
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * Permission to use, copy, modify, and distribute this software for any
0000000000000000000000000000000000000000;;	 * purpose with or without fee is hereby granted, provided that the above
0000000000000000000000000000000000000000;;	 * copyright notice and this permission notice appear in all copies.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
0000000000000000000000000000000000000000;;	 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
0000000000000000000000000000000000000000;;	 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
0000000000000000000000000000000000000000;;	 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
0000000000000000000000000000000000000000;;	 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
0000000000000000000000000000000000000000;;	 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
0000000000000000000000000000000000000000;;	 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
0000000000000000000000000000000000000000;;	 */
5187a61b412c69823a116353fb1601738e904060;Godeps/_workspace/src/github.com/davecgh/go-spew/spew/doc.go[Godeps/_workspace/src/github.com/davecgh/go-spew/spew/doc.go][vendor/github.com/davecgh/go-spew/spew/doc.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package spew implements a deep pretty printer for Go data structures to aid in
0000000000000000000000000000000000000000;;	debugging.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A quick overview of the additional features spew provides over the built-in
0000000000000000000000000000000000000000;;	printing facilities for Go data types are as follows:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* Pointers are dereferenced and followed
0000000000000000000000000000000000000000;;		* Circular data structures are detected and handled properly
0000000000000000000000000000000000000000;;		* Custom Stringer/error interfaces are optionally invoked, including
0000000000000000000000000000000000000000;;		  on unexported types
0000000000000000000000000000000000000000;;		* Custom types which only implement the Stringer/error interfaces via
0000000000000000000000000000000000000000;;		  a pointer receiver are optionally invoked when passing non-pointer
0000000000000000000000000000000000000000;;		  variables
0000000000000000000000000000000000000000;;		* Byte arrays and slices are dumped like the hexdump -C command which
0000000000000000000000000000000000000000;;		  includes offsets, byte values in hex, and ASCII output (only when using
0000000000000000000000000000000000000000;;		  Dump style)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are two different approaches spew allows for dumping Go data structures:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* Dump style which prints with newlines, customizable indentation,
0000000000000000000000000000000000000000;;		  and additional debug information such as types and all pointer addresses
0000000000000000000000000000000000000000;;		  used to indirect to the final value
0000000000000000000000000000000000000000;;		* A custom Formatter interface that integrates cleanly with the standard fmt
0000000000000000000000000000000000000000;;		  package and replaces %v, %+v, %#v, and %#+v to provide inline printing
0000000000000000000000000000000000000000;;		  similar to the default %v while providing the additional functionality
0000000000000000000000000000000000000000;;		  outlined above and passing unsupported format verbs such as %x and %q
0000000000000000000000000000000000000000;;		  along to fmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Quick Start
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This section demonstrates how to quickly get started with spew.  See the
0000000000000000000000000000000000000000;;	sections below for further details on formatting and configuration options.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To dump a variable with full newlines, indentation, type, and pointer
0000000000000000000000000000000000000000;;	information use Dump, Fdump, or Sdump:
0000000000000000000000000000000000000000;;		spew.Dump(myVar1, myVar2, ...)
0000000000000000000000000000000000000000;;		spew.Fdump(someWriter, myVar1, myVar2, ...)
0000000000000000000000000000000000000000;;		str := spew.Sdump(myVar1, myVar2, ...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Alternatively, if you would prefer to use format strings with a compacted inline
0000000000000000000000000000000000000000;;	printing style, use the convenience wrappers Printf, Fprintf, etc with
0000000000000000000000000000000000000000;;	%v (most compact), %+v (adds pointer addresses), %#v (adds types), or
0000000000000000000000000000000000000000;;	%#+v (adds types and pointer addresses):
0000000000000000000000000000000000000000;;		spew.Printf("myVar1: %v -- myVar2: %+v", myVar1, myVar2)
0000000000000000000000000000000000000000;;		spew.Printf("myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
0000000000000000000000000000000000000000;;		spew.Fprintf(someWriter, "myVar1: %v -- myVar2: %+v", myVar1, myVar2)
0000000000000000000000000000000000000000;;		spew.Fprintf(someWriter, "myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Configuration Options
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Configuration of spew is handled by fields in the ConfigState type.  For
0000000000000000000000000000000000000000;;	convenience, all of the top-level functions use a global state available
0000000000000000000000000000000000000000;;	via the spew.Config global.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It is also possible to create a ConfigState instance that provides methods
0000000000000000000000000000000000000000;;	equivalent to the top-level functions.  This allows concurrent configuration
0000000000000000000000000000000000000000;;	options.  See the ConfigState documentation for more details.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following configuration options are available:
0000000000000000000000000000000000000000;;		* Indent
0000000000000000000000000000000000000000;;			String to use for each indentation level for Dump functions.
0000000000000000000000000000000000000000;;			It is a single space by default.  A popular alternative is "\t".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* MaxDepth
0000000000000000000000000000000000000000;;			Maximum number of levels to descend into nested data structures.
0000000000000000000000000000000000000000;;			There is no limit by default.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* DisableMethods
0000000000000000000000000000000000000000;;			Disables invocation of error and Stringer interface methods.
0000000000000000000000000000000000000000;;			Method invocation is enabled by default.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* DisablePointerMethods
0000000000000000000000000000000000000000;;			Disables invocation of error and Stringer interface methods on types
0000000000000000000000000000000000000000;;			which only accept pointer receivers from non-pointer variables.
0000000000000000000000000000000000000000;;			Pointer method invocation is enabled by default.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* ContinueOnMethod
0000000000000000000000000000000000000000;;			Enables recursion into types after invoking error and Stringer interface
0000000000000000000000000000000000000000;;			methods. Recursion after method invocation is disabled by default.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* SortKeys
0000000000000000000000000000000000000000;;			Specifies map keys should be sorted before being printed. Use
0000000000000000000000000000000000000000;;			this to have a more deterministic, diffable output.  Note that
0000000000000000000000000000000000000000;;			only native types (bool, int, uint, floats, uintptr and string)
0000000000000000000000000000000000000000;;			and types which implement error or Stringer interfaces are
0000000000000000000000000000000000000000;;			supported with other types sorted according to the
0000000000000000000000000000000000000000;;			reflect.Value.String() output which guarantees display
0000000000000000000000000000000000000000;;			stability.  Natural map order is used by default.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* SpewKeys
0000000000000000000000000000000000000000;;			Specifies that, as a last resort attempt, map keys should be
0000000000000000000000000000000000000000;;			spewed to strings and sorted by those strings.  This is only
0000000000000000000000000000000000000000;;			considered if SortKeys is true.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Dump Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Simply call spew.Dump with a list of variables you want to dump:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spew.Dump(myVar1, myVar2, ...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You may also call spew.Fdump if you would prefer to output to an arbitrary
0000000000000000000000000000000000000000;;	io.Writer.  For example, to dump to standard error:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spew.Fdump(os.Stderr, myVar1, myVar2, ...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A third option is to call spew.Sdump to get the formatted output as a string:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		str := spew.Sdump(myVar1, myVar2, ...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Sample Dump Output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the Dump example for details on the setup of the types and variables being
0000000000000000000000000000000000000000;;	shown here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		(main.Foo) {
0000000000000000000000000000000000000000;;		 unexportedField: (*main.Bar)(0xf84002e210)({
0000000000000000000000000000000000000000;;		  flag: (main.Flag) flagTwo,
0000000000000000000000000000000000000000;;		  data: (uintptr) <nil>
0000000000000000000000000000000000000000;;		 }),
0000000000000000000000000000000000000000;;		 ExportedField: (map[interface {}]interface {}) (len=1) {
0000000000000000000000000000000000000000;;		  (string) (len=3) "one": (bool) true
0000000000000000000000000000000000000000;;		 }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Byte (and uint8) arrays and slices are displayed uniquely like the hexdump -C
0000000000000000000000000000000000000000;;	command as shown.
0000000000000000000000000000000000000000;;		([]uint8) (len=32 cap=32) {
0000000000000000000000000000000000000000;;		 00000000  11 12 13 14 15 16 17 18  19 1a 1b 1c 1d 1e 1f 20  |............... |
0000000000000000000000000000000000000000;;		 00000010  21 22 23 24 25 26 27 28  29 2a 2b 2c 2d 2e 2f 30  |!"#$%&'()*+,-./0|
0000000000000000000000000000000000000000;;		 00000020  31 32                                             |12|
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Custom Formatter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Spew provides a custom formatter that implements the fmt.Formatter interface
0000000000000000000000000000000000000000;;	so that it integrates cleanly with standard fmt package printing functions. The
0000000000000000000000000000000000000000;;	formatter is useful for inline printing of smaller data types similar to the
0000000000000000000000000000000000000000;;	standard %v format specifier.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The custom formatter only responds to the %v (most compact), %+v (adds pointer
0000000000000000000000000000000000000000;;	addresses), %#v (adds types), or %#+v (adds types and pointer addresses) verb
0000000000000000000000000000000000000000;;	combinations.  Any other verbs such as %x and %q will be sent to the the
0000000000000000000000000000000000000000;;	standard fmt package for formatting.  In addition, the custom formatter ignores
0000000000000000000000000000000000000000;;	the width and precision arguments (however they will still work on the format
0000000000000000000000000000000000000000;;	specifiers not handled by the custom formatter).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Custom Formatter Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The simplest way to make use of the spew custom formatter is to call one of the
0000000000000000000000000000000000000000;;	convenience functions such as spew.Printf, spew.Println, or spew.Printf.  The
0000000000000000000000000000000000000000;;	functions have syntax you are most likely already familiar with:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spew.Printf("myVar1: %v -- myVar2: %+v", myVar1, myVar2)
0000000000000000000000000000000000000000;;		spew.Printf("myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
0000000000000000000000000000000000000000;;		spew.Println(myVar, myVar2)
0000000000000000000000000000000000000000;;		spew.Fprintf(os.Stderr, "myVar1: %v -- myVar2: %+v", myVar1, myVar2)
0000000000000000000000000000000000000000;;		spew.Fprintf(os.Stderr, "myVar3: %#v -- myVar4: %#+v", myVar3, myVar4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the Index for the full list convenience functions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Sample Formatter Output
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Double pointer to a uint8:
0000000000000000000000000000000000000000;;		  %v: <**>5
0000000000000000000000000000000000000000;;		 %+v: <**>(0xf8400420d0->0xf8400420c8)5
0000000000000000000000000000000000000000;;		 %#v: (**uint8)5
0000000000000000000000000000000000000000;;		%#+v: (**uint8)(0xf8400420d0->0xf8400420c8)5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Pointer to circular struct with a uint8 field and a pointer to itself:
0000000000000000000000000000000000000000;;		  %v: <*>{1 <*><shown>}
0000000000000000000000000000000000000000;;		 %+v: <*>(0xf84003e260){ui8:1 c:<*>(0xf84003e260)<shown>}
0000000000000000000000000000000000000000;;		 %#v: (*main.circular){ui8:(uint8)1 c:(*main.circular)<shown>}
0000000000000000000000000000000000000000;;		%#+v: (*main.circular)(0xf84003e260){ui8:(uint8)1 c:(*main.circular)(0xf84003e260)<shown>}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See the Printf example for details on the setup of variables being shown
0000000000000000000000000000000000000000;;	here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Errors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Since it is possible for custom Stringer/error interfaces to panic, spew
0000000000000000000000000000000000000000;;	detects them and handles them internally by printing the panic information
0000000000000000000000000000000000000000;;	inline with the output.  Since spew is intended to provide deep pretty printing
0000000000000000000000000000000000000000;;	capabilities on structures, it intentionally does not return any errors.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package spew
