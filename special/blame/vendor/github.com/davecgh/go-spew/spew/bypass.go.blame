0000000000000000000000000000000000000000;;	// Copyright (c) 2015 Dave Collins <dave@davec.name>
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Permission to use, copy, modify, and distribute this software for any
0000000000000000000000000000000000000000;;	// purpose with or without fee is hereby granted, provided that the above
0000000000000000000000000000000000000000;;	// copyright notice and this permission notice appear in all copies.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
0000000000000000000000000000000000000000;;	// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
0000000000000000000000000000000000000000;;	// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
0000000000000000000000000000000000000000;;	// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
0000000000000000000000000000000000000000;;	// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
0000000000000000000000000000000000000000;;	// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
0000000000000000000000000000000000000000;;	// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
6af08453350e05288507a4858e00b072d7113fde;Godeps/_workspace/src/github.com/davecgh/go-spew/spew/bypass.go[Godeps/_workspace/src/github.com/davecgh/go-spew/spew/bypass.go][vendor/github.com/davecgh/go-spew/spew/bypass.go];	
0000000000000000000000000000000000000000;;	// NOTE: Due to the following build constraints, this file will only be compiled
0000000000000000000000000000000000000000;;	// when the code is not running on Google App Engine and "-tags disableunsafe"
0000000000000000000000000000000000000000;;	// is not added to the go build command line.
0000000000000000000000000000000000000000;;	// +build !appengine,!disableunsafe
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package spew
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// UnsafeDisabled is a build-time constant which specifies whether or
0000000000000000000000000000000000000000;;		// not access to the unsafe package is available.
0000000000000000000000000000000000000000;;		UnsafeDisabled = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ptrSize is the size of a pointer on the current arch.
0000000000000000000000000000000000000000;;		ptrSize = unsafe.Sizeof((*byte)(nil))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// offsetPtr, offsetScalar, and offsetFlag are the offsets for the
0000000000000000000000000000000000000000;;		// internal reflect.Value fields.  These values are valid before golang
0000000000000000000000000000000000000000;;		// commit ecccf07e7f9d which changed the format.  The are also valid
0000000000000000000000000000000000000000;;		// after commit 82f48826c6c7 which changed the format again to mirror
0000000000000000000000000000000000000000;;		// the original format.  Code in the init function updates these offsets
0000000000000000000000000000000000000000;;		// as necessary.
0000000000000000000000000000000000000000;;		offsetPtr    = uintptr(ptrSize)
0000000000000000000000000000000000000000;;		offsetScalar = uintptr(0)
0000000000000000000000000000000000000000;;		offsetFlag   = uintptr(ptrSize * 2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// flagKindWidth and flagKindShift indicate various bits that the
0000000000000000000000000000000000000000;;		// reflect package uses internally to track kind information.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// flagRO indicates whether or not the value field of a reflect.Value is
0000000000000000000000000000000000000000;;		// read-only.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// flagIndir indicates whether the value field of a reflect.Value is
0000000000000000000000000000000000000000;;		// the actual data or a pointer to the data.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// These values are valid before golang commit 90a7c3c86944 which
0000000000000000000000000000000000000000;;		// changed their positions.  Code in the init function updates these
0000000000000000000000000000000000000000;;		// flags as necessary.
0000000000000000000000000000000000000000;;		flagKindWidth = uintptr(5)
0000000000000000000000000000000000000000;;		flagKindShift = uintptr(flagKindWidth - 1)
0000000000000000000000000000000000000000;;		flagRO        = uintptr(1 << 0)
0000000000000000000000000000000000000000;;		flagIndir     = uintptr(1 << 1)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Older versions of reflect.Value stored small integers directly in the
0000000000000000000000000000000000000000;;		// ptr field (which is named val in the older versions).  Versions
0000000000000000000000000000000000000000;;		// between commits ecccf07e7f9d and 82f48826c6c7 added a new field named
0000000000000000000000000000000000000000;;		// scalar for this purpose which unfortunately came before the flag
0000000000000000000000000000000000000000;;		// field, so the offset of the flag field is different for those
0000000000000000000000000000000000000000;;		// versions.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This code constructs a new reflect.Value from a known small integer
0000000000000000000000000000000000000000;;		// and checks if the size of the reflect.Value struct indicates it has
0000000000000000000000000000000000000000;;		// the scalar field. When it does, the offsets are updated accordingly.
0000000000000000000000000000000000000000;;		vv := reflect.ValueOf(0xf00)
0000000000000000000000000000000000000000;;		if unsafe.Sizeof(vv) == (ptrSize * 4) {
0000000000000000000000000000000000000000;;			offsetScalar = ptrSize * 2
0000000000000000000000000000000000000000;;			offsetFlag = ptrSize * 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Commit 90a7c3c86944 changed the flag positions such that the low
0000000000000000000000000000000000000000;;		// order bits are the kind.  This code extracts the kind from the flags
0000000000000000000000000000000000000000;;		// field and ensures it's the correct type.  When it's not, the flag
0000000000000000000000000000000000000000;;		// order has been changed to the newer format, so the flags are updated
0000000000000000000000000000000000000000;;		// accordingly.
0000000000000000000000000000000000000000;;		upf := unsafe.Pointer(uintptr(unsafe.Pointer(&vv)) + offsetFlag)
0000000000000000000000000000000000000000;;		upfv := *(*uintptr)(upf)
0000000000000000000000000000000000000000;;		flagKindMask := uintptr((1<<flagKindWidth - 1) << flagKindShift)
0000000000000000000000000000000000000000;;		if (upfv&flagKindMask)>>flagKindShift != uintptr(reflect.Int) {
0000000000000000000000000000000000000000;;			flagKindShift = 0
0000000000000000000000000000000000000000;;			flagRO = 1 << 5
0000000000000000000000000000000000000000;;			flagIndir = 1 << 6
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Commit adf9b30e5594 modified the flags to separate the
0000000000000000000000000000000000000000;;			// flagRO flag into two bits which specifies whether or not the
0000000000000000000000000000000000000000;;			// field is embedded.  This causes flagIndir to move over a bit
0000000000000000000000000000000000000000;;			// and means that flagRO is the combination of either of the
0000000000000000000000000000000000000000;;			// original flagRO bit and the new bit.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// This code detects the change by extracting what used to be
0000000000000000000000000000000000000000;;			// the indirect bit to ensure it's set.  When it's not, the flag
0000000000000000000000000000000000000000;;			// order has been changed to the newer format, so the flags are
0000000000000000000000000000000000000000;;			// updated accordingly.
0000000000000000000000000000000000000000;;			if upfv&flagIndir == 0 {
0000000000000000000000000000000000000000;;				flagRO = 3 << 5
0000000000000000000000000000000000000000;;				flagIndir = 1 << 7
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unsafeReflectValue converts the passed reflect.Value into a one that bypasses
0000000000000000000000000000000000000000;;	// the typical safety restrictions preventing access to unaddressable and
0000000000000000000000000000000000000000;;	// unexported data.  It works by digging the raw pointer to the underlying
0000000000000000000000000000000000000000;;	// value out of the protected value and generating a new unprotected (unsafe)
0000000000000000000000000000000000000000;;	// reflect.Value to it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This allows us to check for implementations of the Stringer and error
0000000000000000000000000000000000000000;;	// interfaces to be used for pretty printing ordinarily unaddressable and
0000000000000000000000000000000000000000;;	// inaccessible values such as unexported struct fields.
0000000000000000000000000000000000000000;;	func unsafeReflectValue(v reflect.Value) (rv reflect.Value) {
0000000000000000000000000000000000000000;;		indirects := 1
0000000000000000000000000000000000000000;;		vt := v.Type()
0000000000000000000000000000000000000000;;		upv := unsafe.Pointer(uintptr(unsafe.Pointer(&v)) + offsetPtr)
0000000000000000000000000000000000000000;;		rvf := *(*uintptr)(unsafe.Pointer(uintptr(unsafe.Pointer(&v)) + offsetFlag))
0000000000000000000000000000000000000000;;		if rvf&flagIndir != 0 {
0000000000000000000000000000000000000000;;			vt = reflect.PtrTo(v.Type())
0000000000000000000000000000000000000000;;			indirects++
0000000000000000000000000000000000000000;;		} else if offsetScalar != 0 {
0000000000000000000000000000000000000000;;			// The value is in the scalar field when it's not one of the
0000000000000000000000000000000000000000;;			// reference types.
0000000000000000000000000000000000000000;;			switch vt.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Uintptr:
0000000000000000000000000000000000000000;;			case reflect.Chan:
0000000000000000000000000000000000000000;;			case reflect.Func:
0000000000000000000000000000000000000000;;			case reflect.Map:
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;			case reflect.UnsafePointer:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				upv = unsafe.Pointer(uintptr(unsafe.Pointer(&v)) +
0000000000000000000000000000000000000000;;					offsetScalar)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pv := reflect.NewAt(vt, upv)
0000000000000000000000000000000000000000;;		rv = pv
0000000000000000000000000000000000000000;;		for i := 0; i < indirects; i++ {
0000000000000000000000000000000000000000;;			rv = rv.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rv
0000000000000000000000000000000000000000;;	}
