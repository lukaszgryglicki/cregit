0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/db.go[Godeps/_workspace/src/github.com/boltdb/bolt/db.go][vendor/github.com/boltdb/bolt/db.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"runtime/debug"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The largest step that can be taken when remapping the mmap.
0000000000000000000000000000000000000000;;	const maxMmapStep = 1 << 30 // 1GB
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The data file format version.
0000000000000000000000000000000000000000;;	const version = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Represents a marker value to indicate that a file is a Bolt DB.
0000000000000000000000000000000000000000;;	const magic uint32 = 0xED0CDAED
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IgnoreNoSync specifies whether the NoSync field of a DB is ignored when
0000000000000000000000000000000000000000;;	// syncing changes to a file.  This is required as some operating systems,
0000000000000000000000000000000000000000;;	// such as OpenBSD, do not have a unified buffer cache (UBC) and writes
0000000000000000000000000000000000000000;;	// must be synchronized using the msync(2) syscall.
0000000000000000000000000000000000000000;;	const IgnoreNoSync = runtime.GOOS == "openbsd"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Default values if not set in a DB instance.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultMaxBatchSize  int = 1000
0000000000000000000000000000000000000000;;		DefaultMaxBatchDelay     = 10 * time.Millisecond
0000000000000000000000000000000000000000;;		DefaultAllocSize         = 16 * 1024 * 1024
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// default page size for db is set to the OS page size.
0000000000000000000000000000000000000000;;	var defaultPageSize = os.Getpagesize()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DB represents a collection of buckets persisted to a file on disk.
0000000000000000000000000000000000000000;;	// All data access is performed through transactions which can be obtained through the DB.
0000000000000000000000000000000000000000;;	// All the functions on DB will return a ErrDatabaseNotOpen if accessed before Open() is called.
0000000000000000000000000000000000000000;;	type DB struct {
0000000000000000000000000000000000000000;;		// When enabled, the database will perform a Check() after every commit.
0000000000000000000000000000000000000000;;		// A panic is issued if the database is in an inconsistent state. This
0000000000000000000000000000000000000000;;		// flag has a large performance impact so it should only be used for
0000000000000000000000000000000000000000;;		// debugging purposes.
0000000000000000000000000000000000000000;;		StrictMode bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setting the NoSync flag will cause the database to skip fsync()
0000000000000000000000000000000000000000;;		// calls after each commit. This can be useful when bulk loading data
0000000000000000000000000000000000000000;;		// into a database and you can restart the bulk load in the event of
0000000000000000000000000000000000000000;;		// a system failure or database corruption. Do not set this flag for
0000000000000000000000000000000000000000;;		// normal use.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If the package global IgnoreNoSync constant is true, this value is
0000000000000000000000000000000000000000;;		// ignored.  See the comment on that constant for more details.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// THIS IS UNSAFE. PLEASE USE WITH CAUTION.
0000000000000000000000000000000000000000;;		NoSync bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When true, skips the truncate call when growing the database.
0000000000000000000000000000000000000000;;		// Setting this to true is only safe on non-ext3/ext4 systems.
0000000000000000000000000000000000000000;;		// Skipping truncation avoids preallocation of hard drive space and
0000000000000000000000000000000000000000;;		// bypasses a truncate() and fsync() syscall on remapping.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// https://github.com/boltdb/bolt/issues/284
0000000000000000000000000000000000000000;;		NoGrowSync bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If you want to read the entire database fast, you can set MmapFlag to
0000000000000000000000000000000000000000;;		// syscall.MAP_POPULATE on Linux 2.6.23+ for sequential read-ahead.
0000000000000000000000000000000000000000;;		MmapFlags int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxBatchSize is the maximum size of a batch. Default value is
0000000000000000000000000000000000000000;;		// copied from DefaultMaxBatchSize in Open.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If <=0, disables batching.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Do not change concurrently with calls to Batch.
0000000000000000000000000000000000000000;;		MaxBatchSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxBatchDelay is the maximum delay before a batch starts.
0000000000000000000000000000000000000000;;		// Default value is copied from DefaultMaxBatchDelay in Open.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If <=0, effectively disables batching.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Do not change concurrently with calls to Batch.
0000000000000000000000000000000000000000;;		MaxBatchDelay time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AllocSize is the amount of space allocated when the database
0000000000000000000000000000000000000000;;		// needs to create new pages. This is done to amortize the cost
0000000000000000000000000000000000000000;;		// of truncate() and fsync() when growing the data file.
0000000000000000000000000000000000000000;;		AllocSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path     string
0000000000000000000000000000000000000000;;		file     *os.File
0000000000000000000000000000000000000000;;		lockfile *os.File // windows only
0000000000000000000000000000000000000000;;		dataref  []byte   // mmap'ed readonly, write throws SEGV
0000000000000000000000000000000000000000;;		data     *[maxMapSize]byte
0000000000000000000000000000000000000000;;		datasz   int
0000000000000000000000000000000000000000;;		filesz   int // current on disk file size
0000000000000000000000000000000000000000;;		meta0    *meta
0000000000000000000000000000000000000000;;		meta1    *meta
0000000000000000000000000000000000000000;;		pageSize int
0000000000000000000000000000000000000000;;		opened   bool
0000000000000000000000000000000000000000;;		rwtx     *Tx
0000000000000000000000000000000000000000;;		txs      []*Tx
0000000000000000000000000000000000000000;;		freelist *freelist
0000000000000000000000000000000000000000;;		stats    Stats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pagePool sync.Pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		batchMu sync.Mutex
0000000000000000000000000000000000000000;;		batch   *batch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rwlock   sync.Mutex   // Allows only one writer at a time.
0000000000000000000000000000000000000000;;		metalock sync.Mutex   // Protects meta page access.
0000000000000000000000000000000000000000;;		mmaplock sync.RWMutex // Protects mmap access during remapping.
0000000000000000000000000000000000000000;;		statlock sync.RWMutex // Protects stats access.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ops struct {
0000000000000000000000000000000000000000;;			writeAt func(b []byte, off int64) (n int, err error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read only mode.
0000000000000000000000000000000000000000;;		// When true, Update() and Begin(true) return ErrDatabaseReadOnly immediately.
0000000000000000000000000000000000000000;;		readOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path returns the path to currently open database file.
0000000000000000000000000000000000000000;;	func (db *DB) Path() string {
0000000000000000000000000000000000000000;;		return db.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GoString returns the Go string representation of the database.
0000000000000000000000000000000000000000;;	func (db *DB) GoString() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("bolt.DB{path:%q}", db.path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation of the database.
0000000000000000000000000000000000000000;;	func (db *DB) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("DB<%q>", db.path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open creates and opens a database at the given path.
0000000000000000000000000000000000000000;;	// If the file does not exist then it will be created automatically.
0000000000000000000000000000000000000000;;	// Passing in nil options will cause Bolt to open the database with the default options.
0000000000000000000000000000000000000000;;	func Open(path string, mode os.FileMode, options *Options) (*DB, error) {
0000000000000000000000000000000000000000;;		var db = &DB{opened: true}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set default options if no options are provided.
0000000000000000000000000000000000000000;;		if options == nil {
0000000000000000000000000000000000000000;;			options = DefaultOptions
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		db.NoGrowSync = options.NoGrowSync
0000000000000000000000000000000000000000;;		db.MmapFlags = options.MmapFlags
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set default values for later DB operations.
0000000000000000000000000000000000000000;;		db.MaxBatchSize = DefaultMaxBatchSize
0000000000000000000000000000000000000000;;		db.MaxBatchDelay = DefaultMaxBatchDelay
0000000000000000000000000000000000000000;;		db.AllocSize = DefaultAllocSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		flag := os.O_RDWR
0000000000000000000000000000000000000000;;		if options.ReadOnly {
0000000000000000000000000000000000000000;;			flag = os.O_RDONLY
0000000000000000000000000000000000000000;;			db.readOnly = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Open data file and separate sync handler for metadata writes.
0000000000000000000000000000000000000000;;		db.path = path
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if db.file, err = os.OpenFile(db.path, flag|os.O_CREATE, mode); err != nil {
0000000000000000000000000000000000000000;;			_ = db.close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lock file so that other processes using Bolt in read-write mode cannot
0000000000000000000000000000000000000000;;		// use the database  at the same time. This would cause corruption since
0000000000000000000000000000000000000000;;		// the two processes would write meta pages and free pages separately.
0000000000000000000000000000000000000000;;		// The database file is locked exclusively (only one process can grab the lock)
0000000000000000000000000000000000000000;;		// if !options.ReadOnly.
0000000000000000000000000000000000000000;;		// The database file is locked using the shared lock (more than one process may
0000000000000000000000000000000000000000;;		// hold a lock at the same time) otherwise (options.ReadOnly is set).
0000000000000000000000000000000000000000;;		if err := flock(db, mode, !db.readOnly, options.Timeout); err != nil {
0000000000000000000000000000000000000000;;			_ = db.close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default values for test hooks
0000000000000000000000000000000000000000;;		db.ops.writeAt = db.file.WriteAt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize the database if it doesn't exist.
0000000000000000000000000000000000000000;;		if info, err := db.file.Stat(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if info.Size() == 0 {
0000000000000000000000000000000000000000;;			// Initialize new files with meta pages.
0000000000000000000000000000000000000000;;			if err := db.init(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Read the first meta page to determine the page size.
0000000000000000000000000000000000000000;;			var buf [0x1000]byte
0000000000000000000000000000000000000000;;			if _, err := db.file.ReadAt(buf[:], 0); err == nil {
0000000000000000000000000000000000000000;;				m := db.pageInBuffer(buf[:], 0).meta()
0000000000000000000000000000000000000000;;				if err := m.validate(); err != nil {
0000000000000000000000000000000000000000;;					// If we can't read the page size, we can assume it's the same
0000000000000000000000000000000000000000;;					// as the OS -- since that's how the page size was chosen in the
0000000000000000000000000000000000000000;;					// first place.
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// If the first page is invalid and this OS uses a different
0000000000000000000000000000000000000000;;					// page size than what the database was created with then we
0000000000000000000000000000000000000000;;					// are out of luck and cannot access the database.
0000000000000000000000000000000000000000;;					db.pageSize = os.Getpagesize()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					db.pageSize = int(m.pageSize)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize page pool.
0000000000000000000000000000000000000000;;		db.pagePool = sync.Pool{
0000000000000000000000000000000000000000;;			New: func() interface{} {
0000000000000000000000000000000000000000;;				return make([]byte, db.pageSize)
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Memory map the data file.
0000000000000000000000000000000000000000;;		if err := db.mmap(options.InitialMmapSize); err != nil {
0000000000000000000000000000000000000000;;			_ = db.close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read in the freelist.
0000000000000000000000000000000000000000;;		db.freelist = newFreelist()
0000000000000000000000000000000000000000;;		db.freelist.read(db.page(db.meta().freelist))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mark the database as opened and return.
0000000000000000000000000000000000000000;;		return db, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mmap opens the underlying memory-mapped file and initializes the meta references.
0000000000000000000000000000000000000000;;	// minsz is the minimum size that the new mmap can be.
0000000000000000000000000000000000000000;;	func (db *DB) mmap(minsz int) error {
0000000000000000000000000000000000000000;;		db.mmaplock.Lock()
0000000000000000000000000000000000000000;;		defer db.mmaplock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info, err := db.file.Stat()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("mmap stat error: %s", err)
0000000000000000000000000000000000000000;;		} else if int(info.Size()) < db.pageSize*2 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("file size too small")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure the size is at least the minimum size.
0000000000000000000000000000000000000000;;		var size = int(info.Size())
0000000000000000000000000000000000000000;;		if size < minsz {
0000000000000000000000000000000000000000;;			size = minsz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		size, err = db.mmapSize(size)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Dereference all mmap references before unmapping.
0000000000000000000000000000000000000000;;		if db.rwtx != nil {
0000000000000000000000000000000000000000;;			db.rwtx.root.dereference()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unmap existing data before continuing.
0000000000000000000000000000000000000000;;		if err := db.munmap(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Memory-map the data file as a byte slice.
0000000000000000000000000000000000000000;;		if err := mmap(db, size); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save references to the meta pages.
0000000000000000000000000000000000000000;;		db.meta0 = db.page(0).meta()
0000000000000000000000000000000000000000;;		db.meta1 = db.page(1).meta()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate the meta pages. We only return an error if both meta pages fail
0000000000000000000000000000000000000000;;		// validation, since meta0 failing validation means that it wasn't saved
0000000000000000000000000000000000000000;;		// properly -- but we can recover using meta1. And vice-versa.
0000000000000000000000000000000000000000;;		err0 := db.meta0.validate()
0000000000000000000000000000000000000000;;		err1 := db.meta1.validate()
0000000000000000000000000000000000000000;;		if err0 != nil && err1 != nil {
0000000000000000000000000000000000000000;;			return err0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// munmap unmaps the data file from memory.
0000000000000000000000000000000000000000;;	func (db *DB) munmap() error {
0000000000000000000000000000000000000000;;		if err := munmap(db); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unmap error: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mmapSize determines the appropriate size for the mmap given the current size
0000000000000000000000000000000000000000;;	// of the database. The minimum size is 32KB and doubles until it reaches 1GB.
0000000000000000000000000000000000000000;;	// Returns an error if the new mmap size is greater than the max allowed.
0000000000000000000000000000000000000000;;	func (db *DB) mmapSize(size int) (int, error) {
0000000000000000000000000000000000000000;;		// Double the size from 32KB until 1GB.
0000000000000000000000000000000000000000;;		for i := uint(15); i <= 30; i++ {
0000000000000000000000000000000000000000;;			if size <= 1<<i {
0000000000000000000000000000000000000000;;				return 1 << i, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify the requested size is not above the maximum allowed.
0000000000000000000000000000000000000000;;		if size > maxMapSize {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("mmap too large")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If larger than 1GB then grow by 1GB at a time.
0000000000000000000000000000000000000000;;		sz := int64(size)
0000000000000000000000000000000000000000;;		if remainder := sz % int64(maxMmapStep); remainder > 0 {
0000000000000000000000000000000000000000;;			sz += int64(maxMmapStep) - remainder
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure that the mmap size is a multiple of the page size.
0000000000000000000000000000000000000000;;		// This should always be true since we're incrementing in MBs.
0000000000000000000000000000000000000000;;		pageSize := int64(db.pageSize)
0000000000000000000000000000000000000000;;		if (sz % pageSize) != 0 {
0000000000000000000000000000000000000000;;			sz = ((sz / pageSize) + 1) * pageSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we've exceeded the max size then only grow up to the max size.
0000000000000000000000000000000000000000;;		if sz > maxMapSize {
0000000000000000000000000000000000000000;;			sz = maxMapSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return int(sz), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init creates a new database file and initializes its meta pages.
0000000000000000000000000000000000000000;;	func (db *DB) init() error {
0000000000000000000000000000000000000000;;		// Set the page size to the OS page size.
0000000000000000000000000000000000000000;;		db.pageSize = os.Getpagesize()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create two meta pages on a buffer.
0000000000000000000000000000000000000000;;		buf := make([]byte, db.pageSize*4)
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			p := db.pageInBuffer(buf[:], pgid(i))
0000000000000000000000000000000000000000;;			p.id = pgid(i)
0000000000000000000000000000000000000000;;			p.flags = metaPageFlag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Initialize the meta page.
0000000000000000000000000000000000000000;;			m := p.meta()
0000000000000000000000000000000000000000;;			m.magic = magic
0000000000000000000000000000000000000000;;			m.version = version
0000000000000000000000000000000000000000;;			m.pageSize = uint32(db.pageSize)
0000000000000000000000000000000000000000;;			m.freelist = 2
0000000000000000000000000000000000000000;;			m.root = bucket{root: 3}
0000000000000000000000000000000000000000;;			m.pgid = 4
0000000000000000000000000000000000000000;;			m.txid = txid(i)
0000000000000000000000000000000000000000;;			m.checksum = m.sum64()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write an empty freelist at page 3.
0000000000000000000000000000000000000000;;		p := db.pageInBuffer(buf[:], pgid(2))
0000000000000000000000000000000000000000;;		p.id = pgid(2)
0000000000000000000000000000000000000000;;		p.flags = freelistPageFlag
0000000000000000000000000000000000000000;;		p.count = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write an empty leaf page at page 4.
0000000000000000000000000000000000000000;;		p = db.pageInBuffer(buf[:], pgid(3))
0000000000000000000000000000000000000000;;		p.id = pgid(3)
0000000000000000000000000000000000000000;;		p.flags = leafPageFlag
0000000000000000000000000000000000000000;;		p.count = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the buffer to our data file.
0000000000000000000000000000000000000000;;		if _, err := db.ops.writeAt(buf, 0); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := fdatasync(db); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close releases all database resources.
0000000000000000000000000000000000000000;;	// All transactions must be closed before closing the database.
0000000000000000000000000000000000000000;;	func (db *DB) Close() error {
0000000000000000000000000000000000000000;;		db.rwlock.Lock()
0000000000000000000000000000000000000000;;		defer db.rwlock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		db.metalock.Lock()
0000000000000000000000000000000000000000;;		defer db.metalock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		db.mmaplock.RLock()
0000000000000000000000000000000000000000;;		defer db.mmaplock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return db.close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (db *DB) close() error {
0000000000000000000000000000000000000000;;		if !db.opened {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		db.opened = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		db.freelist = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clear ops.
0000000000000000000000000000000000000000;;		db.ops.writeAt = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close the mmap.
0000000000000000000000000000000000000000;;		if err := db.munmap(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close file handles.
0000000000000000000000000000000000000000;;		if db.file != nil {
0000000000000000000000000000000000000000;;			// No need to unlock read-only file.
0000000000000000000000000000000000000000;;			if !db.readOnly {
0000000000000000000000000000000000000000;;				// Unlock the file.
0000000000000000000000000000000000000000;;				if err := funlock(db); err != nil {
0000000000000000000000000000000000000000;;					log.Printf("bolt.Close(): funlock error: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Close the file descriptor.
0000000000000000000000000000000000000000;;			if err := db.file.Close(); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("db file close: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			db.file = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		db.path = ""
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Begin starts a new transaction.
0000000000000000000000000000000000000000;;	// Multiple read-only transactions can be used concurrently but only one
0000000000000000000000000000000000000000;;	// write transaction can be used at a time. Starting multiple write transactions
0000000000000000000000000000000000000000;;	// will cause the calls to block and be serialized until the current write
0000000000000000000000000000000000000000;;	// transaction finishes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Transactions should not be dependent on one another. Opening a read
0000000000000000000000000000000000000000;;	// transaction and a write transaction in the same goroutine can cause the
0000000000000000000000000000000000000000;;	// writer to deadlock because the database periodically needs to re-mmap itself
0000000000000000000000000000000000000000;;	// as it grows and it cannot do that while a read transaction is open.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If a long running read transaction (for example, a snapshot transaction) is
0000000000000000000000000000000000000000;;	// needed, you might want to set DB.InitialMmapSize to a large enough value
0000000000000000000000000000000000000000;;	// to avoid potential blocking of write transaction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// IMPORTANT: You must close read-only transactions after you are finished or
0000000000000000000000000000000000000000;;	// else the database will not reclaim old pages.
0000000000000000000000000000000000000000;;	func (db *DB) Begin(writable bool) (*Tx, error) {
0000000000000000000000000000000000000000;;		if writable {
0000000000000000000000000000000000000000;;			return db.beginRWTx()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return db.beginTx()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (db *DB) beginTx() (*Tx, error) {
0000000000000000000000000000000000000000;;		// Lock the meta pages while we initialize the transaction. We obtain
0000000000000000000000000000000000000000;;		// the meta lock before the mmap lock because that's the order that the
0000000000000000000000000000000000000000;;		// write transaction will obtain them.
0000000000000000000000000000000000000000;;		db.metalock.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Obtain a read-only lock on the mmap. When the mmap is remapped it will
0000000000000000000000000000000000000000;;		// obtain a write lock so all transactions must finish before it can be
0000000000000000000000000000000000000000;;		// remapped.
0000000000000000000000000000000000000000;;		db.mmaplock.RLock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Exit if the database is not open yet.
0000000000000000000000000000000000000000;;		if !db.opened {
0000000000000000000000000000000000000000;;			db.mmaplock.RUnlock()
0000000000000000000000000000000000000000;;			db.metalock.Unlock()
0000000000000000000000000000000000000000;;			return nil, ErrDatabaseNotOpen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a transaction associated with the database.
0000000000000000000000000000000000000000;;		t := &Tx{}
0000000000000000000000000000000000000000;;		t.init(db)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Keep track of transaction until it closes.
0000000000000000000000000000000000000000;;		db.txs = append(db.txs, t)
0000000000000000000000000000000000000000;;		n := len(db.txs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unlock the meta pages.
0000000000000000000000000000000000000000;;		db.metalock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the transaction stats.
0000000000000000000000000000000000000000;;		db.statlock.Lock()
0000000000000000000000000000000000000000;;		db.stats.TxN++
0000000000000000000000000000000000000000;;		db.stats.OpenTxN = n
0000000000000000000000000000000000000000;;		db.statlock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (db *DB) beginRWTx() (*Tx, error) {
0000000000000000000000000000000000000000;;		// If the database was opened with Options.ReadOnly, return an error.
0000000000000000000000000000000000000000;;		if db.readOnly {
0000000000000000000000000000000000000000;;			return nil, ErrDatabaseReadOnly
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Obtain writer lock. This is released by the transaction when it closes.
0000000000000000000000000000000000000000;;		// This enforces only one writer transaction at a time.
0000000000000000000000000000000000000000;;		db.rwlock.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Once we have the writer lock then we can lock the meta pages so that
0000000000000000000000000000000000000000;;		// we can set up the transaction.
0000000000000000000000000000000000000000;;		db.metalock.Lock()
0000000000000000000000000000000000000000;;		defer db.metalock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Exit if the database is not open yet.
0000000000000000000000000000000000000000;;		if !db.opened {
0000000000000000000000000000000000000000;;			db.rwlock.Unlock()
0000000000000000000000000000000000000000;;			return nil, ErrDatabaseNotOpen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a transaction associated with the database.
0000000000000000000000000000000000000000;;		t := &Tx{writable: true}
0000000000000000000000000000000000000000;;		t.init(db)
0000000000000000000000000000000000000000;;		db.rwtx = t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Free any pages associated with closed read-only transactions.
0000000000000000000000000000000000000000;;		var minid txid = 0xFFFFFFFFFFFFFFFF
0000000000000000000000000000000000000000;;		for _, t := range db.txs {
0000000000000000000000000000000000000000;;			if t.meta.txid < minid {
0000000000000000000000000000000000000000;;				minid = t.meta.txid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if minid > 0 {
0000000000000000000000000000000000000000;;			db.freelist.release(minid - 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeTx removes a transaction from the database.
0000000000000000000000000000000000000000;;	func (db *DB) removeTx(tx *Tx) {
0000000000000000000000000000000000000000;;		// Release the read lock on the mmap.
0000000000000000000000000000000000000000;;		db.mmaplock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use the meta lock to restrict access to the DB object.
0000000000000000000000000000000000000000;;		db.metalock.Lock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the transaction.
0000000000000000000000000000000000000000;;		for i, t := range db.txs {
0000000000000000000000000000000000000000;;			if t == tx {
0000000000000000000000000000000000000000;;				db.txs = append(db.txs[:i], db.txs[i+1:]...)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n := len(db.txs)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unlock the meta pages.
0000000000000000000000000000000000000000;;		db.metalock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Merge statistics.
0000000000000000000000000000000000000000;;		db.statlock.Lock()
0000000000000000000000000000000000000000;;		db.stats.OpenTxN = n
0000000000000000000000000000000000000000;;		db.stats.TxStats.add(&tx.stats)
0000000000000000000000000000000000000000;;		db.statlock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update executes a function within the context of a read-write managed transaction.
0000000000000000000000000000000000000000;;	// If no error is returned from the function then the transaction is committed.
0000000000000000000000000000000000000000;;	// If an error is returned then the entire transaction is rolled back.
0000000000000000000000000000000000000000;;	// Any error that is returned from the function or returned from the commit is
0000000000000000000000000000000000000000;;	// returned from the Update() method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Attempting to manually commit or rollback within the function will cause a panic.
0000000000000000000000000000000000000000;;	func (db *DB) Update(fn func(*Tx) error) error {
0000000000000000000000000000000000000000;;		t, err := db.Begin(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure the transaction rolls back in the event of a panic.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if t.db != nil {
0000000000000000000000000000000000000000;;				t.rollback()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mark as a managed tx so that the inner function cannot manually commit.
0000000000000000000000000000000000000000;;		t.managed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If an error is returned from the function then rollback and return error.
0000000000000000000000000000000000000000;;		err = fn(t)
0000000000000000000000000000000000000000;;		t.managed = false
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			_ = t.Rollback()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return t.Commit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// View executes a function within the context of a managed read-only transaction.
0000000000000000000000000000000000000000;;	// Any error that is returned from the function is returned from the View() method.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Attempting to manually rollback within the function will cause a panic.
0000000000000000000000000000000000000000;;	func (db *DB) View(fn func(*Tx) error) error {
0000000000000000000000000000000000000000;;		t, err := db.Begin(false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make sure the transaction rolls back in the event of a panic.
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if t.db != nil {
0000000000000000000000000000000000000000;;				t.rollback()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mark as a managed tx so that the inner function cannot manually rollback.
0000000000000000000000000000000000000000;;		t.managed = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If an error is returned from the function then pass it through.
0000000000000000000000000000000000000000;;		err = fn(t)
0000000000000000000000000000000000000000;;		t.managed = false
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			_ = t.Rollback()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := t.Rollback(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Batch calls fn as part of a batch. It behaves similar to Update,
0000000000000000000000000000000000000000;;	// except:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 1. concurrent Batch calls can be combined into a single Bolt
0000000000000000000000000000000000000000;;	// transaction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 2. the function passed to Batch may be called multiple times,
0000000000000000000000000000000000000000;;	// regardless of whether it returns error or not.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This means that Batch function side effects must be idempotent and
0000000000000000000000000000000000000000;;	// take permanent effect only after a successful return is seen in
0000000000000000000000000000000000000000;;	// caller.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The maximum batch size and delay can be adjusted with DB.MaxBatchSize
0000000000000000000000000000000000000000;;	// and DB.MaxBatchDelay, respectively.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Batch is only useful when there are multiple goroutines calling it.
0000000000000000000000000000000000000000;;	func (db *DB) Batch(fn func(*Tx) error) error {
0000000000000000000000000000000000000000;;		errCh := make(chan error, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		db.batchMu.Lock()
0000000000000000000000000000000000000000;;		if (db.batch == nil) || (db.batch != nil && len(db.batch.calls) >= db.MaxBatchSize) {
0000000000000000000000000000000000000000;;			// There is no existing batch, or the existing batch is full; start a new one.
0000000000000000000000000000000000000000;;			db.batch = &batch{
0000000000000000000000000000000000000000;;				db: db,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			db.batch.timer = time.AfterFunc(db.MaxBatchDelay, db.batch.trigger)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		db.batch.calls = append(db.batch.calls, call{fn: fn, err: errCh})
0000000000000000000000000000000000000000;;		if len(db.batch.calls) >= db.MaxBatchSize {
0000000000000000000000000000000000000000;;			// wake up batch, it's ready to run
0000000000000000000000000000000000000000;;			go db.batch.trigger()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		db.batchMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := <-errCh
0000000000000000000000000000000000000000;;		if err == trySolo {
0000000000000000000000000000000000000000;;			err = db.Update(fn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type call struct {
0000000000000000000000000000000000000000;;		fn  func(*Tx) error
0000000000000000000000000000000000000000;;		err chan<- error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type batch struct {
0000000000000000000000000000000000000000;;		db    *DB
0000000000000000000000000000000000000000;;		timer *time.Timer
0000000000000000000000000000000000000000;;		start sync.Once
0000000000000000000000000000000000000000;;		calls []call
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// trigger runs the batch if it hasn't already been run.
0000000000000000000000000000000000000000;;	func (b *batch) trigger() {
0000000000000000000000000000000000000000;;		b.start.Do(b.run)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// run performs the transactions in the batch and communicates results
0000000000000000000000000000000000000000;;	// back to DB.Batch.
0000000000000000000000000000000000000000;;	func (b *batch) run() {
0000000000000000000000000000000000000000;;		b.db.batchMu.Lock()
0000000000000000000000000000000000000000;;		b.timer.Stop()
0000000000000000000000000000000000000000;;		// Make sure no new work is added to this batch, but don't break
0000000000000000000000000000000000000000;;		// other batches.
0000000000000000000000000000000000000000;;		if b.db.batch == b {
0000000000000000000000000000000000000000;;			b.db.batch = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.db.batchMu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	retry:
0000000000000000000000000000000000000000;;		for len(b.calls) > 0 {
0000000000000000000000000000000000000000;;			var failIdx = -1
0000000000000000000000000000000000000000;;			err := b.db.Update(func(tx *Tx) error {
0000000000000000000000000000000000000000;;				for i, c := range b.calls {
0000000000000000000000000000000000000000;;					if err := safelyCall(c.fn, tx); err != nil {
0000000000000000000000000000000000000000;;						failIdx = i
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if failIdx >= 0 {
0000000000000000000000000000000000000000;;				// take the failing transaction out of the batch. it's
0000000000000000000000000000000000000000;;				// safe to shorten b.calls here because db.batch no longer
0000000000000000000000000000000000000000;;				// points to us, and we hold the mutex anyway.
0000000000000000000000000000000000000000;;				c := b.calls[failIdx]
0000000000000000000000000000000000000000;;				b.calls[failIdx], b.calls = b.calls[len(b.calls)-1], b.calls[:len(b.calls)-1]
0000000000000000000000000000000000000000;;				// tell the submitter re-run it solo, continue with the rest of the batch
0000000000000000000000000000000000000000;;				c.err <- trySolo
0000000000000000000000000000000000000000;;				continue retry
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// pass success, or bolt internal errors, to all callers
0000000000000000000000000000000000000000;;			for _, c := range b.calls {
0000000000000000000000000000000000000000;;				if c.err != nil {
0000000000000000000000000000000000000000;;					c.err <- err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			break retry
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// trySolo is a special sentinel error value used for signaling that a
0000000000000000000000000000000000000000;;	// transaction function should be re-run. It should never be seen by
0000000000000000000000000000000000000000;;	// callers.
0000000000000000000000000000000000000000;;	var trySolo = errors.New("batch function returned an error and should be re-run solo")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type panicked struct {
0000000000000000000000000000000000000000;;		reason interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p panicked) Error() string {
0000000000000000000000000000000000000000;;		if err, ok := p.reason.(error); ok {
0000000000000000000000000000000000000000;;			return err.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("panic: %v", p.reason)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func safelyCall(fn func(*Tx) error, tx *Tx) (err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if p := recover(); p != nil {
0000000000000000000000000000000000000000;;				err = panicked{p}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return fn(tx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sync executes fdatasync() against the database file handle.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is not necessary under normal operation, however, if you use NoSync
0000000000000000000000000000000000000000;;	// then it allows you to force the database file to sync against the disk.
0000000000000000000000000000000000000000;;	func (db *DB) Sync() error { return fdatasync(db) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stats retrieves ongoing performance stats for the database.
0000000000000000000000000000000000000000;;	// This is only updated when a transaction closes.
0000000000000000000000000000000000000000;;	func (db *DB) Stats() Stats {
0000000000000000000000000000000000000000;;		db.statlock.RLock()
0000000000000000000000000000000000000000;;		defer db.statlock.RUnlock()
0000000000000000000000000000000000000000;;		return db.stats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is for internal access to the raw data bytes from the C cursor, use
0000000000000000000000000000000000000000;;	// carefully, or not at all.
0000000000000000000000000000000000000000;;	func (db *DB) Info() *Info {
0000000000000000000000000000000000000000;;		return &Info{uintptr(unsafe.Pointer(&db.data[0])), db.pageSize}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// page retrieves a page reference from the mmap based on the current page size.
0000000000000000000000000000000000000000;;	func (db *DB) page(id pgid) *page {
0000000000000000000000000000000000000000;;		pos := id * pgid(db.pageSize)
0000000000000000000000000000000000000000;;		return (*page)(unsafe.Pointer(&db.data[pos]))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pageInBuffer retrieves a page reference from a given byte array based on the current page size.
0000000000000000000000000000000000000000;;	func (db *DB) pageInBuffer(b []byte, id pgid) *page {
0000000000000000000000000000000000000000;;		return (*page)(unsafe.Pointer(&b[id*pgid(db.pageSize)]))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// meta retrieves the current meta page reference.
0000000000000000000000000000000000000000;;	func (db *DB) meta() *meta {
0000000000000000000000000000000000000000;;		// We have to return the meta with the highest txid which doesn't fail
0000000000000000000000000000000000000000;;		// validation. Otherwise, we can cause errors when in fact the database is
0000000000000000000000000000000000000000;;		// in a consistent state. metaA is the one with the higher txid.
0000000000000000000000000000000000000000;;		metaA := db.meta0
0000000000000000000000000000000000000000;;		metaB := db.meta1
0000000000000000000000000000000000000000;;		if db.meta1.txid > db.meta0.txid {
0000000000000000000000000000000000000000;;			metaA = db.meta1
0000000000000000000000000000000000000000;;			metaB = db.meta0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use higher meta page if valid. Otherwise fallback to previous, if valid.
0000000000000000000000000000000000000000;;		if err := metaA.validate(); err == nil {
0000000000000000000000000000000000000000;;			return metaA
0000000000000000000000000000000000000000;;		} else if err := metaB.validate(); err == nil {
0000000000000000000000000000000000000000;;			return metaB
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This should never be reached, because both meta1 and meta0 were validated
0000000000000000000000000000000000000000;;		// on mmap() and we do fsync() on every write.
0000000000000000000000000000000000000000;;		panic("bolt.DB.meta(): invalid meta pages")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allocate returns a contiguous block of memory starting at a given page.
0000000000000000000000000000000000000000;;	func (db *DB) allocate(count int) (*page, error) {
0000000000000000000000000000000000000000;;		// Allocate a temporary buffer for the page.
0000000000000000000000000000000000000000;;		var buf []byte
0000000000000000000000000000000000000000;;		if count == 1 {
0000000000000000000000000000000000000000;;			buf = db.pagePool.Get().([]byte)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			buf = make([]byte, count*db.pageSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p := (*page)(unsafe.Pointer(&buf[0]))
0000000000000000000000000000000000000000;;		p.overflow = uint32(count - 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use pages from the freelist if they are available.
0000000000000000000000000000000000000000;;		if p.id = db.freelist.allocate(count); p.id != 0 {
0000000000000000000000000000000000000000;;			return p, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Resize mmap() if we're at the end.
0000000000000000000000000000000000000000;;		p.id = db.rwtx.meta.pgid
0000000000000000000000000000000000000000;;		var minsz = int((p.id+pgid(count))+1) * db.pageSize
0000000000000000000000000000000000000000;;		if minsz >= db.datasz {
0000000000000000000000000000000000000000;;			if err := db.mmap(minsz); err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("mmap allocate error: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move the page id high water mark.
0000000000000000000000000000000000000000;;		db.rwtx.meta.pgid += pgid(count)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// grow grows the size of the database to the given sz.
0000000000000000000000000000000000000000;;	func (db *DB) grow(sz int) error {
0000000000000000000000000000000000000000;;		// Ignore if the new size is less than available file size.
0000000000000000000000000000000000000000;;		if sz <= db.filesz {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the data is smaller than the alloc size then only allocate what's needed.
0000000000000000000000000000000000000000;;		// Once it goes over the allocation size then allocate in chunks.
0000000000000000000000000000000000000000;;		if db.datasz < db.AllocSize {
0000000000000000000000000000000000000000;;			sz = db.datasz
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			sz += db.AllocSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Truncate and fsync to ensure file size metadata is flushed.
0000000000000000000000000000000000000000;;		// https://github.com/boltdb/bolt/issues/284
0000000000000000000000000000000000000000;;		if !db.NoGrowSync && !db.readOnly {
0000000000000000000000000000000000000000;;			if runtime.GOOS != "windows" {
0000000000000000000000000000000000000000;;				if err := db.file.Truncate(int64(sz)); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("file resize error: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := db.file.Sync(); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("file sync error: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		db.filesz = sz
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (db *DB) IsReadOnly() bool {
0000000000000000000000000000000000000000;;		return db.readOnly
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options represents the options that can be set when opening a database.
0000000000000000000000000000000000000000;;	type Options struct {
0000000000000000000000000000000000000000;;		// Timeout is the amount of time to wait to obtain a file lock.
0000000000000000000000000000000000000000;;		// When set to zero it will wait indefinitely. This option is only
0000000000000000000000000000000000000000;;		// available on Darwin and Linux.
0000000000000000000000000000000000000000;;		Timeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sets the DB.NoGrowSync flag before memory mapping the file.
0000000000000000000000000000000000000000;;		NoGrowSync bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Open database in read-only mode. Uses flock(..., LOCK_SH |LOCK_NB) to
0000000000000000000000000000000000000000;;		// grab a shared lock (UNIX).
0000000000000000000000000000000000000000;;		ReadOnly bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sets the DB.MmapFlags flag before memory mapping the file.
0000000000000000000000000000000000000000;;		MmapFlags int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InitialMmapSize is the initial mmap size of the database
0000000000000000000000000000000000000000;;		// in bytes. Read transactions won't block write transaction
0000000000000000000000000000000000000000;;		// if the InitialMmapSize is large enough to hold database mmap
0000000000000000000000000000000000000000;;		// size. (See DB.Begin for more information)
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If <=0, the initial map size is 0.
0000000000000000000000000000000000000000;;		// If initialMmapSize is smaller than the previous database size,
0000000000000000000000000000000000000000;;		// it takes no effect.
0000000000000000000000000000000000000000;;		InitialMmapSize int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultOptions represent the options used if nil options are passed into Open().
0000000000000000000000000000000000000000;;	// No timeout is used which will cause Bolt to wait indefinitely for a lock.
0000000000000000000000000000000000000000;;	var DefaultOptions = &Options{
0000000000000000000000000000000000000000;;		Timeout:    0,
0000000000000000000000000000000000000000;;		NoGrowSync: false,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stats represents statistics about the database.
0000000000000000000000000000000000000000;;	type Stats struct {
0000000000000000000000000000000000000000;;		// Freelist stats
0000000000000000000000000000000000000000;;		FreePageN     int // total number of free pages on the freelist
0000000000000000000000000000000000000000;;		PendingPageN  int // total number of pending pages on the freelist
0000000000000000000000000000000000000000;;		FreeAlloc     int // total bytes allocated in free pages
0000000000000000000000000000000000000000;;		FreelistInuse int // total bytes used by the freelist
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Transaction stats
0000000000000000000000000000000000000000;;		TxN     int // total number of started read transactions
0000000000000000000000000000000000000000;;		OpenTxN int // number of currently open read transactions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TxStats TxStats // global, ongoing stats.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sub calculates and returns the difference between two sets of database stats.
0000000000000000000000000000000000000000;;	// This is useful when obtaining stats at two different points and time and
0000000000000000000000000000000000000000;;	// you need the performance counters that occurred within that time span.
0000000000000000000000000000000000000000;;	func (s *Stats) Sub(other *Stats) Stats {
0000000000000000000000000000000000000000;;		if other == nil {
0000000000000000000000000000000000000000;;			return *s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var diff Stats
0000000000000000000000000000000000000000;;		diff.FreePageN = s.FreePageN
0000000000000000000000000000000000000000;;		diff.PendingPageN = s.PendingPageN
0000000000000000000000000000000000000000;;		diff.FreeAlloc = s.FreeAlloc
0000000000000000000000000000000000000000;;		diff.FreelistInuse = s.FreelistInuse
0000000000000000000000000000000000000000;;		diff.TxN = other.TxN - s.TxN
0000000000000000000000000000000000000000;;		diff.TxStats = s.TxStats.Sub(&other.TxStats)
0000000000000000000000000000000000000000;;		return diff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Stats) add(other *Stats) {
0000000000000000000000000000000000000000;;		s.TxStats.add(&other.TxStats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Info struct {
0000000000000000000000000000000000000000;;		Data     uintptr
0000000000000000000000000000000000000000;;		PageSize int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type meta struct {
0000000000000000000000000000000000000000;;		magic    uint32
0000000000000000000000000000000000000000;;		version  uint32
0000000000000000000000000000000000000000;;		pageSize uint32
0000000000000000000000000000000000000000;;		flags    uint32
0000000000000000000000000000000000000000;;		root     bucket
0000000000000000000000000000000000000000;;		freelist pgid
0000000000000000000000000000000000000000;;		pgid     pgid
0000000000000000000000000000000000000000;;		txid     txid
0000000000000000000000000000000000000000;;		checksum uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// validate checks the marker bytes and version of the meta page to ensure it matches this binary.
0000000000000000000000000000000000000000;;	func (m *meta) validate() error {
0000000000000000000000000000000000000000;;		if m.magic != magic {
0000000000000000000000000000000000000000;;			return ErrInvalid
0000000000000000000000000000000000000000;;		} else if m.version != version {
0000000000000000000000000000000000000000;;			return ErrVersionMismatch
0000000000000000000000000000000000000000;;		} else if m.checksum != 0 && m.checksum != m.sum64() {
0000000000000000000000000000000000000000;;			return ErrChecksum
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copy copies one meta object to another.
0000000000000000000000000000000000000000;;	func (m *meta) copy(dest *meta) {
0000000000000000000000000000000000000000;;		*dest = *m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write writes the meta onto a page.
0000000000000000000000000000000000000000;;	func (m *meta) write(p *page) {
0000000000000000000000000000000000000000;;		if m.root.root >= m.pgid {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("root bucket pgid (%d) above high water mark (%d)", m.root.root, m.pgid))
0000000000000000000000000000000000000000;;		} else if m.freelist >= m.pgid {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("freelist pgid (%d) above high water mark (%d)", m.freelist, m.pgid))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Page id is either going to be 0 or 1 which we can determine by the transaction ID.
0000000000000000000000000000000000000000;;		p.id = pgid(m.txid % 2)
0000000000000000000000000000000000000000;;		p.flags |= metaPageFlag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Calculate the checksum.
0000000000000000000000000000000000000000;;		m.checksum = m.sum64()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.copy(p.meta())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generates the checksum for the meta.
0000000000000000000000000000000000000000;;	func (m *meta) sum64() uint64 {
0000000000000000000000000000000000000000;;		var h = fnv.New64a()
0000000000000000000000000000000000000000;;		_, _ = h.Write((*[unsafe.Offsetof(meta{}.checksum)]byte)(unsafe.Pointer(m))[:])
0000000000000000000000000000000000000000;;		return h.Sum64()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// _assert will panic with a given formatted message if the given condition is false.
0000000000000000000000000000000000000000;;	func _assert(condition bool, msg string, v ...interface{}) {
0000000000000000000000000000000000000000;;		if !condition {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("assertion failed: "+msg, v...))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func warn(v ...interface{})              { fmt.Fprintln(os.Stderr, v...) }
0000000000000000000000000000000000000000;;	func warnf(msg string, v ...interface{}) { fmt.Fprintf(os.Stderr, msg+"\n", v...) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printstack() {
0000000000000000000000000000000000000000;;		stack := strings.Join(strings.Split(string(debug.Stack()), "\n")[2:], "\n")
0000000000000000000000000000000000000000;;		fmt.Fprintln(os.Stderr, stack)
0000000000000000000000000000000000000000;;	}
