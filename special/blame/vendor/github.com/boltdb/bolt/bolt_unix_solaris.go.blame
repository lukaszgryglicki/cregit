0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/bolt_unix_solaris.go[Godeps/_workspace/src/github.com/boltdb/bolt/bolt_unix_solaris.go][vendor/github.com/boltdb/bolt/bolt_unix_solaris.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/sys/unix"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flock acquires an advisory lock on a file descriptor.
0000000000000000000000000000000000000000;;	func flock(db *DB, mode os.FileMode, exclusive bool, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		var t time.Time
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// If we're beyond our timeout then return an error.
0000000000000000000000000000000000000000;;			// This can only occur after we've attempted a flock once.
0000000000000000000000000000000000000000;;			if t.IsZero() {
0000000000000000000000000000000000000000;;				t = time.Now()
0000000000000000000000000000000000000000;;			} else if timeout > 0 && time.Since(t) > timeout {
0000000000000000000000000000000000000000;;				return ErrTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var lock syscall.Flock_t
0000000000000000000000000000000000000000;;			lock.Start = 0
0000000000000000000000000000000000000000;;			lock.Len = 0
0000000000000000000000000000000000000000;;			lock.Pid = 0
0000000000000000000000000000000000000000;;			lock.Whence = 0
0000000000000000000000000000000000000000;;			lock.Pid = 0
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				lock.Type = syscall.F_WRLCK
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				lock.Type = syscall.F_RDLCK
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := syscall.FcntlFlock(db.file.Fd(), syscall.F_SETLK, &lock)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if err != syscall.EAGAIN {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for a bit and try again.
0000000000000000000000000000000000000000;;			time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// funlock releases an advisory lock on a file descriptor.
0000000000000000000000000000000000000000;;	func funlock(db *DB) error {
0000000000000000000000000000000000000000;;		var lock syscall.Flock_t
0000000000000000000000000000000000000000;;		lock.Start = 0
0000000000000000000000000000000000000000;;		lock.Len = 0
0000000000000000000000000000000000000000;;		lock.Type = syscall.F_UNLCK
0000000000000000000000000000000000000000;;		lock.Whence = 0
0000000000000000000000000000000000000000;;		return syscall.FcntlFlock(uintptr(db.file.Fd()), syscall.F_SETLK, &lock)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mmap memory maps a DB's data file.
0000000000000000000000000000000000000000;;	func mmap(db *DB, sz int) error {
0000000000000000000000000000000000000000;;		// Map the data file to memory.
0000000000000000000000000000000000000000;;		b, err := unix.Mmap(int(db.file.Fd()), 0, sz, syscall.PROT_READ, syscall.MAP_SHARED|db.MmapFlags)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Advise the kernel that the mmap is accessed randomly.
0000000000000000000000000000000000000000;;		if err := unix.Madvise(b, syscall.MADV_RANDOM); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("madvise: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the original byte slice and convert to a byte array pointer.
0000000000000000000000000000000000000000;;		db.dataref = b
0000000000000000000000000000000000000000;;		db.data = (*[maxMapSize]byte)(unsafe.Pointer(&b[0]))
0000000000000000000000000000000000000000;;		db.datasz = sz
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// munmap unmaps a DB's data file from memory.
0000000000000000000000000000000000000000;;	func munmap(db *DB) error {
0000000000000000000000000000000000000000;;		// Ignore the unmap if we have no mapped data.
0000000000000000000000000000000000000000;;		if db.dataref == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unmap using the original byte slice.
0000000000000000000000000000000000000000;;		err := unix.Munmap(db.dataref)
0000000000000000000000000000000000000000;;		db.dataref = nil
0000000000000000000000000000000000000000;;		db.data = nil
0000000000000000000000000000000000000000;;		db.datasz = 0
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
