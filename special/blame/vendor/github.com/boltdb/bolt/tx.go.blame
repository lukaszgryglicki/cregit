0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/tx.go[Godeps/_workspace/src/github.com/boltdb/bolt/tx.go][vendor/github.com/boltdb/bolt/tx.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// txid represents the internal transaction identifier.
0000000000000000000000000000000000000000;;	type txid uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tx represents a read-only or read/write transaction on the database.
0000000000000000000000000000000000000000;;	// Read-only transactions can be used for retrieving values for keys and creating cursors.
0000000000000000000000000000000000000000;;	// Read/write transactions can create and remove buckets and create and remove keys.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// IMPORTANT: You must commit or rollback transactions when you are done with
0000000000000000000000000000000000000000;;	// them. Pages can not be reclaimed by the writer until no more transactions
0000000000000000000000000000000000000000;;	// are using them. A long running read transaction can cause the database to
0000000000000000000000000000000000000000;;	// quickly grow.
0000000000000000000000000000000000000000;;	type Tx struct {
0000000000000000000000000000000000000000;;		writable       bool
0000000000000000000000000000000000000000;;		managed        bool
0000000000000000000000000000000000000000;;		db             *DB
0000000000000000000000000000000000000000;;		meta           *meta
0000000000000000000000000000000000000000;;		root           Bucket
0000000000000000000000000000000000000000;;		pages          map[pgid]*page
0000000000000000000000000000000000000000;;		stats          TxStats
0000000000000000000000000000000000000000;;		commitHandlers []func()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// WriteFlag specifies the flag for write-related methods like WriteTo().
0000000000000000000000000000000000000000;;		// Tx opens the database file with the specified flag to copy the data.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// By default, the flag is unset, which works well for mostly in-memory
0000000000000000000000000000000000000000;;		// workloads. For databases that are much larger than available RAM,
0000000000000000000000000000000000000000;;		// set the flag to syscall.O_DIRECT to avoid trashing the page cache.
0000000000000000000000000000000000000000;;		WriteFlag int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init initializes the transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) init(db *DB) {
0000000000000000000000000000000000000000;;		tx.db = db
0000000000000000000000000000000000000000;;		tx.pages = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy the meta page since it can be changed by the writer.
0000000000000000000000000000000000000000;;		tx.meta = &meta{}
0000000000000000000000000000000000000000;;		db.meta().copy(tx.meta)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy over the root bucket.
0000000000000000000000000000000000000000;;		tx.root = newBucket(tx)
0000000000000000000000000000000000000000;;		tx.root.bucket = &bucket{}
0000000000000000000000000000000000000000;;		*tx.root.bucket = tx.meta.root
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Increment the transaction id and add a page cache for writable transactions.
0000000000000000000000000000000000000000;;		if tx.writable {
0000000000000000000000000000000000000000;;			tx.pages = make(map[pgid]*page)
0000000000000000000000000000000000000000;;			tx.meta.txid += txid(1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ID returns the transaction id.
0000000000000000000000000000000000000000;;	func (tx *Tx) ID() int {
0000000000000000000000000000000000000000;;		return int(tx.meta.txid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DB returns a reference to the database that created the transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) DB() *DB {
0000000000000000000000000000000000000000;;		return tx.db
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size returns current database size in bytes as seen by this transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) Size() int64 {
0000000000000000000000000000000000000000;;		return int64(tx.meta.pgid) * int64(tx.db.pageSize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writable returns whether the transaction can perform write operations.
0000000000000000000000000000000000000000;;	func (tx *Tx) Writable() bool {
0000000000000000000000000000000000000000;;		return tx.writable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cursor creates a cursor associated with the root bucket.
0000000000000000000000000000000000000000;;	// All items in the cursor will return a nil value because all root bucket keys point to buckets.
0000000000000000000000000000000000000000;;	// The cursor is only valid as long as the transaction is open.
0000000000000000000000000000000000000000;;	// Do not use a cursor after the transaction is closed.
0000000000000000000000000000000000000000;;	func (tx *Tx) Cursor() *Cursor {
0000000000000000000000000000000000000000;;		return tx.root.Cursor()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stats retrieves a copy of the current transaction statistics.
0000000000000000000000000000000000000000;;	func (tx *Tx) Stats() TxStats {
0000000000000000000000000000000000000000;;		return tx.stats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bucket retrieves a bucket by name.
0000000000000000000000000000000000000000;;	// Returns nil if the bucket does not exist.
0000000000000000000000000000000000000000;;	// The bucket instance is only valid for the lifetime of the transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) Bucket(name []byte) *Bucket {
0000000000000000000000000000000000000000;;		return tx.root.Bucket(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateBucket creates a new bucket.
0000000000000000000000000000000000000000;;	// Returns an error if the bucket already exists, if the bucket name is blank, or if the bucket name is too long.
0000000000000000000000000000000000000000;;	// The bucket instance is only valid for the lifetime of the transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) CreateBucket(name []byte) (*Bucket, error) {
0000000000000000000000000000000000000000;;		return tx.root.CreateBucket(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateBucketIfNotExists creates a new bucket if it doesn't already exist.
0000000000000000000000000000000000000000;;	// Returns an error if the bucket name is blank, or if the bucket name is too long.
0000000000000000000000000000000000000000;;	// The bucket instance is only valid for the lifetime of the transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) CreateBucketIfNotExists(name []byte) (*Bucket, error) {
0000000000000000000000000000000000000000;;		return tx.root.CreateBucketIfNotExists(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteBucket deletes a bucket.
0000000000000000000000000000000000000000;;	// Returns an error if the bucket cannot be found or if the key represents a non-bucket value.
0000000000000000000000000000000000000000;;	func (tx *Tx) DeleteBucket(name []byte) error {
0000000000000000000000000000000000000000;;		return tx.root.DeleteBucket(name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForEach executes a function for each bucket in the root.
0000000000000000000000000000000000000000;;	// If the provided function returns an error then the iteration is stopped and
0000000000000000000000000000000000000000;;	// the error is returned to the caller.
0000000000000000000000000000000000000000;;	func (tx *Tx) ForEach(fn func(name []byte, b *Bucket) error) error {
0000000000000000000000000000000000000000;;		return tx.root.ForEach(func(k, v []byte) error {
0000000000000000000000000000000000000000;;			if err := fn(k, tx.root.Bucket(k)); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnCommit adds a handler function to be executed after the transaction successfully commits.
0000000000000000000000000000000000000000;;	func (tx *Tx) OnCommit(fn func()) {
0000000000000000000000000000000000000000;;		tx.commitHandlers = append(tx.commitHandlers, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Commit writes all changes to disk and updates the meta page.
0000000000000000000000000000000000000000;;	// Returns an error if a disk write error occurs, or if Commit is
0000000000000000000000000000000000000000;;	// called on a read-only transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) Commit() error {
0000000000000000000000000000000000000000;;		_assert(!tx.managed, "managed tx commit not allowed")
0000000000000000000000000000000000000000;;		if tx.db == nil {
0000000000000000000000000000000000000000;;			return ErrTxClosed
0000000000000000000000000000000000000000;;		} else if !tx.writable {
0000000000000000000000000000000000000000;;			return ErrTxNotWritable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(benbjohnson): Use vectorized I/O to write out dirty pages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rebalance nodes which have had deletions.
0000000000000000000000000000000000000000;;		var startTime = time.Now()
0000000000000000000000000000000000000000;;		tx.root.rebalance()
0000000000000000000000000000000000000000;;		if tx.stats.Rebalance > 0 {
0000000000000000000000000000000000000000;;			tx.stats.RebalanceTime += time.Since(startTime)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// spill data onto dirty pages.
0000000000000000000000000000000000000000;;		startTime = time.Now()
0000000000000000000000000000000000000000;;		if err := tx.root.spill(); err != nil {
0000000000000000000000000000000000000000;;			tx.rollback()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.stats.SpillTime += time.Since(startTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Free the old root bucket.
0000000000000000000000000000000000000000;;		tx.meta.root.root = tx.root.root
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opgid := tx.meta.pgid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Free the freelist and allocate new pages for it. This will overestimate
0000000000000000000000000000000000000000;;		// the size of the freelist but not underestimate the size (which would be bad).
0000000000000000000000000000000000000000;;		tx.db.freelist.free(tx.meta.txid, tx.db.page(tx.meta.freelist))
0000000000000000000000000000000000000000;;		p, err := tx.allocate((tx.db.freelist.size() / tx.db.pageSize) + 1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			tx.rollback()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := tx.db.freelist.write(p); err != nil {
0000000000000000000000000000000000000000;;			tx.rollback()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.meta.freelist = p.id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the high water mark has moved up then attempt to grow the database.
0000000000000000000000000000000000000000;;		if tx.meta.pgid > opgid {
0000000000000000000000000000000000000000;;			if err := tx.db.grow(int(tx.meta.pgid+1) * tx.db.pageSize); err != nil {
0000000000000000000000000000000000000000;;				tx.rollback()
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write dirty pages to disk.
0000000000000000000000000000000000000000;;		startTime = time.Now()
0000000000000000000000000000000000000000;;		if err := tx.write(); err != nil {
0000000000000000000000000000000000000000;;			tx.rollback()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If strict mode is enabled then perform a consistency check.
0000000000000000000000000000000000000000;;		// Only the first consistency error is reported in the panic.
0000000000000000000000000000000000000000;;		if tx.db.StrictMode {
0000000000000000000000000000000000000000;;			ch := tx.Check()
0000000000000000000000000000000000000000;;			var errs []string
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				err, ok := <-ch
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				errs = append(errs, err.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(errs) > 0 {
0000000000000000000000000000000000000000;;				panic("check fail: " + strings.Join(errs, "\n"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write meta to disk.
0000000000000000000000000000000000000000;;		if err := tx.writeMeta(); err != nil {
0000000000000000000000000000000000000000;;			tx.rollback()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.stats.WriteTime += time.Since(startTime)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finalize the transaction.
0000000000000000000000000000000000000000;;		tx.close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Execute commit handlers now that the locks have been removed.
0000000000000000000000000000000000000000;;		for _, fn := range tx.commitHandlers {
0000000000000000000000000000000000000000;;			fn()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rollback closes the transaction and ignores all previous updates. Read-only
0000000000000000000000000000000000000000;;	// transactions must be rolled back and not committed.
0000000000000000000000000000000000000000;;	func (tx *Tx) Rollback() error {
0000000000000000000000000000000000000000;;		_assert(!tx.managed, "managed tx rollback not allowed")
0000000000000000000000000000000000000000;;		if tx.db == nil {
0000000000000000000000000000000000000000;;			return ErrTxClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.rollback()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tx *Tx) rollback() {
0000000000000000000000000000000000000000;;		if tx.db == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tx.writable {
0000000000000000000000000000000000000000;;			tx.db.freelist.rollback(tx.meta.txid)
0000000000000000000000000000000000000000;;			tx.db.freelist.reload(tx.db.page(tx.db.meta().freelist))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tx.close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tx *Tx) close() {
0000000000000000000000000000000000000000;;		if tx.db == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tx.writable {
0000000000000000000000000000000000000000;;			// Grab freelist stats.
0000000000000000000000000000000000000000;;			var freelistFreeN = tx.db.freelist.free_count()
0000000000000000000000000000000000000000;;			var freelistPendingN = tx.db.freelist.pending_count()
0000000000000000000000000000000000000000;;			var freelistAlloc = tx.db.freelist.size()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove transaction ref & writer lock.
0000000000000000000000000000000000000000;;			tx.db.rwtx = nil
0000000000000000000000000000000000000000;;			tx.db.rwlock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Merge statistics.
0000000000000000000000000000000000000000;;			tx.db.statlock.Lock()
0000000000000000000000000000000000000000;;			tx.db.stats.FreePageN = freelistFreeN
0000000000000000000000000000000000000000;;			tx.db.stats.PendingPageN = freelistPendingN
0000000000000000000000000000000000000000;;			tx.db.stats.FreeAlloc = (freelistFreeN + freelistPendingN) * tx.db.pageSize
0000000000000000000000000000000000000000;;			tx.db.stats.FreelistInuse = freelistAlloc
0000000000000000000000000000000000000000;;			tx.db.stats.TxStats.add(&tx.stats)
0000000000000000000000000000000000000000;;			tx.db.statlock.Unlock()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tx.db.removeTx(tx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clear all references.
0000000000000000000000000000000000000000;;		tx.db = nil
0000000000000000000000000000000000000000;;		tx.meta = nil
0000000000000000000000000000000000000000;;		tx.root = Bucket{tx: tx}
0000000000000000000000000000000000000000;;		tx.pages = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy writes the entire database to a writer.
0000000000000000000000000000000000000000;;	// This function exists for backwards compatibility. Use WriteTo() instead.
0000000000000000000000000000000000000000;;	func (tx *Tx) Copy(w io.Writer) error {
0000000000000000000000000000000000000000;;		_, err := tx.WriteTo(w)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteTo writes the entire database to a writer.
0000000000000000000000000000000000000000;;	// If err == nil then exactly tx.Size() bytes will be written into the writer.
0000000000000000000000000000000000000000;;	func (tx *Tx) WriteTo(w io.Writer) (n int64, err error) {
0000000000000000000000000000000000000000;;		// Attempt to open reader with WriteFlag
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(tx.db.path, os.O_RDONLY|tx.WriteFlag, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() { _ = f.Close() }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate a meta page. We use the same page data for both meta pages.
0000000000000000000000000000000000000000;;		buf := make([]byte, tx.db.pageSize)
0000000000000000000000000000000000000000;;		page := (*page)(unsafe.Pointer(&buf[0]))
0000000000000000000000000000000000000000;;		page.flags = metaPageFlag
0000000000000000000000000000000000000000;;		*page.meta() = *tx.meta
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write meta 0.
0000000000000000000000000000000000000000;;		page.id = 0
0000000000000000000000000000000000000000;;		page.meta().checksum = page.meta().sum64()
0000000000000000000000000000000000000000;;		nn, err := w.Write(buf)
0000000000000000000000000000000000000000;;		n += int64(nn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return n, fmt.Errorf("meta 0 copy: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write meta 1 with a lower transaction id.
0000000000000000000000000000000000000000;;		page.id = 1
0000000000000000000000000000000000000000;;		page.meta().txid -= 1
0000000000000000000000000000000000000000;;		page.meta().checksum = page.meta().sum64()
0000000000000000000000000000000000000000;;		nn, err = w.Write(buf)
0000000000000000000000000000000000000000;;		n += int64(nn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return n, fmt.Errorf("meta 1 copy: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move past the meta pages in the file.
0000000000000000000000000000000000000000;;		if _, err := f.Seek(int64(tx.db.pageSize*2), os.SEEK_SET); err != nil {
0000000000000000000000000000000000000000;;			return n, fmt.Errorf("seek: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy data pages.
0000000000000000000000000000000000000000;;		wn, err := io.CopyN(w, f, tx.Size()-int64(tx.db.pageSize*2))
0000000000000000000000000000000000000000;;		n += wn
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, f.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyFile copies the entire database to file at the given path.
0000000000000000000000000000000000000000;;	// A reader transaction is maintained during the copy so it is safe to continue
0000000000000000000000000000000000000000;;	// using the database while a copy is in progress.
0000000000000000000000000000000000000000;;	func (tx *Tx) CopyFile(path string, mode os.FileMode) error {
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(path, os.O_RDWR|os.O_CREATE|os.O_TRUNC, mode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = tx.Copy(f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			_ = f.Close()
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check performs several consistency checks on the database for this transaction.
0000000000000000000000000000000000000000;;	// An error is returned if any inconsistency is found.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It can be safely run concurrently on a writable transaction. However, this
0000000000000000000000000000000000000000;;	// incurs a high cost for large databases and databases with a lot of subbuckets
0000000000000000000000000000000000000000;;	// because of caching. This overhead can be removed if running on a read-only
0000000000000000000000000000000000000000;;	// transaction, however, it is not safe to execute other writer transactions at
0000000000000000000000000000000000000000;;	// the same time.
0000000000000000000000000000000000000000;;	func (tx *Tx) Check() <-chan error {
0000000000000000000000000000000000000000;;		ch := make(chan error)
0000000000000000000000000000000000000000;;		go tx.check(ch)
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tx *Tx) check(ch chan error) {
0000000000000000000000000000000000000000;;		// Check if any pages are double freed.
0000000000000000000000000000000000000000;;		freed := make(map[pgid]bool)
0000000000000000000000000000000000000000;;		for _, id := range tx.db.freelist.all() {
0000000000000000000000000000000000000000;;			if freed[id] {
0000000000000000000000000000000000000000;;				ch <- fmt.Errorf("page %d: already freed", id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			freed[id] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Track every reachable page.
0000000000000000000000000000000000000000;;		reachable := make(map[pgid]*page)
0000000000000000000000000000000000000000;;		reachable[0] = tx.page(0) // meta0
0000000000000000000000000000000000000000;;		reachable[1] = tx.page(1) // meta1
0000000000000000000000000000000000000000;;		for i := uint32(0); i <= tx.page(tx.meta.freelist).overflow; i++ {
0000000000000000000000000000000000000000;;			reachable[tx.meta.freelist+pgid(i)] = tx.page(tx.meta.freelist)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively check buckets.
0000000000000000000000000000000000000000;;		tx.checkBucket(&tx.root, reachable, freed, ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ensure all pages below high water mark are either reachable or freed.
0000000000000000000000000000000000000000;;		for i := pgid(0); i < tx.meta.pgid; i++ {
0000000000000000000000000000000000000000;;			_, isReachable := reachable[i]
0000000000000000000000000000000000000000;;			if !isReachable && !freed[i] {
0000000000000000000000000000000000000000;;				ch <- fmt.Errorf("page %d: unreachable unfreed", int(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close the channel to signal completion.
0000000000000000000000000000000000000000;;		close(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (tx *Tx) checkBucket(b *Bucket, reachable map[pgid]*page, freed map[pgid]bool, ch chan error) {
0000000000000000000000000000000000000000;;		// Ignore inline buckets.
0000000000000000000000000000000000000000;;		if b.root == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check every page used by this bucket.
0000000000000000000000000000000000000000;;		b.tx.forEachPage(b.root, 0, func(p *page, _ int) {
0000000000000000000000000000000000000000;;			if p.id > tx.meta.pgid {
0000000000000000000000000000000000000000;;				ch <- fmt.Errorf("page %d: out of bounds: %d", int(p.id), int(b.tx.meta.pgid))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure each page is only referenced once.
0000000000000000000000000000000000000000;;			for i := pgid(0); i <= pgid(p.overflow); i++ {
0000000000000000000000000000000000000000;;				var id = p.id + i
0000000000000000000000000000000000000000;;				if _, ok := reachable[id]; ok {
0000000000000000000000000000000000000000;;					ch <- fmt.Errorf("page %d: multiple references", int(id))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				reachable[id] = p
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We should only encounter un-freed leaf and branch pages.
0000000000000000000000000000000000000000;;			if freed[p.id] {
0000000000000000000000000000000000000000;;				ch <- fmt.Errorf("page %d: reachable freed", int(p.id))
0000000000000000000000000000000000000000;;			} else if (p.flags&branchPageFlag) == 0 && (p.flags&leafPageFlag) == 0 {
0000000000000000000000000000000000000000;;				ch <- fmt.Errorf("page %d: invalid type: %s", int(p.id), p.typ())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check each bucket within this bucket.
0000000000000000000000000000000000000000;;		_ = b.ForEach(func(k, v []byte) error {
0000000000000000000000000000000000000000;;			if child := b.Bucket(k); child != nil {
0000000000000000000000000000000000000000;;				tx.checkBucket(child, reachable, freed, ch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allocate returns a contiguous block of memory starting at a given page.
0000000000000000000000000000000000000000;;	func (tx *Tx) allocate(count int) (*page, error) {
0000000000000000000000000000000000000000;;		p, err := tx.db.allocate(count)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save to our page cache.
0000000000000000000000000000000000000000;;		tx.pages[p.id] = p
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update statistics.
0000000000000000000000000000000000000000;;		tx.stats.PageCount++
0000000000000000000000000000000000000000;;		tx.stats.PageAlloc += count * tx.db.pageSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write writes any dirty pages to disk.
0000000000000000000000000000000000000000;;	func (tx *Tx) write() error {
0000000000000000000000000000000000000000;;		// Sort pages by id.
0000000000000000000000000000000000000000;;		pages := make(pages, 0, len(tx.pages))
0000000000000000000000000000000000000000;;		for _, p := range tx.pages {
0000000000000000000000000000000000000000;;			pages = append(pages, p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Clear out page cache early.
0000000000000000000000000000000000000000;;		tx.pages = make(map[pgid]*page)
0000000000000000000000000000000000000000;;		sort.Sort(pages)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write pages to disk in order.
0000000000000000000000000000000000000000;;		for _, p := range pages {
0000000000000000000000000000000000000000;;			size := (int(p.overflow) + 1) * tx.db.pageSize
0000000000000000000000000000000000000000;;			offset := int64(p.id) * int64(tx.db.pageSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write out page in "max allocation" sized chunks.
0000000000000000000000000000000000000000;;			ptr := (*[maxAllocSize]byte)(unsafe.Pointer(p))
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// Limit our write to our max allocation size.
0000000000000000000000000000000000000000;;				sz := size
0000000000000000000000000000000000000000;;				if sz > maxAllocSize-1 {
0000000000000000000000000000000000000000;;					sz = maxAllocSize - 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Write chunk to disk.
0000000000000000000000000000000000000000;;				buf := ptr[:sz]
0000000000000000000000000000000000000000;;				if _, err := tx.db.ops.writeAt(buf, offset); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Update statistics.
0000000000000000000000000000000000000000;;				tx.stats.Write++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Exit inner for loop if we've written all the chunks.
0000000000000000000000000000000000000000;;				size -= sz
0000000000000000000000000000000000000000;;				if size == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Otherwise move offset forward and move pointer to next chunk.
0000000000000000000000000000000000000000;;				offset += int64(sz)
0000000000000000000000000000000000000000;;				ptr = (*[maxAllocSize]byte)(unsafe.Pointer(&ptr[sz]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore file sync if flag is set on DB.
0000000000000000000000000000000000000000;;		if !tx.db.NoSync || IgnoreNoSync {
0000000000000000000000000000000000000000;;			if err := fdatasync(tx.db); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Put small pages back to page pool.
0000000000000000000000000000000000000000;;		for _, p := range pages {
0000000000000000000000000000000000000000;;			// Ignore page sizes over 1 page.
0000000000000000000000000000000000000000;;			// These are allocated using make() instead of the page pool.
0000000000000000000000000000000000000000;;			if int(p.overflow) != 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf := (*[maxAllocSize]byte)(unsafe.Pointer(p))[:tx.db.pageSize]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// See https://go.googlesource.com/go/+/f03c9202c43e0abb130669852082117ca50aa9b1
0000000000000000000000000000000000000000;;			for i := range buf {
0000000000000000000000000000000000000000;;				buf[i] = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tx.db.pagePool.Put(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// writeMeta writes the meta to the disk.
0000000000000000000000000000000000000000;;	func (tx *Tx) writeMeta() error {
0000000000000000000000000000000000000000;;		// Create a temporary buffer for the meta page.
0000000000000000000000000000000000000000;;		buf := make([]byte, tx.db.pageSize)
0000000000000000000000000000000000000000;;		p := tx.db.pageInBuffer(buf, 0)
0000000000000000000000000000000000000000;;		tx.meta.write(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the meta page to file.
0000000000000000000000000000000000000000;;		if _, err := tx.db.ops.writeAt(buf, int64(p.id)*int64(tx.db.pageSize)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !tx.db.NoSync || IgnoreNoSync {
0000000000000000000000000000000000000000;;			if err := fdatasync(tx.db); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update statistics.
0000000000000000000000000000000000000000;;		tx.stats.Write++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// page returns a reference to the page with a given id.
0000000000000000000000000000000000000000;;	// If page has been written to then a temporary buffered page is returned.
0000000000000000000000000000000000000000;;	func (tx *Tx) page(id pgid) *page {
0000000000000000000000000000000000000000;;		// Check the dirty pages first.
0000000000000000000000000000000000000000;;		if tx.pages != nil {
0000000000000000000000000000000000000000;;			if p, ok := tx.pages[id]; ok {
0000000000000000000000000000000000000000;;				return p
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise return directly from the mmap.
0000000000000000000000000000000000000000;;		return tx.db.page(id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forEachPage iterates over every page within a given page and executes a function.
0000000000000000000000000000000000000000;;	func (tx *Tx) forEachPage(pgid pgid, depth int, fn func(*page, int)) {
0000000000000000000000000000000000000000;;		p := tx.page(pgid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Execute function.
0000000000000000000000000000000000000000;;		fn(p, depth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively loop over children.
0000000000000000000000000000000000000000;;		if (p.flags & branchPageFlag) != 0 {
0000000000000000000000000000000000000000;;			for i := 0; i < int(p.count); i++ {
0000000000000000000000000000000000000000;;				elem := p.branchPageElement(uint16(i))
0000000000000000000000000000000000000000;;				tx.forEachPage(elem.pgid, depth+1, fn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Page returns page information for a given page number.
0000000000000000000000000000000000000000;;	// This is only safe for concurrent use when used by a writable transaction.
0000000000000000000000000000000000000000;;	func (tx *Tx) Page(id int) (*PageInfo, error) {
0000000000000000000000000000000000000000;;		if tx.db == nil {
0000000000000000000000000000000000000000;;			return nil, ErrTxClosed
0000000000000000000000000000000000000000;;		} else if pgid(id) >= tx.meta.pgid {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build the page info.
0000000000000000000000000000000000000000;;		p := tx.db.page(pgid(id))
0000000000000000000000000000000000000000;;		info := &PageInfo{
0000000000000000000000000000000000000000;;			ID:            id,
0000000000000000000000000000000000000000;;			Count:         int(p.count),
0000000000000000000000000000000000000000;;			OverflowCount: int(p.overflow),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the type (or if it's free).
0000000000000000000000000000000000000000;;		if tx.db.freelist.freed(pgid(id)) {
0000000000000000000000000000000000000000;;			info.Type = "free"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			info.Type = p.typ()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return info, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TxStats represents statistics about the actions performed by the transaction.
0000000000000000000000000000000000000000;;	type TxStats struct {
0000000000000000000000000000000000000000;;		// Page statistics.
0000000000000000000000000000000000000000;;		PageCount int // number of page allocations
0000000000000000000000000000000000000000;;		PageAlloc int // total bytes allocated
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cursor statistics.
0000000000000000000000000000000000000000;;		CursorCount int // number of cursors created
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Node statistics
0000000000000000000000000000000000000000;;		NodeCount int // number of node allocations
0000000000000000000000000000000000000000;;		NodeDeref int // number of node dereferences
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rebalance statistics.
0000000000000000000000000000000000000000;;		Rebalance     int           // number of node rebalances
0000000000000000000000000000000000000000;;		RebalanceTime time.Duration // total time spent rebalancing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split/Spill statistics.
0000000000000000000000000000000000000000;;		Split     int           // number of nodes split
0000000000000000000000000000000000000000;;		Spill     int           // number of nodes spilled
0000000000000000000000000000000000000000;;		SpillTime time.Duration // total time spent spilling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write statistics.
0000000000000000000000000000000000000000;;		Write     int           // number of writes performed
0000000000000000000000000000000000000000;;		WriteTime time.Duration // total time spent writing to disk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *TxStats) add(other *TxStats) {
0000000000000000000000000000000000000000;;		s.PageCount += other.PageCount
0000000000000000000000000000000000000000;;		s.PageAlloc += other.PageAlloc
0000000000000000000000000000000000000000;;		s.CursorCount += other.CursorCount
0000000000000000000000000000000000000000;;		s.NodeCount += other.NodeCount
0000000000000000000000000000000000000000;;		s.NodeDeref += other.NodeDeref
0000000000000000000000000000000000000000;;		s.Rebalance += other.Rebalance
0000000000000000000000000000000000000000;;		s.RebalanceTime += other.RebalanceTime
0000000000000000000000000000000000000000;;		s.Split += other.Split
0000000000000000000000000000000000000000;;		s.Spill += other.Spill
0000000000000000000000000000000000000000;;		s.SpillTime += other.SpillTime
0000000000000000000000000000000000000000;;		s.Write += other.Write
0000000000000000000000000000000000000000;;		s.WriteTime += other.WriteTime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sub calculates and returns the difference between two sets of transaction stats.
0000000000000000000000000000000000000000;;	// This is useful when obtaining stats at two different points and time and
0000000000000000000000000000000000000000;;	// you need the performance counters that occurred within that time span.
0000000000000000000000000000000000000000;;	func (s *TxStats) Sub(other *TxStats) TxStats {
0000000000000000000000000000000000000000;;		var diff TxStats
0000000000000000000000000000000000000000;;		diff.PageCount = s.PageCount - other.PageCount
0000000000000000000000000000000000000000;;		diff.PageAlloc = s.PageAlloc - other.PageAlloc
0000000000000000000000000000000000000000;;		diff.CursorCount = s.CursorCount - other.CursorCount
0000000000000000000000000000000000000000;;		diff.NodeCount = s.NodeCount - other.NodeCount
0000000000000000000000000000000000000000;;		diff.NodeDeref = s.NodeDeref - other.NodeDeref
0000000000000000000000000000000000000000;;		diff.Rebalance = s.Rebalance - other.Rebalance
0000000000000000000000000000000000000000;;		diff.RebalanceTime = s.RebalanceTime - other.RebalanceTime
0000000000000000000000000000000000000000;;		diff.Split = s.Split - other.Split
0000000000000000000000000000000000000000;;		diff.Spill = s.Spill - other.Spill
0000000000000000000000000000000000000000;;		diff.SpillTime = s.SpillTime - other.SpillTime
0000000000000000000000000000000000000000;;		diff.Write = s.Write - other.Write
0000000000000000000000000000000000000000;;		diff.WriteTime = s.WriteTime - other.WriteTime
0000000000000000000000000000000000000000;;		return diff
0000000000000000000000000000000000000000;;	}
