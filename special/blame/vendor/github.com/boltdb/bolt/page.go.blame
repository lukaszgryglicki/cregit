0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/page.go[Godeps/_workspace/src/github.com/boltdb/bolt/page.go][vendor/github.com/boltdb/bolt/page.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const pageHeaderSize = int(unsafe.Offsetof(((*page)(nil)).ptr))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const minKeysPerPage = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const branchPageElementSize = int(unsafe.Sizeof(branchPageElement{}))
0000000000000000000000000000000000000000;;	const leafPageElementSize = int(unsafe.Sizeof(leafPageElement{}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		branchPageFlag   = 0x01
0000000000000000000000000000000000000000;;		leafPageFlag     = 0x02
0000000000000000000000000000000000000000;;		metaPageFlag     = 0x04
0000000000000000000000000000000000000000;;		freelistPageFlag = 0x10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		bucketLeafFlag = 0x01
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pgid uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type page struct {
0000000000000000000000000000000000000000;;		id       pgid
0000000000000000000000000000000000000000;;		flags    uint16
0000000000000000000000000000000000000000;;		count    uint16
0000000000000000000000000000000000000000;;		overflow uint32
0000000000000000000000000000000000000000;;		ptr      uintptr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typ returns a human readable page type string used for debugging.
0000000000000000000000000000000000000000;;	func (p *page) typ() string {
0000000000000000000000000000000000000000;;		if (p.flags & branchPageFlag) != 0 {
0000000000000000000000000000000000000000;;			return "branch"
0000000000000000000000000000000000000000;;		} else if (p.flags & leafPageFlag) != 0 {
0000000000000000000000000000000000000000;;			return "leaf"
0000000000000000000000000000000000000000;;		} else if (p.flags & metaPageFlag) != 0 {
0000000000000000000000000000000000000000;;			return "meta"
0000000000000000000000000000000000000000;;		} else if (p.flags & freelistPageFlag) != 0 {
0000000000000000000000000000000000000000;;			return "freelist"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("unknown<%02x>", p.flags)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// meta returns a pointer to the metadata section of the page.
0000000000000000000000000000000000000000;;	func (p *page) meta() *meta {
0000000000000000000000000000000000000000;;		return (*meta)(unsafe.Pointer(&p.ptr))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// leafPageElement retrieves the leaf node by index
0000000000000000000000000000000000000000;;	func (p *page) leafPageElement(index uint16) *leafPageElement {
0000000000000000000000000000000000000000;;		n := &((*[0x7FFFFFF]leafPageElement)(unsafe.Pointer(&p.ptr)))[index]
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// leafPageElements retrieves a list of leaf nodes.
0000000000000000000000000000000000000000;;	func (p *page) leafPageElements() []leafPageElement {
0000000000000000000000000000000000000000;;		if p.count == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ((*[0x7FFFFFF]leafPageElement)(unsafe.Pointer(&p.ptr)))[:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// branchPageElement retrieves the branch node by index
0000000000000000000000000000000000000000;;	func (p *page) branchPageElement(index uint16) *branchPageElement {
0000000000000000000000000000000000000000;;		return &((*[0x7FFFFFF]branchPageElement)(unsafe.Pointer(&p.ptr)))[index]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// branchPageElements retrieves a list of branch nodes.
0000000000000000000000000000000000000000;;	func (p *page) branchPageElements() []branchPageElement {
0000000000000000000000000000000000000000;;		if p.count == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ((*[0x7FFFFFF]branchPageElement)(unsafe.Pointer(&p.ptr)))[:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dump writes n bytes of the page to STDERR as hex output.
0000000000000000000000000000000000000000;;	func (p *page) hexdump(n int) {
0000000000000000000000000000000000000000;;		buf := (*[maxAllocSize]byte)(unsafe.Pointer(p))[:n]
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "%x\n", buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pages []*page
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s pages) Len() int           { return len(s) }
0000000000000000000000000000000000000000;;	func (s pages) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s pages) Less(i, j int) bool { return s[i].id < s[j].id }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// branchPageElement represents a node on a branch page.
0000000000000000000000000000000000000000;;	type branchPageElement struct {
0000000000000000000000000000000000000000;;		pos   uint32
0000000000000000000000000000000000000000;;		ksize uint32
0000000000000000000000000000000000000000;;		pgid  pgid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// key returns a byte slice of the node key.
0000000000000000000000000000000000000000;;	func (n *branchPageElement) key() []byte {
0000000000000000000000000000000000000000;;		buf := (*[maxAllocSize]byte)(unsafe.Pointer(n))
0000000000000000000000000000000000000000;;		return (*[maxAllocSize]byte)(unsafe.Pointer(&buf[n.pos]))[:n.ksize]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// leafPageElement represents a node on a leaf page.
0000000000000000000000000000000000000000;;	type leafPageElement struct {
0000000000000000000000000000000000000000;;		flags uint32
0000000000000000000000000000000000000000;;		pos   uint32
0000000000000000000000000000000000000000;;		ksize uint32
0000000000000000000000000000000000000000;;		vsize uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// key returns a byte slice of the node key.
0000000000000000000000000000000000000000;;	func (n *leafPageElement) key() []byte {
0000000000000000000000000000000000000000;;		buf := (*[maxAllocSize]byte)(unsafe.Pointer(n))
0000000000000000000000000000000000000000;;		return (*[maxAllocSize]byte)(unsafe.Pointer(&buf[n.pos]))[:n.ksize:n.ksize]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// value returns a byte slice of the node value.
0000000000000000000000000000000000000000;;	func (n *leafPageElement) value() []byte {
0000000000000000000000000000000000000000;;		buf := (*[maxAllocSize]byte)(unsafe.Pointer(n))
0000000000000000000000000000000000000000;;		return (*[maxAllocSize]byte)(unsafe.Pointer(&buf[n.pos+n.ksize]))[:n.vsize:n.vsize]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PageInfo represents human readable information about a page.
0000000000000000000000000000000000000000;;	type PageInfo struct {
0000000000000000000000000000000000000000;;		ID            int
0000000000000000000000000000000000000000;;		Type          string
0000000000000000000000000000000000000000;;		Count         int
0000000000000000000000000000000000000000;;		OverflowCount int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pgids []pgid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s pgids) Len() int           { return len(s) }
0000000000000000000000000000000000000000;;	func (s pgids) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s pgids) Less(i, j int) bool { return s[i] < s[j] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// merge returns the sorted union of a and b.
0000000000000000000000000000000000000000;;	func (a pgids) merge(b pgids) pgids {
0000000000000000000000000000000000000000;;		// Return the opposite slice if one is nil.
0000000000000000000000000000000000000000;;		if len(a) == 0 {
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		} else if len(b) == 0 {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a list to hold all elements from both lists.
0000000000000000000000000000000000000000;;		merged := make(pgids, 0, len(a)+len(b))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assign lead to the slice with a lower starting value, follow to the higher value.
0000000000000000000000000000000000000000;;		lead, follow := a, b
0000000000000000000000000000000000000000;;		if b[0] < a[0] {
0000000000000000000000000000000000000000;;			lead, follow = b, a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Continue while there are elements in the lead.
0000000000000000000000000000000000000000;;		for len(lead) > 0 {
0000000000000000000000000000000000000000;;			// Merge largest prefix of lead that is ahead of follow[0].
0000000000000000000000000000000000000000;;			n := sort.Search(len(lead), func(i int) bool { return lead[i] > follow[0] })
0000000000000000000000000000000000000000;;			merged = append(merged, lead[:n]...)
0000000000000000000000000000000000000000;;			if n >= len(lead) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Swap lead and follow.
0000000000000000000000000000000000000000;;			lead, follow = follow, lead[n:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Append what's left in follow.
0000000000000000000000000000000000000000;;		merged = append(merged, follow...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return merged
0000000000000000000000000000000000000000;;	}
