0000000000000000000000000000000000000000;;	Bolt [![Coverage Status](https://coveralls.io/repos/boltdb/bolt/badge.svg?branch=master)](https://coveralls.io/r/boltdb/bolt?branch=master) [![GoDoc](https://godoc.org/github.com/boltdb/bolt?status.svg)](https://godoc.org/github.com/boltdb/bolt) ![Version](https://img.shields.io/badge/version-1.2.1-green.svg)
0000000000000000000000000000000000000000;;	====
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt is a pure Go key/value store inspired by [Howard Chu's][hyc_symas]
0000000000000000000000000000000000000000;;	[LMDB project][lmdb]. The goal of the project is to provide a simple,
0000000000000000000000000000000000000000;;	fast, and reliable database for projects that don't require a full database
0000000000000000000000000000000000000000;;	server such as Postgres or MySQL.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Since Bolt is meant to be used as such a low-level piece of functionality,
0000000000000000000000000000000000000000;;	simplicity is key. The API will be small and only focus on getting values
0000000000000000000000000000000000000000;;	and setting values. That's it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[hyc_symas]: https://twitter.com/hyc_symas
0000000000000000000000000000000000000000;;	[lmdb]: http://symas.com/mdb/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Project Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt is stable and the API is fixed. Full unit test coverage and randomized
0000000000000000000000000000000000000000;;	black box testing are used to ensure database consistency and thread safety.
0000000000000000000000000000000000000000;;	Bolt is currently in high-load production environments serving databases as
0000000000000000000000000000000000000000;;	large as 1TB. Many companies such as Shopify and Heroku use Bolt-backed
0000000000000000000000000000000000000000;;	services every day.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Table of Contents
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- [Getting Started](#getting-started)
0000000000000000000000000000000000000000;;	  - [Installing](#installing)
0000000000000000000000000000000000000000;;	  - [Opening a database](#opening-a-database)
0000000000000000000000000000000000000000;;	  - [Transactions](#transactions)
0000000000000000000000000000000000000000;;	    - [Read-write transactions](#read-write-transactions)
0000000000000000000000000000000000000000;;	    - [Read-only transactions](#read-only-transactions)
0000000000000000000000000000000000000000;;	    - [Batch read-write transactions](#batch-read-write-transactions)
0000000000000000000000000000000000000000;;	    - [Managing transactions manually](#managing-transactions-manually)
0000000000000000000000000000000000000000;;	  - [Using buckets](#using-buckets)
0000000000000000000000000000000000000000;;	  - [Using key/value pairs](#using-keyvalue-pairs)
0000000000000000000000000000000000000000;;	  - [Autoincrementing integer for the bucket](#autoincrementing-integer-for-the-bucket)
0000000000000000000000000000000000000000;;	  - [Iterating over keys](#iterating-over-keys)
0000000000000000000000000000000000000000;;	    - [Prefix scans](#prefix-scans)
0000000000000000000000000000000000000000;;	    - [Range scans](#range-scans)
0000000000000000000000000000000000000000;;	    - [ForEach()](#foreach)
0000000000000000000000000000000000000000;;	  - [Nested buckets](#nested-buckets)
0000000000000000000000000000000000000000;;	  - [Database backups](#database-backups)
0000000000000000000000000000000000000000;;	  - [Statistics](#statistics)
0000000000000000000000000000000000000000;;	  - [Read-Only Mode](#read-only-mode)
0000000000000000000000000000000000000000;;	  - [Mobile Use (iOS/Android)](#mobile-use-iosandroid)
0000000000000000000000000000000000000000;;	- [Resources](#resources)
0000000000000000000000000000000000000000;;	- [Comparison with other databases](#comparison-with-other-databases)
0000000000000000000000000000000000000000;;	  - [Postgres, MySQL, & other relational databases](#postgres-mysql--other-relational-databases)
0000000000000000000000000000000000000000;;	  - [LevelDB, RocksDB](#leveldb-rocksdb)
0000000000000000000000000000000000000000;;	  - [LMDB](#lmdb)
0000000000000000000000000000000000000000;;	- [Caveats & Limitations](#caveats--limitations)
0000000000000000000000000000000000000000;;	- [Reading the Source](#reading-the-source)
0000000000000000000000000000000000000000;;	- [Other Projects Using Bolt](#other-projects-using-bolt)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Getting Started
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Installing
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To start using Bolt, install Go and run `go get`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```sh
0000000000000000000000000000000000000000;;	$ go get github.com/boltdb/bolt/...
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This will retrieve the library and install the `bolt` command line utility into
0000000000000000000000000000000000000000;;	your `$GOBIN` path.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Opening a database
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The top-level object in Bolt is a `DB`. It is represented as a single file on
0000000000000000000000000000000000000000;;	your disk and represents a consistent snapshot of your data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To open your database, simply use the `bolt.Open()` function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/boltdb/bolt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;		// Open the my.db data file in your current directory.
0000000000000000000000000000000000000000;;		// It will be created if it doesn't exist.
0000000000000000000000000000000000000000;;		db, err := bolt.Open("my.db", 0600, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer db.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Please note that Bolt obtains a file lock on the data file so multiple processes
0000000000000000000000000000000000000000;;	cannot open the same database at the same time. Opening an already open Bolt
0000000000000000000000000000000000000000;;	database will cause it to hang until the other process closes it. To prevent
0000000000000000000000000000000000000000;;	an indefinite wait you can pass a timeout option to the `Open()` function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db, err := bolt.Open("my.db", 0600, &bolt.Options{Timeout: 1 * time.Second})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Transactions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt allows only one read-write transaction at a time but allows as many
0000000000000000000000000000000000000000;;	read-only transactions as you want at a time. Each transaction has a consistent
0000000000000000000000000000000000000000;;	view of the data as it existed when the transaction started.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Individual transactions and all objects created from them (e.g. buckets, keys)
0000000000000000000000000000000000000000;;	are not thread safe. To work with data in multiple goroutines you must start
0000000000000000000000000000000000000000;;	a transaction for each one or use locking to ensure only one goroutine accesses
0000000000000000000000000000000000000000;;	a transaction at a time. Creating transaction from the `DB` is thread safe.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Read-only transactions and read-write transactions should not depend on one
0000000000000000000000000000000000000000;;	another and generally shouldn't be opened simultaneously in the same goroutine.
0000000000000000000000000000000000000000;;	This can cause a deadlock as the read-write transaction needs to periodically
0000000000000000000000000000000000000000;;	re-map the data file but it cannot do so while a read-only transaction is open.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Read-write transactions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To start a read-write transaction, you can use the `DB.Update()` function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := db.Update(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Inside the closure, you have a consistent view of the database. You commit the
0000000000000000000000000000000000000000;;	transaction by returning `nil` at the end. You can also rollback the transaction
0000000000000000000000000000000000000000;;	at any point by returning an error. All database operations are allowed inside
0000000000000000000000000000000000000000;;	a read-write transaction.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Always check the return error as it will report any disk failures that can cause
0000000000000000000000000000000000000000;;	your transaction to not complete. If you return an error within your closure
0000000000000000000000000000000000000000;;	it will be passed through.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Read-only transactions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To start a read-only transaction, you can use the `DB.View()` function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You also get a consistent view of the database within this closure, however,
0000000000000000000000000000000000000000;;	no mutating operations are allowed within a read-only transaction. You can only
0000000000000000000000000000000000000000;;	retrieve buckets, retrieve values, and copy the database within a read-only
0000000000000000000000000000000000000000;;	transaction.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Batch read-write transactions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Each `DB.Update()` waits for disk to commit the writes. This overhead
0000000000000000000000000000000000000000;;	can be minimized by combining multiple updates with the `DB.Batch()`
0000000000000000000000000000000000000000;;	function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	err := db.Batch(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Concurrent Batch calls are opportunistically combined into larger
0000000000000000000000000000000000000000;;	transactions. Batch is only useful when there are multiple goroutines
0000000000000000000000000000000000000000;;	calling it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The trade-off is that `Batch` can call the given
0000000000000000000000000000000000000000;;	function multiple times, if parts of the transaction fail. The
0000000000000000000000000000000000000000;;	function must be idempotent and side effects must take effect only
0000000000000000000000000000000000000000;;	after a successful return from `DB.Batch()`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example: don't display messages from inside the function, instead
0000000000000000000000000000000000000000;;	set variables in the enclosing scope:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	var id uint64
0000000000000000000000000000000000000000;;	err := db.Batch(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		// Find last key in bucket, decode as bigendian uint64, increment
0000000000000000000000000000000000000000;;		// by one, encode back to []byte, and add new key.
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;		id = newValue
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		return ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	fmt.Println("Allocated ID %d", id)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Managing transactions manually
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `DB.View()` and `DB.Update()` functions are wrappers around the `DB.Begin()`
0000000000000000000000000000000000000000;;	function. These helper functions will start the transaction, execute a function,
0000000000000000000000000000000000000000;;	and then safely close your transaction if an error is returned. This is the
0000000000000000000000000000000000000000;;	recommended way to use Bolt transactions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	However, sometimes you may want to manually start and end your transactions.
0000000000000000000000000000000000000000;;	You can use the `Tx.Begin()` function directly but **please** be sure to close
0000000000000000000000000000000000000000;;	the transaction.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// Start a writable transaction.
0000000000000000000000000000000000000000;;	tx, err := db.Begin(true)
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;	    return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	defer tx.Rollback()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Use the transaction...
0000000000000000000000000000000000000000;;	_, err := tx.CreateBucket([]byte("MyBucket"))
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;	    return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Commit the transaction and check for error.
0000000000000000000000000000000000000000;;	if err := tx.Commit(); err != nil {
0000000000000000000000000000000000000000;;	    return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The first argument to `DB.Begin()` is a boolean stating if the transaction
0000000000000000000000000000000000000000;;	should be writable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Using buckets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Buckets are collections of key/value pairs within the database. All keys in a
0000000000000000000000000000000000000000;;	bucket must be unique. You can create a bucket using the `DB.CreateBucket()`
0000000000000000000000000000000000000000;;	function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db.Update(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		b, err := tx.CreateBucket([]byte("MyBucket"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("create bucket: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also create a bucket only if it doesn't exist by using the
0000000000000000000000000000000000000000;;	`Tx.CreateBucketIfNotExists()` function. It's a common pattern to call this
0000000000000000000000000000000000000000;;	function for all your top-level buckets after you open your database so you can
0000000000000000000000000000000000000000;;	guarantee that they exist for future transactions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To delete a bucket, simply call the `Tx.DeleteBucket()` function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Using key/value pairs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To save a key/value pair to a bucket, use the `Bucket.Put()` function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db.Update(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		b := tx.Bucket([]byte("MyBucket"))
0000000000000000000000000000000000000000;;		err := b.Put([]byte("answer"), []byte("42"))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This will set the value of the `"answer"` key to `"42"` in the `MyBucket`
0000000000000000000000000000000000000000;;	bucket. To retrieve this value, we can use the `Bucket.Get()` function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		b := tx.Bucket([]byte("MyBucket"))
0000000000000000000000000000000000000000;;		v := b.Get([]byte("answer"))
0000000000000000000000000000000000000000;;		fmt.Printf("The answer is: %s\n", v)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `Get()` function does not return an error because its operation is
0000000000000000000000000000000000000000;;	guaranteed to work (unless there is some kind of system failure). If the key
0000000000000000000000000000000000000000;;	exists then it will return its byte slice value. If it doesn't exist then it
0000000000000000000000000000000000000000;;	will return `nil`. It's important to note that you can have a zero-length value
0000000000000000000000000000000000000000;;	set to a key which is different than the key not existing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Use the `Bucket.Delete()` function to delete a key from the bucket.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Please note that values returned from `Get()` are only valid while the
0000000000000000000000000000000000000000;;	transaction is open. If you need to use a value outside of the transaction
0000000000000000000000000000000000000000;;	then you must use `copy()` to copy it to another byte slice.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Autoincrementing integer for the bucket
0000000000000000000000000000000000000000;;	By using the `NextSequence()` function, you can let Bolt determine a sequence
0000000000000000000000000000000000000000;;	which can be used as the unique identifier for your key/value pairs. See the
0000000000000000000000000000000000000000;;	example below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	// CreateUser saves u to the store. The new user ID is set on u once the data is persisted.
0000000000000000000000000000000000000000;;	func (s *Store) CreateUser(u *User) error {
0000000000000000000000000000000000000000;;	    return s.db.Update(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;	        // Retrieve the users bucket.
0000000000000000000000000000000000000000;;	        // This should be created when the DB is first opened.
0000000000000000000000000000000000000000;;	        b := tx.Bucket([]byte("users"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        // Generate ID for the user.
0000000000000000000000000000000000000000;;	        // This returns an error only if the Tx is closed or not writeable.
0000000000000000000000000000000000000000;;	        // That can't happen in an Update() call so I ignore the error check.
0000000000000000000000000000000000000000;;	        id, _ := b.NextSequence()
0000000000000000000000000000000000000000;;	        u.ID = int(id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        // Marshal user data into bytes.
0000000000000000000000000000000000000000;;	        buf, err := json.Marshal(u)
0000000000000000000000000000000000000000;;	        if err != nil {
0000000000000000000000000000000000000000;;	            return err
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        // Persist bytes to users bucket.
0000000000000000000000000000000000000000;;	        return b.Put(itob(u.ID), buf)
0000000000000000000000000000000000000000;;	    })
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// itob returns an 8-byte big endian representation of v.
0000000000000000000000000000000000000000;;	func itob(v int) []byte {
0000000000000000000000000000000000000000;;	    b := make([]byte, 8)
0000000000000000000000000000000000000000;;	    binary.BigEndian.PutUint64(b, uint64(v))
0000000000000000000000000000000000000000;;	    return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type User struct {
0000000000000000000000000000000000000000;;	    ID int
0000000000000000000000000000000000000000;;	    ...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Iterating over keys
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt stores its keys in byte-sorted order within a bucket. This makes sequential
0000000000000000000000000000000000000000;;	iteration over these keys extremely fast. To iterate over keys we'll use a
0000000000000000000000000000000000000000;;	`Cursor`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		// Assume bucket exists and has keys
0000000000000000000000000000000000000000;;		b := tx.Bucket([]byte("MyBucket"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := b.Cursor()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := c.First(); k != nil; k, v = c.Next() {
0000000000000000000000000000000000000000;;			fmt.Printf("key=%s, value=%s\n", k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The cursor allows you to move to a specific point in the list of keys and move
0000000000000000000000000000000000000000;;	forward or backward through the keys one at a time.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following functions are available on the cursor:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	First()  Move to the first key.
0000000000000000000000000000000000000000;;	Last()   Move to the last key.
0000000000000000000000000000000000000000;;	Seek()   Move to a specific key.
0000000000000000000000000000000000000000;;	Next()   Move to the next key.
0000000000000000000000000000000000000000;;	Prev()   Move to the previous key.
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Each of those functions has a return signature of `(key []byte, value []byte)`.
0000000000000000000000000000000000000000;;	When you have iterated to the end of the cursor then `Next()` will return a
0000000000000000000000000000000000000000;;	`nil` key.  You must seek to a position using `First()`, `Last()`, or `Seek()`
0000000000000000000000000000000000000000;;	before calling `Next()` or `Prev()`. If you do not seek to a position then
0000000000000000000000000000000000000000;;	these functions will return a `nil` key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	During iteration, if the key is non-`nil` but the value is `nil`, that means
0000000000000000000000000000000000000000;;	the key refers to a bucket rather than a value.  Use `Bucket.Bucket()` to
0000000000000000000000000000000000000000;;	access the sub-bucket.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Prefix scans
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To iterate over a key prefix, you can combine `Seek()` and `bytes.HasPrefix()`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		// Assume bucket exists and has keys
0000000000000000000000000000000000000000;;		c := tx.Bucket([]byte("MyBucket")).Cursor()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prefix := []byte("1234")
0000000000000000000000000000000000000000;;		for k, v := c.Seek(prefix); bytes.HasPrefix(k, prefix); k, v = c.Next() {
0000000000000000000000000000000000000000;;			fmt.Printf("key=%s, value=%s\n", k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Range scans
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Another common use case is scanning over a range such as a time range. If you
0000000000000000000000000000000000000000;;	use a sortable time encoding such as RFC3339 then you can query a specific
0000000000000000000000000000000000000000;;	date range like this:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		// Assume our events bucket exists and has RFC3339 encoded time keys.
0000000000000000000000000000000000000000;;		c := tx.Bucket([]byte("Events")).Cursor()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Our time range spans the 90's decade.
0000000000000000000000000000000000000000;;		min := []byte("1990-01-01T00:00:00Z")
0000000000000000000000000000000000000000;;		max := []byte("2000-01-01T00:00:00Z")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Iterate over the 90's.
0000000000000000000000000000000000000000;;		for k, v := c.Seek(min); k != nil && bytes.Compare(k, max) <= 0; k, v = c.Next() {
0000000000000000000000000000000000000000;;			fmt.Printf("%s: %s\n", k, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note that, while RFC3339 is sortable, the Golang implementation of RFC3339Nano does not use a fixed number of digits after the decimal point and is therefore not sortable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### ForEach()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also use the function `ForEach()` if you know you'll be iterating over
0000000000000000000000000000000000000000;;	all the keys in a bucket:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;		// Assume bucket exists and has keys
0000000000000000000000000000000000000000;;		b := tx.Bucket([]byte("MyBucket"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b.ForEach(func(k, v []byte) error {
0000000000000000000000000000000000000000;;			fmt.Printf("key=%s, value=%s\n", k, v)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	})
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Nested buckets
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also store a bucket in a key to create nested buckets. The API is the
0000000000000000000000000000000000000000;;	same as the bucket management API on the `DB` object:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func (*Bucket) CreateBucket(key []byte) (*Bucket, error)
0000000000000000000000000000000000000000;;	func (*Bucket) CreateBucketIfNotExists(key []byte) (*Bucket, error)
0000000000000000000000000000000000000000;;	func (*Bucket) DeleteBucket(key []byte) error
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Database backups
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt is a single file so it's easy to backup. You can use the `Tx.WriteTo()`
0000000000000000000000000000000000000000;;	function to write a consistent view of the database to a writer. If you call
0000000000000000000000000000000000000000;;	this from a read-only transaction, it will perform a hot backup and not block
0000000000000000000000000000000000000000;;	your other database reads and writes.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	By default, it will use a regular file handle which will utilize the operating
0000000000000000000000000000000000000000;;	system's page cache. See the [`Tx`](https://godoc.org/github.com/boltdb/bolt#Tx)
0000000000000000000000000000000000000000;;	documentation for information about optimizing for larger-than-RAM datasets.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	One common use case is to backup over HTTP so you can use tools like `cURL` to
0000000000000000000000000000000000000000;;	do database backups:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func BackupHandleFunc(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		err := db.View(func(tx *bolt.Tx) error {
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Type", "application/octet-stream")
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Disposition", `attachment; filename="my.db"`)
0000000000000000000000000000000000000000;;			w.Header().Set("Content-Length", strconv.Itoa(int(tx.Size())))
0000000000000000000000000000000000000000;;			_, err := tx.WriteTo(w)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then you can backup using this command:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```sh
0000000000000000000000000000000000000000;;	$ curl http://localhost/backup > my.db
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Or you can open your browser to `http://localhost/backup` and it will download
0000000000000000000000000000000000000000;;	automatically.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you want to backup to another file you can use the `Tx.CopyFile()` helper
0000000000000000000000000000000000000000;;	function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Statistics
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The database keeps a running count of many of the internal operations it
0000000000000000000000000000000000000000;;	performs so you can better understand what's going on. By grabbing a snapshot
0000000000000000000000000000000000000000;;	of these stats at two points in time we can see what operations were performed
0000000000000000000000000000000000000000;;	in that time range.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example, we could start a goroutine to log stats every 10 seconds:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	go func() {
0000000000000000000000000000000000000000;;		// Grab the initial stats.
0000000000000000000000000000000000000000;;		prev := db.Stats()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Wait for 10s.
0000000000000000000000000000000000000000;;			time.Sleep(10 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Grab the current stats and diff them.
0000000000000000000000000000000000000000;;			stats := db.Stats()
0000000000000000000000000000000000000000;;			diff := stats.Sub(&prev)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Encode stats to JSON and print to STDERR.
0000000000000000000000000000000000000000;;			json.NewEncoder(os.Stderr).Encode(diff)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Save stats for the next loop.
0000000000000000000000000000000000000000;;			prev = stats
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}()
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It's also useful to pipe these stats to a service such as statsd for monitoring
0000000000000000000000000000000000000000;;	or to provide an HTTP endpoint that will perform a fixed-length sample.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Read-Only Mode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Sometimes it is useful to create a shared, read-only Bolt database. To this,
0000000000000000000000000000000000000000;;	set the `Options.ReadOnly` flag when opening your database. Read-only mode
0000000000000000000000000000000000000000;;	uses a shared lock to allow multiple processes to read from the database but
0000000000000000000000000000000000000000;;	it will block any processes from opening the database in read-write mode.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	db, err := bolt.Open("my.db", 0666, &bolt.Options{ReadOnly: true})
0000000000000000000000000000000000000000;;	if err != nil {
0000000000000000000000000000000000000000;;		log.Fatal(err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Mobile Use (iOS/Android)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt is able to run on mobile devices by leveraging the binding feature of the
0000000000000000000000000000000000000000;;	[gomobile](https://github.com/golang/mobile) tool. Create a struct that will
0000000000000000000000000000000000000000;;	contain your database logic and a reference to a `*bolt.DB` with a initializing
0000000000000000000000000000000000000000;;	constructor that takes in a filepath where the database file will be stored.
0000000000000000000000000000000000000000;;	Neither Android nor iOS require extra permissions or cleanup from using this method.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	func NewBoltDB(filepath string) *BoltDB {
0000000000000000000000000000000000000000;;		db, err := bolt.Open(filepath+"/demo.db", 0600, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			log.Fatal(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &BoltDB{db}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type BoltDB struct {
0000000000000000000000000000000000000000;;		db *bolt.DB
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BoltDB) Path() string {
0000000000000000000000000000000000000000;;		return b.db.Path()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *BoltDB) Close() {
0000000000000000000000000000000000000000;;		b.db.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Database logic should be defined as methods on this wrapper struct.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To initialize this struct from the native language (both platforms now sync
0000000000000000000000000000000000000000;;	their local storage to the cloud. These snippets disable that functionality for the
0000000000000000000000000000000000000000;;	database file):
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### Android
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```java
0000000000000000000000000000000000000000;;	String path;
0000000000000000000000000000000000000000;;	if (android.os.Build.VERSION.SDK_INT >=android.os.Build.VERSION_CODES.LOLLIPOP){
0000000000000000000000000000000000000000;;	    path = getNoBackupFilesDir().getAbsolutePath();
0000000000000000000000000000000000000000;;	} else{
0000000000000000000000000000000000000000;;	    path = getFilesDir().getAbsolutePath();
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	Boltmobiledemo.BoltDB boltDB = Boltmobiledemo.NewBoltDB(path)
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#### iOS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```objc
0000000000000000000000000000000000000000;;	- (void)demo {
0000000000000000000000000000000000000000;;	    NSString* path = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,
0000000000000000000000000000000000000000;;	                                                          NSUserDomainMask,
0000000000000000000000000000000000000000;;	                                                          YES) objectAtIndex:0];
0000000000000000000000000000000000000000;;		GoBoltmobiledemoBoltDB * demo = GoBoltmobiledemoNewBoltDB(path);
0000000000000000000000000000000000000000;;		[self addSkipBackupAttributeToItemAtPath:demo.path];
0000000000000000000000000000000000000000;;		//Some DB Logic would go here
0000000000000000000000000000000000000000;;		[demo close];
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- (BOOL)addSkipBackupAttributeToItemAtPath:(NSString *) filePathString
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	    NSURL* URL= [NSURL fileURLWithPath: filePathString];
0000000000000000000000000000000000000000;;	    assert([[NSFileManager defaultManager] fileExistsAtPath: [URL path]]);
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    NSError *error = nil;
0000000000000000000000000000000000000000;;	    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]
0000000000000000000000000000000000000000;;	                                  forKey: NSURLIsExcludedFromBackupKey error: &error];
0000000000000000000000000000000000000000;;	    if(!success){
0000000000000000000000000000000000000000;;	        NSLog(@"Error excluding %@ from backup %@", [URL lastPathComponent], error);
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	    return success;
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Resources
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For more information on getting started with Bolt, check out the following articles:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [Intro to BoltDB: Painless Performant Persistence](http://npf.io/2014/07/intro-to-boltdb-painless-performant-persistence/) by [Nate Finch](https://github.com/natefinch).
0000000000000000000000000000000000000000;;	* [Bolt -- an embedded key/value database for Go](https://www.progville.com/go/bolt-embedded-db-golang/) by Progville
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Comparison with other databases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### Postgres, MySQL, & other relational databases
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Relational databases structure data into rows and are only accessible through
0000000000000000000000000000000000000000;;	the use of SQL. This approach provides flexibility in how you store and query
0000000000000000000000000000000000000000;;	your data but also incurs overhead in parsing and planning SQL statements. Bolt
0000000000000000000000000000000000000000;;	accesses all data by a byte slice key. This makes Bolt fast to read and write
0000000000000000000000000000000000000000;;	data by key but provides no built-in support for joining values together.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Most relational databases (with the exception of SQLite) are standalone servers
0000000000000000000000000000000000000000;;	that run separately from your application. This gives your systems
0000000000000000000000000000000000000000;;	flexibility to connect multiple application servers to a single database
0000000000000000000000000000000000000000;;	server but also adds overhead in serializing and transporting data over the
0000000000000000000000000000000000000000;;	network. Bolt runs as a library included in your application so all data access
0000000000000000000000000000000000000000;;	has to go through your application's process. This brings data closer to your
0000000000000000000000000000000000000000;;	application but limits multi-process access to the data.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### LevelDB, RocksDB
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	LevelDB and its derivatives (RocksDB, HyperLevelDB) are similar to Bolt in that
0000000000000000000000000000000000000000;;	they are libraries bundled into the application, however, their underlying
0000000000000000000000000000000000000000;;	structure is a log-structured merge-tree (LSM tree). An LSM tree optimizes
0000000000000000000000000000000000000000;;	random writes by using a write ahead log and multi-tiered, sorted files called
0000000000000000000000000000000000000000;;	SSTables. Bolt uses a B+tree internally and only a single file. Both approaches
0000000000000000000000000000000000000000;;	have trade-offs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you require a high random write throughput (>10,000 w/sec) or you need to use
0000000000000000000000000000000000000000;;	spinning disks then LevelDB could be a good choice. If your application is
0000000000000000000000000000000000000000;;	read-heavy or does a lot of range scans then Bolt could be a good choice.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	One other important consideration is that LevelDB does not have transactions.
0000000000000000000000000000000000000000;;	It supports batch writing of key/values pairs and it supports read snapshots
0000000000000000000000000000000000000000;;	but it will not give you the ability to do a compare-and-swap operation safely.
0000000000000000000000000000000000000000;;	Bolt supports fully serializable ACID transactions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	### LMDB
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt was originally a port of LMDB so it is architecturally similar. Both use
0000000000000000000000000000000000000000;;	a B+tree, have ACID semantics with fully serializable transactions, and support
0000000000000000000000000000000000000000;;	lock-free MVCC using a single writer and multiple readers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The two projects have somewhat diverged. LMDB heavily focuses on raw performance
0000000000000000000000000000000000000000;;	while Bolt has focused on simplicity and ease of use. For example, LMDB allows
0000000000000000000000000000000000000000;;	several unsafe actions such as direct writes for the sake of performance. Bolt
0000000000000000000000000000000000000000;;	opts to disallow actions which can leave the database in a corrupted state. The
0000000000000000000000000000000000000000;;	only exception to this in Bolt is `DB.NoSync`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are also a few differences in API. LMDB requires a maximum mmap size when
0000000000000000000000000000000000000000;;	opening an `mdb_env` whereas Bolt will handle incremental mmap resizing
0000000000000000000000000000000000000000;;	automatically. LMDB overloads the getter and setter functions with multiple
0000000000000000000000000000000000000000;;	flags whereas Bolt splits these specialized cases into their own functions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Caveats & Limitations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It's important to pick the right tool for the job and Bolt is no exception.
0000000000000000000000000000000000000000;;	Here are a few things to note when evaluating and using Bolt:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Bolt is good for read intensive workloads. Sequential write performance is
0000000000000000000000000000000000000000;;	  also fast but random writes can be slow. You can use `DB.Batch()` or add a
0000000000000000000000000000000000000000;;	  write-ahead log to help mitigate this issue.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Bolt uses a B+tree internally so there can be a lot of random page access.
0000000000000000000000000000000000000000;;	  SSDs provide a significant performance boost over spinning disks.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Try to avoid long running read transactions. Bolt uses copy-on-write so
0000000000000000000000000000000000000000;;	  old pages cannot be reclaimed while an old transaction is using them.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Byte slices returned from Bolt are only valid during a transaction. Once the
0000000000000000000000000000000000000000;;	  transaction has been committed or rolled back then the memory they point to
0000000000000000000000000000000000000000;;	  can be reused by a new page or can be unmapped from virtual memory and you'll
0000000000000000000000000000000000000000;;	  see an `unexpected fault address` panic when accessing it.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Be careful when using `Bucket.FillPercent`. Setting a high fill percent for
0000000000000000000000000000000000000000;;	  buckets that have random inserts will cause your database to have very poor
0000000000000000000000000000000000000000;;	  page utilization.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Use larger buckets in general. Smaller buckets causes poor page utilization
0000000000000000000000000000000000000000;;	  once they become larger than the page size (typically 4KB).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Bulk loading a lot of random writes into a new bucket can be slow as the
0000000000000000000000000000000000000000;;	  page will not split until the transaction is committed. Randomly inserting
0000000000000000000000000000000000000000;;	  more than 100,000 key/value pairs into a single new bucket in a single
0000000000000000000000000000000000000000;;	  transaction is not advised.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Bolt uses a memory-mapped file so the underlying operating system handles the
0000000000000000000000000000000000000000;;	  caching of the data. Typically, the OS will cache as much of the file as it
0000000000000000000000000000000000000000;;	  can in memory and will release memory as needed to other processes. This means
0000000000000000000000000000000000000000;;	  that Bolt can show very high memory usage when working with large databases.
0000000000000000000000000000000000000000;;	  However, this is expected and the OS will release memory as needed. Bolt can
0000000000000000000000000000000000000000;;	  handle databases much larger than the available physical RAM, provided its
0000000000000000000000000000000000000000;;	  memory-map fits in the process virtual address space. It may be problematic
0000000000000000000000000000000000000000;;	  on 32-bits systems.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* The data structures in the Bolt database are memory mapped so the data file
0000000000000000000000000000000000000000;;	  will be endian specific. This means that you cannot copy a Bolt file from a
0000000000000000000000000000000000000000;;	  little endian machine to a big endian machine and have it work. For most
0000000000000000000000000000000000000000;;	  users this is not a concern since most modern CPUs are little endian.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Because of the way pages are laid out on disk, Bolt cannot truncate data files
0000000000000000000000000000000000000000;;	  and return free pages back to the disk. Instead, Bolt maintains a free list
0000000000000000000000000000000000000000;;	  of unused pages within its data file. These free pages can be reused by later
0000000000000000000000000000000000000000;;	  transactions. This works well for many use cases as databases generally tend
0000000000000000000000000000000000000000;;	  to grow. However, it's important to note that deleting large chunks of data
0000000000000000000000000000000000000000;;	  will not allow you to reclaim that space on disk.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  For more information on page allocation, [see this comment][page-allocation].
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[page-allocation]: https://github.com/boltdb/bolt/issues/308#issuecomment-74811638
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Reading the Source
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Bolt is a relatively small code base (<3KLOC) for an embedded, serializable,
0000000000000000000000000000000000000000;;	transactional key/value database so it can be a good starting point for people
0000000000000000000000000000000000000000;;	interested in how databases work.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The best places to start are the main entry points into Bolt:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `Open()` - Initializes the reference to the database. It's responsible for
0000000000000000000000000000000000000000;;	  creating the database if it doesn't exist, obtaining an exclusive lock on the
0000000000000000000000000000000000000000;;	  file, reading the meta pages, & memory-mapping the file.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `DB.Begin()` - Starts a read-only or read-write transaction depending on the
0000000000000000000000000000000000000000;;	  value of the `writable` argument. This requires briefly obtaining the "meta"
0000000000000000000000000000000000000000;;	  lock to keep track of open transactions. Only one read-write transaction can
0000000000000000000000000000000000000000;;	  exist at a time so the "rwlock" is acquired during the life of a read-write
0000000000000000000000000000000000000000;;	  transaction.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `Bucket.Put()` - Writes a key/value pair into a bucket. After validating the
0000000000000000000000000000000000000000;;	  arguments, a cursor is used to traverse the B+tree to the page and position
0000000000000000000000000000000000000000;;	  where they key & value will be written. Once the position is found, the bucket
0000000000000000000000000000000000000000;;	  materializes the underlying page and the page's parent pages into memory as
0000000000000000000000000000000000000000;;	  "nodes". These nodes are where mutations occur during read-write transactions.
0000000000000000000000000000000000000000;;	  These changes get flushed to disk during commit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `Bucket.Get()` - Retrieves a key/value pair from a bucket. This uses a cursor
0000000000000000000000000000000000000000;;	  to move to the page & position of a key/value pair. During a read-only
0000000000000000000000000000000000000000;;	  transaction, the key and value data is returned as a direct reference to the
0000000000000000000000000000000000000000;;	  underlying mmap file so there's no allocation overhead. For read-write
0000000000000000000000000000000000000000;;	  transactions, this data may reference the mmap file or one of the in-memory
0000000000000000000000000000000000000000;;	  node values.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `Cursor` - This object is simply for traversing the B+tree of on-disk pages
0000000000000000000000000000000000000000;;	  or in-memory nodes. It can seek to a specific key, move to the first or last
0000000000000000000000000000000000000000;;	  value, or it can move forward or backward. The cursor handles the movement up
0000000000000000000000000000000000000000;;	  and down the B+tree transparently to the end user.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	- `Tx.Commit()` - Converts the in-memory dirty nodes and the list of free pages
0000000000000000000000000000000000000000;;	  into pages to be written to disk. Writing to disk then occurs in two phases.
0000000000000000000000000000000000000000;;	  First, the dirty pages are written to disk and an `fsync()` occurs. Second, a
0000000000000000000000000000000000000000;;	  new meta page with an incremented transaction ID is written and another
0000000000000000000000000000000000000000;;	  `fsync()` occurs. This two phase write ensures that partially written data
0000000000000000000000000000000000000000;;	  pages are ignored in the event of a crash since the meta page pointing to them
0000000000000000000000000000000000000000;;	  is never written. Partially written meta pages are invalidated because they
0000000000000000000000000000000000000000;;	  are written with a checksum.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you have additional notes that could be helpful for others, please submit
0000000000000000000000000000000000000000;;	them via pull request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Other Projects Using Bolt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Below is a list of public, open source projects that use Bolt:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [BoltDbWeb](https://github.com/evnix/boltdbweb) - A web based GUI for BoltDB files.
0000000000000000000000000000000000000000;;	* [Operation Go: A Routine Mission](http://gocode.io) - An online programming game for Golang using Bolt for user accounts and a leaderboard.
0000000000000000000000000000000000000000;;	* [Bazil](https://bazil.org/) - A file system that lets your data reside where it is most convenient for it to reside.
0000000000000000000000000000000000000000;;	* [DVID](https://github.com/janelia-flyem/dvid) - Added Bolt as optional storage engine and testing it against Basho-tuned leveldb.
0000000000000000000000000000000000000000;;	* [Skybox Analytics](https://github.com/skybox/skybox) - A standalone funnel analysis tool for web analytics.
0000000000000000000000000000000000000000;;	* [Scuttlebutt](https://github.com/benbjohnson/scuttlebutt) - Uses Bolt to store and process all Twitter mentions of GitHub projects.
0000000000000000000000000000000000000000;;	* [Wiki](https://github.com/peterhellberg/wiki) - A tiny wiki using Goji, BoltDB and Blackfriday.
0000000000000000000000000000000000000000;;	* [ChainStore](https://github.com/pressly/chainstore) - Simple key-value interface to a variety of storage engines organized as a chain of operations.
0000000000000000000000000000000000000000;;	* [MetricBase](https://github.com/msiebuhr/MetricBase) - Single-binary version of Graphite.
0000000000000000000000000000000000000000;;	* [Gitchain](https://github.com/gitchain/gitchain) - Decentralized, peer-to-peer Git repositories aka "Git meets Bitcoin".
0000000000000000000000000000000000000000;;	* [event-shuttle](https://github.com/sclasen/event-shuttle) - A Unix system service to collect and reliably deliver messages to Kafka.
0000000000000000000000000000000000000000;;	* [ipxed](https://github.com/kelseyhightower/ipxed) - Web interface and api for ipxed.
0000000000000000000000000000000000000000;;	* [BoltStore](https://github.com/yosssi/boltstore) - Session store using Bolt.
0000000000000000000000000000000000000000;;	* [photosite/session](https://godoc.org/bitbucket.org/kardianos/photosite/session) - Sessions for a photo viewing site.
0000000000000000000000000000000000000000;;	* [LedisDB](https://github.com/siddontang/ledisdb) - A high performance NoSQL, using Bolt as optional storage.
0000000000000000000000000000000000000000;;	* [ipLocator](https://github.com/AndreasBriese/ipLocator) - A fast ip-geo-location-server using bolt with bloom filters.
0000000000000000000000000000000000000000;;	* [cayley](https://github.com/google/cayley) - Cayley is an open-source graph database using Bolt as optional backend.
0000000000000000000000000000000000000000;;	* [bleve](http://www.blevesearch.com/) - A pure Go search engine similar to ElasticSearch that uses Bolt as the default storage backend.
0000000000000000000000000000000000000000;;	* [tentacool](https://github.com/optiflows/tentacool) - REST api server to manage system stuff (IP, DNS, Gateway...) on a linux server.
0000000000000000000000000000000000000000;;	* [Seaweed File System](https://github.com/chrislusf/seaweedfs) - Highly scalable distributed key~file system with O(1) disk read.
0000000000000000000000000000000000000000;;	* [InfluxDB](https://influxdata.com) - Scalable datastore for metrics, events, and real-time analytics.
0000000000000000000000000000000000000000;;	* [Freehold](http://tshannon.bitbucket.org/freehold/) - An open, secure, and lightweight platform for your files and data.
0000000000000000000000000000000000000000;;	* [Prometheus Annotation Server](https://github.com/oliver006/prom_annotation_server) - Annotation server for PromDash & Prometheus service monitoring system.
0000000000000000000000000000000000000000;;	* [Consul](https://github.com/hashicorp/consul) - Consul is service discovery and configuration made easy. Distributed, highly available, and datacenter-aware.
0000000000000000000000000000000000000000;;	* [Kala](https://github.com/ajvb/kala) - Kala is a modern job scheduler optimized to run on a single node. It is persistent, JSON over HTTP API, ISO 8601 duration notation, and dependent jobs.
0000000000000000000000000000000000000000;;	* [drive](https://github.com/odeke-em/drive) - drive is an unofficial Google Drive command line client for \*NIX operating systems.
0000000000000000000000000000000000000000;;	* [stow](https://github.com/djherbis/stow) -  a persistence manager for objects
0000000000000000000000000000000000000000;;	  backed by boltdb.
0000000000000000000000000000000000000000;;	* [buckets](https://github.com/joyrexus/buckets) - a bolt wrapper streamlining
0000000000000000000000000000000000000000;;	  simple tx and key scans.
0000000000000000000000000000000000000000;;	* [mbuckets](https://github.com/abhigupta912/mbuckets) - A Bolt wrapper that allows easy operations on multi level (nested) buckets.
0000000000000000000000000000000000000000;;	* [Request Baskets](https://github.com/darklynx/request-baskets) - A web service to collect arbitrary HTTP requests and inspect them via REST API or simple web UI, similar to [RequestBin](http://requestb.in/) service
0000000000000000000000000000000000000000;;	* [Go Report Card](https://goreportcard.com/) - Go code quality report cards as a (free and open source) service.
0000000000000000000000000000000000000000;;	* [Boltdb Boilerplate](https://github.com/bobintornado/boltdb-boilerplate) - Boilerplate wrapper around bolt aiming to make simple calls one-liners.
0000000000000000000000000000000000000000;;	* [lru](https://github.com/crowdriff/lru) - Easy to use Bolt-backed Least-Recently-Used (LRU) read-through cache with chainable remote stores.
0000000000000000000000000000000000000000;;	* [Storm](https://github.com/asdine/storm) - Simple and powerful ORM for BoltDB.
0000000000000000000000000000000000000000;;	* [GoWebApp](https://github.com/josephspurrier/gowebapp) - A basic MVC web application in Go using BoltDB.
0000000000000000000000000000000000000000;;	* [SimpleBolt](https://github.com/xyproto/simplebolt) - A simple way to use BoltDB. Deals mainly with strings.
0000000000000000000000000000000000000000;;	* [Algernon](https://github.com/xyproto/algernon) - A HTTP/2 web server with built-in support for Lua. Uses BoltDB as the default database backend.
0000000000000000000000000000000000000000;;	* [MuLiFS](https://github.com/dankomiocevic/mulifs) - Music Library Filesystem creates a filesystem to organise your music files.
0000000000000000000000000000000000000000;;	* [GoShort](https://github.com/pankajkhairnar/goShort) - GoShort is a URL shortener written in Golang and BoltDB for persistent key/value storage and for routing it's using high performent HTTPRouter.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you are using Bolt in a project please send a pull request to add it to the list.
