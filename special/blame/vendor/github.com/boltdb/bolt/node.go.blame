0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/node.go[Godeps/_workspace/src/github.com/boltdb/bolt/node.go][vendor/github.com/boltdb/bolt/node.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// node represents an in-memory, deserialized page.
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		bucket     *Bucket
0000000000000000000000000000000000000000;;		isLeaf     bool
0000000000000000000000000000000000000000;;		unbalanced bool
0000000000000000000000000000000000000000;;		spilled    bool
0000000000000000000000000000000000000000;;		key        []byte
0000000000000000000000000000000000000000;;		pgid       pgid
0000000000000000000000000000000000000000;;		parent     *node
0000000000000000000000000000000000000000;;		children   nodes
0000000000000000000000000000000000000000;;		inodes     inodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// root returns the top-level node this node is attached to.
0000000000000000000000000000000000000000;;	func (n *node) root() *node {
0000000000000000000000000000000000000000;;		if n.parent == nil {
0000000000000000000000000000000000000000;;			return n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.parent.root()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// minKeys returns the minimum number of inodes this node should have.
0000000000000000000000000000000000000000;;	func (n *node) minKeys() int {
0000000000000000000000000000000000000000;;		if n.isLeaf {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// size returns the size of the node after serialization.
0000000000000000000000000000000000000000;;	func (n *node) size() int {
0000000000000000000000000000000000000000;;		sz, elsz := pageHeaderSize, n.pageElementSize()
0000000000000000000000000000000000000000;;		for i := 0; i < len(n.inodes); i++ {
0000000000000000000000000000000000000000;;			item := &n.inodes[i]
0000000000000000000000000000000000000000;;			sz += elsz + len(item.key) + len(item.value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sz
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sizeLessThan returns true if the node is less than a given size.
0000000000000000000000000000000000000000;;	// This is an optimization to avoid calculating a large node when we only need
0000000000000000000000000000000000000000;;	// to know if it fits inside a certain page size.
0000000000000000000000000000000000000000;;	func (n *node) sizeLessThan(v int) bool {
0000000000000000000000000000000000000000;;		sz, elsz := pageHeaderSize, n.pageElementSize()
0000000000000000000000000000000000000000;;		for i := 0; i < len(n.inodes); i++ {
0000000000000000000000000000000000000000;;			item := &n.inodes[i]
0000000000000000000000000000000000000000;;			sz += elsz + len(item.key) + len(item.value)
0000000000000000000000000000000000000000;;			if sz >= v {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pageElementSize returns the size of each page element based on the type of node.
0000000000000000000000000000000000000000;;	func (n *node) pageElementSize() int {
0000000000000000000000000000000000000000;;		if n.isLeaf {
0000000000000000000000000000000000000000;;			return leafPageElementSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return branchPageElementSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// childAt returns the child node at a given index.
0000000000000000000000000000000000000000;;	func (n *node) childAt(index int) *node {
0000000000000000000000000000000000000000;;		if n.isLeaf {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("invalid childAt(%d) on a leaf node", index))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.bucket.node(n.inodes[index].pgid, n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// childIndex returns the index of a given child node.
0000000000000000000000000000000000000000;;	func (n *node) childIndex(child *node) int {
0000000000000000000000000000000000000000;;		index := sort.Search(len(n.inodes), func(i int) bool { return bytes.Compare(n.inodes[i].key, child.key) != -1 })
0000000000000000000000000000000000000000;;		return index
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// numChildren returns the number of children.
0000000000000000000000000000000000000000;;	func (n *node) numChildren() int {
0000000000000000000000000000000000000000;;		return len(n.inodes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextSibling returns the next node with the same parent.
0000000000000000000000000000000000000000;;	func (n *node) nextSibling() *node {
0000000000000000000000000000000000000000;;		if n.parent == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index := n.parent.childIndex(n)
0000000000000000000000000000000000000000;;		if index >= n.parent.numChildren()-1 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.parent.childAt(index + 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prevSibling returns the previous node with the same parent.
0000000000000000000000000000000000000000;;	func (n *node) prevSibling() *node {
0000000000000000000000000000000000000000;;		if n.parent == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		index := n.parent.childIndex(n)
0000000000000000000000000000000000000000;;		if index == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.parent.childAt(index - 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// put inserts a key/value.
0000000000000000000000000000000000000000;;	func (n *node) put(oldKey, newKey, value []byte, pgid pgid, flags uint32) {
0000000000000000000000000000000000000000;;		if pgid >= n.bucket.tx.meta.pgid {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("pgid (%d) above high water mark (%d)", pgid, n.bucket.tx.meta.pgid))
0000000000000000000000000000000000000000;;		} else if len(oldKey) <= 0 {
0000000000000000000000000000000000000000;;			panic("put: zero-length old key")
0000000000000000000000000000000000000000;;		} else if len(newKey) <= 0 {
0000000000000000000000000000000000000000;;			panic("put: zero-length new key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Find insertion index.
0000000000000000000000000000000000000000;;		index := sort.Search(len(n.inodes), func(i int) bool { return bytes.Compare(n.inodes[i].key, oldKey) != -1 })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add capacity and shift nodes if we don't have an exact match and need to insert.
0000000000000000000000000000000000000000;;		exact := (len(n.inodes) > 0 && index < len(n.inodes) && bytes.Equal(n.inodes[index].key, oldKey))
0000000000000000000000000000000000000000;;		if !exact {
0000000000000000000000000000000000000000;;			n.inodes = append(n.inodes, inode{})
0000000000000000000000000000000000000000;;			copy(n.inodes[index+1:], n.inodes[index:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inode := &n.inodes[index]
0000000000000000000000000000000000000000;;		inode.flags = flags
0000000000000000000000000000000000000000;;		inode.key = newKey
0000000000000000000000000000000000000000;;		inode.value = value
0000000000000000000000000000000000000000;;		inode.pgid = pgid
0000000000000000000000000000000000000000;;		_assert(len(inode.key) > 0, "put: zero-length inode key")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// del removes a key from the node.
0000000000000000000000000000000000000000;;	func (n *node) del(key []byte) {
0000000000000000000000000000000000000000;;		// Find index of key.
0000000000000000000000000000000000000000;;		index := sort.Search(len(n.inodes), func(i int) bool { return bytes.Compare(n.inodes[i].key, key) != -1 })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Exit if the key isn't found.
0000000000000000000000000000000000000000;;		if index >= len(n.inodes) || !bytes.Equal(n.inodes[index].key, key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete inode from the node.
0000000000000000000000000000000000000000;;		n.inodes = append(n.inodes[:index], n.inodes[index+1:]...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Mark the node as needing rebalancing.
0000000000000000000000000000000000000000;;		n.unbalanced = true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// read initializes the node from a page.
0000000000000000000000000000000000000000;;	func (n *node) read(p *page) {
0000000000000000000000000000000000000000;;		n.pgid = p.id
0000000000000000000000000000000000000000;;		n.isLeaf = ((p.flags & leafPageFlag) != 0)
0000000000000000000000000000000000000000;;		n.inodes = make(inodes, int(p.count))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < int(p.count); i++ {
0000000000000000000000000000000000000000;;			inode := &n.inodes[i]
0000000000000000000000000000000000000000;;			if n.isLeaf {
0000000000000000000000000000000000000000;;				elem := p.leafPageElement(uint16(i))
0000000000000000000000000000000000000000;;				inode.flags = elem.flags
0000000000000000000000000000000000000000;;				inode.key = elem.key()
0000000000000000000000000000000000000000;;				inode.value = elem.value()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				elem := p.branchPageElement(uint16(i))
0000000000000000000000000000000000000000;;				inode.pgid = elem.pgid
0000000000000000000000000000000000000000;;				inode.key = elem.key()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			_assert(len(inode.key) > 0, "read: zero-length inode key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save first key so we can find the node in the parent when we spill.
0000000000000000000000000000000000000000;;		if len(n.inodes) > 0 {
0000000000000000000000000000000000000000;;			n.key = n.inodes[0].key
0000000000000000000000000000000000000000;;			_assert(len(n.key) > 0, "read: zero-length node key")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			n.key = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write writes the items onto one or more pages.
0000000000000000000000000000000000000000;;	func (n *node) write(p *page) {
0000000000000000000000000000000000000000;;		// Initialize page.
0000000000000000000000000000000000000000;;		if n.isLeaf {
0000000000000000000000000000000000000000;;			p.flags |= leafPageFlag
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.flags |= branchPageFlag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(n.inodes) >= 0xFFFF {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("inode overflow: %d (pgid=%d)", len(n.inodes), p.id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.count = uint16(len(n.inodes))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stop here if there are no items to write.
0000000000000000000000000000000000000000;;		if p.count == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Loop over each item and write it to the page.
0000000000000000000000000000000000000000;;		b := (*[maxAllocSize]byte)(unsafe.Pointer(&p.ptr))[n.pageElementSize()*len(n.inodes):]
0000000000000000000000000000000000000000;;		for i, item := range n.inodes {
0000000000000000000000000000000000000000;;			_assert(len(item.key) > 0, "write: zero-length inode key")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write the page element.
0000000000000000000000000000000000000000;;			if n.isLeaf {
0000000000000000000000000000000000000000;;				elem := p.leafPageElement(uint16(i))
0000000000000000000000000000000000000000;;				elem.pos = uint32(uintptr(unsafe.Pointer(&b[0])) - uintptr(unsafe.Pointer(elem)))
0000000000000000000000000000000000000000;;				elem.flags = item.flags
0000000000000000000000000000000000000000;;				elem.ksize = uint32(len(item.key))
0000000000000000000000000000000000000000;;				elem.vsize = uint32(len(item.value))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				elem := p.branchPageElement(uint16(i))
0000000000000000000000000000000000000000;;				elem.pos = uint32(uintptr(unsafe.Pointer(&b[0])) - uintptr(unsafe.Pointer(elem)))
0000000000000000000000000000000000000000;;				elem.ksize = uint32(len(item.key))
0000000000000000000000000000000000000000;;				elem.pgid = item.pgid
0000000000000000000000000000000000000000;;				_assert(elem.pgid != p.id, "write: circular dependency occurred")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the length of key+value is larger than the max allocation size
0000000000000000000000000000000000000000;;			// then we need to reallocate the byte array pointer.
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// See: https://github.com/boltdb/bolt/pull/335
0000000000000000000000000000000000000000;;			klen, vlen := len(item.key), len(item.value)
0000000000000000000000000000000000000000;;			if len(b) < klen+vlen {
0000000000000000000000000000000000000000;;				b = (*[maxAllocSize]byte)(unsafe.Pointer(&b[0]))[:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write data for the element to the end of the page.
0000000000000000000000000000000000000000;;			copy(b[0:], item.key)
0000000000000000000000000000000000000000;;			b = b[klen:]
0000000000000000000000000000000000000000;;			copy(b[0:], item.value)
0000000000000000000000000000000000000000;;			b = b[vlen:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DEBUG ONLY: n.dump()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// split breaks up a node into multiple smaller nodes, if appropriate.
0000000000000000000000000000000000000000;;	// This should only be called from the spill() function.
0000000000000000000000000000000000000000;;	func (n *node) split(pageSize int) []*node {
0000000000000000000000000000000000000000;;		var nodes []*node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		node := n
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Split node into two.
0000000000000000000000000000000000000000;;			a, b := node.splitTwo(pageSize)
0000000000000000000000000000000000000000;;			nodes = append(nodes, a)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we can't split then exit the loop.
0000000000000000000000000000000000000000;;			if b == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set node to b so it gets split on the next iteration.
0000000000000000000000000000000000000000;;			node = b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitTwo breaks up a node into two smaller nodes, if appropriate.
0000000000000000000000000000000000000000;;	// This should only be called from the split() function.
0000000000000000000000000000000000000000;;	func (n *node) splitTwo(pageSize int) (*node, *node) {
0000000000000000000000000000000000000000;;		// Ignore the split if the page doesn't have at least enough nodes for
0000000000000000000000000000000000000000;;		// two pages or if the nodes can fit in a single page.
0000000000000000000000000000000000000000;;		if len(n.inodes) <= (minKeysPerPage*2) || n.sizeLessThan(pageSize) {
0000000000000000000000000000000000000000;;			return n, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the threshold before starting a new node.
0000000000000000000000000000000000000000;;		var fillPercent = n.bucket.FillPercent
0000000000000000000000000000000000000000;;		if fillPercent < minFillPercent {
0000000000000000000000000000000000000000;;			fillPercent = minFillPercent
0000000000000000000000000000000000000000;;		} else if fillPercent > maxFillPercent {
0000000000000000000000000000000000000000;;			fillPercent = maxFillPercent
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		threshold := int(float64(pageSize) * fillPercent)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine split position and sizes of the two pages.
0000000000000000000000000000000000000000;;		splitIndex, _ := n.splitIndex(threshold)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split node into two separate nodes.
0000000000000000000000000000000000000000;;		// If there's no parent then we'll need to create one.
0000000000000000000000000000000000000000;;		if n.parent == nil {
0000000000000000000000000000000000000000;;			n.parent = &node{bucket: n.bucket, children: []*node{n}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create a new node and add it to the parent.
0000000000000000000000000000000000000000;;		next := &node{bucket: n.bucket, isLeaf: n.isLeaf, parent: n.parent}
0000000000000000000000000000000000000000;;		n.parent.children = append(n.parent.children, next)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split inodes across two nodes.
0000000000000000000000000000000000000000;;		next.inodes = n.inodes[splitIndex:]
0000000000000000000000000000000000000000;;		n.inodes = n.inodes[:splitIndex]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the statistics.
0000000000000000000000000000000000000000;;		n.bucket.tx.stats.Split++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n, next
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// splitIndex finds the position where a page will fill a given threshold.
0000000000000000000000000000000000000000;;	// It returns the index as well as the size of the first page.
0000000000000000000000000000000000000000;;	// This is only be called from split().
0000000000000000000000000000000000000000;;	func (n *node) splitIndex(threshold int) (index, sz int) {
0000000000000000000000000000000000000000;;		sz = pageHeaderSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Loop until we only have the minimum number of keys required for the second page.
0000000000000000000000000000000000000000;;		for i := 0; i < len(n.inodes)-minKeysPerPage; i++ {
0000000000000000000000000000000000000000;;			index = i
0000000000000000000000000000000000000000;;			inode := n.inodes[i]
0000000000000000000000000000000000000000;;			elsize := n.pageElementSize() + len(inode.key) + len(inode.value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we have at least the minimum number of keys and adding another
0000000000000000000000000000000000000000;;			// node would put us over the threshold then exit and return.
0000000000000000000000000000000000000000;;			if i >= minKeysPerPage && sz+elsize > threshold {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add the element size to the total size.
0000000000000000000000000000000000000000;;			sz += elsize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// spill writes the nodes to dirty pages and splits nodes as it goes.
0000000000000000000000000000000000000000;;	// Returns an error if dirty pages cannot be allocated.
0000000000000000000000000000000000000000;;	func (n *node) spill() error {
0000000000000000000000000000000000000000;;		var tx = n.bucket.tx
0000000000000000000000000000000000000000;;		if n.spilled {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spill child nodes first. Child nodes can materialize sibling nodes in
0000000000000000000000000000000000000000;;		// the case of split-merge so we cannot use a range loop. We have to check
0000000000000000000000000000000000000000;;		// the children size on every loop iteration.
0000000000000000000000000000000000000000;;		sort.Sort(n.children)
0000000000000000000000000000000000000000;;		for i := 0; i < len(n.children); i++ {
0000000000000000000000000000000000000000;;			if err := n.children[i].spill(); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We no longer need the child list because it's only used for spill tracking.
0000000000000000000000000000000000000000;;		n.children = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split nodes into appropriate sizes. The first node will always be n.
0000000000000000000000000000000000000000;;		var nodes = n.split(tx.db.pageSize)
0000000000000000000000000000000000000000;;		for _, node := range nodes {
0000000000000000000000000000000000000000;;			// Add node's page to the freelist if it's not new.
0000000000000000000000000000000000000000;;			if node.pgid > 0 {
0000000000000000000000000000000000000000;;				tx.db.freelist.free(tx.meta.txid, tx.page(node.pgid))
0000000000000000000000000000000000000000;;				node.pgid = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Allocate contiguous space for the node.
0000000000000000000000000000000000000000;;			p, err := tx.allocate((node.size() / tx.db.pageSize) + 1)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Write the node.
0000000000000000000000000000000000000000;;			if p.id >= tx.meta.pgid {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("pgid (%d) above high water mark (%d)", p.id, tx.meta.pgid))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			node.pgid = p.id
0000000000000000000000000000000000000000;;			node.write(p)
0000000000000000000000000000000000000000;;			node.spilled = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Insert into parent inodes.
0000000000000000000000000000000000000000;;			if node.parent != nil {
0000000000000000000000000000000000000000;;				var key = node.key
0000000000000000000000000000000000000000;;				if key == nil {
0000000000000000000000000000000000000000;;					key = node.inodes[0].key
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				node.parent.put(key, node.inodes[0].key, nil, node.pgid, 0)
0000000000000000000000000000000000000000;;				node.key = node.inodes[0].key
0000000000000000000000000000000000000000;;				_assert(len(node.key) > 0, "spill: zero-length node key")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update the statistics.
0000000000000000000000000000000000000000;;			tx.stats.Spill++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the root node split and created a new root then we need to spill that
0000000000000000000000000000000000000000;;		// as well. We'll clear out the children to make sure it doesn't try to respill.
0000000000000000000000000000000000000000;;		if n.parent != nil && n.parent.pgid == 0 {
0000000000000000000000000000000000000000;;			n.children = nil
0000000000000000000000000000000000000000;;			return n.parent.spill()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rebalance attempts to combine the node with sibling nodes if the node fill
0000000000000000000000000000000000000000;;	// size is below a threshold or if there are not enough keys.
0000000000000000000000000000000000000000;;	func (n *node) rebalance() {
0000000000000000000000000000000000000000;;		if !n.unbalanced {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.unbalanced = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update statistics.
0000000000000000000000000000000000000000;;		n.bucket.tx.stats.Rebalance++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore if node is above threshold (25%) and has enough keys.
0000000000000000000000000000000000000000;;		var threshold = n.bucket.tx.db.pageSize / 4
0000000000000000000000000000000000000000;;		if n.size() > threshold && len(n.inodes) > n.minKeys() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Root node has special handling.
0000000000000000000000000000000000000000;;		if n.parent == nil {
0000000000000000000000000000000000000000;;			// If root node is a branch and only has one node then collapse it.
0000000000000000000000000000000000000000;;			if !n.isLeaf && len(n.inodes) == 1 {
0000000000000000000000000000000000000000;;				// Move root's child up.
0000000000000000000000000000000000000000;;				child := n.bucket.node(n.inodes[0].pgid, n)
0000000000000000000000000000000000000000;;				n.isLeaf = child.isLeaf
0000000000000000000000000000000000000000;;				n.inodes = child.inodes[:]
0000000000000000000000000000000000000000;;				n.children = child.children
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Reparent all child nodes being moved.
0000000000000000000000000000000000000000;;				for _, inode := range n.inodes {
0000000000000000000000000000000000000000;;					if child, ok := n.bucket.nodes[inode.pgid]; ok {
0000000000000000000000000000000000000000;;						child.parent = n
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Remove old child.
0000000000000000000000000000000000000000;;				child.parent = nil
0000000000000000000000000000000000000000;;				delete(n.bucket.nodes, child.pgid)
0000000000000000000000000000000000000000;;				child.free()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If node has no keys then just remove it.
0000000000000000000000000000000000000000;;		if n.numChildren() == 0 {
0000000000000000000000000000000000000000;;			n.parent.del(n.key)
0000000000000000000000000000000000000000;;			n.parent.removeChild(n)
0000000000000000000000000000000000000000;;			delete(n.bucket.nodes, n.pgid)
0000000000000000000000000000000000000000;;			n.free()
0000000000000000000000000000000000000000;;			n.parent.rebalance()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_assert(n.parent.numChildren() > 1, "parent must have at least 2 children")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Destination node is right sibling if idx == 0, otherwise left sibling.
0000000000000000000000000000000000000000;;		var target *node
0000000000000000000000000000000000000000;;		var useNextSibling = (n.parent.childIndex(n) == 0)
0000000000000000000000000000000000000000;;		if useNextSibling {
0000000000000000000000000000000000000000;;			target = n.nextSibling()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			target = n.prevSibling()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If both this node and the target node are too small then merge them.
0000000000000000000000000000000000000000;;		if useNextSibling {
0000000000000000000000000000000000000000;;			// Reparent all child nodes being moved.
0000000000000000000000000000000000000000;;			for _, inode := range target.inodes {
0000000000000000000000000000000000000000;;				if child, ok := n.bucket.nodes[inode.pgid]; ok {
0000000000000000000000000000000000000000;;					child.parent.removeChild(child)
0000000000000000000000000000000000000000;;					child.parent = n
0000000000000000000000000000000000000000;;					child.parent.children = append(child.parent.children, child)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Copy over inodes from target and remove target.
0000000000000000000000000000000000000000;;			n.inodes = append(n.inodes, target.inodes...)
0000000000000000000000000000000000000000;;			n.parent.del(target.key)
0000000000000000000000000000000000000000;;			n.parent.removeChild(target)
0000000000000000000000000000000000000000;;			delete(n.bucket.nodes, target.pgid)
0000000000000000000000000000000000000000;;			target.free()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Reparent all child nodes being moved.
0000000000000000000000000000000000000000;;			for _, inode := range n.inodes {
0000000000000000000000000000000000000000;;				if child, ok := n.bucket.nodes[inode.pgid]; ok {
0000000000000000000000000000000000000000;;					child.parent.removeChild(child)
0000000000000000000000000000000000000000;;					child.parent = target
0000000000000000000000000000000000000000;;					child.parent.children = append(child.parent.children, child)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Copy over inodes to target and remove node.
0000000000000000000000000000000000000000;;			target.inodes = append(target.inodes, n.inodes...)
0000000000000000000000000000000000000000;;			n.parent.del(n.key)
0000000000000000000000000000000000000000;;			n.parent.removeChild(n)
0000000000000000000000000000000000000000;;			delete(n.bucket.nodes, n.pgid)
0000000000000000000000000000000000000000;;			n.free()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Either this node or the target node was deleted from the parent so rebalance it.
0000000000000000000000000000000000000000;;		n.parent.rebalance()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removes a node from the list of in-memory children.
0000000000000000000000000000000000000000;;	// This does not affect the inodes.
0000000000000000000000000000000000000000;;	func (n *node) removeChild(target *node) {
0000000000000000000000000000000000000000;;		for i, child := range n.children {
0000000000000000000000000000000000000000;;			if child == target {
0000000000000000000000000000000000000000;;				n.children = append(n.children[:i], n.children[i+1:]...)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dereference causes the node to copy all its inode key/value references to heap memory.
0000000000000000000000000000000000000000;;	// This is required when the mmap is reallocated so inodes are not pointing to stale data.
0000000000000000000000000000000000000000;;	func (n *node) dereference() {
0000000000000000000000000000000000000000;;		if n.key != nil {
0000000000000000000000000000000000000000;;			key := make([]byte, len(n.key))
0000000000000000000000000000000000000000;;			copy(key, n.key)
0000000000000000000000000000000000000000;;			n.key = key
0000000000000000000000000000000000000000;;			_assert(n.pgid == 0 || len(n.key) > 0, "dereference: zero-length node key on existing node")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range n.inodes {
0000000000000000000000000000000000000000;;			inode := &n.inodes[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			key := make([]byte, len(inode.key))
0000000000000000000000000000000000000000;;			copy(key, inode.key)
0000000000000000000000000000000000000000;;			inode.key = key
0000000000000000000000000000000000000000;;			_assert(len(inode.key) > 0, "dereference: zero-length inode key")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			value := make([]byte, len(inode.value))
0000000000000000000000000000000000000000;;			copy(value, inode.value)
0000000000000000000000000000000000000000;;			inode.value = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively dereference children.
0000000000000000000000000000000000000000;;		for _, child := range n.children {
0000000000000000000000000000000000000000;;			child.dereference()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update statistics.
0000000000000000000000000000000000000000;;		n.bucket.tx.stats.NodeDeref++
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// free adds the node's underlying page to the freelist.
0000000000000000000000000000000000000000;;	func (n *node) free() {
0000000000000000000000000000000000000000;;		if n.pgid != 0 {
0000000000000000000000000000000000000000;;			n.bucket.tx.db.freelist.free(n.bucket.tx.meta.txid, n.bucket.tx.page(n.pgid))
0000000000000000000000000000000000000000;;			n.pgid = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dump writes the contents of the node to STDERR for debugging purposes.
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	func (n *node) dump() {
0000000000000000000000000000000000000000;;		// Write node header.
0000000000000000000000000000000000000000;;		var typ = "branch"
0000000000000000000000000000000000000000;;		if n.isLeaf {
0000000000000000000000000000000000000000;;			typ = "leaf"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		warnf("[NODE %d {type=%s count=%d}]", n.pgid, typ, len(n.inodes))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write out abbreviated version of each item.
0000000000000000000000000000000000000000;;		for _, item := range n.inodes {
0000000000000000000000000000000000000000;;			if n.isLeaf {
0000000000000000000000000000000000000000;;				if item.flags&bucketLeafFlag != 0 {
0000000000000000000000000000000000000000;;					bucket := (*bucket)(unsafe.Pointer(&item.value[0]))
0000000000000000000000000000000000000000;;					warnf("+L %08x -> (bucket root=%d)", trunc(item.key, 4), bucket.root)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					warnf("+L %08x -> %08x", trunc(item.key, 4), trunc(item.value, 4))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				warnf("+B %08x -> pgid=%d", trunc(item.key, 4), item.pgid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		warn("")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nodes []*node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s nodes) Len() int           { return len(s) }
0000000000000000000000000000000000000000;;	func (s nodes) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	func (s nodes) Less(i, j int) bool { return bytes.Compare(s[i].inodes[0].key, s[j].inodes[0].key) == -1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inode represents an internal node inside of a node.
0000000000000000000000000000000000000000;;	// It can be used to point to elements in a page or point
0000000000000000000000000000000000000000;;	// to an element which hasn't been added to a page yet.
0000000000000000000000000000000000000000;;	type inode struct {
0000000000000000000000000000000000000000;;		flags uint32
0000000000000000000000000000000000000000;;		pgid  pgid
0000000000000000000000000000000000000000;;		key   []byte
0000000000000000000000000000000000000000;;		value []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type inodes []inode
