0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/freelist.go[Godeps/_workspace/src/github.com/boltdb/bolt/freelist.go][vendor/github.com/boltdb/bolt/freelist.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// freelist represents a list of all pages that are available for allocation.
0000000000000000000000000000000000000000;;	// It also tracks pages that have been freed but are still in use by open transactions.
0000000000000000000000000000000000000000;;	type freelist struct {
0000000000000000000000000000000000000000;;		ids     []pgid          // all free and available free page ids.
0000000000000000000000000000000000000000;;		pending map[txid][]pgid // mapping of soon-to-be free page ids by tx.
0000000000000000000000000000000000000000;;		cache   map[pgid]bool   // fast lookup of all free and pending page ids.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newFreelist returns an empty, initialized freelist.
0000000000000000000000000000000000000000;;	func newFreelist() *freelist {
0000000000000000000000000000000000000000;;		return &freelist{
0000000000000000000000000000000000000000;;			pending: make(map[txid][]pgid),
0000000000000000000000000000000000000000;;			cache:   make(map[pgid]bool),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// size returns the size of the page after serialization.
0000000000000000000000000000000000000000;;	func (f *freelist) size() int {
0000000000000000000000000000000000000000;;		return pageHeaderSize + (int(unsafe.Sizeof(pgid(0))) * f.count())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// count returns count of pages on the freelist
0000000000000000000000000000000000000000;;	func (f *freelist) count() int {
0000000000000000000000000000000000000000;;		return f.free_count() + f.pending_count()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// free_count returns count of free pages
0000000000000000000000000000000000000000;;	func (f *freelist) free_count() int {
0000000000000000000000000000000000000000;;		return len(f.ids)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pending_count returns count of pending pages
0000000000000000000000000000000000000000;;	func (f *freelist) pending_count() int {
0000000000000000000000000000000000000000;;		var count int
0000000000000000000000000000000000000000;;		for _, list := range f.pending {
0000000000000000000000000000000000000000;;			count += len(list)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return count
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// all returns a list of all free ids and all pending ids in one sorted list.
0000000000000000000000000000000000000000;;	func (f *freelist) all() []pgid {
0000000000000000000000000000000000000000;;		m := make(pgids, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, list := range f.pending {
0000000000000000000000000000000000000000;;			m = append(m, list...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Sort(m)
0000000000000000000000000000000000000000;;		return pgids(f.ids).merge(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// allocate returns the starting page id of a contiguous list of pages of a given size.
0000000000000000000000000000000000000000;;	// If a contiguous block cannot be found then 0 is returned.
0000000000000000000000000000000000000000;;	func (f *freelist) allocate(n int) pgid {
0000000000000000000000000000000000000000;;		if len(f.ids) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var initial, previd pgid
0000000000000000000000000000000000000000;;		for i, id := range f.ids {
0000000000000000000000000000000000000000;;			if id <= 1 {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("invalid page allocation: %d", id))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Reset initial page if this is not contiguous.
0000000000000000000000000000000000000000;;			if previd == 0 || id-previd != 1 {
0000000000000000000000000000000000000000;;				initial = id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we found a contiguous block then remove it and return it.
0000000000000000000000000000000000000000;;			if (id-initial)+1 == pgid(n) {
0000000000000000000000000000000000000000;;				// If we're allocating off the beginning then take the fast path
0000000000000000000000000000000000000000;;				// and just adjust the existing slice. This will use extra memory
0000000000000000000000000000000000000000;;				// temporarily but the append() in free() will realloc the slice
0000000000000000000000000000000000000000;;				// as is necessary.
0000000000000000000000000000000000000000;;				if (i + 1) == n {
0000000000000000000000000000000000000000;;					f.ids = f.ids[i+1:]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					copy(f.ids[i-n+1:], f.ids[i+1:])
0000000000000000000000000000000000000000;;					f.ids = f.ids[:len(f.ids)-n]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Remove from the free cache.
0000000000000000000000000000000000000000;;				for i := pgid(0); i < pgid(n); i++ {
0000000000000000000000000000000000000000;;					delete(f.cache, initial+i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return initial
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			previd = id
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// free releases a page and its overflow for a given transaction id.
0000000000000000000000000000000000000000;;	// If the page is already free then a panic will occur.
0000000000000000000000000000000000000000;;	func (f *freelist) free(txid txid, p *page) {
0000000000000000000000000000000000000000;;		if p.id <= 1 {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("cannot free page 0 or 1: %d", p.id))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Free page and all its overflow pages.
0000000000000000000000000000000000000000;;		var ids = f.pending[txid]
0000000000000000000000000000000000000000;;		for id := p.id; id <= p.id+pgid(p.overflow); id++ {
0000000000000000000000000000000000000000;;			// Verify that page is not already free.
0000000000000000000000000000000000000000;;			if f.cache[id] {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("page %d already freed", id))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add to the freelist and cache.
0000000000000000000000000000000000000000;;			ids = append(ids, id)
0000000000000000000000000000000000000000;;			f.cache[id] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.pending[txid] = ids
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// release moves all page ids for a transaction id (or older) to the freelist.
0000000000000000000000000000000000000000;;	func (f *freelist) release(txid txid) {
0000000000000000000000000000000000000000;;		m := make(pgids, 0)
0000000000000000000000000000000000000000;;		for tid, ids := range f.pending {
0000000000000000000000000000000000000000;;			if tid <= txid {
0000000000000000000000000000000000000000;;				// Move transaction's pending pages to the available freelist.
0000000000000000000000000000000000000000;;				// Don't remove from the cache since the page is still free.
0000000000000000000000000000000000000000;;				m = append(m, ids...)
0000000000000000000000000000000000000000;;				delete(f.pending, tid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(m)
0000000000000000000000000000000000000000;;		f.ids = pgids(f.ids).merge(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rollback removes the pages from a given pending tx.
0000000000000000000000000000000000000000;;	func (f *freelist) rollback(txid txid) {
0000000000000000000000000000000000000000;;		// Remove page ids from cache.
0000000000000000000000000000000000000000;;		for _, id := range f.pending[txid] {
0000000000000000000000000000000000000000;;			delete(f.cache, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove pages from pending list.
0000000000000000000000000000000000000000;;		delete(f.pending, txid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// freed returns whether a given page is in the free list.
0000000000000000000000000000000000000000;;	func (f *freelist) freed(pgid pgid) bool {
0000000000000000000000000000000000000000;;		return f.cache[pgid]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// read initializes the freelist from a freelist page.
0000000000000000000000000000000000000000;;	func (f *freelist) read(p *page) {
0000000000000000000000000000000000000000;;		// If the page.count is at the max uint16 value (64k) then it's considered
0000000000000000000000000000000000000000;;		// an overflow and the size of the freelist is stored as the first element.
0000000000000000000000000000000000000000;;		idx, count := 0, int(p.count)
0000000000000000000000000000000000000000;;		if count == 0xFFFF {
0000000000000000000000000000000000000000;;			idx = 1
0000000000000000000000000000000000000000;;			count = int(((*[maxAllocSize]pgid)(unsafe.Pointer(&p.ptr)))[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Copy the list of page ids from the freelist.
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			f.ids = nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ids := ((*[maxAllocSize]pgid)(unsafe.Pointer(&p.ptr)))[idx:count]
0000000000000000000000000000000000000000;;			f.ids = make([]pgid, len(ids))
0000000000000000000000000000000000000000;;			copy(f.ids, ids)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make sure they're sorted.
0000000000000000000000000000000000000000;;			sort.Sort(pgids(f.ids))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rebuild the page cache.
0000000000000000000000000000000000000000;;		f.reindex()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write writes the page ids onto a freelist page. All free and pending ids are
0000000000000000000000000000000000000000;;	// saved to disk since in the event of a program crash, all pending ids will
0000000000000000000000000000000000000000;;	// become free.
0000000000000000000000000000000000000000;;	func (f *freelist) write(p *page) error {
0000000000000000000000000000000000000000;;		// Combine the old free pgids and pgids waiting on an open transaction.
0000000000000000000000000000000000000000;;		ids := f.all()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the header flag.
0000000000000000000000000000000000000000;;		p.flags |= freelistPageFlag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The page.count can only hold up to 64k elements so if we overflow that
0000000000000000000000000000000000000000;;		// number then we handle it by putting the size in the first element.
0000000000000000000000000000000000000000;;		if len(ids) == 0 {
0000000000000000000000000000000000000000;;			p.count = uint16(len(ids))
0000000000000000000000000000000000000000;;		} else if len(ids) < 0xFFFF {
0000000000000000000000000000000000000000;;			p.count = uint16(len(ids))
0000000000000000000000000000000000000000;;			copy(((*[maxAllocSize]pgid)(unsafe.Pointer(&p.ptr)))[:], ids)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.count = 0xFFFF
0000000000000000000000000000000000000000;;			((*[maxAllocSize]pgid)(unsafe.Pointer(&p.ptr)))[0] = pgid(len(ids))
0000000000000000000000000000000000000000;;			copy(((*[maxAllocSize]pgid)(unsafe.Pointer(&p.ptr)))[1:], ids)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reload reads the freelist from a page and filters out pending items.
0000000000000000000000000000000000000000;;	func (f *freelist) reload(p *page) {
0000000000000000000000000000000000000000;;		f.read(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build a cache of only pending pages.
0000000000000000000000000000000000000000;;		pcache := make(map[pgid]bool)
0000000000000000000000000000000000000000;;		for _, pendingIDs := range f.pending {
0000000000000000000000000000000000000000;;			for _, pendingID := range pendingIDs {
0000000000000000000000000000000000000000;;				pcache[pendingID] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check each page in the freelist and build a new available freelist
0000000000000000000000000000000000000000;;		// with any pages not in the pending lists.
0000000000000000000000000000000000000000;;		var a []pgid
0000000000000000000000000000000000000000;;		for _, id := range f.ids {
0000000000000000000000000000000000000000;;			if !pcache[id] {
0000000000000000000000000000000000000000;;				a = append(a, id)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.ids = a
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Once the available list is rebuilt then rebuild the free cache so that
0000000000000000000000000000000000000000;;		// it includes the available and pending free pages.
0000000000000000000000000000000000000000;;		f.reindex()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reindex rebuilds the free cache based on available and pending free lists.
0000000000000000000000000000000000000000;;	func (f *freelist) reindex() {
0000000000000000000000000000000000000000;;		f.cache = make(map[pgid]bool)
0000000000000000000000000000000000000000;;		for _, id := range f.ids {
0000000000000000000000000000000000000000;;			f.cache[id] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pendingIDs := range f.pending {
0000000000000000000000000000000000000000;;			for _, pendingID := range pendingIDs {
0000000000000000000000000000000000000000;;				f.cache[pendingID] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
