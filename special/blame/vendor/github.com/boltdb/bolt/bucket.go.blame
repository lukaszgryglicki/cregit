0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/bucket.go[Godeps/_workspace/src/github.com/boltdb/bolt/bucket.go][vendor/github.com/boltdb/bolt/bucket.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// MaxKeySize is the maximum length of a key, in bytes.
0000000000000000000000000000000000000000;;		MaxKeySize = 32768
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MaxValueSize is the maximum length of a value, in bytes.
0000000000000000000000000000000000000000;;		MaxValueSize = (1 << 31) - 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxUint = ^uint(0)
0000000000000000000000000000000000000000;;		minUint = 0
0000000000000000000000000000000000000000;;		maxInt  = int(^uint(0) >> 1)
0000000000000000000000000000000000000000;;		minInt  = -maxInt - 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const bucketHeaderSize = int(unsafe.Sizeof(bucket{}))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		minFillPercent = 0.1
0000000000000000000000000000000000000000;;		maxFillPercent = 1.0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultFillPercent is the percentage that split pages are filled.
0000000000000000000000000000000000000000;;	// This value can be changed by setting Bucket.FillPercent.
0000000000000000000000000000000000000000;;	const DefaultFillPercent = 0.5
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bucket represents a collection of key/value pairs inside the database.
0000000000000000000000000000000000000000;;	type Bucket struct {
0000000000000000000000000000000000000000;;		*bucket
0000000000000000000000000000000000000000;;		tx       *Tx                // the associated transaction
0000000000000000000000000000000000000000;;		buckets  map[string]*Bucket // subbucket cache
0000000000000000000000000000000000000000;;		page     *page              // inline page reference
0000000000000000000000000000000000000000;;		rootNode *node              // materialized node for the root page.
0000000000000000000000000000000000000000;;		nodes    map[pgid]*node     // node cache
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sets the threshold for filling nodes when they split. By default,
0000000000000000000000000000000000000000;;		// the bucket will fill to 50% but it can be useful to increase this
0000000000000000000000000000000000000000;;		// amount if you know that your write workloads are mostly append-only.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This is non-persisted across transactions so it must be set in every Tx.
0000000000000000000000000000000000000000;;		FillPercent float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// bucket represents the on-file representation of a bucket.
0000000000000000000000000000000000000000;;	// This is stored as the "value" of a bucket key. If the bucket is small enough,
0000000000000000000000000000000000000000;;	// then its root page can be stored inline in the "value", after the bucket
0000000000000000000000000000000000000000;;	// header. In the case of inline buckets, the "root" will be 0.
0000000000000000000000000000000000000000;;	type bucket struct {
0000000000000000000000000000000000000000;;		root     pgid   // page id of the bucket's root-level page
0000000000000000000000000000000000000000;;		sequence uint64 // monotonically incrementing, used by NextSequence()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newBucket returns a new bucket associated with a transaction.
0000000000000000000000000000000000000000;;	func newBucket(tx *Tx) Bucket {
0000000000000000000000000000000000000000;;		var b = Bucket{tx: tx, FillPercent: DefaultFillPercent}
0000000000000000000000000000000000000000;;		if tx.writable {
0000000000000000000000000000000000000000;;			b.buckets = make(map[string]*Bucket)
0000000000000000000000000000000000000000;;			b.nodes = make(map[pgid]*node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tx returns the tx of the bucket.
0000000000000000000000000000000000000000;;	func (b *Bucket) Tx() *Tx {
0000000000000000000000000000000000000000;;		return b.tx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Root returns the root of the bucket.
0000000000000000000000000000000000000000;;	func (b *Bucket) Root() pgid {
0000000000000000000000000000000000000000;;		return b.root
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writable returns whether the bucket is writable.
0000000000000000000000000000000000000000;;	func (b *Bucket) Writable() bool {
0000000000000000000000000000000000000000;;		return b.tx.writable
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cursor creates a cursor associated with the bucket.
0000000000000000000000000000000000000000;;	// The cursor is only valid as long as the transaction is open.
0000000000000000000000000000000000000000;;	// Do not use a cursor after the transaction is closed.
0000000000000000000000000000000000000000;;	func (b *Bucket) Cursor() *Cursor {
0000000000000000000000000000000000000000;;		// Update transaction statistics.
0000000000000000000000000000000000000000;;		b.tx.stats.CursorCount++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allocate and return a cursor.
0000000000000000000000000000000000000000;;		return &Cursor{
0000000000000000000000000000000000000000;;			bucket: b,
0000000000000000000000000000000000000000;;			stack:  make([]elemRef, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bucket retrieves a nested bucket by name.
0000000000000000000000000000000000000000;;	// Returns nil if the bucket does not exist.
0000000000000000000000000000000000000000;;	// The bucket instance is only valid for the lifetime of the transaction.
0000000000000000000000000000000000000000;;	func (b *Bucket) Bucket(name []byte) *Bucket {
0000000000000000000000000000000000000000;;		if b.buckets != nil {
0000000000000000000000000000000000000000;;			if child := b.buckets[string(name)]; child != nil {
0000000000000000000000000000000000000000;;				return child
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move cursor to key.
0000000000000000000000000000000000000000;;		c := b.Cursor()
0000000000000000000000000000000000000000;;		k, v, flags := c.seek(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return nil if the key doesn't exist or it is not a bucket.
0000000000000000000000000000000000000000;;		if !bytes.Equal(name, k) || (flags&bucketLeafFlag) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise create a bucket and cache it.
0000000000000000000000000000000000000000;;		var child = b.openBucket(v)
0000000000000000000000000000000000000000;;		if b.buckets != nil {
0000000000000000000000000000000000000000;;			b.buckets[string(name)] = child
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return child
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper method that re-interprets a sub-bucket value
0000000000000000000000000000000000000000;;	// from a parent into a Bucket
0000000000000000000000000000000000000000;;	func (b *Bucket) openBucket(value []byte) *Bucket {
0000000000000000000000000000000000000000;;		var child = newBucket(b.tx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If this is a writable transaction then we need to copy the bucket entry.
0000000000000000000000000000000000000000;;		// Read-only transactions can point directly at the mmap entry.
0000000000000000000000000000000000000000;;		if b.tx.writable {
0000000000000000000000000000000000000000;;			child.bucket = &bucket{}
0000000000000000000000000000000000000000;;			*child.bucket = *(*bucket)(unsafe.Pointer(&value[0]))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			child.bucket = (*bucket)(unsafe.Pointer(&value[0]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save a reference to the inline page if the bucket is inline.
0000000000000000000000000000000000000000;;		if child.root == 0 {
0000000000000000000000000000000000000000;;			child.page = (*page)(unsafe.Pointer(&value[bucketHeaderSize]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &child
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateBucket creates a new bucket at the given key and returns the new bucket.
0000000000000000000000000000000000000000;;	// Returns an error if the key already exists, if the bucket name is blank, or if the bucket name is too long.
0000000000000000000000000000000000000000;;	// The bucket instance is only valid for the lifetime of the transaction.
0000000000000000000000000000000000000000;;	func (b *Bucket) CreateBucket(key []byte) (*Bucket, error) {
0000000000000000000000000000000000000000;;		if b.tx.db == nil {
0000000000000000000000000000000000000000;;			return nil, ErrTxClosed
0000000000000000000000000000000000000000;;		} else if !b.tx.writable {
0000000000000000000000000000000000000000;;			return nil, ErrTxNotWritable
0000000000000000000000000000000000000000;;		} else if len(key) == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrBucketNameRequired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move cursor to correct position.
0000000000000000000000000000000000000000;;		c := b.Cursor()
0000000000000000000000000000000000000000;;		k, _, flags := c.seek(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return an error if there is an existing key.
0000000000000000000000000000000000000000;;		if bytes.Equal(key, k) {
0000000000000000000000000000000000000000;;			if (flags & bucketLeafFlag) != 0 {
0000000000000000000000000000000000000000;;				return nil, ErrBucketExists
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, ErrIncompatibleValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create empty, inline bucket.
0000000000000000000000000000000000000000;;		var bucket = Bucket{
0000000000000000000000000000000000000000;;			bucket:      &bucket{},
0000000000000000000000000000000000000000;;			rootNode:    &node{isLeaf: true},
0000000000000000000000000000000000000000;;			FillPercent: DefaultFillPercent,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var value = bucket.write()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Insert into node.
0000000000000000000000000000000000000000;;		key = cloneBytes(key)
0000000000000000000000000000000000000000;;		c.node().put(key, key, value, 0, bucketLeafFlag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Since subbuckets are not allowed on inline buckets, we need to
0000000000000000000000000000000000000000;;		// dereference the inline page, if it exists. This will cause the bucket
0000000000000000000000000000000000000000;;		// to be treated as a regular, non-inline bucket for the rest of the tx.
0000000000000000000000000000000000000000;;		b.page = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b.Bucket(key), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateBucketIfNotExists creates a new bucket if it doesn't already exist and returns a reference to it.
0000000000000000000000000000000000000000;;	// Returns an error if the bucket name is blank, or if the bucket name is too long.
0000000000000000000000000000000000000000;;	// The bucket instance is only valid for the lifetime of the transaction.
0000000000000000000000000000000000000000;;	func (b *Bucket) CreateBucketIfNotExists(key []byte) (*Bucket, error) {
0000000000000000000000000000000000000000;;		child, err := b.CreateBucket(key)
0000000000000000000000000000000000000000;;		if err == ErrBucketExists {
0000000000000000000000000000000000000000;;			return b.Bucket(key), nil
0000000000000000000000000000000000000000;;		} else if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return child, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteBucket deletes a bucket at the given key.
0000000000000000000000000000000000000000;;	// Returns an error if the bucket does not exists, or if the key represents a non-bucket value.
0000000000000000000000000000000000000000;;	func (b *Bucket) DeleteBucket(key []byte) error {
0000000000000000000000000000000000000000;;		if b.tx.db == nil {
0000000000000000000000000000000000000000;;			return ErrTxClosed
0000000000000000000000000000000000000000;;		} else if !b.Writable() {
0000000000000000000000000000000000000000;;			return ErrTxNotWritable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move cursor to correct position.
0000000000000000000000000000000000000000;;		c := b.Cursor()
0000000000000000000000000000000000000000;;		k, _, flags := c.seek(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return an error if bucket doesn't exist or is not a bucket.
0000000000000000000000000000000000000000;;		if !bytes.Equal(key, k) {
0000000000000000000000000000000000000000;;			return ErrBucketNotFound
0000000000000000000000000000000000000000;;		} else if (flags & bucketLeafFlag) == 0 {
0000000000000000000000000000000000000000;;			return ErrIncompatibleValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively delete all child buckets.
0000000000000000000000000000000000000000;;		child := b.Bucket(key)
0000000000000000000000000000000000000000;;		err := child.ForEach(func(k, v []byte) error {
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				if err := child.DeleteBucket(k); err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("delete bucket: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove cached copy.
0000000000000000000000000000000000000000;;		delete(b.buckets, string(key))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Release all bucket pages to freelist.
0000000000000000000000000000000000000000;;		child.nodes = nil
0000000000000000000000000000000000000000;;		child.rootNode = nil
0000000000000000000000000000000000000000;;		child.free()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the node if we have a matching key.
0000000000000000000000000000000000000000;;		c.node().del(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves the value for a key in the bucket.
0000000000000000000000000000000000000000;;	// Returns a nil value if the key does not exist or if the key is a nested bucket.
0000000000000000000000000000000000000000;;	// The returned value is only valid for the life of the transaction.
0000000000000000000000000000000000000000;;	func (b *Bucket) Get(key []byte) []byte {
0000000000000000000000000000000000000000;;		k, v, flags := b.Cursor().seek(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return nil if this is a bucket.
0000000000000000000000000000000000000000;;		if (flags & bucketLeafFlag) != 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If our target node isn't the same key as what's passed in then return nil.
0000000000000000000000000000000000000000;;		if !bytes.Equal(key, k) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Put sets the value for a key in the bucket.
0000000000000000000000000000000000000000;;	// If the key exist then its previous value will be overwritten.
0000000000000000000000000000000000000000;;	// Supplied value must remain valid for the life of the transaction.
0000000000000000000000000000000000000000;;	// Returns an error if the bucket was created from a read-only transaction, if the key is blank, if the key is too large, or if the value is too large.
0000000000000000000000000000000000000000;;	func (b *Bucket) Put(key []byte, value []byte) error {
0000000000000000000000000000000000000000;;		if b.tx.db == nil {
0000000000000000000000000000000000000000;;			return ErrTxClosed
0000000000000000000000000000000000000000;;		} else if !b.Writable() {
0000000000000000000000000000000000000000;;			return ErrTxNotWritable
0000000000000000000000000000000000000000;;		} else if len(key) == 0 {
0000000000000000000000000000000000000000;;			return ErrKeyRequired
0000000000000000000000000000000000000000;;		} else if len(key) > MaxKeySize {
0000000000000000000000000000000000000000;;			return ErrKeyTooLarge
0000000000000000000000000000000000000000;;		} else if int64(len(value)) > MaxValueSize {
0000000000000000000000000000000000000000;;			return ErrValueTooLarge
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move cursor to correct position.
0000000000000000000000000000000000000000;;		c := b.Cursor()
0000000000000000000000000000000000000000;;		k, _, flags := c.seek(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return an error if there is an existing key with a bucket value.
0000000000000000000000000000000000000000;;		if bytes.Equal(key, k) && (flags&bucketLeafFlag) != 0 {
0000000000000000000000000000000000000000;;			return ErrIncompatibleValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Insert into node.
0000000000000000000000000000000000000000;;		key = cloneBytes(key)
0000000000000000000000000000000000000000;;		c.node().put(key, key, value, 0, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes a key from the bucket.
0000000000000000000000000000000000000000;;	// If the key does not exist then nothing is done and a nil error is returned.
0000000000000000000000000000000000000000;;	// Returns an error if the bucket was created from a read-only transaction.
0000000000000000000000000000000000000000;;	func (b *Bucket) Delete(key []byte) error {
0000000000000000000000000000000000000000;;		if b.tx.db == nil {
0000000000000000000000000000000000000000;;			return ErrTxClosed
0000000000000000000000000000000000000000;;		} else if !b.Writable() {
0000000000000000000000000000000000000000;;			return ErrTxNotWritable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move cursor to correct position.
0000000000000000000000000000000000000000;;		c := b.Cursor()
0000000000000000000000000000000000000000;;		_, _, flags := c.seek(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return an error if there is already existing bucket value.
0000000000000000000000000000000000000000;;		if (flags & bucketLeafFlag) != 0 {
0000000000000000000000000000000000000000;;			return ErrIncompatibleValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Delete the node if we have a matching key.
0000000000000000000000000000000000000000;;		c.node().del(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextSequence returns an autoincrementing integer for the bucket.
0000000000000000000000000000000000000000;;	func (b *Bucket) NextSequence() (uint64, error) {
0000000000000000000000000000000000000000;;		if b.tx.db == nil {
0000000000000000000000000000000000000000;;			return 0, ErrTxClosed
0000000000000000000000000000000000000000;;		} else if !b.Writable() {
0000000000000000000000000000000000000000;;			return 0, ErrTxNotWritable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Materialize the root node if it hasn't been already so that the
0000000000000000000000000000000000000000;;		// bucket will be saved during commit.
0000000000000000000000000000000000000000;;		if b.rootNode == nil {
0000000000000000000000000000000000000000;;			_ = b.node(b.root, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Increment and return the sequence.
0000000000000000000000000000000000000000;;		b.bucket.sequence++
0000000000000000000000000000000000000000;;		return b.bucket.sequence, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForEach executes a function for each key/value pair in a bucket.
0000000000000000000000000000000000000000;;	// If the provided function returns an error then the iteration is stopped and
0000000000000000000000000000000000000000;;	// the error is returned to the caller. The provided function must not modify
0000000000000000000000000000000000000000;;	// the bucket; this will result in undefined behavior.
0000000000000000000000000000000000000000;;	func (b *Bucket) ForEach(fn func(k, v []byte) error) error {
0000000000000000000000000000000000000000;;		if b.tx.db == nil {
0000000000000000000000000000000000000000;;			return ErrTxClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := b.Cursor()
0000000000000000000000000000000000000000;;		for k, v := c.First(); k != nil; k, v = c.Next() {
0000000000000000000000000000000000000000;;			if err := fn(k, v); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stat returns stats on a bucket.
0000000000000000000000000000000000000000;;	func (b *Bucket) Stats() BucketStats {
0000000000000000000000000000000000000000;;		var s, subStats BucketStats
0000000000000000000000000000000000000000;;		pageSize := b.tx.db.pageSize
0000000000000000000000000000000000000000;;		s.BucketN += 1
0000000000000000000000000000000000000000;;		if b.root == 0 {
0000000000000000000000000000000000000000;;			s.InlineBucketN += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.forEachPage(func(p *page, depth int) {
0000000000000000000000000000000000000000;;			if (p.flags & leafPageFlag) != 0 {
0000000000000000000000000000000000000000;;				s.KeyN += int(p.count)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// used totals the used bytes for the page
0000000000000000000000000000000000000000;;				used := pageHeaderSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if p.count != 0 {
0000000000000000000000000000000000000000;;					// If page has any elements, add all element headers.
0000000000000000000000000000000000000000;;					used += leafPageElementSize * int(p.count-1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Add all element key, value sizes.
0000000000000000000000000000000000000000;;					// The computation takes advantage of the fact that the position
0000000000000000000000000000000000000000;;					// of the last element's key/value equals to the total of the sizes
0000000000000000000000000000000000000000;;					// of all previous elements' keys and values.
0000000000000000000000000000000000000000;;					// It also includes the last element's header.
0000000000000000000000000000000000000000;;					lastElement := p.leafPageElement(p.count - 1)
0000000000000000000000000000000000000000;;					used += int(lastElement.pos + lastElement.ksize + lastElement.vsize)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if b.root == 0 {
0000000000000000000000000000000000000000;;					// For inlined bucket just update the inline stats
0000000000000000000000000000000000000000;;					s.InlineBucketInuse += used
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// For non-inlined bucket update all the leaf stats
0000000000000000000000000000000000000000;;					s.LeafPageN++
0000000000000000000000000000000000000000;;					s.LeafInuse += used
0000000000000000000000000000000000000000;;					s.LeafOverflowN += int(p.overflow)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Collect stats from sub-buckets.
0000000000000000000000000000000000000000;;					// Do that by iterating over all element headers
0000000000000000000000000000000000000000;;					// looking for the ones with the bucketLeafFlag.
0000000000000000000000000000000000000000;;					for i := uint16(0); i < p.count; i++ {
0000000000000000000000000000000000000000;;						e := p.leafPageElement(i)
0000000000000000000000000000000000000000;;						if (e.flags & bucketLeafFlag) != 0 {
0000000000000000000000000000000000000000;;							// For any bucket element, open the element value
0000000000000000000000000000000000000000;;							// and recursively call Stats on the contained bucket.
0000000000000000000000000000000000000000;;							subStats.Add(b.openBucket(e.value()).Stats())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if (p.flags & branchPageFlag) != 0 {
0000000000000000000000000000000000000000;;				s.BranchPageN++
0000000000000000000000000000000000000000;;				lastElement := p.branchPageElement(p.count - 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// used totals the used bytes for the page
0000000000000000000000000000000000000000;;				// Add header and all element headers.
0000000000000000000000000000000000000000;;				used := pageHeaderSize + (branchPageElementSize * int(p.count-1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Add size of all keys and values.
0000000000000000000000000000000000000000;;				// Again, use the fact that last element's position equals to
0000000000000000000000000000000000000000;;				// the total of key, value sizes of all previous elements.
0000000000000000000000000000000000000000;;				used += int(lastElement.pos + lastElement.ksize)
0000000000000000000000000000000000000000;;				s.BranchInuse += used
0000000000000000000000000000000000000000;;				s.BranchOverflowN += int(p.overflow)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Keep track of maximum page depth.
0000000000000000000000000000000000000000;;			if depth+1 > s.Depth {
0000000000000000000000000000000000000000;;				s.Depth = (depth + 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Alloc stats can be computed from page counts and pageSize.
0000000000000000000000000000000000000000;;		s.BranchAlloc = (s.BranchPageN + s.BranchOverflowN) * pageSize
0000000000000000000000000000000000000000;;		s.LeafAlloc = (s.LeafPageN + s.LeafOverflowN) * pageSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the max depth of sub-buckets to get total nested depth.
0000000000000000000000000000000000000000;;		s.Depth += subStats.Depth
0000000000000000000000000000000000000000;;		// Add the stats for all sub-buckets
0000000000000000000000000000000000000000;;		s.Add(subStats)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forEachPage iterates over every page in a bucket, including inline pages.
0000000000000000000000000000000000000000;;	func (b *Bucket) forEachPage(fn func(*page, int)) {
0000000000000000000000000000000000000000;;		// If we have an inline page then just use that.
0000000000000000000000000000000000000000;;		if b.page != nil {
0000000000000000000000000000000000000000;;			fn(b.page, 0)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise traverse the page hierarchy.
0000000000000000000000000000000000000000;;		b.tx.forEachPage(b.root, 0, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// forEachPageNode iterates over every page (or node) in a bucket.
0000000000000000000000000000000000000000;;	// This also includes inline pages.
0000000000000000000000000000000000000000;;	func (b *Bucket) forEachPageNode(fn func(*page, *node, int)) {
0000000000000000000000000000000000000000;;		// If we have an inline page or root node then just use that.
0000000000000000000000000000000000000000;;		if b.page != nil {
0000000000000000000000000000000000000000;;			fn(b.page, nil, 0)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b._forEachPageNode(b.root, 0, fn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *Bucket) _forEachPageNode(pgid pgid, depth int, fn func(*page, *node, int)) {
0000000000000000000000000000000000000000;;		var p, n = b.pageNode(pgid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Execute function.
0000000000000000000000000000000000000000;;		fn(p, n, depth)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively loop over children.
0000000000000000000000000000000000000000;;		if p != nil {
0000000000000000000000000000000000000000;;			if (p.flags & branchPageFlag) != 0 {
0000000000000000000000000000000000000000;;				for i := 0; i < int(p.count); i++ {
0000000000000000000000000000000000000000;;					elem := p.branchPageElement(uint16(i))
0000000000000000000000000000000000000000;;					b._forEachPageNode(elem.pgid, depth+1, fn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if !n.isLeaf {
0000000000000000000000000000000000000000;;				for _, inode := range n.inodes {
0000000000000000000000000000000000000000;;					b._forEachPageNode(inode.pgid, depth+1, fn)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// spill writes all the nodes for this bucket to dirty pages.
0000000000000000000000000000000000000000;;	func (b *Bucket) spill() error {
0000000000000000000000000000000000000000;;		// Spill all child buckets first.
0000000000000000000000000000000000000000;;		for name, child := range b.buckets {
0000000000000000000000000000000000000000;;			// If the child bucket is small enough and it has no child buckets then
0000000000000000000000000000000000000000;;			// write it inline into the parent bucket's page. Otherwise spill it
0000000000000000000000000000000000000000;;			// like a normal bucket and make the parent value a pointer to the page.
0000000000000000000000000000000000000000;;			var value []byte
0000000000000000000000000000000000000000;;			if child.inlineable() {
0000000000000000000000000000000000000000;;				child.free()
0000000000000000000000000000000000000000;;				value = child.write()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := child.spill(); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Update the child bucket header in this bucket.
0000000000000000000000000000000000000000;;				value = make([]byte, unsafe.Sizeof(bucket{}))
0000000000000000000000000000000000000000;;				var bucket = (*bucket)(unsafe.Pointer(&value[0]))
0000000000000000000000000000000000000000;;				*bucket = *child.bucket
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Skip writing the bucket if there are no materialized nodes.
0000000000000000000000000000000000000000;;			if child.rootNode == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Update parent node.
0000000000000000000000000000000000000000;;			var c = b.Cursor()
0000000000000000000000000000000000000000;;			k, _, flags := c.seek([]byte(name))
0000000000000000000000000000000000000000;;			if !bytes.Equal([]byte(name), k) {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("misplaced bucket header: %x -> %x", []byte(name), k))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if flags&bucketLeafFlag == 0 {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("unexpected bucket header flag: %x", flags))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.node().put([]byte(name), []byte(name), value, 0, bucketLeafFlag)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore if there's not a materialized root node.
0000000000000000000000000000000000000000;;		if b.rootNode == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Spill nodes.
0000000000000000000000000000000000000000;;		if err := b.rootNode.spill(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.rootNode = b.rootNode.root()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update the root node for this bucket.
0000000000000000000000000000000000000000;;		if b.rootNode.pgid >= b.tx.meta.pgid {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("pgid (%d) above high water mark (%d)", b.rootNode.pgid, b.tx.meta.pgid))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.root = b.rootNode.pgid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// inlineable returns true if a bucket is small enough to be written inline
0000000000000000000000000000000000000000;;	// and if it contains no subbuckets. Otherwise returns false.
0000000000000000000000000000000000000000;;	func (b *Bucket) inlineable() bool {
0000000000000000000000000000000000000000;;		var n = b.rootNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bucket must only contain a single leaf node.
0000000000000000000000000000000000000000;;		if n == nil || !n.isLeaf {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bucket is not inlineable if it contains subbuckets or if it goes beyond
0000000000000000000000000000000000000000;;		// our threshold for inline bucket size.
0000000000000000000000000000000000000000;;		var size = pageHeaderSize
0000000000000000000000000000000000000000;;		for _, inode := range n.inodes {
0000000000000000000000000000000000000000;;			size += leafPageElementSize + len(inode.key) + len(inode.value)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if inode.flags&bucketLeafFlag != 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			} else if size > b.maxInlineBucketSize() {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the maximum total size of a bucket to make it a candidate for inlining.
0000000000000000000000000000000000000000;;	func (b *Bucket) maxInlineBucketSize() int {
0000000000000000000000000000000000000000;;		return b.tx.db.pageSize / 4
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// write allocates and writes a bucket to a byte slice.
0000000000000000000000000000000000000000;;	func (b *Bucket) write() []byte {
0000000000000000000000000000000000000000;;		// Allocate the appropriate size.
0000000000000000000000000000000000000000;;		var n = b.rootNode
0000000000000000000000000000000000000000;;		var value = make([]byte, bucketHeaderSize+n.size())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write a bucket header.
0000000000000000000000000000000000000000;;		var bucket = (*bucket)(unsafe.Pointer(&value[0]))
0000000000000000000000000000000000000000;;		*bucket = *b.bucket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert byte slice to a fake page and write the root node.
0000000000000000000000000000000000000000;;		var p = (*page)(unsafe.Pointer(&value[bucketHeaderSize]))
0000000000000000000000000000000000000000;;		n.write(p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rebalance attempts to balance all nodes.
0000000000000000000000000000000000000000;;	func (b *Bucket) rebalance() {
0000000000000000000000000000000000000000;;		for _, n := range b.nodes {
0000000000000000000000000000000000000000;;			n.rebalance()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, child := range b.buckets {
0000000000000000000000000000000000000000;;			child.rebalance()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// node creates a node from a page and associates it with a given parent.
0000000000000000000000000000000000000000;;	func (b *Bucket) node(pgid pgid, parent *node) *node {
0000000000000000000000000000000000000000;;		_assert(b.nodes != nil, "nodes map expected")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve node if it's already been created.
0000000000000000000000000000000000000000;;		if n := b.nodes[pgid]; n != nil {
0000000000000000000000000000000000000000;;			return n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise create a node and cache it.
0000000000000000000000000000000000000000;;		n := &node{bucket: b, parent: parent}
0000000000000000000000000000000000000000;;		if parent == nil {
0000000000000000000000000000000000000000;;			b.rootNode = n
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			parent.children = append(parent.children, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use the inline page if this is an inline bucket.
0000000000000000000000000000000000000000;;		var p = b.page
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			p = b.tx.page(pgid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read the page into the node and cache it.
0000000000000000000000000000000000000000;;		n.read(p)
0000000000000000000000000000000000000000;;		b.nodes[pgid] = n
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Update statistics.
0000000000000000000000000000000000000000;;		b.tx.stats.NodeCount++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// free recursively frees all pages in the bucket.
0000000000000000000000000000000000000000;;	func (b *Bucket) free() {
0000000000000000000000000000000000000000;;		if b.root == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tx = b.tx
0000000000000000000000000000000000000000;;		b.forEachPageNode(func(p *page, n *node, _ int) {
0000000000000000000000000000000000000000;;			if p != nil {
0000000000000000000000000000000000000000;;				tx.db.freelist.free(tx.meta.txid, p)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n.free()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		b.root = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dereference removes all references to the old mmap.
0000000000000000000000000000000000000000;;	func (b *Bucket) dereference() {
0000000000000000000000000000000000000000;;		if b.rootNode != nil {
0000000000000000000000000000000000000000;;			b.rootNode.root().dereference()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, child := range b.buckets {
0000000000000000000000000000000000000000;;			child.dereference()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pageNode returns the in-memory node, if it exists.
0000000000000000000000000000000000000000;;	// Otherwise returns the underlying page.
0000000000000000000000000000000000000000;;	func (b *Bucket) pageNode(id pgid) (*page, *node) {
0000000000000000000000000000000000000000;;		// Inline buckets have a fake page embedded in their value so treat them
0000000000000000000000000000000000000000;;		// differently. We'll return the rootNode (if available) or the fake page.
0000000000000000000000000000000000000000;;		if b.root == 0 {
0000000000000000000000000000000000000000;;			if id != 0 {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("inline bucket non-zero page access(2): %d != 0", id))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if b.rootNode != nil {
0000000000000000000000000000000000000000;;				return nil, b.rootNode
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return b.page, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check the node cache for non-inline buckets.
0000000000000000000000000000000000000000;;		if b.nodes != nil {
0000000000000000000000000000000000000000;;			if n := b.nodes[id]; n != nil {
0000000000000000000000000000000000000000;;				return nil, n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finally lookup the page from the transaction if no node is materialized.
0000000000000000000000000000000000000000;;		return b.tx.page(id), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BucketStats records statistics about resources used by a bucket.
0000000000000000000000000000000000000000;;	type BucketStats struct {
0000000000000000000000000000000000000000;;		// Page count statistics.
0000000000000000000000000000000000000000;;		BranchPageN     int // number of logical branch pages
0000000000000000000000000000000000000000;;		BranchOverflowN int // number of physical branch overflow pages
0000000000000000000000000000000000000000;;		LeafPageN       int // number of logical leaf pages
0000000000000000000000000000000000000000;;		LeafOverflowN   int // number of physical leaf overflow pages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tree statistics.
0000000000000000000000000000000000000000;;		KeyN  int // number of keys/value pairs
0000000000000000000000000000000000000000;;		Depth int // number of levels in B+tree
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Page size utilization.
0000000000000000000000000000000000000000;;		BranchAlloc int // bytes allocated for physical branch pages
0000000000000000000000000000000000000000;;		BranchInuse int // bytes actually used for branch data
0000000000000000000000000000000000000000;;		LeafAlloc   int // bytes allocated for physical leaf pages
0000000000000000000000000000000000000000;;		LeafInuse   int // bytes actually used for leaf data
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bucket statistics
0000000000000000000000000000000000000000;;		BucketN           int // total number of buckets including the top bucket
0000000000000000000000000000000000000000;;		InlineBucketN     int // total number on inlined buckets
0000000000000000000000000000000000000000;;		InlineBucketInuse int // bytes used for inlined buckets (also accounted for in LeafInuse)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *BucketStats) Add(other BucketStats) {
0000000000000000000000000000000000000000;;		s.BranchPageN += other.BranchPageN
0000000000000000000000000000000000000000;;		s.BranchOverflowN += other.BranchOverflowN
0000000000000000000000000000000000000000;;		s.LeafPageN += other.LeafPageN
0000000000000000000000000000000000000000;;		s.LeafOverflowN += other.LeafOverflowN
0000000000000000000000000000000000000000;;		s.KeyN += other.KeyN
0000000000000000000000000000000000000000;;		if s.Depth < other.Depth {
0000000000000000000000000000000000000000;;			s.Depth = other.Depth
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.BranchAlloc += other.BranchAlloc
0000000000000000000000000000000000000000;;		s.BranchInuse += other.BranchInuse
0000000000000000000000000000000000000000;;		s.LeafAlloc += other.LeafAlloc
0000000000000000000000000000000000000000;;		s.LeafInuse += other.LeafInuse
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.BucketN += other.BucketN
0000000000000000000000000000000000000000;;		s.InlineBucketN += other.InlineBucketN
0000000000000000000000000000000000000000;;		s.InlineBucketInuse += other.InlineBucketInuse
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cloneBytes returns a copy of a given slice.
0000000000000000000000000000000000000000;;	func cloneBytes(v []byte) []byte {
0000000000000000000000000000000000000000;;		var clone = make([]byte, len(v))
0000000000000000000000000000000000000000;;		copy(clone, v)
0000000000000000000000000000000000000000;;		return clone
0000000000000000000000000000000000000000;;	}
