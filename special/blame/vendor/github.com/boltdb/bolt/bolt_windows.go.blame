0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/bolt_windows.go[Godeps/_workspace/src/github.com/boltdb/bolt/bolt_windows.go][vendor/github.com/boltdb/bolt/bolt_windows.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LockFileEx code derived from golang build filemutex_windows.go @ v1.5.1
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		modkernel32      = syscall.NewLazyDLL("kernel32.dll")
0000000000000000000000000000000000000000;;		procLockFileEx   = modkernel32.NewProc("LockFileEx")
0000000000000000000000000000000000000000;;		procUnlockFileEx = modkernel32.NewProc("UnlockFileEx")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		lockExt = ".lock"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see https://msdn.microsoft.com/en-us/library/windows/desktop/aa365203(v=vs.85).aspx
0000000000000000000000000000000000000000;;		flagLockExclusive       = 2
0000000000000000000000000000000000000000;;		flagLockFailImmediately = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// see https://msdn.microsoft.com/en-us/library/windows/desktop/ms681382(v=vs.85).aspx
0000000000000000000000000000000000000000;;		errLockViolation syscall.Errno = 0x21
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lockFileEx(h syscall.Handle, flags, reserved, locklow, lockhigh uint32, ol *syscall.Overlapped) (err error) {
0000000000000000000000000000000000000000;;		r, _, err := procLockFileEx.Call(uintptr(h), uintptr(flags), uintptr(reserved), uintptr(locklow), uintptr(lockhigh), uintptr(unsafe.Pointer(ol)))
0000000000000000000000000000000000000000;;		if r == 0 {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unlockFileEx(h syscall.Handle, reserved, locklow, lockhigh uint32, ol *syscall.Overlapped) (err error) {
0000000000000000000000000000000000000000;;		r, _, err := procUnlockFileEx.Call(uintptr(h), uintptr(reserved), uintptr(locklow), uintptr(lockhigh), uintptr(unsafe.Pointer(ol)), 0)
0000000000000000000000000000000000000000;;		if r == 0 {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fdatasync flushes written data to a file descriptor.
0000000000000000000000000000000000000000;;	func fdatasync(db *DB) error {
0000000000000000000000000000000000000000;;		return db.file.Sync()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flock acquires an advisory lock on a file descriptor.
0000000000000000000000000000000000000000;;	func flock(db *DB, mode os.FileMode, exclusive bool, timeout time.Duration) error {
0000000000000000000000000000000000000000;;		// Create a separate lock file on windows because a process
0000000000000000000000000000000000000000;;		// cannot share an exclusive lock on the same file. This is
0000000000000000000000000000000000000000;;		// needed during Tx.WriteTo().
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(db.path+lockExt, os.O_CREATE, mode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		db.lockfile = f
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var t time.Time
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// If we're beyond our timeout then return an error.
0000000000000000000000000000000000000000;;			// This can only occur after we've attempted a flock once.
0000000000000000000000000000000000000000;;			if t.IsZero() {
0000000000000000000000000000000000000000;;				t = time.Now()
0000000000000000000000000000000000000000;;			} else if timeout > 0 && time.Since(t) > timeout {
0000000000000000000000000000000000000000;;				return ErrTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var flag uint32 = flagLockFailImmediately
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				flag |= flagLockExclusive
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := lockFileEx(syscall.Handle(db.lockfile.Fd()), flag, 0, 1, 0, &syscall.Overlapped{})
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			} else if err != errLockViolation {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for a bit and try again.
0000000000000000000000000000000000000000;;			time.Sleep(50 * time.Millisecond)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// funlock releases an advisory lock on a file descriptor.
0000000000000000000000000000000000000000;;	func funlock(db *DB) error {
0000000000000000000000000000000000000000;;		err := unlockFileEx(syscall.Handle(db.lockfile.Fd()), 0, 1, 0, &syscall.Overlapped{})
0000000000000000000000000000000000000000;;		db.lockfile.Close()
0000000000000000000000000000000000000000;;		os.Remove(db.path+lockExt)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mmap memory maps a DB's data file.
0000000000000000000000000000000000000000;;	// Based on: https://github.com/edsrzf/mmap-go
0000000000000000000000000000000000000000;;	func mmap(db *DB, sz int) error {
0000000000000000000000000000000000000000;;		if !db.readOnly {
0000000000000000000000000000000000000000;;			// Truncate the database to the size of the mmap.
0000000000000000000000000000000000000000;;			if err := db.file.Truncate(int64(sz)); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("truncate: %s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Open a file mapping handle.
0000000000000000000000000000000000000000;;		sizelo := uint32(sz >> 32)
0000000000000000000000000000000000000000;;		sizehi := uint32(sz) & 0xffffffff
0000000000000000000000000000000000000000;;		h, errno := syscall.CreateFileMapping(syscall.Handle(db.file.Fd()), nil, syscall.PAGE_READONLY, sizelo, sizehi, nil)
0000000000000000000000000000000000000000;;		if h == 0 {
0000000000000000000000000000000000000000;;			return os.NewSyscallError("CreateFileMapping", errno)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the memory map.
0000000000000000000000000000000000000000;;		addr, errno := syscall.MapViewOfFile(h, syscall.FILE_MAP_READ, 0, 0, uintptr(sz))
0000000000000000000000000000000000000000;;		if addr == 0 {
0000000000000000000000000000000000000000;;			return os.NewSyscallError("MapViewOfFile", errno)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Close mapping handle.
0000000000000000000000000000000000000000;;		if err := syscall.CloseHandle(syscall.Handle(h)); err != nil {
0000000000000000000000000000000000000000;;			return os.NewSyscallError("CloseHandle", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert to a byte array.
0000000000000000000000000000000000000000;;		db.data = ((*[maxMapSize]byte)(unsafe.Pointer(addr)))
0000000000000000000000000000000000000000;;		db.datasz = sz
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// munmap unmaps a pointer from a file.
0000000000000000000000000000000000000000;;	// Based on: https://github.com/edsrzf/mmap-go
0000000000000000000000000000000000000000;;	func munmap(db *DB) error {
0000000000000000000000000000000000000000;;		if db.data == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		addr := (uintptr)(unsafe.Pointer(&db.data[0]))
0000000000000000000000000000000000000000;;		if err := syscall.UnmapViewOfFile(addr); err != nil {
0000000000000000000000000000000000000000;;			return os.NewSyscallError("UnmapViewOfFile", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
