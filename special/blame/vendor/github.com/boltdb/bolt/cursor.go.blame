0000000000000000000000000000000000000000;;	package bolt
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/boltdb/bolt/cursor.go[Godeps/_workspace/src/github.com/boltdb/bolt/cursor.go][vendor/github.com/boltdb/bolt/cursor.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cursor represents an iterator that can traverse over all key/value pairs in a bucket in sorted order.
0000000000000000000000000000000000000000;;	// Cursors see nested buckets with value == nil.
0000000000000000000000000000000000000000;;	// Cursors can be obtained from a transaction and are valid as long as the transaction is open.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Keys and values returned from the cursor are only valid for the life of the transaction.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Changing data while traversing with a cursor may cause it to be invalidated
0000000000000000000000000000000000000000;;	// and return unexpected keys and/or values. You must reposition your cursor
0000000000000000000000000000000000000000;;	// after mutating data.
0000000000000000000000000000000000000000;;	type Cursor struct {
0000000000000000000000000000000000000000;;		bucket *Bucket
0000000000000000000000000000000000000000;;		stack  []elemRef
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bucket returns the bucket that this cursor was created from.
0000000000000000000000000000000000000000;;	func (c *Cursor) Bucket() *Bucket {
0000000000000000000000000000000000000000;;		return c.bucket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// First moves the cursor to the first item in the bucket and returns its key and value.
0000000000000000000000000000000000000000;;	// If the bucket is empty then a nil key and value are returned.
0000000000000000000000000000000000000000;;	// The returned key and value are only valid for the life of the transaction.
0000000000000000000000000000000000000000;;	func (c *Cursor) First() (key []byte, value []byte) {
0000000000000000000000000000000000000000;;		_assert(c.bucket.tx.db != nil, "tx closed")
0000000000000000000000000000000000000000;;		c.stack = c.stack[:0]
0000000000000000000000000000000000000000;;		p, n := c.bucket.pageNode(c.bucket.root)
0000000000000000000000000000000000000000;;		c.stack = append(c.stack, elemRef{page: p, node: n, index: 0})
0000000000000000000000000000000000000000;;		c.first()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we land on an empty page then move to the next value.
0000000000000000000000000000000000000000;;		// https://github.com/boltdb/bolt/issues/450
0000000000000000000000000000000000000000;;		if c.stack[len(c.stack)-1].count() == 0 {
0000000000000000000000000000000000000000;;			c.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k, v, flags := c.keyValue()
0000000000000000000000000000000000000000;;		if (flags & uint32(bucketLeafFlag)) != 0 {
0000000000000000000000000000000000000000;;			return k, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k, v
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Last moves the cursor to the last item in the bucket and returns its key and value.
0000000000000000000000000000000000000000;;	// If the bucket is empty then a nil key and value are returned.
0000000000000000000000000000000000000000;;	// The returned key and value are only valid for the life of the transaction.
0000000000000000000000000000000000000000;;	func (c *Cursor) Last() (key []byte, value []byte) {
0000000000000000000000000000000000000000;;		_assert(c.bucket.tx.db != nil, "tx closed")
0000000000000000000000000000000000000000;;		c.stack = c.stack[:0]
0000000000000000000000000000000000000000;;		p, n := c.bucket.pageNode(c.bucket.root)
0000000000000000000000000000000000000000;;		ref := elemRef{page: p, node: n}
0000000000000000000000000000000000000000;;		ref.index = ref.count() - 1
0000000000000000000000000000000000000000;;		c.stack = append(c.stack, ref)
0000000000000000000000000000000000000000;;		c.last()
0000000000000000000000000000000000000000;;		k, v, flags := c.keyValue()
0000000000000000000000000000000000000000;;		if (flags & uint32(bucketLeafFlag)) != 0 {
0000000000000000000000000000000000000000;;			return k, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k, v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next moves the cursor to the next item in the bucket and returns its key and value.
0000000000000000000000000000000000000000;;	// If the cursor is at the end of the bucket then a nil key and value are returned.
0000000000000000000000000000000000000000;;	// The returned key and value are only valid for the life of the transaction.
0000000000000000000000000000000000000000;;	func (c *Cursor) Next() (key []byte, value []byte) {
0000000000000000000000000000000000000000;;		_assert(c.bucket.tx.db != nil, "tx closed")
0000000000000000000000000000000000000000;;		k, v, flags := c.next()
0000000000000000000000000000000000000000;;		if (flags & uint32(bucketLeafFlag)) != 0 {
0000000000000000000000000000000000000000;;			return k, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k, v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prev moves the cursor to the previous item in the bucket and returns its key and value.
0000000000000000000000000000000000000000;;	// If the cursor is at the beginning of the bucket then a nil key and value are returned.
0000000000000000000000000000000000000000;;	// The returned key and value are only valid for the life of the transaction.
0000000000000000000000000000000000000000;;	func (c *Cursor) Prev() (key []byte, value []byte) {
0000000000000000000000000000000000000000;;		_assert(c.bucket.tx.db != nil, "tx closed")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Attempt to move back one element until we're successful.
0000000000000000000000000000000000000000;;		// Move up the stack as we hit the beginning of each page in our stack.
0000000000000000000000000000000000000000;;		for i := len(c.stack) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			elem := &c.stack[i]
0000000000000000000000000000000000000000;;			if elem.index > 0 {
0000000000000000000000000000000000000000;;				elem.index--
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.stack = c.stack[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we've hit the end then return nil.
0000000000000000000000000000000000000000;;		if len(c.stack) == 0 {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Move down the stack to find the last element of the last leaf under this branch.
0000000000000000000000000000000000000000;;		c.last()
0000000000000000000000000000000000000000;;		k, v, flags := c.keyValue()
0000000000000000000000000000000000000000;;		if (flags & uint32(bucketLeafFlag)) != 0 {
0000000000000000000000000000000000000000;;			return k, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k, v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seek moves the cursor to a given key and returns it.
0000000000000000000000000000000000000000;;	// If the key does not exist then the next key is used. If no keys
0000000000000000000000000000000000000000;;	// follow, a nil key is returned.
0000000000000000000000000000000000000000;;	// The returned key and value are only valid for the life of the transaction.
0000000000000000000000000000000000000000;;	func (c *Cursor) Seek(seek []byte) (key []byte, value []byte) {
0000000000000000000000000000000000000000;;		k, v, flags := c.seek(seek)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we ended up after the last element of a page then move to the next one.
0000000000000000000000000000000000000000;;		if ref := &c.stack[len(c.stack)-1]; ref.index >= ref.count() {
0000000000000000000000000000000000000000;;			k, v, flags = c.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if k == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		} else if (flags & uint32(bucketLeafFlag)) != 0 {
0000000000000000000000000000000000000000;;			return k, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k, v
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes the current key/value under the cursor from the bucket.
0000000000000000000000000000000000000000;;	// Delete fails if current key/value is a bucket or if the transaction is not writable.
0000000000000000000000000000000000000000;;	func (c *Cursor) Delete() error {
0000000000000000000000000000000000000000;;		if c.bucket.tx.db == nil {
0000000000000000000000000000000000000000;;			return ErrTxClosed
0000000000000000000000000000000000000000;;		} else if !c.bucket.Writable() {
0000000000000000000000000000000000000000;;			return ErrTxNotWritable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key, _, flags := c.keyValue()
0000000000000000000000000000000000000000;;		// Return an error if current value is a bucket.
0000000000000000000000000000000000000000;;		if (flags & bucketLeafFlag) != 0 {
0000000000000000000000000000000000000000;;			return ErrIncompatibleValue
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.node().del(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// seek moves the cursor to a given key and returns it.
0000000000000000000000000000000000000000;;	// If the key does not exist then the next key is used.
0000000000000000000000000000000000000000;;	func (c *Cursor) seek(seek []byte) (key []byte, value []byte, flags uint32) {
0000000000000000000000000000000000000000;;		_assert(c.bucket.tx.db != nil, "tx closed")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start from root page/node and traverse to correct page.
0000000000000000000000000000000000000000;;		c.stack = c.stack[:0]
0000000000000000000000000000000000000000;;		c.search(seek, c.bucket.root)
0000000000000000000000000000000000000000;;		ref := &c.stack[len(c.stack)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the cursor is pointing to the end of page/node then return nil.
0000000000000000000000000000000000000000;;		if ref.index >= ref.count() {
0000000000000000000000000000000000000000;;			return nil, nil, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If this is a bucket then return a nil value.
0000000000000000000000000000000000000000;;		return c.keyValue()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// first moves the cursor to the first leaf element under the last page in the stack.
0000000000000000000000000000000000000000;;	func (c *Cursor) first() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Exit when we hit a leaf page.
0000000000000000000000000000000000000000;;			var ref = &c.stack[len(c.stack)-1]
0000000000000000000000000000000000000000;;			if ref.isLeaf() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Keep adding pages pointing to the first element to the stack.
0000000000000000000000000000000000000000;;			var pgid pgid
0000000000000000000000000000000000000000;;			if ref.node != nil {
0000000000000000000000000000000000000000;;				pgid = ref.node.inodes[ref.index].pgid
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pgid = ref.page.branchPageElement(uint16(ref.index)).pgid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p, n := c.bucket.pageNode(pgid)
0000000000000000000000000000000000000000;;			c.stack = append(c.stack, elemRef{page: p, node: n, index: 0})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// last moves the cursor to the last leaf element under the last page in the stack.
0000000000000000000000000000000000000000;;	func (c *Cursor) last() {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Exit when we hit a leaf page.
0000000000000000000000000000000000000000;;			ref := &c.stack[len(c.stack)-1]
0000000000000000000000000000000000000000;;			if ref.isLeaf() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Keep adding pages pointing to the last element in the stack.
0000000000000000000000000000000000000000;;			var pgid pgid
0000000000000000000000000000000000000000;;			if ref.node != nil {
0000000000000000000000000000000000000000;;				pgid = ref.node.inodes[ref.index].pgid
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pgid = ref.page.branchPageElement(uint16(ref.index)).pgid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p, n := c.bucket.pageNode(pgid)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var nextRef = elemRef{page: p, node: n}
0000000000000000000000000000000000000000;;			nextRef.index = nextRef.count() - 1
0000000000000000000000000000000000000000;;			c.stack = append(c.stack, nextRef)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// next moves to the next leaf element and returns the key and value.
0000000000000000000000000000000000000000;;	// If the cursor is at the last leaf element then it stays there and returns nil.
0000000000000000000000000000000000000000;;	func (c *Cursor) next() (key []byte, value []byte, flags uint32) {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Attempt to move over one element until we're successful.
0000000000000000000000000000000000000000;;			// Move up the stack as we hit the end of each page in our stack.
0000000000000000000000000000000000000000;;			var i int
0000000000000000000000000000000000000000;;			for i = len(c.stack) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				elem := &c.stack[i]
0000000000000000000000000000000000000000;;				if elem.index < elem.count()-1 {
0000000000000000000000000000000000000000;;					elem.index++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we've hit the root page then stop and return. This will leave the
0000000000000000000000000000000000000000;;			// cursor on the last element of the last page.
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				return nil, nil, 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Otherwise start from where we left off in the stack and find the
0000000000000000000000000000000000000000;;			// first element of the first leaf page.
0000000000000000000000000000000000000000;;			c.stack = c.stack[:i+1]
0000000000000000000000000000000000000000;;			c.first()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If this is an empty page then restart and move back up the stack.
0000000000000000000000000000000000000000;;			// https://github.com/boltdb/bolt/issues/450
0000000000000000000000000000000000000000;;			if c.stack[len(c.stack)-1].count() == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return c.keyValue()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// search recursively performs a binary search against a given page/node until it finds a given key.
0000000000000000000000000000000000000000;;	func (c *Cursor) search(key []byte, pgid pgid) {
0000000000000000000000000000000000000000;;		p, n := c.bucket.pageNode(pgid)
0000000000000000000000000000000000000000;;		if p != nil && (p.flags&(branchPageFlag|leafPageFlag)) == 0 {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("invalid page type: %d: %x", p.id, p.flags))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e := elemRef{page: p, node: n}
0000000000000000000000000000000000000000;;		c.stack = append(c.stack, e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we're on a leaf page/node then find the specific node.
0000000000000000000000000000000000000000;;		if e.isLeaf() {
0000000000000000000000000000000000000000;;			c.nsearch(key)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n != nil {
0000000000000000000000000000000000000000;;			c.searchNode(key, n)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.searchPage(key, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cursor) searchNode(key []byte, n *node) {
0000000000000000000000000000000000000000;;		var exact bool
0000000000000000000000000000000000000000;;		index := sort.Search(len(n.inodes), func(i int) bool {
0000000000000000000000000000000000000000;;			// TODO(benbjohnson): Optimize this range search. It's a bit hacky right now.
0000000000000000000000000000000000000000;;			// sort.Search() finds the lowest index where f() != -1 but we need the highest index.
0000000000000000000000000000000000000000;;			ret := bytes.Compare(n.inodes[i].key, key)
0000000000000000000000000000000000000000;;			if ret == 0 {
0000000000000000000000000000000000000000;;				exact = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ret != -1
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if !exact && index > 0 {
0000000000000000000000000000000000000000;;			index--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.stack[len(c.stack)-1].index = index
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively search to the next page.
0000000000000000000000000000000000000000;;		c.search(key, n.inodes[index].pgid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cursor) searchPage(key []byte, p *page) {
0000000000000000000000000000000000000000;;		// Binary search for the correct range.
0000000000000000000000000000000000000000;;		inodes := p.branchPageElements()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var exact bool
0000000000000000000000000000000000000000;;		index := sort.Search(int(p.count), func(i int) bool {
0000000000000000000000000000000000000000;;			// TODO(benbjohnson): Optimize this range search. It's a bit hacky right now.
0000000000000000000000000000000000000000;;			// sort.Search() finds the lowest index where f() != -1 but we need the highest index.
0000000000000000000000000000000000000000;;			ret := bytes.Compare(inodes[i].key(), key)
0000000000000000000000000000000000000000;;			if ret == 0 {
0000000000000000000000000000000000000000;;				exact = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ret != -1
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if !exact && index > 0 {
0000000000000000000000000000000000000000;;			index--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.stack[len(c.stack)-1].index = index
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Recursively search to the next page.
0000000000000000000000000000000000000000;;		c.search(key, inodes[index].pgid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nsearch searches the leaf node on the top of the stack for a key.
0000000000000000000000000000000000000000;;	func (c *Cursor) nsearch(key []byte) {
0000000000000000000000000000000000000000;;		e := &c.stack[len(c.stack)-1]
0000000000000000000000000000000000000000;;		p, n := e.page, e.node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have a node then search its inodes.
0000000000000000000000000000000000000000;;		if n != nil {
0000000000000000000000000000000000000000;;			index := sort.Search(len(n.inodes), func(i int) bool {
0000000000000000000000000000000000000000;;				return bytes.Compare(n.inodes[i].key, key) != -1
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			e.index = index
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have a page then search its leaf elements.
0000000000000000000000000000000000000000;;		inodes := p.leafPageElements()
0000000000000000000000000000000000000000;;		index := sort.Search(int(p.count), func(i int) bool {
0000000000000000000000000000000000000000;;			return bytes.Compare(inodes[i].key(), key) != -1
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		e.index = index
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// keyValue returns the key and value of the current leaf element.
0000000000000000000000000000000000000000;;	func (c *Cursor) keyValue() ([]byte, []byte, uint32) {
0000000000000000000000000000000000000000;;		ref := &c.stack[len(c.stack)-1]
0000000000000000000000000000000000000000;;		if ref.count() == 0 || ref.index >= ref.count() {
0000000000000000000000000000000000000000;;			return nil, nil, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Retrieve value from node.
0000000000000000000000000000000000000000;;		if ref.node != nil {
0000000000000000000000000000000000000000;;			inode := &ref.node.inodes[ref.index]
0000000000000000000000000000000000000000;;			return inode.key, inode.value, inode.flags
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Or retrieve value from page.
0000000000000000000000000000000000000000;;		elem := ref.page.leafPageElement(uint16(ref.index))
0000000000000000000000000000000000000000;;		return elem.key(), elem.value(), elem.flags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// node returns the node that the cursor is currently positioned on.
0000000000000000000000000000000000000000;;	func (c *Cursor) node() *node {
0000000000000000000000000000000000000000;;		_assert(len(c.stack) > 0, "accessing a node with a zero-length cursor stack")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the top of the stack is a leaf node then just return it.
0000000000000000000000000000000000000000;;		if ref := &c.stack[len(c.stack)-1]; ref.node != nil && ref.isLeaf() {
0000000000000000000000000000000000000000;;			return ref.node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start from root and traverse down the hierarchy.
0000000000000000000000000000000000000000;;		var n = c.stack[0].node
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			n = c.bucket.node(c.stack[0].page.id, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ref := range c.stack[:len(c.stack)-1] {
0000000000000000000000000000000000000000;;			_assert(!n.isLeaf, "expected branch node")
0000000000000000000000000000000000000000;;			n = n.childAt(int(ref.index))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_assert(n.isLeaf, "expected leaf node")
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// elemRef represents a reference to an element on a given page/node.
0000000000000000000000000000000000000000;;	type elemRef struct {
0000000000000000000000000000000000000000;;		page  *page
0000000000000000000000000000000000000000;;		node  *node
0000000000000000000000000000000000000000;;		index int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isLeaf returns whether the ref is pointing at a leaf page/node.
0000000000000000000000000000000000000000;;	func (r *elemRef) isLeaf() bool {
0000000000000000000000000000000000000000;;		if r.node != nil {
0000000000000000000000000000000000000000;;			return r.node.isLeaf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (r.page.flags & leafPageFlag) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// count returns the number of inodes or page elements.
0000000000000000000000000000000000000000;;	func (r *elemRef) count() int {
0000000000000000000000000000000000000000;;		if r.node != nil {
0000000000000000000000000000000000000000;;			return len(r.node.inodes)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(r.page.count)
0000000000000000000000000000000000000000;;	}
