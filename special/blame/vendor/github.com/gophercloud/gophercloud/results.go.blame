0000000000000000000000000000000000000000;;	package gophercloud
c191e5bce96b97325e2d7149d40cc3a540ce2fa4;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Result is an internal type to be used by individual resource packages, but its
0000000000000000000000000000000000000000;;	methods will be available on a wide variety of user-facing embedding types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It acts as a base struct that other Result types, returned from request
0000000000000000000000000000000000000000;;	functions, can embed for convenience. All Results capture basic information
0000000000000000000000000000000000000000;;	from the HTTP transaction that was performed, including the response body,
0000000000000000000000000000000000000000;;	HTTP headers, and any errors that happened.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Generally, each Result type will have an Extract method that can be used to
0000000000000000000000000000000000000000;;	further interpret the result's payload in a specific context. Extensions or
0000000000000000000000000000000000000000;;	providers can then provide additional extraction functions to pull out
0000000000000000000000000000000000000000;;	provider- or extension-specific information as well.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type Result struct {
0000000000000000000000000000000000000000;;		// Body is the payload of the HTTP response from the server. In most cases,
0000000000000000000000000000000000000000;;		// this will be the deserialized JSON structure.
0000000000000000000000000000000000000000;;		Body interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Header contains the HTTP header structure from the original response.
0000000000000000000000000000000000000000;;		Header http.Header
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Err is an error that occurred during the operation. It's deferred until
0000000000000000000000000000000000000000;;		// extraction to make it easier to chain the Extract call.
0000000000000000000000000000000000000000;;		Err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractInto allows users to provide an object into which `Extract` will extract
0000000000000000000000000000000000000000;;	// the `Result.Body`. This would be useful for OpenStack providers that have
0000000000000000000000000000000000000000;;	// different fields in the response object than OpenStack proper.
0000000000000000000000000000000000000000;;	func (r Result) ExtractInto(to interface{}) error {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if reader, ok := r.Body.(io.Reader); ok {
0000000000000000000000000000000000000000;;			if readCloser, ok := reader.(io.Closer); ok {
0000000000000000000000000000000000000000;;				defer readCloser.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return json.NewDecoder(reader).Decode(to)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(r.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(b, to)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r Result) extractIntoPtr(to interface{}, label string) error {
0000000000000000000000000000000000000000;;		if label == "" {
0000000000000000000000000000000000000000;;			return r.ExtractInto(&to)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var m map[string]interface{}
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&m)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(m[label])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = json.Unmarshal(b, &to)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractIntoStructPtr will unmarshal the Result (r) into the provided
0000000000000000000000000000000000000000;;	// interface{} (to).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: For internal use only
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// `to` must be a pointer to an underlying struct type
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If provided, `label` will be filtered out of the response
0000000000000000000000000000000000000000;;	// body prior to `r` being unmarshalled into `to`.
0000000000000000000000000000000000000000;;	func (r Result) ExtractIntoStructPtr(to interface{}, label string) error {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(to)
0000000000000000000000000000000000000000;;		if k := t.Kind(); k != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected pointer, got %v", k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Elem().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return r.extractIntoPtr(to, label)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected pointer to struct, got: %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractIntoSlicePtr will unmarshal the Result (r) into the provided
0000000000000000000000000000000000000000;;	// interface{} (to).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: For internal use only
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// `to` must be a pointer to an underlying slice type
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If provided, `label` will be filtered out of the response
0000000000000000000000000000000000000000;;	// body prior to `r` being unmarshalled into `to`.
0000000000000000000000000000000000000000;;	func (r Result) ExtractIntoSlicePtr(to interface{}, label string) error {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := reflect.TypeOf(to)
0000000000000000000000000000000000000000;;		if k := t.Kind(); k != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected pointer, got %v", k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Elem().Kind() {
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return r.extractIntoPtr(to, label)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected pointer to slice, got: %v", t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrettyPrintJSON creates a string containing the full response body as
0000000000000000000000000000000000000000;;	// pretty-printed JSON. It's useful for capturing test fixtures and for
0000000000000000000000000000000000000000;;	// debugging extraction bugs. If you include its output in an issue related to
0000000000000000000000000000000000000000;;	// a buggy extraction function, we will all love you forever.
0000000000000000000000000000000000000000;;	func (r Result) PrettyPrintJSON() string {
0000000000000000000000000000000000000000;;		pretty, err := json.MarshalIndent(r.Body, "", "  ")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(pretty)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrResult is an internal type to be used by individual resource packages, but
0000000000000000000000000000000000000000;;	// its methods will be available on a wide variety of user-facing embedding
0000000000000000000000000000000000000000;;	// types.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It represents results that only contain a potential error and
0000000000000000000000000000000000000000;;	// nothing else. Usually, if the operation executed successfully, the Err field
0000000000000000000000000000000000000000;;	// will be nil; otherwise it will be stocked with a relevant error. Use the
0000000000000000000000000000000000000000;;	// ExtractErr method
0000000000000000000000000000000000000000;;	// to cleanly pull it out.
0000000000000000000000000000000000000000;;	type ErrResult struct {
0000000000000000000000000000000000000000;;		Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractErr is a function that extracts error information, or nil, from a result.
0000000000000000000000000000000000000000;;	func (r ErrResult) ExtractErr() error {
0000000000000000000000000000000000000000;;		return r.Err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	HeaderResult is an internal type to be used by individual resource packages, but
0000000000000000000000000000000000000000;;	its methods will be available on a wide variety of user-facing embedding types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It represents a result that only contains an error (possibly nil) and an
0000000000000000000000000000000000000000;;	http.Header. This is used, for example, by the objectstorage packages in
0000000000000000000000000000000000000000;;	openstack, because most of the operations don't return response bodies, but do
0000000000000000000000000000000000000000;;	have relevant information in headers.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type HeaderResult struct {
0000000000000000000000000000000000000000;;		Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractHeader will return the http.Header and error from the HeaderResult.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   header, err := objects.Create(client, "my_container", objects.CreateOpts{}).ExtractHeader()
0000000000000000000000000000000000000000;;	func (r HeaderResult) ExtractInto(to interface{}) error {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tmpHeaderMap := map[string]string{}
0000000000000000000000000000000000000000;;		for k, v := range r.Header {
0000000000000000000000000000000000000000;;			if len(v) > 0 {
0000000000000000000000000000000000000000;;				tmpHeaderMap[k] = v[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := json.Marshal(tmpHeaderMap)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(b, to)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC3339Milli describes a common time format used by some API responses.
0000000000000000000000000000000000000000;;	const RFC3339Milli = "2006-01-02T15:04:05.999999Z"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JSONRFC3339Milli time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (jt *JSONRFC3339Milli) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		b := bytes.NewBuffer(data)
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(b)
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := dec.Decode(&s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := time.Parse(RFC3339Milli, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*jt = JSONRFC3339Milli(t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const RFC3339MilliNoZ = "2006-01-02T15:04:05.999999"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JSONRFC3339MilliNoZ time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (jt *JSONRFC3339MilliNoZ) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := time.Parse(RFC3339MilliNoZ, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*jt = JSONRFC3339MilliNoZ(t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JSONRFC1123 time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (jt *JSONRFC1123) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := time.Parse(time.RFC1123, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*jt = JSONRFC1123(t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JSONUnix time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (jt *JSONUnix) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		unix, err := strconv.ParseInt(s, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t = time.Unix(unix, 0)
0000000000000000000000000000000000000000;;		*jt = JSONUnix(t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC3339NoZ is the time format used in Heat (Orchestration).
0000000000000000000000000000000000000000;;	const RFC3339NoZ = "2006-01-02T15:04:05"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type JSONRFC3339NoZ time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (jt *JSONRFC3339NoZ) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &s); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := time.Parse(RFC3339NoZ, s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*jt = JSONRFC3339NoZ(t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Link is an internal type to be used in packages of collection resources that are
0000000000000000000000000000000000000000;;	paginated in a certain way.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It's a response substructure common to many paginated collection results that is
0000000000000000000000000000000000000000;;	used to point to related pages. Usually, the one we care about is the one with
0000000000000000000000000000000000000000;;	Rel field set to "next".
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type Link struct {
0000000000000000000000000000000000000000;;		Href string `json:"href"`
0000000000000000000000000000000000000000;;		Rel  string `json:"rel"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	ExtractNextURL is an internal function useful for packages of collection
0000000000000000000000000000000000000000;;	resources that are paginated in a certain way.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It attempts to extract the "next" URL from slice of Link structs, or
0000000000000000000000000000000000000000;;	"" if no such URL is present.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func ExtractNextURL(links []Link) (string, error) {
0000000000000000000000000000000000000000;;		var url string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, l := range links {
0000000000000000000000000000000000000000;;			if l.Rel == "next" {
0000000000000000000000000000000000000000;;				url = l.Href
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if url == "" {
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return url, nil
0000000000000000000000000000000000000000;;	}
