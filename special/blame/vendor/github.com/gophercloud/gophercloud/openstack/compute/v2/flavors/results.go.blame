0000000000000000000000000000000000000000;;	package flavors
c191e5bce96b97325e2d7149d40cc3a540ce2fa4;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/pagination"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type commonResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateResult struct {
0000000000000000000000000000000000000000;;		commonResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResult temporarily holds the response from a Get call.
0000000000000000000000000000000000000000;;	type GetResult struct {
0000000000000000000000000000000000000000;;		commonResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract provides access to the individual Flavor returned by the Get and Create functions.
0000000000000000000000000000000000000000;;	func (r commonResult) Extract() (*Flavor, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Flavor *Flavor `json:"flavor"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&s)
0000000000000000000000000000000000000000;;		return s.Flavor, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flavor records represent (virtual) hardware configurations for server resources in a region.
0000000000000000000000000000000000000000;;	type Flavor struct {
0000000000000000000000000000000000000000;;		// The Id field contains the flavor's unique identifier.
0000000000000000000000000000000000000000;;		// For example, this identifier will be useful when specifying which hardware configuration to use for a new server instance.
0000000000000000000000000000000000000000;;		ID string `json:"id"`
0000000000000000000000000000000000000000;;		// The Disk and RA< fields provide a measure of storage space offered by the flavor, in GB and MB, respectively.
0000000000000000000000000000000000000000;;		Disk int `json:"disk"`
0000000000000000000000000000000000000000;;		RAM  int `json:"ram"`
0000000000000000000000000000000000000000;;		// The Name field provides a human-readable moniker for the flavor.
0000000000000000000000000000000000000000;;		Name       string  `json:"name"`
0000000000000000000000000000000000000000;;		RxTxFactor float64 `json:"rxtx_factor"`
0000000000000000000000000000000000000000;;		// Swap indicates how much space is reserved for swap.
0000000000000000000000000000000000000000;;		// If not provided, this field will be set to 0.
0000000000000000000000000000000000000000;;		Swap int `json:"swap"`
0000000000000000000000000000000000000000;;		// VCPUs indicates how many (virtual) CPUs are available for this flavor.
0000000000000000000000000000000000000000;;		VCPUs int `json:"vcpus"`
0000000000000000000000000000000000000000;;		// IsPublic indicates whether the flavor is public.
0000000000000000000000000000000000000000;;		IsPublic bool `json:"is_public"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Flavor) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		type tmp Flavor
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			tmp
0000000000000000000000000000000000000000;;			Swap interface{} `json:"swap"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(b, &s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*r = Flavor(s.tmp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := s.Swap.(type) {
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			r.Swap = int(t)
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case "":
0000000000000000000000000000000000000000;;				r.Swap = 0
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				swap, err := strconv.ParseFloat(t, 64)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.Swap = int(swap)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlavorPage contains a single page of the response from a List call.
0000000000000000000000000000000000000000;;	type FlavorPage struct {
0000000000000000000000000000000000000000;;		pagination.LinkedPageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty determines if a page contains any results.
0000000000000000000000000000000000000000;;	func (page FlavorPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		flavors, err := ExtractFlavors(page)
0000000000000000000000000000000000000000;;		return len(flavors) == 0, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextPageURL uses the response's embedded link reference to navigate to the next page of results.
0000000000000000000000000000000000000000;;	func (page FlavorPage) NextPageURL() (string, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Links []gophercloud.Link `json:"flavors_links"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := page.ExtractInto(&s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gophercloud.ExtractNextURL(s.Links)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractFlavors provides access to the list of flavors in a page acquired from the List operation.
0000000000000000000000000000000000000000;;	func ExtractFlavors(r pagination.Page) ([]Flavor, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Flavors []Flavor `json:"flavors"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := (r.(FlavorPage)).ExtractInto(&s)
0000000000000000000000000000000000000000;;		return s.Flavors, err
0000000000000000000000000000000000000000;;	}
