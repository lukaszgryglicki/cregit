0000000000000000000000000000000000000000;;	package servers
c191e5bce96b97325e2d7149d40cc3a540ce2fa4;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/pagination"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any serverResult as a Server, if possible.
0000000000000000000000000000000000000000;;	func (r serverResult) Extract() (*Server, error) {
0000000000000000000000000000000000000000;;		var s Server
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&s)
0000000000000000000000000000000000000000;;		return &s, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r serverResult) ExtractInto(v interface{}) error {
0000000000000000000000000000000000000000;;		return r.Result.ExtractIntoStructPtr(v, "server")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ExtractServersInto(r pagination.Page, v interface{}) error {
0000000000000000000000000000000000000000;;		return r.(ServerPage).Result.ExtractIntoSlicePtr(v, "servers")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateResult temporarily contains the response from a Create call.
0000000000000000000000000000000000000000;;	type CreateResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResult temporarily contains the response from a Get call.
0000000000000000000000000000000000000000;;	type GetResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateResult temporarily contains the response from an Update call.
0000000000000000000000000000000000000000;;	type UpdateResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteResult temporarily contains the response from a Delete call.
0000000000000000000000000000000000000000;;	type DeleteResult struct {
0000000000000000000000000000000000000000;;		gophercloud.ErrResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RebuildResult temporarily contains the response from a Rebuild call.
0000000000000000000000000000000000000000;;	type RebuildResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActionResult represents the result of server action operations, like reboot
0000000000000000000000000000000000000000;;	type ActionResult struct {
0000000000000000000000000000000000000000;;		gophercloud.ErrResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RescueResult represents the result of a server rescue operation
0000000000000000000000000000000000000000;;	type RescueResult struct {
0000000000000000000000000000000000000000;;		ActionResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateImageResult represents the result of an image creation operation
0000000000000000000000000000000000000000;;	type CreateImageResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPasswordResult represent the result of a get os-server-password operation.
0000000000000000000000000000000000000000;;	type GetPasswordResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractPassword gets the encrypted password.
0000000000000000000000000000000000000000;;	// If privateKey != nil the password is decrypted with the private key.
0000000000000000000000000000000000000000;;	// If privateKey == nil the encrypted password is returned and can be decrypted with:
0000000000000000000000000000000000000000;;	//   echo '<pwd>' | base64 -D | openssl rsautl -decrypt -inkey <private_key>
0000000000000000000000000000000000000000;;	func (r GetPasswordResult) ExtractPassword(privateKey *rsa.PrivateKey) (string, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Password string `json:"password"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&s)
0000000000000000000000000000000000000000;;		if err == nil && privateKey != nil && s.Password != "" {
0000000000000000000000000000000000000000;;			return decryptPassword(s.Password, privateKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.Password, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decryptPassword(encryptedPassword string, privateKey *rsa.PrivateKey) (string, error) {
0000000000000000000000000000000000000000;;		b64EncryptedPassword := make([]byte, base64.StdEncoding.DecodedLen(len(encryptedPassword)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := base64.StdEncoding.Decode(b64EncryptedPassword, []byte(encryptedPassword))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to base64 decode encrypted password: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		password, err := rsa.DecryptPKCS1v15(nil, privateKey, b64EncryptedPassword[0:n])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to decrypt password: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(password), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractImageID gets the ID of the newly created server image from the header
0000000000000000000000000000000000000000;;	func (r CreateImageResult) ExtractImageID() (string, error) {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return "", r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get the image id from the header
0000000000000000000000000000000000000000;;		u, err := url.ParseRequestURI(r.Header.Get("Location"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageID := path.Base(u.Path)
0000000000000000000000000000000000000000;;		if imageID == "." || imageID == "/" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to parse the ID of newly created image: %s", u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return imageID, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any RescueResult as an AdminPass, if possible.
0000000000000000000000000000000000000000;;	func (r RescueResult) Extract() (string, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			AdminPass string `json:"adminPass"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&s)
0000000000000000000000000000000000000000;;		return s.AdminPass, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server exposes only the standard OpenStack fields corresponding to a given server on the user's account.
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		// ID uniquely identifies this server amongst all other servers, including those not accessible to the current tenant.
0000000000000000000000000000000000000000;;		ID string `json:"id"`
0000000000000000000000000000000000000000;;		// TenantID identifies the tenant owning this server resource.
0000000000000000000000000000000000000000;;		TenantID string `json:"tenant_id"`
0000000000000000000000000000000000000000;;		// UserID uniquely identifies the user account owning the tenant.
0000000000000000000000000000000000000000;;		UserID string `json:"user_id"`
0000000000000000000000000000000000000000;;		// Name contains the human-readable name for the server.
0000000000000000000000000000000000000000;;		Name string `json:"name"`
0000000000000000000000000000000000000000;;		// Updated and Created contain ISO-8601 timestamps of when the state of the server last changed, and when it was created.
0000000000000000000000000000000000000000;;		Updated time.Time `json:"updated"`
0000000000000000000000000000000000000000;;		Created time.Time `json:"created"`
0000000000000000000000000000000000000000;;		HostID  string    `json:"hostid"`
0000000000000000000000000000000000000000;;		// Status contains the current operational status of the server, such as IN_PROGRESS or ACTIVE.
0000000000000000000000000000000000000000;;		Status string `json:"status"`
0000000000000000000000000000000000000000;;		// Progress ranges from 0..100.
0000000000000000000000000000000000000000;;		// A request made against the server completes only once Progress reaches 100.
0000000000000000000000000000000000000000;;		Progress int `json:"progress"`
0000000000000000000000000000000000000000;;		// AccessIPv4 and AccessIPv6 contain the IP addresses of the server, suitable for remote access for administration.
0000000000000000000000000000000000000000;;		AccessIPv4 string `json:"accessIPv4"`
0000000000000000000000000000000000000000;;		AccessIPv6 string `json:"accessIPv6"`
0000000000000000000000000000000000000000;;		// Image refers to a JSON object, which itself indicates the OS image used to deploy the server.
0000000000000000000000000000000000000000;;		Image map[string]interface{} `json:"-"`
0000000000000000000000000000000000000000;;		// Flavor refers to a JSON object, which itself indicates the hardware configuration of the deployed server.
0000000000000000000000000000000000000000;;		Flavor map[string]interface{} `json:"flavor"`
0000000000000000000000000000000000000000;;		// Addresses includes a list of all IP addresses assigned to the server, keyed by pool.
0000000000000000000000000000000000000000;;		Addresses map[string]interface{} `json:"addresses"`
0000000000000000000000000000000000000000;;		// Metadata includes a list of all user-specified key-value pairs attached to the server.
0000000000000000000000000000000000000000;;		Metadata map[string]string `json:"metadata"`
0000000000000000000000000000000000000000;;		// Links includes HTTP references to the itself, useful for passing along to other APIs that might want a server reference.
0000000000000000000000000000000000000000;;		Links []interface{} `json:"links"`
0000000000000000000000000000000000000000;;		// KeyName indicates which public key was injected into the server on launch.
0000000000000000000000000000000000000000;;		KeyName string `json:"key_name"`
0000000000000000000000000000000000000000;;		// AdminPass will generally be empty ("").  However, it will contain the administrative password chosen when provisioning a new server without a set AdminPass setting in the first place.
0000000000000000000000000000000000000000;;		// Note that this is the ONLY time this field will be valid.
0000000000000000000000000000000000000000;;		AdminPass string `json:"adminPass"`
0000000000000000000000000000000000000000;;		// SecurityGroups includes the security groups that this instance has applied to it
0000000000000000000000000000000000000000;;		SecurityGroups []map[string]interface{} `json:"security_groups"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Server) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		type tmp Server
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			tmp
0000000000000000000000000000000000000000;;			Image interface{} `json:"image"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(b, &s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*r = Server(s.tmp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := s.Image.(type) {
0000000000000000000000000000000000000000;;		case map[string]interface{}:
0000000000000000000000000000000000000000;;			r.Image = t
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			switch t {
0000000000000000000000000000000000000000;;			case "":
0000000000000000000000000000000000000000;;				r.Image = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerPage abstracts the raw results of making a List() request against the API.
0000000000000000000000000000000000000000;;	// As OpenStack extensions may freely alter the response bodies of structures returned to the client, you may only safely access the
0000000000000000000000000000000000000000;;	// data provided through the ExtractServers call.
0000000000000000000000000000000000000000;;	type ServerPage struct {
0000000000000000000000000000000000000000;;		pagination.LinkedPageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if a page contains no Server results.
0000000000000000000000000000000000000000;;	func (r ServerPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		s, err := ExtractServers(r)
0000000000000000000000000000000000000000;;		return len(s) == 0, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextPageURL uses the response's embedded link reference to navigate to the next page of results.
0000000000000000000000000000000000000000;;	func (r ServerPage) NextPageURL() (string, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Links []gophercloud.Link `json:"servers_links"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return gophercloud.ExtractNextURL(s.Links)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractServers interprets the results of a single page from a List() call, producing a slice of Server entities.
0000000000000000000000000000000000000000;;	func ExtractServers(r pagination.Page) ([]Server, error) {
0000000000000000000000000000000000000000;;		var s []Server
0000000000000000000000000000000000000000;;		err := ExtractServersInto(r, &s)
0000000000000000000000000000000000000000;;		return s, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadataResult contains the result of a call for (potentially) multiple key-value pairs.
0000000000000000000000000000000000000000;;	type MetadataResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetadataResult temporarily contains the response from a metadata Get call.
0000000000000000000000000000000000000000;;	type GetMetadataResult struct {
0000000000000000000000000000000000000000;;		MetadataResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetMetadataResult temporarily contains the response from a metadata Reset call.
0000000000000000000000000000000000000000;;	type ResetMetadataResult struct {
0000000000000000000000000000000000000000;;		MetadataResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateMetadataResult temporarily contains the response from a metadata Update call.
0000000000000000000000000000000000000000;;	type UpdateMetadataResult struct {
0000000000000000000000000000000000000000;;		MetadataResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadatumResult contains the result of a call for individual a single key-value pair.
0000000000000000000000000000000000000000;;	type MetadatumResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetadatumResult temporarily contains the response from a metadatum Get call.
0000000000000000000000000000000000000000;;	type GetMetadatumResult struct {
0000000000000000000000000000000000000000;;		MetadatumResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateMetadatumResult temporarily contains the response from a metadatum Create call.
0000000000000000000000000000000000000000;;	type CreateMetadatumResult struct {
0000000000000000000000000000000000000000;;		MetadatumResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteMetadatumResult temporarily contains the response from a metadatum Delete call.
0000000000000000000000000000000000000000;;	type DeleteMetadatumResult struct {
0000000000000000000000000000000000000000;;		gophercloud.ErrResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any MetadataResult as a Metadata, if possible.
0000000000000000000000000000000000000000;;	func (r MetadataResult) Extract() (map[string]string, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Metadata map[string]string `json:"metadata"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&s)
0000000000000000000000000000000000000000;;		return s.Metadata, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any MetadatumResult as a Metadatum, if possible.
0000000000000000000000000000000000000000;;	func (r MetadatumResult) Extract() (map[string]string, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Metadatum map[string]string `json:"meta"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := r.ExtractInto(&s)
0000000000000000000000000000000000000000;;		return s.Metadatum, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Address represents an IP address.
0000000000000000000000000000000000000000;;	type Address struct {
0000000000000000000000000000000000000000;;		Version int    `json:"version"`
0000000000000000000000000000000000000000;;		Address string `json:"addr"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddressPage abstracts the raw results of making a ListAddresses() request against the API.
0000000000000000000000000000000000000000;;	// As OpenStack extensions may freely alter the response bodies of structures returned
0000000000000000000000000000000000000000;;	// to the client, you may only safely access the data provided through the ExtractAddresses call.
0000000000000000000000000000000000000000;;	type AddressPage struct {
0000000000000000000000000000000000000000;;		pagination.SinglePageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if an AddressPage contains no networks.
0000000000000000000000000000000000000000;;	func (r AddressPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		addresses, err := ExtractAddresses(r)
0000000000000000000000000000000000000000;;		return len(addresses) == 0, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractAddresses interprets the results of a single page from a ListAddresses() call,
0000000000000000000000000000000000000000;;	// producing a map of addresses.
0000000000000000000000000000000000000000;;	func ExtractAddresses(r pagination.Page) (map[string][]Address, error) {
0000000000000000000000000000000000000000;;		var s struct {
0000000000000000000000000000000000000000;;			Addresses map[string][]Address `json:"addresses"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := (r.(AddressPage)).ExtractInto(&s)
0000000000000000000000000000000000000000;;		return s.Addresses, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkAddressPage abstracts the raw results of making a ListAddressesByNetwork() request against the API.
0000000000000000000000000000000000000000;;	// As OpenStack extensions may freely alter the response bodies of structures returned
0000000000000000000000000000000000000000;;	// to the client, you may only safely access the data provided through the ExtractAddresses call.
0000000000000000000000000000000000000000;;	type NetworkAddressPage struct {
0000000000000000000000000000000000000000;;		pagination.SinglePageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if a NetworkAddressPage contains no addresses.
0000000000000000000000000000000000000000;;	func (r NetworkAddressPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		addresses, err := ExtractNetworkAddresses(r)
0000000000000000000000000000000000000000;;		return len(addresses) == 0, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractNetworkAddresses interprets the results of a single page from a ListAddressesByNetwork() call,
0000000000000000000000000000000000000000;;	// producing a slice of addresses.
0000000000000000000000000000000000000000;;	func ExtractNetworkAddresses(r pagination.Page) ([]Address, error) {
0000000000000000000000000000000000000000;;		var s map[string][]Address
0000000000000000000000000000000000000000;;		err := (r.(NetworkAddressPage)).ExtractInto(&s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var key string
0000000000000000000000000000000000000000;;		for k := range s {
0000000000000000000000000000000000000000;;			key = k
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s[key], err
0000000000000000000000000000000000000000;;	}
