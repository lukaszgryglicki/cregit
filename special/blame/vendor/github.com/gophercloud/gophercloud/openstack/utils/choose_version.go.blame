0000000000000000000000000000000000000000;;	package utils
c191e5bce96b97325e2d7149d40cc3a540ce2fa4;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version is a supported API version, corresponding to a vN package within the appropriate service.
0000000000000000000000000000000000000000;;	type Version struct {
0000000000000000000000000000000000000000;;		ID       string
0000000000000000000000000000000000000000;;		Suffix   string
0000000000000000000000000000000000000000;;		Priority int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var goodStatus = map[string]bool{
0000000000000000000000000000000000000000;;		"current":   true,
0000000000000000000000000000000000000000;;		"supported": true,
0000000000000000000000000000000000000000;;		"stable":    true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChooseVersion queries the base endpoint of an API to choose the most recent non-experimental alternative from a service's
0000000000000000000000000000000000000000;;	// published versions.
0000000000000000000000000000000000000000;;	// It returns the highest-Priority Version among the alternatives that are provided, as well as its corresponding endpoint.
0000000000000000000000000000000000000000;;	func ChooseVersion(client *gophercloud.ProviderClient, recognized []*Version) (*Version, string, error) {
0000000000000000000000000000000000000000;;		type linkResp struct {
0000000000000000000000000000000000000000;;			Href string `json:"href"`
0000000000000000000000000000000000000000;;			Rel  string `json:"rel"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type valueResp struct {
0000000000000000000000000000000000000000;;			ID     string     `json:"id"`
0000000000000000000000000000000000000000;;			Status string     `json:"status"`
0000000000000000000000000000000000000000;;			Links  []linkResp `json:"links"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type versionsResp struct {
0000000000000000000000000000000000000000;;			Values []valueResp `json:"values"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type response struct {
0000000000000000000000000000000000000000;;			Versions versionsResp `json:"versions"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		normalize := func(endpoint string) string {
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(endpoint, "/") {
0000000000000000000000000000000000000000;;				return endpoint + "/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return endpoint
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		identityEndpoint := normalize(client.IdentityEndpoint)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If a full endpoint is specified, check version suffixes for a match first.
0000000000000000000000000000000000000000;;		for _, v := range recognized {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(identityEndpoint, v.Suffix) {
0000000000000000000000000000000000000000;;				return v, identityEndpoint, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var resp response
0000000000000000000000000000000000000000;;		_, err := client.Request("GET", client.IdentityBase, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			JSONResponse: &resp,
0000000000000000000000000000000000000000;;			OkCodes:      []int{200, 300},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		byID := make(map[string]*Version)
0000000000000000000000000000000000000000;;		for _, version := range recognized {
0000000000000000000000000000000000000000;;			byID[version.ID] = version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var highest *Version
0000000000000000000000000000000000000000;;		var endpoint string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, value := range resp.Versions.Values {
0000000000000000000000000000000000000000;;			href := ""
0000000000000000000000000000000000000000;;			for _, link := range value.Links {
0000000000000000000000000000000000000000;;				if link.Rel == "self" {
0000000000000000000000000000000000000000;;					href = normalize(link.Href)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if matching, ok := byID[value.ID]; ok {
0000000000000000000000000000000000000000;;				// Prefer a version that exactly matches the provided endpoint.
0000000000000000000000000000000000000000;;				if href == identityEndpoint {
0000000000000000000000000000000000000000;;					if href == "" {
0000000000000000000000000000000000000000;;						return nil, "", fmt.Errorf("Endpoint missing in version %s response from %s", value.ID, client.IdentityBase)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return matching, href, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Otherwise, find the highest-priority version with a whitelisted status.
0000000000000000000000000000000000000000;;				if goodStatus[strings.ToLower(value.Status)] {
0000000000000000000000000000000000000000;;					if highest == nil || matching.Priority > highest.Priority {
0000000000000000000000000000000000000000;;						highest = matching
0000000000000000000000000000000000000000;;						endpoint = href
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if highest == nil {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf("No supported version available from endpoint %s", client.IdentityBase)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if endpoint == "" {
0000000000000000000000000000000000000000;;			return nil, "", fmt.Errorf("Endpoint missing in version %s response from %s", highest.ID, client.IdentityBase)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return highest, endpoint, nil
0000000000000000000000000000000000000000;;	}
