0000000000000000000000000000000000000000;;	package rules
c191e5bce96b97325e2d7149d40cc3a540ce2fa4;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/gophercloud/gophercloud/pagination"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListOpts allows the filtering and sorting of paginated collections through
0000000000000000000000000000000000000000;;	// the API. Filtering is achieved by passing in struct field values that map to
0000000000000000000000000000000000000000;;	// the security group attributes you want to see returned. SortKey allows you to
0000000000000000000000000000000000000000;;	// sort by a particular network attribute. SortDir sets the direction, and is
0000000000000000000000000000000000000000;;	// either `asc' or `desc'. Marker and Limit are used for pagination.
0000000000000000000000000000000000000000;;	type ListOpts struct {
0000000000000000000000000000000000000000;;		Direction      string `q:"direction"`
0000000000000000000000000000000000000000;;		EtherType      string `q:"ethertype"`
0000000000000000000000000000000000000000;;		ID             string `q:"id"`
0000000000000000000000000000000000000000;;		PortRangeMax   int    `q:"port_range_max"`
0000000000000000000000000000000000000000;;		PortRangeMin   int    `q:"port_range_min"`
0000000000000000000000000000000000000000;;		Protocol       string `q:"protocol"`
0000000000000000000000000000000000000000;;		RemoteGroupID  string `q:"remote_group_id"`
0000000000000000000000000000000000000000;;		RemoteIPPrefix string `q:"remote_ip_prefix"`
0000000000000000000000000000000000000000;;		SecGroupID     string `q:"security_group_id"`
0000000000000000000000000000000000000000;;		TenantID       string `q:"tenant_id"`
0000000000000000000000000000000000000000;;		Limit          int    `q:"limit"`
0000000000000000000000000000000000000000;;		Marker         string `q:"marker"`
0000000000000000000000000000000000000000;;		SortKey        string `q:"sort_key"`
0000000000000000000000000000000000000000;;		SortDir        string `q:"sort_dir"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List returns a Pager which allows you to iterate over a collection of
0000000000000000000000000000000000000000;;	// security group rules. It accepts a ListOpts struct, which allows you to filter
0000000000000000000000000000000000000000;;	// and sort the returned collection for greater efficiency.
0000000000000000000000000000000000000000;;	func List(c *gophercloud.ServiceClient, opts ListOpts) pagination.Pager {
0000000000000000000000000000000000000000;;		q, err := gophercloud.BuildQueryString(&opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return pagination.Pager{Err: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u := rootURL(c) + q.String()
0000000000000000000000000000000000000000;;		return pagination.NewPager(c, u, func(r pagination.PageResult) pagination.Page {
0000000000000000000000000000000000000000;;			return SecGroupRulePage{pagination.LinkedPageBase{PageResult: r}}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RuleDirection string
0000000000000000000000000000000000000000;;	type RuleProtocol string
0000000000000000000000000000000000000000;;	type RuleEtherType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Constants useful for CreateOpts
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DirIngress        RuleDirection = "ingress"
0000000000000000000000000000000000000000;;		DirEgress         RuleDirection = "egress"
0000000000000000000000000000000000000000;;		EtherType4        RuleEtherType = "IPv4"
0000000000000000000000000000000000000000;;		EtherType6        RuleEtherType = "IPv6"
0000000000000000000000000000000000000000;;		ProtocolAH        RuleProtocol  = "ah"
0000000000000000000000000000000000000000;;		ProtocolDCCP      RuleProtocol  = "dccp"
0000000000000000000000000000000000000000;;		ProtocolEGP       RuleProtocol  = "egp"
0000000000000000000000000000000000000000;;		ProtocolESP       RuleProtocol  = "esp"
0000000000000000000000000000000000000000;;		ProtocolGRE       RuleProtocol  = "gre"
0000000000000000000000000000000000000000;;		ProtocolICMP      RuleProtocol  = "icmp"
0000000000000000000000000000000000000000;;		ProtocolIGMP      RuleProtocol  = "igmp"
0000000000000000000000000000000000000000;;		ProtocolIPv6Encap RuleProtocol  = "ipv6-encap"
0000000000000000000000000000000000000000;;		ProtocolIPv6Frag  RuleProtocol  = "ipv6-frag"
0000000000000000000000000000000000000000;;		ProtocolIPv6ICMP  RuleProtocol  = "ipv6-icmp"
0000000000000000000000000000000000000000;;		ProtocolIPv6NoNxt RuleProtocol  = "ipv6-nonxt"
0000000000000000000000000000000000000000;;		ProtocolIPv6Opts  RuleProtocol  = "ipv6-opts"
0000000000000000000000000000000000000000;;		ProtocolIPv6Route RuleProtocol  = "ipv6-route"
0000000000000000000000000000000000000000;;		ProtocolOSPF      RuleProtocol  = "ospf"
0000000000000000000000000000000000000000;;		ProtocolPGM       RuleProtocol  = "pgm"
0000000000000000000000000000000000000000;;		ProtocolRSVP      RuleProtocol  = "rsvp"
0000000000000000000000000000000000000000;;		ProtocolSCTP      RuleProtocol  = "sctp"
0000000000000000000000000000000000000000;;		ProtocolTCP       RuleProtocol  = "tcp"
0000000000000000000000000000000000000000;;		ProtocolUDP       RuleProtocol  = "udp"
0000000000000000000000000000000000000000;;		ProtocolUDPLite   RuleProtocol  = "udplite"
0000000000000000000000000000000000000000;;		ProtocolVRRP      RuleProtocol  = "vrrp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOptsBuilder is what types must satisfy to be used as Create
0000000000000000000000000000000000000000;;	// options.
0000000000000000000000000000000000000000;;	type CreateOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToSecGroupRuleCreateMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOpts contains all the values needed to create a new security group rule.
0000000000000000000000000000000000000000;;	type CreateOpts struct {
0000000000000000000000000000000000000000;;		// Required. Must be either "ingress" or "egress": the direction in which the
0000000000000000000000000000000000000000;;		// security group rule is applied.
0000000000000000000000000000000000000000;;		Direction RuleDirection `json:"direction" required:"true"`
0000000000000000000000000000000000000000;;		// Required. Must be "IPv4" or "IPv6", and addresses represented in CIDR must
0000000000000000000000000000000000000000;;		// match the ingress or egress rules.
0000000000000000000000000000000000000000;;		EtherType RuleEtherType `json:"ethertype" required:"true"`
0000000000000000000000000000000000000000;;		// Required. The security group ID to associate with this security group rule.
0000000000000000000000000000000000000000;;		SecGroupID string `json:"security_group_id" required:"true"`
0000000000000000000000000000000000000000;;		// Optional. The maximum port number in the range that is matched by the
0000000000000000000000000000000000000000;;		// security group rule. The PortRangeMin attribute constrains the PortRangeMax
0000000000000000000000000000000000000000;;		// attribute. If the protocol is ICMP, this value must be an ICMP type.
0000000000000000000000000000000000000000;;		PortRangeMax int `json:"port_range_max,omitempty"`
0000000000000000000000000000000000000000;;		// Optional. The minimum port number in the range that is matched by the
0000000000000000000000000000000000000000;;		// security group rule. If the protocol is TCP or UDP, this value must be
0000000000000000000000000000000000000000;;		// less than or equal to the value of the PortRangeMax attribute. If the
0000000000000000000000000000000000000000;;		// protocol is ICMP, this value must be an ICMP type.
0000000000000000000000000000000000000000;;		PortRangeMin int `json:"port_range_min,omitempty"`
0000000000000000000000000000000000000000;;		// Optional. The protocol that is matched by the security group rule. Valid
0000000000000000000000000000000000000000;;		// values are "tcp", "udp", "icmp" or an empty string.
0000000000000000000000000000000000000000;;		Protocol RuleProtocol `json:"protocol,omitempty"`
0000000000000000000000000000000000000000;;		// Optional. The remote group ID to be associated with this security group
0000000000000000000000000000000000000000;;		// rule. You can specify either RemoteGroupID or RemoteIPPrefix.
0000000000000000000000000000000000000000;;		RemoteGroupID string `json:"remote_group_id,omitempty"`
0000000000000000000000000000000000000000;;		// Optional. The remote IP prefix to be associated with this security group
0000000000000000000000000000000000000000;;		// rule. You can specify either RemoteGroupID or RemoteIPPrefix. This
0000000000000000000000000000000000000000;;		// attribute matches the specified IP prefix as the source IP address of the
0000000000000000000000000000000000000000;;		// IP packet.
0000000000000000000000000000000000000000;;		RemoteIPPrefix string `json:"remote_ip_prefix,omitempty"`
0000000000000000000000000000000000000000;;		// Required for admins. Indicates the owner of the VIP.
0000000000000000000000000000000000000000;;		TenantID string `json:"tenant_id,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToSecGroupRuleCreateMap allows CreateOpts to satisfy the CreateOptsBuilder
0000000000000000000000000000000000000000;;	// interface
0000000000000000000000000000000000000000;;	func (opts CreateOpts) ToSecGroupRuleCreateMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		return gophercloud.BuildRequestBody(opts, "security_group_rule")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create is an operation which adds a new security group rule and associates it
0000000000000000000000000000000000000000;;	// with an existing security group (whose ID is specified in CreateOpts).
0000000000000000000000000000000000000000;;	func Create(c *gophercloud.ServiceClient, opts CreateOptsBuilder) (r CreateResult) {
0000000000000000000000000000000000000000;;		b, err := opts.ToSecGroupRuleCreateMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			r.Err = err
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, r.Err = c.Post(rootURL(c), b, &r.Body, nil)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get retrieves a particular security group rule based on its unique ID.
0000000000000000000000000000000000000000;;	func Get(c *gophercloud.ServiceClient, id string) (r GetResult) {
0000000000000000000000000000000000000000;;		_, r.Err = c.Get(resourceURL(c, id), &r.Body, nil)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete will permanently delete a particular security group rule based on its unique ID.
0000000000000000000000000000000000000000;;	func Delete(c *gophercloud.ServiceClient, id string) (r DeleteResult) {
0000000000000000000000000000000000000000;;		_, r.Err = c.Delete(resourceURL(c, id), nil)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
