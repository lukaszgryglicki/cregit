0000000000000000000000000000000000000000;;	package gophercloud
c191e5bce96b97325e2d7149d40cc3a540ce2fa4;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	AuthOptions stores information needed to authenticate to an OpenStack Cloud.
0000000000000000000000000000000000000000;;	You can populate one manually, or use a provider's AuthOptionsFromEnv() function
0000000000000000000000000000000000000000;;	to read relevant information from the standard environment variables. Pass one
0000000000000000000000000000000000000000;;	to a provider's AuthenticatedClient function to authenticate and obtain a
0000000000000000000000000000000000000000;;	ProviderClient representing an active session on that provider.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Its fields are the union of those recognized by each identity implementation and
0000000000000000000000000000000000000000;;	provider.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	type AuthOptions struct {
0000000000000000000000000000000000000000;;		// IdentityEndpoint specifies the HTTP endpoint that is required to work with
0000000000000000000000000000000000000000;;		// the Identity API of the appropriate version. While it's ultimately needed by
0000000000000000000000000000000000000000;;		// all of the identity services, it will often be populated by a provider-level
0000000000000000000000000000000000000000;;		// function.
0000000000000000000000000000000000000000;;		IdentityEndpoint string `json:"-"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Username is required if using Identity V2 API. Consult with your provider's
0000000000000000000000000000000000000000;;		// control panel to discover your account's username. In Identity V3, either
0000000000000000000000000000000000000000;;		// UserID or a combination of Username and DomainID or DomainName are needed.
0000000000000000000000000000000000000000;;		Username string `json:"username,omitempty"`
0000000000000000000000000000000000000000;;		UserID   string `json:"-"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Password string `json:"password,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// At most one of DomainID and DomainName must be provided if using Username
0000000000000000000000000000000000000000;;		// with Identity V3. Otherwise, either are optional.
0000000000000000000000000000000000000000;;		DomainID   string `json:"-"`
0000000000000000000000000000000000000000;;		DomainName string `json:"name,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The TenantID and TenantName fields are optional for the Identity V2 API.
0000000000000000000000000000000000000000;;		// The same fields are known as project_id and project_name in the Identity
0000000000000000000000000000000000000000;;		// V3 API, but are collected as TenantID and TenantName here in both cases.
0000000000000000000000000000000000000000;;		// Some providers allow you to specify a TenantName instead of the TenantId.
0000000000000000000000000000000000000000;;		// Some require both. Your provider's authentication policies will determine
0000000000000000000000000000000000000000;;		// how these fields influence authentication.
0000000000000000000000000000000000000000;;		// If DomainID or DomainName are provided, they will also apply to TenantName.
0000000000000000000000000000000000000000;;		// It is not currently possible to authenticate with Username and a Domain
0000000000000000000000000000000000000000;;		// and scope to a Project in a different Domain by using TenantName. To
0000000000000000000000000000000000000000;;		// accomplish that, the ProjectID will need to be provided to the TenantID
0000000000000000000000000000000000000000;;		// option.
0000000000000000000000000000000000000000;;		TenantID   string `json:"tenantId,omitempty"`
0000000000000000000000000000000000000000;;		TenantName string `json:"tenantName,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AllowReauth should be set to true if you grant permission for Gophercloud to
0000000000000000000000000000000000000000;;		// cache your credentials in memory, and to allow Gophercloud to attempt to
0000000000000000000000000000000000000000;;		// re-authenticate automatically if/when your token expires.  If you set it to
0000000000000000000000000000000000000000;;		// false, it will not cache these settings, but re-authentication will not be
0000000000000000000000000000000000000000;;		// possible.  This setting defaults to false.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// NOTE: The reauth function will try to re-authenticate endlessly if left unchecked.
0000000000000000000000000000000000000000;;		// The way to limit the number of attempts is to provide a custom HTTP client to the provider client
0000000000000000000000000000000000000000;;		// and provide a transport that implements the RoundTripper interface and stores the number of failed retries.
0000000000000000000000000000000000000000;;		// For an example of this, see here: https://github.com/rackspace/rack/blob/1.0.0/auth/clients.go#L311
0000000000000000000000000000000000000000;;		AllowReauth bool `json:"-"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TokenID allows users to authenticate (possibly as another user) with an
0000000000000000000000000000000000000000;;		// authentication token ID.
0000000000000000000000000000000000000000;;		TokenID string `json:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToTokenV2CreateMap allows AuthOptions to satisfy the AuthOptionsBuilder
0000000000000000000000000000000000000000;;	// interface in the v2 tokens package
0000000000000000000000000000000000000000;;	func (opts AuthOptions) ToTokenV2CreateMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		// Populate the request map.
0000000000000000000000000000000000000000;;		authMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.Username != "" {
0000000000000000000000000000000000000000;;			if opts.Password != "" {
0000000000000000000000000000000000000000;;				authMap["passwordCredentials"] = map[string]interface{}{
0000000000000000000000000000000000000000;;					"username": opts.Username,
0000000000000000000000000000000000000000;;					"password": opts.Password,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, ErrMissingInput{Argument: "Password"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if opts.TokenID != "" {
0000000000000000000000000000000000000000;;			authMap["token"] = map[string]interface{}{
0000000000000000000000000000000000000000;;				"id": opts.TokenID,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, ErrMissingInput{Argument: "Username"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.TenantID != "" {
0000000000000000000000000000000000000000;;			authMap["tenantId"] = opts.TenantID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.TenantName != "" {
0000000000000000000000000000000000000000;;			authMap["tenantName"] = opts.TenantName
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return map[string]interface{}{"auth": authMap}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (opts *AuthOptions) ToTokenV3CreateMap(scope map[string]interface{}) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		type domainReq struct {
0000000000000000000000000000000000000000;;			ID   *string `json:"id,omitempty"`
0000000000000000000000000000000000000000;;			Name *string `json:"name,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type projectReq struct {
0000000000000000000000000000000000000000;;			Domain *domainReq `json:"domain,omitempty"`
0000000000000000000000000000000000000000;;			Name   *string    `json:"name,omitempty"`
0000000000000000000000000000000000000000;;			ID     *string    `json:"id,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type userReq struct {
0000000000000000000000000000000000000000;;			ID       *string    `json:"id,omitempty"`
0000000000000000000000000000000000000000;;			Name     *string    `json:"name,omitempty"`
0000000000000000000000000000000000000000;;			Password string     `json:"password"`
0000000000000000000000000000000000000000;;			Domain   *domainReq `json:"domain,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type passwordReq struct {
0000000000000000000000000000000000000000;;			User userReq `json:"user"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type tokenReq struct {
0000000000000000000000000000000000000000;;			ID string `json:"id"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type identityReq struct {
0000000000000000000000000000000000000000;;			Methods  []string     `json:"methods"`
0000000000000000000000000000000000000000;;			Password *passwordReq `json:"password,omitempty"`
0000000000000000000000000000000000000000;;			Token    *tokenReq    `json:"token,omitempty"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type authReq struct {
0000000000000000000000000000000000000000;;			Identity identityReq `json:"identity"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type request struct {
0000000000000000000000000000000000000000;;			Auth authReq `json:"auth"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate the request structure based on the provided arguments. Create and return an error
0000000000000000000000000000000000000000;;		// if insufficient or incompatible information is present.
0000000000000000000000000000000000000000;;		var req request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.Password == "" {
0000000000000000000000000000000000000000;;			if opts.TokenID != "" {
0000000000000000000000000000000000000000;;				// Because we aren't using password authentication, it's an error to also provide any of the user-based authentication
0000000000000000000000000000000000000000;;				// parameters.
0000000000000000000000000000000000000000;;				if opts.Username != "" {
0000000000000000000000000000000000000000;;					return nil, ErrUsernameWithToken{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if opts.UserID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrUserIDWithToken{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if opts.DomainID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainIDWithToken{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if opts.DomainName != "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainNameWithToken{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Configure the request for Token authentication.
0000000000000000000000000000000000000000;;				req.Auth.Identity.Methods = []string{"token"}
0000000000000000000000000000000000000000;;				req.Auth.Identity.Token = &tokenReq{
0000000000000000000000000000000000000000;;					ID: opts.TokenID,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// If no password or token ID are available, authentication can't continue.
0000000000000000000000000000000000000000;;				return nil, ErrMissingPassword{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Password authentication.
0000000000000000000000000000000000000000;;			req.Auth.Identity.Methods = []string{"password"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// At least one of Username and UserID must be specified.
0000000000000000000000000000000000000000;;			if opts.Username == "" && opts.UserID == "" {
0000000000000000000000000000000000000000;;				return nil, ErrUsernameOrUserID{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if opts.Username != "" {
0000000000000000000000000000000000000000;;				// If Username is provided, UserID may not be provided.
0000000000000000000000000000000000000000;;				if opts.UserID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrUsernameOrUserID{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Either DomainID or DomainName must also be specified.
0000000000000000000000000000000000000000;;				if opts.DomainID == "" && opts.DomainName == "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainIDOrDomainName{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if opts.DomainID != "" {
0000000000000000000000000000000000000000;;					if opts.DomainName != "" {
0000000000000000000000000000000000000000;;						return nil, ErrDomainIDOrDomainName{}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Configure the request for Username and Password authentication with a DomainID.
0000000000000000000000000000000000000000;;					req.Auth.Identity.Password = &passwordReq{
0000000000000000000000000000000000000000;;						User: userReq{
0000000000000000000000000000000000000000;;							Name:     &opts.Username,
0000000000000000000000000000000000000000;;							Password: opts.Password,
0000000000000000000000000000000000000000;;							Domain:   &domainReq{ID: &opts.DomainID},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if opts.DomainName != "" {
0000000000000000000000000000000000000000;;					// Configure the request for Username and Password authentication with a DomainName.
0000000000000000000000000000000000000000;;					req.Auth.Identity.Password = &passwordReq{
0000000000000000000000000000000000000000;;						User: userReq{
0000000000000000000000000000000000000000;;							Name:     &opts.Username,
0000000000000000000000000000000000000000;;							Password: opts.Password,
0000000000000000000000000000000000000000;;							Domain:   &domainReq{Name: &opts.DomainName},
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if opts.UserID != "" {
0000000000000000000000000000000000000000;;				// If UserID is specified, neither DomainID nor DomainName may be.
0000000000000000000000000000000000000000;;				if opts.DomainID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainIDWithUserID{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if opts.DomainName != "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainNameWithUserID{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Configure the request for UserID and Password authentication.
0000000000000000000000000000000000000000;;				req.Auth.Identity.Password = &passwordReq{
0000000000000000000000000000000000000000;;					User: userReq{ID: &opts.UserID, Password: opts.Password},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, err := BuildRequestBody(req, "")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(scope) != 0 {
0000000000000000000000000000000000000000;;			b["auth"].(map[string]interface{})["scope"] = scope
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (opts *AuthOptions) ToTokenV3ScopeMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var scope struct {
0000000000000000000000000000000000000000;;			ProjectID   string
0000000000000000000000000000000000000000;;			ProjectName string
0000000000000000000000000000000000000000;;			DomainID    string
0000000000000000000000000000000000000000;;			DomainName  string
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.TenantID != "" {
0000000000000000000000000000000000000000;;			scope.ProjectID = opts.TenantID
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if opts.TenantName != "" {
0000000000000000000000000000000000000000;;				scope.ProjectName = opts.TenantName
0000000000000000000000000000000000000000;;				scope.DomainID = opts.DomainID
0000000000000000000000000000000000000000;;				scope.DomainName = opts.DomainName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if scope.ProjectName != "" {
0000000000000000000000000000000000000000;;			// ProjectName provided: either DomainID or DomainName must also be supplied.
0000000000000000000000000000000000000000;;			// ProjectID may not be supplied.
0000000000000000000000000000000000000000;;			if scope.DomainID == "" && scope.DomainName == "" {
0000000000000000000000000000000000000000;;				return nil, ErrScopeDomainIDOrDomainName{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if scope.ProjectID != "" {
0000000000000000000000000000000000000000;;				return nil, ErrScopeProjectIDOrProjectName{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if scope.DomainID != "" {
0000000000000000000000000000000000000000;;				// ProjectName + DomainID
0000000000000000000000000000000000000000;;				return map[string]interface{}{
0000000000000000000000000000000000000000;;					"project": map[string]interface{}{
0000000000000000000000000000000000000000;;						"name":   &scope.ProjectName,
0000000000000000000000000000000000000000;;						"domain": map[string]interface{}{"id": &scope.DomainID},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if scope.DomainName != "" {
0000000000000000000000000000000000000000;;				// ProjectName + DomainName
0000000000000000000000000000000000000000;;				return map[string]interface{}{
0000000000000000000000000000000000000000;;					"project": map[string]interface{}{
0000000000000000000000000000000000000000;;						"name":   &scope.ProjectName,
0000000000000000000000000000000000000000;;						"domain": map[string]interface{}{"name": &scope.DomainName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if scope.ProjectID != "" {
0000000000000000000000000000000000000000;;			// ProjectID provided. ProjectName, DomainID, and DomainName may not be provided.
0000000000000000000000000000000000000000;;			if scope.DomainID != "" {
0000000000000000000000000000000000000000;;				return nil, ErrScopeProjectIDAlone{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if scope.DomainName != "" {
0000000000000000000000000000000000000000;;				return nil, ErrScopeProjectIDAlone{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// ProjectID
0000000000000000000000000000000000000000;;			return map[string]interface{}{
0000000000000000000000000000000000000000;;				"project": map[string]interface{}{
0000000000000000000000000000000000000000;;					"id": &scope.ProjectID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		} else if scope.DomainID != "" {
0000000000000000000000000000000000000000;;			// DomainID provided. ProjectID, ProjectName, and DomainName may not be provided.
0000000000000000000000000000000000000000;;			if scope.DomainName != "" {
0000000000000000000000000000000000000000;;				return nil, ErrScopeDomainIDOrDomainName{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// DomainID
0000000000000000000000000000000000000000;;			return map[string]interface{}{
0000000000000000000000000000000000000000;;				"domain": map[string]interface{}{
0000000000000000000000000000000000000000;;					"id": &scope.DomainID,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		} else if scope.DomainName != "" {
0000000000000000000000000000000000000000;;			return nil, ErrScopeDomainName{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (opts AuthOptions) CanReauth() bool {
0000000000000000000000000000000000000000;;		return opts.AllowReauth
0000000000000000000000000000000000000000;;	}
