0000000000000000000000000000000000000000;;	package gophercloud
c191e5bce96b97325e2d7149d40cc3a540ce2fa4;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildRequestBody builds a map[string]interface from the given `struct`. If
0000000000000000000000000000000000000000;;	// parent is not the empty string, the final map[string]interface returned will
0000000000000000000000000000000000000000;;	// encapsulate the built one
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func BuildRequestBody(opts interface{}, parent string) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		optsValue := reflect.ValueOf(opts)
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsValue = optsValue.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsType := reflect.TypeOf(opts)
0000000000000000000000000000000000000000;;		if optsType.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsType = optsType.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			//fmt.Printf("optsValue.Kind() is a reflect.Struct: %+v\n", optsValue.Kind())
0000000000000000000000000000000000000000;;			for i := 0; i < optsValue.NumField(); i++ {
0000000000000000000000000000000000000000;;				v := optsValue.Field(i)
0000000000000000000000000000000000000000;;				f := optsType.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if f.Name != strings.Title(f.Name) {
0000000000000000000000000000000000000000;;					//fmt.Printf("Skipping field: %s...\n", f.Name)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				//fmt.Printf("Starting on field: %s...\n", f.Name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				zero := isZero(v)
0000000000000000000000000000000000000000;;				//fmt.Printf("v is zero?: %v\n", zero)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if the field has a required tag that's set to "true"
0000000000000000000000000000000000000000;;				if requiredTag := f.Tag.Get("required"); requiredTag == "true" {
0000000000000000000000000000000000000000;;					//fmt.Printf("Checking required field [%s]:\n\tv: %+v\n\tisZero:%v\n", f.Name, v.Interface(), zero)
0000000000000000000000000000000000000000;;					// if the field's value is zero, return a missing-argument error
0000000000000000000000000000000000000000;;					if zero {
0000000000000000000000000000000000000000;;						// if the field has a 'required' tag, it can't have a zero-value
0000000000000000000000000000000000000000;;						err := ErrMissingInput{}
0000000000000000000000000000000000000000;;						err.Argument = f.Name
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if xorTag := f.Tag.Get("xor"); xorTag != "" {
0000000000000000000000000000000000000000;;					//fmt.Printf("Checking `xor` tag for field [%s] with value %+v:\n\txorTag: %s\n", f.Name, v, xorTag)
0000000000000000000000000000000000000000;;					xorField := optsValue.FieldByName(xorTag)
0000000000000000000000000000000000000000;;					var xorFieldIsZero bool
0000000000000000000000000000000000000000;;					if reflect.ValueOf(xorField.Interface()) == reflect.Zero(xorField.Type()) {
0000000000000000000000000000000000000000;;						xorFieldIsZero = true
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if xorField.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;							xorField = xorField.Elem()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						xorFieldIsZero = isZero(xorField)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !(zero != xorFieldIsZero) {
0000000000000000000000000000000000000000;;						err := ErrMissingInput{}
0000000000000000000000000000000000000000;;						err.Argument = fmt.Sprintf("%s/%s", f.Name, xorTag)
0000000000000000000000000000000000000000;;						err.Info = fmt.Sprintf("Exactly one of %s and %s must be provided", f.Name, xorTag)
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if orTag := f.Tag.Get("or"); orTag != "" {
0000000000000000000000000000000000000000;;					//fmt.Printf("Checking `or` tag for field with:\n\tname: %+v\n\torTag:%s\n", f.Name, orTag)
0000000000000000000000000000000000000000;;					//fmt.Printf("field is zero?: %v\n", zero)
0000000000000000000000000000000000000000;;					if zero {
0000000000000000000000000000000000000000;;						orField := optsValue.FieldByName(orTag)
0000000000000000000000000000000000000000;;						var orFieldIsZero bool
0000000000000000000000000000000000000000;;						if reflect.ValueOf(orField.Interface()) == reflect.Zero(orField.Type()) {
0000000000000000000000000000000000000000;;							orFieldIsZero = true
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							if orField.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;								orField = orField.Elem()
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							orFieldIsZero = isZero(orField)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if orFieldIsZero {
0000000000000000000000000000000000000000;;							err := ErrMissingInput{}
0000000000000000000000000000000000000000;;							err.Argument = fmt.Sprintf("%s/%s", f.Name, orTag)
0000000000000000000000000000000000000000;;							err.Info = fmt.Sprintf("At least one of %s and %s must be provided", f.Name, orTag)
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if v.Kind() == reflect.Struct || (v.Kind() == reflect.Ptr && v.Elem().Kind() == reflect.Struct) {
0000000000000000000000000000000000000000;;					if zero {
0000000000000000000000000000000000000000;;						//fmt.Printf("value before change: %+v\n", optsValue.Field(i))
0000000000000000000000000000000000000000;;						if jsonTag := f.Tag.Get("json"); jsonTag != "" {
0000000000000000000000000000000000000000;;							jsonTagPieces := strings.Split(jsonTag, ",")
0000000000000000000000000000000000000000;;							if len(jsonTagPieces) > 1 && jsonTagPieces[1] == "omitempty" {
0000000000000000000000000000000000000000;;								if v.CanSet() {
0000000000000000000000000000000000000000;;									if !v.IsNil() {
0000000000000000000000000000000000000000;;										if v.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;											v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;										}
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;									//fmt.Printf("value after change: %+v\n", optsValue.Field(i))
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					//fmt.Printf("Calling BuildRequestBody with:\n\tv: %+v\n\tf.Name:%s\n", v.Interface(), f.Name)
0000000000000000000000000000000000000000;;					_, err := BuildRequestBody(v.Interface(), f.Name)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//fmt.Printf("opts: %+v \n", opts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			b, err := json.Marshal(opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//fmt.Printf("string(b): %s\n", string(b))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err = json.Unmarshal(b, &optsMap)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			//fmt.Printf("optsMap: %+v\n", optsMap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if parent != "" {
0000000000000000000000000000000000000000;;				optsMap = map[string]interface{}{parent: optsMap}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			//fmt.Printf("optsMap after parent added: %+v\n", optsMap)
0000000000000000000000000000000000000000;;			return optsMap, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return an error if the underlying type of 'opts' isn't a struct.
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Options type is not a struct.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnabledState is a convenience type, mostly used in Create and Update
0000000000000000000000000000000000000000;;	// operations. Because the zero value of a bool is FALSE, we need to use a
0000000000000000000000000000000000000000;;	// pointer instead to indicate zero-ness.
0000000000000000000000000000000000000000;;	type EnabledState *bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convenience vars for EnabledState values.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		iTrue  = true
0000000000000000000000000000000000000000;;		iFalse = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Enabled  EnabledState = &iTrue
0000000000000000000000000000000000000000;;		Disabled EnabledState = &iFalse
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IPVersion is a type for the possible IP address versions. Valid instances
0000000000000000000000000000000000000000;;	// are IPv4 and IPv6
0000000000000000000000000000000000000000;;	type IPVersion int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// IPv4 is used for IP version 4 addresses
0000000000000000000000000000000000000000;;		IPv4 IPVersion = 4
0000000000000000000000000000000000000000;;		// IPv6 is used for IP version 6 addresses
0000000000000000000000000000000000000000;;		IPv6 IPVersion = 6
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntToPointer is a function for converting integers into integer pointers.
0000000000000000000000000000000000000000;;	// This is useful when passing in options to operations.
0000000000000000000000000000000000000000;;	func IntToPointer(i int) *int {
0000000000000000000000000000000000000000;;		return &i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	MaybeString is an internal function to be used by request methods in individual
0000000000000000000000000000000000000000;;	resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It takes a string that might be a zero value and returns either a pointer to its
0000000000000000000000000000000000000000;;	address or nil. This is useful for allowing users to conveniently omit values
0000000000000000000000000000000000000000;;	from an options struct by leaving them zeroed, but still pass nil to the JSON
0000000000000000000000000000000000000000;;	serializer so they'll be omitted from the request body.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func MaybeString(original string) *string {
0000000000000000000000000000000000000000;;		if original != "" {
0000000000000000000000000000000000000000;;			return &original
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	MaybeInt is an internal function to be used by request methods in individual
0000000000000000000000000000000000000000;;	resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Like MaybeString, it accepts an int that may or may not be a zero value, and
0000000000000000000000000000000000000000;;	returns either a pointer to its address or nil. It's intended to hint that the
0000000000000000000000000000000000000000;;	JSON serializer should omit its field.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func MaybeInt(original int) *int {
0000000000000000000000000000000000000000;;		if original != 0 {
0000000000000000000000000000000000000000;;			return &original
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	func isUnderlyingStructZero(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return isUnderlyingStructZero(v.Elem())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return isZero(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var t time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isZero(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		//fmt.Printf("\n\nchecking isZero for value: %+v\n", v)
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case reflect.Func, reflect.Map, reflect.Slice:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			z := true
0000000000000000000000000000000000000000;;			for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;				z = z && isZero(v.Index(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return z
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if v.Type() == reflect.TypeOf(t) {
0000000000000000000000000000000000000000;;				if v.Interface().(time.Time).IsZero() {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			z := true
0000000000000000000000000000000000000000;;			for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;				z = z && isZero(v.Field(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return z
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Compare other types directly:
0000000000000000000000000000000000000000;;		z := reflect.Zero(v.Type())
0000000000000000000000000000000000000000;;		//fmt.Printf("zero type for value: %+v\n\n\n", z)
0000000000000000000000000000000000000000;;		return v.Interface() == z.Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	BuildQueryString is an internal function to be used by request methods in
0000000000000000000000000000000000000000;;	individual resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It accepts a tagged structure and expands it into a URL struct. Field names are
0000000000000000000000000000000000000000;;	converted into query parameters based on a "q" tag. For example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type struct Something {
0000000000000000000000000000000000000000;;		   Bar string `q:"x_bar"`
0000000000000000000000000000000000000000;;		   Baz int    `q:"lorem_ipsum"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instance := Something{
0000000000000000000000000000000000000000;;		   Bar: "AAA",
0000000000000000000000000000000000000000;;		   Baz: "BBB",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	will be converted into "?x_bar=AAA&lorem_ipsum=BBB".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The struct's fields may be strings, integers, or boolean values. Fields left at
0000000000000000000000000000000000000000;;	their type's zero value will be omitted from the query.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func BuildQueryString(opts interface{}) (*url.URL, error) {
0000000000000000000000000000000000000000;;		optsValue := reflect.ValueOf(opts)
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsValue = optsValue.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsType := reflect.TypeOf(opts)
0000000000000000000000000000000000000000;;		if optsType.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsType = optsType.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			for i := 0; i < optsValue.NumField(); i++ {
0000000000000000000000000000000000000000;;				v := optsValue.Field(i)
0000000000000000000000000000000000000000;;				f := optsType.Field(i)
0000000000000000000000000000000000000000;;				qTag := f.Tag.Get("q")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if the field has a 'q' tag, it goes in the query string
0000000000000000000000000000000000000000;;				if qTag != "" {
0000000000000000000000000000000000000000;;					tags := strings.Split(qTag, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// if the field is set, add it to the slice of query pieces
0000000000000000000000000000000000000000;;					if !isZero(v) {
0000000000000000000000000000000000000000;;					loop:
0000000000000000000000000000000000000000;;						switch v.Kind() {
0000000000000000000000000000000000000000;;						case reflect.Ptr:
0000000000000000000000000000000000000000;;							v = v.Elem()
0000000000000000000000000000000000000000;;							goto loop
0000000000000000000000000000000000000000;;						case reflect.String:
0000000000000000000000000000000000000000;;							params.Add(tags[0], v.String())
0000000000000000000000000000000000000000;;						case reflect.Int:
0000000000000000000000000000000000000000;;							params.Add(tags[0], strconv.FormatInt(v.Int(), 10))
0000000000000000000000000000000000000000;;						case reflect.Bool:
0000000000000000000000000000000000000000;;							params.Add(tags[0], strconv.FormatBool(v.Bool()))
0000000000000000000000000000000000000000;;						case reflect.Slice:
0000000000000000000000000000000000000000;;							switch v.Type().Elem() {
0000000000000000000000000000000000000000;;							case reflect.TypeOf(0):
0000000000000000000000000000000000000000;;								for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;									params.Add(tags[0], strconv.FormatInt(v.Index(i).Int(), 10))
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							default:
0000000000000000000000000000000000000000;;								for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;									params.Add(tags[0], v.Index(i).String())
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// Otherwise, the field is not set.
0000000000000000000000000000000000000000;;						if len(tags) == 2 && tags[1] == "required" {
0000000000000000000000000000000000000000;;							// And the field is required. Return an error.
0000000000000000000000000000000000000000;;							return nil, fmt.Errorf("Required query parameter [%s] not set.", f.Name)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return &url.URL{RawQuery: params.Encode()}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return an error if the underlying type of 'opts' isn't a struct.
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Options type is not a struct.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	BuildHeaders is an internal function to be used by request methods in
0000000000000000000000000000000000000000;;	individual resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It accepts an arbitrary tagged structure and produces a string map that's
0000000000000000000000000000000000000000;;	suitable for use as the HTTP headers of an outgoing request. Field names are
0000000000000000000000000000000000000000;;	mapped to header names based in "h" tags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  type struct Something {
0000000000000000000000000000000000000000;;	    Bar string `h:"x_bar"`
0000000000000000000000000000000000000000;;	    Baz int    `h:"lorem_ipsum"`
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  instance := Something{
0000000000000000000000000000000000000000;;	    Bar: "AAA",
0000000000000000000000000000000000000000;;	    Baz: "BBB",
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	will be converted into:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  map[string]string{
0000000000000000000000000000000000000000;;	    "x_bar": "AAA",
0000000000000000000000000000000000000000;;	    "lorem_ipsum": "BBB",
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Untagged fields and fields left at their zero values are skipped. Integers,
0000000000000000000000000000000000000000;;	booleans and string values are supported.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func BuildHeaders(opts interface{}) (map[string]string, error) {
0000000000000000000000000000000000000000;;		optsValue := reflect.ValueOf(opts)
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsValue = optsValue.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsType := reflect.TypeOf(opts)
0000000000000000000000000000000000000000;;		if optsType.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsType = optsType.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsMap := make(map[string]string)
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			for i := 0; i < optsValue.NumField(); i++ {
0000000000000000000000000000000000000000;;				v := optsValue.Field(i)
0000000000000000000000000000000000000000;;				f := optsType.Field(i)
0000000000000000000000000000000000000000;;				hTag := f.Tag.Get("h")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if the field has a 'h' tag, it goes in the header
0000000000000000000000000000000000000000;;				if hTag != "" {
0000000000000000000000000000000000000000;;					tags := strings.Split(hTag, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// if the field is set, add it to the slice of query pieces
0000000000000000000000000000000000000000;;					if !isZero(v) {
0000000000000000000000000000000000000000;;						switch v.Kind() {
0000000000000000000000000000000000000000;;						case reflect.String:
0000000000000000000000000000000000000000;;							optsMap[tags[0]] = v.String()
0000000000000000000000000000000000000000;;						case reflect.Int:
0000000000000000000000000000000000000000;;							optsMap[tags[0]] = strconv.FormatInt(v.Int(), 10)
0000000000000000000000000000000000000000;;						case reflect.Bool:
0000000000000000000000000000000000000000;;							optsMap[tags[0]] = strconv.FormatBool(v.Bool())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// Otherwise, the field is not set.
0000000000000000000000000000000000000000;;						if len(tags) == 2 && tags[1] == "required" {
0000000000000000000000000000000000000000;;							// And the field is required. Return an error.
0000000000000000000000000000000000000000;;							return optsMap, fmt.Errorf("Required header not set.")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return optsMap, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return an error if the underlying type of 'opts' isn't a struct.
0000000000000000000000000000000000000000;;		return optsMap, fmt.Errorf("Options type is not a struct.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IDSliceToQueryString takes a slice of elements and converts them into a query
0000000000000000000000000000000000000000;;	// string. For example, if name=foo and slice=[]int{20, 40, 60}, then the
0000000000000000000000000000000000000000;;	// result would be `?name=20&name=40&name=60'
0000000000000000000000000000000000000000;;	func IDSliceToQueryString(name string, ids []int) string {
0000000000000000000000000000000000000000;;		str := ""
0000000000000000000000000000000000000000;;		for k, v := range ids {
0000000000000000000000000000000000000000;;			if k == 0 {
0000000000000000000000000000000000000000;;				str += "?"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				str += "&"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			str += fmt.Sprintf("%s=%s", name, strconv.Itoa(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntWithinRange returns TRUE if an integer falls within a defined range, and
0000000000000000000000000000000000000000;;	// FALSE if not.
0000000000000000000000000000000000000000;;	func IntWithinRange(val, min, max int) bool {
0000000000000000000000000000000000000000;;		return val > min && val < max
0000000000000000000000000000000000000000;;	}
