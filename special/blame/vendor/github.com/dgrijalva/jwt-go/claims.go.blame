0000000000000000000000000000000000000000;;	package jwt
ba6ffe25891a71ddd84e82b77bc1c495ddcacd73;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/subtle"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// For a type to be a Claims object, it must just have a Valid method that determines
0000000000000000000000000000000000000000;;	// if the token is invalid for any supported reason
0000000000000000000000000000000000000000;;	type Claims interface {
0000000000000000000000000000000000000000;;		Valid() error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Structured version of Claims Section, as referenced at
0000000000000000000000000000000000000000;;	// https://tools.ietf.org/html/rfc7519#section-4.1
0000000000000000000000000000000000000000;;	// See examples for how to use this with your own claim types
0000000000000000000000000000000000000000;;	type StandardClaims struct {
0000000000000000000000000000000000000000;;		Audience  string `json:"aud,omitempty"`
0000000000000000000000000000000000000000;;		ExpiresAt int64  `json:"exp,omitempty"`
0000000000000000000000000000000000000000;;		Id        string `json:"jti,omitempty"`
0000000000000000000000000000000000000000;;		IssuedAt  int64  `json:"iat,omitempty"`
0000000000000000000000000000000000000000;;		Issuer    string `json:"iss,omitempty"`
0000000000000000000000000000000000000000;;		NotBefore int64  `json:"nbf,omitempty"`
0000000000000000000000000000000000000000;;		Subject   string `json:"sub,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates time based claims "exp, iat, nbf".
0000000000000000000000000000000000000000;;	// There is no accounting for clock skew.
0000000000000000000000000000000000000000;;	// As well, if any of the above claims are not in the token, it will still
0000000000000000000000000000000000000000;;	// be considered a valid claim.
0000000000000000000000000000000000000000;;	func (c StandardClaims) Valid() error {
0000000000000000000000000000000000000000;;		vErr := new(ValidationError)
0000000000000000000000000000000000000000;;		now := TimeFunc().Unix()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The claims below are optional, by default, so if they are set to the
0000000000000000000000000000000000000000;;		// default value in Go, let's not fail the verification for them.
0000000000000000000000000000000000000000;;		if c.VerifyExpiresAt(now, false) == false {
0000000000000000000000000000000000000000;;			delta := time.Unix(now, 0).Sub(time.Unix(c.ExpiresAt, 0))
0000000000000000000000000000000000000000;;			vErr.Inner = fmt.Errorf("token is expired by %v", delta)
0000000000000000000000000000000000000000;;			vErr.Errors |= ValidationErrorExpired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.VerifyIssuedAt(now, false) == false {
0000000000000000000000000000000000000000;;			vErr.Inner = fmt.Errorf("Token used before issued")
0000000000000000000000000000000000000000;;			vErr.Errors |= ValidationErrorIssuedAt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.VerifyNotBefore(now, false) == false {
0000000000000000000000000000000000000000;;			vErr.Inner = fmt.Errorf("token is not valid yet")
0000000000000000000000000000000000000000;;			vErr.Errors |= ValidationErrorNotValidYet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vErr.valid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the aud claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (c *StandardClaims) VerifyAudience(cmp string, req bool) bool {
0000000000000000000000000000000000000000;;		return verifyAud(c.Audience, cmp, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the exp claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (c *StandardClaims) VerifyExpiresAt(cmp int64, req bool) bool {
0000000000000000000000000000000000000000;;		return verifyExp(c.ExpiresAt, cmp, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the iat claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (c *StandardClaims) VerifyIssuedAt(cmp int64, req bool) bool {
0000000000000000000000000000000000000000;;		return verifyIat(c.IssuedAt, cmp, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the iss claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (c *StandardClaims) VerifyIssuer(cmp string, req bool) bool {
0000000000000000000000000000000000000000;;		return verifyIss(c.Issuer, cmp, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the nbf claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (c *StandardClaims) VerifyNotBefore(cmp int64, req bool) bool {
0000000000000000000000000000000000000000;;		return verifyNbf(c.NotBefore, cmp, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----- helpers
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyAud(aud string, cmp string, required bool) bool {
0000000000000000000000000000000000000000;;		if aud == "" {
0000000000000000000000000000000000000000;;			return !required
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if subtle.ConstantTimeCompare([]byte(aud), []byte(cmp)) != 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyExp(exp int64, now int64, required bool) bool {
0000000000000000000000000000000000000000;;		if exp == 0 {
0000000000000000000000000000000000000000;;			return !required
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return now <= exp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyIat(iat int64, now int64, required bool) bool {
0000000000000000000000000000000000000000;;		if iat == 0 {
0000000000000000000000000000000000000000;;			return !required
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return now >= iat
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyIss(iss string, cmp string, required bool) bool {
0000000000000000000000000000000000000000;;		if iss == "" {
0000000000000000000000000000000000000000;;			return !required
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if subtle.ConstantTimeCompare([]byte(iss), []byte(cmp)) != 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func verifyNbf(nbf int64, now int64, required bool) bool {
0000000000000000000000000000000000000000;;		if nbf == 0 {
0000000000000000000000000000000000000000;;			return !required
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return now >= nbf
0000000000000000000000000000000000000000;;	}
