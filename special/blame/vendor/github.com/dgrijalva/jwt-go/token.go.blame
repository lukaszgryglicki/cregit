0000000000000000000000000000000000000000;;	package jwt
ba6ffe25891a71ddd84e82b77bc1c495ddcacd73;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeFunc provides the current time when parsing token to validate "exp" claim (expiration time).
0000000000000000000000000000000000000000;;	// You can override it to use another time value.  This is useful for testing or if your
0000000000000000000000000000000000000000;;	// server uses a different time zone than your tokens.
0000000000000000000000000000000000000000;;	var TimeFunc = time.Now
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse methods use this callback function to supply
0000000000000000000000000000000000000000;;	// the key for verification.  The function receives the parsed,
0000000000000000000000000000000000000000;;	// but unverified Token.  This allows you to use properties in the
0000000000000000000000000000000000000000;;	// Header of the token (such as `kid`) to identify which key to use.
0000000000000000000000000000000000000000;;	type Keyfunc func(*Token) (interface{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A JWT Token.  Different fields will be used depending on whether you're
0000000000000000000000000000000000000000;;	// creating or parsing/verifying a token.
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		Raw       string                 // The raw token.  Populated when you Parse a token
0000000000000000000000000000000000000000;;		Method    SigningMethod          // The signing method used or to be used
0000000000000000000000000000000000000000;;		Header    map[string]interface{} // The first segment of the token
0000000000000000000000000000000000000000;;		Claims    Claims                 // The second segment of the token
0000000000000000000000000000000000000000;;		Signature string                 // The third segment of the token.  Populated when you Parse a token
0000000000000000000000000000000000000000;;		Valid     bool                   // Is the token valid?  Populated when you Parse/Verify a token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new Token.  Takes a signing method
0000000000000000000000000000000000000000;;	func New(method SigningMethod) *Token {
0000000000000000000000000000000000000000;;		return NewWithClaims(method, MapClaims{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewWithClaims(method SigningMethod, claims Claims) *Token {
0000000000000000000000000000000000000000;;		return &Token{
0000000000000000000000000000000000000000;;			Header: map[string]interface{}{
0000000000000000000000000000000000000000;;				"typ": "JWT",
0000000000000000000000000000000000000000;;				"alg": method.Alg(),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Claims: claims,
0000000000000000000000000000000000000000;;			Method: method,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the complete, signed token
0000000000000000000000000000000000000000;;	func (t *Token) SignedString(key interface{}) (string, error) {
0000000000000000000000000000000000000000;;		var sig, sstr string
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if sstr, err = t.SigningString(); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sig, err = t.Method.Sign(sstr, key); err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join([]string{sstr, sig}, "."), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate the signing string.  This is the
0000000000000000000000000000000000000000;;	// most expensive part of the whole deal.  Unless you
0000000000000000000000000000000000000000;;	// need this for something special, just go straight for
0000000000000000000000000000000000000000;;	// the SignedString.
0000000000000000000000000000000000000000;;	func (t *Token) SigningString() (string, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		parts := make([]string, 2)
0000000000000000000000000000000000000000;;		for i, _ := range parts {
0000000000000000000000000000000000000000;;			var jsonValue []byte
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				if jsonValue, err = json.Marshal(t.Header); err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if jsonValue, err = json.Marshal(t.Claims); err != nil {
0000000000000000000000000000000000000000;;					return "", err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			parts[i] = EncodeSegment(jsonValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(parts, "."), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse, validate, and return a token.
0000000000000000000000000000000000000000;;	// keyFunc will receive the parsed token and should return the key for validating.
0000000000000000000000000000000000000000;;	// If everything is kosher, err will be nil
0000000000000000000000000000000000000000;;	func Parse(tokenString string, keyFunc Keyfunc) (*Token, error) {
0000000000000000000000000000000000000000;;		return new(Parser).Parse(tokenString, keyFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {
0000000000000000000000000000000000000000;;		return new(Parser).ParseWithClaims(tokenString, claims, keyFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Encode JWT specific base64url encoding with padding stripped
0000000000000000000000000000000000000000;;	func EncodeSegment(seg []byte) string {
0000000000000000000000000000000000000000;;		return strings.TrimRight(base64.URLEncoding.EncodeToString(seg), "=")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode JWT specific base64url encoding with padding stripped
0000000000000000000000000000000000000000;;	func DecodeSegment(seg string) ([]byte, error) {
0000000000000000000000000000000000000000;;		if l := len(seg) % 4; l > 0 {
0000000000000000000000000000000000000000;;			seg += strings.Repeat("=", 4-l)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return base64.URLEncoding.DecodeString(seg)
0000000000000000000000000000000000000000;;	}
