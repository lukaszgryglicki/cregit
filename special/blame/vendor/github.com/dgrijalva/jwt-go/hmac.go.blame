0000000000000000000000000000000000000000;;	package jwt
60d7e7a19c23729a8887eaae029559136e0e6b02;Godeps/_workspace/src/github.com/dgrijalva/jwt-go/hmac.go[Godeps/_workspace/src/github.com/dgrijalva/jwt-go/hmac.go][vendor/github.com/dgrijalva/jwt-go/hmac.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/hmac"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements the HMAC-SHA family of signing methods signing methods
0000000000000000000000000000000000000000;;	type SigningMethodHMAC struct {
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		Hash crypto.Hash
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Specific instances for HS256 and company
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		SigningMethodHS256  *SigningMethodHMAC
0000000000000000000000000000000000000000;;		SigningMethodHS384  *SigningMethodHMAC
0000000000000000000000000000000000000000;;		SigningMethodHS512  *SigningMethodHMAC
0000000000000000000000000000000000000000;;		ErrSignatureInvalid = errors.New("signature is invalid")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// HS256
0000000000000000000000000000000000000000;;		SigningMethodHS256 = &SigningMethodHMAC{"HS256", crypto.SHA256}
0000000000000000000000000000000000000000;;		RegisterSigningMethod(SigningMethodHS256.Alg(), func() SigningMethod {
0000000000000000000000000000000000000000;;			return SigningMethodHS256
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HS384
0000000000000000000000000000000000000000;;		SigningMethodHS384 = &SigningMethodHMAC{"HS384", crypto.SHA384}
0000000000000000000000000000000000000000;;		RegisterSigningMethod(SigningMethodHS384.Alg(), func() SigningMethod {
0000000000000000000000000000000000000000;;			return SigningMethodHS384
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HS512
0000000000000000000000000000000000000000;;		SigningMethodHS512 = &SigningMethodHMAC{"HS512", crypto.SHA512}
0000000000000000000000000000000000000000;;		RegisterSigningMethod(SigningMethodHS512.Alg(), func() SigningMethod {
0000000000000000000000000000000000000000;;			return SigningMethodHS512
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SigningMethodHMAC) Alg() string {
0000000000000000000000000000000000000000;;		return m.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify the signature of HSXXX tokens.  Returns nil if the signature is valid.
0000000000000000000000000000000000000000;;	func (m *SigningMethodHMAC) Verify(signingString, signature string, key interface{}) error {
0000000000000000000000000000000000000000;;		// Verify the key is the right type
0000000000000000000000000000000000000000;;		keyBytes, ok := key.([]byte)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrInvalidKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decode signature, for comparison
0000000000000000000000000000000000000000;;		sig, err := DecodeSegment(signature)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Can we use the specified hashing method?
0000000000000000000000000000000000000000;;		if !m.Hash.Available() {
0000000000000000000000000000000000000000;;			return ErrHashUnavailable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This signing method is symmetric, so we validate the signature
0000000000000000000000000000000000000000;;		// by reproducing the signature from the signing string and key, then
0000000000000000000000000000000000000000;;		// comparing that against the provided signature.
0000000000000000000000000000000000000000;;		hasher := hmac.New(m.Hash.New, keyBytes)
0000000000000000000000000000000000000000;;		hasher.Write([]byte(signingString))
0000000000000000000000000000000000000000;;		if !hmac.Equal(sig, hasher.Sum(nil)) {
0000000000000000000000000000000000000000;;			return ErrSignatureInvalid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No validation errors.  Signature is good.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements the Sign method from SigningMethod for this signing method.
0000000000000000000000000000000000000000;;	// Key must be []byte
0000000000000000000000000000000000000000;;	func (m *SigningMethodHMAC) Sign(signingString string, key interface{}) (string, error) {
0000000000000000000000000000000000000000;;		if keyBytes, ok := key.([]byte); ok {
0000000000000000000000000000000000000000;;			if !m.Hash.Available() {
0000000000000000000000000000000000000000;;				return "", ErrHashUnavailable
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hasher := hmac.New(m.Hash.New, keyBytes)
0000000000000000000000000000000000000000;;			hasher.Write([]byte(signingString))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return EncodeSegment(hasher.Sum(nil)), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", ErrInvalidKey
0000000000000000000000000000000000000000;;	}
