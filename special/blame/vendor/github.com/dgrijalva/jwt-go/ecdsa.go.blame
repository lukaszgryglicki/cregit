0000000000000000000000000000000000000000;;	package jwt
ba6ffe25891a71ddd84e82b77bc1c495ddcacd73;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Sadly this is missing from crypto/ecdsa compared to crypto/rsa
0000000000000000000000000000000000000000;;		ErrECDSAVerification = errors.New("crypto/ecdsa: verification error")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements the ECDSA family of signing methods signing methods
0000000000000000000000000000000000000000;;	type SigningMethodECDSA struct {
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		Hash      crypto.Hash
0000000000000000000000000000000000000000;;		KeySize   int
0000000000000000000000000000000000000000;;		CurveBits int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Specific instances for EC256 and company
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		SigningMethodES256 *SigningMethodECDSA
0000000000000000000000000000000000000000;;		SigningMethodES384 *SigningMethodECDSA
0000000000000000000000000000000000000000;;		SigningMethodES512 *SigningMethodECDSA
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// ES256
0000000000000000000000000000000000000000;;		SigningMethodES256 = &SigningMethodECDSA{"ES256", crypto.SHA256, 32, 256}
0000000000000000000000000000000000000000;;		RegisterSigningMethod(SigningMethodES256.Alg(), func() SigningMethod {
0000000000000000000000000000000000000000;;			return SigningMethodES256
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ES384
0000000000000000000000000000000000000000;;		SigningMethodES384 = &SigningMethodECDSA{"ES384", crypto.SHA384, 48, 384}
0000000000000000000000000000000000000000;;		RegisterSigningMethod(SigningMethodES384.Alg(), func() SigningMethod {
0000000000000000000000000000000000000000;;			return SigningMethodES384
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ES512
0000000000000000000000000000000000000000;;		SigningMethodES512 = &SigningMethodECDSA{"ES512", crypto.SHA512, 66, 521}
0000000000000000000000000000000000000000;;		RegisterSigningMethod(SigningMethodES512.Alg(), func() SigningMethod {
0000000000000000000000000000000000000000;;			return SigningMethodES512
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SigningMethodECDSA) Alg() string {
0000000000000000000000000000000000000000;;		return m.Name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements the Verify method from SigningMethod
0000000000000000000000000000000000000000;;	// For this verify method, key must be an ecdsa.PublicKey struct
0000000000000000000000000000000000000000;;	func (m *SigningMethodECDSA) Verify(signingString, signature string, key interface{}) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decode the signature
0000000000000000000000000000000000000000;;		var sig []byte
0000000000000000000000000000000000000000;;		if sig, err = DecodeSegment(signature); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the key
0000000000000000000000000000000000000000;;		var ecdsaKey *ecdsa.PublicKey
0000000000000000000000000000000000000000;;		switch k := key.(type) {
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			ecdsaKey = k
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrInvalidKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(sig) != 2*m.KeySize {
0000000000000000000000000000000000000000;;			return ErrECDSAVerification
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := big.NewInt(0).SetBytes(sig[:m.KeySize])
0000000000000000000000000000000000000000;;		s := big.NewInt(0).SetBytes(sig[m.KeySize:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create hasher
0000000000000000000000000000000000000000;;		if !m.Hash.Available() {
0000000000000000000000000000000000000000;;			return ErrHashUnavailable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasher := m.Hash.New()
0000000000000000000000000000000000000000;;		hasher.Write([]byte(signingString))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify the signature
0000000000000000000000000000000000000000;;		if verifystatus := ecdsa.Verify(ecdsaKey, hasher.Sum(nil), r, s); verifystatus == true {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return ErrECDSAVerification
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Implements the Sign method from SigningMethod
0000000000000000000000000000000000000000;;	// For this signing method, key must be an ecdsa.PrivateKey struct
0000000000000000000000000000000000000000;;	func (m *SigningMethodECDSA) Sign(signingString string, key interface{}) (string, error) {
0000000000000000000000000000000000000000;;		// Get the key
0000000000000000000000000000000000000000;;		var ecdsaKey *ecdsa.PrivateKey
0000000000000000000000000000000000000000;;		switch k := key.(type) {
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			ecdsaKey = k
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", ErrInvalidKeyType
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the hasher
0000000000000000000000000000000000000000;;		if !m.Hash.Available() {
0000000000000000000000000000000000000000;;			return "", ErrHashUnavailable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasher := m.Hash.New()
0000000000000000000000000000000000000000;;		hasher.Write([]byte(signingString))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sign the string and return r, s
0000000000000000000000000000000000000000;;		if r, s, err := ecdsa.Sign(rand.Reader, ecdsaKey, hasher.Sum(nil)); err == nil {
0000000000000000000000000000000000000000;;			curveBits := ecdsaKey.Curve.Params().BitSize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if m.CurveBits != curveBits {
0000000000000000000000000000000000000000;;				return "", ErrInvalidKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			keyBytes := curveBits / 8
0000000000000000000000000000000000000000;;			if curveBits%8 > 0 {
0000000000000000000000000000000000000000;;				keyBytes += 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// We serialize the outpus (r and s) into big-endian byte arrays and pad
0000000000000000000000000000000000000000;;			// them with zeros on the left to make sure the sizes work out. Both arrays
0000000000000000000000000000000000000000;;			// must be keyBytes long, and the output must be 2*keyBytes long.
0000000000000000000000000000000000000000;;			rBytes := r.Bytes()
0000000000000000000000000000000000000000;;			rBytesPadded := make([]byte, keyBytes)
0000000000000000000000000000000000000000;;			copy(rBytesPadded[keyBytes-len(rBytes):], rBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sBytes := s.Bytes()
0000000000000000000000000000000000000000;;			sBytesPadded := make([]byte, keyBytes)
0000000000000000000000000000000000000000;;			copy(sBytesPadded[keyBytes-len(sBytes):], sBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out := append(rBytesPadded, sBytesPadded...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return EncodeSegment(out), nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
