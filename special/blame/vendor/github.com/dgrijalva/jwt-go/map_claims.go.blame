0000000000000000000000000000000000000000;;	package jwt
ba6ffe25891a71ddd84e82b77bc1c495ddcacd73;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		// "fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Claims type that uses the map[string]interface{} for JSON decoding
0000000000000000000000000000000000000000;;	// This is the default claims type if you don't supply one
0000000000000000000000000000000000000000;;	type MapClaims map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the aud claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (m MapClaims) VerifyAudience(cmp string, req bool) bool {
0000000000000000000000000000000000000000;;		aud, _ := m["aud"].(string)
0000000000000000000000000000000000000000;;		return verifyAud(aud, cmp, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the exp claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (m MapClaims) VerifyExpiresAt(cmp int64, req bool) bool {
0000000000000000000000000000000000000000;;		switch exp := m["exp"].(type) {
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			return verifyExp(int64(exp), cmp, req)
0000000000000000000000000000000000000000;;		case json.Number:
0000000000000000000000000000000000000000;;			v, _ := exp.Int64()
0000000000000000000000000000000000000000;;			return verifyExp(v, cmp, req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return req == false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the iat claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (m MapClaims) VerifyIssuedAt(cmp int64, req bool) bool {
0000000000000000000000000000000000000000;;		switch iat := m["iat"].(type) {
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			return verifyIat(int64(iat), cmp, req)
0000000000000000000000000000000000000000;;		case json.Number:
0000000000000000000000000000000000000000;;			v, _ := iat.Int64()
0000000000000000000000000000000000000000;;			return verifyIat(v, cmp, req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return req == false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the iss claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (m MapClaims) VerifyIssuer(cmp string, req bool) bool {
0000000000000000000000000000000000000000;;		iss, _ := m["iss"].(string)
0000000000000000000000000000000000000000;;		return verifyIss(iss, cmp, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compares the nbf claim against cmp.
0000000000000000000000000000000000000000;;	// If required is false, this method will return true if the value matches or is unset
0000000000000000000000000000000000000000;;	func (m MapClaims) VerifyNotBefore(cmp int64, req bool) bool {
0000000000000000000000000000000000000000;;		switch nbf := m["nbf"].(type) {
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			return verifyNbf(int64(nbf), cmp, req)
0000000000000000000000000000000000000000;;		case json.Number:
0000000000000000000000000000000000000000;;			v, _ := nbf.Int64()
0000000000000000000000000000000000000000;;			return verifyNbf(v, cmp, req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return req == false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validates time based claims "exp, iat, nbf".
0000000000000000000000000000000000000000;;	// There is no accounting for clock skew.
0000000000000000000000000000000000000000;;	// As well, if any of the above claims are not in the token, it will still
0000000000000000000000000000000000000000;;	// be considered a valid claim.
0000000000000000000000000000000000000000;;	func (m MapClaims) Valid() error {
0000000000000000000000000000000000000000;;		vErr := new(ValidationError)
0000000000000000000000000000000000000000;;		now := TimeFunc().Unix()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.VerifyExpiresAt(now, false) == false {
0000000000000000000000000000000000000000;;			vErr.Inner = errors.New("Token is expired")
0000000000000000000000000000000000000000;;			vErr.Errors |= ValidationErrorExpired
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.VerifyIssuedAt(now, false) == false {
0000000000000000000000000000000000000000;;			vErr.Inner = errors.New("Token used before issued")
0000000000000000000000000000000000000000;;			vErr.Errors |= ValidationErrorIssuedAt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if m.VerifyNotBefore(now, false) == false {
0000000000000000000000000000000000000000;;			vErr.Inner = errors.New("Token is not valid yet")
0000000000000000000000000000000000000000;;			vErr.Errors |= ValidationErrorNotValidYet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vErr.valid() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return vErr
0000000000000000000000000000000000000000;;	}
