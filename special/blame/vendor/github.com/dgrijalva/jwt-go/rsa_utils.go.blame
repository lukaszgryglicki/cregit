0000000000000000000000000000000000000000;;	package jwt
60d7e7a19c23729a8887eaae029559136e0e6b02;Godeps/_workspace/src/github.com/dgrijalva/jwt-go/rsa_utils.go[Godeps/_workspace/src/github.com/dgrijalva/jwt-go/rsa_utils.go][vendor/github.com/dgrijalva/jwt-go/rsa_utils.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrKeyMustBePEMEncoded = errors.New("Invalid Key: Key must be PEM encoded PKCS1 or PKCS8 private key")
0000000000000000000000000000000000000000;;		ErrNotRSAPrivateKey    = errors.New("Key is not a valid RSA private key")
0000000000000000000000000000000000000000;;		ErrNotRSAPublicKey     = errors.New("Key is not a valid RSA public key")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse PEM encoded PKCS1 or PKCS8 private key
0000000000000000000000000000000000000000;;	func ParseRSAPrivateKeyFromPEM(key []byte) (*rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse PEM block
0000000000000000000000000000000000000000;;		var block *pem.Block
0000000000000000000000000000000000000000;;		if block, _ = pem.Decode(key); block == nil {
0000000000000000000000000000000000000000;;			return nil, ErrKeyMustBePEMEncoded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var parsedKey interface{}
0000000000000000000000000000000000000000;;		if parsedKey, err = x509.ParsePKCS1PrivateKey(block.Bytes); err != nil {
0000000000000000000000000000000000000000;;			if parsedKey, err = x509.ParsePKCS8PrivateKey(block.Bytes); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pkey *rsa.PrivateKey
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if pkey, ok = parsedKey.(*rsa.PrivateKey); !ok {
0000000000000000000000000000000000000000;;			return nil, ErrNotRSAPrivateKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pkey, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse PEM encoded PKCS1 or PKCS8 public key
0000000000000000000000000000000000000000;;	func ParseRSAPublicKeyFromPEM(key []byte) (*rsa.PublicKey, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse PEM block
0000000000000000000000000000000000000000;;		var block *pem.Block
0000000000000000000000000000000000000000;;		if block, _ = pem.Decode(key); block == nil {
0000000000000000000000000000000000000000;;			return nil, ErrKeyMustBePEMEncoded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse the key
0000000000000000000000000000000000000000;;		var parsedKey interface{}
0000000000000000000000000000000000000000;;		if parsedKey, err = x509.ParsePKIXPublicKey(block.Bytes); err != nil {
0000000000000000000000000000000000000000;;			if cert, err := x509.ParseCertificate(block.Bytes); err == nil {
0000000000000000000000000000000000000000;;				parsedKey = cert.PublicKey
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pkey *rsa.PublicKey
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		if pkey, ok = parsedKey.(*rsa.PublicKey); !ok {
0000000000000000000000000000000000000000;;			return nil, ErrNotRSAPublicKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pkey, nil
0000000000000000000000000000000000000000;;	}
