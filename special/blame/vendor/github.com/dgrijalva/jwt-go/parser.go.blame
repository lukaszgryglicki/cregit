0000000000000000000000000000000000000000;;	package jwt
ba6ffe25891a71ddd84e82b77bc1c495ddcacd73;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parser struct {
0000000000000000000000000000000000000000;;		ValidMethods         []string // If populated, only these methods will be considered valid
0000000000000000000000000000000000000000;;		UseJSONNumber        bool     // Use JSON Number format in JSON decoder
0000000000000000000000000000000000000000;;		SkipClaimsValidation bool     // Skip claims validation during token parsing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse, validate, and return a token.
0000000000000000000000000000000000000000;;	// keyFunc will receive the parsed token and should return the key for validating.
0000000000000000000000000000000000000000;;	// If everything is kosher, err will be nil
0000000000000000000000000000000000000000;;	func (p *Parser) Parse(tokenString string, keyFunc Keyfunc) (*Token, error) {
0000000000000000000000000000000000000000;;		return p.ParseWithClaims(tokenString, MapClaims{}, keyFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) ParseWithClaims(tokenString string, claims Claims, keyFunc Keyfunc) (*Token, error) {
0000000000000000000000000000000000000000;;		parts := strings.Split(tokenString, ".")
0000000000000000000000000000000000000000;;		if len(parts) != 3 {
0000000000000000000000000000000000000000;;			return nil, NewValidationError("token contains an invalid number of segments", ValidationErrorMalformed)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		token := &Token{Raw: tokenString}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse Header
0000000000000000000000000000000000000000;;		var headerBytes []byte
0000000000000000000000000000000000000000;;		if headerBytes, err = DecodeSegment(parts[0]); err != nil {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(strings.ToLower(tokenString), "bearer ") {
0000000000000000000000000000000000000000;;				return token, NewValidationError("tokenstring should not contain 'bearer '", ValidationErrorMalformed)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return token, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = json.Unmarshal(headerBytes, &token.Header); err != nil {
0000000000000000000000000000000000000000;;			return token, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse Claims
0000000000000000000000000000000000000000;;		var claimBytes []byte
0000000000000000000000000000000000000000;;		token.Claims = claims
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if claimBytes, err = DecodeSegment(parts[1]); err != nil {
0000000000000000000000000000000000000000;;			return token, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dec := json.NewDecoder(bytes.NewBuffer(claimBytes))
0000000000000000000000000000000000000000;;		if p.UseJSONNumber {
0000000000000000000000000000000000000000;;			dec.UseNumber()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// JSON Decode.  Special case for map type to avoid weird pointer behavior
0000000000000000000000000000000000000000;;		if c, ok := token.Claims.(MapClaims); ok {
0000000000000000000000000000000000000000;;			err = dec.Decode(&c)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			err = dec.Decode(&claims)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Handle decode error
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return token, &ValidationError{Inner: err, Errors: ValidationErrorMalformed}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lookup signature method
0000000000000000000000000000000000000000;;		if method, ok := token.Header["alg"].(string); ok {
0000000000000000000000000000000000000000;;			if token.Method = GetSigningMethod(method); token.Method == nil {
0000000000000000000000000000000000000000;;				return token, NewValidationError("signing method (alg) is unavailable.", ValidationErrorUnverifiable)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return token, NewValidationError("signing method (alg) is unspecified.", ValidationErrorUnverifiable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify signing method is in the required set
0000000000000000000000000000000000000000;;		if p.ValidMethods != nil {
0000000000000000000000000000000000000000;;			var signingMethodValid = false
0000000000000000000000000000000000000000;;			var alg = token.Method.Alg()
0000000000000000000000000000000000000000;;			for _, m := range p.ValidMethods {
0000000000000000000000000000000000000000;;				if m == alg {
0000000000000000000000000000000000000000;;					signingMethodValid = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !signingMethodValid {
0000000000000000000000000000000000000000;;				// signing method is not in the listed set
0000000000000000000000000000000000000000;;				return token, NewValidationError(fmt.Sprintf("signing method %v is invalid", alg), ValidationErrorSignatureInvalid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lookup key
0000000000000000000000000000000000000000;;		var key interface{}
0000000000000000000000000000000000000000;;		if keyFunc == nil {
0000000000000000000000000000000000000000;;			// keyFunc was not provided.  short circuiting validation
0000000000000000000000000000000000000000;;			return token, NewValidationError("no Keyfunc was provided.", ValidationErrorUnverifiable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if key, err = keyFunc(token); err != nil {
0000000000000000000000000000000000000000;;			// keyFunc returned an error
0000000000000000000000000000000000000000;;			return token, &ValidationError{Inner: err, Errors: ValidationErrorUnverifiable}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vErr := &ValidationError{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Validate Claims
0000000000000000000000000000000000000000;;		if !p.SkipClaimsValidation {
0000000000000000000000000000000000000000;;			if err := token.Claims.Valid(); err != nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If the Claims Valid returned an error, check if it is a validation error,
0000000000000000000000000000000000000000;;				// If it was another error type, create a ValidationError with a generic ClaimsInvalid flag set
0000000000000000000000000000000000000000;;				if e, ok := err.(*ValidationError); !ok {
0000000000000000000000000000000000000000;;					vErr = &ValidationError{Inner: err, Errors: ValidationErrorClaimsInvalid}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					vErr = e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Perform validation
0000000000000000000000000000000000000000;;		token.Signature = parts[2]
0000000000000000000000000000000000000000;;		if err = token.Method.Verify(strings.Join(parts[0:2], "."), token.Signature, key); err != nil {
0000000000000000000000000000000000000000;;			vErr.Inner = err
0000000000000000000000000000000000000000;;			vErr.Errors |= ValidationErrorSignatureInvalid
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vErr.valid() {
0000000000000000000000000000000000000000;;			token.Valid = true
0000000000000000000000000000000000000000;;			return token, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return token, vErr
0000000000000000000000000000000000000000;;	}
