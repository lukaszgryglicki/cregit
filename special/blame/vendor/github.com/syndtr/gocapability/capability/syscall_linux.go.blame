0000000000000000000000000000000000000000;;	// Copyright (c) 2013, Suryandaru Triandana <syndtr@gmail.com>
0000000000000000000000000000000000000000;;	// All rights reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style license that can be
0000000000000000000000000000000000000000;;	// found in the LICENSE file.
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/syndtr/gocapability/capability/syscall_linux.go[Godeps/_workspace/src/github.com/syndtr/gocapability/capability/syscall_linux.go][vendor/github.com/syndtr/gocapability/capability/syscall_linux.go];	
0000000000000000000000000000000000000000;;	package capability
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type capHeader struct {
0000000000000000000000000000000000000000;;		version uint32
0000000000000000000000000000000000000000;;		pid     int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type capData struct {
0000000000000000000000000000000000000000;;		effective   uint32
0000000000000000000000000000000000000000;;		permitted   uint32
0000000000000000000000000000000000000000;;		inheritable uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func capget(hdr *capHeader, data *capData) (err error) {
0000000000000000000000000000000000000000;;		_, _, e1 := syscall.Syscall(syscall.SYS_CAPGET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func capset(hdr *capHeader, data *capData) (err error) {
0000000000000000000000000000000000000000;;		_, _, e1 := syscall.Syscall(syscall.SYS_CAPSET, uintptr(unsafe.Pointer(hdr)), uintptr(unsafe.Pointer(data)), 0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// not yet in syscall
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		pr_CAP_AMBIENT           = 47
0000000000000000000000000000000000000000;;		pr_CAP_AMBIENT_IS_SET    = uintptr(1)
0000000000000000000000000000000000000000;;		pr_CAP_AMBIENT_RAISE     = uintptr(2)
0000000000000000000000000000000000000000;;		pr_CAP_AMBIENT_LOWER     = uintptr(3)
0000000000000000000000000000000000000000;;		pr_CAP_AMBIENT_CLEAR_ALL = uintptr(4)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prctl(option int, arg2, arg3, arg4, arg5 uintptr) (err error) {
0000000000000000000000000000000000000000;;		_, _, e1 := syscall.Syscall6(syscall.SYS_PRCTL, uintptr(option), arg2, arg3, arg4, arg5, 0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		vfsXattrName = "security.capability"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vfsCapVerMask = 0xff000000
0000000000000000000000000000000000000000;;		vfsCapVer1    = 0x01000000
0000000000000000000000000000000000000000;;		vfsCapVer2    = 0x02000000
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vfsCapFlagMask      = ^vfsCapVerMask
0000000000000000000000000000000000000000;;		vfsCapFlageffective = 0x000001
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vfscapDataSizeV1 = 4 * (1 + 2*1)
0000000000000000000000000000000000000000;;		vfscapDataSizeV2 = 4 * (1 + 2*2)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type vfscapData struct {
0000000000000000000000000000000000000000;;		magic uint32
0000000000000000000000000000000000000000;;		data  [2]struct {
0000000000000000000000000000000000000000;;			permitted   uint32
0000000000000000000000000000000000000000;;			inheritable uint32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		effective [2]uint32
0000000000000000000000000000000000000000;;		version   int8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		_vfsXattrName *byte
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		_vfsXattrName, _ = syscall.BytePtrFromString(vfsXattrName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVfsCap(path string, dest *vfscapData) (err error) {
0000000000000000000000000000000000000000;;		var _p0 *byte
0000000000000000000000000000000000000000;;		_p0, err = syscall.BytePtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r0, _, e1 := syscall.Syscall6(syscall.SYS_GETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_vfsXattrName)), uintptr(unsafe.Pointer(dest)), vfscapDataSizeV2, 0, 0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			if e1 == syscall.ENODATA {
0000000000000000000000000000000000000000;;				dest.version = 2
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch dest.magic & vfsCapVerMask {
0000000000000000000000000000000000000000;;		case vfsCapVer1:
0000000000000000000000000000000000000000;;			dest.version = 1
0000000000000000000000000000000000000000;;			if r0 != vfscapDataSizeV1 {
0000000000000000000000000000000000000000;;				return syscall.EINVAL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dest.data[1].permitted = 0
0000000000000000000000000000000000000000;;			dest.data[1].inheritable = 0
0000000000000000000000000000000000000000;;		case vfsCapVer2:
0000000000000000000000000000000000000000;;			dest.version = 2
0000000000000000000000000000000000000000;;			if r0 != vfscapDataSizeV2 {
0000000000000000000000000000000000000000;;				return syscall.EINVAL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dest.magic&vfsCapFlageffective != 0 {
0000000000000000000000000000000000000000;;			dest.effective[0] = dest.data[0].permitted | dest.data[0].inheritable
0000000000000000000000000000000000000000;;			dest.effective[1] = dest.data[1].permitted | dest.data[1].inheritable
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			dest.effective[0] = 0
0000000000000000000000000000000000000000;;			dest.effective[1] = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setVfsCap(path string, data *vfscapData) (err error) {
0000000000000000000000000000000000000000;;		var _p0 *byte
0000000000000000000000000000000000000000;;		_p0, err = syscall.BytePtrFromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var size uintptr
0000000000000000000000000000000000000000;;		if data.version == 1 {
0000000000000000000000000000000000000000;;			data.magic = vfsCapVer1
0000000000000000000000000000000000000000;;			size = vfscapDataSizeV1
0000000000000000000000000000000000000000;;		} else if data.version == 2 {
0000000000000000000000000000000000000000;;			data.magic = vfsCapVer2
0000000000000000000000000000000000000000;;			if data.effective[0] != 0 || data.effective[1] != 0 {
0000000000000000000000000000000000000000;;				data.magic |= vfsCapFlageffective
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			size = vfscapDataSizeV2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return syscall.EINVAL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, _, e1 := syscall.Syscall6(syscall.SYS_SETXATTR, uintptr(unsafe.Pointer(_p0)), uintptr(unsafe.Pointer(_vfsXattrName)), uintptr(unsafe.Pointer(data)), size, 0, 0)
0000000000000000000000000000000000000000;;		if e1 != 0 {
0000000000000000000000000000000000000000;;			err = e1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
