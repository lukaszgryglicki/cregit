0000000000000000000000000000000000000000;;	// Copyright (c) 2013, Suryandaru Triandana <syndtr@gmail.com>
0000000000000000000000000000000000000000;;	// All rights reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style license that can be
0000000000000000000000000000000000000000;;	// found in the LICENSE file.
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/syndtr/gocapability/capability/capability_linux.go[Godeps/_workspace/src/github.com/syndtr/gocapability/capability/capability_linux.go][vendor/github.com/syndtr/gocapability/capability/capability_linux.go];	
0000000000000000000000000000000000000000;;	package capability
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errUnknownVers = errors.New("unknown capability version")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		linuxCapVer1 = 0x19980330
0000000000000000000000000000000000000000;;		linuxCapVer2 = 0x20071026
0000000000000000000000000000000000000000;;		linuxCapVer3 = 0x20080522
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		capVers    uint32
0000000000000000000000000000000000000000;;		capLastCap Cap
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		var hdr capHeader
0000000000000000000000000000000000000000;;		capget(&hdr, nil)
0000000000000000000000000000000000000000;;		capVers = hdr.version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if initLastCap() == nil {
0000000000000000000000000000000000000000;;			CAP_LAST_CAP = capLastCap
0000000000000000000000000000000000000000;;			if capLastCap > 31 {
0000000000000000000000000000000000000000;;				capUpperMask = (uint32(1) << (uint(capLastCap) - 31)) - 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				capUpperMask = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initLastCap() error {
0000000000000000000000000000000000000000;;		if capLastCap != 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open("/proc/sys/kernel/cap_last_cap")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var b []byte = make([]byte, 11)
0000000000000000000000000000000000000000;;		_, err = f.Read(b)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Sscanf(string(b), "%d", &capLastCap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mkStringCap(c Capabilities, which CapType) (ret string) {
0000000000000000000000000000000000000000;;		for i, first := Cap(0), true; i <= CAP_LAST_CAP; i++ {
0000000000000000000000000000000000000000;;			if !c.Get(which, i) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				first = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ret += ", "
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret += i.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mkString(c Capabilities, max CapType) (ret string) {
0000000000000000000000000000000000000000;;		ret = "{"
0000000000000000000000000000000000000000;;		for i := CapType(1); i <= max; i <<= 1 {
0000000000000000000000000000000000000000;;			ret += " " + i.String() + "=\""
0000000000000000000000000000000000000000;;			if c.Empty(i) {
0000000000000000000000000000000000000000;;				ret += "empty"
0000000000000000000000000000000000000000;;			} else if c.Full(i) {
0000000000000000000000000000000000000000;;				ret += "full"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ret += c.StringCap(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret += "\""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret += " }"
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newPid(pid int) (c Capabilities, err error) {
0000000000000000000000000000000000000000;;		switch capVers {
0000000000000000000000000000000000000000;;		case linuxCapVer1:
0000000000000000000000000000000000000000;;			p := new(capsV1)
0000000000000000000000000000000000000000;;			p.hdr.version = capVers
0000000000000000000000000000000000000000;;			p.hdr.pid = pid
0000000000000000000000000000000000000000;;			c = p
0000000000000000000000000000000000000000;;		case linuxCapVer2, linuxCapVer3:
0000000000000000000000000000000000000000;;			p := new(capsV3)
0000000000000000000000000000000000000000;;			p.hdr.version = capVers
0000000000000000000000000000000000000000;;			p.hdr.pid = pid
0000000000000000000000000000000000000000;;			c = p
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = errUnknownVers
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.Load()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type capsV1 struct {
0000000000000000000000000000000000000000;;		hdr  capHeader
0000000000000000000000000000000000000000;;		data capData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Get(which CapType, what Cap) bool {
0000000000000000000000000000000000000000;;		if what > 32 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch which {
0000000000000000000000000000000000000000;;		case EFFECTIVE:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data.effective != 0
0000000000000000000000000000000000000000;;		case PERMITTED:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data.permitted != 0
0000000000000000000000000000000000000000;;		case INHERITABLE:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data.inheritable != 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) getData(which CapType) (ret uint32) {
0000000000000000000000000000000000000000;;		switch which {
0000000000000000000000000000000000000000;;		case EFFECTIVE:
0000000000000000000000000000000000000000;;			ret = c.data.effective
0000000000000000000000000000000000000000;;		case PERMITTED:
0000000000000000000000000000000000000000;;			ret = c.data.permitted
0000000000000000000000000000000000000000;;		case INHERITABLE:
0000000000000000000000000000000000000000;;			ret = c.data.inheritable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Empty(which CapType) bool {
0000000000000000000000000000000000000000;;		return c.getData(which) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Full(which CapType) bool {
0000000000000000000000000000000000000000;;		return (c.getData(which) & 0x7fffffff) == 0x7fffffff
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Set(which CapType, caps ...Cap) {
0000000000000000000000000000000000000000;;		for _, what := range caps {
0000000000000000000000000000000000000000;;			if what > 32 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if which&EFFECTIVE != 0 {
0000000000000000000000000000000000000000;;				c.data.effective |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&PERMITTED != 0 {
0000000000000000000000000000000000000000;;				c.data.permitted |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&INHERITABLE != 0 {
0000000000000000000000000000000000000000;;				c.data.inheritable |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Unset(which CapType, caps ...Cap) {
0000000000000000000000000000000000000000;;		for _, what := range caps {
0000000000000000000000000000000000000000;;			if what > 32 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if which&EFFECTIVE != 0 {
0000000000000000000000000000000000000000;;				c.data.effective &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&PERMITTED != 0 {
0000000000000000000000000000000000000000;;				c.data.permitted &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&INHERITABLE != 0 {
0000000000000000000000000000000000000000;;				c.data.inheritable &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Fill(kind CapType) {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			c.data.effective = 0x7fffffff
0000000000000000000000000000000000000000;;			c.data.permitted = 0x7fffffff
0000000000000000000000000000000000000000;;			c.data.inheritable = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Clear(kind CapType) {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			c.data.effective = 0
0000000000000000000000000000000000000000;;			c.data.permitted = 0
0000000000000000000000000000000000000000;;			c.data.inheritable = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) StringCap(which CapType) (ret string) {
0000000000000000000000000000000000000000;;		return mkStringCap(c, which)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) String() (ret string) {
0000000000000000000000000000000000000000;;		return mkString(c, BOUNDING)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Load() (err error) {
0000000000000000000000000000000000000000;;		return capget(&c.hdr, &c.data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV1) Apply(kind CapType) error {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			return capset(&c.hdr, &c.data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type capsV3 struct {
0000000000000000000000000000000000000000;;		hdr     capHeader
0000000000000000000000000000000000000000;;		data    [2]capData
0000000000000000000000000000000000000000;;		bounds  [2]uint32
0000000000000000000000000000000000000000;;		ambient [2]uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Get(which CapType, what Cap) bool {
0000000000000000000000000000000000000000;;		var i uint
0000000000000000000000000000000000000000;;		if what > 31 {
0000000000000000000000000000000000000000;;			i = uint(what) >> 5
0000000000000000000000000000000000000000;;			what %= 32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch which {
0000000000000000000000000000000000000000;;		case EFFECTIVE:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data[i].effective != 0
0000000000000000000000000000000000000000;;		case PERMITTED:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data[i].permitted != 0
0000000000000000000000000000000000000000;;		case INHERITABLE:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data[i].inheritable != 0
0000000000000000000000000000000000000000;;		case BOUNDING:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.bounds[i] != 0
0000000000000000000000000000000000000000;;		case AMBIENT:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.ambient[i] != 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) getData(which CapType, dest []uint32) {
0000000000000000000000000000000000000000;;		switch which {
0000000000000000000000000000000000000000;;		case EFFECTIVE:
0000000000000000000000000000000000000000;;			dest[0] = c.data[0].effective
0000000000000000000000000000000000000000;;			dest[1] = c.data[1].effective
0000000000000000000000000000000000000000;;		case PERMITTED:
0000000000000000000000000000000000000000;;			dest[0] = c.data[0].permitted
0000000000000000000000000000000000000000;;			dest[1] = c.data[1].permitted
0000000000000000000000000000000000000000;;		case INHERITABLE:
0000000000000000000000000000000000000000;;			dest[0] = c.data[0].inheritable
0000000000000000000000000000000000000000;;			dest[1] = c.data[1].inheritable
0000000000000000000000000000000000000000;;		case BOUNDING:
0000000000000000000000000000000000000000;;			dest[0] = c.bounds[0]
0000000000000000000000000000000000000000;;			dest[1] = c.bounds[1]
0000000000000000000000000000000000000000;;		case AMBIENT:
0000000000000000000000000000000000000000;;			dest[0] = c.ambient[0]
0000000000000000000000000000000000000000;;			dest[1] = c.ambient[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Empty(which CapType) bool {
0000000000000000000000000000000000000000;;		var data [2]uint32
0000000000000000000000000000000000000000;;		c.getData(which, data[:])
0000000000000000000000000000000000000000;;		return data[0] == 0 && data[1] == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Full(which CapType) bool {
0000000000000000000000000000000000000000;;		var data [2]uint32
0000000000000000000000000000000000000000;;		c.getData(which, data[:])
0000000000000000000000000000000000000000;;		if (data[0] & 0xffffffff) != 0xffffffff {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (data[1] & capUpperMask) == capUpperMask
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Set(which CapType, caps ...Cap) {
0000000000000000000000000000000000000000;;		for _, what := range caps {
0000000000000000000000000000000000000000;;			var i uint
0000000000000000000000000000000000000000;;			if what > 31 {
0000000000000000000000000000000000000000;;				i = uint(what) >> 5
0000000000000000000000000000000000000000;;				what %= 32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if which&EFFECTIVE != 0 {
0000000000000000000000000000000000000000;;				c.data[i].effective |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&PERMITTED != 0 {
0000000000000000000000000000000000000000;;				c.data[i].permitted |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&INHERITABLE != 0 {
0000000000000000000000000000000000000000;;				c.data[i].inheritable |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&BOUNDING != 0 {
0000000000000000000000000000000000000000;;				c.bounds[i] |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&AMBIENT != 0 {
0000000000000000000000000000000000000000;;				c.ambient[i] |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Unset(which CapType, caps ...Cap) {
0000000000000000000000000000000000000000;;		for _, what := range caps {
0000000000000000000000000000000000000000;;			var i uint
0000000000000000000000000000000000000000;;			if what > 31 {
0000000000000000000000000000000000000000;;				i = uint(what) >> 5
0000000000000000000000000000000000000000;;				what %= 32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if which&EFFECTIVE != 0 {
0000000000000000000000000000000000000000;;				c.data[i].effective &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&PERMITTED != 0 {
0000000000000000000000000000000000000000;;				c.data[i].permitted &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&INHERITABLE != 0 {
0000000000000000000000000000000000000000;;				c.data[i].inheritable &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&BOUNDING != 0 {
0000000000000000000000000000000000000000;;				c.bounds[i] &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&AMBIENT != 0 {
0000000000000000000000000000000000000000;;				c.ambient[i] &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Fill(kind CapType) {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			c.data[0].effective = 0xffffffff
0000000000000000000000000000000000000000;;			c.data[0].permitted = 0xffffffff
0000000000000000000000000000000000000000;;			c.data[0].inheritable = 0
0000000000000000000000000000000000000000;;			c.data[1].effective = 0xffffffff
0000000000000000000000000000000000000000;;			c.data[1].permitted = 0xffffffff
0000000000000000000000000000000000000000;;			c.data[1].inheritable = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kind&BOUNDS == BOUNDS {
0000000000000000000000000000000000000000;;			c.bounds[0] = 0xffffffff
0000000000000000000000000000000000000000;;			c.bounds[1] = 0xffffffff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if kind&AMBS == AMBS {
0000000000000000000000000000000000000000;;			c.ambient[0] = 0xffffffff
0000000000000000000000000000000000000000;;			c.ambient[1] = 0xffffffff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Clear(kind CapType) {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			c.data[0].effective = 0
0000000000000000000000000000000000000000;;			c.data[0].permitted = 0
0000000000000000000000000000000000000000;;			c.data[0].inheritable = 0
0000000000000000000000000000000000000000;;			c.data[1].effective = 0
0000000000000000000000000000000000000000;;			c.data[1].permitted = 0
0000000000000000000000000000000000000000;;			c.data[1].inheritable = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kind&BOUNDS == BOUNDS {
0000000000000000000000000000000000000000;;			c.bounds[0] = 0
0000000000000000000000000000000000000000;;			c.bounds[1] = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if kind&AMBS == AMBS {
0000000000000000000000000000000000000000;;			c.ambient[0] = 0
0000000000000000000000000000000000000000;;			c.ambient[1] = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) StringCap(which CapType) (ret string) {
0000000000000000000000000000000000000000;;		return mkStringCap(c, which)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) String() (ret string) {
0000000000000000000000000000000000000000;;		return mkString(c, BOUNDING)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Load() (err error) {
0000000000000000000000000000000000000000;;		err = capget(&c.hdr, &c.data[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var status_path string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.hdr.pid == 0 {
0000000000000000000000000000000000000000;;			status_path = fmt.Sprintf("/proc/self/status")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			status_path = fmt.Sprintf("/proc/%d/status", c.hdr.pid)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.Open(status_path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b := bufio.NewReader(f)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			line, e := b.ReadString('\n')
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				if e != io.EOF {
0000000000000000000000000000000000000000;;					err = e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "CapB") {
0000000000000000000000000000000000000000;;				fmt.Sscanf(line[4:], "nd:  %08x%08x", &c.bounds[1], &c.bounds[0])
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasPrefix(line, "CapA") {
0000000000000000000000000000000000000000;;				fmt.Sscanf(line[4:], "mb:  %08x%08x", &c.ambient[1], &c.ambient[0])
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsV3) Apply(kind CapType) (err error) {
0000000000000000000000000000000000000000;;		if kind&BOUNDS == BOUNDS {
0000000000000000000000000000000000000000;;			var data [2]capData
0000000000000000000000000000000000000000;;			err = capget(&c.hdr, &data[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (1<<uint(CAP_SETPCAP))&data[0].effective != 0 {
0000000000000000000000000000000000000000;;				for i := Cap(0); i <= CAP_LAST_CAP; i++ {
0000000000000000000000000000000000000000;;					if c.Get(BOUNDING, i) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					err = prctl(syscall.PR_CAPBSET_DROP, uintptr(i), 0, 0, 0)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						// Ignore EINVAL since the capability may not be supported in this system.
0000000000000000000000000000000000000000;;						if errno, ok := err.(syscall.Errno); ok && errno == syscall.EINVAL {
0000000000000000000000000000000000000000;;							err = nil
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			err = capset(&c.hdr, &c.data[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kind&AMBS == AMBS {
0000000000000000000000000000000000000000;;			for i := Cap(0); i <= CAP_LAST_CAP; i++ {
0000000000000000000000000000000000000000;;				action := pr_CAP_AMBIENT_LOWER
0000000000000000000000000000000000000000;;				if c.Get(AMBIENT, i) {
0000000000000000000000000000000000000000;;					action = pr_CAP_AMBIENT_RAISE
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := prctl(pr_CAP_AMBIENT, action, uintptr(i), 0, 0)
0000000000000000000000000000000000000000;;				// Ignore EINVAL as not supported on kernels before 4.3
0000000000000000000000000000000000000000;;				if errno, ok := err.(syscall.Errno); ok && errno == syscall.EINVAL {
0000000000000000000000000000000000000000;;					err = nil
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newFile(path string) (c Capabilities, err error) {
0000000000000000000000000000000000000000;;		c = &capsFile{path: path}
0000000000000000000000000000000000000000;;		err = c.Load()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type capsFile struct {
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;		data vfscapData
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Get(which CapType, what Cap) bool {
0000000000000000000000000000000000000000;;		var i uint
0000000000000000000000000000000000000000;;		if what > 31 {
0000000000000000000000000000000000000000;;			if c.data.version == 1 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = uint(what) >> 5
0000000000000000000000000000000000000000;;			what %= 32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch which {
0000000000000000000000000000000000000000;;		case EFFECTIVE:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data.effective[i] != 0
0000000000000000000000000000000000000000;;		case PERMITTED:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data.data[i].permitted != 0
0000000000000000000000000000000000000000;;		case INHERITABLE:
0000000000000000000000000000000000000000;;			return (1<<uint(what))&c.data.data[i].inheritable != 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) getData(which CapType, dest []uint32) {
0000000000000000000000000000000000000000;;		switch which {
0000000000000000000000000000000000000000;;		case EFFECTIVE:
0000000000000000000000000000000000000000;;			dest[0] = c.data.effective[0]
0000000000000000000000000000000000000000;;			dest[1] = c.data.effective[1]
0000000000000000000000000000000000000000;;		case PERMITTED:
0000000000000000000000000000000000000000;;			dest[0] = c.data.data[0].permitted
0000000000000000000000000000000000000000;;			dest[1] = c.data.data[1].permitted
0000000000000000000000000000000000000000;;		case INHERITABLE:
0000000000000000000000000000000000000000;;			dest[0] = c.data.data[0].inheritable
0000000000000000000000000000000000000000;;			dest[1] = c.data.data[1].inheritable
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Empty(which CapType) bool {
0000000000000000000000000000000000000000;;		var data [2]uint32
0000000000000000000000000000000000000000;;		c.getData(which, data[:])
0000000000000000000000000000000000000000;;		return data[0] == 0 && data[1] == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Full(which CapType) bool {
0000000000000000000000000000000000000000;;		var data [2]uint32
0000000000000000000000000000000000000000;;		c.getData(which, data[:])
0000000000000000000000000000000000000000;;		if c.data.version == 0 {
0000000000000000000000000000000000000000;;			return (data[0] & 0x7fffffff) == 0x7fffffff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (data[0] & 0xffffffff) != 0xffffffff {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (data[1] & capUpperMask) == capUpperMask
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Set(which CapType, caps ...Cap) {
0000000000000000000000000000000000000000;;		for _, what := range caps {
0000000000000000000000000000000000000000;;			var i uint
0000000000000000000000000000000000000000;;			if what > 31 {
0000000000000000000000000000000000000000;;				if c.data.version == 1 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i = uint(what) >> 5
0000000000000000000000000000000000000000;;				what %= 32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if which&EFFECTIVE != 0 {
0000000000000000000000000000000000000000;;				c.data.effective[i] |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&PERMITTED != 0 {
0000000000000000000000000000000000000000;;				c.data.data[i].permitted |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&INHERITABLE != 0 {
0000000000000000000000000000000000000000;;				c.data.data[i].inheritable |= 1 << uint(what)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Unset(which CapType, caps ...Cap) {
0000000000000000000000000000000000000000;;		for _, what := range caps {
0000000000000000000000000000000000000000;;			var i uint
0000000000000000000000000000000000000000;;			if what > 31 {
0000000000000000000000000000000000000000;;				if c.data.version == 1 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i = uint(what) >> 5
0000000000000000000000000000000000000000;;				what %= 32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if which&EFFECTIVE != 0 {
0000000000000000000000000000000000000000;;				c.data.effective[i] &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&PERMITTED != 0 {
0000000000000000000000000000000000000000;;				c.data.data[i].permitted &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if which&INHERITABLE != 0 {
0000000000000000000000000000000000000000;;				c.data.data[i].inheritable &= ^(1 << uint(what))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Fill(kind CapType) {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			c.data.effective[0] = 0xffffffff
0000000000000000000000000000000000000000;;			c.data.data[0].permitted = 0xffffffff
0000000000000000000000000000000000000000;;			c.data.data[0].inheritable = 0
0000000000000000000000000000000000000000;;			if c.data.version == 2 {
0000000000000000000000000000000000000000;;				c.data.effective[1] = 0xffffffff
0000000000000000000000000000000000000000;;				c.data.data[1].permitted = 0xffffffff
0000000000000000000000000000000000000000;;				c.data.data[1].inheritable = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Clear(kind CapType) {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			c.data.effective[0] = 0
0000000000000000000000000000000000000000;;			c.data.data[0].permitted = 0
0000000000000000000000000000000000000000;;			c.data.data[0].inheritable = 0
0000000000000000000000000000000000000000;;			if c.data.version == 2 {
0000000000000000000000000000000000000000;;				c.data.effective[1] = 0
0000000000000000000000000000000000000000;;				c.data.data[1].permitted = 0
0000000000000000000000000000000000000000;;				c.data.data[1].inheritable = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) StringCap(which CapType) (ret string) {
0000000000000000000000000000000000000000;;		return mkStringCap(c, which)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) String() (ret string) {
0000000000000000000000000000000000000000;;		return mkString(c, INHERITABLE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Load() (err error) {
0000000000000000000000000000000000000000;;		return getVfsCap(c.path, &c.data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *capsFile) Apply(kind CapType) (err error) {
0000000000000000000000000000000000000000;;		if kind&CAPS == CAPS {
0000000000000000000000000000000000000000;;			return setVfsCap(c.path, &c.data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
