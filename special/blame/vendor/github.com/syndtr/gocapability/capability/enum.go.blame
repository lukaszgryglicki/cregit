0000000000000000000000000000000000000000;;	// Copyright (c) 2013, Suryandaru Triandana <syndtr@gmail.com>
0000000000000000000000000000000000000000;;	// All rights reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style license that can be
0000000000000000000000000000000000000000;;	// found in the LICENSE file.
a32493865be4f7e35896c83bdc29fed7e53478df;Godeps/_workspace/src/github.com/syndtr/gocapability/capability/enum.go[Godeps/_workspace/src/github.com/syndtr/gocapability/capability/enum.go][vendor/github.com/syndtr/gocapability/capability/enum.go];	
0000000000000000000000000000000000000000;;	package capability
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CapType uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c CapType) String() string {
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case EFFECTIVE:
0000000000000000000000000000000000000000;;			return "effective"
0000000000000000000000000000000000000000;;		case PERMITTED:
0000000000000000000000000000000000000000;;			return "permitted"
0000000000000000000000000000000000000000;;		case INHERITABLE:
0000000000000000000000000000000000000000;;			return "inheritable"
0000000000000000000000000000000000000000;;		case BOUNDING:
0000000000000000000000000000000000000000;;			return "bounding"
0000000000000000000000000000000000000000;;		case CAPS:
0000000000000000000000000000000000000000;;			return "caps"
0000000000000000000000000000000000000000;;		case AMBIENT:
0000000000000000000000000000000000000000;;			return "ambient"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "unknown"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EFFECTIVE CapType = 1 << iota
0000000000000000000000000000000000000000;;		PERMITTED
0000000000000000000000000000000000000000;;		INHERITABLE
0000000000000000000000000000000000000000;;		BOUNDING
0000000000000000000000000000000000000000;;		AMBIENT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CAPS   = EFFECTIVE | PERMITTED | INHERITABLE
0000000000000000000000000000000000000000;;		BOUNDS = BOUNDING
0000000000000000000000000000000000000000;;		AMBS   = AMBIENT
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:generate go run enumgen/gen.go
0000000000000000000000000000000000000000;;	type Cap int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// POSIX-draft defined capabilities.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// In a system with the [_POSIX_CHOWN_RESTRICTED] option defined, this
0000000000000000000000000000000000000000;;		// overrides the restriction of changing file ownership and group
0000000000000000000000000000000000000000;;		// ownership.
0000000000000000000000000000000000000000;;		CAP_CHOWN = Cap(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override all DAC access, including ACL execute access if
0000000000000000000000000000000000000000;;		// [_POSIX_ACL] is defined. Excluding DAC access covered by
0000000000000000000000000000000000000000;;		// CAP_LINUX_IMMUTABLE.
0000000000000000000000000000000000000000;;		CAP_DAC_OVERRIDE = Cap(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Overrides all DAC restrictions regarding read and search on files
0000000000000000000000000000000000000000;;		// and directories, including ACL restrictions if [_POSIX_ACL] is
0000000000000000000000000000000000000000;;		// defined. Excluding DAC access covered by CAP_LINUX_IMMUTABLE.
0000000000000000000000000000000000000000;;		CAP_DAC_READ_SEARCH = Cap(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Overrides all restrictions about allowed operations on files, where
0000000000000000000000000000000000000000;;		// file owner ID must be equal to the user ID, except where CAP_FSETID
0000000000000000000000000000000000000000;;		// is applicable. It doesn't override MAC and DAC restrictions.
0000000000000000000000000000000000000000;;		CAP_FOWNER = Cap(3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Overrides the following restrictions that the effective user ID
0000000000000000000000000000000000000000;;		// shall match the file owner ID when setting the S_ISUID and S_ISGID
0000000000000000000000000000000000000000;;		// bits on that file; that the effective group ID (or one of the
0000000000000000000000000000000000000000;;		// supplementary group IDs) shall match the file owner ID when setting
0000000000000000000000000000000000000000;;		// the S_ISGID bit on that file; that the S_ISUID and S_ISGID bits are
0000000000000000000000000000000000000000;;		// cleared on successful return from chown(2) (not implemented).
0000000000000000000000000000000000000000;;		CAP_FSETID = Cap(4)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Overrides the restriction that the real or effective user ID of a
0000000000000000000000000000000000000000;;		// process sending a signal must match the real or effective user ID
0000000000000000000000000000000000000000;;		// of the process receiving the signal.
0000000000000000000000000000000000000000;;		CAP_KILL = Cap(5)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allows setgid(2) manipulation
0000000000000000000000000000000000000000;;		// Allows setgroups(2)
0000000000000000000000000000000000000000;;		// Allows forged gids on socket credentials passing.
0000000000000000000000000000000000000000;;		CAP_SETGID = Cap(6)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allows set*uid(2) manipulation (including fsuid).
0000000000000000000000000000000000000000;;		// Allows forged pids on socket credentials passing.
0000000000000000000000000000000000000000;;		CAP_SETUID = Cap(7)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Linux-specific capabilities
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Without VFS support for capabilities:
0000000000000000000000000000000000000000;;		//   Transfer any capability in your permitted set to any pid,
0000000000000000000000000000000000000000;;		//   remove any capability in your permitted set from any pid
0000000000000000000000000000000000000000;;		// With VFS support for capabilities (neither of above, but)
0000000000000000000000000000000000000000;;		//   Add any capability from current's capability bounding set
0000000000000000000000000000000000000000;;		//     to the current process' inheritable set
0000000000000000000000000000000000000000;;		//   Allow taking bits out of capability bounding set
0000000000000000000000000000000000000000;;		//   Allow modification of the securebits for a process
0000000000000000000000000000000000000000;;		CAP_SETPCAP = Cap(8)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow modification of S_IMMUTABLE and S_APPEND file attributes
0000000000000000000000000000000000000000;;		CAP_LINUX_IMMUTABLE = Cap(9)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allows binding to TCP/UDP sockets below 1024
0000000000000000000000000000000000000000;;		// Allows binding to ATM VCIs below 32
0000000000000000000000000000000000000000;;		CAP_NET_BIND_SERVICE = Cap(10)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow broadcasting, listen to multicast
0000000000000000000000000000000000000000;;		CAP_NET_BROADCAST = Cap(11)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow interface configuration
0000000000000000000000000000000000000000;;		// Allow administration of IP firewall, masquerading and accounting
0000000000000000000000000000000000000000;;		// Allow setting debug option on sockets
0000000000000000000000000000000000000000;;		// Allow modification of routing tables
0000000000000000000000000000000000000000;;		// Allow setting arbitrary process / process group ownership on
0000000000000000000000000000000000000000;;		// sockets
0000000000000000000000000000000000000000;;		// Allow binding to any address for transparent proxying (also via NET_RAW)
0000000000000000000000000000000000000000;;		// Allow setting TOS (type of service)
0000000000000000000000000000000000000000;;		// Allow setting promiscuous mode
0000000000000000000000000000000000000000;;		// Allow clearing driver statistics
0000000000000000000000000000000000000000;;		// Allow multicasting
0000000000000000000000000000000000000000;;		// Allow read/write of device-specific registers
0000000000000000000000000000000000000000;;		// Allow activation of ATM control sockets
0000000000000000000000000000000000000000;;		CAP_NET_ADMIN = Cap(12)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow use of RAW sockets
0000000000000000000000000000000000000000;;		// Allow use of PACKET sockets
0000000000000000000000000000000000000000;;		// Allow binding to any address for transparent proxying (also via NET_ADMIN)
0000000000000000000000000000000000000000;;		CAP_NET_RAW = Cap(13)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow locking of shared memory segments
0000000000000000000000000000000000000000;;		// Allow mlock and mlockall (which doesn't really have anything to do
0000000000000000000000000000000000000000;;		// with IPC)
0000000000000000000000000000000000000000;;		CAP_IPC_LOCK = Cap(14)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override IPC ownership checks
0000000000000000000000000000000000000000;;		CAP_IPC_OWNER = Cap(15)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Insert and remove kernel modules - modify kernel without limit
0000000000000000000000000000000000000000;;		CAP_SYS_MODULE = Cap(16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow ioperm/iopl access
0000000000000000000000000000000000000000;;		// Allow sending USB messages to any device via /proc/bus/usb
0000000000000000000000000000000000000000;;		CAP_SYS_RAWIO = Cap(17)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow use of chroot()
0000000000000000000000000000000000000000;;		CAP_SYS_CHROOT = Cap(18)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow ptrace() of any process
0000000000000000000000000000000000000000;;		CAP_SYS_PTRACE = Cap(19)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow configuration of process accounting
0000000000000000000000000000000000000000;;		CAP_SYS_PACCT = Cap(20)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow configuration of the secure attention key
0000000000000000000000000000000000000000;;		// Allow administration of the random device
0000000000000000000000000000000000000000;;		// Allow examination and configuration of disk quotas
0000000000000000000000000000000000000000;;		// Allow setting the domainname
0000000000000000000000000000000000000000;;		// Allow setting the hostname
0000000000000000000000000000000000000000;;		// Allow calling bdflush()
0000000000000000000000000000000000000000;;		// Allow mount() and umount(), setting up new smb connection
0000000000000000000000000000000000000000;;		// Allow some autofs root ioctls
0000000000000000000000000000000000000000;;		// Allow nfsservctl
0000000000000000000000000000000000000000;;		// Allow VM86_REQUEST_IRQ
0000000000000000000000000000000000000000;;		// Allow to read/write pci config on alpha
0000000000000000000000000000000000000000;;		// Allow irix_prctl on mips (setstacksize)
0000000000000000000000000000000000000000;;		// Allow flushing all cache on m68k (sys_cacheflush)
0000000000000000000000000000000000000000;;		// Allow removing semaphores
0000000000000000000000000000000000000000;;		// Used instead of CAP_CHOWN to "chown" IPC message queues, semaphores
0000000000000000000000000000000000000000;;		// and shared memory
0000000000000000000000000000000000000000;;		// Allow locking/unlocking of shared memory segment
0000000000000000000000000000000000000000;;		// Allow turning swap on/off
0000000000000000000000000000000000000000;;		// Allow forged pids on socket credentials passing
0000000000000000000000000000000000000000;;		// Allow setting readahead and flushing buffers on block devices
0000000000000000000000000000000000000000;;		// Allow setting geometry in floppy driver
0000000000000000000000000000000000000000;;		// Allow turning DMA on/off in xd driver
0000000000000000000000000000000000000000;;		// Allow administration of md devices (mostly the above, but some
0000000000000000000000000000000000000000;;		// extra ioctls)
0000000000000000000000000000000000000000;;		// Allow tuning the ide driver
0000000000000000000000000000000000000000;;		// Allow access to the nvram device
0000000000000000000000000000000000000000;;		// Allow administration of apm_bios, serial and bttv (TV) device
0000000000000000000000000000000000000000;;		// Allow manufacturer commands in isdn CAPI support driver
0000000000000000000000000000000000000000;;		// Allow reading non-standardized portions of pci configuration space
0000000000000000000000000000000000000000;;		// Allow DDI debug ioctl on sbpcd driver
0000000000000000000000000000000000000000;;		// Allow setting up serial ports
0000000000000000000000000000000000000000;;		// Allow sending raw qic-117 commands
0000000000000000000000000000000000000000;;		// Allow enabling/disabling tagged queuing on SCSI controllers and sending
0000000000000000000000000000000000000000;;		// arbitrary SCSI commands
0000000000000000000000000000000000000000;;		// Allow setting encryption key on loopback filesystem
0000000000000000000000000000000000000000;;		// Allow setting zone reclaim policy
0000000000000000000000000000000000000000;;		CAP_SYS_ADMIN = Cap(21)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow use of reboot()
0000000000000000000000000000000000000000;;		CAP_SYS_BOOT = Cap(22)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow raising priority and setting priority on other (different
0000000000000000000000000000000000000000;;		// UID) processes
0000000000000000000000000000000000000000;;		// Allow use of FIFO and round-robin (realtime) scheduling on own
0000000000000000000000000000000000000000;;		// processes and setting the scheduling algorithm used by another
0000000000000000000000000000000000000000;;		// process.
0000000000000000000000000000000000000000;;		// Allow setting cpu affinity on other processes
0000000000000000000000000000000000000000;;		CAP_SYS_NICE = Cap(23)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override resource limits. Set resource limits.
0000000000000000000000000000000000000000;;		// Override quota limits.
0000000000000000000000000000000000000000;;		// Override reserved space on ext2 filesystem
0000000000000000000000000000000000000000;;		// Modify data journaling mode on ext3 filesystem (uses journaling
0000000000000000000000000000000000000000;;		// resources)
0000000000000000000000000000000000000000;;		// NOTE: ext2 honors fsuid when checking for resource overrides, so
0000000000000000000000000000000000000000;;		// you can override using fsuid too
0000000000000000000000000000000000000000;;		// Override size restrictions on IPC message queues
0000000000000000000000000000000000000000;;		// Allow more than 64hz interrupts from the real-time clock
0000000000000000000000000000000000000000;;		// Override max number of consoles on console allocation
0000000000000000000000000000000000000000;;		// Override max number of keymaps
0000000000000000000000000000000000000000;;		CAP_SYS_RESOURCE = Cap(24)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow manipulation of system clock
0000000000000000000000000000000000000000;;		// Allow irix_stime on mips
0000000000000000000000000000000000000000;;		// Allow setting the real-time clock
0000000000000000000000000000000000000000;;		CAP_SYS_TIME = Cap(25)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow configuration of tty devices
0000000000000000000000000000000000000000;;		// Allow vhangup() of tty
0000000000000000000000000000000000000000;;		CAP_SYS_TTY_CONFIG = Cap(26)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow the privileged aspects of mknod()
0000000000000000000000000000000000000000;;		CAP_MKNOD = Cap(27)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow taking of leases on files
0000000000000000000000000000000000000000;;		CAP_LEASE = Cap(28)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CAP_AUDIT_WRITE   = Cap(29)
0000000000000000000000000000000000000000;;		CAP_AUDIT_CONTROL = Cap(30)
0000000000000000000000000000000000000000;;		CAP_SETFCAP       = Cap(31)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Override MAC access.
0000000000000000000000000000000000000000;;		// The base kernel enforces no MAC policy.
0000000000000000000000000000000000000000;;		// An LSM may enforce a MAC policy, and if it does and it chooses
0000000000000000000000000000000000000000;;		// to implement capability based overrides of that policy, this is
0000000000000000000000000000000000000000;;		// the capability it should use to do so.
0000000000000000000000000000000000000000;;		CAP_MAC_OVERRIDE = Cap(32)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow MAC configuration or state changes.
0000000000000000000000000000000000000000;;		// The base kernel requires no MAC configuration.
0000000000000000000000000000000000000000;;		// An LSM may enforce a MAC policy, and if it does and it chooses
0000000000000000000000000000000000000000;;		// to implement capability based checks on modifications to that
0000000000000000000000000000000000000000;;		// policy or the data required to maintain it, this is the
0000000000000000000000000000000000000000;;		// capability it should use to do so.
0000000000000000000000000000000000000000;;		CAP_MAC_ADMIN = Cap(33)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow configuring the kernel's syslog (printk behaviour)
0000000000000000000000000000000000000000;;		CAP_SYSLOG = Cap(34)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow triggering something that will wake the system
0000000000000000000000000000000000000000;;		CAP_WAKE_ALARM = Cap(35)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow preventing system suspends
0000000000000000000000000000000000000000;;		CAP_BLOCK_SUSPEND = Cap(36)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allow reading audit messages from the kernel
0000000000000000000000000000000000000000;;		CAP_AUDIT_READ = Cap(37)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Highest valid capability of the running kernel.
0000000000000000000000000000000000000000;;		CAP_LAST_CAP = Cap(63)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		capUpperMask = ^uint32(0)
0000000000000000000000000000000000000000;;	)
