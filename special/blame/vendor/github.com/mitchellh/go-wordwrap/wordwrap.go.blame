0000000000000000000000000000000000000000;;	package wordwrap
d724170bb0095021f4df9eadcf86507140d2409c;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WrapString wraps the given string within lim width in characters.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Wrapping is currently naive and only happens at white-space. A future
0000000000000000000000000000000000000000;;	// version of the library will implement smarter wrapping. This means that
0000000000000000000000000000000000000000;;	// pathological cases can dramatically reach past the limit, such as a very
0000000000000000000000000000000000000000;;	// long word.
0000000000000000000000000000000000000000;;	func WrapString(s string, lim uint) string {
0000000000000000000000000000000000000000;;		// Initialize a buffer with a slightly larger size to account for breaks
0000000000000000000000000000000000000000;;		init := make([]byte, 0, len(s))
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(init)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var current uint
0000000000000000000000000000000000000000;;		var wordBuf, spaceBuf bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, char := range s {
0000000000000000000000000000000000000000;;			if char == '\n' {
0000000000000000000000000000000000000000;;				if wordBuf.Len() == 0 {
0000000000000000000000000000000000000000;;					if current+uint(spaceBuf.Len()) > lim {
0000000000000000000000000000000000000000;;						current = 0
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						current += uint(spaceBuf.Len())
0000000000000000000000000000000000000000;;						spaceBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					spaceBuf.Reset()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					current += uint(spaceBuf.Len() + wordBuf.Len())
0000000000000000000000000000000000000000;;					spaceBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;					spaceBuf.Reset()
0000000000000000000000000000000000000000;;					wordBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;					wordBuf.Reset()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buf.WriteRune(char)
0000000000000000000000000000000000000000;;				current = 0
0000000000000000000000000000000000000000;;			} else if unicode.IsSpace(char) {
0000000000000000000000000000000000000000;;				if spaceBuf.Len() == 0 || wordBuf.Len() > 0 {
0000000000000000000000000000000000000000;;					current += uint(spaceBuf.Len() + wordBuf.Len())
0000000000000000000000000000000000000000;;					spaceBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;					spaceBuf.Reset()
0000000000000000000000000000000000000000;;					wordBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;					wordBuf.Reset()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				spaceBuf.WriteRune(char)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				wordBuf.WriteRune(char)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if current+uint(spaceBuf.Len()+wordBuf.Len()) > lim && uint(wordBuf.Len()) < lim {
0000000000000000000000000000000000000000;;					buf.WriteRune('\n')
0000000000000000000000000000000000000000;;					current = 0
0000000000000000000000000000000000000000;;					spaceBuf.Reset()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if wordBuf.Len() == 0 {
0000000000000000000000000000000000000000;;			if current+uint(spaceBuf.Len()) <= lim {
0000000000000000000000000000000000000000;;				spaceBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			spaceBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;			wordBuf.WriteTo(buf)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
