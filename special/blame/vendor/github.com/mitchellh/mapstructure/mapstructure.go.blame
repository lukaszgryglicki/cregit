0000000000000000000000000000000000000000;;	// The mapstructure package exposes functionality to convert an
0000000000000000000000000000000000000000;;	// arbitrary map[string]interface{} into a native Go structure.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Go structure can be arbitrarily complex, containing slices,
0000000000000000000000000000000000000000;;	// other structs, etc. and the decoder will properly decode nested
0000000000000000000000000000000000000000;;	// maps and so on into the proper structures in the native Go struct.
0000000000000000000000000000000000000000;;	// See the examples to see what the decoder is capable of.
0000000000000000000000000000000000000000;;	package mapstructure
5ee9c53e7b694ff752a75066a2192058fc5b79ef;Godeps/_workspace/src/github.com/mitchellh/mapstructure/mapstructure.go[Godeps/_workspace/src/github.com/mitchellh/mapstructure/mapstructure.go][vendor/github.com/mitchellh/mapstructure/mapstructure.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeHookFunc is the callback function that can be used for
0000000000000000000000000000000000000000;;	// data transformations. See "DecodeHook" in the DecoderConfig
0000000000000000000000000000000000000000;;	// struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The type should be DecodeHookFuncType or DecodeHookFuncKind.
0000000000000000000000000000000000000000;;	// Either is accepted. Types are a superset of Kinds (Types can return
0000000000000000000000000000000000000000;;	// Kinds) and are generally a richer thing to use, but Kinds are simpler
0000000000000000000000000000000000000000;;	// if you only need those.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The reason DecodeHookFunc is multi-typed is for backwards compatibility:
0000000000000000000000000000000000000000;;	// we started with Kinds and then realized Types were the better solution,
0000000000000000000000000000000000000000;;	// but have a promise to not break backwards compat so we now support
0000000000000000000000000000000000000000;;	// both.
0000000000000000000000000000000000000000;;	type DecodeHookFunc interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DecodeHookFuncType func(reflect.Type, reflect.Type, interface{}) (interface{}, error)
0000000000000000000000000000000000000000;;	type DecodeHookFuncKind func(reflect.Kind, reflect.Kind, interface{}) (interface{}, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecoderConfig is the configuration that is used to create a new decoder
0000000000000000000000000000000000000000;;	// and allows customization of various aspects of decoding.
0000000000000000000000000000000000000000;;	type DecoderConfig struct {
0000000000000000000000000000000000000000;;		// DecodeHook, if set, will be called before any decoding and any
0000000000000000000000000000000000000000;;		// type conversion (if WeaklyTypedInput is on). This lets you modify
0000000000000000000000000000000000000000;;		// the values before they're set down onto the resulting struct.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// If an error is returned, the entire decode will fail with that
0000000000000000000000000000000000000000;;		// error.
0000000000000000000000000000000000000000;;		DecodeHook DecodeHookFunc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If ErrorUnused is true, then it is an error for there to exist
0000000000000000000000000000000000000000;;		// keys in the original map that were unused in the decoding process
0000000000000000000000000000000000000000;;		// (extra keys).
0000000000000000000000000000000000000000;;		ErrorUnused bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ZeroFields, if set to true, will zero fields before writing them.
0000000000000000000000000000000000000000;;		// For example, a map will be emptied before decoded values are put in
0000000000000000000000000000000000000000;;		// it. If this is false, a map will be merged.
0000000000000000000000000000000000000000;;		ZeroFields bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If WeaklyTypedInput is true, the decoder will make the following
0000000000000000000000000000000000000000;;		// "weak" conversions:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//   - bools to string (true = "1", false = "0")
0000000000000000000000000000000000000000;;		//   - numbers to string (base 10)
0000000000000000000000000000000000000000;;		//   - bools to int/uint (true = 1, false = 0)
0000000000000000000000000000000000000000;;		//   - strings to int/uint (base implied by prefix)
0000000000000000000000000000000000000000;;		//   - int to bool (true if value != 0)
0000000000000000000000000000000000000000;;		//   - string to bool (accepts: 1, t, T, TRUE, true, True, 0, f, F,
0000000000000000000000000000000000000000;;		//     FALSE, false, False. Anything else is an error)
0000000000000000000000000000000000000000;;		//   - empty array = empty map and vice versa
0000000000000000000000000000000000000000;;		//   - negative numbers to overflowed uint values (base 10)
0000000000000000000000000000000000000000;;		//   - slice of maps to a merged map
0000000000000000000000000000000000000000;;		//   - single values are converted to slices if required. Each
0000000000000000000000000000000000000000;;		//     element is weakly decoded. For example: "4" can become []int{4}
0000000000000000000000000000000000000000;;		//     if the target type is an int slice.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		WeaklyTypedInput bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata is the struct that will contain extra metadata about
0000000000000000000000000000000000000000;;		// the decoding. If this is nil, then no metadata will be tracked.
0000000000000000000000000000000000000000;;		Metadata *Metadata
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Result is a pointer to the struct that will contain the decoded
0000000000000000000000000000000000000000;;		// value.
0000000000000000000000000000000000000000;;		Result interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The tag name that mapstructure reads for field names. This
0000000000000000000000000000000000000000;;		// defaults to "mapstructure"
0000000000000000000000000000000000000000;;		TagName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Decoder takes a raw interface value and turns it into structured
0000000000000000000000000000000000000000;;	// data, keeping track of rich error information along the way in case
0000000000000000000000000000000000000000;;	// anything goes wrong. Unlike the basic top-level Decode method, you can
0000000000000000000000000000000000000000;;	// more finely control how the Decoder behaves using the DecoderConfig
0000000000000000000000000000000000000000;;	// structure. The top-level Decode method is just a convenience that sets
0000000000000000000000000000000000000000;;	// up the most basic Decoder.
0000000000000000000000000000000000000000;;	type Decoder struct {
0000000000000000000000000000000000000000;;		config *DecoderConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Metadata contains information about decoding a structure that
0000000000000000000000000000000000000000;;	// is tedious or difficult to get otherwise.
0000000000000000000000000000000000000000;;	type Metadata struct {
0000000000000000000000000000000000000000;;		// Keys are the keys of the structure which were successfully decoded
0000000000000000000000000000000000000000;;		Keys []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unused is a slice of keys that were found in the raw value but
0000000000000000000000000000000000000000;;		// weren't decoded since there was no matching field in the result interface
0000000000000000000000000000000000000000;;		Unused []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode takes a map and uses reflection to convert it into the
0000000000000000000000000000000000000000;;	// given Go native structure. val must be a pointer to a struct.
0000000000000000000000000000000000000000;;	func Decode(m interface{}, rawVal interface{}) error {
0000000000000000000000000000000000000000;;		config := &DecoderConfig{
0000000000000000000000000000000000000000;;			Metadata: nil,
0000000000000000000000000000000000000000;;			Result:   rawVal,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder, err := NewDecoder(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return decoder.Decode(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WeakDecode is the same as Decode but is shorthand to enable
0000000000000000000000000000000000000000;;	// WeaklyTypedInput. See DecoderConfig for more info.
0000000000000000000000000000000000000000;;	func WeakDecode(input, output interface{}) error {
0000000000000000000000000000000000000000;;		config := &DecoderConfig{
0000000000000000000000000000000000000000;;			Metadata:         nil,
0000000000000000000000000000000000000000;;			Result:           output,
0000000000000000000000000000000000000000;;			WeaklyTypedInput: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		decoder, err := NewDecoder(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return decoder.Decode(input)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDecoder returns a new decoder for the given configuration. Once
0000000000000000000000000000000000000000;;	// a decoder has been returned, the same configuration must not be used
0000000000000000000000000000000000000000;;	// again.
0000000000000000000000000000000000000000;;	func NewDecoder(config *DecoderConfig) (*Decoder, error) {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(config.Result)
0000000000000000000000000000000000000000;;		if val.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return nil, errors.New("result must be a pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val = val.Elem()
0000000000000000000000000000000000000000;;		if !val.CanAddr() {
0000000000000000000000000000000000000000;;			return nil, errors.New("result must be addressable (a pointer)")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.Metadata != nil {
0000000000000000000000000000000000000000;;			if config.Metadata.Keys == nil {
0000000000000000000000000000000000000000;;				config.Metadata.Keys = make([]string, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if config.Metadata.Unused == nil {
0000000000000000000000000000000000000000;;				config.Metadata.Unused = make([]string, 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if config.TagName == "" {
0000000000000000000000000000000000000000;;			config.TagName = "mapstructure"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := &Decoder{
0000000000000000000000000000000000000000;;			config: config,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode decodes the given raw interface to the target pointer specified
0000000000000000000000000000000000000000;;	// by the configuration.
0000000000000000000000000000000000000000;;	func (d *Decoder) Decode(raw interface{}) error {
0000000000000000000000000000000000000000;;		return d.decode("", raw, reflect.ValueOf(d.config.Result).Elem())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decodes an unknown data type into a specific reflection value.
0000000000000000000000000000000000000000;;	func (d *Decoder) decode(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			// If the data is nil, then we don't set anything.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		if !dataVal.IsValid() {
0000000000000000000000000000000000000000;;			// If the data value is invalid, then we just set the value
0000000000000000000000000000000000000000;;			// to be the zero value.
0000000000000000000000000000000000000000;;			val.Set(reflect.Zero(val.Type()))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.config.DecodeHook != nil {
0000000000000000000000000000000000000000;;			// We have a DecodeHook, so let's pre-process the data.
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			data, err = DecodeHookExec(
0000000000000000000000000000000000000000;;				d.config.DecodeHook,
0000000000000000000000000000000000000000;;				dataVal.Type(), val.Type(), data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error decoding '%s': %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		dataKind := getKind(val)
0000000000000000000000000000000000000000;;		switch dataKind {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			err = d.decodeBool(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			err = d.decodeBasic(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			err = d.decodeString(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Int:
0000000000000000000000000000000000000000;;			err = d.decodeInt(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Uint:
0000000000000000000000000000000000000000;;			err = d.decodeUint(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Float32:
0000000000000000000000000000000000000000;;			err = d.decodeFloat(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			err = d.decodeStruct(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			err = d.decodeMap(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			err = d.decodePtr(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			err = d.decodeSlice(name, data, val)
0000000000000000000000000000000000000000;;		case reflect.Func:
0000000000000000000000000000000000000000;;			err = d.decodeFunc(name, data, val)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// If we reached this point then we weren't able to decode it
0000000000000000000000000000000000000000;;			return fmt.Errorf("%s: unsupported type: %s", name, dataKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we reached here, then we successfully decoded SOMETHING, so
0000000000000000000000000000000000000000;;		// mark the key as used if we're tracking metadata.
0000000000000000000000000000000000000000;;		if d.config.Metadata != nil && name != "" {
0000000000000000000000000000000000000000;;			d.config.Metadata.Keys = append(d.config.Metadata.Keys, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This decodes a basic type (bool, int, string, etc.) and sets the
0000000000000000000000000000000000000000;;	// value to "data" of that type.
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeBasic(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		if !dataVal.IsValid() {
0000000000000000000000000000000000000000;;			dataVal = reflect.Zero(val.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataValType := dataVal.Type()
0000000000000000000000000000000000000000;;		if !dataValType.AssignableTo(val.Type()) {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' expected type '%s', got '%s'",
0000000000000000000000000000000000000000;;				name, val.Type(), dataValType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val.Set(dataVal)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeString(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		dataKind := getKind(dataVal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		converted := true
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case dataKind == reflect.String:
0000000000000000000000000000000000000000;;			val.SetString(dataVal.String())
0000000000000000000000000000000000000000;;		case dataKind == reflect.Bool && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			if dataVal.Bool() {
0000000000000000000000000000000000000000;;				val.SetString("1")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				val.SetString("0")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case dataKind == reflect.Int && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			val.SetString(strconv.FormatInt(dataVal.Int(), 10))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Uint && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			val.SetString(strconv.FormatUint(dataVal.Uint(), 10))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Float32 && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			val.SetString(strconv.FormatFloat(dataVal.Float(), 'f', -1, 64))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Slice && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			dataType := dataVal.Type()
0000000000000000000000000000000000000000;;			elemKind := dataType.Elem().Kind()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case elemKind == reflect.Uint8:
0000000000000000000000000000000000000000;;				val.SetString(string(dataVal.Interface().([]uint8)))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				converted = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			converted = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !converted {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' expected type '%s', got unconvertible type '%s'",
0000000000000000000000000000000000000000;;				name, val.Type(), dataVal.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeInt(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		dataKind := getKind(dataVal)
0000000000000000000000000000000000000000;;		dataType := dataVal.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case dataKind == reflect.Int:
0000000000000000000000000000000000000000;;			val.SetInt(dataVal.Int())
0000000000000000000000000000000000000000;;		case dataKind == reflect.Uint:
0000000000000000000000000000000000000000;;			val.SetInt(int64(dataVal.Uint()))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Float32:
0000000000000000000000000000000000000000;;			val.SetInt(int64(dataVal.Float()))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Bool && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			if dataVal.Bool() {
0000000000000000000000000000000000000000;;				val.SetInt(1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				val.SetInt(0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case dataKind == reflect.String && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			i, err := strconv.ParseInt(dataVal.String(), 0, val.Type().Bits())
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				val.SetInt(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot parse '%s' as int: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case dataType.PkgPath() == "encoding/json" && dataType.Name() == "Number":
0000000000000000000000000000000000000000;;			jn := data.(json.Number)
0000000000000000000000000000000000000000;;			i, err := jn.Int64()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"error decoding json.Number into %s: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val.SetInt(i)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' expected type '%s', got unconvertible type '%s'",
0000000000000000000000000000000000000000;;				name, val.Type(), dataVal.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeUint(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		dataKind := getKind(dataVal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case dataKind == reflect.Int:
0000000000000000000000000000000000000000;;			i := dataVal.Int()
0000000000000000000000000000000000000000;;			if i < 0 && !d.config.WeaklyTypedInput {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot parse '%s', %d overflows uint",
0000000000000000000000000000000000000000;;					name, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val.SetUint(uint64(i))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Uint:
0000000000000000000000000000000000000000;;			val.SetUint(dataVal.Uint())
0000000000000000000000000000000000000000;;		case dataKind == reflect.Float32:
0000000000000000000000000000000000000000;;			f := dataVal.Float()
0000000000000000000000000000000000000000;;			if f < 0 && !d.config.WeaklyTypedInput {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot parse '%s', %f overflows uint",
0000000000000000000000000000000000000000;;					name, f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val.SetUint(uint64(f))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Bool && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			if dataVal.Bool() {
0000000000000000000000000000000000000000;;				val.SetUint(1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				val.SetUint(0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case dataKind == reflect.String && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			i, err := strconv.ParseUint(dataVal.String(), 0, val.Type().Bits())
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				val.SetUint(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot parse '%s' as uint: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' expected type '%s', got unconvertible type '%s'",
0000000000000000000000000000000000000000;;				name, val.Type(), dataVal.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeBool(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		dataKind := getKind(dataVal)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case dataKind == reflect.Bool:
0000000000000000000000000000000000000000;;			val.SetBool(dataVal.Bool())
0000000000000000000000000000000000000000;;		case dataKind == reflect.Int && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			val.SetBool(dataVal.Int() != 0)
0000000000000000000000000000000000000000;;		case dataKind == reflect.Uint && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			val.SetBool(dataVal.Uint() != 0)
0000000000000000000000000000000000000000;;		case dataKind == reflect.Float32 && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			val.SetBool(dataVal.Float() != 0)
0000000000000000000000000000000000000000;;		case dataKind == reflect.String && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			b, err := strconv.ParseBool(dataVal.String())
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				val.SetBool(b)
0000000000000000000000000000000000000000;;			} else if dataVal.String() == "" {
0000000000000000000000000000000000000000;;				val.SetBool(false)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot parse '%s' as bool: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' expected type '%s', got unconvertible type '%s'",
0000000000000000000000000000000000000000;;				name, val.Type(), dataVal.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeFloat(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		dataKind := getKind(dataVal)
0000000000000000000000000000000000000000;;		dataType := dataVal.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case dataKind == reflect.Int:
0000000000000000000000000000000000000000;;			val.SetFloat(float64(dataVal.Int()))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Uint:
0000000000000000000000000000000000000000;;			val.SetFloat(float64(dataVal.Uint()))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Float32:
0000000000000000000000000000000000000000;;			val.SetFloat(float64(dataVal.Float()))
0000000000000000000000000000000000000000;;		case dataKind == reflect.Bool && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			if dataVal.Bool() {
0000000000000000000000000000000000000000;;				val.SetFloat(1)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				val.SetFloat(0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case dataKind == reflect.String && d.config.WeaklyTypedInput:
0000000000000000000000000000000000000000;;			f, err := strconv.ParseFloat(dataVal.String(), val.Type().Bits())
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				val.SetFloat(f)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot parse '%s' as float: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case dataType.PkgPath() == "encoding/json" && dataType.Name() == "Number":
0000000000000000000000000000000000000000;;			jn := data.(json.Number)
0000000000000000000000000000000000000000;;			i, err := jn.Float64()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"error decoding json.Number into %s: %s", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val.SetFloat(i)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' expected type '%s', got unconvertible type '%s'",
0000000000000000000000000000000000000000;;				name, val.Type(), dataVal.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeMap(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		valType := val.Type()
0000000000000000000000000000000000000000;;		valKeyType := valType.Key()
0000000000000000000000000000000000000000;;		valElemType := valType.Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// By default we overwrite keys in the current map
0000000000000000000000000000000000000000;;		valMap := val
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the map is nil or we're purposely zeroing fields, make a new map
0000000000000000000000000000000000000000;;		if valMap.IsNil() || d.config.ZeroFields {
0000000000000000000000000000000000000000;;			// Make a new map to hold our result
0000000000000000000000000000000000000000;;			mapType := reflect.MapOf(valKeyType, valElemType)
0000000000000000000000000000000000000000;;			valMap = reflect.MakeMap(mapType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check input type
0000000000000000000000000000000000000000;;		dataVal := reflect.Indirect(reflect.ValueOf(data))
0000000000000000000000000000000000000000;;		if dataVal.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			// In weak mode, we accept a slice of maps as an input...
0000000000000000000000000000000000000000;;			if d.config.WeaklyTypedInput {
0000000000000000000000000000000000000000;;				switch dataVal.Kind() {
0000000000000000000000000000000000000000;;				case reflect.Array, reflect.Slice:
0000000000000000000000000000000000000000;;					// Special case for BC reasons (covered by tests)
0000000000000000000000000000000000000000;;					if dataVal.Len() == 0 {
0000000000000000000000000000000000000000;;						val.Set(valMap)
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for i := 0; i < dataVal.Len(); i++ {
0000000000000000000000000000000000000000;;						err := d.decode(
0000000000000000000000000000000000000000;;							fmt.Sprintf("%s[%d]", name, i),
0000000000000000000000000000000000000000;;							dataVal.Index(i).Interface(), val)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Errorf("'%s' expected a map, got '%s'", name, dataVal.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Accumulate errors
0000000000000000000000000000000000000000;;		errors := make([]string, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, k := range dataVal.MapKeys() {
0000000000000000000000000000000000000000;;			fieldName := fmt.Sprintf("%s[%s]", name, k)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// First decode the key into the proper type
0000000000000000000000000000000000000000;;			currentKey := reflect.Indirect(reflect.New(valKeyType))
0000000000000000000000000000000000000000;;			if err := d.decode(fieldName, k.Interface(), currentKey); err != nil {
0000000000000000000000000000000000000000;;				errors = appendErrors(errors, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Next decode the data into the proper type
0000000000000000000000000000000000000000;;			v := dataVal.MapIndex(k).Interface()
0000000000000000000000000000000000000000;;			currentVal := reflect.Indirect(reflect.New(valElemType))
0000000000000000000000000000000000000000;;			if err := d.decode(fieldName, v, currentVal); err != nil {
0000000000000000000000000000000000000000;;				errors = appendErrors(errors, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			valMap.SetMapIndex(currentKey, currentVal)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the built up map to the value
0000000000000000000000000000000000000000;;		val.Set(valMap)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we had errors, return those
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			return &Error{errors}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodePtr(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		// Create an element of the concrete (non pointer) type and decode
0000000000000000000000000000000000000000;;		// into that. Then set the value of the pointer to this type.
0000000000000000000000000000000000000000;;		valType := val.Type()
0000000000000000000000000000000000000000;;		valElemType := valType.Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		realVal := val
0000000000000000000000000000000000000000;;		if realVal.IsNil() || d.config.ZeroFields {
0000000000000000000000000000000000000000;;			realVal = reflect.New(valElemType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := d.decode(name, data, reflect.Indirect(realVal)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val.Set(realVal)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeFunc(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		// Create an element of the concrete (non pointer) type and decode
0000000000000000000000000000000000000000;;		// into that. Then set the value of the pointer to this type.
0000000000000000000000000000000000000000;;		dataVal := reflect.Indirect(reflect.ValueOf(data))
0000000000000000000000000000000000000000;;		if val.Type() != dataVal.Type() {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' expected type '%s', got unconvertible type '%s'",
0000000000000000000000000000000000000000;;				name, val.Type(), dataVal.Type())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val.Set(dataVal)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeSlice(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.Indirect(reflect.ValueOf(data))
0000000000000000000000000000000000000000;;		dataValKind := dataVal.Kind()
0000000000000000000000000000000000000000;;		valType := val.Type()
0000000000000000000000000000000000000000;;		valElemType := valType.Elem()
0000000000000000000000000000000000000000;;		sliceType := reflect.SliceOf(valElemType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		valSlice := val
0000000000000000000000000000000000000000;;		if valSlice.IsNil() || d.config.ZeroFields {
0000000000000000000000000000000000000000;;			// Check input type
0000000000000000000000000000000000000000;;			if dataValKind != reflect.Array && dataValKind != reflect.Slice {
0000000000000000000000000000000000000000;;				if d.config.WeaklyTypedInput {
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					// Empty maps turn into empty slices
0000000000000000000000000000000000000000;;					case dataValKind == reflect.Map:
0000000000000000000000000000000000000000;;						if dataVal.Len() == 0 {
0000000000000000000000000000000000000000;;							val.Set(reflect.MakeSlice(sliceType, 0, 0))
0000000000000000000000000000000000000000;;							return nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// All other types we try to convert to the slice type
0000000000000000000000000000000000000000;;					// and "lift" it into it. i.e. a string becomes a string slice.
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						// Just re-try this function with data as a slice.
0000000000000000000000000000000000000000;;						return d.decodeSlice(name, []interface{}{data}, val)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return fmt.Errorf(
0000000000000000000000000000000000000000;;					"'%s': source data must be an array or slice, got %s", name, dataValKind)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make a new slice to hold our result, same size as the original data.
0000000000000000000000000000000000000000;;			valSlice = reflect.MakeSlice(sliceType, dataVal.Len(), dataVal.Len())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Accumulate any errors
0000000000000000000000000000000000000000;;		errors := make([]string, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < dataVal.Len(); i++ {
0000000000000000000000000000000000000000;;			currentData := dataVal.Index(i).Interface()
0000000000000000000000000000000000000000;;			for valSlice.Len() <= i {
0000000000000000000000000000000000000000;;				valSlice = reflect.Append(valSlice, reflect.Zero(valElemType))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			currentField := valSlice.Index(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fieldName := fmt.Sprintf("%s[%d]", name, i)
0000000000000000000000000000000000000000;;			if err := d.decode(fieldName, currentData, currentField); err != nil {
0000000000000000000000000000000000000000;;				errors = appendErrors(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Finally, set the value to the slice we built up
0000000000000000000000000000000000000000;;		val.Set(valSlice)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there were errors, we return those
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			return &Error{errors}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Decoder) decodeStruct(name string, data interface{}, val reflect.Value) error {
0000000000000000000000000000000000000000;;		dataVal := reflect.Indirect(reflect.ValueOf(data))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the type of the value to write to and the data match directly,
0000000000000000000000000000000000000000;;		// then we just set it directly instead of recursing into the structure.
0000000000000000000000000000000000000000;;		if dataVal.Type() == val.Type() {
0000000000000000000000000000000000000000;;			val.Set(dataVal)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataValKind := dataVal.Kind()
0000000000000000000000000000000000000000;;		if dataValKind != reflect.Map {
0000000000000000000000000000000000000000;;			return fmt.Errorf("'%s' expected a map, got '%s'", name, dataValKind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataValType := dataVal.Type()
0000000000000000000000000000000000000000;;		if kind := dataValType.Key().Kind(); kind != reflect.String && kind != reflect.Interface {
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"'%s' needs a map with string keys, has '%s' keys",
0000000000000000000000000000000000000000;;				name, dataValType.Key().Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataValKeys := make(map[reflect.Value]struct{})
0000000000000000000000000000000000000000;;		dataValKeysUnused := make(map[interface{}]struct{})
0000000000000000000000000000000000000000;;		for _, dataValKey := range dataVal.MapKeys() {
0000000000000000000000000000000000000000;;			dataValKeys[dataValKey] = struct{}{}
0000000000000000000000000000000000000000;;			dataValKeysUnused[dataValKey.Interface()] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errors := make([]string, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This slice will keep track of all the structs we'll be decoding.
0000000000000000000000000000000000000000;;		// There can be more than one struct if there are embedded structs
0000000000000000000000000000000000000000;;		// that are squashed.
0000000000000000000000000000000000000000;;		structs := make([]reflect.Value, 1, 5)
0000000000000000000000000000000000000000;;		structs[0] = val
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compile the list of all the fields that we're going to be decoding
0000000000000000000000000000000000000000;;		// from all the structs.
0000000000000000000000000000000000000000;;		fields := make(map[*reflect.StructField]reflect.Value)
0000000000000000000000000000000000000000;;		for len(structs) > 0 {
0000000000000000000000000000000000000000;;			structVal := structs[0]
0000000000000000000000000000000000000000;;			structs = structs[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			structType := structVal.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i := 0; i < structType.NumField(); i++ {
0000000000000000000000000000000000000000;;				fieldType := structType.Field(i)
0000000000000000000000000000000000000000;;				fieldKind := fieldType.Type.Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If "squash" is specified in the tag, we squash the field down.
0000000000000000000000000000000000000000;;				squash := false
0000000000000000000000000000000000000000;;				tagParts := strings.Split(fieldType.Tag.Get(d.config.TagName), ",")
0000000000000000000000000000000000000000;;				for _, tag := range tagParts[1:] {
0000000000000000000000000000000000000000;;					if tag == "squash" {
0000000000000000000000000000000000000000;;						squash = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if squash {
0000000000000000000000000000000000000000;;					if fieldKind != reflect.Struct {
0000000000000000000000000000000000000000;;						errors = appendErrors(errors,
0000000000000000000000000000000000000000;;							fmt.Errorf("%s: unsupported type for squash: %s", fieldType.Name, fieldKind))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						structs = append(structs, val.FieldByName(fieldType.Name))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Normal struct field, store it away
0000000000000000000000000000000000000000;;				fields[&fieldType] = structVal.Field(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for fieldType, field := range fields {
0000000000000000000000000000000000000000;;			fieldName := fieldType.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tagValue := fieldType.Tag.Get(d.config.TagName)
0000000000000000000000000000000000000000;;			tagValue = strings.SplitN(tagValue, ",", 2)[0]
0000000000000000000000000000000000000000;;			if tagValue != "" {
0000000000000000000000000000000000000000;;				fieldName = tagValue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rawMapKey := reflect.ValueOf(fieldName)
0000000000000000000000000000000000000000;;			rawMapVal := dataVal.MapIndex(rawMapKey)
0000000000000000000000000000000000000000;;			if !rawMapVal.IsValid() {
0000000000000000000000000000000000000000;;				// Do a slower search by iterating over each key and
0000000000000000000000000000000000000000;;				// doing case-insensitive search.
0000000000000000000000000000000000000000;;				for dataValKey := range dataValKeys {
0000000000000000000000000000000000000000;;					mK, ok := dataValKey.Interface().(string)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						// Not a string key
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if strings.EqualFold(mK, fieldName) {
0000000000000000000000000000000000000000;;						rawMapKey = dataValKey
0000000000000000000000000000000000000000;;						rawMapVal = dataVal.MapIndex(dataValKey)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !rawMapVal.IsValid() {
0000000000000000000000000000000000000000;;					// There was no matching key in the map for the value in
0000000000000000000000000000000000000000;;					// the struct. Just ignore.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Delete the key we're using from the unused map so we stop tracking
0000000000000000000000000000000000000000;;			delete(dataValKeysUnused, rawMapKey.Interface())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !field.IsValid() {
0000000000000000000000000000000000000000;;				// This should never happen
0000000000000000000000000000000000000000;;				panic("field is not valid")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we can't set the field, then it is unexported or something,
0000000000000000000000000000000000000000;;			// and we just continue onwards.
0000000000000000000000000000000000000000;;			if !field.CanSet() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If the name is empty string, then we're at the root, and we
0000000000000000000000000000000000000000;;			// don't dot-join the fields.
0000000000000000000000000000000000000000;;			if name != "" {
0000000000000000000000000000000000000000;;				fieldName = fmt.Sprintf("%s.%s", name, fieldName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := d.decode(fieldName, rawMapVal.Interface(), field); err != nil {
0000000000000000000000000000000000000000;;				errors = appendErrors(errors, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.config.ErrorUnused && len(dataValKeysUnused) > 0 {
0000000000000000000000000000000000000000;;			keys := make([]string, 0, len(dataValKeysUnused))
0000000000000000000000000000000000000000;;			for rawKey := range dataValKeysUnused {
0000000000000000000000000000000000000000;;				keys = append(keys, rawKey.(string))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := fmt.Errorf("'%s' has invalid keys: %s", name, strings.Join(keys, ", "))
0000000000000000000000000000000000000000;;			errors = appendErrors(errors, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(errors) > 0 {
0000000000000000000000000000000000000000;;			return &Error{errors}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the unused keys to the list of unused keys if we're tracking metadata
0000000000000000000000000000000000000000;;		if d.config.Metadata != nil {
0000000000000000000000000000000000000000;;			for rawKey := range dataValKeysUnused {
0000000000000000000000000000000000000000;;				key := rawKey.(string)
0000000000000000000000000000000000000000;;				if name != "" {
0000000000000000000000000000000000000000;;					key = fmt.Sprintf("%s.%s", name, key)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				d.config.Metadata.Unused = append(d.config.Metadata.Unused, key)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getKind(val reflect.Value) reflect.Kind {
0000000000000000000000000000000000000000;;		kind := val.Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case kind >= reflect.Int && kind <= reflect.Int64:
0000000000000000000000000000000000000000;;			return reflect.Int
0000000000000000000000000000000000000000;;		case kind >= reflect.Uint && kind <= reflect.Uint64:
0000000000000000000000000000000000000000;;			return reflect.Uint
0000000000000000000000000000000000000000;;		case kind >= reflect.Float32 && kind <= reflect.Float64:
0000000000000000000000000000000000000000;;			return reflect.Float32
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return kind
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
