0000000000000000000000000000000000000000;;	package mapstructure
5ee9c53e7b694ff752a75066a2192058fc5b79ef;Godeps/_workspace/src/github.com/mitchellh/mapstructure/decode_hooks.go[Godeps/_workspace/src/github.com/mitchellh/mapstructure/decode_hooks.go][vendor/github.com/mitchellh/mapstructure/decode_hooks.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// typedDecodeHook takes a raw DecodeHookFunc (an interface{}) and turns
0000000000000000000000000000000000000000;;	// it into the proper DecodeHookFunc type, such as DecodeHookFuncType.
0000000000000000000000000000000000000000;;	func typedDecodeHook(h DecodeHookFunc) DecodeHookFunc {
0000000000000000000000000000000000000000;;		// Create variables here so we can reference them with the reflect pkg
0000000000000000000000000000000000000000;;		var f1 DecodeHookFuncType
0000000000000000000000000000000000000000;;		var f2 DecodeHookFuncKind
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fill in the variables into this interface and the rest is done
0000000000000000000000000000000000000000;;		// automatically using the reflect package.
0000000000000000000000000000000000000000;;		potential := []interface{}{f1, f2}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(h)
0000000000000000000000000000000000000000;;		vt := v.Type()
0000000000000000000000000000000000000000;;		for _, raw := range potential {
0000000000000000000000000000000000000000;;			pt := reflect.ValueOf(raw).Type()
0000000000000000000000000000000000000000;;			if vt.ConvertibleTo(pt) {
0000000000000000000000000000000000000000;;				return v.Convert(pt).Interface()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeHookExec executes the given decode hook. This should be used
0000000000000000000000000000000000000000;;	// since it'll naturally degrade to the older backwards compatible DecodeHookFunc
0000000000000000000000000000000000000000;;	// that took reflect.Kind instead of reflect.Type.
0000000000000000000000000000000000000000;;	func DecodeHookExec(
0000000000000000000000000000000000000000;;		raw DecodeHookFunc,
0000000000000000000000000000000000000000;;		from reflect.Type, to reflect.Type,
0000000000000000000000000000000000000000;;		data interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		// Build our arguments that reflect expects
0000000000000000000000000000000000000000;;		argVals := make([]reflect.Value, 3)
0000000000000000000000000000000000000000;;		argVals[0] = reflect.ValueOf(from)
0000000000000000000000000000000000000000;;		argVals[1] = reflect.ValueOf(to)
0000000000000000000000000000000000000000;;		argVals[2] = reflect.ValueOf(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch f := typedDecodeHook(raw).(type) {
0000000000000000000000000000000000000000;;		case DecodeHookFuncType:
0000000000000000000000000000000000000000;;			return f(from, to, data)
0000000000000000000000000000000000000000;;		case DecodeHookFuncKind:
0000000000000000000000000000000000000000;;			return f(from.Kind(), to.Kind(), data)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid decode hook signature")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComposeDecodeHookFunc creates a single DecodeHookFunc that
0000000000000000000000000000000000000000;;	// automatically composes multiple DecodeHookFuncs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The composed funcs are called in order, with the result of the
0000000000000000000000000000000000000000;;	// previous transformation.
0000000000000000000000000000000000000000;;	func ComposeDecodeHookFunc(fs ...DecodeHookFunc) DecodeHookFunc {
0000000000000000000000000000000000000000;;		return func(
0000000000000000000000000000000000000000;;			f reflect.Type,
0000000000000000000000000000000000000000;;			t reflect.Type,
0000000000000000000000000000000000000000;;			data interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			for _, f1 := range fs {
0000000000000000000000000000000000000000;;				data, err = DecodeHookExec(f1, f, t, data)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Modify the from kind to be correct with the new data
0000000000000000000000000000000000000000;;				f = nil
0000000000000000000000000000000000000000;;				if val := reflect.ValueOf(data); val.IsValid() {
0000000000000000000000000000000000000000;;					f = val.Type()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return data, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToSliceHookFunc returns a DecodeHookFunc that converts
0000000000000000000000000000000000000000;;	// string to []string by splitting on the given sep.
0000000000000000000000000000000000000000;;	func StringToSliceHookFunc(sep string) DecodeHookFunc {
0000000000000000000000000000000000000000;;		return func(
0000000000000000000000000000000000000000;;			f reflect.Kind,
0000000000000000000000000000000000000000;;			t reflect.Kind,
0000000000000000000000000000000000000000;;			data interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;			if f != reflect.String || t != reflect.Slice {
0000000000000000000000000000000000000000;;				return data, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			raw := data.(string)
0000000000000000000000000000000000000000;;			if raw == "" {
0000000000000000000000000000000000000000;;				return []string{}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return strings.Split(raw, sep), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToTimeDurationHookFunc returns a DecodeHookFunc that converts
0000000000000000000000000000000000000000;;	// strings to time.Duration.
0000000000000000000000000000000000000000;;	func StringToTimeDurationHookFunc() DecodeHookFunc {
0000000000000000000000000000000000000000;;		return func(
0000000000000000000000000000000000000000;;			f reflect.Type,
0000000000000000000000000000000000000000;;			t reflect.Type,
0000000000000000000000000000000000000000;;			data interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;			if f.Kind() != reflect.String {
0000000000000000000000000000000000000000;;				return data, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t != reflect.TypeOf(time.Duration(5)) {
0000000000000000000000000000000000000000;;				return data, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Convert it by parsing
0000000000000000000000000000000000000000;;			return time.ParseDuration(data.(string))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func WeaklyTypedHook(
0000000000000000000000000000000000000000;;		f reflect.Kind,
0000000000000000000000000000000000000000;;		t reflect.Kind,
0000000000000000000000000000000000000000;;		data interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		dataVal := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			switch f {
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				if dataVal.Bool() {
0000000000000000000000000000000000000000;;					return "1", nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return "0", nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Float32:
0000000000000000000000000000000000000000;;				return strconv.FormatFloat(dataVal.Float(), 'f', -1, 64), nil
0000000000000000000000000000000000000000;;			case reflect.Int:
0000000000000000000000000000000000000000;;				return strconv.FormatInt(dataVal.Int(), 10), nil
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				dataType := dataVal.Type()
0000000000000000000000000000000000000000;;				elemKind := dataType.Elem().Kind()
0000000000000000000000000000000000000000;;				if elemKind == reflect.Uint8 {
0000000000000000000000000000000000000000;;					return string(dataVal.Interface().([]uint8)), nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case reflect.Uint:
0000000000000000000000000000000000000000;;				return strconv.FormatUint(dataVal.Uint(), 10), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data, nil
0000000000000000000000000000000000000000;;	}
