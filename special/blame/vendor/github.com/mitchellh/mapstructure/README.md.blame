0000000000000000000000000000000000000000;;	# mapstructure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	mapstructure is a Go library for decoding generic map values to structures
0000000000000000000000000000000000000000;;	and vice versa, while providing helpful error handling.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This library is most useful when decoding values from some data stream (JSON,
0000000000000000000000000000000000000000;;	Gob, etc.) where you don't _quite_ know the structure of the underlying data
0000000000000000000000000000000000000000;;	until you read a part of it. You can therefore read a `map[string]interface{}`
0000000000000000000000000000000000000000;;	and use this library to decode it into the proper underlying native Go
0000000000000000000000000000000000000000;;	structure.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Installation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Standard `go get`:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	$ go get github.com/mitchellh/mapstructure
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Usage & Example
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For usage and examples see the [Godoc](http://godoc.org/github.com/mitchellh/mapstructure).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The `Decode` function has examples associated with it there.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## But Why?!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Go offers fantastic standard libraries for decoding formats such as JSON.
0000000000000000000000000000000000000000;;	The standard method is to have a struct pre-created, and populate that struct
0000000000000000000000000000000000000000;;	from the bytes of the encoded format. This is great, but the problem is if
0000000000000000000000000000000000000000;;	you have configuration or an encoding that changes slightly depending on
0000000000000000000000000000000000000000;;	specific fields. For example, consider this JSON:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```json
0000000000000000000000000000000000000000;;	{
0000000000000000000000000000000000000000;;	  "type": "person",
0000000000000000000000000000000000000000;;	  "name": "Mitchell"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Perhaps we can't populate a specific structure without first reading
0000000000000000000000000000000000000000;;	the "type" field from the JSON. We could always do two passes over the
0000000000000000000000000000000000000000;;	decoding of the JSON (reading the "type" first, and the rest later).
0000000000000000000000000000000000000000;;	However, it is much simpler to just decode this into a `map[string]interface{}`
0000000000000000000000000000000000000000;;	structure, read the "type" key, then use something like this library
0000000000000000000000000000000000000000;;	to decode it into the proper structure.
