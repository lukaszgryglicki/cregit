0000000000000000000000000000000000000000;;	package mapstructure
5ee9c53e7b694ff752a75066a2192058fc5b79ef;Godeps/_workspace/src/github.com/mitchellh/mapstructure/error.go[Godeps/_workspace/src/github.com/mitchellh/mapstructure/error.go][vendor/github.com/mitchellh/mapstructure/error.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error implements the error interface and can represents multiple
0000000000000000000000000000000000000000;;	// errors that occur in the course of a single decode.
0000000000000000000000000000000000000000;;	type Error struct {
0000000000000000000000000000000000000000;;		Errors []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Error) Error() string {
0000000000000000000000000000000000000000;;		points := make([]string, len(e.Errors))
0000000000000000000000000000000000000000;;		for i, err := range e.Errors {
0000000000000000000000000000000000000000;;			points[i] = fmt.Sprintf("* %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sort.Strings(points)
0000000000000000000000000000000000000000;;		return fmt.Sprintf(
0000000000000000000000000000000000000000;;			"%d error(s) decoding:\n\n%s",
0000000000000000000000000000000000000000;;			len(e.Errors), strings.Join(points, "\n"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WrappedErrors implements the errwrap.Wrapper interface to make this
0000000000000000000000000000000000000000;;	// return value more useful with the errwrap and go-multierror libraries.
0000000000000000000000000000000000000000;;	func (e *Error) WrappedErrors() []error {
0000000000000000000000000000000000000000;;		if e == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]error, len(e.Errors))
0000000000000000000000000000000000000000;;		for i, e := range e.Errors {
0000000000000000000000000000000000000000;;			result[i] = errors.New(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendErrors(errors []string, err error) []string {
0000000000000000000000000000000000000000;;		switch e := err.(type) {
0000000000000000000000000000000000000000;;		case *Error:
0000000000000000000000000000000000000000;;			return append(errors, e.Errors...)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return append(errors, e.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
