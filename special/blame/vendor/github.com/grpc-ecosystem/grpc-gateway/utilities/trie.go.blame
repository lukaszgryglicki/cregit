0000000000000000000000000000000000000000;;	package utilities
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoubleArray is a Double Array implementation of trie on sequences of strings.
0000000000000000000000000000000000000000;;	type DoubleArray struct {
0000000000000000000000000000000000000000;;		// Encoding keeps an encoding from string to int
0000000000000000000000000000000000000000;;		Encoding map[string]int
0000000000000000000000000000000000000000;;		// Base is the base array of Double Array
0000000000000000000000000000000000000000;;		Base []int
0000000000000000000000000000000000000000;;		// Check is the check array of Double Array
0000000000000000000000000000000000000000;;		Check []int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewDoubleArray builds a DoubleArray from a set of sequences of strings.
0000000000000000000000000000000000000000;;	func NewDoubleArray(seqs [][]string) *DoubleArray {
0000000000000000000000000000000000000000;;		da := &DoubleArray{Encoding: make(map[string]int)}
0000000000000000000000000000000000000000;;		if len(seqs) == 0 {
0000000000000000000000000000000000000000;;			return da
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encoded := registerTokens(da, seqs)
0000000000000000000000000000000000000000;;		sort.Sort(byLex(encoded))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		root := node{row: -1, col: -1, left: 0, right: len(encoded)}
0000000000000000000000000000000000000000;;		addSeqs(da, encoded, 0, root)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := len(da.Base); i > 0; i-- {
0000000000000000000000000000000000000000;;			if da.Check[i-1] != 0 {
0000000000000000000000000000000000000000;;				da.Base = da.Base[:i]
0000000000000000000000000000000000000000;;				da.Check = da.Check[:i]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return da
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func registerTokens(da *DoubleArray, seqs [][]string) [][]int {
0000000000000000000000000000000000000000;;		var result [][]int
0000000000000000000000000000000000000000;;		for _, seq := range seqs {
0000000000000000000000000000000000000000;;			var encoded []int
0000000000000000000000000000000000000000;;			for _, token := range seq {
0000000000000000000000000000000000000000;;				if _, ok := da.Encoding[token]; !ok {
0000000000000000000000000000000000000000;;					da.Encoding[token] = len(da.Encoding)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				encoded = append(encoded, da.Encoding[token])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, encoded)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range result {
0000000000000000000000000000000000000000;;			result[i] = append(result[i], len(da.Encoding))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		row, col    int
0000000000000000000000000000000000000000;;		left, right int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n node) value(seqs [][]int) int {
0000000000000000000000000000000000000000;;		return seqs[n.row][n.col]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n node) children(seqs [][]int) []*node {
0000000000000000000000000000000000000000;;		var result []*node
0000000000000000000000000000000000000000;;		lastVal := int(-1)
0000000000000000000000000000000000000000;;		last := new(node)
0000000000000000000000000000000000000000;;		for i := n.left; i < n.right; i++ {
0000000000000000000000000000000000000000;;			if lastVal == seqs[i][n.col+1] {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			last.right = i
0000000000000000000000000000000000000000;;			last = &node{
0000000000000000000000000000000000000000;;				row:  i,
0000000000000000000000000000000000000000;;				col:  n.col + 1,
0000000000000000000000000000000000000000;;				left: i,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, last)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		last.right = n.right
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addSeqs(da *DoubleArray, seqs [][]int, pos int, n node) {
0000000000000000000000000000000000000000;;		ensureSize(da, pos)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		children := n.children(seqs)
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		for i = 1; ; i++ {
0000000000000000000000000000000000000000;;			ok := func() bool {
0000000000000000000000000000000000000000;;				for _, child := range children {
0000000000000000000000000000000000000000;;					code := child.value(seqs)
0000000000000000000000000000000000000000;;					j := i + code
0000000000000000000000000000000000000000;;					ensureSize(da, j)
0000000000000000000000000000000000000000;;					if da.Check[j] != 0 {
0000000000000000000000000000000000000000;;						return false
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		da.Base[pos] = i
0000000000000000000000000000000000000000;;		for _, child := range children {
0000000000000000000000000000000000000000;;			code := child.value(seqs)
0000000000000000000000000000000000000000;;			j := i + code
0000000000000000000000000000000000000000;;			da.Check[j] = pos + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		terminator := len(da.Encoding)
0000000000000000000000000000000000000000;;		for _, child := range children {
0000000000000000000000000000000000000000;;			code := child.value(seqs)
0000000000000000000000000000000000000000;;			if code == terminator {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			j := i + code
0000000000000000000000000000000000000000;;			addSeqs(da, seqs, j, *child)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureSize(da *DoubleArray, i int) {
0000000000000000000000000000000000000000;;		for i >= len(da.Base) {
0000000000000000000000000000000000000000;;			da.Base = append(da.Base, make([]int, len(da.Base)+1)...)
0000000000000000000000000000000000000000;;			da.Check = append(da.Check, make([]int, len(da.Check)+1)...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byLex [][]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l byLex) Len() int      { return len(l) }
0000000000000000000000000000000000000000;;	func (l byLex) Swap(i, j int) { l[i], l[j] = l[j], l[i] }
0000000000000000000000000000000000000000;;	func (l byLex) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		si := l[i]
0000000000000000000000000000000000000000;;		sj := l[j]
0000000000000000000000000000000000000000;;		var k int
0000000000000000000000000000000000000000;;		for k = 0; k < len(si) && k < len(sj); k++ {
0000000000000000000000000000000000000000;;			if si[k] < sj[k] {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if si[k] > sj[k] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if k < len(sj) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasCommonPrefix determines if any sequence in the DoubleArray is a prefix of the given sequence.
0000000000000000000000000000000000000000;;	func (da *DoubleArray) HasCommonPrefix(seq []string) bool {
0000000000000000000000000000000000000000;;		if len(da.Base) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		for _, t := range seq {
0000000000000000000000000000000000000000;;			code, ok := da.Encoding[t]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			j := da.Base[i] + code
0000000000000000000000000000000000000000;;			if len(da.Check) <= j || da.Check[j] != i+1 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = j
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		j := da.Base[i] + len(da.Encoding)
0000000000000000000000000000000000000000;;		if len(da.Check) <= j || da.Check[j] != i+1 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
