0000000000000000000000000000000000000000;;	package runtime
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/grpc-ecosystem/grpc-gateway/utilities"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrNotMatch indicates that the given HTTP request path does not match to the pattern.
0000000000000000000000000000000000000000;;		ErrNotMatch = errors.New("not match to the path pattern")
0000000000000000000000000000000000000000;;		// ErrInvalidPattern indicates that the given definition of Pattern is not valid.
0000000000000000000000000000000000000000;;		ErrInvalidPattern = errors.New("invalid pattern")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type op struct {
0000000000000000000000000000000000000000;;		code    utilities.OpCode
0000000000000000000000000000000000000000;;		operand int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pattern is a template pattern of http request paths defined in third_party/googleapis/google/api/http.proto.
0000000000000000000000000000000000000000;;	type Pattern struct {
0000000000000000000000000000000000000000;;		// ops is a list of operations
0000000000000000000000000000000000000000;;		ops []op
0000000000000000000000000000000000000000;;		// pool is a constant pool indexed by the operands or vars.
0000000000000000000000000000000000000000;;		pool []string
0000000000000000000000000000000000000000;;		// vars is a list of variables names to be bound by this pattern
0000000000000000000000000000000000000000;;		vars []string
0000000000000000000000000000000000000000;;		// stacksize is the max depth of the stack
0000000000000000000000000000000000000000;;		stacksize int
0000000000000000000000000000000000000000;;		// tailLen is the length of the fixed-size segments after a deep wildcard
0000000000000000000000000000000000000000;;		tailLen int
0000000000000000000000000000000000000000;;		// verb is the VERB part of the path pattern. It is empty if the pattern does not have VERB part.
0000000000000000000000000000000000000000;;		verb string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPattern returns a new Pattern from the given definition values.
0000000000000000000000000000000000000000;;	// "ops" is a sequence of op codes. "pool" is a constant pool.
0000000000000000000000000000000000000000;;	// "verb" is the verb part of the pattern. It is empty if the pattern does not have the part.
0000000000000000000000000000000000000000;;	// "version" must be 1 for now.
0000000000000000000000000000000000000000;;	// It returns an error if the given definition is invalid.
0000000000000000000000000000000000000000;;	func NewPattern(version int, ops []int, pool []string, verb string) (Pattern, error) {
0000000000000000000000000000000000000000;;		if version != 1 {
0000000000000000000000000000000000000000;;			grpclog.Printf("unsupported version: %d", version)
0000000000000000000000000000000000000000;;			return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := len(ops)
0000000000000000000000000000000000000000;;		if l%2 != 0 {
0000000000000000000000000000000000000000;;			grpclog.Printf("odd number of ops codes: %d", l)
0000000000000000000000000000000000000000;;			return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			typedOps        []op
0000000000000000000000000000000000000000;;			stack, maxstack int
0000000000000000000000000000000000000000;;			tailLen         int
0000000000000000000000000000000000000000;;			pushMSeen       bool
0000000000000000000000000000000000000000;;			vars            []string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i += 2 {
0000000000000000000000000000000000000000;;			op := op{code: utilities.OpCode(ops[i]), operand: ops[i+1]}
0000000000000000000000000000000000000000;;			switch op.code {
0000000000000000000000000000000000000000;;			case utilities.OpNop:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case utilities.OpPush:
0000000000000000000000000000000000000000;;				if pushMSeen {
0000000000000000000000000000000000000000;;					tailLen++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stack++
0000000000000000000000000000000000000000;;			case utilities.OpPushM:
0000000000000000000000000000000000000000;;				if pushMSeen {
0000000000000000000000000000000000000000;;					grpclog.Printf("pushM appears twice")
0000000000000000000000000000000000000000;;					return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pushMSeen = true
0000000000000000000000000000000000000000;;				stack++
0000000000000000000000000000000000000000;;			case utilities.OpLitPush:
0000000000000000000000000000000000000000;;				if op.operand < 0 || len(pool) <= op.operand {
0000000000000000000000000000000000000000;;					grpclog.Printf("negative literal index: %d", op.operand)
0000000000000000000000000000000000000000;;					return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if pushMSeen {
0000000000000000000000000000000000000000;;					tailLen++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stack++
0000000000000000000000000000000000000000;;			case utilities.OpConcatN:
0000000000000000000000000000000000000000;;				if op.operand <= 0 {
0000000000000000000000000000000000000000;;					grpclog.Printf("negative concat size: %d", op.operand)
0000000000000000000000000000000000000000;;					return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stack -= op.operand
0000000000000000000000000000000000000000;;				if stack < 0 {
0000000000000000000000000000000000000000;;					grpclog.Print("stack underflow")
0000000000000000000000000000000000000000;;					return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stack++
0000000000000000000000000000000000000000;;			case utilities.OpCapture:
0000000000000000000000000000000000000000;;				if op.operand < 0 || len(pool) <= op.operand {
0000000000000000000000000000000000000000;;					grpclog.Printf("variable name index out of bound: %d", op.operand)
0000000000000000000000000000000000000000;;					return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v := pool[op.operand]
0000000000000000000000000000000000000000;;				op.operand = len(vars)
0000000000000000000000000000000000000000;;				vars = append(vars, v)
0000000000000000000000000000000000000000;;				stack--
0000000000000000000000000000000000000000;;				if stack < 0 {
0000000000000000000000000000000000000000;;					grpclog.Printf("stack underflow")
0000000000000000000000000000000000000000;;					return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				grpclog.Printf("invalid opcode: %d", op.code)
0000000000000000000000000000000000000000;;				return Pattern{}, ErrInvalidPattern
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if maxstack < stack {
0000000000000000000000000000000000000000;;				maxstack = stack
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			typedOps = append(typedOps, op)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Pattern{
0000000000000000000000000000000000000000;;			ops:       typedOps,
0000000000000000000000000000000000000000;;			pool:      pool,
0000000000000000000000000000000000000000;;			vars:      vars,
0000000000000000000000000000000000000000;;			stacksize: maxstack,
0000000000000000000000000000000000000000;;			tailLen:   tailLen,
0000000000000000000000000000000000000000;;			verb:      verb,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustPattern is a helper function which makes it easier to call NewPattern in variable initialization.
0000000000000000000000000000000000000000;;	func MustPattern(p Pattern, err error) Pattern {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			grpclog.Fatalf("Pattern initialization failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match examines components if it matches to the Pattern.
0000000000000000000000000000000000000000;;	// If it matches, the function returns a mapping from field paths to their captured values.
0000000000000000000000000000000000000000;;	// If otherwise, the function returns an error.
0000000000000000000000000000000000000000;;	func (p Pattern) Match(components []string, verb string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		if p.verb != verb {
0000000000000000000000000000000000000000;;			return nil, ErrNotMatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var pos int
0000000000000000000000000000000000000000;;		stack := make([]string, 0, p.stacksize)
0000000000000000000000000000000000000000;;		captured := make([]string, len(p.vars))
0000000000000000000000000000000000000000;;		l := len(components)
0000000000000000000000000000000000000000;;		for _, op := range p.ops {
0000000000000000000000000000000000000000;;			switch op.code {
0000000000000000000000000000000000000000;;			case utilities.OpNop:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case utilities.OpPush, utilities.OpLitPush:
0000000000000000000000000000000000000000;;				if pos >= l {
0000000000000000000000000000000000000000;;					return nil, ErrNotMatch
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c := components[pos]
0000000000000000000000000000000000000000;;				if op.code == utilities.OpLitPush {
0000000000000000000000000000000000000000;;					if lit := p.pool[op.operand]; c != lit {
0000000000000000000000000000000000000000;;						return nil, ErrNotMatch
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stack = append(stack, c)
0000000000000000000000000000000000000000;;				pos++
0000000000000000000000000000000000000000;;			case utilities.OpPushM:
0000000000000000000000000000000000000000;;				end := len(components)
0000000000000000000000000000000000000000;;				if end < pos+p.tailLen {
0000000000000000000000000000000000000000;;					return nil, ErrNotMatch
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				end -= p.tailLen
0000000000000000000000000000000000000000;;				stack = append(stack, strings.Join(components[pos:end], "/"))
0000000000000000000000000000000000000000;;				pos = end
0000000000000000000000000000000000000000;;			case utilities.OpConcatN:
0000000000000000000000000000000000000000;;				n := op.operand
0000000000000000000000000000000000000000;;				l := len(stack) - n
0000000000000000000000000000000000000000;;				stack = append(stack[:l], strings.Join(stack[l:], "/"))
0000000000000000000000000000000000000000;;			case utilities.OpCapture:
0000000000000000000000000000000000000000;;				n := len(stack) - 1
0000000000000000000000000000000000000000;;				captured[op.operand] = stack[n]
0000000000000000000000000000000000000000;;				stack = stack[:n]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pos < l {
0000000000000000000000000000000000000000;;			return nil, ErrNotMatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bindings := make(map[string]string)
0000000000000000000000000000000000000000;;		for i, val := range captured {
0000000000000000000000000000000000000000;;			bindings[p.vars[i]] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bindings, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verb returns the verb part of the Pattern.
0000000000000000000000000000000000000000;;	func (p Pattern) Verb() string { return p.verb }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Pattern) String() string {
0000000000000000000000000000000000000000;;		var stack []string
0000000000000000000000000000000000000000;;		for _, op := range p.ops {
0000000000000000000000000000000000000000;;			switch op.code {
0000000000000000000000000000000000000000;;			case utilities.OpNop:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case utilities.OpPush:
0000000000000000000000000000000000000000;;				stack = append(stack, "*")
0000000000000000000000000000000000000000;;			case utilities.OpLitPush:
0000000000000000000000000000000000000000;;				stack = append(stack, p.pool[op.operand])
0000000000000000000000000000000000000000;;			case utilities.OpPushM:
0000000000000000000000000000000000000000;;				stack = append(stack, "**")
0000000000000000000000000000000000000000;;			case utilities.OpConcatN:
0000000000000000000000000000000000000000;;				n := op.operand
0000000000000000000000000000000000000000;;				l := len(stack) - n
0000000000000000000000000000000000000000;;				stack = append(stack[:l], strings.Join(stack[l:], "/"))
0000000000000000000000000000000000000000;;			case utilities.OpCapture:
0000000000000000000000000000000000000000;;				n := len(stack) - 1
0000000000000000000000000000000000000000;;				stack[n] = fmt.Sprintf("{%s=%s}", p.vars[op.operand], stack[n])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		segs := strings.Join(stack, "/")
0000000000000000000000000000000000000000;;		if p.verb != "" {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("/%s:%s", segs, p.verb)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "/" + segs
0000000000000000000000000000000000000000;;	}
