0000000000000000000000000000000000000000;;	package runtime
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/grpc-ecosystem/grpc-gateway/utilities"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PopulateQueryParameters populates "values" into "msg".
0000000000000000000000000000000000000000;;	// A value is ignored if its key starts with one of the elements in "filter".
0000000000000000000000000000000000000000;;	func PopulateQueryParameters(msg proto.Message, values url.Values, filter *utilities.DoubleArray) error {
0000000000000000000000000000000000000000;;		for key, values := range values {
0000000000000000000000000000000000000000;;			fieldPath := strings.Split(key, ".")
0000000000000000000000000000000000000000;;			if filter.HasCommonPrefix(fieldPath) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := populateFieldValueFromPath(msg, fieldPath, values); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PopulateFieldFromPath sets a value in a nested Protobuf structure.
0000000000000000000000000000000000000000;;	// It instantiates missing protobuf fields as it goes.
0000000000000000000000000000000000000000;;	func PopulateFieldFromPath(msg proto.Message, fieldPathString string, value string) error {
0000000000000000000000000000000000000000;;		fieldPath := strings.Split(fieldPathString, ".")
0000000000000000000000000000000000000000;;		return populateFieldValueFromPath(msg, fieldPath, []string{value})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func populateFieldValueFromPath(msg proto.Message, fieldPath []string, values []string) error {
0000000000000000000000000000000000000000;;		m := reflect.ValueOf(msg)
0000000000000000000000000000000000000000;;		if m.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unexpected type %T: %v", msg, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m = m.Elem()
0000000000000000000000000000000000000000;;		for i, fieldName := range fieldPath {
0000000000000000000000000000000000000000;;			isLast := i == len(fieldPath)-1
0000000000000000000000000000000000000000;;			if !isLast && m.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;				return fmt.Errorf("non-aggregate type in the mid of path: %s", strings.Join(fieldPath, "."))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f := fieldByProtoName(m, fieldName)
0000000000000000000000000000000000000000;;			if !f.IsValid() {
0000000000000000000000000000000000000000;;				grpclog.Printf("field not found in %T: %s", msg, strings.Join(fieldPath, "."))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch f.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Bool, reflect.Float32, reflect.Float64, reflect.Int32, reflect.Int64, reflect.String, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;				m = f
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				// TODO(yugui) Support []byte
0000000000000000000000000000000000000000;;				if !isLast {
0000000000000000000000000000000000000000;;					return fmt.Errorf("unexpected repeated field in %s", strings.Join(fieldPath, "."))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return populateRepeatedField(f, values)
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;				if f.IsNil() {
0000000000000000000000000000000000000000;;					m = reflect.New(f.Type().Elem())
0000000000000000000000000000000000000000;;					f.Set(m)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				m = f.Elem()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case reflect.Struct:
0000000000000000000000000000000000000000;;				m = f
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("unexpected type %s in %T", f.Type(), msg)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch len(values) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return fmt.Errorf("no value of field: %s", strings.Join(fieldPath, "."))
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			grpclog.Printf("too many field values: %s", strings.Join(fieldPath, "."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return populateField(m, values[0])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fieldByProtoName looks up a field whose corresponding protobuf field name is "name".
0000000000000000000000000000000000000000;;	// "m" must be a struct value. It returns zero reflect.Value if no such field found.
0000000000000000000000000000000000000000;;	func fieldByProtoName(m reflect.Value, name string) reflect.Value {
0000000000000000000000000000000000000000;;		props := proto.GetProperties(m.Type())
0000000000000000000000000000000000000000;;		for _, p := range props.Prop {
0000000000000000000000000000000000000000;;			if p.OrigName == name {
0000000000000000000000000000000000000000;;				return m.FieldByName(p.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return reflect.Value{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func populateRepeatedField(f reflect.Value, values []string) error {
0000000000000000000000000000000000000000;;		elemType := f.Type().Elem()
0000000000000000000000000000000000000000;;		conv, ok := convFromType[elemType.Kind()]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported field type %s", elemType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Set(reflect.MakeSlice(f.Type(), len(values), len(values)))
0000000000000000000000000000000000000000;;		for i, v := range values {
0000000000000000000000000000000000000000;;			result := conv.Call([]reflect.Value{reflect.ValueOf(v)})
0000000000000000000000000000000000000000;;			if err := result[1].Interface(); err != nil {
0000000000000000000000000000000000000000;;				return err.(error)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.Index(i).Set(result[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func populateField(f reflect.Value, value string) error {
0000000000000000000000000000000000000000;;		conv, ok := convFromType[f.Kind()]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported field type %T", f)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := conv.Call([]reflect.Value{reflect.ValueOf(value)})
0000000000000000000000000000000000000000;;		if err := result[1].Interface(); err != nil {
0000000000000000000000000000000000000000;;			return err.(error)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.Set(result[0])
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		convFromType = map[reflect.Kind]reflect.Value{
0000000000000000000000000000000000000000;;			reflect.String:  reflect.ValueOf(String),
0000000000000000000000000000000000000000;;			reflect.Bool:    reflect.ValueOf(Bool),
0000000000000000000000000000000000000000;;			reflect.Float64: reflect.ValueOf(Float64),
0000000000000000000000000000000000000000;;			reflect.Float32: reflect.ValueOf(Float32),
0000000000000000000000000000000000000000;;			reflect.Int64:   reflect.ValueOf(Int64),
0000000000000000000000000000000000000000;;			reflect.Int32:   reflect.ValueOf(Int32),
0000000000000000000000000000000000000000;;			reflect.Uint64:  reflect.ValueOf(Uint64),
0000000000000000000000000000000000000000;;			reflect.Uint32:  reflect.ValueOf(Uint32),
0000000000000000000000000000000000000000;;			// TODO(yugui) Support []byte
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
