0000000000000000000000000000000000000000;;	package runtime
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/textproto"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;		"github.com/grpc-ecosystem/grpc-gateway/runtime/internal"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForwardResponseStream forwards the stream from gRPC server to REST client.
0000000000000000000000000000000000000000;;	func ForwardResponseStream(ctx context.Context, marshaler Marshaler, w http.ResponseWriter, req *http.Request, recv func() (proto.Message, error), opts ...func(context.Context, http.ResponseWriter, proto.Message) error) {
0000000000000000000000000000000000000000;;		f, ok := w.(http.Flusher)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			grpclog.Printf("Flush not supported in %T", w)
0000000000000000000000000000000000000000;;			http.Error(w, "unexpected type of web server", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		md, ok := ServerMetadataFromContext(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			grpclog.Printf("Failed to extract ServerMetadata from context")
0000000000000000000000000000000000000000;;			http.Error(w, "unexpected error", http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handleForwardResponseServerMetadata(w, md)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Transfer-Encoding", "chunked")
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", marshaler.ContentType())
0000000000000000000000000000000000000000;;		if err := handleForwardResponseOptions(ctx, w, nil, opts); err != nil {
0000000000000000000000000000000000000000;;			http.Error(w, err.Error(), http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		f.Flush()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			resp, err := recv()
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				handleForwardResponseStreamError(marshaler, w, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := handleForwardResponseOptions(ctx, w, resp, opts); err != nil {
0000000000000000000000000000000000000000;;				handleForwardResponseStreamError(marshaler, w, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			buf, err := marshaler.Marshal(streamChunk(resp, nil))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				grpclog.Printf("Failed to marshal response chunk: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, err = fmt.Fprintf(w, "%s\n", buf); err != nil {
0000000000000000000000000000000000000000;;				grpclog.Printf("Failed to send response chunk: %v", err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleForwardResponseServerMetadata(w http.ResponseWriter, md ServerMetadata) {
0000000000000000000000000000000000000000;;		for k, vs := range md.HeaderMD {
0000000000000000000000000000000000000000;;			hKey := fmt.Sprintf("%s%s", MetadataHeaderPrefix, k)
0000000000000000000000000000000000000000;;			for i := range vs {
0000000000000000000000000000000000000000;;				w.Header().Add(hKey, vs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleForwardResponseTrailerHeader(w http.ResponseWriter, md ServerMetadata) {
0000000000000000000000000000000000000000;;		for k := range md.TrailerMD {
0000000000000000000000000000000000000000;;			tKey := textproto.CanonicalMIMEHeaderKey(fmt.Sprintf("%s%s", MetadataTrailerPrefix, k))
0000000000000000000000000000000000000000;;			w.Header().Add("Trailer", tKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleForwardResponseTrailer(w http.ResponseWriter, md ServerMetadata) {
0000000000000000000000000000000000000000;;		for k, vs := range md.TrailerMD {
0000000000000000000000000000000000000000;;			tKey := fmt.Sprintf("%s%s", MetadataTrailerPrefix, k)
0000000000000000000000000000000000000000;;			for i := range vs {
0000000000000000000000000000000000000000;;				w.Header().Add(tKey, vs[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ForwardResponseMessage forwards the message "resp" from gRPC server to REST client.
0000000000000000000000000000000000000000;;	func ForwardResponseMessage(ctx context.Context, marshaler Marshaler, w http.ResponseWriter, req *http.Request, resp proto.Message, opts ...func(context.Context, http.ResponseWriter, proto.Message) error) {
0000000000000000000000000000000000000000;;		md, ok := ServerMetadataFromContext(ctx)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			grpclog.Printf("Failed to extract ServerMetadata from context")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handleForwardResponseServerMetadata(w, md)
0000000000000000000000000000000000000000;;		handleForwardResponseTrailerHeader(w, md)
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", marshaler.ContentType())
0000000000000000000000000000000000000000;;		if err := handleForwardResponseOptions(ctx, w, resp, opts); err != nil {
0000000000000000000000000000000000000000;;			HTTPError(ctx, marshaler, w, req, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf, err := marshaler.Marshal(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("Marshal error: %v", err)
0000000000000000000000000000000000000000;;			HTTPError(ctx, marshaler, w, req, err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err = w.Write(buf); err != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("Failed to write response: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handleForwardResponseTrailer(w, md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleForwardResponseOptions(ctx context.Context, w http.ResponseWriter, resp proto.Message, opts []func(context.Context, http.ResponseWriter, proto.Message) error) error {
0000000000000000000000000000000000000000;;		if len(opts) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, opt := range opts {
0000000000000000000000000000000000000000;;			if err := opt(ctx, w, resp); err != nil {
0000000000000000000000000000000000000000;;				grpclog.Printf("Error handling ForwardResponseOptions: %v", err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleForwardResponseStreamError(marshaler Marshaler, w http.ResponseWriter, err error) {
0000000000000000000000000000000000000000;;		buf, merr := marshaler.Marshal(streamChunk(nil, err))
0000000000000000000000000000000000000000;;		if merr != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("Failed to marshal an error: %v", merr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, werr := fmt.Fprintf(w, "%s\n", buf); werr != nil {
0000000000000000000000000000000000000000;;			grpclog.Printf("Failed to notify error to client: %v", werr)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func streamChunk(result proto.Message, err error) map[string]proto.Message {
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			grpcCode := grpc.Code(err)
0000000000000000000000000000000000000000;;			httpCode := HTTPStatusFromCode(grpcCode)
0000000000000000000000000000000000000000;;			return map[string]proto.Message{
0000000000000000000000000000000000000000;;				"error": &internal.StreamError{
0000000000000000000000000000000000000000;;					GrpcCode:   int32(grpcCode),
0000000000000000000000000000000000000000;;					HttpCode:   int32(httpCode),
0000000000000000000000000000000000000000;;					Message:    err.Error(),
0000000000000000000000000000000000000000;;					HttpStatus: http.StatusText(httpCode),
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if result == nil {
0000000000000000000000000000000000000000;;			return streamChunk(nil, fmt.Errorf("empty response"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return map[string]proto.Message{"result": result}
0000000000000000000000000000000000000000;;	}
