0000000000000000000000000000000000000000;;	package runtime
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/codes"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/grpclog"
0000000000000000000000000000000000000000;;		"google.golang.org/grpc/metadata"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadataHeaderPrefix is prepended to HTTP headers in order to convert them to 
0000000000000000000000000000000000000000;;	// gRPC metadata for incoming requests processed by grpc-gateway
0000000000000000000000000000000000000000;;	const MetadataHeaderPrefix = "Grpc-Metadata-"
0000000000000000000000000000000000000000;;	// MetadataTrailerPrefix is prepended to gRPC metadata as it is converted to
0000000000000000000000000000000000000000;;	// HTTP headers in a response handled by grpc-gateway
0000000000000000000000000000000000000000;;	const MetadataTrailerPrefix = "Grpc-Trailer-"
0000000000000000000000000000000000000000;;	const metadataGrpcTimeout = "Grpc-Timeout"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const xForwardedFor = "X-Forwarded-For"
0000000000000000000000000000000000000000;;	const xForwardedHost = "X-Forwarded-Host"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// DefaultContextTimeout is used for gRPC call context.WithTimeout whenever a Grpc-Timeout inbound
0000000000000000000000000000000000000000;;		// header isn't present. If the value is 0 the sent `context` will not have a timeout.
0000000000000000000000000000000000000000;;		DefaultContextTimeout = 0 * time.Second
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	AnnotateContext adds context information such as metadata from the request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	At a minimum, the RemoteAddr is included in the fashion of "X-Forwarded-For",
0000000000000000000000000000000000000000;;	except that the forwarded destination is not another HTTP service but rather
0000000000000000000000000000000000000000;;	a gRPC service.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func AnnotateContext(ctx context.Context, req *http.Request) (context.Context, error) {
0000000000000000000000000000000000000000;;		var pairs []string
0000000000000000000000000000000000000000;;		timeout := DefaultContextTimeout
0000000000000000000000000000000000000000;;		if tm := req.Header.Get(metadataGrpcTimeout); tm != "" {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			timeout, err = timeoutDecode(tm)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, grpc.Errorf(codes.InvalidArgument, "invalid grpc-timeout: %s", tm)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, vals := range req.Header {
0000000000000000000000000000000000000000;;			for _, val := range vals {
0000000000000000000000000000000000000000;;				if key == "Authorization" {
0000000000000000000000000000000000000000;;					pairs = append(pairs, "authorization", val)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if strings.HasPrefix(key, MetadataHeaderPrefix) {
0000000000000000000000000000000000000000;;					pairs = append(pairs, key[len(MetadataHeaderPrefix):], val)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if host := req.Header.Get(xForwardedHost); host != "" {
0000000000000000000000000000000000000000;;			pairs = append(pairs, strings.ToLower(xForwardedHost), host)
0000000000000000000000000000000000000000;;		} else if req.Host != "" {
0000000000000000000000000000000000000000;;			pairs = append(pairs, strings.ToLower(xForwardedHost), req.Host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if addr := req.RemoteAddr; addr != "" {
0000000000000000000000000000000000000000;;			if remoteIP, _, err := net.SplitHostPort(addr); err == nil {
0000000000000000000000000000000000000000;;				if fwd := req.Header.Get(xForwardedFor); fwd == "" {
0000000000000000000000000000000000000000;;					pairs = append(pairs, strings.ToLower(xForwardedFor), remoteIP)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					pairs = append(pairs, strings.ToLower(xForwardedFor), fmt.Sprintf("%s, %s", fwd, remoteIP))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				grpclog.Printf("invalid remote addr: %s", addr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if timeout != 0 {
0000000000000000000000000000000000000000;;			ctx, _ = context.WithTimeout(ctx, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(pairs) == 0 {
0000000000000000000000000000000000000000;;			return ctx, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metadata.NewContext(ctx, metadata.Pairs(pairs...)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerMetadata consists of metadata sent from gRPC server.
0000000000000000000000000000000000000000;;	type ServerMetadata struct {
0000000000000000000000000000000000000000;;		HeaderMD  metadata.MD
0000000000000000000000000000000000000000;;		TrailerMD metadata.MD
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverMetadataKey struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServerMetadataContext creates a new context with ServerMetadata
0000000000000000000000000000000000000000;;	func NewServerMetadataContext(ctx context.Context, md ServerMetadata) context.Context {
0000000000000000000000000000000000000000;;		return context.WithValue(ctx, serverMetadataKey{}, md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerMetadataFromContext returns the ServerMetadata in ctx
0000000000000000000000000000000000000000;;	func ServerMetadataFromContext(ctx context.Context) (md ServerMetadata, ok bool) {
0000000000000000000000000000000000000000;;		md, ok = ctx.Value(serverMetadataKey{}).(ServerMetadata)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func timeoutDecode(s string) (time.Duration, error) {
0000000000000000000000000000000000000000;;		size := len(s)
0000000000000000000000000000000000000000;;		if size < 2 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("timeout string is too short: %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d, ok := timeoutUnitToDuration(s[size-1])
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("timeout unit is not recognized: %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, err := strconv.ParseInt(s[:size-1], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d * time.Duration(t), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func timeoutUnitToDuration(u uint8) (d time.Duration, ok bool) {
0000000000000000000000000000000000000000;;		switch u {
0000000000000000000000000000000000000000;;		case 'H':
0000000000000000000000000000000000000000;;			return time.Hour, true
0000000000000000000000000000000000000000;;		case 'M':
0000000000000000000000000000000000000000;;			return time.Minute, true
0000000000000000000000000000000000000000;;		case 'S':
0000000000000000000000000000000000000000;;			return time.Second, true
0000000000000000000000000000000000000000;;		case 'm':
0000000000000000000000000000000000000000;;			return time.Millisecond, true
0000000000000000000000000000000000000000;;		case 'u':
0000000000000000000000000000000000000000;;			return time.Microsecond, true
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			return time.Nanosecond, true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
