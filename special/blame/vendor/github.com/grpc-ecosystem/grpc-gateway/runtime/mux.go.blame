0000000000000000000000000000000000000000;;	package runtime
885071b7d07344044421ffe2fd90c1bcd1ee9812;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A HandlerFunc handles a specific pair of path pattern and HTTP method.
0000000000000000000000000000000000000000;;	type HandlerFunc func(w http.ResponseWriter, r *http.Request, pathParams map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeMux is a request multiplexer for grpc-gateway.
0000000000000000000000000000000000000000;;	// It matches http requests to patterns and invokes the corresponding handler.
0000000000000000000000000000000000000000;;	type ServeMux struct {
0000000000000000000000000000000000000000;;		// handlers maps HTTP method to a list of handlers.
0000000000000000000000000000000000000000;;		handlers               map[string][]handler
0000000000000000000000000000000000000000;;		forwardResponseOptions []func(context.Context, http.ResponseWriter, proto.Message) error
0000000000000000000000000000000000000000;;		marshalers             marshalerRegistry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeMuxOption is an option that can be given to a ServeMux on construction.
0000000000000000000000000000000000000000;;	type ServeMuxOption func(*ServeMux)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithForwardResponseOption returns a ServeMuxOption representing the forwardResponseOption.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// forwardResponseOption is an option that will be called on the relevant context.Context,
0000000000000000000000000000000000000000;;	// http.ResponseWriter, and proto.Message before every forwarded response.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The message may be nil in the case where just a header is being sent.
0000000000000000000000000000000000000000;;	func WithForwardResponseOption(forwardResponseOption func(context.Context, http.ResponseWriter, proto.Message) error) ServeMuxOption {
0000000000000000000000000000000000000000;;		return func(serveMux *ServeMux) {
0000000000000000000000000000000000000000;;			serveMux.forwardResponseOptions = append(serveMux.forwardResponseOptions, forwardResponseOption)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServeMux returns a new ServeMux whose internal mapping is empty.
0000000000000000000000000000000000000000;;	func NewServeMux(opts ...ServeMuxOption) *ServeMux {
0000000000000000000000000000000000000000;;		serveMux := &ServeMux{
0000000000000000000000000000000000000000;;			handlers:               make(map[string][]handler),
0000000000000000000000000000000000000000;;			forwardResponseOptions: make([]func(context.Context, http.ResponseWriter, proto.Message) error, 0),
0000000000000000000000000000000000000000;;			marshalers:             makeMarshalerMIMERegistry(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, opt := range opts {
0000000000000000000000000000000000000000;;			opt(serveMux)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return serveMux
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle associates "h" to the pair of HTTP method and path pattern.
0000000000000000000000000000000000000000;;	func (s *ServeMux) Handle(meth string, pat Pattern, h HandlerFunc) {
0000000000000000000000000000000000000000;;		s.handlers[meth] = append(s.handlers[meth], handler{pat: pat, h: h})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP dispatches the request to the first handler whose pattern matches to r.Method and r.Path.
0000000000000000000000000000000000000000;;	func (s *ServeMux) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		path := r.URL.Path
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(path, "/") {
0000000000000000000000000000000000000000;;			OtherErrorHandler(w, r, http.StatusText(http.StatusBadRequest), http.StatusBadRequest)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		components := strings.Split(path[1:], "/")
0000000000000000000000000000000000000000;;		l := len(components)
0000000000000000000000000000000000000000;;		var verb string
0000000000000000000000000000000000000000;;		if idx := strings.LastIndex(components[l-1], ":"); idx == 0 {
0000000000000000000000000000000000000000;;			OtherErrorHandler(w, r, http.StatusText(http.StatusNotFound), http.StatusNotFound)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		} else if idx > 0 {
0000000000000000000000000000000000000000;;			c := components[l-1]
0000000000000000000000000000000000000000;;			components[l-1], verb = c[:idx], c[idx+1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if override := r.Header.Get("X-HTTP-Method-Override"); override != "" && isPathLengthFallback(r) {
0000000000000000000000000000000000000000;;			r.Method = strings.ToUpper(override)
0000000000000000000000000000000000000000;;			if err := r.ParseForm(); err != nil {
0000000000000000000000000000000000000000;;				OtherErrorHandler(w, r, err.Error(), http.StatusBadRequest)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, h := range s.handlers[r.Method] {
0000000000000000000000000000000000000000;;			pathParams, err := h.pat.Match(components, verb)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.h(w, r, pathParams)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// lookup other methods to handle fallback from GET to POST and
0000000000000000000000000000000000000000;;		// to determine if it is MethodNotAllowed or NotFound.
0000000000000000000000000000000000000000;;		for m, handlers := range s.handlers {
0000000000000000000000000000000000000000;;			if m == r.Method {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, h := range handlers {
0000000000000000000000000000000000000000;;				pathParams, err := h.pat.Match(components, verb)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// X-HTTP-Method-Override is optional. Always allow fallback to POST.
0000000000000000000000000000000000000000;;				if isPathLengthFallback(r) {
0000000000000000000000000000000000000000;;					if err := r.ParseForm(); err != nil {
0000000000000000000000000000000000000000;;						OtherErrorHandler(w, r, err.Error(), http.StatusBadRequest)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					h.h(w, r, pathParams)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				OtherErrorHandler(w, r, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		OtherErrorHandler(w, r, http.StatusText(http.StatusNotFound), http.StatusNotFound)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetForwardResponseOptions returns the ForwardResponseOptions associated with this ServeMux.
0000000000000000000000000000000000000000;;	func (s *ServeMux) GetForwardResponseOptions() []func(context.Context, http.ResponseWriter, proto.Message) error {
0000000000000000000000000000000000000000;;		return s.forwardResponseOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isPathLengthFallback(r *http.Request) bool {
0000000000000000000000000000000000000000;;		return r.Method == "POST" && r.Header.Get("Content-Type") == "application/x-www-form-urlencoded"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type handler struct {
0000000000000000000000000000000000000000;;		pat Pattern
0000000000000000000000000000000000000000;;		h   HandlerFunc
0000000000000000000000000000000000000000;;	}
