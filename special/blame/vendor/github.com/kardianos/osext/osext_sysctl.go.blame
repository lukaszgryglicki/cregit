0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
8bf96f60ebe71bf5a86b9d9176b6678b12f558f8;Godeps/_workspace/src/github.com/kardianos/osext/osext_sysctl.go[Godeps/_workspace/src/github.com/kardianos/osext/osext_sysctl.go][vendor/github.com/kardianos/osext/osext_sysctl.go];	
0000000000000000000000000000000000000000;;	// +build darwin freebsd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package osext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var initCwd, initCwdErr = os.Getwd()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func executable() (string, error) {
0000000000000000000000000000000000000000;;		var mib [4]int32
0000000000000000000000000000000000000000;;		switch runtime.GOOS {
0000000000000000000000000000000000000000;;		case "freebsd":
0000000000000000000000000000000000000000;;			mib = [4]int32{1 /* CTL_KERN */, 14 /* KERN_PROC */, 12 /* KERN_PROC_PATHNAME */, -1}
0000000000000000000000000000000000000000;;		case "darwin":
0000000000000000000000000000000000000000;;			mib = [4]int32{1 /* CTL_KERN */, 38 /* KERN_PROCARGS */, int32(os.Getpid()), -1}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := uintptr(0)
0000000000000000000000000000000000000000;;		// Get length.
0000000000000000000000000000000000000000;;		_, _, errNum := syscall.Syscall6(syscall.SYS___SYSCTL, uintptr(unsafe.Pointer(&mib[0])), 4, 0, uintptr(unsafe.Pointer(&n)), 0, 0)
0000000000000000000000000000000000000000;;		if errNum != 0 {
0000000000000000000000000000000000000000;;			return "", errNum
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == 0 { // This shouldn't happen.
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := make([]byte, n)
0000000000000000000000000000000000000000;;		_, _, errNum = syscall.Syscall6(syscall.SYS___SYSCTL, uintptr(unsafe.Pointer(&mib[0])), 4, uintptr(unsafe.Pointer(&buf[0])), uintptr(unsafe.Pointer(&n)), 0, 0)
0000000000000000000000000000000000000000;;		if errNum != 0 {
0000000000000000000000000000000000000000;;			return "", errNum
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == 0 { // This shouldn't happen.
0000000000000000000000000000000000000000;;			return "", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range buf {
0000000000000000000000000000000000000000;;			if v == 0 {
0000000000000000000000000000000000000000;;				buf = buf[:i]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		execPath := string(buf)
0000000000000000000000000000000000000000;;		// execPath will not be empty due to above checks.
0000000000000000000000000000000000000000;;		// Try to get the absolute path if the execPath is not rooted.
0000000000000000000000000000000000000000;;		if execPath[0] != '/' {
0000000000000000000000000000000000000000;;			execPath, err = getAbs(execPath)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return execPath, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// For darwin KERN_PROCARGS may return the path to a symlink rather than the
0000000000000000000000000000000000000000;;		// actual executable.
0000000000000000000000000000000000000000;;		if runtime.GOOS == "darwin" {
0000000000000000000000000000000000000000;;			if execPath, err = filepath.EvalSymlinks(execPath); err != nil {
0000000000000000000000000000000000000000;;				return execPath, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return execPath, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getAbs(execPath string) (string, error) {
0000000000000000000000000000000000000000;;		if initCwdErr != nil {
0000000000000000000000000000000000000000;;			return execPath, initCwdErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The execPath may begin with a "../" or a "./" so clean it first.
0000000000000000000000000000000000000000;;		// Join the two paths, trailing and starting slashes undetermined, so use
0000000000000000000000000000000000000000;;		// the generic Join function.
0000000000000000000000000000000000000000;;		return filepath.Join(initCwd, filepath.Clean(execPath)), nil
0000000000000000000000000000000000000000;;	}
