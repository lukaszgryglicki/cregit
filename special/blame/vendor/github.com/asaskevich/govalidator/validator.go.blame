0000000000000000000000000000000000000000;;	// Package govalidator is package of validators and sanitizers for strings, structs and collections.
0000000000000000000000000000000000000000;;	package govalidator
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fieldsRequiredByDefault bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetFieldsRequiredByDefault causes validation to fail when struct fields
0000000000000000000000000000000000000000;;	// do not include validations or are not explicitly marked as exempt (using `valid:"-"` or `valid:"email,optional"`).
0000000000000000000000000000000000000000;;	// This struct definition will fail govalidator.ValidateStruct() (and the field values do not matter):
0000000000000000000000000000000000000000;;	//     type exampleStruct struct {
0000000000000000000000000000000000000000;;	//         Name  string ``
0000000000000000000000000000000000000000;;	//         Email string `valid:"email"`
0000000000000000000000000000000000000000;;	// This, however, will only fail when Email is empty or an invalid email address:
0000000000000000000000000000000000000000;;	//     type exampleStruct2 struct {
0000000000000000000000000000000000000000;;	//         Name  string `valid:"-"`
0000000000000000000000000000000000000000;;	//         Email string `valid:"email"`
0000000000000000000000000000000000000000;;	// Lastly, this will only fail when Email is an invalid email address but not when it's empty:
0000000000000000000000000000000000000000;;	//     type exampleStruct2 struct {
0000000000000000000000000000000000000000;;	//         Name  string `valid:"-"`
0000000000000000000000000000000000000000;;	//         Email string `valid:"email,optional"`
0000000000000000000000000000000000000000;;	func SetFieldsRequiredByDefault(value bool) {
0000000000000000000000000000000000000000;;		fieldsRequiredByDefault = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmail check if the string is an email.
0000000000000000000000000000000000000000;;	func IsEmail(str string) bool {
0000000000000000000000000000000000000000;;		// TODO uppercase letters are not supported
0000000000000000000000000000000000000000;;		return rxEmail.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsURL check if the string is an URL.
0000000000000000000000000000000000000000;;	func IsURL(str string) bool {
0000000000000000000000000000000000000000;;		if str == "" || len(str) >= 2083 || len(str) <= 3 || strings.HasPrefix(str, ".") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u, err := url.Parse(str)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.HasPrefix(u.Host, ".") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.Host == "" && (u.Path != "" && !strings.Contains(u.Path, ".")) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxURL.MatchString(str)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRequestURL check if the string rawurl, assuming
0000000000000000000000000000000000000000;;	// it was recieved in an HTTP request, is a valid
0000000000000000000000000000000000000000;;	// URL confirm to RFC 3986
0000000000000000000000000000000000000000;;	func IsRequestURL(rawurl string) bool {
0000000000000000000000000000000000000000;;		url, err := url.ParseRequestURI(rawurl)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false //Couldn't even parse the rawurl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(url.Scheme) == 0 {
0000000000000000000000000000000000000000;;			return false //No Scheme found
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRequestURI check if the string rawurl, assuming
0000000000000000000000000000000000000000;;	// it was recieved in an HTTP request, is an
0000000000000000000000000000000000000000;;	// absolute URI or an absolute path.
0000000000000000000000000000000000000000;;	func IsRequestURI(rawurl string) bool {
0000000000000000000000000000000000000000;;		_, err := url.ParseRequestURI(rawurl)
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAlpha check if the string contains only letters (a-zA-Z). Empty string is valid.
0000000000000000000000000000000000000000;;	func IsAlpha(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxAlpha.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//IsUTFLetter check if the string contains only unicode letter characters.
0000000000000000000000000000000000000000;;	//Similar to IsAlpha but for all languages. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsUTFLetter(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range str {
0000000000000000000000000000000000000000;;			if !unicode.IsLetter(c) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsAlphanumeric check if the string contains only letters and numbers. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsAlphanumeric(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxAlphanumeric.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUTFLetterNumeric check if the string contains only unicode letters and numbers. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsUTFLetterNumeric(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range str {
0000000000000000000000000000000000000000;;			if !unicode.IsLetter(c) && !unicode.IsNumber(c) { //letters && numbers are ok
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNumeric check if the string contains only numbers. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsNumeric(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxNumeric.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUTFNumeric check if the string contains only unicode numbers of any kind.
0000000000000000000000000000000000000000;;	// Numbers can be 0-9 but also Fractions ¾,Roman Ⅸ and Hangzhou 〩. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsUTFNumeric(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.IndexAny(str, "+-") > 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(str) > 1 {
0000000000000000000000000000000000000000;;			str = strings.TrimPrefix(str, "-")
0000000000000000000000000000000000000000;;			str = strings.TrimPrefix(str, "+")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range str {
0000000000000000000000000000000000000000;;			if unicode.IsNumber(c) == false { //numbers && minus sign are ok
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUTFDigit check if the string contains only unicode radix-10 decimal digits. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsUTFDigit(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.IndexAny(str, "+-") > 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(str) > 1 {
0000000000000000000000000000000000000000;;			str = strings.TrimPrefix(str, "-")
0000000000000000000000000000000000000000;;			str = strings.TrimPrefix(str, "+")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range str {
0000000000000000000000000000000000000000;;			if !unicode.IsDigit(c) { //digits && minus sign are ok
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHexadecimal check if the string is a hexadecimal number.
0000000000000000000000000000000000000000;;	func IsHexadecimal(str string) bool {
0000000000000000000000000000000000000000;;		return rxHexadecimal.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHexcolor check if the string is a hexadecimal color.
0000000000000000000000000000000000000000;;	func IsHexcolor(str string) bool {
0000000000000000000000000000000000000000;;		return rxHexcolor.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRGBcolor check if the string is a valid RGB color in form rgb(RRR, GGG, BBB).
0000000000000000000000000000000000000000;;	func IsRGBcolor(str string) bool {
0000000000000000000000000000000000000000;;		return rxRGBcolor.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLowerCase check if the string is lowercase. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsLowerCase(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str == strings.ToLower(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUpperCase check if the string is uppercase. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsUpperCase(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str == strings.ToUpper(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsInt check if the string is an integer. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsInt(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxInt.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFloat check if the string is a float.
0000000000000000000000000000000000000000;;	func IsFloat(str string) bool {
0000000000000000000000000000000000000000;;		return str != "" && rxFloat.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDivisibleBy check if the string is a number that's divisible by another.
0000000000000000000000000000000000000000;;	// If second argument is not valid integer or zero, it's return false.
0000000000000000000000000000000000000000;;	// Otherwise, if first argument is not valid integer or zero, it's return true (Invalid string converts to zero).
0000000000000000000000000000000000000000;;	func IsDivisibleBy(str, num string) bool {
0000000000000000000000000000000000000000;;		f, _ := ToFloat(str)
0000000000000000000000000000000000000000;;		p := int64(f)
0000000000000000000000000000000000000000;;		q, _ := ToInt(num)
0000000000000000000000000000000000000000;;		if q == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (p == 0) || (p%q == 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsNull check if the string is null.
0000000000000000000000000000000000000000;;	func IsNull(str string) bool {
0000000000000000000000000000000000000000;;		return len(str) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsByteLength check if the string's length (in bytes) falls in a range.
0000000000000000000000000000000000000000;;	func IsByteLength(str string, min, max int) bool {
0000000000000000000000000000000000000000;;		return len(str) >= min && len(str) <= max
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUUIDv3 check if the string is a UUID version 3.
0000000000000000000000000000000000000000;;	func IsUUIDv3(str string) bool {
0000000000000000000000000000000000000000;;		return rxUUID3.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUUIDv4 check if the string is a UUID version 4.
0000000000000000000000000000000000000000;;	func IsUUIDv4(str string) bool {
0000000000000000000000000000000000000000;;		return rxUUID4.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUUIDv5 check if the string is a UUID version 5.
0000000000000000000000000000000000000000;;	func IsUUIDv5(str string) bool {
0000000000000000000000000000000000000000;;		return rxUUID5.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsUUID check if the string is a UUID (version 3, 4 or 5).
0000000000000000000000000000000000000000;;	func IsUUID(str string) bool {
0000000000000000000000000000000000000000;;		return rxUUID.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsCreditCard check if the string is a credit card.
0000000000000000000000000000000000000000;;	func IsCreditCard(str string) bool {
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile("[^0-9]+")
0000000000000000000000000000000000000000;;		sanitized := r.ReplaceAll([]byte(str), []byte(""))
0000000000000000000000000000000000000000;;		if !rxCreditCard.MatchString(string(sanitized)) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var sum int64
0000000000000000000000000000000000000000;;		var digit string
0000000000000000000000000000000000000000;;		var tmpNum int64
0000000000000000000000000000000000000000;;		var shouldDouble bool
0000000000000000000000000000000000000000;;		for i := len(sanitized) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			digit = string(sanitized[i:(i + 1)])
0000000000000000000000000000000000000000;;			tmpNum, _ = ToInt(digit)
0000000000000000000000000000000000000000;;			if shouldDouble {
0000000000000000000000000000000000000000;;				tmpNum *= 2
0000000000000000000000000000000000000000;;				if tmpNum >= 10 {
0000000000000000000000000000000000000000;;					sum += ((tmpNum % 10) + 1)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					sum += tmpNum
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sum += tmpNum
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			shouldDouble = !shouldDouble
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sum%10 == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsISBN10 check if the string is an ISBN version 10.
0000000000000000000000000000000000000000;;	func IsISBN10(str string) bool {
0000000000000000000000000000000000000000;;		return IsISBN(str, 10)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsISBN13 check if the string is an ISBN version 13.
0000000000000000000000000000000000000000;;	func IsISBN13(str string) bool {
0000000000000000000000000000000000000000;;		return IsISBN(str, 13)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsISBN check if the string is an ISBN (version 10 or 13).
0000000000000000000000000000000000000000;;	// If version value is not equal to 10 or 13, it will be check both variants.
0000000000000000000000000000000000000000;;	func IsISBN(str string, version int) bool {
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile("[\\s-]+")
0000000000000000000000000000000000000000;;		sanitized := r.ReplaceAll([]byte(str), []byte(""))
0000000000000000000000000000000000000000;;		var checksum int32
0000000000000000000000000000000000000000;;		var i int32
0000000000000000000000000000000000000000;;		if version == 10 {
0000000000000000000000000000000000000000;;			if !rxISBN10.MatchString(string(sanitized)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i = 0; i < 9; i++ {
0000000000000000000000000000000000000000;;				checksum += (i + 1) * int32(sanitized[i]-'0')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sanitized[9] == 'X' {
0000000000000000000000000000000000000000;;				checksum += 10 * 10
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				checksum += 10 * int32(sanitized[9]-'0')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if checksum%11 == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		} else if version == 13 {
0000000000000000000000000000000000000000;;			if !rxISBN13.MatchString(string(sanitized)) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			factor := []int32{1, 3}
0000000000000000000000000000000000000000;;			for i = 0; i < 12; i++ {
0000000000000000000000000000000000000000;;				checksum += factor[i%2] * int32(sanitized[i]-'0')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if (int32(sanitized[12]-'0'))-((10-(checksum%10))%10) == 0 {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return IsISBN(str, 10) || IsISBN(str, 13)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsJSON check if the string is valid JSON (note: uses json.Unmarshal).
0000000000000000000000000000000000000000;;	func IsJSON(str string) bool {
0000000000000000000000000000000000000000;;		var js json.RawMessage
0000000000000000000000000000000000000000;;		return json.Unmarshal([]byte(str), &js) == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsMultibyte check if the string contains one or more multibyte chars. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsMultibyte(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxMultibyte.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsASCII check if the string contains ASCII chars only. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsASCII(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxASCII.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPrintableASCII check if the string contains printable ASCII chars only. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsPrintableASCII(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxPrintableASCII.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFullWidth check if the string contains any full-width chars. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsFullWidth(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxFullWidth.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHalfWidth check if the string contains any half-width chars. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsHalfWidth(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxHalfWidth.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsVariableWidth check if the string contains a mixture of full and half-width chars. Empty string is valid.
0000000000000000000000000000000000000000;;	func IsVariableWidth(str string) bool {
0000000000000000000000000000000000000000;;		if IsNull(str) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxHalfWidth.MatchString(str) && rxFullWidth.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsBase64 check if a string is base64 encoded.
0000000000000000000000000000000000000000;;	func IsBase64(str string) bool {
0000000000000000000000000000000000000000;;		return rxBase64.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFilePath check is a string is Win or Unix file path and returns it's type.
0000000000000000000000000000000000000000;;	func IsFilePath(str string) (bool, int) {
0000000000000000000000000000000000000000;;		if rxWinPath.MatchString(str) {
0000000000000000000000000000000000000000;;			//check windows path limit see:
0000000000000000000000000000000000000000;;			//  http://msdn.microsoft.com/en-us/library/aa365247(VS.85).aspx#maxpath
0000000000000000000000000000000000000000;;			if len(str[3:]) > 32767 {
0000000000000000000000000000000000000000;;				return false, Win
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, Win
0000000000000000000000000000000000000000;;		} else if rxUnixPath.MatchString(str) {
0000000000000000000000000000000000000000;;			return true, Unix
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, Unknown
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDataURI checks if a string is base64 encoded data URI such as an image
0000000000000000000000000000000000000000;;	func IsDataURI(str string) bool {
0000000000000000000000000000000000000000;;		dataURI := strings.Split(str, ",")
0000000000000000000000000000000000000000;;		if !rxDataURI.MatchString(dataURI[0]) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return IsBase64(dataURI[1])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsISO3166Alpha2 checks if a string is valid two-letter country code
0000000000000000000000000000000000000000;;	func IsISO3166Alpha2(str string) bool {
0000000000000000000000000000000000000000;;		for _, entry := range ISO3166List {
0000000000000000000000000000000000000000;;			if str == entry.Alpha2Code {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsISO3166Alpha3 checks if a string is valid three-letter country code
0000000000000000000000000000000000000000;;	func IsISO3166Alpha3(str string) bool {
0000000000000000000000000000000000000000;;		for _, entry := range ISO3166List {
0000000000000000000000000000000000000000;;			if str == entry.Alpha3Code {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDNSName will validate the given string as a DNS name
0000000000000000000000000000000000000000;;	func IsDNSName(str string) bool {
0000000000000000000000000000000000000000;;		if str == "" || len(strings.Replace(str, ".", "", -1)) > 255 {
0000000000000000000000000000000000000000;;			// constraints already violated
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxDNSName.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDialString validates the given string for usage with the various Dial() functions
0000000000000000000000000000000000000000;;	func IsDialString(str string) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h, p, err := net.SplitHostPort(str); err == nil && h != "" && p != "" && (IsDNSName(h) || IsIP(h)) && IsPort(p) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsIP checks if a string is either IP version 4 or 6.
0000000000000000000000000000000000000000;;	func IsIP(str string) bool {
0000000000000000000000000000000000000000;;		return net.ParseIP(str) != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsPort checks if a string represents a valid port
0000000000000000000000000000000000000000;;	func IsPort(str string) bool {
0000000000000000000000000000000000000000;;		if i, err := strconv.Atoi(str); err == nil && i > 0 && i < 65536 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsIPv4 check if the string is an IP version 4.
0000000000000000000000000000000000000000;;	func IsIPv4(str string) bool {
0000000000000000000000000000000000000000;;		ip := net.ParseIP(str)
0000000000000000000000000000000000000000;;		return ip != nil && strings.Contains(str, ".")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsIPv6 check if the string is an IP version 6.
0000000000000000000000000000000000000000;;	func IsIPv6(str string) bool {
0000000000000000000000000000000000000000;;		ip := net.ParseIP(str)
0000000000000000000000000000000000000000;;		return ip != nil && strings.Contains(str, ":")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsMAC check if a string is valid MAC address.
0000000000000000000000000000000000000000;;	// Possible MAC formats:
0000000000000000000000000000000000000000;;	// 01:23:45:67:89:ab
0000000000000000000000000000000000000000;;	// 01:23:45:67:89:ab:cd:ef
0000000000000000000000000000000000000000;;	// 01-23-45-67-89-ab
0000000000000000000000000000000000000000;;	// 01-23-45-67-89-ab-cd-ef
0000000000000000000000000000000000000000;;	// 0123.4567.89ab
0000000000000000000000000000000000000000;;	// 0123.4567.89ab.cdef
0000000000000000000000000000000000000000;;	func IsMAC(str string) bool {
0000000000000000000000000000000000000000;;		_, err := net.ParseMAC(str)
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsHost checks if the string is a valid IP (both v4 and v6) or a valid DNS name
0000000000000000000000000000000000000000;;	func IsHost(str string) bool {
0000000000000000000000000000000000000000;;		return IsIP(str) || IsDNSName(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsMongoID check if the string is a valid hex-encoded representation of a MongoDB ObjectId.
0000000000000000000000000000000000000000;;	func IsMongoID(str string) bool {
0000000000000000000000000000000000000000;;		return rxHexadecimal.MatchString(str) && (len(str) == 24)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLatitude check if a string is valid latitude.
0000000000000000000000000000000000000000;;	func IsLatitude(str string) bool {
0000000000000000000000000000000000000000;;		return rxLatitude.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLongitude check if a string is valid longitude.
0000000000000000000000000000000000000000;;	func IsLongitude(str string) bool {
0000000000000000000000000000000000000000;;		return rxLongitude.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidateStruct use tags for fields.
0000000000000000000000000000000000000000;;	// result will be equal to `false` if there are any errors.
0000000000000000000000000000000000000000;;	func ValidateStruct(s interface{}) (bool, error) {
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := true
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(s)
0000000000000000000000000000000000000000;;		if val.Kind() == reflect.Interface || val.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			val = val.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// we only accept structs
0000000000000000000000000000000000000000;;		if val.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("function only accepts structs; got %s", val.Kind())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var errs Errors
0000000000000000000000000000000000000000;;		for i := 0; i < val.NumField(); i++ {
0000000000000000000000000000000000000000;;			valueField := val.Field(i)
0000000000000000000000000000000000000000;;			typeField := val.Type().Field(i)
0000000000000000000000000000000000000000;;			if typeField.PkgPath != "" {
0000000000000000000000000000000000000000;;				continue // Private field
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resultField, err2 := typeCheck(valueField, typeField, val)
0000000000000000000000000000000000000000;;			if err2 != nil {
0000000000000000000000000000000000000000;;				errs = append(errs, err2)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = result && resultField
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(errs) > 0 {
0000000000000000000000000000000000000000;;			err = errs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseTagIntoMap parses a struct tag `valid:required~Some error message,length(2|3)` into map[string]string{"required": "Some error message", "length(2|3)": ""}
0000000000000000000000000000000000000000;;	func parseTagIntoMap(tag string) tagOptionsMap {
0000000000000000000000000000000000000000;;		optionsMap := make(tagOptionsMap)
0000000000000000000000000000000000000000;;		options := strings.SplitN(tag, ",", -1)
0000000000000000000000000000000000000000;;		for _, option := range options {
0000000000000000000000000000000000000000;;			validationOptions := strings.Split(option, "~")
0000000000000000000000000000000000000000;;			if !isValidTag(validationOptions[0]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(validationOptions) == 2 {
0000000000000000000000000000000000000000;;				optionsMap[validationOptions[0]] = validationOptions[1]
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				optionsMap[validationOptions[0]] = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return optionsMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isValidTag(s string) bool {
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range s {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case strings.ContainsRune("!#$%&()*+-./:<=>?@[]^_{|}~ ", c):
0000000000000000000000000000000000000000;;				// Backslash and quote chars are reserved, but
0000000000000000000000000000000000000000;;				// otherwise any punctuation chars are allowed
0000000000000000000000000000000000000000;;				// in a tag name.
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if !unicode.IsLetter(c) && !unicode.IsDigit(c) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSSN will validate the given string as a U.S. Social Security Number
0000000000000000000000000000000000000000;;	func IsSSN(str string) bool {
0000000000000000000000000000000000000000;;		if str == "" || len(str) != 11 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rxSSN.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSemver check if string is valid semantic version
0000000000000000000000000000000000000000;;	func IsSemver(str string) bool {
0000000000000000000000000000000000000000;;		return rxSemver.MatchString(str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByteLength check string's length
0000000000000000000000000000000000000000;;	func ByteLength(str string, params ...string) bool {
0000000000000000000000000000000000000000;;		if len(params) == 2 {
0000000000000000000000000000000000000000;;			min, _ := ToInt(params[0])
0000000000000000000000000000000000000000;;			max, _ := ToInt(params[1])
0000000000000000000000000000000000000000;;			return len(str) >= int(min) && len(str) <= int(max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringMatches checks if a string matches a given pattern.
0000000000000000000000000000000000000000;;	func StringMatches(s string, params ...string) bool {
0000000000000000000000000000000000000000;;		if len(params) == 1 {
0000000000000000000000000000000000000000;;			pattern := params[0]
0000000000000000000000000000000000000000;;			return Matches(s, pattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringLength check string's length (including multi byte strings)
0000000000000000000000000000000000000000;;	func StringLength(str string, params ...string) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(params) == 2 {
0000000000000000000000000000000000000000;;			strLength := utf8.RuneCountInString(str)
0000000000000000000000000000000000000000;;			min, _ := ToInt(params[0])
0000000000000000000000000000000000000000;;			max, _ := ToInt(params[1])
0000000000000000000000000000000000000000;;			return strLength >= int(min) && strLength <= int(max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkRequired(v reflect.Value, t reflect.StructField, options tagOptionsMap) (bool, error) {
0000000000000000000000000000000000000000;;		if requiredOption, isRequired := options["required"]; isRequired {
0000000000000000000000000000000000000000;;			if len(requiredOption) > 0 {
0000000000000000000000000000000000000000;;				return false, Error{t.Name, fmt.Errorf(requiredOption), true}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, Error{t.Name, fmt.Errorf("non zero value required"), false}
0000000000000000000000000000000000000000;;		} else if _, isOptional := options["optional"]; fieldsRequiredByDefault && !isOptional {
0000000000000000000000000000000000000000;;			return false, Error{t.Name, fmt.Errorf("All fields are required to at least have one validation defined"), false}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// not required and empty is valid
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func typeCheck(v reflect.Value, t reflect.StructField, o reflect.Value) (bool, error) {
0000000000000000000000000000000000000000;;		if !v.IsValid() {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tag := t.Tag.Get(tagName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the field should be ignored
0000000000000000000000000000000000000000;;		switch tag {
0000000000000000000000000000000000000000;;		case "":
0000000000000000000000000000000000000000;;			if !fieldsRequiredByDefault {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false, Error{t.Name, fmt.Errorf("All fields are required to at least have one validation defined"), false}
0000000000000000000000000000000000000000;;		case "-":
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options := parseTagIntoMap(tag)
0000000000000000000000000000000000000000;;		var customTypeErrors Errors
0000000000000000000000000000000000000000;;		var customTypeValidatorsExist bool
0000000000000000000000000000000000000000;;		for validatorName, customErrorMessage := range options {
0000000000000000000000000000000000000000;;			if validatefunc, ok := CustomTypeTagMap.Get(validatorName); ok {
0000000000000000000000000000000000000000;;				customTypeValidatorsExist = true
0000000000000000000000000000000000000000;;				if result := validatefunc(v.Interface(), o.Interface()); !result {
0000000000000000000000000000000000000000;;					if len(customErrorMessage) > 0 {
0000000000000000000000000000000000000000;;						customTypeErrors = append(customTypeErrors, Error{Name: t.Name, Err: fmt.Errorf(customErrorMessage), CustomErrorMessageExists: true})
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					customTypeErrors = append(customTypeErrors, Error{Name: t.Name, Err: fmt.Errorf("%s does not validate as %s", fmt.Sprint(v), validatorName), CustomErrorMessageExists: false})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if customTypeValidatorsExist {
0000000000000000000000000000000000000000;;			if len(customTypeErrors.Errors()) > 0 {
0000000000000000000000000000000000000000;;				return false, customTypeErrors
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isEmptyValue(v) {
0000000000000000000000000000000000000000;;			// an empty value is not validated, check only required
0000000000000000000000000000000000000000;;			return checkRequired(v, t, options)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool,
0000000000000000000000000000000000000000;;			reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64,
0000000000000000000000000000000000000000;;			reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr,
0000000000000000000000000000000000000000;;			reflect.Float32, reflect.Float64,
0000000000000000000000000000000000000000;;			reflect.String:
0000000000000000000000000000000000000000;;			// for each tag option check the map of validator functions
0000000000000000000000000000000000000000;;			for validator, customErrorMessage := range options {
0000000000000000000000000000000000000000;;				var negate bool
0000000000000000000000000000000000000000;;				customMsgExists := (len(customErrorMessage) > 0)
0000000000000000000000000000000000000000;;				// Check wether the tag looks like '!something' or 'something'
0000000000000000000000000000000000000000;;				if validator[0] == '!' {
0000000000000000000000000000000000000000;;					validator = string(validator[1:])
0000000000000000000000000000000000000000;;					negate = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check for param validators
0000000000000000000000000000000000000000;;				for key, value := range ParamTagRegexMap {
0000000000000000000000000000000000000000;;					ps := value.FindStringSubmatch(validator)
0000000000000000000000000000000000000000;;					if len(ps) > 0 {
0000000000000000000000000000000000000000;;						if validatefunc, ok := ParamTagMap[key]; ok {
0000000000000000000000000000000000000000;;							switch v.Kind() {
0000000000000000000000000000000000000000;;							case reflect.String:
0000000000000000000000000000000000000000;;								field := fmt.Sprint(v) // make value into string, then validate with regex
0000000000000000000000000000000000000000;;								if result := validatefunc(field, ps[1:]...); (!result && !negate) || (result && negate) {
0000000000000000000000000000000000000000;;									var err error
0000000000000000000000000000000000000000;;									if !negate {
0000000000000000000000000000000000000000;;										if customMsgExists {
0000000000000000000000000000000000000000;;											err = fmt.Errorf(customErrorMessage)
0000000000000000000000000000000000000000;;										} else {
0000000000000000000000000000000000000000;;											err = fmt.Errorf("%s does not validate as %s", field, validator)
0000000000000000000000000000000000000000;;										}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;									} else {
0000000000000000000000000000000000000000;;										if customMsgExists {
0000000000000000000000000000000000000000;;											err = fmt.Errorf(customErrorMessage)
0000000000000000000000000000000000000000;;										} else {
0000000000000000000000000000000000000000;;											err = fmt.Errorf("%s does validate as %s", field, validator)
0000000000000000000000000000000000000000;;										}
0000000000000000000000000000000000000000;;									}
0000000000000000000000000000000000000000;;									return false, Error{t.Name, err, customMsgExists}
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							default:
0000000000000000000000000000000000000000;;								// type not yet supported, fail
0000000000000000000000000000000000000000;;								return false, Error{t.Name, fmt.Errorf("Validator %s doesn't support kind %s", validator, v.Kind()), false}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if validatefunc, ok := TagMap[validator]; ok {
0000000000000000000000000000000000000000;;					switch v.Kind() {
0000000000000000000000000000000000000000;;					case reflect.String:
0000000000000000000000000000000000000000;;						field := fmt.Sprint(v) // make value into string, then validate with regex
0000000000000000000000000000000000000000;;						if result := validatefunc(field); !result && !negate || result && negate {
0000000000000000000000000000000000000000;;							var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							if !negate {
0000000000000000000000000000000000000000;;								if customMsgExists {
0000000000000000000000000000000000000000;;									err = fmt.Errorf(customErrorMessage)
0000000000000000000000000000000000000000;;								} else {
0000000000000000000000000000000000000000;;									err = fmt.Errorf("%s does not validate as %s", field, validator)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								if customMsgExists {
0000000000000000000000000000000000000000;;									err = fmt.Errorf(customErrorMessage)
0000000000000000000000000000000000000000;;								} else {
0000000000000000000000000000000000000000;;									err = fmt.Errorf("%s does validate as %s", field, validator)
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							return false, Error{t.Name, err, customMsgExists}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						//Not Yet Supported Types (Fail here!)
0000000000000000000000000000000000000000;;						err := fmt.Errorf("Validator %s doesn't support kind %s for value %v", validator, v.Kind(), v)
0000000000000000000000000000000000000000;;						return false, Error{t.Name, err, false}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if v.Type().Key().Kind() != reflect.String {
0000000000000000000000000000000000000000;;				return false, &UnsupportedTypeError{v.Type()}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var sv stringValues
0000000000000000000000000000000000000000;;			sv = v.MapKeys()
0000000000000000000000000000000000000000;;			sort.Sort(sv)
0000000000000000000000000000000000000000;;			result := true
0000000000000000000000000000000000000000;;			for _, k := range sv {
0000000000000000000000000000000000000000;;				resultItem, err := ValidateStruct(v.MapIndex(k).Interface())
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return false, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = result && resultItem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			result := true
0000000000000000000000000000000000000000;;			for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;				var resultItem bool
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if v.Index(i).Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;					resultItem, err = typeCheck(v.Index(i), t, o)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					resultItem, err = ValidateStruct(v.Index(i).Interface())
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = result && resultItem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			result := true
0000000000000000000000000000000000000000;;			for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;				var resultItem bool
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				if v.Index(i).Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;					resultItem, err = typeCheck(v.Index(i), t, o)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					resultItem, err = ValidateStruct(v.Index(i).Interface())
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return false, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result = result && resultItem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result, nil
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// If the value is an interface then encode its element
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ValidateStruct(v.Interface())
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			// If the value is a pointer then check its element
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				return true, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return typeCheck(v.Elem(), t, o)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return ValidateStruct(v.Interface())
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false, &UnsupportedTypeError{v.Type()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEmptyValue(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String, reflect.Array:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Map, reflect.Slice:
0000000000000000000000000000000000000000;;			return v.Len() == 0 || v.IsNil()
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return reflect.DeepEqual(v.Interface(), reflect.Zero(v.Type()).Interface())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorByField returns error for specified field of the struct
0000000000000000000000000000000000000000;;	// validated by ValidateStruct or empty string if there are no errors
0000000000000000000000000000000000000000;;	// or this field doesn't exists or doesn't have any errors.
0000000000000000000000000000000000000000;;	func ErrorByField(e error, field string) string {
0000000000000000000000000000000000000000;;		if e == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrorsByField(e)[field]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrorsByField returns map of errors of the struct validated
0000000000000000000000000000000000000000;;	// by ValidateStruct or empty map if there are no errors.
0000000000000000000000000000000000000000;;	func ErrorsByField(e error) map[string]string {
0000000000000000000000000000000000000000;;		m := make(map[string]string)
0000000000000000000000000000000000000000;;		if e == nil {
0000000000000000000000000000000000000000;;			return m
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// prototype for ValidateStruct
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch e.(type) {
0000000000000000000000000000000000000000;;		case Error:
0000000000000000000000000000000000000000;;			m[e.(Error).Name] = e.(Error).Err.Error()
0000000000000000000000000000000000000000;;		case Errors:
0000000000000000000000000000000000000000;;			for _, item := range e.(Errors).Errors() {
0000000000000000000000000000000000000000;;				n := ErrorsByField(item)
0000000000000000000000000000000000000000;;				for k, v := range n {
0000000000000000000000000000000000000000;;					m[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error returns string equivalent for reflect.Type
0000000000000000000000000000000000000000;;	func (e *UnsupportedTypeError) Error() string {
0000000000000000000000000000000000000000;;		return "validator: unsupported type: " + e.Type.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (sv stringValues) Len() int           { return len(sv) }
0000000000000000000000000000000000000000;;	func (sv stringValues) Swap(i, j int)      { sv[i], sv[j] = sv[j], sv[i] }
0000000000000000000000000000000000000000;;	func (sv stringValues) Less(i, j int) bool { return sv.get(i) < sv.get(j) }
0000000000000000000000000000000000000000;;	func (sv stringValues) get(i int) string   { return sv[i].String() }
