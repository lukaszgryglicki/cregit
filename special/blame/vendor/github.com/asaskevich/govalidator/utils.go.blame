0000000000000000000000000000000000000000;;	package govalidator
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"html"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains check if the string contains the substring.
0000000000000000000000000000000000000000;;	func Contains(str, substring string) bool {
0000000000000000000000000000000000000000;;		return strings.Contains(str, substring)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Matches check if string matches the pattern (pattern is regular expression)
0000000000000000000000000000000000000000;;	// In case of error return false
0000000000000000000000000000000000000000;;	func Matches(str, pattern string) bool {
0000000000000000000000000000000000000000;;		match, _ := regexp.MatchString(pattern, str)
0000000000000000000000000000000000000000;;		return match
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeftTrim trim characters from the left-side of the input.
0000000000000000000000000000000000000000;;	// If second argument is empty, it's will be remove leading spaces.
0000000000000000000000000000000000000000;;	func LeftTrim(str, chars string) string {
0000000000000000000000000000000000000000;;		pattern := ""
0000000000000000000000000000000000000000;;		if chars == "" {
0000000000000000000000000000000000000000;;			pattern = "^\\s+"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pattern = "^[" + chars + "]+"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile(pattern)
0000000000000000000000000000000000000000;;		return string(r.ReplaceAll([]byte(str), []byte("")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RightTrim trim characters from the right-side of the input.
0000000000000000000000000000000000000000;;	// If second argument is empty, it's will be remove spaces.
0000000000000000000000000000000000000000;;	func RightTrim(str, chars string) string {
0000000000000000000000000000000000000000;;		pattern := ""
0000000000000000000000000000000000000000;;		if chars == "" {
0000000000000000000000000000000000000000;;			pattern = "\\s+$"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pattern = "[" + chars + "]+$"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile(pattern)
0000000000000000000000000000000000000000;;		return string(r.ReplaceAll([]byte(str), []byte("")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Trim trim characters from both sides of the input.
0000000000000000000000000000000000000000;;	// If second argument is empty, it's will be remove spaces.
0000000000000000000000000000000000000000;;	func Trim(str, chars string) string {
0000000000000000000000000000000000000000;;		return LeftTrim(RightTrim(str, chars), chars)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WhiteList remove characters that do not appear in the whitelist.
0000000000000000000000000000000000000000;;	func WhiteList(str, chars string) string {
0000000000000000000000000000000000000000;;		pattern := "[^" + chars + "]+"
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile(pattern)
0000000000000000000000000000000000000000;;		return string(r.ReplaceAll([]byte(str), []byte("")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BlackList remove characters that appear in the blacklist.
0000000000000000000000000000000000000000;;	func BlackList(str, chars string) string {
0000000000000000000000000000000000000000;;		pattern := "[" + chars + "]+"
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile(pattern)
0000000000000000000000000000000000000000;;		return string(r.ReplaceAll([]byte(str), []byte("")))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StripLow remove characters with a numerical value < 32 and 127, mostly control characters.
0000000000000000000000000000000000000000;;	// If keep_new_lines is true, newline characters are preserved (\n and \r, hex 0xA and 0xD).
0000000000000000000000000000000000000000;;	func StripLow(str string, keepNewLines bool) string {
0000000000000000000000000000000000000000;;		chars := ""
0000000000000000000000000000000000000000;;		if keepNewLines {
0000000000000000000000000000000000000000;;			chars = "\x00-\x09\x0B\x0C\x0E-\x1F\x7F"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			chars = "\x00-\x1F\x7F"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return BlackList(str, chars)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplacePattern replace regular expression pattern in string
0000000000000000000000000000000000000000;;	func ReplacePattern(str, pattern, replace string) string {
0000000000000000000000000000000000000000;;		r, _ := regexp.Compile(pattern)
0000000000000000000000000000000000000000;;		return string(r.ReplaceAll([]byte(str), []byte(replace)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Escape replace <, >, & and " with HTML entities.
0000000000000000000000000000000000000000;;	var Escape = html.EscapeString
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addSegment(inrune, segment []rune) []rune {
0000000000000000000000000000000000000000;;		if len(segment) == 0 {
0000000000000000000000000000000000000000;;			return inrune
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(inrune) != 0 {
0000000000000000000000000000000000000000;;			inrune = append(inrune, '_')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inrune = append(inrune, segment...)
0000000000000000000000000000000000000000;;		return inrune
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnderscoreToCamelCase converts from underscore separated form to camel case form.
0000000000000000000000000000000000000000;;	// Ex.: my_func => MyFunc
0000000000000000000000000000000000000000;;	func UnderscoreToCamelCase(s string) string {
0000000000000000000000000000000000000000;;		return strings.Replace(strings.Title(strings.Replace(strings.ToLower(s), "_", " ", -1)), " ", "", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CamelCaseToUnderscore converts from camel case form to underscore separated form.
0000000000000000000000000000000000000000;;	// Ex.: MyFunc => my_func
0000000000000000000000000000000000000000;;	func CamelCaseToUnderscore(str string) string {
0000000000000000000000000000000000000000;;		var output []rune
0000000000000000000000000000000000000000;;		var segment []rune
0000000000000000000000000000000000000000;;		for _, r := range str {
0000000000000000000000000000000000000000;;			if !unicode.IsLower(r) {
0000000000000000000000000000000000000000;;				output = addSegment(output, segment)
0000000000000000000000000000000000000000;;				segment = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			segment = append(segment, unicode.ToLower(r))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		output = addSegment(output, segment)
0000000000000000000000000000000000000000;;		return string(output)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reverse return reversed string
0000000000000000000000000000000000000000;;	func Reverse(s string) string {
0000000000000000000000000000000000000000;;		r := []rune(s)
0000000000000000000000000000000000000000;;		for i, j := 0, len(r)-1; i < j; i, j = i+1, j-1 {
0000000000000000000000000000000000000000;;			r[i], r[j] = r[j], r[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLines split string by "\n" and return array of lines
0000000000000000000000000000000000000000;;	func GetLines(s string) []string {
0000000000000000000000000000000000000000;;		return strings.Split(s, "\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetLine return specified line of multiline string
0000000000000000000000000000000000000000;;	func GetLine(s string, index int) (string, error) {
0000000000000000000000000000000000000000;;		lines := GetLines(s)
0000000000000000000000000000000000000000;;		if index < 0 || index >= len(lines) {
0000000000000000000000000000000000000000;;			return "", errors.New("line index out of bounds")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lines[index], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveTags remove all tags from HTML string
0000000000000000000000000000000000000000;;	func RemoveTags(s string) string {
0000000000000000000000000000000000000000;;		return ReplacePattern(s, "<[^>]*>", "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SafeFileName return safe string that can be used in file names
0000000000000000000000000000000000000000;;	func SafeFileName(str string) string {
0000000000000000000000000000000000000000;;		name := strings.ToLower(str)
0000000000000000000000000000000000000000;;		name = path.Clean(path.Base(name))
0000000000000000000000000000000000000000;;		name = strings.Trim(name, " ")
0000000000000000000000000000000000000000;;		separators, err := regexp.Compile(`[ &_=+:]`)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			name = separators.ReplaceAllString(name, "-")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		legal, err := regexp.Compile(`[^[:alnum:]-.]`)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			name = legal.ReplaceAllString(name, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for strings.Contains(name, "--") {
0000000000000000000000000000000000000000;;			name = strings.Replace(name, "--", "-", -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NormalizeEmail canonicalize an email address.
0000000000000000000000000000000000000000;;	// The local part of the email address is lowercased for all domains; the hostname is always lowercased and
0000000000000000000000000000000000000000;;	// the local part of the email address is always lowercased for hosts that are known to be case-insensitive (currently only GMail).
0000000000000000000000000000000000000000;;	// Normalization follows special rules for known providers: currently, GMail addresses have dots removed in the local part and
0000000000000000000000000000000000000000;;	// are stripped of tags (e.g. some.one+tag@gmail.com becomes someone@gmail.com) and all @googlemail.com addresses are
0000000000000000000000000000000000000000;;	// normalized to @gmail.com.
0000000000000000000000000000000000000000;;	func NormalizeEmail(str string) (string, error) {
0000000000000000000000000000000000000000;;		if !IsEmail(str) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("%s is not an email", str)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parts := strings.Split(str, "@")
0000000000000000000000000000000000000000;;		parts[0] = strings.ToLower(parts[0])
0000000000000000000000000000000000000000;;		parts[1] = strings.ToLower(parts[1])
0000000000000000000000000000000000000000;;		if parts[1] == "gmail.com" || parts[1] == "googlemail.com" {
0000000000000000000000000000000000000000;;			parts[1] = "gmail.com"
0000000000000000000000000000000000000000;;			parts[0] = strings.Split(ReplacePattern(parts[0], `\.`, ""), "+")[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(parts, "@"), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Truncate a string to the closest length without breaking words.
0000000000000000000000000000000000000000;;	func Truncate(str string, length int, ending string) string {
0000000000000000000000000000000000000000;;		var aftstr, befstr string
0000000000000000000000000000000000000000;;		if len(str) > length {
0000000000000000000000000000000000000000;;			words := strings.Fields(str)
0000000000000000000000000000000000000000;;			before, present := 0, 0
0000000000000000000000000000000000000000;;			for i := range words {
0000000000000000000000000000000000000000;;				befstr = aftstr
0000000000000000000000000000000000000000;;				before = present
0000000000000000000000000000000000000000;;				aftstr = aftstr + words[i] + " "
0000000000000000000000000000000000000000;;				present = len(aftstr)
0000000000000000000000000000000000000000;;				if present > length && i != 0 {
0000000000000000000000000000000000000000;;					if (length - before) < (present - length) {
0000000000000000000000000000000000000000;;						return Trim(befstr, " /\\.,\"'#!?&@+-") + ending
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return Trim(aftstr, " /\\.,\"'#!?&@+-") + ending
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return str
0000000000000000000000000000000000000000;;	}
