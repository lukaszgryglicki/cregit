0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/google/btree/btree.go[Godeps/_workspace/src/github.com/google/btree/btree.go][vendor/github.com/google/btree/btree.go];	
0000000000000000000000000000000000000000;;	// Package btree implements in-memory B-Trees of arbitrary degree.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// btree implements an in-memory B-Tree for use as an ordered data structure.
0000000000000000000000000000000000000000;;	// It is not meant for persistent storage solutions.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It has a flatter structure than an equivalent red-black or other binary tree,
0000000000000000000000000000000000000000;;	// which in some cases yields better memory usage and/or performance.
0000000000000000000000000000000000000000;;	// See some discussion on the matter here:
0000000000000000000000000000000000000000;;	//   http://google-opensource.blogspot.com/2013/01/c-containers-that-save-memory-and-time.html
0000000000000000000000000000000000000000;;	// Note, though, that this project is in no way related to the C++ B-Tree
0000000000000000000000000000000000000000;;	// implmentation written about there.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Within this tree, each node contains a slice of items and a (possibly nil)
0000000000000000000000000000000000000000;;	// slice of children.  For basic numeric values or raw structs, this can cause
0000000000000000000000000000000000000000;;	// efficiency differences when compared to equivalent C++ template code that
0000000000000000000000000000000000000000;;	// stores values in arrays within the node:
0000000000000000000000000000000000000000;;	//   * Due to the overhead of storing values as interfaces (each
0000000000000000000000000000000000000000;;	//     value needs to be stored as the value itself, then 2 words for the
0000000000000000000000000000000000000000;;	//     interface pointing to that value and its type), resulting in higher
0000000000000000000000000000000000000000;;	//     memory use.
0000000000000000000000000000000000000000;;	//   * Since interfaces can point to values anywhere in memory, values are
0000000000000000000000000000000000000000;;	//     most likely not stored in contiguous blocks, resulting in a higher
0000000000000000000000000000000000000000;;	//     number of cache misses.
0000000000000000000000000000000000000000;;	// These issues don't tend to matter, though, when working with strings or other
0000000000000000000000000000000000000000;;	// heap-allocated structures, since C++-equivalent structures also must store
0000000000000000000000000000000000000000;;	// pointers and also distribute their values across the heap.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This implementation is designed to be a drop-in replacement to gollrb.LLRB
0000000000000000000000000000000000000000;;	// trees, (http://github.com/petar/gollrb), an excellent and probably the most
0000000000000000000000000000000000000000;;	// widely used ordered tree implementation in the Go ecosystem currently.
0000000000000000000000000000000000000000;;	// Its functions, therefore, exactly mirror those of
0000000000000000000000000000000000000000;;	// llrb.LLRB where possible.  Unlike gollrb, though, we currently don't
0000000000000000000000000000000000000000;;	// support storing multiple equivalent values or backwards iteration.
0000000000000000000000000000000000000000;;	package btree
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Item represents a single object in the tree.
0000000000000000000000000000000000000000;;	type Item interface {
0000000000000000000000000000000000000000;;		// Less tests whether the current item is less than the given argument.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// This must provide a strict weak ordering.
0000000000000000000000000000000000000000;;		// If !a.Less(b) && !b.Less(a), we treat this to mean a == b (i.e. we can only
0000000000000000000000000000000000000000;;		// hold one of either a or b in the tree).
0000000000000000000000000000000000000000;;		Less(than Item) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		DefaultFreeListSize = 32
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FreeList represents a free list of btree nodes. By default each
0000000000000000000000000000000000000000;;	// BTree has its own FreeList, but multiple BTrees can share the same
0000000000000000000000000000000000000000;;	// FreeList.
0000000000000000000000000000000000000000;;	// Two Btrees using the same freelist are not safe for concurrent write access.
0000000000000000000000000000000000000000;;	type FreeList struct {
0000000000000000000000000000000000000000;;		freelist []*node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFreeList creates a new free list.
0000000000000000000000000000000000000000;;	// size is the maximum size of the returned free list.
0000000000000000000000000000000000000000;;	func NewFreeList(size int) *FreeList {
0000000000000000000000000000000000000000;;		return &FreeList{freelist: make([]*node, 0, size)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FreeList) newNode() (n *node) {
0000000000000000000000000000000000000000;;		index := len(f.freelist) - 1
0000000000000000000000000000000000000000;;		if index < 0 {
0000000000000000000000000000000000000000;;			return new(node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.freelist, n = f.freelist[:index], f.freelist[index]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FreeList) freeNode(n *node) {
0000000000000000000000000000000000000000;;		if len(f.freelist) < cap(f.freelist) {
0000000000000000000000000000000000000000;;			f.freelist = append(f.freelist, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ItemIterator allows callers of Ascend* to iterate in-order over portions of
0000000000000000000000000000000000000000;;	// the tree.  When this function returns false, iteration will stop and the
0000000000000000000000000000000000000000;;	// associated Ascend* function will immediately return.
0000000000000000000000000000000000000000;;	type ItemIterator func(i Item) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new B-Tree with the given degree.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// New(2), for example, will create a 2-3-4 tree (each node contains 1-3 items
0000000000000000000000000000000000000000;;	// and 2-4 children).
0000000000000000000000000000000000000000;;	func New(degree int) *BTree {
0000000000000000000000000000000000000000;;		return NewWithFreeList(degree, NewFreeList(DefaultFreeListSize))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWithFreeList creates a new B-Tree that uses the given node free list.
0000000000000000000000000000000000000000;;	func NewWithFreeList(degree int, f *FreeList) *BTree {
0000000000000000000000000000000000000000;;		if degree <= 1 {
0000000000000000000000000000000000000000;;			panic("bad degree")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &BTree{
0000000000000000000000000000000000000000;;			degree:   degree,
0000000000000000000000000000000000000000;;			freelist: f,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// items stores items in a node.
0000000000000000000000000000000000000000;;	type items []Item
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertAt inserts a value into the given index, pushing all subsequent values
0000000000000000000000000000000000000000;;	// forward.
0000000000000000000000000000000000000000;;	func (s *items) insertAt(index int, item Item) {
0000000000000000000000000000000000000000;;		*s = append(*s, nil)
0000000000000000000000000000000000000000;;		if index < len(*s) {
0000000000000000000000000000000000000000;;			copy((*s)[index+1:], (*s)[index:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		(*s)[index] = item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeAt removes a value at a given index, pulling all subsequent values
0000000000000000000000000000000000000000;;	// back.
0000000000000000000000000000000000000000;;	func (s *items) removeAt(index int) Item {
0000000000000000000000000000000000000000;;		item := (*s)[index]
0000000000000000000000000000000000000000;;		(*s)[index] = nil
0000000000000000000000000000000000000000;;		copy((*s)[index:], (*s)[index+1:])
0000000000000000000000000000000000000000;;		*s = (*s)[:len(*s)-1]
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pop removes and returns the last element in the list.
0000000000000000000000000000000000000000;;	func (s *items) pop() (out Item) {
0000000000000000000000000000000000000000;;		index := len(*s) - 1
0000000000000000000000000000000000000000;;		out = (*s)[index]
0000000000000000000000000000000000000000;;		(*s)[index] = nil
0000000000000000000000000000000000000000;;		*s = (*s)[:index]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// find returns the index where the given item should be inserted into this
0000000000000000000000000000000000000000;;	// list.  'found' is true if the item already exists in the list at the given
0000000000000000000000000000000000000000;;	// index.
0000000000000000000000000000000000000000;;	func (s items) find(item Item) (index int, found bool) {
0000000000000000000000000000000000000000;;		i := sort.Search(len(s), func(i int) bool {
0000000000000000000000000000000000000000;;			return item.Less(s[i])
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if i > 0 && !s[i-1].Less(item) {
0000000000000000000000000000000000000000;;			return i - 1, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// children stores child nodes in a node.
0000000000000000000000000000000000000000;;	type children []*node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insertAt inserts a value into the given index, pushing all subsequent values
0000000000000000000000000000000000000000;;	// forward.
0000000000000000000000000000000000000000;;	func (s *children) insertAt(index int, n *node) {
0000000000000000000000000000000000000000;;		*s = append(*s, nil)
0000000000000000000000000000000000000000;;		if index < len(*s) {
0000000000000000000000000000000000000000;;			copy((*s)[index+1:], (*s)[index:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		(*s)[index] = n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeAt removes a value at a given index, pulling all subsequent values
0000000000000000000000000000000000000000;;	// back.
0000000000000000000000000000000000000000;;	func (s *children) removeAt(index int) *node {
0000000000000000000000000000000000000000;;		n := (*s)[index]
0000000000000000000000000000000000000000;;		(*s)[index] = nil
0000000000000000000000000000000000000000;;		copy((*s)[index:], (*s)[index+1:])
0000000000000000000000000000000000000000;;		*s = (*s)[:len(*s)-1]
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pop removes and returns the last element in the list.
0000000000000000000000000000000000000000;;	func (s *children) pop() (out *node) {
0000000000000000000000000000000000000000;;		index := len(*s) - 1
0000000000000000000000000000000000000000;;		out = (*s)[index]
0000000000000000000000000000000000000000;;		(*s)[index] = nil
0000000000000000000000000000000000000000;;		*s = (*s)[:index]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// node is an internal node in a tree.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It must at all times maintain the invariant that either
0000000000000000000000000000000000000000;;	//   * len(children) == 0, len(items) unconstrained
0000000000000000000000000000000000000000;;	//   * len(children) == len(items) + 1
0000000000000000000000000000000000000000;;	type node struct {
0000000000000000000000000000000000000000;;		items    items
0000000000000000000000000000000000000000;;		children children
0000000000000000000000000000000000000000;;		t        *BTree
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// split splits the given node at the given index.  The current node shrinks,
0000000000000000000000000000000000000000;;	// and this function returns the item that existed at that index and a new node
0000000000000000000000000000000000000000;;	// containing all items/children after it.
0000000000000000000000000000000000000000;;	func (n *node) split(i int) (Item, *node) {
0000000000000000000000000000000000000000;;		item := n.items[i]
0000000000000000000000000000000000000000;;		next := n.t.newNode()
0000000000000000000000000000000000000000;;		next.items = append(next.items, n.items[i+1:]...)
0000000000000000000000000000000000000000;;		n.items = n.items[:i]
0000000000000000000000000000000000000000;;		if len(n.children) > 0 {
0000000000000000000000000000000000000000;;			next.children = append(next.children, n.children[i+1:]...)
0000000000000000000000000000000000000000;;			n.children = n.children[:i+1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return item, next
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maybeSplitChild checks if a child should be split, and if so splits it.
0000000000000000000000000000000000000000;;	// Returns whether or not a split occurred.
0000000000000000000000000000000000000000;;	func (n *node) maybeSplitChild(i, maxItems int) bool {
0000000000000000000000000000000000000000;;		if len(n.children[i].items) < maxItems {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		first := n.children[i]
0000000000000000000000000000000000000000;;		item, second := first.split(maxItems / 2)
0000000000000000000000000000000000000000;;		n.items.insertAt(i, item)
0000000000000000000000000000000000000000;;		n.children.insertAt(i+1, second)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// insert inserts an item into the subtree rooted at this node, making sure
0000000000000000000000000000000000000000;;	// no nodes in the subtree exceed maxItems items.  Should an equivalent item be
0000000000000000000000000000000000000000;;	// be found/replaced by insert, it will be returned.
0000000000000000000000000000000000000000;;	func (n *node) insert(item Item, maxItems int) Item {
0000000000000000000000000000000000000000;;		i, found := n.items.find(item)
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			out := n.items[i]
0000000000000000000000000000000000000000;;			n.items[i] = item
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.children) == 0 {
0000000000000000000000000000000000000000;;			n.items.insertAt(i, item)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.maybeSplitChild(i, maxItems) {
0000000000000000000000000000000000000000;;			inTree := n.items[i]
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case item.Less(inTree):
0000000000000000000000000000000000000000;;				// no change, we want first split node
0000000000000000000000000000000000000000;;			case inTree.Less(item):
0000000000000000000000000000000000000000;;				i++ // we want second split node
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				out := n.items[i]
0000000000000000000000000000000000000000;;				n.items[i] = item
0000000000000000000000000000000000000000;;				return out
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.children[i].insert(item, maxItems)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get finds the given key in the subtree and returns it.
0000000000000000000000000000000000000000;;	func (n *node) get(key Item) Item {
0000000000000000000000000000000000000000;;		i, found := n.items.find(key)
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			return n.items[i]
0000000000000000000000000000000000000000;;		} else if len(n.children) > 0 {
0000000000000000000000000000000000000000;;			return n.children[i].get(key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// min returns the first item in the subtree.
0000000000000000000000000000000000000000;;	func min(n *node) Item {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for len(n.children) > 0 {
0000000000000000000000000000000000000000;;			n = n.children[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.items) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.items[0]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// max returns the last item in the subtree.
0000000000000000000000000000000000000000;;	func max(n *node) Item {
0000000000000000000000000000000000000000;;		if n == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for len(n.children) > 0 {
0000000000000000000000000000000000000000;;			n = n.children[len(n.children)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.items) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.items[len(n.items)-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toRemove details what item to remove in a node.remove call.
0000000000000000000000000000000000000000;;	type toRemove int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		removeItem toRemove = iota // removes the given item
0000000000000000000000000000000000000000;;		removeMin                  // removes smallest item in the subtree
0000000000000000000000000000000000000000;;		removeMax                  // removes largest item in the subtree
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// remove removes an item from the subtree rooted at this node.
0000000000000000000000000000000000000000;;	func (n *node) remove(item Item, minItems int, typ toRemove) Item {
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		var found bool
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case removeMax:
0000000000000000000000000000000000000000;;			if len(n.children) == 0 {
0000000000000000000000000000000000000000;;				return n.items.pop()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = len(n.items)
0000000000000000000000000000000000000000;;		case removeMin:
0000000000000000000000000000000000000000;;			if len(n.children) == 0 {
0000000000000000000000000000000000000000;;				return n.items.removeAt(0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = 0
0000000000000000000000000000000000000000;;		case removeItem:
0000000000000000000000000000000000000000;;			i, found = n.items.find(item)
0000000000000000000000000000000000000000;;			if len(n.children) == 0 {
0000000000000000000000000000000000000000;;				if found {
0000000000000000000000000000000000000000;;					return n.items.removeAt(i)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("invalid type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we get to here, we have children.
0000000000000000000000000000000000000000;;		child := n.children[i]
0000000000000000000000000000000000000000;;		if len(child.items) <= minItems {
0000000000000000000000000000000000000000;;			return n.growChildAndRemove(i, item, minItems, typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Either we had enough items to begin with, or we've done some
0000000000000000000000000000000000000000;;		// merging/stealing, because we've got enough now and we're ready to return
0000000000000000000000000000000000000000;;		// stuff.
0000000000000000000000000000000000000000;;		if found {
0000000000000000000000000000000000000000;;			// The item exists at index 'i', and the child we've selected can give us a
0000000000000000000000000000000000000000;;			// predecessor, since if we've gotten here it's got > minItems items in it.
0000000000000000000000000000000000000000;;			out := n.items[i]
0000000000000000000000000000000000000000;;			// We use our special-case 'remove' call with typ=maxItem to pull the
0000000000000000000000000000000000000000;;			// predecessor of item i (the rightmost leaf of our immediate left child)
0000000000000000000000000000000000000000;;			// and set it into where we pulled the item from.
0000000000000000000000000000000000000000;;			n.items[i] = child.remove(nil, minItems, removeMax)
0000000000000000000000000000000000000000;;			return out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Final recursive call.  Once we're here, we know that the item isn't in this
0000000000000000000000000000000000000000;;		// node and that the child is big enough to remove from.
0000000000000000000000000000000000000000;;		return child.remove(item, minItems, typ)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// growChildAndRemove grows child 'i' to make sure it's possible to remove an
0000000000000000000000000000000000000000;;	// item from it while keeping it at minItems, then calls remove to actually
0000000000000000000000000000000000000000;;	// remove it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Most documentation says we have to do two sets of special casing:
0000000000000000000000000000000000000000;;	//   1) item is in this node
0000000000000000000000000000000000000000;;	//   2) item is in child
0000000000000000000000000000000000000000;;	// In both cases, we need to handle the two subcases:
0000000000000000000000000000000000000000;;	//   A) node has enough values that it can spare one
0000000000000000000000000000000000000000;;	//   B) node doesn't have enough values
0000000000000000000000000000000000000000;;	// For the latter, we have to check:
0000000000000000000000000000000000000000;;	//   a) left sibling has node to spare
0000000000000000000000000000000000000000;;	//   b) right sibling has node to spare
0000000000000000000000000000000000000000;;	//   c) we must merge
0000000000000000000000000000000000000000;;	// To simplify our code here, we handle cases #1 and #2 the same:
0000000000000000000000000000000000000000;;	// If a node doesn't have enough items, we make sure it does (using a,b,c).
0000000000000000000000000000000000000000;;	// We then simply redo our remove call, and the second time (regardless of
0000000000000000000000000000000000000000;;	// whether we're in case 1 or 2), we'll have enough items and can guarantee
0000000000000000000000000000000000000000;;	// that we hit case A.
0000000000000000000000000000000000000000;;	func (n *node) growChildAndRemove(i int, item Item, minItems int, typ toRemove) Item {
0000000000000000000000000000000000000000;;		child := n.children[i]
0000000000000000000000000000000000000000;;		if i > 0 && len(n.children[i-1].items) > minItems {
0000000000000000000000000000000000000000;;			// Steal from left child
0000000000000000000000000000000000000000;;			stealFrom := n.children[i-1]
0000000000000000000000000000000000000000;;			stolenItem := stealFrom.items.pop()
0000000000000000000000000000000000000000;;			child.items.insertAt(0, n.items[i-1])
0000000000000000000000000000000000000000;;			n.items[i-1] = stolenItem
0000000000000000000000000000000000000000;;			if len(stealFrom.children) > 0 {
0000000000000000000000000000000000000000;;				child.children.insertAt(0, stealFrom.children.pop())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if i < len(n.items) && len(n.children[i+1].items) > minItems {
0000000000000000000000000000000000000000;;			// steal from right child
0000000000000000000000000000000000000000;;			stealFrom := n.children[i+1]
0000000000000000000000000000000000000000;;			stolenItem := stealFrom.items.removeAt(0)
0000000000000000000000000000000000000000;;			child.items = append(child.items, n.items[i])
0000000000000000000000000000000000000000;;			n.items[i] = stolenItem
0000000000000000000000000000000000000000;;			if len(stealFrom.children) > 0 {
0000000000000000000000000000000000000000;;				child.children = append(child.children, stealFrom.children.removeAt(0))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if i >= len(n.items) {
0000000000000000000000000000000000000000;;				i--
0000000000000000000000000000000000000000;;				child = n.children[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// merge with right child
0000000000000000000000000000000000000000;;			mergeItem := n.items.removeAt(i)
0000000000000000000000000000000000000000;;			mergeChild := n.children.removeAt(i + 1)
0000000000000000000000000000000000000000;;			child.items = append(child.items, mergeItem)
0000000000000000000000000000000000000000;;			child.items = append(child.items, mergeChild.items...)
0000000000000000000000000000000000000000;;			child.children = append(child.children, mergeChild.children...)
0000000000000000000000000000000000000000;;			n.t.freeNode(mergeChild)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.remove(item, minItems, typ)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// iterate provides a simple method for iterating over elements in the tree.
0000000000000000000000000000000000000000;;	// It could probably use some work to be extra-efficient (it calls from() a
0000000000000000000000000000000000000000;;	// little more than it should), but it works pretty well for now.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It requires that 'from' and 'to' both return true for values we should hit
0000000000000000000000000000000000000000;;	// with the iterator.  It should also be the case that 'from' returns true for
0000000000000000000000000000000000000000;;	// values less than or equal to values 'to' returns true for, and 'to'
0000000000000000000000000000000000000000;;	// returns true for values greater than or equal to those that 'from'
0000000000000000000000000000000000000000;;	// does.
0000000000000000000000000000000000000000;;	func (n *node) iterate(from, to func(Item) bool, iter ItemIterator) bool {
0000000000000000000000000000000000000000;;		for i, item := range n.items {
0000000000000000000000000000000000000000;;			if !from(item) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(n.children) > 0 && !n.children[i].iterate(from, to, iter) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !to(item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !iter(item) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.children) > 0 {
0000000000000000000000000000000000000000;;			return n.children[len(n.children)-1].iterate(from, to, iter)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used for testing/debugging purposes.
0000000000000000000000000000000000000000;;	func (n *node) print(w io.Writer, level int) {
0000000000000000000000000000000000000000;;		fmt.Fprintf(w, "%sNODE:%v\n", strings.Repeat("  ", level), n.items)
0000000000000000000000000000000000000000;;		for _, c := range n.children {
0000000000000000000000000000000000000000;;			c.print(w, level+1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BTree is an implementation of a B-Tree.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// BTree stores Item instances in an ordered structure, allowing easy insertion,
0000000000000000000000000000000000000000;;	// removal, and iteration.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Write operations are not safe for concurrent mutation by multiple
0000000000000000000000000000000000000000;;	// goroutines, but Read operations are.
0000000000000000000000000000000000000000;;	type BTree struct {
0000000000000000000000000000000000000000;;		degree   int
0000000000000000000000000000000000000000;;		length   int
0000000000000000000000000000000000000000;;		root     *node
0000000000000000000000000000000000000000;;		freelist *FreeList
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// maxItems returns the max number of items to allow per node.
0000000000000000000000000000000000000000;;	func (t *BTree) maxItems() int {
0000000000000000000000000000000000000000;;		return t.degree*2 - 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// minItems returns the min number of items to allow per node (ignored for the
0000000000000000000000000000000000000000;;	// root node).
0000000000000000000000000000000000000000;;	func (t *BTree) minItems() int {
0000000000000000000000000000000000000000;;		return t.degree - 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *BTree) newNode() (n *node) {
0000000000000000000000000000000000000000;;		n = t.freelist.newNode()
0000000000000000000000000000000000000000;;		n.t = t
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *BTree) freeNode(n *node) {
0000000000000000000000000000000000000000;;		for i := range n.items {
0000000000000000000000000000000000000000;;			n.items[i] = nil // clear to allow GC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.items = n.items[:0]
0000000000000000000000000000000000000000;;		for i := range n.children {
0000000000000000000000000000000000000000;;			n.children[i] = nil // clear to allow GC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n.children = n.children[:0]
0000000000000000000000000000000000000000;;		n.t = nil // clear to allow GC
0000000000000000000000000000000000000000;;		t.freelist.freeNode(n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReplaceOrInsert adds the given item to the tree.  If an item in the tree
0000000000000000000000000000000000000000;;	// already equals the given one, it is removed from the tree and returned.
0000000000000000000000000000000000000000;;	// Otherwise, nil is returned.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// nil cannot be added to the tree (will panic).
0000000000000000000000000000000000000000;;	func (t *BTree) ReplaceOrInsert(item Item) Item {
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			panic("nil item being added to BTree")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.root == nil {
0000000000000000000000000000000000000000;;			t.root = t.newNode()
0000000000000000000000000000000000000000;;			t.root.items = append(t.root.items, item)
0000000000000000000000000000000000000000;;			t.length++
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		} else if len(t.root.items) >= t.maxItems() {
0000000000000000000000000000000000000000;;			item2, second := t.root.split(t.maxItems() / 2)
0000000000000000000000000000000000000000;;			oldroot := t.root
0000000000000000000000000000000000000000;;			t.root = t.newNode()
0000000000000000000000000000000000000000;;			t.root.items = append(t.root.items, item2)
0000000000000000000000000000000000000000;;			t.root.children = append(t.root.children, oldroot, second)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := t.root.insert(item, t.maxItems())
0000000000000000000000000000000000000000;;		if out == nil {
0000000000000000000000000000000000000000;;			t.length++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete removes an item equal to the passed in item from the tree, returning
0000000000000000000000000000000000000000;;	// it.  If no such item exists, returns nil.
0000000000000000000000000000000000000000;;	func (t *BTree) Delete(item Item) Item {
0000000000000000000000000000000000000000;;		return t.deleteItem(item, removeItem)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteMin removes the smallest item in the tree and returns it.
0000000000000000000000000000000000000000;;	// If no such item exists, returns nil.
0000000000000000000000000000000000000000;;	func (t *BTree) DeleteMin() Item {
0000000000000000000000000000000000000000;;		return t.deleteItem(nil, removeMin)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteMax removes the largest item in the tree and returns it.
0000000000000000000000000000000000000000;;	// If no such item exists, returns nil.
0000000000000000000000000000000000000000;;	func (t *BTree) DeleteMax() Item {
0000000000000000000000000000000000000000;;		return t.deleteItem(nil, removeMax)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *BTree) deleteItem(item Item, typ toRemove) Item {
0000000000000000000000000000000000000000;;		if t.root == nil || len(t.root.items) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := t.root.remove(item, t.minItems(), typ)
0000000000000000000000000000000000000000;;		if len(t.root.items) == 0 && len(t.root.children) > 0 {
0000000000000000000000000000000000000000;;			oldroot := t.root
0000000000000000000000000000000000000000;;			t.root = t.root.children[0]
0000000000000000000000000000000000000000;;			t.freeNode(oldroot)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if out != nil {
0000000000000000000000000000000000000000;;			t.length--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AscendRange calls the iterator for every value in the tree within the range
0000000000000000000000000000000000000000;;	// [greaterOrEqual, lessThan), until iterator returns false.
0000000000000000000000000000000000000000;;	func (t *BTree) AscendRange(greaterOrEqual, lessThan Item, iterator ItemIterator) {
0000000000000000000000000000000000000000;;		if t.root == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.root.iterate(
0000000000000000000000000000000000000000;;			func(a Item) bool { return !a.Less(greaterOrEqual) },
0000000000000000000000000000000000000000;;			func(a Item) bool { return a.Less(lessThan) },
0000000000000000000000000000000000000000;;			iterator)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AscendLessThan calls the iterator for every value in the tree within the range
0000000000000000000000000000000000000000;;	// [first, pivot), until iterator returns false.
0000000000000000000000000000000000000000;;	func (t *BTree) AscendLessThan(pivot Item, iterator ItemIterator) {
0000000000000000000000000000000000000000;;		if t.root == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.root.iterate(
0000000000000000000000000000000000000000;;			func(a Item) bool { return true },
0000000000000000000000000000000000000000;;			func(a Item) bool { return a.Less(pivot) },
0000000000000000000000000000000000000000;;			iterator)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AscendGreaterOrEqual calls the iterator for every value in the tree within
0000000000000000000000000000000000000000;;	// the range [pivot, last], until iterator returns false.
0000000000000000000000000000000000000000;;	func (t *BTree) AscendGreaterOrEqual(pivot Item, iterator ItemIterator) {
0000000000000000000000000000000000000000;;		if t.root == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.root.iterate(
0000000000000000000000000000000000000000;;			func(a Item) bool { return !a.Less(pivot) },
0000000000000000000000000000000000000000;;			func(a Item) bool { return true },
0000000000000000000000000000000000000000;;			iterator)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ascend calls the iterator for every value in the tree within the range
0000000000000000000000000000000000000000;;	// [first, last], until iterator returns false.
0000000000000000000000000000000000000000;;	func (t *BTree) Ascend(iterator ItemIterator) {
0000000000000000000000000000000000000000;;		if t.root == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.root.iterate(
0000000000000000000000000000000000000000;;			func(a Item) bool { return true },
0000000000000000000000000000000000000000;;			func(a Item) bool { return true },
0000000000000000000000000000000000000000;;			iterator)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get looks for the key item in the tree, returning it.  It returns nil if
0000000000000000000000000000000000000000;;	// unable to find that item.
0000000000000000000000000000000000000000;;	func (t *BTree) Get(key Item) Item {
0000000000000000000000000000000000000000;;		if t.root == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.root.get(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Min returns the smallest item in the tree, or nil if the tree is empty.
0000000000000000000000000000000000000000;;	func (t *BTree) Min() Item {
0000000000000000000000000000000000000000;;		return min(t.root)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Max returns the largest item in the tree, or nil if the tree is empty.
0000000000000000000000000000000000000000;;	func (t *BTree) Max() Item {
0000000000000000000000000000000000000000;;		return max(t.root)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns true if the given key is in the tree.
0000000000000000000000000000000000000000;;	func (t *BTree) Has(key Item) bool {
0000000000000000000000000000000000000000;;		return t.Get(key) != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of items currently in the tree.
0000000000000000000000000000000000000000;;	func (t *BTree) Len() int {
0000000000000000000000000000000000000000;;		return t.length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int implements the Item interface for integers.
0000000000000000000000000000000000000000;;	type Int int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Less returns true if int(a) < int(b).
0000000000000000000000000000000000000000;;	func (a Int) Less(b Item) bool {
0000000000000000000000000000000000000000;;		return a < b.(Int)
0000000000000000000000000000000000000000;;	}
