0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/storage/memory/stats_buffer.go[Godeps/_workspace/src/github.com/google/cadvisor/storage/memory/stats_buffer.go][vendor/github.com/google/cadvisor/utils/timed_store.go];	
0000000000000000000000000000000000000000;;	package utils
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timedStoreDataSlice []timedStoreData
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t timedStoreDataSlice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return t[i].timestamp.Before(t[j].timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t timedStoreDataSlice) Len() int {
0000000000000000000000000000000000000000;;		return len(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t timedStoreDataSlice) Swap(i, j int) {
0000000000000000000000000000000000000000;;		t[i], t[j] = t[j], t[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A time-based buffer for ContainerStats.
0000000000000000000000000000000000000000;;	// Holds information for a specific time period and/or a max number of items.
0000000000000000000000000000000000000000;;	type TimedStore struct {
0000000000000000000000000000000000000000;;		buffer   timedStoreDataSlice
0000000000000000000000000000000000000000;;		age      time.Duration
0000000000000000000000000000000000000000;;		maxItems int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timedStoreData struct {
0000000000000000000000000000000000000000;;		timestamp time.Time
0000000000000000000000000000000000000000;;		data      interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a new thread-compatible TimedStore.
0000000000000000000000000000000000000000;;	// A maxItems value of -1 means no limit.
0000000000000000000000000000000000000000;;	func NewTimedStore(age time.Duration, maxItems int) *TimedStore {
0000000000000000000000000000000000000000;;		return &TimedStore{
0000000000000000000000000000000000000000;;			buffer:   make(timedStoreDataSlice, 0),
0000000000000000000000000000000000000000;;			age:      age,
0000000000000000000000000000000000000000;;			maxItems: maxItems,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds an element to the start of the buffer (removing one from the end if necessary).
0000000000000000000000000000000000000000;;	func (self *TimedStore) Add(timestamp time.Time, item interface{}) {
0000000000000000000000000000000000000000;;		data := timedStoreData{
0000000000000000000000000000000000000000;;			timestamp: timestamp,
0000000000000000000000000000000000000000;;			data:      item,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Common case: data is added in order.
0000000000000000000000000000000000000000;;		if len(self.buffer) == 0 || !timestamp.Before(self.buffer[len(self.buffer)-1].timestamp) {
0000000000000000000000000000000000000000;;			self.buffer = append(self.buffer, data)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Data is out of order; insert it in the correct position.
0000000000000000000000000000000000000000;;			index := sort.Search(len(self.buffer), func(index int) bool {
0000000000000000000000000000000000000000;;				return self.buffer[index].timestamp.After(timestamp)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			self.buffer = append(self.buffer, timedStoreData{}) // Make room to shift the elements
0000000000000000000000000000000000000000;;			copy(self.buffer[index+1:], self.buffer[index:])    // Shift the elements over
0000000000000000000000000000000000000000;;			self.buffer[index] = data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove any elements before eviction time.
0000000000000000000000000000000000000000;;		// TODO(rjnagal): This is assuming that the added entry has timestamp close to now.
0000000000000000000000000000000000000000;;		evictTime := timestamp.Add(-self.age)
0000000000000000000000000000000000000000;;		index := sort.Search(len(self.buffer), func(index int) bool {
0000000000000000000000000000000000000000;;			return self.buffer[index].timestamp.After(evictTime)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if index < len(self.buffer) {
0000000000000000000000000000000000000000;;			self.buffer = self.buffer[index:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove any elements if over our max size.
0000000000000000000000000000000000000000;;		if self.maxItems >= 0 && len(self.buffer) > self.maxItems {
0000000000000000000000000000000000000000;;			startIndex := len(self.buffer) - self.maxItems
0000000000000000000000000000000000000000;;			self.buffer = self.buffer[startIndex:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns up to maxResult elements in the specified time period (inclusive).
0000000000000000000000000000000000000000;;	// Results are from first to last. maxResults of -1 means no limit.
0000000000000000000000000000000000000000;;	func (self *TimedStore) InTimeRange(start, end time.Time, maxResults int) []interface{} {
0000000000000000000000000000000000000000;;		// No stats, return empty.
0000000000000000000000000000000000000000;;		if len(self.buffer) == 0 {
0000000000000000000000000000000000000000;;			return []interface{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var startIndex int
0000000000000000000000000000000000000000;;		if start.IsZero() {
0000000000000000000000000000000000000000;;			// None specified, start at the beginning.
0000000000000000000000000000000000000000;;			startIndex = len(self.buffer) - 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Start is the index before the elements smaller than it. We do this by
0000000000000000000000000000000000000000;;			// finding the first element smaller than start and taking the index
0000000000000000000000000000000000000000;;			// before that element
0000000000000000000000000000000000000000;;			startIndex = sort.Search(len(self.buffer), func(index int) bool {
0000000000000000000000000000000000000000;;				// buffer[index] < start
0000000000000000000000000000000000000000;;				return self.getData(index).timestamp.Before(start)
0000000000000000000000000000000000000000;;			}) - 1
0000000000000000000000000000000000000000;;			// Check if start is after all the data we have.
0000000000000000000000000000000000000000;;			if startIndex < 0 {
0000000000000000000000000000000000000000;;				return []interface{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var endIndex int
0000000000000000000000000000000000000000;;		if end.IsZero() {
0000000000000000000000000000000000000000;;			// None specified, end with the latest stats.
0000000000000000000000000000000000000000;;			endIndex = 0
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// End is the first index smaller than or equal to it (so, not larger).
0000000000000000000000000000000000000000;;			endIndex = sort.Search(len(self.buffer), func(index int) bool {
0000000000000000000000000000000000000000;;				// buffer[index] <= t -> !(buffer[index] > t)
0000000000000000000000000000000000000000;;				return !self.getData(index).timestamp.After(end)
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			// Check if end is before all the data we have.
0000000000000000000000000000000000000000;;			if endIndex == len(self.buffer) {
0000000000000000000000000000000000000000;;				return []interface{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trim to maxResults size.
0000000000000000000000000000000000000000;;		numResults := startIndex - endIndex + 1
0000000000000000000000000000000000000000;;		if maxResults != -1 && numResults > maxResults {
0000000000000000000000000000000000000000;;			startIndex -= numResults - maxResults
0000000000000000000000000000000000000000;;			numResults = maxResults
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Return in sorted timestamp order so from the "back" to "front".
0000000000000000000000000000000000000000;;		result := make([]interface{}, numResults)
0000000000000000000000000000000000000000;;		for i := 0; i < numResults; i++ {
0000000000000000000000000000000000000000;;			result[i] = self.Get(startIndex - i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the element at the specified index. Note that elements are output in LIFO order.
0000000000000000000000000000000000000000;;	func (self *TimedStore) Get(index int) interface{} {
0000000000000000000000000000000000000000;;		return self.getData(index).data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Gets the data at the specified index. Note that elements are output in LIFO order.
0000000000000000000000000000000000000000;;	func (self *TimedStore) getData(index int) timedStoreData {
0000000000000000000000000000000000000000;;		return self.buffer[len(self.buffer)-index-1]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *TimedStore) Size() int {
0000000000000000000000000000000000000000;;		return len(self.buffer)
0000000000000000000000000000000000000000;;	}
