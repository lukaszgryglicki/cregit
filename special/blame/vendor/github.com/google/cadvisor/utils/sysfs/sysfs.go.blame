0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/utils/sysfs/sysfs.go[Godeps/_workspace/src/github.com/google/cadvisor/utils/sysfs/sysfs.go][vendor/github.com/google/cadvisor/utils/sysfs/sysfs.go];	
0000000000000000000000000000000000000000;;	package sysfs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		blockDir     = "/sys/block"
0000000000000000000000000000000000000000;;		cacheDir     = "/sys/devices/system/cpu/cpu"
0000000000000000000000000000000000000000;;		netDir       = "/sys/class/net"
0000000000000000000000000000000000000000;;		dmiDir       = "/sys/class/dmi"
0000000000000000000000000000000000000000;;		ppcDevTree   = "/proc/device-tree"
0000000000000000000000000000000000000000;;		s390xDevTree = "/etc" // s390/s390x changes
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CacheInfo struct {
0000000000000000000000000000000000000000;;		// size in bytes
0000000000000000000000000000000000000000;;		Size uint64
0000000000000000000000000000000000000000;;		// cache type - instruction, data, unified
0000000000000000000000000000000000000000;;		Type string
0000000000000000000000000000000000000000;;		// distance from cpus in a multi-level hierarchy
0000000000000000000000000000000000000000;;		Level int
0000000000000000000000000000000000000000;;		// number of cpus that can access this cache.
0000000000000000000000000000000000000000;;		Cpus int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Abstracts the lowest level calls to sysfs.
0000000000000000000000000000000000000000;;	type SysFs interface {
0000000000000000000000000000000000000000;;		// Get directory information for available block devices.
0000000000000000000000000000000000000000;;		GetBlockDevices() ([]os.FileInfo, error)
0000000000000000000000000000000000000000;;		// Get Size of a given block device.
0000000000000000000000000000000000000000;;		GetBlockDeviceSize(string) (string, error)
0000000000000000000000000000000000000000;;		// Get scheduler type for the block device.
0000000000000000000000000000000000000000;;		GetBlockDeviceScheduler(string) (string, error)
0000000000000000000000000000000000000000;;		// Get device major:minor number string.
0000000000000000000000000000000000000000;;		GetBlockDeviceNumbers(string) (string, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GetNetworkDevices() ([]os.FileInfo, error)
0000000000000000000000000000000000000000;;		GetNetworkAddress(string) (string, error)
0000000000000000000000000000000000000000;;		GetNetworkMtu(string) (string, error)
0000000000000000000000000000000000000000;;		GetNetworkSpeed(string) (string, error)
0000000000000000000000000000000000000000;;		GetNetworkStatValue(dev string, stat string) (uint64, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get directory information for available caches accessible to given cpu.
0000000000000000000000000000000000000000;;		GetCaches(id int) ([]os.FileInfo, error)
0000000000000000000000000000000000000000;;		// Get information for a cache accessible from the given cpu.
0000000000000000000000000000000000000000;;		GetCacheInfo(cpu int, cache string) (CacheInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GetSystemUUID() (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realSysFs struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRealSysFs() SysFs {
0000000000000000000000000000000000000000;;		return &realSysFs{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetBlockDevices() ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return ioutil.ReadDir(blockDir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetBlockDeviceNumbers(name string) (string, error) {
0000000000000000000000000000000000000000;;		dev, err := ioutil.ReadFile(path.Join(blockDir, name, "/dev"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(dev), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetBlockDeviceScheduler(name string) (string, error) {
0000000000000000000000000000000000000000;;		sched, err := ioutil.ReadFile(path.Join(blockDir, name, "/queue/scheduler"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(sched), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetBlockDeviceSize(name string) (string, error) {
0000000000000000000000000000000000000000;;		size, err := ioutil.ReadFile(path.Join(blockDir, name, "/size"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(size), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetNetworkDevices() ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		files, err := ioutil.ReadDir(netDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Filter out non-directory & non-symlink files
0000000000000000000000000000000000000000;;		var dirs []os.FileInfo
0000000000000000000000000000000000000000;;		for _, f := range files {
0000000000000000000000000000000000000000;;			if f.Mode()|os.ModeSymlink != 0 {
0000000000000000000000000000000000000000;;				f, err = os.Stat(path.Join(netDir, f.Name()))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.IsDir() {
0000000000000000000000000000000000000000;;				dirs = append(dirs, f)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dirs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetNetworkAddress(name string) (string, error) {
0000000000000000000000000000000000000000;;		address, err := ioutil.ReadFile(path.Join(netDir, name, "/address"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(address), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetNetworkMtu(name string) (string, error) {
0000000000000000000000000000000000000000;;		mtu, err := ioutil.ReadFile(path.Join(netDir, name, "/mtu"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(mtu), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetNetworkSpeed(name string) (string, error) {
0000000000000000000000000000000000000000;;		speed, err := ioutil.ReadFile(path.Join(netDir, name, "/speed"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(speed), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetNetworkStatValue(dev string, stat string) (uint64, error) {
0000000000000000000000000000000000000000;;		statPath := path.Join(netDir, dev, "/statistics", stat)
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile(statPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to read stat from %q for device %q", statPath, dev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var s uint64
0000000000000000000000000000000000000000;;		n, err := fmt.Sscanf(string(out), "%d", &s)
0000000000000000000000000000000000000000;;		if err != nil || n != 1 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("could not parse value from %q for file %s", string(out), statPath)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetCaches(id int) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		cpuPath := fmt.Sprintf("%s%d/cache", cacheDir, id)
0000000000000000000000000000000000000000;;		return ioutil.ReadDir(cpuPath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func bitCount(i uint64) (count int) {
0000000000000000000000000000000000000000;;		for i != 0 {
0000000000000000000000000000000000000000;;			if i&1 == 1 {
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i >>= 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getCpuCount(cache string) (count int, err error) {
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile(path.Join(cache, "/shared_cpu_map"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		masks := strings.Split(string(out), ",")
0000000000000000000000000000000000000000;;		for _, mask := range masks {
0000000000000000000000000000000000000000;;			// convert hex string to uint64
0000000000000000000000000000000000000000;;			m, err := strconv.ParseUint(strings.TrimSpace(mask), 16, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("failed to parse cpu map %q: %v", string(out), err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count += bitCount(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetCacheInfo(id int, name string) (CacheInfo, error) {
0000000000000000000000000000000000000000;;		cachePath := fmt.Sprintf("%s%d/cache/%s", cacheDir, id, name)
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile(path.Join(cachePath, "/size"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return CacheInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var size uint64
0000000000000000000000000000000000000000;;		n, err := fmt.Sscanf(string(out), "%dK", &size)
0000000000000000000000000000000000000000;;		if err != nil || n != 1 {
0000000000000000000000000000000000000000;;			return CacheInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// convert to bytes
0000000000000000000000000000000000000000;;		size = size * 1024
0000000000000000000000000000000000000000;;		out, err = ioutil.ReadFile(path.Join(cachePath, "/level"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return CacheInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var level int
0000000000000000000000000000000000000000;;		n, err = fmt.Sscanf(string(out), "%d", &level)
0000000000000000000000000000000000000000;;		if err != nil || n != 1 {
0000000000000000000000000000000000000000;;			return CacheInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err = ioutil.ReadFile(path.Join(cachePath, "/type"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return CacheInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cacheType := strings.TrimSpace(string(out))
0000000000000000000000000000000000000000;;		cpuCount, err := getCpuCount(cachePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return CacheInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return CacheInfo{
0000000000000000000000000000000000000000;;			Size:  size,
0000000000000000000000000000000000000000;;			Level: level,
0000000000000000000000000000000000000000;;			Type:  cacheType,
0000000000000000000000000000000000000000;;			Cpus:  cpuCount,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *realSysFs) GetSystemUUID() (string, error) {
0000000000000000000000000000000000000000;;		if id, err := ioutil.ReadFile(path.Join(dmiDir, "id", "product_uuid")); err == nil {
0000000000000000000000000000000000000000;;			return strings.TrimSpace(string(id)), nil
0000000000000000000000000000000000000000;;		} else if id, err = ioutil.ReadFile(path.Join(ppcDevTree, "system-id")); err == nil {
0000000000000000000000000000000000000000;;			return strings.TrimSpace(string(id)), nil
0000000000000000000000000000000000000000;;		} else if id, err = ioutil.ReadFile(path.Join(ppcDevTree, "vm,uuid")); err == nil {
0000000000000000000000000000000000000000;;			return strings.TrimSpace(string(id)), nil
0000000000000000000000000000000000000000;;		} else if id, err = ioutil.ReadFile(path.Join(s390xDevTree, "machine-id")); err == nil {
0000000000000000000000000000000000000000;;			return strings.TrimSpace(string(id)), nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
