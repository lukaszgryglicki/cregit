0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/utils/oomparser/oomparser.go[Godeps/_workspace/src/github.com/google/cadvisor/utils/oomparser/oomparser.go][vendor/github.com/google/cadvisor/utils/oomparser/oomparser.go];	
0000000000000000000000000000000000000000;;	package oomparser
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/tail"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		containerRegexp = regexp.MustCompile(`Task in (.*) killed as a result of limit of (.*)`)
0000000000000000000000000000000000000000;;		lastLineRegexp  = regexp.MustCompile(`(^[A-Z][a-z]{2} .*[0-9]{1,2} [0-9]{1,2}:[0-9]{2}:[0-9]{2}) .* Killed process ([0-9]+) \(([\w]+)\)`)
0000000000000000000000000000000000000000;;		firstLineRegexp = regexp.MustCompile(`invoked oom-killer:`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// struct to hold file from which we obtain OomInstances
0000000000000000000000000000000000000000;;	type OomParser struct {
0000000000000000000000000000000000000000;;		ioreader *bufio.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// struct that contains information related to an OOM kill instance
0000000000000000000000000000000000000000;;	type OomInstance struct {
0000000000000000000000000000000000000000;;		// process id of the killed process
0000000000000000000000000000000000000000;;		Pid int
0000000000000000000000000000000000000000;;		// the name of the killed process
0000000000000000000000000000000000000000;;		ProcessName string
0000000000000000000000000000000000000000;;		// the time that the process was reported to be killed,
0000000000000000000000000000000000000000;;		// accurate to the minute
0000000000000000000000000000000000000000;;		TimeOfDeath time.Time
0000000000000000000000000000000000000000;;		// the absolute name of the container that OOMed
0000000000000000000000000000000000000000;;		ContainerName string
0000000000000000000000000000000000000000;;		// the absolute name of the container that was killed
0000000000000000000000000000000000000000;;		// due to the OOM.
0000000000000000000000000000000000000000;;		VictimContainerName string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gets the container name from a line and adds it to the oomInstance.
0000000000000000000000000000000000000000;;	func getContainerName(line string, currentOomInstance *OomInstance) error {
0000000000000000000000000000000000000000;;		parsedLine := containerRegexp.FindStringSubmatch(line)
0000000000000000000000000000000000000000;;		if parsedLine == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentOomInstance.ContainerName = path.Join("/", parsedLine[1])
0000000000000000000000000000000000000000;;		currentOomInstance.VictimContainerName = path.Join("/", parsedLine[2])
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gets the pid, name, and date from a line and adds it to oomInstance
0000000000000000000000000000000000000000;;	func getProcessNamePid(line string, currentOomInstance *OomInstance) (bool, error) {
0000000000000000000000000000000000000000;;		reList := lastLineRegexp.FindStringSubmatch(line)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if reList == nil {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		const longForm = "Jan _2 15:04:05 2006"
0000000000000000000000000000000000000000;;		stringYear := strconv.Itoa(time.Now().Year())
0000000000000000000000000000000000000000;;		linetime, err := time.ParseInLocation(longForm, reList[1]+" "+stringYear, time.Local)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentOomInstance.TimeOfDeath = linetime
0000000000000000000000000000000000000000;;		pid, err := strconv.Atoi(reList[2])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		currentOomInstance.Pid = pid
0000000000000000000000000000000000000000;;		currentOomInstance.ProcessName = reList[3]
0000000000000000000000000000000000000000;;		return true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// uses regex to see if line is the start of a kernel oom log
0000000000000000000000000000000000000000;;	func checkIfStartOfOomMessages(line string) bool {
0000000000000000000000000000000000000000;;		potential_oom_start := firstLineRegexp.MatchString(line)
0000000000000000000000000000000000000000;;		if potential_oom_start {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// reads the file and sends only complete lines over a channel to analyzeLines.
0000000000000000000000000000000000000000;;	// Should prevent EOF errors that occur when lines are read before being fully
0000000000000000000000000000000000000000;;	// written to the log. It reads line by line splitting on
0000000000000000000000000000000000000000;;	// the "\n" character.
0000000000000000000000000000000000000000;;	func readLinesFromFile(lineChannel chan string, ioreader *bufio.Reader) error {
0000000000000000000000000000000000000000;;		linefragment := ""
0000000000000000000000000000000000000000;;		var line string
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for true {
0000000000000000000000000000000000000000;;			line, err = ioreader.ReadString('\n')
0000000000000000000000000000000000000000;;			if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;				glog.Errorf("exiting analyzeLinesHelper with error %v", err)
0000000000000000000000000000000000000000;;				close(lineChannel)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if line == "" {
0000000000000000000000000000000000000000;;				time.Sleep(100 * time.Millisecond)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				lineChannel <- linefragment + line
0000000000000000000000000000000000000000;;				linefragment = ""
0000000000000000000000000000000000000000;;			} else { // err == io.EOF
0000000000000000000000000000000000000000;;				linefragment += line
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calls goroutine for readLinesFromFile, which feeds it complete lines.
0000000000000000000000000000000000000000;;	// Lines are checked against a regexp to check for the pid, process name, etc.
0000000000000000000000000000000000000000;;	// At the end of an oom message group, StreamOoms adds the new oomInstance to
0000000000000000000000000000000000000000;;	// oomLog
0000000000000000000000000000000000000000;;	func (self *OomParser) StreamOoms(outStream chan *OomInstance) {
0000000000000000000000000000000000000000;;		lineChannel := make(chan string, 10)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			readLinesFromFile(lineChannel, self.ioreader)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for line := range lineChannel {
0000000000000000000000000000000000000000;;			in_oom_kernel_log := checkIfStartOfOomMessages(line)
0000000000000000000000000000000000000000;;			if in_oom_kernel_log {
0000000000000000000000000000000000000000;;				oomCurrentInstance := &OomInstance{
0000000000000000000000000000000000000000;;					ContainerName: "/",
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for line := range lineChannel {
0000000000000000000000000000000000000000;;					err := getContainerName(line, oomCurrentInstance)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("%v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					finished, err := getProcessNamePid(line, oomCurrentInstance)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("%v", err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if finished {
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				outStream <- oomCurrentInstance
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("exiting analyzeLines. OOM events will not be reported.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func callJournalctl() (io.ReadCloser, error) {
0000000000000000000000000000000000000000;;		cmd := exec.Command("journalctl", "-k", "-f")
0000000000000000000000000000000000000000;;		readcloser, err := cmd.StdoutPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := cmd.Start(); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return readcloser, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trySystemd() (*OomParser, error) {
0000000000000000000000000000000000000000;;		readcloser, err := callJournalctl()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("oomparser using systemd")
0000000000000000000000000000000000000000;;		return &OomParser{
0000000000000000000000000000000000000000;;			ioreader: bufio.NewReader(readcloser),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List of possible kernel log files. These are prioritized in order so that
0000000000000000000000000000000000000000;;	// we will use the first one that is available.
0000000000000000000000000000000000000000;;	var kernelLogFiles = []string{"/var/log/kern.log", "/var/log/messages", "/var/log/syslog"}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// looks for system files that contain kernel messages and if one is found, sets
0000000000000000000000000000000000000000;;	// the systemFile attribute of the OomParser object
0000000000000000000000000000000000000000;;	func getLogFile() (string, error) {
0000000000000000000000000000000000000000;;		for _, logFile := range kernelLogFiles {
0000000000000000000000000000000000000000;;			if utils.FileExists(logFile) {
0000000000000000000000000000000000000000;;				glog.Infof("OOM parser using kernel log file: %q", logFile)
0000000000000000000000000000000000000000;;				return logFile, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("unable to find any kernel log file available from our set: %v", kernelLogFiles)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tryLogFile() (*OomParser, error) {
0000000000000000000000000000000000000000;;		logFile, err := getLogFile()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tail, err := tail.NewTail(logFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &OomParser{
0000000000000000000000000000000000000000;;			ioreader: bufio.NewReader(tail),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// initializes an OomParser object. Returns an OomParser object and an error.
0000000000000000000000000000000000000000;;	func New() (*OomParser, error) {
0000000000000000000000000000000000000000;;		parser, err := trySystemd()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return parser, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser, err = tryLogFile()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return parser, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
