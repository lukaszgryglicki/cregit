0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/utils/sysinfo/sysinfo.go[Godeps/_workspace/src/github.com/google/cadvisor/utils/sysinfo/sysinfo.go][vendor/github.com/google/cadvisor/utils/sysinfo/sysinfo.go];	
0000000000000000000000000000000000000000;;	package sysinfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/sysfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var schedulerRegExp = regexp.MustCompile(`.*\[(.*)\].*`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get information about block devices present on the system.
0000000000000000000000000000000000000000;;	// Uses the passed in system interface to retrieve the low level OS information.
0000000000000000000000000000000000000000;;	func GetBlockDeviceInfo(sysfs sysfs.SysFs) (map[string]info.DiskInfo, error) {
0000000000000000000000000000000000000000;;		disks, err := sysfs.GetBlockDevices()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskMap := make(map[string]info.DiskInfo)
0000000000000000000000000000000000000000;;		for _, disk := range disks {
0000000000000000000000000000000000000000;;			name := disk.Name()
0000000000000000000000000000000000000000;;			// Ignore non-disk devices.
0000000000000000000000000000000000000000;;			// TODO(rjnagal): Maybe just match hd, sd, and dm prefixes.
0000000000000000000000000000000000000000;;			if strings.HasPrefix(name, "loop") || strings.HasPrefix(name, "ram") || strings.HasPrefix(name, "sr") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			disk_info := info.DiskInfo{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dev, err := sysfs.GetBlockDeviceNumbers(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, err := fmt.Sscanf(dev, "%d:%d", &disk_info.Major, &disk_info.Minor)
0000000000000000000000000000000000000000;;			if err != nil || n != 2 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse device numbers from %s for device %s", dev, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out, err := sysfs.GetBlockDeviceSize(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Remove trailing newline before conversion.
0000000000000000000000000000000000000000;;			size, err := strconv.ParseUint(strings.TrimSpace(out), 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// size is in 512 bytes blocks.
0000000000000000000000000000000000000000;;			disk_info.Size = size * 512
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			disk_info.Scheduler = "none"
0000000000000000000000000000000000000000;;			blkSched, err := sysfs.GetBlockDeviceScheduler(name)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				matches := schedulerRegExp.FindSubmatch([]byte(blkSched))
0000000000000000000000000000000000000000;;				if len(matches) >= 2 {
0000000000000000000000000000000000000000;;					disk_info.Scheduler = string(matches[1])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			device := fmt.Sprintf("%d:%d", disk_info.Major, disk_info.Minor)
0000000000000000000000000000000000000000;;			diskMap[device] = disk_info
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return diskMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get information about network devices present on the system.
0000000000000000000000000000000000000000;;	func GetNetworkDevices(sysfs sysfs.SysFs) ([]info.NetInfo, error) {
0000000000000000000000000000000000000000;;		devs, err := sysfs.GetNetworkDevices()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		netDevices := []info.NetInfo{}
0000000000000000000000000000000000000000;;		for _, dev := range devs {
0000000000000000000000000000000000000000;;			name := dev.Name()
0000000000000000000000000000000000000000;;			// Ignore docker, loopback, and veth devices.
0000000000000000000000000000000000000000;;			ignoredDevices := []string{"lo", "veth", "docker"}
0000000000000000000000000000000000000000;;			ignored := false
0000000000000000000000000000000000000000;;			for _, prefix := range ignoredDevices {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(name, prefix) {
0000000000000000000000000000000000000000;;					ignored = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ignored {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			address, err := sysfs.GetNetworkAddress(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mtuStr, err := sysfs.GetNetworkMtu(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var mtu int64
0000000000000000000000000000000000000000;;			n, err := fmt.Sscanf(mtuStr, "%d", &mtu)
0000000000000000000000000000000000000000;;			if err != nil || n != 1 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse mtu from %s for device %s", mtuStr, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			netInfo := info.NetInfo{
0000000000000000000000000000000000000000;;				Name:       name,
0000000000000000000000000000000000000000;;				MacAddress: strings.TrimSpace(address),
0000000000000000000000000000000000000000;;				Mtu:        mtu,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			speed, err := sysfs.GetNetworkSpeed(name)
0000000000000000000000000000000000000000;;			// Some devices don't set speed.
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				var s int64
0000000000000000000000000000000000000000;;				n, err := fmt.Sscanf(speed, "%d", &s)
0000000000000000000000000000000000000000;;				if err != nil || n != 1 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("could not parse speed from %s for device %s", speed, name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				netInfo.Speed = s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			netDevices = append(netDevices, netInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return netDevices, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetCacheInfo(sysFs sysfs.SysFs, id int) ([]sysfs.CacheInfo, error) {
0000000000000000000000000000000000000000;;		caches, err := sysFs.GetCaches(id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info := []sysfs.CacheInfo{}
0000000000000000000000000000000000000000;;		for _, cache := range caches {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(cache.Name(), "index") {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cacheInfo, err := sysFs.GetCacheInfo(id, cache.Name())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			info = append(info, cacheInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return info, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetNetworkStats(name string) (info.InterfaceStats, error) {
0000000000000000000000000000000000000000;;		// TODO(rjnagal): Take syfs as an argument.
0000000000000000000000000000000000000000;;		sysFs := sysfs.NewRealSysFs()
0000000000000000000000000000000000000000;;		return getNetworkStats(name, sysFs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getNetworkStats(name string, sysFs sysfs.SysFs) (info.InterfaceStats, error) {
0000000000000000000000000000000000000000;;		var stats info.InterfaceStats
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		stats.Name = name
0000000000000000000000000000000000000000;;		stats.RxBytes, err = sysFs.GetNetworkStatValue(name, "rx_bytes")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.RxPackets, err = sysFs.GetNetworkStatValue(name, "rx_packets")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.RxErrors, err = sysFs.GetNetworkStatValue(name, "rx_errors")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.RxDropped, err = sysFs.GetNetworkStatValue(name, "rx_dropped")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.TxBytes, err = sysFs.GetNetworkStatValue(name, "tx_bytes")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.TxPackets, err = sysFs.GetNetworkStatValue(name, "tx_packets")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.TxErrors, err = sysFs.GetNetworkStatValue(name, "tx_errors")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats.TxDropped, err = sysFs.GetNetworkStatValue(name, "tx_dropped")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetSystemUUID(sysFs sysfs.SysFs) (string, error) {
0000000000000000000000000000000000000000;;		return sysFs.GetSystemUUID()
0000000000000000000000000000000000000000;;	}
