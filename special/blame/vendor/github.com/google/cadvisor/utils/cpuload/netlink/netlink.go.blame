0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/utils/cpuload/netlink/netlink.go[Godeps/_workspace/src/github.com/google/cadvisor/utils/cpuload/netlink/netlink.go][vendor/github.com/google/cadvisor/utils/cpuload/netlink/netlink.go];	
0000000000000000000000000000000000000000;;	package netlink
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Kernel constants for tasks stats.
0000000000000000000000000000000000000000;;		genlIdCtrl           = syscall.NLMSG_MIN_TYPE // GENL_ID_CTRL
0000000000000000000000000000000000000000;;		taskstatsGenlName    = "TASKSTATS"            // TASKSTATS_GENL_NAME
0000000000000000000000000000000000000000;;		cgroupStatsCmdAttrFd = 0x1                    // CGROUPSTATS_CMD_ATTR_FD
0000000000000000000000000000000000000000;;		ctrlAttrFamilyId     = 0x1                    // CTRL_ATTR_FAMILY_ID
0000000000000000000000000000000000000000;;		ctrlAttrFamilyName   = 0x2                    // CTRL_ATTR_FAMILY_NAME
0000000000000000000000000000000000000000;;		ctrlCmdGetFamily     = 0x3                    // CTRL_CMD_GETFAMILY
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// TODO(rjnagal): Verify and fix for other architectures.
0000000000000000000000000000000000000000;;		Endian = binary.LittleEndian
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type genMsghdr struct {
0000000000000000000000000000000000000000;;		Command  uint8
0000000000000000000000000000000000000000;;		Version  uint8
0000000000000000000000000000000000000000;;		Reserved uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type netlinkMessage struct {
0000000000000000000000000000000000000000;;		Header    syscall.NlMsghdr
0000000000000000000000000000000000000000;;		GenHeader genMsghdr
0000000000000000000000000000000000000000;;		Data      []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self netlinkMessage) toRawMsg() (rawmsg syscall.NetlinkMessage) {
0000000000000000000000000000000000000000;;		rawmsg.Header = self.Header
0000000000000000000000000000000000000000;;		w := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		binary.Write(w, Endian, self.GenHeader)
0000000000000000000000000000000000000000;;		w.Write(self.Data)
0000000000000000000000000000000000000000;;		rawmsg.Data = w.Bytes()
0000000000000000000000000000000000000000;;		return rawmsg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type loadStatsResp struct {
0000000000000000000000000000000000000000;;		Header    syscall.NlMsghdr
0000000000000000000000000000000000000000;;		GenHeader genMsghdr
0000000000000000000000000000000000000000;;		Stats     info.LoadStats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return required padding to align 'size' to 'alignment'.
0000000000000000000000000000000000000000;;	func padding(size int, alignment int) int {
0000000000000000000000000000000000000000;;		unalignedPart := size % alignment
0000000000000000000000000000000000000000;;		return (alignment - unalignedPart) % alignment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get family id for taskstats subsystem.
0000000000000000000000000000000000000000;;	func getFamilyId(conn *Connection) (uint16, error) {
0000000000000000000000000000000000000000;;		msg := prepareFamilyMessage()
0000000000000000000000000000000000000000;;		conn.WriteMessage(msg.toRawMsg())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := conn.ReadMessage()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id, err := parseFamilyResp(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return id, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Append an attribute to the message.
0000000000000000000000000000000000000000;;	// Adds attribute info (length and type), followed by the data and necessary padding.
0000000000000000000000000000000000000000;;	// Can be called multiple times to add attributes. Only fixed size and string type
0000000000000000000000000000000000000000;;	// attributes are handled. We don't need nested attributes for task stats.
0000000000000000000000000000000000000000;;	func addAttribute(buf *bytes.Buffer, attrType uint16, data interface{}, dataSize int) {
0000000000000000000000000000000000000000;;		attr := syscall.RtAttr{
0000000000000000000000000000000000000000;;			Len:  syscall.SizeofRtAttr,
0000000000000000000000000000000000000000;;			Type: attrType,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attr.Len += uint16(dataSize)
0000000000000000000000000000000000000000;;		binary.Write(buf, Endian, attr)
0000000000000000000000000000000000000000;;		switch data := data.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			binary.Write(buf, Endian, []byte(data))
0000000000000000000000000000000000000000;;			buf.WriteByte(0) // terminate
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			binary.Write(buf, Endian, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < padding(int(attr.Len), syscall.NLMSG_ALIGNTO); i++ {
0000000000000000000000000000000000000000;;			buf.WriteByte(0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prepares the message and generic headers and appends attributes as data.
0000000000000000000000000000000000000000;;	func prepareMessage(headerType uint16, cmd uint8, attributes []byte) (msg netlinkMessage) {
0000000000000000000000000000000000000000;;		msg.Header.Type = headerType
0000000000000000000000000000000000000000;;		msg.Header.Flags = syscall.NLM_F_REQUEST
0000000000000000000000000000000000000000;;		msg.GenHeader.Command = cmd
0000000000000000000000000000000000000000;;		msg.GenHeader.Version = 0x1
0000000000000000000000000000000000000000;;		msg.Data = attributes
0000000000000000000000000000000000000000;;		return msg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prepares message to query family id for task stats.
0000000000000000000000000000000000000000;;	func prepareFamilyMessage() (msg netlinkMessage) {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		addAttribute(buf, ctrlAttrFamilyName, taskstatsGenlName, len(taskstatsGenlName)+1)
0000000000000000000000000000000000000000;;		return prepareMessage(genlIdCtrl, ctrlCmdGetFamily, buf.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prepares message to query task stats for a task group.
0000000000000000000000000000000000000000;;	func prepareCmdMessage(id uint16, cfd uintptr) (msg netlinkMessage) {
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer([]byte{})
0000000000000000000000000000000000000000;;		addAttribute(buf, cgroupStatsCmdAttrFd, uint32(cfd), 4)
0000000000000000000000000000000000000000;;		return prepareMessage(id, __TASKSTATS_CMD_MAX+1, buf.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extracts returned family id from the response.
0000000000000000000000000000000000000000;;	func parseFamilyResp(msg syscall.NetlinkMessage) (uint16, error) {
0000000000000000000000000000000000000000;;		m := new(netlinkMessage)
0000000000000000000000000000000000000000;;		m.Header = msg.Header
0000000000000000000000000000000000000000;;		err := verifyHeader(msg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(msg.Data)
0000000000000000000000000000000000000000;;		// extract generic header from data.
0000000000000000000000000000000000000000;;		err = binary.Read(buf, Endian, &m.GenHeader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		id := uint16(0)
0000000000000000000000000000000000000000;;		// Extract attributes. kernel reports family name, id, version, etc.
0000000000000000000000000000000000000000;;		// Scan till we find id.
0000000000000000000000000000000000000000;;		for buf.Len() > syscall.SizeofRtAttr {
0000000000000000000000000000000000000000;;			var attr syscall.RtAttr
0000000000000000000000000000000000000000;;			err = binary.Read(buf, Endian, &attr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if attr.Type == ctrlAttrFamilyId {
0000000000000000000000000000000000000000;;				err = binary.Read(buf, Endian, &id)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return 0, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return id, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			payload := int(attr.Len) - syscall.SizeofRtAttr
0000000000000000000000000000000000000000;;			skipLen := payload + padding(payload, syscall.SizeofRtAttr)
0000000000000000000000000000000000000000;;			name := make([]byte, skipLen)
0000000000000000000000000000000000000000;;			err = binary.Read(buf, Endian, name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("family id not found in the response.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract task stats from response returned by kernel.
0000000000000000000000000000000000000000;;	func parseLoadStatsResp(msg syscall.NetlinkMessage) (*loadStatsResp, error) {
0000000000000000000000000000000000000000;;		m := new(loadStatsResp)
0000000000000000000000000000000000000000;;		m.Header = msg.Header
0000000000000000000000000000000000000000;;		err := verifyHeader(msg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return m, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(msg.Data)
0000000000000000000000000000000000000000;;		// Scan the general header.
0000000000000000000000000000000000000000;;		err = binary.Read(buf, Endian, &m.GenHeader)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return m, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// cgroup stats response should have just one attribute.
0000000000000000000000000000000000000000;;		// Read it directly into the stats structure.
0000000000000000000000000000000000000000;;		var attr syscall.RtAttr
0000000000000000000000000000000000000000;;		err = binary.Read(buf, Endian, &attr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return m, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = binary.Read(buf, Endian, &m.Stats)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return m, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify and return any error reported by kernel.
0000000000000000000000000000000000000000;;	func verifyHeader(msg syscall.NetlinkMessage) error {
0000000000000000000000000000000000000000;;		switch msg.Header.Type {
0000000000000000000000000000000000000000;;		case syscall.NLMSG_DONE:
0000000000000000000000000000000000000000;;			return fmt.Errorf("expected a response, got nil")
0000000000000000000000000000000000000000;;		case syscall.NLMSG_ERROR:
0000000000000000000000000000000000000000;;			buf := bytes.NewBuffer(msg.Data)
0000000000000000000000000000000000000000;;			var errno int32
0000000000000000000000000000000000000000;;			binary.Read(buf, Endian, errno)
0000000000000000000000000000000000000000;;			return fmt.Errorf("netlink request failed with error %s", syscall.Errno(-errno))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get load stats for a task group.
0000000000000000000000000000000000000000;;	// id: family id for taskstats.
0000000000000000000000000000000000000000;;	// cfd: open file to path to the cgroup directory under cpu hierarchy.
0000000000000000000000000000000000000000;;	// conn: open netlink connection used to communicate with kernel.
0000000000000000000000000000000000000000;;	func getLoadStats(id uint16, cfd *os.File, conn *Connection) (info.LoadStats, error) {
0000000000000000000000000000000000000000;;		msg := prepareCmdMessage(id, cfd.Fd())
0000000000000000000000000000000000000000;;		err := conn.WriteMessage(msg.toRawMsg())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return info.LoadStats{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := conn.ReadMessage()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return info.LoadStats{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parsedmsg, err := parseLoadStatsResp(resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return info.LoadStats{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parsedmsg.Stats, nil
0000000000000000000000000000000000000000;;	}
