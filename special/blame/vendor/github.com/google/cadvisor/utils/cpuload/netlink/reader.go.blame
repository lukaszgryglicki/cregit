0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/utils/cpuload/netlink/reader.go[Godeps/_workspace/src/github.com/google/cadvisor/utils/cpuload/netlink/reader.go][vendor/github.com/google/cadvisor/utils/cpuload/netlink/reader.go];	
0000000000000000000000000000000000000000;;	package netlink
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetlinkReader struct {
0000000000000000000000000000000000000000;;		familyId uint16
0000000000000000000000000000000000000000;;		conn     *Connection
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New() (*NetlinkReader, error) {
0000000000000000000000000000000000000000;;		conn, err := newConnection()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to create a new connection: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id, err := getFamilyId(conn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get netlink family id for task stats: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Family id for taskstats: %d", id)
0000000000000000000000000000000000000000;;		return &NetlinkReader{
0000000000000000000000000000000000000000;;			familyId: id,
0000000000000000000000000000000000000000;;			conn:     conn,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *NetlinkReader) Stop() {
0000000000000000000000000000000000000000;;		if self.conn != nil {
0000000000000000000000000000000000000000;;			self.conn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *NetlinkReader) Start() error {
0000000000000000000000000000000000000000;;		// We do the start setup for netlink in New(). Nothing to do here.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns instantaneous number of running tasks in a group.
0000000000000000000000000000000000000000;;	// Caller can use historical data to calculate cpu load.
0000000000000000000000000000000000000000;;	// path is an absolute filesystem path for a container under the CPU cgroup hierarchy.
0000000000000000000000000000000000000000;;	// NOTE: non-hierarchical load is returned. It does not include load for subcontainers.
0000000000000000000000000000000000000000;;	func (self *NetlinkReader) GetCpuLoad(name string, path string) (info.LoadStats, error) {
0000000000000000000000000000000000000000;;		if len(path) == 0 {
0000000000000000000000000000000000000000;;			return info.LoadStats{}, fmt.Errorf("cgroup path can not be empty!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfd, err := os.Open(path)
0000000000000000000000000000000000000000;;		defer cfd.Close()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return info.LoadStats{}, fmt.Errorf("failed to open cgroup path %s: %q", path, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats, err := getLoadStats(self.familyId, cfd, self.conn)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return info.LoadStats{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Task stats for %q: %+v", path, stats)
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
