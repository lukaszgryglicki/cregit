0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/utils/cpuload/netlink/conn.go[Godeps/_workspace/src/github.com/google/cadvisor/utils/cpuload/netlink/conn.go][vendor/github.com/google/cadvisor/utils/cpuload/netlink/conn.go];	
0000000000000000000000000000000000000000;;	package netlink
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Connection struct {
0000000000000000000000000000000000000000;;		// netlink socket
0000000000000000000000000000000000000000;;		fd int
0000000000000000000000000000000000000000;;		// cache pid to use in every netlink request.
0000000000000000000000000000000000000000;;		pid uint32
0000000000000000000000000000000000000000;;		// sequence number for netlink messages.
0000000000000000000000000000000000000000;;		seq  uint32
0000000000000000000000000000000000000000;;		addr syscall.SockaddrNetlink
0000000000000000000000000000000000000000;;		rbuf *bufio.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create and bind a new netlink socket.
0000000000000000000000000000000000000000;;	func newConnection() (*Connection, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fd, err := syscall.Socket(syscall.AF_NETLINK, syscall.SOCK_DGRAM, syscall.NETLINK_GENERIC)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn := new(Connection)
0000000000000000000000000000000000000000;;		conn.fd = fd
0000000000000000000000000000000000000000;;		conn.seq = 0
0000000000000000000000000000000000000000;;		conn.pid = uint32(os.Getpid())
0000000000000000000000000000000000000000;;		conn.addr.Family = syscall.AF_NETLINK
0000000000000000000000000000000000000000;;		conn.rbuf = bufio.NewReader(conn)
0000000000000000000000000000000000000000;;		err = syscall.Bind(fd, &conn.addr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			syscall.Close(fd)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Connection) Read(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		n, _, err = syscall.Recvfrom(self.fd, b, 0)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Connection) Write(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		err = syscall.Sendto(self.fd, b, 0, &self.addr)
0000000000000000000000000000000000000000;;		return len(b), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Connection) Close() error {
0000000000000000000000000000000000000000;;		return syscall.Close(self.fd)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Connection) WriteMessage(msg syscall.NetlinkMessage) error {
0000000000000000000000000000000000000000;;		w := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;		msg.Header.Len = uint32(syscall.NLMSG_HDRLEN + len(msg.Data))
0000000000000000000000000000000000000000;;		msg.Header.Seq = self.seq
0000000000000000000000000000000000000000;;		self.seq++
0000000000000000000000000000000000000000;;		msg.Header.Pid = self.pid
0000000000000000000000000000000000000000;;		binary.Write(w, binary.LittleEndian, msg.Header)
0000000000000000000000000000000000000000;;		_, err := w.Write(msg.Data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = self.Write(w.Bytes())
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *Connection) ReadMessage() (msg syscall.NetlinkMessage, err error) {
0000000000000000000000000000000000000000;;		err = binary.Read(self.rbuf, binary.LittleEndian, &msg.Header)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return msg, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg.Data = make([]byte, msg.Header.Len-syscall.NLMSG_HDRLEN)
0000000000000000000000000000000000000000;;		_, err = self.rbuf.Read(msg.Data)
0000000000000000000000000000000000000000;;		return msg, err
0000000000000000000000000000000000000000;;	}
