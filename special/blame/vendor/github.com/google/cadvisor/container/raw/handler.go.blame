0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/container/raw/handler.go[Godeps/_workspace/src/github.com/google/cadvisor/container/raw/handler.go][vendor/github.com/google/cadvisor/container/raw/handler.go];	
0000000000000000000000000000000000000000;;	// Handler for "raw" containers.
0000000000000000000000000000000000000000;;	package raw
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/common"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/libcontainer"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/machine"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		cgroupfs "github.com/opencontainers/runc/libcontainer/cgroups/fs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rawContainerHandler struct {
0000000000000000000000000000000000000000;;		// Name of the container for this handler.
0000000000000000000000000000000000000000;;		name               string
0000000000000000000000000000000000000000;;		cgroupSubsystems   *libcontainer.CgroupSubsystems
0000000000000000000000000000000000000000;;		machineInfoFactory info.MachineInfoFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Absolute path to the cgroup hierarchies of this container.
0000000000000000000000000000000000000000;;		// (e.g.: "cpu" -> "/sys/fs/cgroup/cpu/test")
0000000000000000000000000000000000000000;;		cgroupPaths map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Manager of this container's cgroups.
0000000000000000000000000000000000000000;;		cgroupManager cgroups.Manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsInfo         fs.FsInfo
0000000000000000000000000000000000000000;;		externalMounts []common.Mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootFs string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metrics to be ignored.
0000000000000000000000000000000000000000;;		ignoreMetrics container.MetricSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pid int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isRootCgroup(name string) bool {
0000000000000000000000000000000000000000;;		return name == "/"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRawContainerHandler(name string, cgroupSubsystems *libcontainer.CgroupSubsystems, machineInfoFactory info.MachineInfoFactory, fsInfo fs.FsInfo, watcher *common.InotifyWatcher, rootFs string, ignoreMetrics container.MetricSet) (container.ContainerHandler, error) {
0000000000000000000000000000000000000000;;		cgroupPaths := common.MakeCgroupPaths(cgroupSubsystems.MountPoints, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cHints, err := common.GetContainerHintsFromFile(*common.ArgContainerHints)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the equivalent cgroup manager for this container.
0000000000000000000000000000000000000000;;		cgroupManager := &cgroupfs.Manager{
0000000000000000000000000000000000000000;;			Cgroups: &configs.Cgroup{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Paths: cgroupPaths,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var externalMounts []common.Mount
0000000000000000000000000000000000000000;;		for _, container := range cHints.AllHosts {
0000000000000000000000000000000000000000;;			if name == container.FullName {
0000000000000000000000000000000000000000;;				externalMounts = container.Mounts
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pid := 0
0000000000000000000000000000000000000000;;		if isRootCgroup(name) {
0000000000000000000000000000000000000000;;			pid = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &rawContainerHandler{
0000000000000000000000000000000000000000;;			name:               name,
0000000000000000000000000000000000000000;;			cgroupSubsystems:   cgroupSubsystems,
0000000000000000000000000000000000000000;;			machineInfoFactory: machineInfoFactory,
0000000000000000000000000000000000000000;;			cgroupPaths:        cgroupPaths,
0000000000000000000000000000000000000000;;			cgroupManager:      cgroupManager,
0000000000000000000000000000000000000000;;			fsInfo:             fsInfo,
0000000000000000000000000000000000000000;;			externalMounts:     externalMounts,
0000000000000000000000000000000000000000;;			rootFs:             rootFs,
0000000000000000000000000000000000000000;;			ignoreMetrics:      ignoreMetrics,
0000000000000000000000000000000000000000;;			pid:                pid,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) ContainerReference() (info.ContainerReference, error) {
0000000000000000000000000000000000000000;;		// We only know the container by its one name.
0000000000000000000000000000000000000000;;		return info.ContainerReference{
0000000000000000000000000000000000000000;;			Name: self.name,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) GetRootNetworkDevices() ([]info.NetInfo, error) {
0000000000000000000000000000000000000000;;		nd := []info.NetInfo{}
0000000000000000000000000000000000000000;;		if isRootCgroup(self.name) {
0000000000000000000000000000000000000000;;			mi, err := self.machineInfoFactory.GetMachineInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nd, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return mi.NetworkDevices, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nd, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nothing to start up.
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) Start() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Nothing to clean up.
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) Cleanup() {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) GetSpec() (info.ContainerSpec, error) {
0000000000000000000000000000000000000000;;		const hasNetwork = false
0000000000000000000000000000000000000000;;		hasFilesystem := isRootCgroup(self.name) || len(self.externalMounts) > 0
0000000000000000000000000000000000000000;;		spec, err := common.GetSpec(self.cgroupPaths, self.machineInfoFactory, hasNetwork, hasFilesystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return spec, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isRootCgroup(self.name) {
0000000000000000000000000000000000000000;;			// Check physical network devices for root container.
0000000000000000000000000000000000000000;;			nd, err := self.GetRootNetworkDevices()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return spec, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			spec.HasNetwork = spec.HasNetwork || len(nd) != 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get memory and swap limits of the running machine
0000000000000000000000000000000000000000;;			memLimit, err := machine.GetMachineMemoryCapacity()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("failed to obtain memory limit for machine container")
0000000000000000000000000000000000000000;;				spec.HasMemory = false
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				spec.Memory.Limit = uint64(memLimit)
0000000000000000000000000000000000000000;;				// Spec is marked to have memory only if the memory limit is set
0000000000000000000000000000000000000000;;				spec.HasMemory = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			swapLimit, err := machine.GetMachineSwapCapacity()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("failed to obtain swap limit for machine container")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				spec.Memory.SwapLimit = uint64(swapLimit)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spec, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fsToFsStats(fs *fs.Fs) info.FsStats {
0000000000000000000000000000000000000000;;		inodes := uint64(0)
0000000000000000000000000000000000000000;;		inodesFree := uint64(0)
0000000000000000000000000000000000000000;;		hasInodes := fs.InodesFree != nil
0000000000000000000000000000000000000000;;		if hasInodes {
0000000000000000000000000000000000000000;;			inodes = *fs.Inodes
0000000000000000000000000000000000000000;;			inodesFree = *fs.InodesFree
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return info.FsStats{
0000000000000000000000000000000000000000;;			Device:          fs.Device,
0000000000000000000000000000000000000000;;			Type:            fs.Type.String(),
0000000000000000000000000000000000000000;;			Limit:           fs.Capacity,
0000000000000000000000000000000000000000;;			Usage:           fs.Capacity - fs.Free,
0000000000000000000000000000000000000000;;			HasInodes:       hasInodes,
0000000000000000000000000000000000000000;;			Inodes:          inodes,
0000000000000000000000000000000000000000;;			InodesFree:      inodesFree,
0000000000000000000000000000000000000000;;			Available:       fs.Available,
0000000000000000000000000000000000000000;;			ReadsCompleted:  fs.DiskStats.ReadsCompleted,
0000000000000000000000000000000000000000;;			ReadsMerged:     fs.DiskStats.ReadsMerged,
0000000000000000000000000000000000000000;;			SectorsRead:     fs.DiskStats.SectorsRead,
0000000000000000000000000000000000000000;;			ReadTime:        fs.DiskStats.ReadTime,
0000000000000000000000000000000000000000;;			WritesCompleted: fs.DiskStats.WritesCompleted,
0000000000000000000000000000000000000000;;			WritesMerged:    fs.DiskStats.WritesMerged,
0000000000000000000000000000000000000000;;			SectorsWritten:  fs.DiskStats.SectorsWritten,
0000000000000000000000000000000000000000;;			WriteTime:       fs.DiskStats.WriteTime,
0000000000000000000000000000000000000000;;			IoInProgress:    fs.DiskStats.IoInProgress,
0000000000000000000000000000000000000000;;			IoTime:          fs.DiskStats.IoTime,
0000000000000000000000000000000000000000;;			WeightedIoTime:  fs.DiskStats.WeightedIoTime,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) getFsStats(stats *info.ContainerStats) error {
0000000000000000000000000000000000000000;;		var allFs []fs.Fs
0000000000000000000000000000000000000000;;		// Get Filesystem information only for the root cgroup.
0000000000000000000000000000000000000000;;		if isRootCgroup(self.name) {
0000000000000000000000000000000000000000;;			filesystems, err := self.fsInfo.GetGlobalFsInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range filesystems {
0000000000000000000000000000000000000000;;				fs := filesystems[i]
0000000000000000000000000000000000000000;;				stats.Filesystem = append(stats.Filesystem, fsToFsStats(&fs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allFs = filesystems
0000000000000000000000000000000000000000;;		} else if len(self.externalMounts) > 0 {
0000000000000000000000000000000000000000;;			var mountSet map[string]struct{}
0000000000000000000000000000000000000000;;			mountSet = make(map[string]struct{})
0000000000000000000000000000000000000000;;			for _, mount := range self.externalMounts {
0000000000000000000000000000000000000000;;				mountSet[mount.HostDir] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filesystems, err := self.fsInfo.GetFsInfoForPath(mountSet)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range filesystems {
0000000000000000000000000000000000000000;;				fs := filesystems[i]
0000000000000000000000000000000000000000;;				stats.Filesystem = append(stats.Filesystem, fsToFsStats(&fs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			allFs = filesystems
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		common.AssignDeviceNamesToDiskStats(&fsNamer{fs: allFs, factory: self.machineInfoFactory}, &stats.DiskIo)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) GetStats() (*info.ContainerStats, error) {
0000000000000000000000000000000000000000;;		stats, err := libcontainer.GetStats(self.cgroupManager, self.rootFs, self.pid, self.ignoreMetrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get filesystem stats.
0000000000000000000000000000000000000000;;		err = self.getFsStats(stats)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) GetCgroupPath(resource string) (string, error) {
0000000000000000000000000000000000000000;;		path, ok := self.cgroupPaths[resource]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("could not find path for resource %q for container %q\n", resource, self.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) GetContainerLabels() map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) GetContainerIPAddress() string {
0000000000000000000000000000000000000000;;		// the IP address for the raw container corresponds to the system ip address.
0000000000000000000000000000000000000000;;		return "127.0.0.1"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) ListContainers(listType container.ListType) ([]info.ContainerReference, error) {
0000000000000000000000000000000000000000;;		return common.ListContainers(self.name, self.cgroupPaths, listType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) ListProcesses(listType container.ListType) ([]int, error) {
0000000000000000000000000000000000000000;;		return libcontainer.GetProcesses(self.cgroupManager)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) Exists() bool {
0000000000000000000000000000000000000000;;		return common.CgroupExists(self.cgroupPaths)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerHandler) Type() container.ContainerType {
0000000000000000000000000000000000000000;;		return container.ContainerTypeRaw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type fsNamer struct {
0000000000000000000000000000000000000000;;		fs      []fs.Fs
0000000000000000000000000000000000000000;;		factory info.MachineInfoFactory
0000000000000000000000000000000000000000;;		info    common.DeviceNamer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *fsNamer) DeviceName(major, minor uint64) (string, bool) {
0000000000000000000000000000000000000000;;		for _, info := range n.fs {
0000000000000000000000000000000000000000;;			if uint64(info.Major) == major && uint64(info.Minor) == minor {
0000000000000000000000000000000000000000;;				return info.Device, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.info == nil {
0000000000000000000000000000000000000000;;			mi, err := n.factory.GetMachineInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n.info = (*common.MachineInfoNamer)(mi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n.info.DeviceName(major, minor)
0000000000000000000000000000000000000000;;	}
