0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/container/factory.go[Godeps/_workspace/src/github.com/google/cadvisor/container/factory.go][vendor/github.com/google/cadvisor/container/factory.go];	
0000000000000000000000000000000000000000;;	package container
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager/watcher"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerHandlerFactory interface {
0000000000000000000000000000000000000000;;		// Create a new ContainerHandler using this factory. CanHandleAndAccept() must have returned true.
0000000000000000000000000000000000000000;;		NewContainerHandler(name string, inHostNamespace bool) (c ContainerHandler, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns whether this factory can handle and accept the specified container.
0000000000000000000000000000000000000000;;		CanHandleAndAccept(name string) (handle bool, accept bool, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the factory.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns debugging information. Map of lines per category.
0000000000000000000000000000000000000000;;		DebugInfo() map[string][]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetricKind represents the kind of metrics that cAdvisor exposes.
0000000000000000000000000000000000000000;;	type MetricKind string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CpuUsageMetrics        MetricKind = "cpu"
0000000000000000000000000000000000000000;;		MemoryUsageMetrics     MetricKind = "memory"
0000000000000000000000000000000000000000;;		CpuLoadMetrics         MetricKind = "cpuLoad"
0000000000000000000000000000000000000000;;		DiskIOMetrics          MetricKind = "diskIO"
0000000000000000000000000000000000000000;;		DiskUsageMetrics       MetricKind = "disk"
0000000000000000000000000000000000000000;;		NetworkUsageMetrics    MetricKind = "network"
0000000000000000000000000000000000000000;;		NetworkTcpUsageMetrics MetricKind = "tcp"
0000000000000000000000000000000000000000;;		NetworkUdpUsageMetrics MetricKind = "udp"
0000000000000000000000000000000000000000;;		AppMetrics             MetricKind = "app"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mk MetricKind) String() string {
0000000000000000000000000000000000000000;;		return string(mk)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MetricSet map[MetricKind]struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ms MetricSet) Has(mk MetricKind) bool {
0000000000000000000000000000000000000000;;		_, exists := ms[mk]
0000000000000000000000000000000000000000;;		return exists
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ms MetricSet) Add(mk MetricKind) {
0000000000000000000000000000000000000000;;		ms[mk] = struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(vmarmol): Consider not making this global.
0000000000000000000000000000000000000000;;	// Global list of factories.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		factories     = map[watcher.ContainerWatchSource][]ContainerHandlerFactory{}
0000000000000000000000000000000000000000;;		factoriesLock sync.RWMutex
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register a ContainerHandlerFactory. These should be registered from least general to most general
0000000000000000000000000000000000000000;;	// as they will be asked in order whether they can handle a particular container.
0000000000000000000000000000000000000000;;	func RegisterContainerHandlerFactory(factory ContainerHandlerFactory, watchTypes []watcher.ContainerWatchSource) {
0000000000000000000000000000000000000000;;		factoriesLock.Lock()
0000000000000000000000000000000000000000;;		defer factoriesLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, watchType := range watchTypes {
0000000000000000000000000000000000000000;;			factories[watchType] = append(factories[watchType], factory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns whether there are any container handler factories registered.
0000000000000000000000000000000000000000;;	func HasFactories() bool {
0000000000000000000000000000000000000000;;		factoriesLock.Lock()
0000000000000000000000000000000000000000;;		defer factoriesLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(factories) != 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new ContainerHandler for the specified container.
0000000000000000000000000000000000000000;;	func NewContainerHandler(name string, watchType watcher.ContainerWatchSource, inHostNamespace bool) (ContainerHandler, bool, error) {
0000000000000000000000000000000000000000;;		factoriesLock.RLock()
0000000000000000000000000000000000000000;;		defer factoriesLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the ContainerHandler with the first factory that supports it.
0000000000000000000000000000000000000000;;		for _, factory := range factories[watchType] {
0000000000000000000000000000000000000000;;			canHandle, canAccept, err := factory.CanHandleAndAccept(name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Error trying to work out if we can handle %s: %v", name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if canHandle {
0000000000000000000000000000000000000000;;				if !canAccept {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("Factory %q can handle container %q, but ignoring.", factory, name)
0000000000000000000000000000000000000000;;					return nil, false, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Using factory %q for container %q", factory, name)
0000000000000000000000000000000000000000;;				handle, err := factory.NewContainerHandler(name, inHostNamespace)
0000000000000000000000000000000000000000;;				return handle, canAccept, err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				glog.V(4).Infof("Factory %q was unable to handle container %q", factory, name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false, fmt.Errorf("no known factory can handle creation of container")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clear the known factories.
0000000000000000000000000000000000000000;;	func ClearContainerHandlerFactories() {
0000000000000000000000000000000000000000;;		factoriesLock.Lock()
0000000000000000000000000000000000000000;;		defer factoriesLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		factories = map[watcher.ContainerWatchSource][]ContainerHandlerFactory{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DebugInfo() map[string][]string {
0000000000000000000000000000000000000000;;		factoriesLock.RLock()
0000000000000000000000000000000000000000;;		defer factoriesLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get debug information for all factories.
0000000000000000000000000000000000000000;;		out := make(map[string][]string)
0000000000000000000000000000000000000000;;		for _, factoriesSlice := range factories {
0000000000000000000000000000000000000000;;			for _, factory := range factoriesSlice {
0000000000000000000000000000000000000000;;				for k, v := range factory.DebugInfo() {
0000000000000000000000000000000000000000;;					out[k] = v
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
