0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
00bfea346f0eb4c2521868b22ad906fe633a233b;Godeps/_workspace/src/github.com/google/cadvisor/container/raw/inotify_watcher.go[Godeps/_workspace/src/github.com/google/cadvisor/container/raw/inotify_watcher.go][vendor/github.com/google/cadvisor/container/common/inotify_watcher.go];	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/exp/inotify"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watcher for container-related inotify events in the cgroup hierarchy.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Implementation is thread-safe.
0000000000000000000000000000000000000000;;	type InotifyWatcher struct {
0000000000000000000000000000000000000000;;		// Underlying inotify watcher.
0000000000000000000000000000000000000000;;		watcher *inotify.Watcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Map of containers being watched to cgroup paths watched for that container.
0000000000000000000000000000000000000000;;		containersWatched map[string]map[string]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Lock for all datastructure access.
0000000000000000000000000000000000000000;;		lock sync.Mutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewInotifyWatcher() (*InotifyWatcher, error) {
0000000000000000000000000000000000000000;;		w, err := inotify.NewWatcher()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &InotifyWatcher{
0000000000000000000000000000000000000000;;			watcher:           w,
0000000000000000000000000000000000000000;;			containersWatched: make(map[string]map[string]bool),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a watch to the specified directory. Returns if the container was already being watched.
0000000000000000000000000000000000000000;;	func (iw *InotifyWatcher) AddWatch(containerName, dir string) (bool, error) {
0000000000000000000000000000000000000000;;		iw.lock.Lock()
0000000000000000000000000000000000000000;;		defer iw.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupsWatched, alreadyWatched := iw.containersWatched[containerName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register an inotify notification.
0000000000000000000000000000000000000000;;		if !cgroupsWatched[dir] {
0000000000000000000000000000000000000000;;			err := iw.watcher.AddWatch(dir, inotify.IN_CREATE|inotify.IN_DELETE|inotify.IN_MOVE)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return alreadyWatched, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cgroupsWatched == nil {
0000000000000000000000000000000000000000;;				cgroupsWatched = make(map[string]bool)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cgroupsWatched[dir] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Record our watching of the container.
0000000000000000000000000000000000000000;;		if !alreadyWatched {
0000000000000000000000000000000000000000;;			iw.containersWatched[containerName] = cgroupsWatched
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return alreadyWatched, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove watch from the specified directory. Returns if this was the last watch on the specified container.
0000000000000000000000000000000000000000;;	func (iw *InotifyWatcher) RemoveWatch(containerName, dir string) (bool, error) {
0000000000000000000000000000000000000000;;		iw.lock.Lock()
0000000000000000000000000000000000000000;;		defer iw.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we don't have a watch registed for this, just return.
0000000000000000000000000000000000000000;;		cgroupsWatched, ok := iw.containersWatched[containerName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the inotify watch if it exists.
0000000000000000000000000000000000000000;;		if cgroupsWatched[dir] {
0000000000000000000000000000000000000000;;			err := iw.watcher.RemoveWatch(dir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(cgroupsWatched, dir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the record if this is the last watch.
0000000000000000000000000000000000000000;;		if len(cgroupsWatched) == 0 {
0000000000000000000000000000000000000000;;			delete(iw.containersWatched, containerName)
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errors are returned on this channel.
0000000000000000000000000000000000000000;;	func (iw *InotifyWatcher) Error() chan error {
0000000000000000000000000000000000000000;;		return iw.watcher.Error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Events are returned on this channel.
0000000000000000000000000000000000000000;;	func (iw *InotifyWatcher) Event() chan *inotify.Event {
0000000000000000000000000000000000000000;;		return iw.watcher.Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Closes the inotify watcher.
0000000000000000000000000000000000000000;;	func (iw *InotifyWatcher) Close() error {
0000000000000000000000000000000000000000;;		return iw.watcher.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a map of containers to the cgroup paths being watched.
0000000000000000000000000000000000000000;;	func (iw *InotifyWatcher) GetWatches() map[string][]string {
0000000000000000000000000000000000000000;;		out := make(map[string][]string, len(iw.containersWatched))
0000000000000000000000000000000000000000;;		for k, v := range iw.containersWatched {
0000000000000000000000000000000000000000;;			out[k] = mapToSlice(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapToSlice(m map[string]bool) []string {
0000000000000000000000000000000000000000;;		out := make([]string, 0, len(m))
0000000000000000000000000000000000000000;;		for k := range m {
0000000000000000000000000000000000000000;;			out = append(out, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
