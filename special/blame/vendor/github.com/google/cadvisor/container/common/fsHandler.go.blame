0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
39f75e39b7e8748d8c9f7c2aae0cea76c3c62ab8;Godeps/_workspace/src/github.com/google/cadvisor/container/docker/fsHandler.go[Godeps/_workspace/src/github.com/google/cadvisor/container/docker/fsHandler.go][vendor/github.com/google/cadvisor/container/common/fsHandler.go];	
0000000000000000000000000000000000000000;;	// Handler for Docker containers.
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FsHandler interface {
0000000000000000000000000000000000000000;;		Start()
0000000000000000000000000000000000000000;;		Usage() FsUsage
0000000000000000000000000000000000000000;;		Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FsUsage struct {
0000000000000000000000000000000000000000;;		BaseUsageBytes  uint64
0000000000000000000000000000000000000000;;		TotalUsageBytes uint64
0000000000000000000000000000000000000000;;		InodeUsage      uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type realFsHandler struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		lastUpdate time.Time
0000000000000000000000000000000000000000;;		usage      FsUsage
0000000000000000000000000000000000000000;;		period     time.Duration
0000000000000000000000000000000000000000;;		minPeriod  time.Duration
0000000000000000000000000000000000000000;;		rootfs     string
0000000000000000000000000000000000000000;;		extraDir   string
0000000000000000000000000000000000000000;;		fsInfo     fs.FsInfo
0000000000000000000000000000000000000000;;		// Tells the container to stop.
0000000000000000000000000000000000000000;;		stopChan chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		longOp           = time.Second
0000000000000000000000000000000000000000;;		timeout          = 2 * time.Minute
0000000000000000000000000000000000000000;;		maxBackoffFactor = 20
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const DefaultPeriod = time.Minute
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ FsHandler = &realFsHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFsHandler(period time.Duration, rootfs, extraDir string, fsInfo fs.FsInfo) FsHandler {
0000000000000000000000000000000000000000;;		return &realFsHandler{
0000000000000000000000000000000000000000;;			lastUpdate: time.Time{},
0000000000000000000000000000000000000000;;			usage:      FsUsage{},
0000000000000000000000000000000000000000;;			period:     period,
0000000000000000000000000000000000000000;;			minPeriod:  period,
0000000000000000000000000000000000000000;;			rootfs:     rootfs,
0000000000000000000000000000000000000000;;			extraDir:   extraDir,
0000000000000000000000000000000000000000;;			fsInfo:     fsInfo,
0000000000000000000000000000000000000000;;			stopChan:   make(chan struct{}, 1),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *realFsHandler) update() error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			baseUsage, extraDirUsage, inodeUsage    uint64
0000000000000000000000000000000000000000;;			rootDiskErr, rootInodeErr, extraDiskErr error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		// TODO(vishh): Add support for external mounts.
0000000000000000000000000000000000000000;;		if fh.rootfs != "" {
0000000000000000000000000000000000000000;;			baseUsage, rootDiskErr = fh.fsInfo.GetDirDiskUsage(fh.rootfs, timeout)
0000000000000000000000000000000000000000;;			inodeUsage, rootInodeErr = fh.fsInfo.GetDirInodeUsage(fh.rootfs, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fh.extraDir != "" {
0000000000000000000000000000000000000000;;			extraDirUsage, extraDiskErr = fh.fsInfo.GetDirDiskUsage(fh.extraDir, timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Wait to handle errors until after all operartions are run.
0000000000000000000000000000000000000000;;		// An error in one will not cause an early return, skipping others
0000000000000000000000000000000000000000;;		fh.Lock()
0000000000000000000000000000000000000000;;		defer fh.Unlock()
0000000000000000000000000000000000000000;;		fh.lastUpdate = time.Now()
0000000000000000000000000000000000000000;;		if rootDiskErr == nil && fh.rootfs != "" {
0000000000000000000000000000000000000000;;			fh.usage.InodeUsage = inodeUsage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rootInodeErr == nil && fh.rootfs != "" {
0000000000000000000000000000000000000000;;			fh.usage.TotalUsageBytes = baseUsage + extraDirUsage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if extraDiskErr == nil && fh.extraDir != "" {
0000000000000000000000000000000000000000;;			fh.usage.BaseUsageBytes = baseUsage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Combine errors into a single error to return
0000000000000000000000000000000000000000;;		if rootDiskErr != nil || rootInodeErr != nil || extraDiskErr != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("rootDiskErr: %v, rootInodeErr: %v, extraDiskErr: %v", rootDiskErr, rootInodeErr, extraDiskErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *realFsHandler) trackUsage() {
0000000000000000000000000000000000000000;;		fh.update()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-fh.stopChan:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-time.After(fh.period):
0000000000000000000000000000000000000000;;				start := time.Now()
0000000000000000000000000000000000000000;;				if err := fh.update(); err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to collect filesystem stats - %v", err)
0000000000000000000000000000000000000000;;					fh.period = fh.period * 2
0000000000000000000000000000000000000000;;					if fh.period > maxBackoffFactor*fh.minPeriod {
0000000000000000000000000000000000000000;;						fh.period = maxBackoffFactor * fh.minPeriod
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fh.period = fh.minPeriod
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				duration := time.Since(start)
0000000000000000000000000000000000000000;;				if duration > longOp {
0000000000000000000000000000000000000000;;					glog.V(2).Infof("du and find on following dirs took %v: %v", duration, []string{fh.rootfs, fh.extraDir})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *realFsHandler) Start() {
0000000000000000000000000000000000000000;;		go fh.trackUsage()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *realFsHandler) Stop() {
0000000000000000000000000000000000000000;;		close(fh.stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fh *realFsHandler) Usage() FsUsage {
0000000000000000000000000000000000000000;;		fh.RLock()
0000000000000000000000000000000000000000;;		defer fh.RUnlock()
0000000000000000000000000000000000000000;;		return fh.usage
0000000000000000000000000000000000000000;;	}
