0000000000000000000000000000000000000000;;	// Copyright 2016 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d5fa6cf31825f06f168e8c9a6e5568ec5d58ce4f;Godeps/_workspace/src/github.com/google/cadvisor/container/common/helpers.go[Godeps/_workspace/src/github.com/google/cadvisor/container/common/helpers.go][vendor/github.com/google/cadvisor/container/common/helpers.go];	
0000000000000000000000000000000000000000;;	package common
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DebugInfo(watches map[string][]string) map[string][]string {
0000000000000000000000000000000000000000;;		out := make(map[string][]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lines := make([]string, 0, len(watches))
0000000000000000000000000000000000000000;;		for containerName, cgroupWatches := range watches {
0000000000000000000000000000000000000000;;			lines = append(lines, fmt.Sprintf("%s:", containerName))
0000000000000000000000000000000000000000;;			for _, cg := range cgroupWatches {
0000000000000000000000000000000000000000;;				lines = append(lines, fmt.Sprintf("\t%s", cg))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out["Inotify watches"] = lines
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetSpec(cgroupPaths map[string]string, machineInfoFactory info.MachineInfoFactory, hasNetwork, hasFilesystem bool) (info.ContainerSpec, error) {
0000000000000000000000000000000000000000;;		var spec info.ContainerSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume unified hierarchy containers.
0000000000000000000000000000000000000000;;		// Get the lowest creation time from all hierarchies as the container creation time.
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		lowestTime := now
0000000000000000000000000000000000000000;;		for _, cgroupPath := range cgroupPaths {
0000000000000000000000000000000000000000;;			// The modified time of the cgroup directory changes whenever a subcontainer is created.
0000000000000000000000000000000000000000;;			// eg. /docker will have creation time matching the creation of latest docker container.
0000000000000000000000000000000000000000;;			// Use clone_children as a workaround as it isn't usually modified. It is only likely changed
0000000000000000000000000000000000000000;;			// immediately after creating a container.
0000000000000000000000000000000000000000;;			cgroupPath = path.Join(cgroupPath, "cgroup.clone_children")
0000000000000000000000000000000000000000;;			fi, err := os.Stat(cgroupPath)
0000000000000000000000000000000000000000;;			if err == nil && fi.ModTime().Before(lowestTime) {
0000000000000000000000000000000000000000;;				lowestTime = fi.ModTime()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lowestTime != now {
0000000000000000000000000000000000000000;;			spec.CreationTime = lowestTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get machine info.
0000000000000000000000000000000000000000;;		mi, err := machineInfoFactory.GetMachineInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return spec, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CPU.
0000000000000000000000000000000000000000;;		cpuRoot, ok := cgroupPaths["cpu"]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if utils.FileExists(cpuRoot) {
0000000000000000000000000000000000000000;;				spec.HasCpu = true
0000000000000000000000000000000000000000;;				spec.Cpu.Limit = readUInt64(cpuRoot, "cpu.shares")
0000000000000000000000000000000000000000;;				spec.Cpu.Period = readUInt64(cpuRoot, "cpu.cfs_period_us")
0000000000000000000000000000000000000000;;				quota := readString(cpuRoot, "cpu.cfs_quota_us")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if quota != "" && quota != "-1" {
0000000000000000000000000000000000000000;;					val, err := strconv.ParseUint(quota, 10, 64)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Errorf("GetSpec: Failed to parse CPUQuota from %q: %s", path.Join(cpuRoot, "cpu.cfs_quota_us"), err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					spec.Cpu.Quota = val
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cpu Mask.
0000000000000000000000000000000000000000;;		// This will fail for non-unified hierarchies. We'll return the whole machine mask in that case.
0000000000000000000000000000000000000000;;		cpusetRoot, ok := cgroupPaths["cpuset"]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if utils.FileExists(cpusetRoot) {
0000000000000000000000000000000000000000;;				spec.HasCpu = true
0000000000000000000000000000000000000000;;				mask := readString(cpusetRoot, "cpuset.cpus")
0000000000000000000000000000000000000000;;				spec.Cpu.Mask = utils.FixCpuMask(mask, mi.NumCores)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Memory
0000000000000000000000000000000000000000;;		memoryRoot, ok := cgroupPaths["memory"]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			if utils.FileExists(memoryRoot) {
0000000000000000000000000000000000000000;;				spec.HasMemory = true
0000000000000000000000000000000000000000;;				spec.Memory.Limit = readUInt64(memoryRoot, "memory.limit_in_bytes")
0000000000000000000000000000000000000000;;				spec.Memory.SwapLimit = readUInt64(memoryRoot, "memory.memsw.limit_in_bytes")
0000000000000000000000000000000000000000;;				spec.Memory.Reservation = readUInt64(memoryRoot, "memory.soft_limit_in_bytes")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.HasNetwork = hasNetwork
0000000000000000000000000000000000000000;;		spec.HasFilesystem = hasFilesystem
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if blkioRoot, ok := cgroupPaths["blkio"]; ok && utils.FileExists(blkioRoot) {
0000000000000000000000000000000000000000;;			spec.HasDiskIo = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spec, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readString(dirpath string, file string) string {
0000000000000000000000000000000000000000;;		cgroupFile := path.Join(dirpath, file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore non-existent files
0000000000000000000000000000000000000000;;		if !utils.FileExists(cgroupFile) {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile(cgroupFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("readString: Failed to read %q: %s", cgroupFile, err)
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimSpace(string(out))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readUInt64(dirpath string, file string) uint64 {
0000000000000000000000000000000000000000;;		out := readString(dirpath, file)
0000000000000000000000000000000000000000;;		if out == "" {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, err := strconv.ParseUint(out, 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("readUInt64: Failed to parse int %q from file %q: %s", out, path.Join(dirpath, file), err)
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lists all directories under "path" and outputs the results as children of "parent".
0000000000000000000000000000000000000000;;	func ListDirectories(dirpath string, parent string, recursive bool, output map[string]struct{}) error {
0000000000000000000000000000000000000000;;		// Ignore if this hierarchy does not exist.
0000000000000000000000000000000000000000;;		if !utils.FileExists(dirpath) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entries, err := ioutil.ReadDir(dirpath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, entry := range entries {
0000000000000000000000000000000000000000;;			// We only grab directories.
0000000000000000000000000000000000000000;;			if entry.IsDir() {
0000000000000000000000000000000000000000;;				name := path.Join(parent, entry.Name())
0000000000000000000000000000000000000000;;				output[name] = struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// List subcontainers if asked to.
0000000000000000000000000000000000000000;;				if recursive {
0000000000000000000000000000000000000000;;					err := ListDirectories(path.Join(dirpath, entry.Name()), name, true, output)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeCgroupPaths(mountPoints map[string]string, name string) map[string]string {
0000000000000000000000000000000000000000;;		cgroupPaths := make(map[string]string, len(mountPoints))
0000000000000000000000000000000000000000;;		for key, val := range mountPoints {
0000000000000000000000000000000000000000;;			cgroupPaths[key] = path.Join(val, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cgroupPaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CgroupExists(cgroupPaths map[string]string) bool {
0000000000000000000000000000000000000000;;		// If any cgroup exists, the container is still alive.
0000000000000000000000000000000000000000;;		for _, cgroupPath := range cgroupPaths {
0000000000000000000000000000000000000000;;			if utils.FileExists(cgroupPath) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ListContainers(name string, cgroupPaths map[string]string, listType container.ListType) ([]info.ContainerReference, error) {
0000000000000000000000000000000000000000;;		containers := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, cgroupPath := range cgroupPaths {
0000000000000000000000000000000000000000;;			err := ListDirectories(cgroupPath, name, listType == container.ListRecursive, containers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make into container references.
0000000000000000000000000000000000000000;;		ret := make([]info.ContainerReference, 0, len(containers))
0000000000000000000000000000000000000000;;		for cont := range containers {
0000000000000000000000000000000000000000;;			ret = append(ret, info.ContainerReference{
0000000000000000000000000000000000000000;;				Name: cont,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssignDeviceNamesToDiskStats assigns the Device field on the provided DiskIoStats by looking up
0000000000000000000000000000000000000000;;	// the device major and minor identifiers in the provided device namer.
0000000000000000000000000000000000000000;;	func AssignDeviceNamesToDiskStats(namer DeviceNamer, stats *info.DiskIoStats) {
0000000000000000000000000000000000000000;;		assignDeviceNamesToPerDiskStats(
0000000000000000000000000000000000000000;;			namer,
0000000000000000000000000000000000000000;;			stats.IoMerged,
0000000000000000000000000000000000000000;;			stats.IoQueued,
0000000000000000000000000000000000000000;;			stats.IoServiceBytes,
0000000000000000000000000000000000000000;;			stats.IoServiceTime,
0000000000000000000000000000000000000000;;			stats.IoServiced,
0000000000000000000000000000000000000000;;			stats.IoTime,
0000000000000000000000000000000000000000;;			stats.IoWaitTime,
0000000000000000000000000000000000000000;;			stats.Sectors,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// assignDeviceNamesToPerDiskStats looks up device names for the provided stats, caching names
0000000000000000000000000000000000000000;;	// if necessary.
0000000000000000000000000000000000000000;;	func assignDeviceNamesToPerDiskStats(namer DeviceNamer, diskStats ...[]info.PerDiskStats) {
0000000000000000000000000000000000000000;;		devices := make(deviceIdentifierMap)
0000000000000000000000000000000000000000;;		for _, stats := range diskStats {
0000000000000000000000000000000000000000;;			for i, stat := range stats {
0000000000000000000000000000000000000000;;				stats[i].Device = devices.Find(stat.Major, stat.Minor, namer)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeviceNamer returns string names for devices by their major and minor id.
0000000000000000000000000000000000000000;;	type DeviceNamer interface {
0000000000000000000000000000000000000000;;		// DeviceName returns the name of the device by its major and minor ids, or false if no
0000000000000000000000000000000000000000;;		// such device is recognized.
0000000000000000000000000000000000000000;;		DeviceName(major, minor uint64) (string, bool)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MachineInfoNamer info.MachineInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *MachineInfoNamer) DeviceName(major, minor uint64) (string, bool) {
0000000000000000000000000000000000000000;;		for _, info := range n.DiskMap {
0000000000000000000000000000000000000000;;			if info.Major == major && info.Minor == minor {
0000000000000000000000000000000000000000;;				return "/dev/" + info.Name, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, info := range n.Filesystems {
0000000000000000000000000000000000000000;;			if info.DeviceMajor == major && info.DeviceMinor == minor {
0000000000000000000000000000000000000000;;				return info.Device, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deviceIdentifier struct {
0000000000000000000000000000000000000000;;		major uint64
0000000000000000000000000000000000000000;;		minor uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deviceIdentifierMap map[deviceIdentifier]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find locates the device name by device identifier out of from, caching the result as necessary.
0000000000000000000000000000000000000000;;	func (m deviceIdentifierMap) Find(major, minor uint64, namer DeviceNamer) string {
0000000000000000000000000000000000000000;;		d := deviceIdentifier{major, minor}
0000000000000000000000000000000000000000;;		if s, ok := m[d]; ok {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s, _ := namer.DeviceName(major, minor)
0000000000000000000000000000000000000000;;		m[d] = s
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
