0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/container/docker/factory.go[Godeps/_workspace/src/github.com/google/cadvisor/container/docker/factory.go][vendor/github.com/google/cadvisor/container/docker/factory.go];	
0000000000000000000000000000000000000000;;	package docker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/blang/semver"
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/libcontainer"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/devicemapper"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/machine"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager/watcher"
0000000000000000000000000000000000000000;;		dockerutil "github.com/google/cadvisor/utils/docker"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/zfs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		docker "github.com/docker/engine-api/client"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ArgDockerEndpoint = flag.String("docker", "unix:///var/run/docker.sock", "docker endpoint")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The namespace under which Docker aliases are unique.
0000000000000000000000000000000000000000;;	const DockerNamespace = "docker"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Regexp that identifies docker cgroups, containers started with
0000000000000000000000000000000000000000;;	// --cgroup-parent have another prefix than 'docker'
0000000000000000000000000000000000000000;;	var dockerCgroupRegexp = regexp.MustCompile(`([a-z0-9]{64})`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var dockerEnvWhitelist = flag.String("docker_env_metadata_whitelist", "", "a comma-separated list of environment variable keys that needs to be collected for docker containers")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// Basepath to all container specific information that libcontainer stores.
0000000000000000000000000000000000000000;;		dockerRootDir string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerRootDirFlag = flag.String("docker_root", "/var/lib/docker", "DEPRECATED: docker root is read from docker info (this is a fallback, default: /var/lib/docker)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerRootDirOnce sync.Once
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// flag that controls globally disabling thin_ls pending future enhancements.
0000000000000000000000000000000000000000;;		// in production, it has been found that thin_ls makes excessive use of iops.
0000000000000000000000000000000000000000;;		// in an iops restricted environment, usage of thin_ls must be controlled via blkio.
0000000000000000000000000000000000000000;;		// pending that enhancement, disable its usage.
0000000000000000000000000000000000000000;;		disableThinLs = true
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RootDir() string {
0000000000000000000000000000000000000000;;		dockerRootDirOnce.Do(func() {
0000000000000000000000000000000000000000;;			status, err := Status()
0000000000000000000000000000000000000000;;			if err == nil && status.RootDir != "" {
0000000000000000000000000000000000000000;;				dockerRootDir = status.RootDir
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				dockerRootDir = *dockerRootDirFlag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return dockerRootDir
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type storageDriver string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		devicemapperStorageDriver storageDriver = "devicemapper"
0000000000000000000000000000000000000000;;		aufsStorageDriver         storageDriver = "aufs"
0000000000000000000000000000000000000000;;		overlayStorageDriver      storageDriver = "overlay"
0000000000000000000000000000000000000000;;		overlay2StorageDriver     storageDriver = "overlay2"
0000000000000000000000000000000000000000;;		zfsStorageDriver          storageDriver = "zfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dockerFactory struct {
0000000000000000000000000000000000000000;;		machineInfoFactory info.MachineInfoFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storageDriver storageDriver
0000000000000000000000000000000000000000;;		storageDir    string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		client *docker.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Information about the mounted cgroup subsystems.
0000000000000000000000000000000000000000;;		cgroupSubsystems libcontainer.CgroupSubsystems
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Information about mounted filesystems.
0000000000000000000000000000000000000000;;		fsInfo fs.FsInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerVersion []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerAPIVersion []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ignoreMetrics container.MetricSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		thinPoolName    string
0000000000000000000000000000000000000000;;		thinPoolWatcher *devicemapper.ThinPoolWatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zfsWatcher *zfs.ZfsWatcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerFactory) String() string {
0000000000000000000000000000000000000000;;		return DockerNamespace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerFactory) NewContainerHandler(name string, inHostNamespace bool) (handler container.ContainerHandler, err error) {
0000000000000000000000000000000000000000;;		client, err := Client()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		metadataEnvs := strings.Split(*dockerEnvWhitelist, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler, err = newDockerContainerHandler(
0000000000000000000000000000000000000000;;			client,
0000000000000000000000000000000000000000;;			name,
0000000000000000000000000000000000000000;;			self.machineInfoFactory,
0000000000000000000000000000000000000000;;			self.fsInfo,
0000000000000000000000000000000000000000;;			self.storageDriver,
0000000000000000000000000000000000000000;;			self.storageDir,
0000000000000000000000000000000000000000;;			&self.cgroupSubsystems,
0000000000000000000000000000000000000000;;			inHostNamespace,
0000000000000000000000000000000000000000;;			metadataEnvs,
0000000000000000000000000000000000000000;;			self.dockerVersion,
0000000000000000000000000000000000000000;;			self.ignoreMetrics,
0000000000000000000000000000000000000000;;			self.thinPoolName,
0000000000000000000000000000000000000000;;			self.thinPoolWatcher,
0000000000000000000000000000000000000000;;			self.zfsWatcher,
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the Docker ID from the full container name.
0000000000000000000000000000000000000000;;	func ContainerNameToDockerId(name string) string {
0000000000000000000000000000000000000000;;		id := path.Base(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if matches := dockerCgroupRegexp.FindStringSubmatch(id); matches != nil {
0000000000000000000000000000000000000000;;			return matches[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isContainerName returns true if the cgroup with associated name
0000000000000000000000000000000000000000;;	// corresponds to a docker container.
0000000000000000000000000000000000000000;;	func isContainerName(name string) bool {
0000000000000000000000000000000000000000;;		// always ignore .mount cgroup even if associated with docker and delegate to systemd
0000000000000000000000000000000000000000;;		if strings.HasSuffix(name, ".mount") {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dockerCgroupRegexp.MatchString(path.Base(name))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Docker handles all containers under /docker
0000000000000000000000000000000000000000;;	func (self *dockerFactory) CanHandleAndAccept(name string) (bool, bool, error) {
0000000000000000000000000000000000000000;;		// if the container is not associated with docker, we can't handle it or accept it.
0000000000000000000000000000000000000000;;		if !isContainerName(name) {
0000000000000000000000000000000000000000;;			return false, false, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the container is known to docker and it is active.
0000000000000000000000000000000000000000;;		id := ContainerNameToDockerId(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We assume that if Inspect fails then the container is not known to docker.
0000000000000000000000000000000000000000;;		ctnr, err := self.client.ContainerInspect(context.Background(), id)
0000000000000000000000000000000000000000;;		if err != nil || !ctnr.State.Running {
0000000000000000000000000000000000000000;;			return false, true, fmt.Errorf("error inspecting container: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, true, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerFactory) DebugInfo() map[string][]string {
0000000000000000000000000000000000000000;;		return map[string][]string{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		version_regexp_string    = `(\d+)\.(\d+)\.(\d+)`
0000000000000000000000000000000000000000;;		version_re               = regexp.MustCompile(version_regexp_string)
0000000000000000000000000000000000000000;;		apiversion_regexp_string = `(\d+)\.(\d+)`
0000000000000000000000000000000000000000;;		apiversion_re            = regexp.MustCompile(apiversion_regexp_string)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startThinPoolWatcher(dockerInfo *dockertypes.Info) (*devicemapper.ThinPoolWatcher, error) {
0000000000000000000000000000000000000000;;		_, err := devicemapper.ThinLsBinaryPresent()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := ensureThinLsKernelVersion(machine.KernelVersion()); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if disableThinLs {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("usage of thin_ls is disabled to preserve iops")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerThinPoolName, err := dockerutil.DockerThinPoolName(*dockerInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerMetadataDevice, err := dockerutil.DockerMetadataDevice(*dockerInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		thinPoolWatcher, err := devicemapper.NewThinPoolWatcher(dockerThinPoolName, dockerMetadataDevice)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go thinPoolWatcher.Start()
0000000000000000000000000000000000000000;;		return thinPoolWatcher, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func startZfsWatcher(dockerInfo *dockertypes.Info) (*zfs.ZfsWatcher, error) {
0000000000000000000000000000000000000000;;		filesystem, err := dockerutil.DockerZfsFilesystem(*dockerInfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zfsWatcher, err := zfs.NewZfsWatcher(filesystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go zfsWatcher.Start()
0000000000000000000000000000000000000000;;		return zfsWatcher, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ensureThinLsKernelVersion(kernelVersion string) error {
0000000000000000000000000000000000000000;;		// kernel 4.4.0 has the proper bug fixes to allow thin_ls to work without corrupting the thin pool
0000000000000000000000000000000000000000;;		minKernelVersion := semver.MustParse("4.4.0")
0000000000000000000000000000000000000000;;		// RHEL 7 kernel 3.10.0 release >= 366 has the proper bug fixes backported from 4.4.0 to allow
0000000000000000000000000000000000000000;;		// thin_ls to work without corrupting the thin pool
0000000000000000000000000000000000000000;;		minRhel7KernelVersion := semver.MustParse("3.10.0")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		matches := version_re.FindStringSubmatch(kernelVersion)
0000000000000000000000000000000000000000;;		if len(matches) < 4 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("error parsing kernel version: %q is not a semver", kernelVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sem, err := semver.Make(matches[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sem.GTE(minKernelVersion) {
0000000000000000000000000000000000000000;;			// kernel 4.4+ - good
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Certain RHEL/Centos 7.x kernels have a backport to fix the corruption bug
0000000000000000000000000000000000000000;;		if !strings.Contains(kernelVersion, ".el7") {
0000000000000000000000000000000000000000;;			// not a RHEL 7.x kernel - won't work
0000000000000000000000000000000000000000;;			return fmt.Errorf("kernel version 4.4.0 or later is required to use thin_ls - you have %q", kernelVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RHEL/Centos 7.x from here on
0000000000000000000000000000000000000000;;		if sem.Major != 3 {
0000000000000000000000000000000000000000;;			// only 3.x kernels *may* work correctly
0000000000000000000000000000000000000000;;			return fmt.Errorf("RHEL/Centos 7.x kernel version 3.10.0-366 or later is required to use thin_ls - you have %q", kernelVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sem.GT(minRhel7KernelVersion) {
0000000000000000000000000000000000000000;;			// 3.10.1+ - good
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if sem.EQ(minRhel7KernelVersion) {
0000000000000000000000000000000000000000;;			// need to check release
0000000000000000000000000000000000000000;;			releaseRE := regexp.MustCompile(`^[^-]+-([0-9]+)\.`)
0000000000000000000000000000000000000000;;			releaseMatches := releaseRE.FindStringSubmatch(kernelVersion)
0000000000000000000000000000000000000000;;			if len(releaseMatches) != 2 {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to determine RHEL/Centos 7.x kernel release from %q", kernelVersion)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			release, err := strconv.Atoi(releaseMatches[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("error parsing release %q: %v", releaseMatches[1], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if release >= 366 {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("RHEL/Centos 7.x kernel version 3.10.0-366 or later is required to use thin_ls - you have %q", kernelVersion)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Register root container before running this function!
0000000000000000000000000000000000000000;;	func Register(factory info.MachineInfoFactory, fsInfo fs.FsInfo, ignoreMetrics container.MetricSet) error {
0000000000000000000000000000000000000000;;		client, err := Client()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to communicate with docker daemon: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerInfo, err := ValidateInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to validate Docker info: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Version already validated above, assume no error here.
0000000000000000000000000000000000000000;;		dockerVersion, _ := parseVersion(dockerInfo.ServerVersion, version_re, 3)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerAPIVersion, _ := APIVersion()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupSubsystems, err := libcontainer.GetCgroupSubsystems()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get cgroup subsystems: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			thinPoolWatcher *devicemapper.ThinPoolWatcher
0000000000000000000000000000000000000000;;			thinPoolName    string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if storageDriver(dockerInfo.Driver) == devicemapperStorageDriver {
0000000000000000000000000000000000000000;;			thinPoolWatcher, err = startThinPoolWatcher(dockerInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("devicemapper filesystem stats will not be reported: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			status := StatusFromDockerInfo(*dockerInfo)
0000000000000000000000000000000000000000;;			thinPoolName = status.DriverStatus[dockerutil.DriverStatusPoolName]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var zfsWatcher *zfs.ZfsWatcher
0000000000000000000000000000000000000000;;		if storageDriver(dockerInfo.Driver) == zfsStorageDriver {
0000000000000000000000000000000000000000;;			zfsWatcher, err = startZfsWatcher(dockerInfo)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("zfs filesystem stats will not be reported: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Registering Docker factory")
0000000000000000000000000000000000000000;;		f := &dockerFactory{
0000000000000000000000000000000000000000;;			cgroupSubsystems:   cgroupSubsystems,
0000000000000000000000000000000000000000;;			client:             client,
0000000000000000000000000000000000000000;;			dockerVersion:      dockerVersion,
0000000000000000000000000000000000000000;;			dockerAPIVersion:   dockerAPIVersion,
0000000000000000000000000000000000000000;;			fsInfo:             fsInfo,
0000000000000000000000000000000000000000;;			machineInfoFactory: factory,
0000000000000000000000000000000000000000;;			storageDriver:      storageDriver(dockerInfo.Driver),
0000000000000000000000000000000000000000;;			storageDir:         RootDir(),
0000000000000000000000000000000000000000;;			ignoreMetrics:      ignoreMetrics,
0000000000000000000000000000000000000000;;			thinPoolName:       thinPoolName,
0000000000000000000000000000000000000000;;			thinPoolWatcher:    thinPoolWatcher,
0000000000000000000000000000000000000000;;			zfsWatcher:         zfsWatcher,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		container.RegisterContainerHandlerFactory(f, []watcher.ContainerWatchSource{watcher.Raw})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
