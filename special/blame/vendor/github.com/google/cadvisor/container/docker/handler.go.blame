0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/container/docker/handler.go[Godeps/_workspace/src/github.com/google/cadvisor/container/docker/handler.go][vendor/github.com/google/cadvisor/container/docker/handler.go];	
0000000000000000000000000000000000000000;;	// Handler for Docker containers.
0000000000000000000000000000000000000000;;	package docker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/common"
0000000000000000000000000000000000000000;;		containerlibcontainer "github.com/google/cadvisor/container/libcontainer"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/devicemapper"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		dockerutil "github.com/google/cadvisor/utils/docker"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/zfs"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		docker "github.com/docker/engine-api/client"
0000000000000000000000000000000000000000;;		dockercontainer "github.com/docker/engine-api/types/container"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		cgroupfs "github.com/opencontainers/runc/libcontainer/cgroups/fs"
0000000000000000000000000000000000000000;;		libcontainerconfigs "github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// The read write layers exist here.
0000000000000000000000000000000000000000;;		aufsRWLayer = "diff"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Path to the directory where docker stores log files if the json logging driver is enabled.
0000000000000000000000000000000000000000;;		pathToContainersDir = "containers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dockerContainerHandler struct {
0000000000000000000000000000000000000000;;		client             *docker.Client
0000000000000000000000000000000000000000;;		name               string
0000000000000000000000000000000000000000;;		id                 string
0000000000000000000000000000000000000000;;		aliases            []string
0000000000000000000000000000000000000000;;		machineInfoFactory info.MachineInfoFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Absolute path to the cgroup hierarchies of this container.
0000000000000000000000000000000000000000;;		// (e.g.: "cpu" -> "/sys/fs/cgroup/cpu/test")
0000000000000000000000000000000000000000;;		cgroupPaths map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Manager of this container's cgroups.
0000000000000000000000000000000000000000;;		cgroupManager cgroups.Manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the docker storage driver
0000000000000000000000000000000000000000;;		storageDriver    storageDriver
0000000000000000000000000000000000000000;;		fsInfo           fs.FsInfo
0000000000000000000000000000000000000000;;		rootfsStorageDir string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// devicemapper state
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the devicemapper poolname
0000000000000000000000000000000000000000;;		poolName string
0000000000000000000000000000000000000000;;		// the devicemapper device id for the container
0000000000000000000000000000000000000000;;		deviceID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// zfs Filesystem
0000000000000000000000000000000000000000;;		zfsFilesystem string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// zfsParent is the parent for docker zfs
0000000000000000000000000000000000000000;;		zfsParent string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time at which this container was created.
0000000000000000000000000000000000000000;;		creationTime time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata associated with the container.
0000000000000000000000000000000000000000;;		labels map[string]string
0000000000000000000000000000000000000000;;		envs   map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container PID used to switch namespaces as required
0000000000000000000000000000000000000000;;		pid int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Image name used for this container.
0000000000000000000000000000000000000000;;		image string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The host root FS to read
0000000000000000000000000000000000000000;;		rootFs string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The network mode of the container
0000000000000000000000000000000000000000;;		networkMode dockercontainer.NetworkMode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Filesystem handler.
0000000000000000000000000000000000000000;;		fsHandler common.FsHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The IP address of the container
0000000000000000000000000000000000000000;;		ipAddress string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ignoreMetrics container.MetricSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// thin pool watcher
0000000000000000000000000000000000000000;;		thinPoolWatcher *devicemapper.ThinPoolWatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// zfs watcher
0000000000000000000000000000000000000000;;		zfsWatcher *zfs.ZfsWatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// container restart count
0000000000000000000000000000000000000000;;		restartCount int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ container.ContainerHandler = &dockerContainerHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getRwLayerID(containerID, storageDir string, sd storageDriver, dockerVersion []int) (string, error) {
0000000000000000000000000000000000000000;;		const (
0000000000000000000000000000000000000000;;			// Docker version >=1.10.0 have a randomized ID for the root fs of a container.
0000000000000000000000000000000000000000;;			randomizedRWLayerMinorVersion = 10
0000000000000000000000000000000000000000;;			rwLayerIDFile                 = "mount-id"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if (dockerVersion[0] <= 1) && (dockerVersion[1] < randomizedRWLayerMinorVersion) {
0000000000000000000000000000000000000000;;			return containerID, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bytes, err := ioutil.ReadFile(path.Join(storageDir, "image", string(sd), "layerdb", "mounts", containerID, rwLayerIDFile))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("failed to identify the read-write layer ID for container %q. - %v", containerID, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(bytes), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newDockerContainerHandler returns a new container.ContainerHandler
0000000000000000000000000000000000000000;;	func newDockerContainerHandler(
0000000000000000000000000000000000000000;;		client *docker.Client,
0000000000000000000000000000000000000000;;		name string,
0000000000000000000000000000000000000000;;		machineInfoFactory info.MachineInfoFactory,
0000000000000000000000000000000000000000;;		fsInfo fs.FsInfo,
0000000000000000000000000000000000000000;;		storageDriver storageDriver,
0000000000000000000000000000000000000000;;		storageDir string,
0000000000000000000000000000000000000000;;		cgroupSubsystems *containerlibcontainer.CgroupSubsystems,
0000000000000000000000000000000000000000;;		inHostNamespace bool,
0000000000000000000000000000000000000000;;		metadataEnvs []string,
0000000000000000000000000000000000000000;;		dockerVersion []int,
0000000000000000000000000000000000000000;;		ignoreMetrics container.MetricSet,
0000000000000000000000000000000000000000;;		thinPoolName string,
0000000000000000000000000000000000000000;;		thinPoolWatcher *devicemapper.ThinPoolWatcher,
0000000000000000000000000000000000000000;;		zfsWatcher *zfs.ZfsWatcher,
0000000000000000000000000000000000000000;;	) (container.ContainerHandler, error) {
0000000000000000000000000000000000000000;;		// Create the cgroup paths.
0000000000000000000000000000000000000000;;		cgroupPaths := make(map[string]string, len(cgroupSubsystems.MountPoints))
0000000000000000000000000000000000000000;;		for key, val := range cgroupSubsystems.MountPoints {
0000000000000000000000000000000000000000;;			cgroupPaths[key] = path.Join(val, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the equivalent cgroup manager for this container.
0000000000000000000000000000000000000000;;		cgroupManager := &cgroupfs.Manager{
0000000000000000000000000000000000000000;;			Cgroups: &libcontainerconfigs.Cgroup{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Paths: cgroupPaths,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootFs := "/"
0000000000000000000000000000000000000000;;		if !inHostNamespace {
0000000000000000000000000000000000000000;;			rootFs = "/rootfs"
0000000000000000000000000000000000000000;;			storageDir = path.Join(rootFs, storageDir)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		id := ContainerNameToDockerId(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the Containers dir where the log files are stored.
0000000000000000000000000000000000000000;;		// FIXME: Give `otherStorageDir` a more descriptive name.
0000000000000000000000000000000000000000;;		otherStorageDir := path.Join(storageDir, pathToContainersDir, id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rwLayerID, err := getRwLayerID(id, storageDir, storageDriver, dockerVersion)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the rootfs storage dir OR the pool name to determine the device.
0000000000000000000000000000000000000000;;		// For devicemapper, we only need the thin pool name, and that is passed in to this call
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			rootfsStorageDir string
0000000000000000000000000000000000000000;;			zfsFilesystem    string
0000000000000000000000000000000000000000;;			zfsParent        string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		switch storageDriver {
0000000000000000000000000000000000000000;;		case aufsStorageDriver:
0000000000000000000000000000000000000000;;			rootfsStorageDir = path.Join(storageDir, string(aufsStorageDriver), aufsRWLayer, rwLayerID)
0000000000000000000000000000000000000000;;		case overlayStorageDriver, overlay2StorageDriver:
0000000000000000000000000000000000000000;;			rootfsStorageDir = path.Join(storageDir, string(storageDriver), rwLayerID)
0000000000000000000000000000000000000000;;		case zfsStorageDriver:
0000000000000000000000000000000000000000;;			status, err := Status()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to determine docker status: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			zfsParent = status.DriverStatus[dockerutil.DriverStatusParentDataset]
0000000000000000000000000000000000000000;;			zfsFilesystem = path.Join(zfsParent, rwLayerID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: extract object mother method
0000000000000000000000000000000000000000;;		handler := &dockerContainerHandler{
0000000000000000000000000000000000000000;;			id:                 id,
0000000000000000000000000000000000000000;;			client:             client,
0000000000000000000000000000000000000000;;			name:               name,
0000000000000000000000000000000000000000;;			machineInfoFactory: machineInfoFactory,
0000000000000000000000000000000000000000;;			cgroupPaths:        cgroupPaths,
0000000000000000000000000000000000000000;;			cgroupManager:      cgroupManager,
0000000000000000000000000000000000000000;;			storageDriver:      storageDriver,
0000000000000000000000000000000000000000;;			fsInfo:             fsInfo,
0000000000000000000000000000000000000000;;			rootFs:             rootFs,
0000000000000000000000000000000000000000;;			poolName:           thinPoolName,
0000000000000000000000000000000000000000;;			zfsFilesystem:      zfsFilesystem,
0000000000000000000000000000000000000000;;			rootfsStorageDir:   rootfsStorageDir,
0000000000000000000000000000000000000000;;			envs:               make(map[string]string),
0000000000000000000000000000000000000000;;			ignoreMetrics:      ignoreMetrics,
0000000000000000000000000000000000000000;;			thinPoolWatcher:    thinPoolWatcher,
0000000000000000000000000000000000000000;;			zfsWatcher:         zfsWatcher,
0000000000000000000000000000000000000000;;			zfsParent:          zfsParent,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We assume that if Inspect fails then the container is not known to docker.
0000000000000000000000000000000000000000;;		ctnr, err := client.ContainerInspect(context.Background(), id)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to inspect container %q: %v", id, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Timestamp returned by Docker is in time.RFC3339Nano format.
0000000000000000000000000000000000000000;;		handler.creationTime, err = time.Parse(time.RFC3339Nano, ctnr.Created)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// This should not happen, report the error just in case
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to parse the create timestamp %q for container %q: %v", ctnr.Created, id, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler.pid = ctnr.State.Pid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the name and bare ID as aliases of the container.
0000000000000000000000000000000000000000;;		handler.aliases = append(handler.aliases, strings.TrimPrefix(ctnr.Name, "/"), id)
0000000000000000000000000000000000000000;;		handler.labels = ctnr.Config.Labels
0000000000000000000000000000000000000000;;		handler.image = ctnr.Config.Image
0000000000000000000000000000000000000000;;		handler.networkMode = ctnr.HostConfig.NetworkMode
0000000000000000000000000000000000000000;;		handler.deviceID = ctnr.GraphDriver.Data["DeviceId"]
0000000000000000000000000000000000000000;;		handler.restartCount = ctnr.RestartCount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Obtain the IP address for the contianer.
0000000000000000000000000000000000000000;;		// If the NetworkMode starts with 'container:' then we need to use the IP address of the container specified.
0000000000000000000000000000000000000000;;		// This happens in cases such as kubernetes where the containers doesn't have an IP address itself and we need to use the pod's address
0000000000000000000000000000000000000000;;		ipAddress := ctnr.NetworkSettings.IPAddress
0000000000000000000000000000000000000000;;		networkMode := string(ctnr.HostConfig.NetworkMode)
0000000000000000000000000000000000000000;;		if ipAddress == "" && strings.HasPrefix(networkMode, "container:") {
0000000000000000000000000000000000000000;;			containerId := strings.TrimPrefix(networkMode, "container:")
0000000000000000000000000000000000000000;;			c, err := client.ContainerInspect(context.Background(), containerId)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("failed to inspect container %q: %v", id, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ipAddress = c.NetworkSettings.IPAddress
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler.ipAddress = ipAddress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ignoreMetrics.Has(container.DiskUsageMetrics) {
0000000000000000000000000000000000000000;;			handler.fsHandler = &dockerFsHandler{
0000000000000000000000000000000000000000;;				fsHandler:       common.NewFsHandler(common.DefaultPeriod, rootfsStorageDir, otherStorageDir, fsInfo),
0000000000000000000000000000000000000000;;				thinPoolWatcher: thinPoolWatcher,
0000000000000000000000000000000000000000;;				zfsWatcher:      zfsWatcher,
0000000000000000000000000000000000000000;;				deviceID:        handler.deviceID,
0000000000000000000000000000000000000000;;				zfsFilesystem:   zfsFilesystem,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// split env vars to get metadata map.
0000000000000000000000000000000000000000;;		for _, exposedEnv := range metadataEnvs {
0000000000000000000000000000000000000000;;			for _, envVar := range ctnr.Config.Env {
0000000000000000000000000000000000000000;;				if envVar != "" {
0000000000000000000000000000000000000000;;					splits := strings.SplitN(envVar, "=", 2)
0000000000000000000000000000000000000000;;					if len(splits) == 2 && splits[0] == exposedEnv {
0000000000000000000000000000000000000000;;						handler.envs[strings.ToLower(exposedEnv)] = splits[1]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handler, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dockerFsHandler is a composite FsHandler implementation the incorporates
0000000000000000000000000000000000000000;;	// the common fs handler, a devicemapper ThinPoolWatcher, and a zfsWatcher
0000000000000000000000000000000000000000;;	type dockerFsHandler struct {
0000000000000000000000000000000000000000;;		fsHandler common.FsHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// thinPoolWatcher is the devicemapper thin pool watcher
0000000000000000000000000000000000000000;;		thinPoolWatcher *devicemapper.ThinPoolWatcher
0000000000000000000000000000000000000000;;		// deviceID is the id of the container's fs device
0000000000000000000000000000000000000000;;		deviceID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// zfsWatcher is the zfs filesystem watcher
0000000000000000000000000000000000000000;;		zfsWatcher *zfs.ZfsWatcher
0000000000000000000000000000000000000000;;		// zfsFilesystem is the docker zfs filesystem
0000000000000000000000000000000000000000;;		zfsFilesystem string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ common.FsHandler = &dockerFsHandler{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *dockerFsHandler) Start() {
0000000000000000000000000000000000000000;;		h.fsHandler.Start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *dockerFsHandler) Stop() {
0000000000000000000000000000000000000000;;		h.fsHandler.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *dockerFsHandler) Usage() common.FsUsage {
0000000000000000000000000000000000000000;;		usage := h.fsHandler.Usage()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When devicemapper is the storage driver, the base usage of the container comes from the thin pool.
0000000000000000000000000000000000000000;;		// We still need the result of the fsHandler for any extra storage associated with the container.
0000000000000000000000000000000000000000;;		// To correctly factor in the thin pool usage, we should:
0000000000000000000000000000000000000000;;		// * Usage the thin pool usage as the base usage
0000000000000000000000000000000000000000;;		// * Calculate the overall usage by adding the overall usage from the fs handler to the thin pool usage
0000000000000000000000000000000000000000;;		if h.thinPoolWatcher != nil {
0000000000000000000000000000000000000000;;			thinPoolUsage, err := h.thinPoolWatcher.GetUsage(h.deviceID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO: ideally we should keep track of how many times we failed to get the usage for this
0000000000000000000000000000000000000000;;				// device vs how many refreshes of the cache there have been, and display an error e.g. if we've
0000000000000000000000000000000000000000;;				// had at least 1 refresh and we still can't find the device.
0000000000000000000000000000000000000000;;				glog.V(5).Infof("unable to get fs usage from thin pool for device %s: %v", h.deviceID, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				usage.BaseUsageBytes = thinPoolUsage
0000000000000000000000000000000000000000;;				usage.TotalUsageBytes += thinPoolUsage
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.zfsWatcher != nil {
0000000000000000000000000000000000000000;;			zfsUsage, err := h.zfsWatcher.GetUsage(h.zfsFilesystem)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(5).Infof("unable to get fs usage from zfs for filesystem %s: %v", h.zfsFilesystem, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				usage.BaseUsageBytes = zfsUsage
0000000000000000000000000000000000000000;;				usage.TotalUsageBytes += zfsUsage
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return usage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) Start() {
0000000000000000000000000000000000000000;;		if self.fsHandler != nil {
0000000000000000000000000000000000000000;;			self.fsHandler.Start()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) Cleanup() {
0000000000000000000000000000000000000000;;		if self.fsHandler != nil {
0000000000000000000000000000000000000000;;			self.fsHandler.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) ContainerReference() (info.ContainerReference, error) {
0000000000000000000000000000000000000000;;		return info.ContainerReference{
0000000000000000000000000000000000000000;;			Id:        self.id,
0000000000000000000000000000000000000000;;			Name:      self.name,
0000000000000000000000000000000000000000;;			Aliases:   self.aliases,
0000000000000000000000000000000000000000;;			Namespace: DockerNamespace,
0000000000000000000000000000000000000000;;			Labels:    self.labels,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) needNet() bool {
0000000000000000000000000000000000000000;;		if !self.ignoreMetrics.Has(container.NetworkUsageMetrics) {
0000000000000000000000000000000000000000;;			return !self.networkMode.IsContainer()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) GetSpec() (info.ContainerSpec, error) {
0000000000000000000000000000000000000000;;		hasFilesystem := !self.ignoreMetrics.Has(container.DiskUsageMetrics)
0000000000000000000000000000000000000000;;		spec, err := common.GetSpec(self.cgroupPaths, self.machineInfoFactory, self.needNet(), hasFilesystem)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.Labels = self.labels
0000000000000000000000000000000000000000;;		// Only adds restartcount label if it's greater than 0
0000000000000000000000000000000000000000;;		if self.restartCount > 0 {
0000000000000000000000000000000000000000;;			spec.Labels["restartcount"] = strconv.Itoa(self.restartCount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		spec.Envs = self.envs
0000000000000000000000000000000000000000;;		spec.Image = self.image
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spec, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) getFsStats(stats *info.ContainerStats) error {
0000000000000000000000000000000000000000;;		mi, err := self.machineInfoFactory.GetMachineInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !self.ignoreMetrics.Has(container.DiskIOMetrics) {
0000000000000000000000000000000000000000;;			common.AssignDeviceNamesToDiskStats((*common.MachineInfoNamer)(mi), &stats.DiskIo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if self.ignoreMetrics.Has(container.DiskUsageMetrics) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var device string
0000000000000000000000000000000000000000;;		switch self.storageDriver {
0000000000000000000000000000000000000000;;		case devicemapperStorageDriver:
0000000000000000000000000000000000000000;;			// Device has to be the pool name to correlate with the device name as
0000000000000000000000000000000000000000;;			// set in the machine info filesystems.
0000000000000000000000000000000000000000;;			device = self.poolName
0000000000000000000000000000000000000000;;		case aufsStorageDriver, overlayStorageDriver, overlay2StorageDriver:
0000000000000000000000000000000000000000;;			deviceInfo, err := self.fsInfo.GetDirFsDevice(self.rootfsStorageDir)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("unable to determine device info for dir: %v: %v", self.rootfsStorageDir, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			device = deviceInfo.Device
0000000000000000000000000000000000000000;;		case zfsStorageDriver:
0000000000000000000000000000000000000000;;			device = self.zfsParent
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			limit  uint64
0000000000000000000000000000000000000000;;			fsType string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Docker does not impose any filesystem limits for containers. So use capacity as limit.
0000000000000000000000000000000000000000;;		for _, fs := range mi.Filesystems {
0000000000000000000000000000000000000000;;			if fs.Device == device {
0000000000000000000000000000000000000000;;				limit = fs.Capacity
0000000000000000000000000000000000000000;;				fsType = fs.Type
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsStat := info.FsStats{Device: device, Type: fsType, Limit: limit}
0000000000000000000000000000000000000000;;		usage := self.fsHandler.Usage()
0000000000000000000000000000000000000000;;		fsStat.BaseUsage = usage.BaseUsageBytes
0000000000000000000000000000000000000000;;		fsStat.Usage = usage.TotalUsageBytes
0000000000000000000000000000000000000000;;		fsStat.Inodes = usage.InodeUsage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats.Filesystem = append(stats.Filesystem, fsStat)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(vmarmol): Get from libcontainer API instead of cgroup manager when we don't have to support older Dockers.
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) GetStats() (*info.ContainerStats, error) {
0000000000000000000000000000000000000000;;		stats, err := containerlibcontainer.GetStats(self.cgroupManager, self.rootFs, self.pid, self.ignoreMetrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Clean up stats for containers that don't have their own network - this
0000000000000000000000000000000000000000;;		// includes containers running in Kubernetes pods that use the network of the
0000000000000000000000000000000000000000;;		// infrastructure container. This stops metrics being reported multiple times
0000000000000000000000000000000000000000;;		// for each container in a pod.
0000000000000000000000000000000000000000;;		if !self.needNet() {
0000000000000000000000000000000000000000;;			stats.Network = info.NetworkStats{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get filesystem stats.
0000000000000000000000000000000000000000;;		err = self.getFsStats(stats)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) ListContainers(listType container.ListType) ([]info.ContainerReference, error) {
0000000000000000000000000000000000000000;;		// No-op for Docker driver.
0000000000000000000000000000000000000000;;		return []info.ContainerReference{}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) GetCgroupPath(resource string) (string, error) {
0000000000000000000000000000000000000000;;		path, ok := self.cgroupPaths[resource]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("could not find path for resource %q for container %q\n", resource, self.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) GetContainerLabels() map[string]string {
0000000000000000000000000000000000000000;;		return self.labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) GetContainerIPAddress() string {
0000000000000000000000000000000000000000;;		return self.ipAddress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) ListProcesses(listType container.ListType) ([]int, error) {
0000000000000000000000000000000000000000;;		return containerlibcontainer.GetProcesses(self.cgroupManager)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) Exists() bool {
0000000000000000000000000000000000000000;;		return common.CgroupExists(self.cgroupPaths)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *dockerContainerHandler) Type() container.ContainerType {
0000000000000000000000000000000000000000;;		return container.ContainerTypeDocker
0000000000000000000000000000000000000000;;	}
