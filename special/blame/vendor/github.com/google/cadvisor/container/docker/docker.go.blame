0000000000000000000000000000000000000000;;	// Copyright 2016 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a93fc00f9e3e99c0b1e06ca1ecb0ad623862f330;;	
0000000000000000000000000000000000000000;;	// Provides global docker information.
0000000000000000000000000000000000000000;;	package docker
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockertypes "github.com/docker/engine-api/types"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/machine"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Status() (v1.DockerStatus, error) {
0000000000000000000000000000000000000000;;		client, err := Client()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return v1.DockerStatus{}, fmt.Errorf("unable to communicate with docker daemon: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dockerInfo, err := client.Info(context.Background())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return v1.DockerStatus{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return StatusFromDockerInfo(dockerInfo), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func StatusFromDockerInfo(dockerInfo dockertypes.Info) v1.DockerStatus {
0000000000000000000000000000000000000000;;		out := v1.DockerStatus{}
0000000000000000000000000000000000000000;;		out.Version = VersionString()
0000000000000000000000000000000000000000;;		out.APIVersion = APIVersionString()
0000000000000000000000000000000000000000;;		out.KernelVersion = machine.KernelVersion()
0000000000000000000000000000000000000000;;		out.OS = dockerInfo.OperatingSystem
0000000000000000000000000000000000000000;;		out.Hostname = dockerInfo.Name
0000000000000000000000000000000000000000;;		out.RootDir = dockerInfo.DockerRootDir
0000000000000000000000000000000000000000;;		out.Driver = dockerInfo.Driver
0000000000000000000000000000000000000000;;		out.ExecDriver = dockerInfo.ExecutionDriver
0000000000000000000000000000000000000000;;		out.NumImages = dockerInfo.Images
0000000000000000000000000000000000000000;;		out.NumContainers = dockerInfo.Containers
0000000000000000000000000000000000000000;;		out.DriverStatus = make(map[string]string, len(dockerInfo.DriverStatus))
0000000000000000000000000000000000000000;;		for _, v := range dockerInfo.DriverStatus {
0000000000000000000000000000000000000000;;			out.DriverStatus[v[0]] = v[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Images() ([]v1.DockerImage, error) {
0000000000000000000000000000000000000000;;		client, err := Client()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to communicate with docker daemon: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		images, err := client.ImageList(context.Background(), dockertypes.ImageListOptions{All: false})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := []v1.DockerImage{}
0000000000000000000000000000000000000000;;		const unknownTag = "<none>:<none>"
0000000000000000000000000000000000000000;;		for _, image := range images {
0000000000000000000000000000000000000000;;			if len(image.RepoTags) == 1 && image.RepoTags[0] == unknownTag {
0000000000000000000000000000000000000000;;				// images with repo or tags are uninteresting.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			di := v1.DockerImage{
0000000000000000000000000000000000000000;;				ID:          image.ID,
0000000000000000000000000000000000000000;;				RepoTags:    image.RepoTags,
0000000000000000000000000000000000000000;;				Created:     image.Created,
0000000000000000000000000000000000000000;;				VirtualSize: image.VirtualSize,
0000000000000000000000000000000000000000;;				Size:        image.Size,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, di)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks whether the dockerInfo reflects a valid docker setup, and returns it if it does, or an
0000000000000000000000000000000000000000;;	// error otherwise.
0000000000000000000000000000000000000000;;	func ValidateInfo() (*dockertypes.Info, error) {
0000000000000000000000000000000000000000;;		client, err := Client()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to communicate with docker daemon: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerInfo, err := client.Info(context.Background())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to detect Docker info: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fall back to version API if ServerVersion is not set in info.
0000000000000000000000000000000000000000;;		if dockerInfo.ServerVersion == "" {
0000000000000000000000000000000000000000;;			version, err := client.ServerVersion(context.Background())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to get docker version: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dockerInfo.ServerVersion = version.Version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version, err := parseVersion(dockerInfo.ServerVersion, version_re, 3)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if version[0] < 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("cAdvisor requires docker version %v or above but we have found version %v reported as %q", []int{1, 0, 0}, version, dockerInfo.ServerVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that the libcontainer execdriver is used if the version is < 1.11
0000000000000000000000000000000000000000;;		// (execution drivers are no longer supported as of 1.11).
0000000000000000000000000000000000000000;;		if version[0] <= 1 && version[1] <= 10 &&
0000000000000000000000000000000000000000;;			!strings.HasPrefix(dockerInfo.ExecutionDriver, "native") {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("docker found, but not using native exec driver")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dockerInfo.Driver == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to find docker storage driver")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &dockerInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Version() ([]int, error) {
0000000000000000000000000000000000000000;;		return parseVersion(VersionString(), version_re, 3)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func APIVersion() ([]int, error) {
0000000000000000000000000000000000000000;;		return parseVersion(APIVersionString(), apiversion_re, 2)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VersionString() string {
0000000000000000000000000000000000000000;;		docker_version := "Unknown"
0000000000000000000000000000000000000000;;		client, err := Client()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			version, err := client.ServerVersion(context.Background())
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				docker_version = version.Version
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return docker_version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func APIVersionString() string {
0000000000000000000000000000000000000000;;		docker_api_version := "Unknown"
0000000000000000000000000000000000000000;;		client, err := Client()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			version, err := client.ServerVersion(context.Background())
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				docker_api_version = version.APIVersion
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return docker_api_version
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseVersion(version_string string, regex *regexp.Regexp, length int) ([]int, error) {
0000000000000000000000000000000000000000;;		matches := regex.FindAllStringSubmatch(version_string, -1)
0000000000000000000000000000000000000000;;		if len(matches) != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("version string \"%v\" doesn't match expected regular expression: \"%v\"", version_string, regex.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version_string_array := matches[0][1:]
0000000000000000000000000000000000000000;;		version_array := make([]int, length)
0000000000000000000000000000000000000000;;		for index, version_str := range version_string_array {
0000000000000000000000000000000000000000;;			version, err := strconv.Atoi(version_str)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("error while parsing \"%v\" in \"%v\"", version_str, version_string)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			version_array[index] = version
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return version_array, nil
0000000000000000000000000000000000000000;;	}
