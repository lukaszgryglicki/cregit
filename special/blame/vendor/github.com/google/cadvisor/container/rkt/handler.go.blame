0000000000000000000000000000000000000000;;	// Copyright 2016 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d5fa6cf31825f06f168e8c9a6e5568ec5d58ce4f;Godeps/_workspace/src/github.com/google/cadvisor/container/rkt/handler.go[Godeps/_workspace/src/github.com/google/cadvisor/container/rkt/handler.go][vendor/github.com/google/cadvisor/container/rkt/handler.go];	
0000000000000000000000000000000000000000;;	// Handler for "rkt" containers.
0000000000000000000000000000000000000000;;	package rkt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rktapi "github.com/coreos/rkt/api/v1alpha"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/common"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/libcontainer"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;		cgroupfs "github.com/opencontainers/runc/libcontainer/cgroups/fs"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/configs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rktContainerHandler struct {
0000000000000000000000000000000000000000;;		rktClient rktapi.PublicAPIClient
0000000000000000000000000000000000000000;;		// Name of the container for this handler.
0000000000000000000000000000000000000000;;		name               string
0000000000000000000000000000000000000000;;		cgroupSubsystems   *libcontainer.CgroupSubsystems
0000000000000000000000000000000000000000;;		machineInfoFactory info.MachineInfoFactory
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Absolute path to the cgroup hierarchies of this container.
0000000000000000000000000000000000000000;;		// (e.g.: "cpu" -> "/sys/fs/cgroup/cpu/test")
0000000000000000000000000000000000000000;;		cgroupPaths map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Manager of this container's cgroups.
0000000000000000000000000000000000000000;;		cgroupManager cgroups.Manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether this container has network isolation enabled.
0000000000000000000000000000000000000000;;		hasNetwork bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsInfo fs.FsInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootFs string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isPod bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		aliases []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pid int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootfsStorageDir string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Filesystem handler.
0000000000000000000000000000000000000000;;		fsHandler common.FsHandler
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ignoreMetrics container.MetricSet
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiPod *rktapi.Pod
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newRktContainerHandler(name string, rktClient rktapi.PublicAPIClient, rktPath string, cgroupSubsystems *libcontainer.CgroupSubsystems, machineInfoFactory info.MachineInfoFactory, fsInfo fs.FsInfo, rootFs string, ignoreMetrics container.MetricSet) (container.ContainerHandler, error) {
0000000000000000000000000000000000000000;;		aliases := make([]string, 1)
0000000000000000000000000000000000000000;;		isPod := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		apiPod := &rktapi.Pod{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parsed, err := parseName(name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("this should be impossible!, new handler failing, but factory allowed, name = %s", name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rktnetes uses containerID: rkt://fff40827-b994-4e3a-8f88-6427c2c8a5ac:nginx
0000000000000000000000000000000000000000;;		if parsed.Container == "" {
0000000000000000000000000000000000000000;;			isPod = true
0000000000000000000000000000000000000000;;			aliases = append(aliases, "rkt://"+parsed.Pod)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			aliases = append(aliases, "rkt://"+parsed.Pod+":"+parsed.Container)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pid := os.Getpid()
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		resp, err := rktClient.InspectPod(context.Background(), &rktapi.InspectPodRequest{
0000000000000000000000000000000000000000;;			Id: parsed.Pod,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		annotations := resp.Pod.Annotations
0000000000000000000000000000000000000000;;		if parsed.Container != "" { // As not empty string, an App container
0000000000000000000000000000000000000000;;			if contAnnotations, ok := findAnnotations(resp.Pod.Apps, parsed.Container); !ok {
0000000000000000000000000000000000000000;;				glog.Warningf("couldn't find app %v in pod", parsed.Container)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				annotations = append(annotations, contAnnotations...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else { // The Pod container
0000000000000000000000000000000000000000;;			pid = int(resp.Pod.Pid)
0000000000000000000000000000000000000000;;			apiPod = resp.Pod
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		labels = createLabels(annotations)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupPaths := common.MakeCgroupPaths(cgroupSubsystems.MountPoints, name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Generate the equivalent cgroup manager for this container.
0000000000000000000000000000000000000000;;		cgroupManager := &cgroupfs.Manager{
0000000000000000000000000000000000000000;;			Cgroups: &configs.Cgroup{
0000000000000000000000000000000000000000;;				Name: name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Paths: cgroupPaths,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasNetwork := false
0000000000000000000000000000000000000000;;		if isPod {
0000000000000000000000000000000000000000;;			hasNetwork = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootfsStorageDir := getRootFs(rktPath, parsed)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := &rktContainerHandler{
0000000000000000000000000000000000000000;;			name:               name,
0000000000000000000000000000000000000000;;			rktClient:          rktClient,
0000000000000000000000000000000000000000;;			cgroupSubsystems:   cgroupSubsystems,
0000000000000000000000000000000000000000;;			machineInfoFactory: machineInfoFactory,
0000000000000000000000000000000000000000;;			cgroupPaths:        cgroupPaths,
0000000000000000000000000000000000000000;;			cgroupManager:      cgroupManager,
0000000000000000000000000000000000000000;;			fsInfo:             fsInfo,
0000000000000000000000000000000000000000;;			hasNetwork:         hasNetwork,
0000000000000000000000000000000000000000;;			rootFs:             rootFs,
0000000000000000000000000000000000000000;;			isPod:              isPod,
0000000000000000000000000000000000000000;;			aliases:            aliases,
0000000000000000000000000000000000000000;;			pid:                pid,
0000000000000000000000000000000000000000;;			labels:             labels,
0000000000000000000000000000000000000000;;			rootfsStorageDir:   rootfsStorageDir,
0000000000000000000000000000000000000000;;			ignoreMetrics:      ignoreMetrics,
0000000000000000000000000000000000000000;;			apiPod:             apiPod,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !ignoreMetrics.Has(container.DiskUsageMetrics) {
0000000000000000000000000000000000000000;;			handler.fsHandler = common.NewFsHandler(common.DefaultPeriod, rootfsStorageDir, "", fsInfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return handler, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findAnnotations(apps []*rktapi.App, container string) ([]*rktapi.KeyValue, bool) {
0000000000000000000000000000000000000000;;		for _, app := range apps {
0000000000000000000000000000000000000000;;			if app.Name == container {
0000000000000000000000000000000000000000;;				return app.Annotations, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func createLabels(annotations []*rktapi.KeyValue) map[string]string {
0000000000000000000000000000000000000000;;		labels := make(map[string]string)
0000000000000000000000000000000000000000;;		for _, kv := range annotations {
0000000000000000000000000000000000000000;;			labels[kv.Key] = kv.Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) ContainerReference() (info.ContainerReference, error) {
0000000000000000000000000000000000000000;;		return info.ContainerReference{
0000000000000000000000000000000000000000;;			Name:      handler.name,
0000000000000000000000000000000000000000;;			Aliases:   handler.aliases,
0000000000000000000000000000000000000000;;			Namespace: RktNamespace,
0000000000000000000000000000000000000000;;			Labels:    handler.labels,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) Start() {
0000000000000000000000000000000000000000;;		handler.fsHandler.Start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) Cleanup() {
0000000000000000000000000000000000000000;;		handler.fsHandler.Stop()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) GetSpec() (info.ContainerSpec, error) {
0000000000000000000000000000000000000000;;		hasNetwork := handler.hasNetwork && !handler.ignoreMetrics.Has(container.NetworkUsageMetrics)
0000000000000000000000000000000000000000;;		hasFilesystem := !handler.ignoreMetrics.Has(container.DiskUsageMetrics)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec, err := common.GetSpec(handler.cgroupPaths, handler.machineInfoFactory, hasNetwork, hasFilesystem)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec.Labels = handler.labels
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return spec, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) getFsStats(stats *info.ContainerStats) error {
0000000000000000000000000000000000000000;;		mi, err := handler.machineInfoFactory.GetMachineInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !handler.ignoreMetrics.Has(container.DiskIOMetrics) {
0000000000000000000000000000000000000000;;			common.AssignDeviceNamesToDiskStats((*common.MachineInfoNamer)(mi), &stats.DiskIo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if handler.ignoreMetrics.Has(container.DiskUsageMetrics) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deviceInfo, err := handler.fsInfo.GetDirFsDevice(handler.rootfsStorageDir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var limit uint64 = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use capacity as limit.
0000000000000000000000000000000000000000;;		for _, fs := range mi.Filesystems {
0000000000000000000000000000000000000000;;			if fs.Device == deviceInfo.Device {
0000000000000000000000000000000000000000;;				limit = fs.Capacity
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsStat := info.FsStats{Device: deviceInfo.Device, Limit: limit}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usage := handler.fsHandler.Usage()
0000000000000000000000000000000000000000;;		fsStat.BaseUsage = usage.BaseUsageBytes
0000000000000000000000000000000000000000;;		fsStat.Usage = usage.TotalUsageBytes
0000000000000000000000000000000000000000;;		fsStat.Inodes = usage.InodeUsage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats.Filesystem = append(stats.Filesystem, fsStat)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) GetStats() (*info.ContainerStats, error) {
0000000000000000000000000000000000000000;;		stats, err := libcontainer.GetStats(handler.cgroupManager, handler.rootFs, handler.pid, handler.ignoreMetrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get filesystem stats.
0000000000000000000000000000000000000000;;		err = handler.getFsStats(stats)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rktContainerHandler) GetContainerIPAddress() string {
0000000000000000000000000000000000000000;;		// attempt to return the ip address of the pod
0000000000000000000000000000000000000000;;		// if a specific ip address of the pod could not be determined, return the system ip address
0000000000000000000000000000000000000000;;		if self.isPod && len(self.apiPod.Networks) > 0 {
0000000000000000000000000000000000000000;;			address := self.apiPod.Networks[0].Ipv4
0000000000000000000000000000000000000000;;			if address != "" {
0000000000000000000000000000000000000000;;				return address
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return self.apiPod.Networks[0].Ipv6
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return "127.0.0.1"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) GetCgroupPath(resource string) (string, error) {
0000000000000000000000000000000000000000;;		path, ok := handler.cgroupPaths[resource]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("could not find path for resource %q for container %q\n", resource, handler.name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return path, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) GetContainerLabels() map[string]string {
0000000000000000000000000000000000000000;;		return handler.labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) ListContainers(listType container.ListType) ([]info.ContainerReference, error) {
0000000000000000000000000000000000000000;;		return common.ListContainers(handler.name, handler.cgroupPaths, listType)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) ListProcesses(listType container.ListType) ([]int, error) {
0000000000000000000000000000000000000000;;		return libcontainer.GetProcesses(handler.cgroupManager)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) Exists() bool {
0000000000000000000000000000000000000000;;		return common.CgroupExists(handler.cgroupPaths)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (handler *rktContainerHandler) Type() container.ContainerType {
0000000000000000000000000000000000000000;;		return container.ContainerTypeRkt
0000000000000000000000000000000000000000;;	}
