0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/container/libcontainer/helpers.go[Godeps/_workspace/src/github.com/google/cadvisor/container/libcontainer/helpers.go][vendor/github.com/google/cadvisor/container/libcontainer/helpers.go];	
0000000000000000000000000000000000000000;;	package libcontainer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CgroupSubsystems struct {
0000000000000000000000000000000000000000;;		// Cgroup subsystem mounts.
0000000000000000000000000000000000000000;;		// e.g.: "/sys/fs/cgroup/cpu" -> ["cpu", "cpuacct"]
0000000000000000000000000000000000000000;;		Mounts []cgroups.Mount
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Cgroup subsystem to their mount location.
0000000000000000000000000000000000000000;;		// e.g.: "cpu" -> "/sys/fs/cgroup/cpu"
0000000000000000000000000000000000000000;;		MountPoints map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get information about the cgroup subsystems.
0000000000000000000000000000000000000000;;	func GetCgroupSubsystems() (CgroupSubsystems, error) {
0000000000000000000000000000000000000000;;		// Get all cgroup mounts.
0000000000000000000000000000000000000000;;		allCgroups, err := cgroups.GetCgroupMounts(true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return CgroupSubsystems{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(allCgroups) == 0 {
0000000000000000000000000000000000000000;;			return CgroupSubsystems{}, fmt.Errorf("failed to find cgroup mounts")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trim the mounts to only the subsystems we care about.
0000000000000000000000000000000000000000;;		supportedCgroups := make([]cgroups.Mount, 0, len(allCgroups))
0000000000000000000000000000000000000000;;		mountPoints := make(map[string]string, len(allCgroups))
0000000000000000000000000000000000000000;;		for _, mount := range allCgroups {
0000000000000000000000000000000000000000;;			for _, subsystem := range mount.Subsystems {
0000000000000000000000000000000000000000;;				if _, ok := supportedSubsystems[subsystem]; ok {
0000000000000000000000000000000000000000;;					supportedCgroups = append(supportedCgroups, mount)
0000000000000000000000000000000000000000;;					mountPoints[subsystem] = mount.Mountpoint
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return CgroupSubsystems{
0000000000000000000000000000000000000000;;			Mounts:      supportedCgroups,
0000000000000000000000000000000000000000;;			MountPoints: mountPoints,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cgroup subsystems we support listing (should be the minimal set we need stats from).
0000000000000000000000000000000000000000;;	var supportedSubsystems map[string]struct{} = map[string]struct{}{
0000000000000000000000000000000000000000;;		"cpu":     {},
0000000000000000000000000000000000000000;;		"cpuacct": {},
0000000000000000000000000000000000000000;;		"memory":  {},
0000000000000000000000000000000000000000;;		"cpuset":  {},
0000000000000000000000000000000000000000;;		"blkio":   {},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get cgroup and networking stats of the specified container
0000000000000000000000000000000000000000;;	func GetStats(cgroupManager cgroups.Manager, rootFs string, pid int, ignoreMetrics container.MetricSet) (*info.ContainerStats, error) {
0000000000000000000000000000000000000000;;		cgroupStats, err := cgroupManager.GetStats()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		libcontainerStats := &libcontainer.Stats{
0000000000000000000000000000000000000000;;			CgroupStats: cgroupStats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stats := newContainerStats(libcontainerStats)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we know the pid then get network stats from /proc/<pid>/net/dev
0000000000000000000000000000000000000000;;		if pid == 0 {
0000000000000000000000000000000000000000;;			return stats, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ignoreMetrics.Has(container.NetworkUsageMetrics) {
0000000000000000000000000000000000000000;;			netStats, err := networkStatsFromProc(rootFs, pid)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Unable to get network stats from pid %d: %v", pid, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				stats.Network.Interfaces = append(stats.Network.Interfaces, netStats...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ignoreMetrics.Has(container.NetworkTcpUsageMetrics) {
0000000000000000000000000000000000000000;;			t, err := tcpStatsFromProc(rootFs, pid, "net/tcp")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Unable to get tcp stats from pid %d: %v", pid, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				stats.Network.Tcp = t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t6, err := tcpStatsFromProc(rootFs, pid, "net/tcp6")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Unable to get tcp6 stats from pid %d: %v", pid, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				stats.Network.Tcp6 = t6
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !ignoreMetrics.Has(container.NetworkUdpUsageMetrics) {
0000000000000000000000000000000000000000;;			u, err := udpStatsFromProc(rootFs, pid, "net/udp")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Unable to get udp stats from pid %d: %v", pid, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				stats.Network.Udp = u
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			u6, err := udpStatsFromProc(rootFs, pid, "net/udp6")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Unable to get udp6 stats from pid %d: %v", pid, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				stats.Network.Udp6 = u6
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For backwards compatibility.
0000000000000000000000000000000000000000;;		if len(stats.Network.Interfaces) > 0 {
0000000000000000000000000000000000000000;;			stats.Network.InterfaceStats = stats.Network.Interfaces[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func networkStatsFromProc(rootFs string, pid int) ([]info.InterfaceStats, error) {
0000000000000000000000000000000000000000;;		netStatsFile := path.Join(rootFs, "proc", strconv.Itoa(pid), "/net/dev")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ifaceStats, err := scanInterfaceStats(netStatsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []info.InterfaceStats{}, fmt.Errorf("couldn't read network stats: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ifaceStats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ignoredDevicePrefixes = []string{"lo", "veth", "docker"}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isIgnoredDevice(ifName string) bool {
0000000000000000000000000000000000000000;;		for _, prefix := range ignoredDevicePrefixes {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(strings.ToLower(ifName), prefix) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scanInterfaceStats(netStatsFile string) ([]info.InterfaceStats, error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(netStatsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failure opening %s: %v", netStatsFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Discard header lines
0000000000000000000000000000000000000000;;		for i := 0; i < 2; i++ {
0000000000000000000000000000000000000000;;			if b := scanner.Scan(); !b {
0000000000000000000000000000000000000000;;				return nil, scanner.Err()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats := []info.InterfaceStats{}
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := scanner.Text()
0000000000000000000000000000000000000000;;			line = strings.Replace(line, ":", "", -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fields := strings.Fields(line)
0000000000000000000000000000000000000000;;			// If the format of the  line is invalid then don't trust any of the stats
0000000000000000000000000000000000000000;;			// in this file.
0000000000000000000000000000000000000000;;			if len(fields) != 17 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid interface stats line: %v", line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			devName := fields[0]
0000000000000000000000000000000000000000;;			if isIgnoredDevice(devName) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i := info.InterfaceStats{
0000000000000000000000000000000000000000;;				Name: devName,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			statFields := append(fields[1:5], fields[9:13]...)
0000000000000000000000000000000000000000;;			statPointers := []*uint64{
0000000000000000000000000000000000000000;;				&i.RxBytes, &i.RxPackets, &i.RxErrors, &i.RxDropped,
0000000000000000000000000000000000000000;;				&i.TxBytes, &i.TxPackets, &i.TxErrors, &i.TxDropped,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := setInterfaceStatValues(statFields, statPointers)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("cannot parse interface stats (%v): %v", err, line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stats = append(stats, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setInterfaceStatValues(fields []string, pointers []*uint64) error {
0000000000000000000000000000000000000000;;		for i, v := range fields {
0000000000000000000000000000000000000000;;			val, err := strconv.ParseUint(v, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*pointers[i] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tcpStatsFromProc(rootFs string, pid int, file string) (info.TcpStat, error) {
0000000000000000000000000000000000000000;;		tcpStatsFile := path.Join(rootFs, "proc", strconv.Itoa(pid), file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tcpStats, err := scanTcpStats(tcpStatsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return tcpStats, fmt.Errorf("couldn't read tcp stats: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return tcpStats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scanTcpStats(tcpStatsFile string) (info.TcpStat, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var stats info.TcpStat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, err := ioutil.ReadFile(tcpStatsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return stats, fmt.Errorf("failure opening %s: %v", tcpStatsFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tcpStateMap := map[string]uint64{
0000000000000000000000000000000000000000;;			"01": 0, //ESTABLISHED
0000000000000000000000000000000000000000;;			"02": 0, //SYN_SENT
0000000000000000000000000000000000000000;;			"03": 0, //SYN_RECV
0000000000000000000000000000000000000000;;			"04": 0, //FIN_WAIT1
0000000000000000000000000000000000000000;;			"05": 0, //FIN_WAIT2
0000000000000000000000000000000000000000;;			"06": 0, //TIME_WAIT
0000000000000000000000000000000000000000;;			"07": 0, //CLOSE
0000000000000000000000000000000000000000;;			"08": 0, //CLOSE_WAIT
0000000000000000000000000000000000000000;;			"09": 0, //LAST_ACK
0000000000000000000000000000000000000000;;			"0A": 0, //LISTEN
0000000000000000000000000000000000000000;;			"0B": 0, //CLOSING
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := strings.NewReader(string(data))
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(reader)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner.Split(bufio.ScanLines)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Discard header line
0000000000000000000000000000000000000000;;		if b := scanner.Scan(); !b {
0000000000000000000000000000000000000000;;			return stats, scanner.Err()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := scanner.Text()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			state := strings.Fields(line)
0000000000000000000000000000000000000000;;			// TCP state is the 4th field.
0000000000000000000000000000000000000000;;			// Format: sl local_address rem_address st tx_queue rx_queue tr tm->when retrnsmt  uid timeout inode
0000000000000000000000000000000000000000;;			tcpState := state[3]
0000000000000000000000000000000000000000;;			_, ok := tcpStateMap[tcpState]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return stats, fmt.Errorf("invalid TCP stats line: %v", line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tcpStateMap[tcpState]++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats = info.TcpStat{
0000000000000000000000000000000000000000;;			Established: tcpStateMap["01"],
0000000000000000000000000000000000000000;;			SynSent:     tcpStateMap["02"],
0000000000000000000000000000000000000000;;			SynRecv:     tcpStateMap["03"],
0000000000000000000000000000000000000000;;			FinWait1:    tcpStateMap["04"],
0000000000000000000000000000000000000000;;			FinWait2:    tcpStateMap["05"],
0000000000000000000000000000000000000000;;			TimeWait:    tcpStateMap["06"],
0000000000000000000000000000000000000000;;			Close:       tcpStateMap["07"],
0000000000000000000000000000000000000000;;			CloseWait:   tcpStateMap["08"],
0000000000000000000000000000000000000000;;			LastAck:     tcpStateMap["09"],
0000000000000000000000000000000000000000;;			Listen:      tcpStateMap["0A"],
0000000000000000000000000000000000000000;;			Closing:     tcpStateMap["0B"],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func udpStatsFromProc(rootFs string, pid int, file string) (info.UdpStat, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var udpStats info.UdpStat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		udpStatsFile := path.Join(rootFs, "proc", strconv.Itoa(pid), file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, err := os.Open(udpStatsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return udpStats, fmt.Errorf("failure opening %s: %v", udpStatsFile, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		udpStats, err = scanUdpStats(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return udpStats, fmt.Errorf("couldn't read udp stats: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return udpStats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scanUdpStats(r io.Reader) (info.UdpStat, error) {
0000000000000000000000000000000000000000;;		var stats info.UdpStat
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(r)
0000000000000000000000000000000000000000;;		scanner.Split(bufio.ScanLines)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Discard header line
0000000000000000000000000000000000000000;;		if b := scanner.Scan(); !b {
0000000000000000000000000000000000000000;;			return stats, scanner.Err()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		listening := uint64(0)
0000000000000000000000000000000000000000;;		dropped := uint64(0)
0000000000000000000000000000000000000000;;		rxQueued := uint64(0)
0000000000000000000000000000000000000000;;		txQueued := uint64(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := scanner.Text()
0000000000000000000000000000000000000000;;			// Format: sl local_address rem_address st tx_queue rx_queue tr tm->when retrnsmt  uid timeout inode ref pointer drops
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			listening++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fs := strings.Fields(line)
0000000000000000000000000000000000000000;;			if len(fs) != 13 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rx, tx := uint64(0), uint64(0)
0000000000000000000000000000000000000000;;			fmt.Sscanf(fs[4], "%X:%X", &rx, &tx)
0000000000000000000000000000000000000000;;			rxQueued += rx
0000000000000000000000000000000000000000;;			txQueued += tx
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			d, err := strconv.Atoi(string(fs[12]))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dropped += uint64(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats = info.UdpStat{
0000000000000000000000000000000000000000;;			Listen:   listening,
0000000000000000000000000000000000000000;;			Dropped:  dropped,
0000000000000000000000000000000000000000;;			RxQueued: rxQueued,
0000000000000000000000000000000000000000;;			TxQueued: txQueued,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return stats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetProcesses(cgroupManager cgroups.Manager) ([]int, error) {
0000000000000000000000000000000000000000;;		pids, err := cgroupManager.GetPids()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pids, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DiskStatsCopy0(major, minor uint64) *info.PerDiskStats {
0000000000000000000000000000000000000000;;		disk := info.PerDiskStats{
0000000000000000000000000000000000000000;;			Major: major,
0000000000000000000000000000000000000000;;			Minor: minor,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disk.Stats = make(map[string]uint64)
0000000000000000000000000000000000000000;;		return &disk
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DiskKey struct {
0000000000000000000000000000000000000000;;		Major uint64
0000000000000000000000000000000000000000;;		Minor uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DiskStatsCopy1(disk_stat map[DiskKey]*info.PerDiskStats) []info.PerDiskStats {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		stat := make([]info.PerDiskStats, len(disk_stat))
0000000000000000000000000000000000000000;;		for _, disk := range disk_stat {
0000000000000000000000000000000000000000;;			stat[i] = *disk
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stat
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DiskStatsCopy(blkio_stats []cgroups.BlkioStatEntry) (stat []info.PerDiskStats) {
0000000000000000000000000000000000000000;;		if len(blkio_stats) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		disk_stat := make(map[DiskKey]*info.PerDiskStats)
0000000000000000000000000000000000000000;;		for i := range blkio_stats {
0000000000000000000000000000000000000000;;			major := blkio_stats[i].Major
0000000000000000000000000000000000000000;;			minor := blkio_stats[i].Minor
0000000000000000000000000000000000000000;;			disk_key := DiskKey{
0000000000000000000000000000000000000000;;				Major: major,
0000000000000000000000000000000000000000;;				Minor: minor,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			diskp, ok := disk_stat[disk_key]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				diskp = DiskStatsCopy0(major, minor)
0000000000000000000000000000000000000000;;				disk_stat[disk_key] = diskp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			op := blkio_stats[i].Op
0000000000000000000000000000000000000000;;			if op == "" {
0000000000000000000000000000000000000000;;				op = "Count"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			diskp.Stats[op] = blkio_stats[i].Value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return DiskStatsCopy1(disk_stat)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert libcontainer stats to info.ContainerStats.
0000000000000000000000000000000000000000;;	func setCpuStats(s *cgroups.Stats, ret *info.ContainerStats) {
0000000000000000000000000000000000000000;;		ret.Cpu.Usage.User = s.CpuStats.CpuUsage.UsageInUsermode
0000000000000000000000000000000000000000;;		ret.Cpu.Usage.System = s.CpuStats.CpuUsage.UsageInKernelmode
0000000000000000000000000000000000000000;;		n := len(s.CpuStats.CpuUsage.PercpuUsage)
0000000000000000000000000000000000000000;;		ret.Cpu.Usage.PerCpu = make([]uint64, n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret.Cpu.Usage.Total = 0
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			ret.Cpu.Usage.PerCpu[i] = s.CpuStats.CpuUsage.PercpuUsage[i]
0000000000000000000000000000000000000000;;			ret.Cpu.Usage.Total += s.CpuStats.CpuUsage.PercpuUsage[i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret.Cpu.CFS.Periods = s.CpuStats.ThrottlingData.Periods
0000000000000000000000000000000000000000;;		ret.Cpu.CFS.ThrottledPeriods = s.CpuStats.ThrottlingData.ThrottledPeriods
0000000000000000000000000000000000000000;;		ret.Cpu.CFS.ThrottledTime = s.CpuStats.ThrottlingData.ThrottledTime
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDiskIoStats(s *cgroups.Stats, ret *info.ContainerStats) {
0000000000000000000000000000000000000000;;		ret.DiskIo.IoServiceBytes = DiskStatsCopy(s.BlkioStats.IoServiceBytesRecursive)
0000000000000000000000000000000000000000;;		ret.DiskIo.IoServiced = DiskStatsCopy(s.BlkioStats.IoServicedRecursive)
0000000000000000000000000000000000000000;;		ret.DiskIo.IoQueued = DiskStatsCopy(s.BlkioStats.IoQueuedRecursive)
0000000000000000000000000000000000000000;;		ret.DiskIo.Sectors = DiskStatsCopy(s.BlkioStats.SectorsRecursive)
0000000000000000000000000000000000000000;;		ret.DiskIo.IoServiceTime = DiskStatsCopy(s.BlkioStats.IoServiceTimeRecursive)
0000000000000000000000000000000000000000;;		ret.DiskIo.IoWaitTime = DiskStatsCopy(s.BlkioStats.IoWaitTimeRecursive)
0000000000000000000000000000000000000000;;		ret.DiskIo.IoMerged = DiskStatsCopy(s.BlkioStats.IoMergedRecursive)
0000000000000000000000000000000000000000;;		ret.DiskIo.IoTime = DiskStatsCopy(s.BlkioStats.IoTimeRecursive)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMemoryStats(s *cgroups.Stats, ret *info.ContainerStats) {
0000000000000000000000000000000000000000;;		ret.Memory.Usage = s.MemoryStats.Usage.Usage
0000000000000000000000000000000000000000;;		ret.Memory.Failcnt = s.MemoryStats.Usage.Failcnt
0000000000000000000000000000000000000000;;		ret.Memory.Cache = s.MemoryStats.Stats["cache"]
0000000000000000000000000000000000000000;;		ret.Memory.RSS = s.MemoryStats.Stats["rss"]
0000000000000000000000000000000000000000;;		ret.Memory.Swap = s.MemoryStats.Stats["swap"]
0000000000000000000000000000000000000000;;		if v, ok := s.MemoryStats.Stats["pgfault"]; ok {
0000000000000000000000000000000000000000;;			ret.Memory.ContainerData.Pgfault = v
0000000000000000000000000000000000000000;;			ret.Memory.HierarchicalData.Pgfault = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := s.MemoryStats.Stats["pgmajfault"]; ok {
0000000000000000000000000000000000000000;;			ret.Memory.ContainerData.Pgmajfault = v
0000000000000000000000000000000000000000;;			ret.Memory.HierarchicalData.Pgmajfault = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		workingSet := ret.Memory.Usage
0000000000000000000000000000000000000000;;		if v, ok := s.MemoryStats.Stats["total_inactive_file"]; ok {
0000000000000000000000000000000000000000;;			if workingSet < v {
0000000000000000000000000000000000000000;;				workingSet = 0
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				workingSet -= v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret.Memory.WorkingSet = workingSet
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNetworkStats(libcontainerStats *libcontainer.Stats, ret *info.ContainerStats) {
0000000000000000000000000000000000000000;;		ret.Network.Interfaces = make([]info.InterfaceStats, len(libcontainerStats.Interfaces))
0000000000000000000000000000000000000000;;		for i := range libcontainerStats.Interfaces {
0000000000000000000000000000000000000000;;			ret.Network.Interfaces[i] = info.InterfaceStats{
0000000000000000000000000000000000000000;;				Name:      libcontainerStats.Interfaces[i].Name,
0000000000000000000000000000000000000000;;				RxBytes:   libcontainerStats.Interfaces[i].RxBytes,
0000000000000000000000000000000000000000;;				RxPackets: libcontainerStats.Interfaces[i].RxPackets,
0000000000000000000000000000000000000000;;				RxErrors:  libcontainerStats.Interfaces[i].RxErrors,
0000000000000000000000000000000000000000;;				RxDropped: libcontainerStats.Interfaces[i].RxDropped,
0000000000000000000000000000000000000000;;				TxBytes:   libcontainerStats.Interfaces[i].TxBytes,
0000000000000000000000000000000000000000;;				TxPackets: libcontainerStats.Interfaces[i].TxPackets,
0000000000000000000000000000000000000000;;				TxErrors:  libcontainerStats.Interfaces[i].TxErrors,
0000000000000000000000000000000000000000;;				TxDropped: libcontainerStats.Interfaces[i].TxDropped,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add to base struct for backwards compatibility.
0000000000000000000000000000000000000000;;		if len(ret.Network.Interfaces) > 0 {
0000000000000000000000000000000000000000;;			ret.Network.InterfaceStats = ret.Network.Interfaces[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newContainerStats(libcontainerStats *libcontainer.Stats) *info.ContainerStats {
0000000000000000000000000000000000000000;;		ret := &info.ContainerStats{
0000000000000000000000000000000000000000;;			Timestamp: time.Now(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s := libcontainerStats.CgroupStats; s != nil {
0000000000000000000000000000000000000000;;			setCpuStats(s, ret)
0000000000000000000000000000000000000000;;			setDiskIoStats(s, ret)
0000000000000000000000000000000000000000;;			setMemoryStats(s, ret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(libcontainerStats.Interfaces) > 0 {
0000000000000000000000000000000000000000;;			setNetworkStats(libcontainerStats, ret)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
