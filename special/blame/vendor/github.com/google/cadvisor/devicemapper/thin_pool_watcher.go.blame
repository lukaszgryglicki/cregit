0000000000000000000000000000000000000000;;	// Copyright 2016 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
0000000000000000000000000000000000000000;;	package devicemapper
a93fc00f9e3e99c0b1e06ca1ecb0ad623862f330;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ThinPoolWatcher maintains a cache of device name -> usage stats for a
0000000000000000000000000000000000000000;;	// devicemapper thin-pool using thin_ls.
0000000000000000000000000000000000000000;;	type ThinPoolWatcher struct {
0000000000000000000000000000000000000000;;		poolName       string
0000000000000000000000000000000000000000;;		metadataDevice string
0000000000000000000000000000000000000000;;		lock           *sync.RWMutex
0000000000000000000000000000000000000000;;		cache          map[string]uint64
0000000000000000000000000000000000000000;;		period         time.Duration
0000000000000000000000000000000000000000;;		stopChan       chan struct{}
0000000000000000000000000000000000000000;;		dmsetup        DmsetupClient
0000000000000000000000000000000000000000;;		thinLsClient   thinLsClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewThinPoolWatcher returns a new ThinPoolWatcher for the given devicemapper
0000000000000000000000000000000000000000;;	// thin pool name and metadata device or an error.
0000000000000000000000000000000000000000;;	func NewThinPoolWatcher(poolName, metadataDevice string) (*ThinPoolWatcher, error) {
0000000000000000000000000000000000000000;;		thinLsClient, err := newThinLsClient()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("encountered error creating thin_ls client: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ThinPoolWatcher{poolName: poolName,
0000000000000000000000000000000000000000;;			metadataDevice: metadataDevice,
0000000000000000000000000000000000000000;;			lock:           &sync.RWMutex{},
0000000000000000000000000000000000000000;;			cache:          make(map[string]uint64),
0000000000000000000000000000000000000000;;			period:         15 * time.Second,
0000000000000000000000000000000000000000;;			stopChan:       make(chan struct{}),
0000000000000000000000000000000000000000;;			dmsetup:        NewDmsetupClient(),
0000000000000000000000000000000000000000;;			thinLsClient:   thinLsClient,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start starts the ThinPoolWatcher.
0000000000000000000000000000000000000000;;	func (w *ThinPoolWatcher) Start() {
0000000000000000000000000000000000000000;;		err := w.Refresh()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("encountered error refreshing thin pool watcher: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-w.stopChan:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-time.After(w.period):
0000000000000000000000000000000000000000;;				start := time.Now()
0000000000000000000000000000000000000000;;				err = w.Refresh()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("encountered error refreshing thin pool watcher: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// print latency for refresh
0000000000000000000000000000000000000000;;				duration := time.Since(start)
0000000000000000000000000000000000000000;;				glog.V(5).Infof("thin_ls(%d) took %s", start.Unix(), duration)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the ThinPoolWatcher.
0000000000000000000000000000000000000000;;	func (w *ThinPoolWatcher) Stop() {
0000000000000000000000000000000000000000;;		close(w.stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUsage gets the cached usage value of the given device.
0000000000000000000000000000000000000000;;	func (w *ThinPoolWatcher) GetUsage(deviceId string) (uint64, error) {
0000000000000000000000000000000000000000;;		w.lock.RLock()
0000000000000000000000000000000000000000;;		defer w.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v, ok := w.cache[deviceId]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("no cached value for usage of device %v", deviceId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		reserveMetadataMessage = "reserve_metadata_snap"
0000000000000000000000000000000000000000;;		releaseMetadataMessage = "release_metadata_snap"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Refresh performs a `thin_ls` of the pool being watched and refreshes the
0000000000000000000000000000000000000000;;	// cached data with the result.
0000000000000000000000000000000000000000;;	func (w *ThinPoolWatcher) Refresh() error {
0000000000000000000000000000000000000000;;		w.lock.Lock()
0000000000000000000000000000000000000000;;		defer w.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentlyReserved, err := w.checkReservation(w.poolName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("error determining whether snapshot is reserved: %v", err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if currentlyReserved {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("metadata for %v is currently reserved; releasing", w.poolName)
0000000000000000000000000000000000000000;;			_, err = w.dmsetup.Message(w.poolName, 0, releaseMetadataMessage)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				err = fmt.Errorf("error releasing metadata snapshot for %v: %v", w.poolName, err)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("reserving metadata snapshot for thin-pool %v", w.poolName)
0000000000000000000000000000000000000000;;		// NOTE: "0" in the call below is for the 'sector' argument to 'dmsetup
0000000000000000000000000000000000000000;;		// message'.  It's not needed for thin pools.
0000000000000000000000000000000000000000;;		if output, err := w.dmsetup.Message(w.poolName, 0, reserveMetadataMessage); err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("error reserving metadata for thin-pool %v: %v output: %v", w.poolName, err, string(output))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("reserved metadata snapshot for thin-pool %v", w.poolName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(5).Infof("releasing metadata snapshot for thin-pool %v", w.poolName)
0000000000000000000000000000000000000000;;			w.dmsetup.Message(w.poolName, 0, releaseMetadataMessage)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("running thin_ls on metadata device %v", w.metadataDevice)
0000000000000000000000000000000000000000;;		newCache, err := w.thinLsClient.ThinLs(w.metadataDevice)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("error performing thin_ls on metadata device %v: %v", w.metadataDevice, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.cache = newCache
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		thinPoolDmsetupStatusHeldMetadataRoot = 6
0000000000000000000000000000000000000000;;		thinPoolDmsetupStatusMinFields        = thinPoolDmsetupStatusHeldMetadataRoot + 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkReservation checks to see whether the thin device is currently holding
0000000000000000000000000000000000000000;;	// userspace metadata.
0000000000000000000000000000000000000000;;	func (w *ThinPoolWatcher) checkReservation(poolName string) (bool, error) {
0000000000000000000000000000000000000000;;		glog.V(5).Infof("checking whether the thin-pool is holding a metadata snapshot")
0000000000000000000000000000000000000000;;		output, err := w.dmsetup.Status(poolName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we care about the field at fields[thinPoolDmsetupStatusHeldMetadataRoot],
0000000000000000000000000000000000000000;;		// so make sure we get enough fields
0000000000000000000000000000000000000000;;		fields := strings.Fields(string(output))
0000000000000000000000000000000000000000;;		if len(fields) < thinPoolDmsetupStatusMinFields {
0000000000000000000000000000000000000000;;			return false, fmt.Errorf("unexpected output of dmsetup status command; expected at least %d fields, got %v; output: %v", thinPoolDmsetupStatusMinFields, len(fields), string(output))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		heldMetadataRoot := fields[thinPoolDmsetupStatusHeldMetadataRoot]
0000000000000000000000000000000000000000;;		currentlyReserved := heldMetadataRoot != "-"
0000000000000000000000000000000000000000;;		return currentlyReserved, nil
0000000000000000000000000000000000000000;;	}
