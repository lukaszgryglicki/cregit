0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
ddb91896b60df07452d87846c6343678b1c48dde;Godeps/_workspace/src/github.com/google/cadvisor/pages/docker.go[Godeps/_workspace/src/github.com/google/cadvisor/pages/docker.go][vendor/github.com/google/cadvisor/pages/docker.go];	
0000000000000000000000000000000000000000;;	package pages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/docker"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const DockerPage = "/docker/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toStatusKV(status info.DockerStatus) ([]keyVal, []keyVal) {
0000000000000000000000000000000000000000;;		ds := []keyVal{
0000000000000000000000000000000000000000;;			{Key: "Driver", Value: status.Driver},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range status.DriverStatus {
0000000000000000000000000000000000000000;;			ds = append(ds, keyVal{Key: k, Value: v})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []keyVal{
0000000000000000000000000000000000000000;;			{Key: "Docker Version", Value: status.Version},
0000000000000000000000000000000000000000;;			{Key: "Docker API Version", Value: status.APIVersion},
0000000000000000000000000000000000000000;;			{Key: "Kernel Version", Value: status.KernelVersion},
0000000000000000000000000000000000000000;;			{Key: "OS Version", Value: status.OS},
0000000000000000000000000000000000000000;;			{Key: "Host Name", Value: status.Hostname},
0000000000000000000000000000000000000000;;			{Key: "Docker Root Directory", Value: status.RootDir},
0000000000000000000000000000000000000000;;			{Key: "Execution  Driver", Value: status.ExecDriver},
0000000000000000000000000000000000000000;;			{Key: "Number of Images", Value: strconv.Itoa(status.NumImages)},
0000000000000000000000000000000000000000;;			{Key: "Number of Containers", Value: strconv.Itoa(status.NumContainers)},
0000000000000000000000000000000000000000;;		}, ds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serveDockerPage(m manager.Manager, w http.ResponseWriter, u *url.URL) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container name is the path after the handler
0000000000000000000000000000000000000000;;		containerName := u.Path[len(DockerPage)-1:]
0000000000000000000000000000000000000000;;		rootDir := getRootDir(containerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var data *pageData
0000000000000000000000000000000000000000;;		if containerName == "/" {
0000000000000000000000000000000000000000;;			// Get the containers.
0000000000000000000000000000000000000000;;			reqParams := info.ContainerInfoRequest{
0000000000000000000000000000000000000000;;				NumStats: 0,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			conts, err := m.AllDockerContainers(&reqParams)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to get container %q with error: %v", containerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			subcontainers := make([]link, 0, len(conts))
0000000000000000000000000000000000000000;;			for _, cont := range conts {
0000000000000000000000000000000000000000;;				subcontainers = append(subcontainers, link{
0000000000000000000000000000000000000000;;					Text: getContainerDisplayName(cont.ContainerReference),
0000000000000000000000000000000000000000;;					Link: path.Join(rootDir, DockerPage, docker.ContainerNameToDockerId(cont.ContainerReference.Name)),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get Docker status
0000000000000000000000000000000000000000;;			status, err := m.DockerInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dockerStatus, driverStatus := toStatusKV(status)
0000000000000000000000000000000000000000;;			// Get Docker Images
0000000000000000000000000000000000000000;;			images, err := m.DockerImages()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			dockerContainersText := "Docker Containers"
0000000000000000000000000000000000000000;;			data = &pageData{
0000000000000000000000000000000000000000;;				DisplayName: dockerContainersText,
0000000000000000000000000000000000000000;;				ParentContainers: []link{
0000000000000000000000000000000000000000;;					{
0000000000000000000000000000000000000000;;						Text: dockerContainersText,
0000000000000000000000000000000000000000;;						Link: path.Join(rootDir, DockerPage),
0000000000000000000000000000000000000000;;					}},
0000000000000000000000000000000000000000;;				Subcontainers:      subcontainers,
0000000000000000000000000000000000000000;;				Root:               rootDir,
0000000000000000000000000000000000000000;;				DockerStatus:       dockerStatus,
0000000000000000000000000000000000000000;;				DockerDriverStatus: driverStatus,
0000000000000000000000000000000000000000;;				DockerImages:       images,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Get the container.
0000000000000000000000000000000000000000;;			reqParams := info.ContainerInfoRequest{
0000000000000000000000000000000000000000;;				NumStats: 60,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cont, err := m.DockerContainer(containerName[1:], &reqParams)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to get container %q with error: %v", containerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			displayName := getContainerDisplayName(cont.ContainerReference)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make a list of the parent containers and their links
0000000000000000000000000000000000000000;;			var parentContainers []link
0000000000000000000000000000000000000000;;			parentContainers = append(parentContainers, link{
0000000000000000000000000000000000000000;;				Text: "Docker Containers",
0000000000000000000000000000000000000000;;				Link: path.Join(rootDir, DockerPage),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			parentContainers = append(parentContainers, link{
0000000000000000000000000000000000000000;;				Text: displayName,
0000000000000000000000000000000000000000;;				Link: path.Join(rootDir, DockerPage, docker.ContainerNameToDockerId(cont.Name)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the MachineInfo
0000000000000000000000000000000000000000;;			machineInfo, err := m.GetMachineInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			data = &pageData{
0000000000000000000000000000000000000000;;				DisplayName:            displayName,
0000000000000000000000000000000000000000;;				ContainerName:          escapeContainerName(cont.Name),
0000000000000000000000000000000000000000;;				ParentContainers:       parentContainers,
0000000000000000000000000000000000000000;;				Spec:                   cont.Spec,
0000000000000000000000000000000000000000;;				Stats:                  cont.Stats,
0000000000000000000000000000000000000000;;				MachineInfo:            machineInfo,
0000000000000000000000000000000000000000;;				ResourcesAvailable:     cont.Spec.HasCpu || cont.Spec.HasMemory || cont.Spec.HasNetwork,
0000000000000000000000000000000000000000;;				CpuAvailable:           cont.Spec.HasCpu,
0000000000000000000000000000000000000000;;				MemoryAvailable:        cont.Spec.HasMemory,
0000000000000000000000000000000000000000;;				NetworkAvailable:       cont.Spec.HasNetwork,
0000000000000000000000000000000000000000;;				FsAvailable:            cont.Spec.HasFilesystem,
0000000000000000000000000000000000000000;;				CustomMetricsAvailable: cont.Spec.HasCustomMetrics,
0000000000000000000000000000000000000000;;				Root: rootDir,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := pageTemplate.Execute(w, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to apply template: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Request took %s", time.Since(start))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
