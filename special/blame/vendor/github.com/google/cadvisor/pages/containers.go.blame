0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
ddb91896b60df07452d87846c6343678b1c48dde;Godeps/_workspace/src/github.com/google/cadvisor/pages/containers.go[Godeps/_workspace/src/github.com/google/cadvisor/pages/containers.go][vendor/github.com/google/cadvisor/pages/containers.go];	
0000000000000000000000000000000000000000;;	// Page for /containers/
0000000000000000000000000000000000000000;;	package pages
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"html/template"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ContainersPage = "/containers/"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// from http://golang.org/doc/effective_go.html#constants
0000000000000000000000000000000000000000;;	type ByteSize float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_ = iota
0000000000000000000000000000000000000000;;		// KB - kilobyte
0000000000000000000000000000000000000000;;		KB ByteSize = 1 << (10 * iota)
0000000000000000000000000000000000000000;;		// MB - megabyte
0000000000000000000000000000000000000000;;		MB
0000000000000000000000000000000000000000;;		// GB - gigabyte
0000000000000000000000000000000000000000;;		GB
0000000000000000000000000000000000000000;;		// TB - terabyte
0000000000000000000000000000000000000000;;		TB
0000000000000000000000000000000000000000;;		// PB - petabyte
0000000000000000000000000000000000000000;;		PB
0000000000000000000000000000000000000000;;		// EB - exabyte
0000000000000000000000000000000000000000;;		EB
0000000000000000000000000000000000000000;;		// ZB - zettabyte
0000000000000000000000000000000000000000;;		ZB
0000000000000000000000000000000000000000;;		// YB - yottabyte
0000000000000000000000000000000000000000;;		YB
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b ByteSize) Size() string {
0000000000000000000000000000000000000000;;		for _, i := range [...]ByteSize{YB, ZB, EB, PB, TB, GB, MB, KB} {
0000000000000000000000000000000000000000;;			if b >= i {
0000000000000000000000000000000000000000;;				return fmt.Sprintf("%.2f", b/i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%.2f", b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b ByteSize) Unit() string {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case b >= YB:
0000000000000000000000000000000000000000;;			return "YB"
0000000000000000000000000000000000000000;;		case b >= ZB:
0000000000000000000000000000000000000000;;			return "ZB"
0000000000000000000000000000000000000000;;		case b >= EB:
0000000000000000000000000000000000000000;;			return "EB"
0000000000000000000000000000000000000000;;		case b >= PB:
0000000000000000000000000000000000000000;;			return "PB"
0000000000000000000000000000000000000000;;		case b >= TB:
0000000000000000000000000000000000000000;;			return "TB"
0000000000000000000000000000000000000000;;		case b >= GB:
0000000000000000000000000000000000000000;;			return "GB"
0000000000000000000000000000000000000000;;		case b >= MB:
0000000000000000000000000000000000000000;;			return "MB"
0000000000000000000000000000000000000000;;		case b >= KB:
0000000000000000000000000000000000000000;;			return "KB"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "B"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var funcMap = template.FuncMap{
0000000000000000000000000000000000000000;;		"printMask":   printMask,
0000000000000000000000000000000000000000;;		"printCores":  printCores,
0000000000000000000000000000000000000000;;		"printShares": printShares,
0000000000000000000000000000000000000000;;		"printSize":   printSize,
0000000000000000000000000000000000000000;;		"printUnit":   printUnit,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printMask(mask string, numCores int) interface{} {
0000000000000000000000000000000000000000;;		masks := make([]string, numCores)
0000000000000000000000000000000000000000;;		activeCores := getActiveCores(mask)
0000000000000000000000000000000000000000;;		for i := 0; i < numCores; i++ {
0000000000000000000000000000000000000000;;			coreClass := "inactive-cpu"
0000000000000000000000000000000000000000;;			if activeCores[i] {
0000000000000000000000000000000000000000;;				coreClass = "active-cpu"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			masks[i] = fmt.Sprintf("<span class=\"%s\">%d</span>", coreClass, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return template.HTML(strings.Join(masks, "&nbsp;"))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getActiveCores(mask string) map[int]bool {
0000000000000000000000000000000000000000;;		activeCores := make(map[int]bool)
0000000000000000000000000000000000000000;;		for _, corebits := range strings.Split(mask, ",") {
0000000000000000000000000000000000000000;;			cores := strings.Split(corebits, "-")
0000000000000000000000000000000000000000;;			if len(cores) == 1 {
0000000000000000000000000000000000000000;;				index, err := strconv.Atoi(cores[0])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					// Ignore malformed strings.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				activeCores[index] = true
0000000000000000000000000000000000000000;;			} else if len(cores) == 2 {
0000000000000000000000000000000000000000;;				start, err := strconv.Atoi(cores[0])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				end, err := strconv.Atoi(cores[1])
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i := start; i <= end; i++ {
0000000000000000000000000000000000000000;;					activeCores[i] = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return activeCores
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printCores(millicores *uint64) string {
0000000000000000000000000000000000000000;;		cores := float64(*millicores) / 1000
0000000000000000000000000000000000000000;;		return strconv.FormatFloat(cores, 'f', 3, 64)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printShares(shares *uint64) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d", *shares)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Size after which we consider memory to be "unlimited". This is not
0000000000000000000000000000000000000000;;	// MaxInt64 due to rounding by the kernel.
0000000000000000000000000000000000000000;;	const maxMemorySize = uint64(1 << 62)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printSize(bytes uint64) string {
0000000000000000000000000000000000000000;;		if bytes >= maxMemorySize {
0000000000000000000000000000000000000000;;			return "unlimited"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ByteSize(bytes).Size()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func printUnit(bytes uint64) string {
0000000000000000000000000000000000000000;;		if bytes >= maxMemorySize {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ByteSize(bytes).Unit()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serveContainersPage(m manager.Manager, w http.ResponseWriter, u *url.URL) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The container name is the path after the handler
0000000000000000000000000000000000000000;;		containerName := u.Path[len(ContainersPage)-1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the container.
0000000000000000000000000000000000000000;;		reqParams := info.ContainerInfoRequest{
0000000000000000000000000000000000000000;;			NumStats: 60,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cont, err := m.GetContainerInfo(containerName, &reqParams)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to get container %q with error: %v", containerName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		displayName := getContainerDisplayName(cont.ContainerReference)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the MachineInfo
0000000000000000000000000000000000000000;;		machineInfo, err := m.GetMachineInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rootDir := getRootDir(containerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a list of the parent containers and their links
0000000000000000000000000000000000000000;;		pathParts := strings.Split(string(cont.Name), "/")
0000000000000000000000000000000000000000;;		parentContainers := make([]link, 0, len(pathParts))
0000000000000000000000000000000000000000;;		parentContainers = append(parentContainers, link{
0000000000000000000000000000000000000000;;			Text: "root",
0000000000000000000000000000000000000000;;			Link: path.Join(rootDir, ContainersPage),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		for i := 1; i < len(pathParts); i++ {
0000000000000000000000000000000000000000;;			// Skip empty parts.
0000000000000000000000000000000000000000;;			if pathParts[i] == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parentContainers = append(parentContainers, link{
0000000000000000000000000000000000000000;;				Text: pathParts[i],
0000000000000000000000000000000000000000;;				Link: path.Join(rootDir, ContainersPage, path.Join(pathParts[1:i+1]...)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Build the links for the subcontainers.
0000000000000000000000000000000000000000;;		subcontainerLinks := make([]link, 0, len(cont.Subcontainers))
0000000000000000000000000000000000000000;;		for _, sub := range cont.Subcontainers {
0000000000000000000000000000000000000000;;			if !m.Exists(sub.Name) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			subcontainerLinks = append(subcontainerLinks, link{
0000000000000000000000000000000000000000;;				Text: getContainerDisplayName(sub),
0000000000000000000000000000000000000000;;				Link: path.Join(rootDir, ContainersPage, sub.Name),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := &pageData{
0000000000000000000000000000000000000000;;			DisplayName:            displayName,
0000000000000000000000000000000000000000;;			ContainerName:          escapeContainerName(cont.Name),
0000000000000000000000000000000000000000;;			ParentContainers:       parentContainers,
0000000000000000000000000000000000000000;;			Subcontainers:          subcontainerLinks,
0000000000000000000000000000000000000000;;			Spec:                   cont.Spec,
0000000000000000000000000000000000000000;;			Stats:                  cont.Stats,
0000000000000000000000000000000000000000;;			MachineInfo:            machineInfo,
0000000000000000000000000000000000000000;;			IsRoot:                 cont.Name == "/",
0000000000000000000000000000000000000000;;			ResourcesAvailable:     cont.Spec.HasCpu || cont.Spec.HasMemory || cont.Spec.HasNetwork || cont.Spec.HasFilesystem,
0000000000000000000000000000000000000000;;			CpuAvailable:           cont.Spec.HasCpu,
0000000000000000000000000000000000000000;;			MemoryAvailable:        cont.Spec.HasMemory,
0000000000000000000000000000000000000000;;			NetworkAvailable:       cont.Spec.HasNetwork,
0000000000000000000000000000000000000000;;			FsAvailable:            cont.Spec.HasFilesystem,
0000000000000000000000000000000000000000;;			CustomMetricsAvailable: cont.Spec.HasCustomMetrics,
0000000000000000000000000000000000000000;;			SubcontainersAvailable: len(subcontainerLinks) > 0,
0000000000000000000000000000000000000000;;			Root: rootDir,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = pageTemplate.Execute(w, data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to apply template: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(5).Infof("Request took %s", time.Since(start))
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Build a relative path to the root of the container page.
0000000000000000000000000000000000000000;;	func getRootDir(containerName string) string {
0000000000000000000000000000000000000000;;		// The root is at: container depth
0000000000000000000000000000000000000000;;		levels := (strings.Count(containerName, "/"))
0000000000000000000000000000000000000000;;		return strings.Repeat("../", levels)
0000000000000000000000000000000000000000;;	}
