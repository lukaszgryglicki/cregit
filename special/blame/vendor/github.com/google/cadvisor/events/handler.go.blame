0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/events/handler.go[Godeps/_workspace/src/github.com/google/cadvisor/events/handler.go][vendor/github.com/google/cadvisor/events/handler.go];	
0000000000000000000000000000000000000000;;	package events
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byTimestamp []*info.Event
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// functions necessary to implement the sort interface on the Events struct
0000000000000000000000000000000000000000;;	func (e byTimestamp) Len() int {
0000000000000000000000000000000000000000;;		return len(e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e byTimestamp) Swap(i, j int) {
0000000000000000000000000000000000000000;;		e[i], e[j] = e[j], e[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e byTimestamp) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return e[i].Timestamp.Before(e[j].Timestamp)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EventChannel struct {
0000000000000000000000000000000000000000;;		// Watch ID. Can be used by the caller to request cancellation of watch events.
0000000000000000000000000000000000000000;;		watchId int
0000000000000000000000000000000000000000;;		// Channel on which the caller can receive watch events.
0000000000000000000000000000000000000000;;		channel chan *info.Event
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Request holds a set of parameters by which Event objects may be screened.
0000000000000000000000000000000000000000;;	// The caller may want events that occurred within a specific timeframe
0000000000000000000000000000000000000000;;	// or of a certain type, which may be specified in the *Request object
0000000000000000000000000000000000000000;;	// they pass to an EventManager function
0000000000000000000000000000000000000000;;	type Request struct {
0000000000000000000000000000000000000000;;		// events falling before StartTime do not satisfy the request. StartTime
0000000000000000000000000000000000000000;;		// must be left blank in calls to WatchEvents
0000000000000000000000000000000000000000;;		StartTime time.Time
0000000000000000000000000000000000000000;;		// events falling after EndTime do not satisfy the request. EndTime
0000000000000000000000000000000000000000;;		// must be left blank in calls to WatchEvents
0000000000000000000000000000000000000000;;		EndTime time.Time
0000000000000000000000000000000000000000;;		// EventType is a map that specifies the type(s) of events wanted
0000000000000000000000000000000000000000;;		EventType map[info.EventType]bool
0000000000000000000000000000000000000000;;		// allows the caller to put a limit on how many
0000000000000000000000000000000000000000;;		// events to receive. If there are more events than MaxEventsReturned
0000000000000000000000000000000000000000;;		// then the most chronologically recent events in the time period
0000000000000000000000000000000000000000;;		// specified are returned. Must be >= 1
0000000000000000000000000000000000000000;;		MaxEventsReturned int
0000000000000000000000000000000000000000;;		// the absolute container name for which the event occurred
0000000000000000000000000000000000000000;;		ContainerName string
0000000000000000000000000000000000000000;;		// if IncludeSubcontainers is false, only events occurring in the specific
0000000000000000000000000000000000000000;;		// container, and not the subcontainers, will be returned
0000000000000000000000000000000000000000;;		IncludeSubcontainers bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventManager is implemented by Events. It provides two ways to monitor
0000000000000000000000000000000000000000;;	// events and one way to add events
0000000000000000000000000000000000000000;;	type EventManager interface {
0000000000000000000000000000000000000000;;		// WatchEvents() allows a caller to register for receiving events based on the specified request.
0000000000000000000000000000000000000000;;		// On successful registration, an EventChannel object is returned.
0000000000000000000000000000000000000000;;		WatchEvents(request *Request) (*EventChannel, error)
0000000000000000000000000000000000000000;;		// GetEvents() returns all detected events based on the filters specified in request.
0000000000000000000000000000000000000000;;		GetEvents(request *Request) ([]*info.Event, error)
0000000000000000000000000000000000000000;;		// AddEvent allows the caller to add an event to an EventManager
0000000000000000000000000000000000000000;;		// object
0000000000000000000000000000000000000000;;		AddEvent(e *info.Event) error
0000000000000000000000000000000000000000;;		// Cancels a previously requested watch event.
0000000000000000000000000000000000000000;;		StopWatch(watch_id int)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// events provides an implementation for the EventManager interface.
0000000000000000000000000000000000000000;;	type events struct {
0000000000000000000000000000000000000000;;		// eventStore holds the events by event type.
0000000000000000000000000000000000000000;;		eventStore map[info.EventType]*utils.TimedStore
0000000000000000000000000000000000000000;;		// map of registered watchers keyed by watch id.
0000000000000000000000000000000000000000;;		watchers map[int]*watch
0000000000000000000000000000000000000000;;		// lock guarding the eventStore.
0000000000000000000000000000000000000000;;		eventsLock sync.RWMutex
0000000000000000000000000000000000000000;;		// lock guarding watchers.
0000000000000000000000000000000000000000;;		watcherLock sync.RWMutex
0000000000000000000000000000000000000000;;		// last allocated watch id.
0000000000000000000000000000000000000000;;		lastId int
0000000000000000000000000000000000000000;;		// Event storage policy.
0000000000000000000000000000000000000000;;		storagePolicy StoragePolicy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// initialized by a call to WatchEvents(), a watch struct will then be added
0000000000000000000000000000000000000000;;	// to the events slice of *watch objects. When AddEvent() finds an event that
0000000000000000000000000000000000000000;;	// satisfies the request parameter of a watch object in events.watchers,
0000000000000000000000000000000000000000;;	// it will send that event out over the watch object's channel. The caller that
0000000000000000000000000000000000000000;;	// called WatchEvents will receive the event over the channel provided to
0000000000000000000000000000000000000000;;	// WatchEvents
0000000000000000000000000000000000000000;;	type watch struct {
0000000000000000000000000000000000000000;;		// request parameters passed in by the caller of WatchEvents()
0000000000000000000000000000000000000000;;		request *Request
0000000000000000000000000000000000000000;;		// a channel used to send event back to the caller.
0000000000000000000000000000000000000000;;		eventChannel *EventChannel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewEventChannel(watchId int) *EventChannel {
0000000000000000000000000000000000000000;;		return &EventChannel{
0000000000000000000000000000000000000000;;			watchId: watchId,
0000000000000000000000000000000000000000;;			channel: make(chan *info.Event, 10),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Policy specifying how many events to store.
0000000000000000000000000000000000000000;;	// MaxAge is the max duration for which to keep events.
0000000000000000000000000000000000000000;;	// MaxNumEvents is the max number of events to keep (-1 for no limit).
0000000000000000000000000000000000000000;;	type StoragePolicy struct {
0000000000000000000000000000000000000000;;		// Defaults limites, used if a per-event limit is not set.
0000000000000000000000000000000000000000;;		DefaultMaxAge       time.Duration
0000000000000000000000000000000000000000;;		DefaultMaxNumEvents int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Per-event type limits.
0000000000000000000000000000000000000000;;		PerTypeMaxAge       map[info.EventType]time.Duration
0000000000000000000000000000000000000000;;		PerTypeMaxNumEvents map[info.EventType]int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DefaultStoragePolicy() StoragePolicy {
0000000000000000000000000000000000000000;;		return StoragePolicy{
0000000000000000000000000000000000000000;;			DefaultMaxAge:       24 * time.Hour,
0000000000000000000000000000000000000000;;			DefaultMaxNumEvents: 100000,
0000000000000000000000000000000000000000;;			PerTypeMaxAge:       make(map[info.EventType]time.Duration),
0000000000000000000000000000000000000000;;			PerTypeMaxNumEvents: make(map[info.EventType]int),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns a pointer to an initialized Events object.
0000000000000000000000000000000000000000;;	func NewEventManager(storagePolicy StoragePolicy) *events {
0000000000000000000000000000000000000000;;		return &events{
0000000000000000000000000000000000000000;;			eventStore:    make(map[info.EventType]*utils.TimedStore, 0),
0000000000000000000000000000000000000000;;			watchers:      make(map[int]*watch),
0000000000000000000000000000000000000000;;			storagePolicy: storagePolicy,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns a pointer to an initialized Request object
0000000000000000000000000000000000000000;;	func NewRequest() *Request {
0000000000000000000000000000000000000000;;		return &Request{
0000000000000000000000000000000000000000;;			EventType:            map[info.EventType]bool{},
0000000000000000000000000000000000000000;;			IncludeSubcontainers: false,
0000000000000000000000000000000000000000;;			MaxEventsReturned:    10,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns a pointer to an initialized watch object
0000000000000000000000000000000000000000;;	func newWatch(request *Request, eventChannel *EventChannel) *watch {
0000000000000000000000000000000000000000;;		return &watch{
0000000000000000000000000000000000000000;;			request:      request,
0000000000000000000000000000000000000000;;			eventChannel: eventChannel,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *EventChannel) GetChannel() chan *info.Event {
0000000000000000000000000000000000000000;;		return self.channel
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *EventChannel) GetWatchId() int {
0000000000000000000000000000000000000000;;		return self.watchId
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// sorts and returns up to the last MaxEventsReturned chronological elements
0000000000000000000000000000000000000000;;	func getMaxEventsReturned(request *Request, eSlice []*info.Event) []*info.Event {
0000000000000000000000000000000000000000;;		sort.Sort(byTimestamp(eSlice))
0000000000000000000000000000000000000000;;		n := request.MaxEventsReturned
0000000000000000000000000000000000000000;;		if n >= len(eSlice) || n <= 0 {
0000000000000000000000000000000000000000;;			return eSlice
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return eSlice[len(eSlice)-n:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If the request wants all subcontainers, this returns if the request's
0000000000000000000000000000000000000000;;	// container path is a prefix of the event container path.  Otherwise,
0000000000000000000000000000000000000000;;	// it checks that the container paths of the event and request are
0000000000000000000000000000000000000000;;	// equivalent
0000000000000000000000000000000000000000;;	func checkIfIsSubcontainer(request *Request, event *info.Event) bool {
0000000000000000000000000000000000000000;;		if request.IncludeSubcontainers == true {
0000000000000000000000000000000000000000;;			return request.ContainerName == "/" || strings.HasPrefix(event.ContainerName+"/", request.ContainerName+"/")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return event.ContainerName == request.ContainerName
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// determines if an event occurs within the time set in the request object and is the right type
0000000000000000000000000000000000000000;;	func checkIfEventSatisfiesRequest(request *Request, event *info.Event) bool {
0000000000000000000000000000000000000000;;		startTime := request.StartTime
0000000000000000000000000000000000000000;;		endTime := request.EndTime
0000000000000000000000000000000000000000;;		eventTime := event.Timestamp
0000000000000000000000000000000000000000;;		if !startTime.IsZero() {
0000000000000000000000000000000000000000;;			if startTime.After(eventTime) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !endTime.IsZero() {
0000000000000000000000000000000000000000;;			if endTime.Before(eventTime) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !request.EventType[event.EventType] {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if request.ContainerName != "" {
0000000000000000000000000000000000000000;;			return checkIfIsSubcontainer(request, event)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// method of Events object that screens Event objects found in the eventStore
0000000000000000000000000000000000000000;;	// attribute and if they fit the parameters passed by the Request object,
0000000000000000000000000000000000000000;;	// adds it to a slice of *Event objects that is returned. If both MaxEventsReturned
0000000000000000000000000000000000000000;;	// and StartTime/EndTime are specified in the request object, then only
0000000000000000000000000000000000000000;;	// up to the most recent MaxEventsReturned events in that time range are returned.
0000000000000000000000000000000000000000;;	func (self *events) GetEvents(request *Request) ([]*info.Event, error) {
0000000000000000000000000000000000000000;;		returnEventList := []*info.Event{}
0000000000000000000000000000000000000000;;		self.eventsLock.RLock()
0000000000000000000000000000000000000000;;		defer self.eventsLock.RUnlock()
0000000000000000000000000000000000000000;;		for eventType, fetch := range request.EventType {
0000000000000000000000000000000000000000;;			if !fetch {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			evs, ok := self.eventStore[eventType]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			res := evs.InTimeRange(request.StartTime, request.EndTime, request.MaxEventsReturned)
0000000000000000000000000000000000000000;;			for _, in := range res {
0000000000000000000000000000000000000000;;				e := in.(*info.Event)
0000000000000000000000000000000000000000;;				if checkIfEventSatisfiesRequest(request, e) {
0000000000000000000000000000000000000000;;					returnEventList = append(returnEventList, e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		returnEventList = getMaxEventsReturned(request, returnEventList)
0000000000000000000000000000000000000000;;		return returnEventList, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// method of Events object that maintains an *Event channel passed by the user.
0000000000000000000000000000000000000000;;	// When an event is added by AddEvents that satisfies the parameters in the passed
0000000000000000000000000000000000000000;;	// Request object it is fed to the channel. The StartTime and EndTime of the watch
0000000000000000000000000000000000000000;;	// request should be uninitialized because the purpose is to watch indefinitely
0000000000000000000000000000000000000000;;	// for events that will happen in the future
0000000000000000000000000000000000000000;;	func (self *events) WatchEvents(request *Request) (*EventChannel, error) {
0000000000000000000000000000000000000000;;		if !request.StartTime.IsZero() || !request.EndTime.IsZero() {
0000000000000000000000000000000000000000;;			return nil, errors.New(
0000000000000000000000000000000000000000;;				"for a call to watch, request.StartTime and request.EndTime must be uninitialized")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self.watcherLock.Lock()
0000000000000000000000000000000000000000;;		defer self.watcherLock.Unlock()
0000000000000000000000000000000000000000;;		new_id := self.lastId + 1
0000000000000000000000000000000000000000;;		returnEventChannel := NewEventChannel(new_id)
0000000000000000000000000000000000000000;;		newWatcher := newWatch(request, returnEventChannel)
0000000000000000000000000000000000000000;;		self.watchers[new_id] = newWatcher
0000000000000000000000000000000000000000;;		self.lastId = new_id
0000000000000000000000000000000000000000;;		return returnEventChannel, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper function to update the event manager's eventStore
0000000000000000000000000000000000000000;;	func (self *events) updateEventStore(e *info.Event) {
0000000000000000000000000000000000000000;;		self.eventsLock.Lock()
0000000000000000000000000000000000000000;;		defer self.eventsLock.Unlock()
0000000000000000000000000000000000000000;;		if _, ok := self.eventStore[e.EventType]; !ok {
0000000000000000000000000000000000000000;;			maxNumEvents := self.storagePolicy.DefaultMaxNumEvents
0000000000000000000000000000000000000000;;			if numEvents, ok := self.storagePolicy.PerTypeMaxNumEvents[e.EventType]; ok {
0000000000000000000000000000000000000000;;				maxNumEvents = numEvents
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if maxNumEvents == 0 {
0000000000000000000000000000000000000000;;				// Event storage is disabled for e.EventType
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			maxAge := self.storagePolicy.DefaultMaxAge
0000000000000000000000000000000000000000;;			if age, ok := self.storagePolicy.PerTypeMaxAge[e.EventType]; ok {
0000000000000000000000000000000000000000;;				maxAge = age
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			self.eventStore[e.EventType] = utils.NewTimedStore(maxAge, maxNumEvents)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self.eventStore[e.EventType].Add(e.Timestamp, e)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *events) findValidWatchers(e *info.Event) []*watch {
0000000000000000000000000000000000000000;;		watchesToSend := make([]*watch, 0)
0000000000000000000000000000000000000000;;		for _, watcher := range self.watchers {
0000000000000000000000000000000000000000;;			watchRequest := watcher.request
0000000000000000000000000000000000000000;;			if checkIfEventSatisfiesRequest(watchRequest, e) {
0000000000000000000000000000000000000000;;				watchesToSend = append(watchesToSend, watcher)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return watchesToSend
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// method of Events object that adds the argument Event object to the
0000000000000000000000000000000000000000;;	// eventStore. It also feeds the event to a set of watch channels
0000000000000000000000000000000000000000;;	// held by the manager if it satisfies the request keys of the channels
0000000000000000000000000000000000000000;;	func (self *events) AddEvent(e *info.Event) error {
0000000000000000000000000000000000000000;;		self.updateEventStore(e)
0000000000000000000000000000000000000000;;		self.watcherLock.RLock()
0000000000000000000000000000000000000000;;		defer self.watcherLock.RUnlock()
0000000000000000000000000000000000000000;;		watchesToSend := self.findValidWatchers(e)
0000000000000000000000000000000000000000;;		for _, watchObject := range watchesToSend {
0000000000000000000000000000000000000000;;			watchObject.eventChannel.GetChannel() <- e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(4).Infof("Added event %v", e)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes a watch instance from the EventManager's watchers map
0000000000000000000000000000000000000000;;	func (self *events) StopWatch(watchId int) {
0000000000000000000000000000000000000000;;		self.watcherLock.Lock()
0000000000000000000000000000000000000000;;		defer self.watcherLock.Unlock()
0000000000000000000000000000000000000000;;		_, ok := self.watchers[watchId]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			glog.Errorf("Could not find watcher instance %v", watchId)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(self.watchers[watchId].eventChannel.GetChannel())
0000000000000000000000000000000000000000;;		delete(self.watchers, watchId)
0000000000000000000000000000000000000000;;	}
