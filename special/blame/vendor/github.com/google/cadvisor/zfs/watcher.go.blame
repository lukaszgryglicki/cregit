0000000000000000000000000000000000000000;;	// Copyright 2016 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
0000000000000000000000000000000000000000;;	package zfs
9535767824eb08341029c43083357745711d0ed9;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		zfs "github.com/mistifyio/go-zfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// zfsWatcher maintains a cache of filesystem -> usage stats for a
0000000000000000000000000000000000000000;;	// zfs filesystem
0000000000000000000000000000000000000000;;	type ZfsWatcher struct {
0000000000000000000000000000000000000000;;		filesystem string
0000000000000000000000000000000000000000;;		lock       *sync.RWMutex
0000000000000000000000000000000000000000;;		cache      map[string]uint64
0000000000000000000000000000000000000000;;		period     time.Duration
0000000000000000000000000000000000000000;;		stopChan   chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewThinPoolWatcher returns a new ThinPoolWatcher for the given devicemapper
0000000000000000000000000000000000000000;;	// thin pool name and metadata device or an error.
0000000000000000000000000000000000000000;;	func NewZfsWatcher(filesystem string) (*ZfsWatcher, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ZfsWatcher{
0000000000000000000000000000000000000000;;			filesystem: filesystem,
0000000000000000000000000000000000000000;;			lock:       &sync.RWMutex{},
0000000000000000000000000000000000000000;;			cache:      make(map[string]uint64),
0000000000000000000000000000000000000000;;			period:     15 * time.Second,
0000000000000000000000000000000000000000;;			stopChan:   make(chan struct{}),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start starts the ZfsWatcher.
0000000000000000000000000000000000000000;;	func (w *ZfsWatcher) Start() {
0000000000000000000000000000000000000000;;		err := w.Refresh()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("encountered error refreshing zfs watcher: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-w.stopChan:
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			case <-time.After(w.period):
0000000000000000000000000000000000000000;;				start := time.Now()
0000000000000000000000000000000000000000;;				err = w.Refresh()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("encountered error refreshing zfs watcher: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// print latency for refresh
0000000000000000000000000000000000000000;;				duration := time.Since(start)
0000000000000000000000000000000000000000;;				glog.V(5).Infof("zfs(%d) took %s", start.Unix(), duration)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stop stops the ZfsWatcher.
0000000000000000000000000000000000000000;;	func (w *ZfsWatcher) Stop() {
0000000000000000000000000000000000000000;;		close(w.stopChan)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetUsage gets the cached usage value of the given filesystem.
0000000000000000000000000000000000000000;;	func (w *ZfsWatcher) GetUsage(filesystem string) (uint64, error) {
0000000000000000000000000000000000000000;;		w.lock.RLock()
0000000000000000000000000000000000000000;;		defer w.lock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v, ok := w.cache[filesystem]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("no cached value for usage of filesystem %v", filesystem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Refresh performs a zfs get
0000000000000000000000000000000000000000;;	func (w *ZfsWatcher) Refresh() error {
0000000000000000000000000000000000000000;;		w.lock.Lock()
0000000000000000000000000000000000000000;;		defer w.lock.Unlock()
0000000000000000000000000000000000000000;;		newCache := make(map[string]uint64)
0000000000000000000000000000000000000000;;		parent, err := zfs.GetDataset(w.filesystem)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("encountered error getting zfs filesystem: %s: %v", w.filesystem, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		children, err := parent.Children(0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("encountered error getting children of zfs filesystem: %s: %v", w.filesystem, err)
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ds := range children {
0000000000000000000000000000000000000000;;			newCache[ds.Name] = ds.Used
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.cache = newCache
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
