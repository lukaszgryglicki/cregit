0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
ddb91896b60df07452d87846c6343678b1c48dde;Godeps/_workspace/src/github.com/google/cadvisor/validate/validate.go[Godeps/_workspace/src/github.com/google/cadvisor/validate/validate.go][vendor/github.com/google/cadvisor/validate/validate.go];	
0000000000000000000000000000000000000000;;	// Handler for /validate content.
0000000000000000000000000000000000000000;;	// Validates cadvisor dependencies - kernel, os, docker setup.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/docker"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ValidatePage  = "/validate/"
0000000000000000000000000000000000000000;;		Supported     = "[Supported, but not recommended]"
0000000000000000000000000000000000000000;;		Unsupported   = "[Unsupported]"
0000000000000000000000000000000000000000;;		Recommended   = "[Supported and recommended]"
0000000000000000000000000000000000000000;;		Unknown       = "[Unknown]"
0000000000000000000000000000000000000000;;		VersionFormat = "%d.%d%s"
0000000000000000000000000000000000000000;;		OutputFormat  = "%s: %s\n\t%s\n\n"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getMajorMinor(version string) (int, int, error) {
0000000000000000000000000000000000000000;;		var major, minor int
0000000000000000000000000000000000000000;;		var ign string
0000000000000000000000000000000000000000;;		n, err := fmt.Sscanf(version, VersionFormat, &major, &minor, &ign)
0000000000000000000000000000000000000000;;		if n != 3 || err != nil {
0000000000000000000000000000000000000000;;			log.Printf("Failed to parse version for %s", version)
0000000000000000000000000000000000000000;;			return -1, -1, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return major, minor, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateKernelVersion(version string) (string, string) {
0000000000000000000000000000000000000000;;		desc := fmt.Sprintf("Kernel version is %s. Versions >= 2.6 are supported. 3.0+ are recommended.\n", version)
0000000000000000000000000000000000000000;;		major, minor, err := getMajorMinor(version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			desc = fmt.Sprintf("Could not parse kernel version. %s", desc)
0000000000000000000000000000000000000000;;			return Unknown, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if major < 2 {
0000000000000000000000000000000000000000;;			return Unsupported, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if major == 2 && minor < 6 {
0000000000000000000000000000000000000000;;			return Unsupported, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if major >= 3 {
0000000000000000000000000000000000000000;;			return Recommended, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Supported, desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateDockerVersion(version string) (string, string) {
0000000000000000000000000000000000000000;;		desc := fmt.Sprintf("Docker version is %s. Versions >= 1.0 are supported. 1.2+ are recommended.\n", version)
0000000000000000000000000000000000000000;;		major, minor, err := getMajorMinor(version)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			desc = fmt.Sprintf("Could not parse docker version. %s\n\t", desc)
0000000000000000000000000000000000000000;;			return Unknown, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if major < 1 {
0000000000000000000000000000000000000000;;			return Unsupported, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if major == 1 && minor < 2 {
0000000000000000000000000000000000000000;;			return Supported, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Recommended, desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getEnabledCgroups() (map[string]int, error) {
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile("/proc/cgroups")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cgroups := make(map[string]int)
0000000000000000000000000000000000000000;;		for i, line := range strings.Split(string(out), "\n") {
0000000000000000000000000000000000000000;;			var cgroup string
0000000000000000000000000000000000000000;;			var ign, enabled int
0000000000000000000000000000000000000000;;			if i == 0 || line == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, err := fmt.Sscanf(line, "%s %d %d %d", &cgroup, &ign, &ign, &enabled)
0000000000000000000000000000000000000000;;			if n != 4 || err != nil {
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					err = fmt.Errorf("failed to parse /proc/cgroup entry %s", line)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			cgroups[cgroup] = enabled
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cgroups, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func areCgroupsPresent(available map[string]int, desired []string) (bool, string) {
0000000000000000000000000000000000000000;;		for _, cgroup := range desired {
0000000000000000000000000000000000000000;;			enabled, ok := available[cgroup]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				reason := fmt.Sprintf("Missing cgroup %s. Available cgroups: %v\n", cgroup, available)
0000000000000000000000000000000000000000;;				return false, reason
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if enabled != 1 {
0000000000000000000000000000000000000000;;				reason := fmt.Sprintf("Cgroup %s not enabled. Available cgroups: %v\n", cgroup, available)
0000000000000000000000000000000000000000;;				return false, reason
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateMemoryAccounting(available_cgroups map[string]int) string {
0000000000000000000000000000000000000000;;		ok, _ := areCgroupsPresent(available_cgroups, []string{"memory"})
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "\tHierarchical memory accounting status unknown: memory cgroup not enabled.\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mnt, err := cgroups.FindCgroupMountpoint("memory")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "\tHierarchical memory accounting status unknown: memory cgroup not mounted.\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hier, err := ioutil.ReadFile(path.Join(mnt, "memory.use_hierarchy"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "\tHierarchical memory accounting status unknown: hierarchy interface unavailable.\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var enabled int
0000000000000000000000000000000000000000;;		n, err := fmt.Sscanf(string(hier), "%d", &enabled)
0000000000000000000000000000000000000000;;		if err != nil || n != 1 {
0000000000000000000000000000000000000000;;			return "\tHierarchical memory accounting status unknown: hierarchy interface unreadable.\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if enabled == 1 {
0000000000000000000000000000000000000000;;			return "\tHierarchical memory accounting enabled. Reported memory usage includes memory used by child containers.\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "\tHierarchical memory accounting disabled. Memory usage does not include usage from child containers.\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateCgroups() (string, string) {
0000000000000000000000000000000000000000;;		required_cgroups := []string{"cpu", "cpuacct"}
0000000000000000000000000000000000000000;;		recommended_cgroups := []string{"memory", "blkio", "cpuset", "devices", "freezer"}
0000000000000000000000000000000000000000;;		available_cgroups, err := getEnabledCgroups()
0000000000000000000000000000000000000000;;		desc := fmt.Sprintf("\tFollowing cgroups are required: %v\n\tFollowing other cgroups are recommended: %v\n", required_cgroups, recommended_cgroups)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			desc = fmt.Sprintf("Could not parse /proc/cgroups.\n%s", desc)
0000000000000000000000000000000000000000;;			return Unknown, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok, out := areCgroupsPresent(available_cgroups, required_cgroups)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			out += desc
0000000000000000000000000000000000000000;;			return Unsupported, out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok, out = areCgroupsPresent(available_cgroups, recommended_cgroups)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// supported, but not recommended.
0000000000000000000000000000000000000000;;			out += desc
0000000000000000000000000000000000000000;;			return Supported, out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out = fmt.Sprintf("Available cgroups: %v\n", available_cgroups)
0000000000000000000000000000000000000000;;		out += desc
0000000000000000000000000000000000000000;;		out += validateMemoryAccounting(available_cgroups)
0000000000000000000000000000000000000000;;		return Recommended, out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateDockerInfo() (string, string) {
0000000000000000000000000000000000000000;;		info, err := docker.ValidateInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Unsupported, fmt.Sprintf("Docker setup is invalid: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		desc := fmt.Sprintf("Docker exec driver is %s. Storage driver is %s.\n", info.ExecutionDriver, info.Driver)
0000000000000000000000000000000000000000;;		return Recommended, desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateCgroupMounts() (string, string) {
0000000000000000000000000000000000000000;;		const recommendedMount = "/sys/fs/cgroup"
0000000000000000000000000000000000000000;;		desc := fmt.Sprintf("\tAny cgroup mount point that is detectible and accessible is supported. %s is recommended as a standard location.\n", recommendedMount)
0000000000000000000000000000000000000000;;		mnt, err := cgroups.FindCgroupMountpoint("cpu")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			out := "Could not locate cgroup mount point.\n"
0000000000000000000000000000000000000000;;			out += desc
0000000000000000000000000000000000000000;;			return Unknown, out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mnt = path.Dir(mnt)
0000000000000000000000000000000000000000;;		if !utils.FileExists(mnt) {
0000000000000000000000000000000000000000;;			out := fmt.Sprintf("Cgroup mount directory %s inaccessible.\n", mnt)
0000000000000000000000000000000000000000;;			out += desc
0000000000000000000000000000000000000000;;			return Unsupported, out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mounts, err := ioutil.ReadDir(mnt)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			out := fmt.Sprintf("Could not read cgroup mount directory %s.\n", mnt)
0000000000000000000000000000000000000000;;			out += desc
0000000000000000000000000000000000000000;;			return Unsupported, out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mountNames := "\tCgroup mount directories: "
0000000000000000000000000000000000000000;;		for _, mount := range mounts {
0000000000000000000000000000000000000000;;			mountNames += mount.Name() + " "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mountNames += "\n"
0000000000000000000000000000000000000000;;		out := fmt.Sprintf("Cgroups are mounted at %s.\n", mnt)
0000000000000000000000000000000000000000;;		out += mountNames
0000000000000000000000000000000000000000;;		out += desc
0000000000000000000000000000000000000000;;		info, err := ioutil.ReadFile("/proc/mounts")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			out := fmt.Sprintf("Could not read /proc/mounts.\n")
0000000000000000000000000000000000000000;;			out += desc
0000000000000000000000000000000000000000;;			return Unsupported, out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out += "\tCgroup mounts:\n"
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(string(info), "\n") {
0000000000000000000000000000000000000000;;			if strings.Contains(line, " cgroup ") {
0000000000000000000000000000000000000000;;				out += "\t" + line + "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if mnt == recommendedMount {
0000000000000000000000000000000000000000;;			return Recommended, out
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Supported, out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func validateIoScheduler(containerManager manager.Manager) (string, string) {
0000000000000000000000000000000000000000;;		var desc string
0000000000000000000000000000000000000000;;		mi, err := containerManager.GetMachineInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Unknown, "Machine info not available\n\t"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cfq := false
0000000000000000000000000000000000000000;;		for _, disk := range mi.DiskMap {
0000000000000000000000000000000000000000;;			desc += fmt.Sprintf("\t Disk %q Scheduler type %q.\n", disk.Name, disk.Scheduler)
0000000000000000000000000000000000000000;;			if disk.Scheduler == "cfq" {
0000000000000000000000000000000000000000;;				cfq = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Since we get lot of random block devices, report recommended if
0000000000000000000000000000000000000000;;		// at least one of them is on cfq. Report Supported otherwise.
0000000000000000000000000000000000000000;;		if cfq {
0000000000000000000000000000000000000000;;			desc = "At least one device supports 'cfq' I/O scheduler. Some disk stats can be reported.\n" + desc
0000000000000000000000000000000000000000;;			return Recommended, desc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		desc = "None of the devices support 'cfq' I/O scheduler. No disk stats can be reported.\n" + desc
0000000000000000000000000000000000000000;;		return Supported, desc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func HandleRequest(w http.ResponseWriter, containerManager manager.Manager) error {
0000000000000000000000000000000000000000;;		// Get cAdvisor version Info.
0000000000000000000000000000000000000000;;		versionInfo, err := containerManager.GetVersionInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := fmt.Sprintf("cAdvisor version: %s\n\n", versionInfo.CadvisorVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No OS is preferred or unsupported as of now.
0000000000000000000000000000000000000000;;		out += fmt.Sprintf("OS version: %s\n\n", versionInfo.ContainerOsVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kernelValidation, desc := validateKernelVersion(versionInfo.KernelVersion)
0000000000000000000000000000000000000000;;		out += fmt.Sprintf(OutputFormat, "Kernel version", kernelValidation, desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupValidation, desc := validateCgroups()
0000000000000000000000000000000000000000;;		out += fmt.Sprintf(OutputFormat, "Cgroup setup", cgroupValidation, desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mountsValidation, desc := validateCgroupMounts()
0000000000000000000000000000000000000000;;		out += fmt.Sprintf(OutputFormat, "Cgroup mount setup", mountsValidation, desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerValidation, desc := validateDockerVersion(versionInfo.DockerVersion)
0000000000000000000000000000000000000000;;		out += fmt.Sprintf(OutputFormat, "Docker version", dockerValidation, desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerInfoValidation, desc := validateDockerInfo()
0000000000000000000000000000000000000000;;		out += fmt.Sprintf(OutputFormat, "Docker driver setup", dockerInfoValidation, desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ioSchedulerValidation, desc := validateIoScheduler(containerManager)
0000000000000000000000000000000000000000;;		out += fmt.Sprintf(OutputFormat, "Block device setup", ioSchedulerValidation, desc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Output debug info.
0000000000000000000000000000000000000000;;		debugInfo := containerManager.DebugInfo()
0000000000000000000000000000000000000000;;		for category, lines := range debugInfo {
0000000000000000000000000000000000000000;;			out += fmt.Sprintf(OutputFormat, category, "", strings.Join(lines, "\n\t"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, err = w.Write([]byte(out))
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
