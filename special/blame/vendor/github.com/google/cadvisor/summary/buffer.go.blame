0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/summary/buffer.go[Godeps/_workspace/src/github.com/google/cadvisor/summary/buffer.go][vendor/github.com/google/cadvisor/summary/buffer.go];	
0000000000000000000000000000000000000000;;	package summary
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Manages a buffer of usage samples.
0000000000000000000000000000000000000000;;	// This is similar to stats buffer in cache/memory.
0000000000000000000000000000000000000000;;	// The main difference is that we do not pre-allocate the buffer as most containers
0000000000000000000000000000000000000000;;	// won't live that long.
0000000000000000000000000000000000000000;;	type SamplesBuffer struct {
0000000000000000000000000000000000000000;;		// list of collected samples.
0000000000000000000000000000000000000000;;		samples []info.Usage
0000000000000000000000000000000000000000;;		// maximum size this buffer can grow to.
0000000000000000000000000000000000000000;;		maxSize int
0000000000000000000000000000000000000000;;		// index for the latest sample.
0000000000000000000000000000000000000000;;		index int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Initializes an empty buffer.
0000000000000000000000000000000000000000;;	func NewSamplesBuffer(size int) *SamplesBuffer {
0000000000000000000000000000000000000000;;		return &SamplesBuffer{
0000000000000000000000000000000000000000;;			index:   -1,
0000000000000000000000000000000000000000;;			maxSize: size,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the current number of samples in the buffer.
0000000000000000000000000000000000000000;;	func (s *SamplesBuffer) Size() int {
0000000000000000000000000000000000000000;;		return len(s.samples)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add an element to the buffer. Oldest one is overwritten if required.
0000000000000000000000000000000000000000;;	func (s *SamplesBuffer) Add(stat info.Usage) {
0000000000000000000000000000000000000000;;		if len(s.samples) < s.maxSize {
0000000000000000000000000000000000000000;;			s.samples = append(s.samples, stat)
0000000000000000000000000000000000000000;;			s.index++
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.index = (s.index + 1) % s.maxSize
0000000000000000000000000000000000000000;;		s.samples[s.index] = stat
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns pointers to the last 'n' stats.
0000000000000000000000000000000000000000;;	func (s *SamplesBuffer) RecentStats(n int) []*info.Usage {
0000000000000000000000000000000000000000;;		if n > len(s.samples) {
0000000000000000000000000000000000000000;;			n = len(s.samples)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start := s.index - (n - 1)
0000000000000000000000000000000000000000;;		if start < 0 {
0000000000000000000000000000000000000000;;			start += len(s.samples)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := make([]*info.Usage, n)
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			index := (start + i) % len(s.samples)
0000000000000000000000000000000000000000;;			out[i] = &s.samples[index]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
