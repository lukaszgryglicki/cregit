0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/summary/percentiles.go[Godeps/_workspace/src/github.com/google/cadvisor/summary/percentiles.go][vendor/github.com/google/cadvisor/summary/percentiles.go];	
0000000000000000000000000000000000000000;;	// Utility methods to calculate percentiles.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package summary
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const secondsToMilliSeconds = 1000
0000000000000000000000000000000000000000;;	const milliSecondsToNanoSeconds = 1000000
0000000000000000000000000000000000000000;;	const secondsToNanoSeconds = secondsToMilliSeconds * milliSecondsToNanoSeconds
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Uint64Slice []uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a Uint64Slice) Len() int           { return len(a) }
0000000000000000000000000000000000000000;;	func (a Uint64Slice) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
0000000000000000000000000000000000000000;;	func (a Uint64Slice) Less(i, j int) bool { return a[i] < a[j] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get percentile of the provided samples. Round to integer.
0000000000000000000000000000000000000000;;	func (self Uint64Slice) GetPercentile(d float64) uint64 {
0000000000000000000000000000000000000000;;		if d < 0.0 || d > 1.0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		count := self.Len()
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(self)
0000000000000000000000000000000000000000;;		n := float64(d * (float64(count) + 1))
0000000000000000000000000000000000000000;;		idx, frac := math.Modf(n)
0000000000000000000000000000000000000000;;		index := int(idx)
0000000000000000000000000000000000000000;;		percentile := float64(self[index-1])
0000000000000000000000000000000000000000;;		if index > 1 && index < count {
0000000000000000000000000000000000000000;;			percentile += frac * float64(self[index]-self[index-1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint64(percentile)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type mean struct {
0000000000000000000000000000000000000000;;		// current count.
0000000000000000000000000000000000000000;;		count uint64
0000000000000000000000000000000000000000;;		// current mean.
0000000000000000000000000000000000000000;;		Mean float64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *mean) Add(value uint64) {
0000000000000000000000000000000000000000;;		self.count++
0000000000000000000000000000000000000000;;		if self.count == 1 {
0000000000000000000000000000000000000000;;			self.Mean = float64(value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := float64(self.count)
0000000000000000000000000000000000000000;;		v := float64(value)
0000000000000000000000000000000000000000;;		self.Mean = (self.Mean*(c-1) + v) / c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type resource struct {
0000000000000000000000000000000000000000;;		// list of samples being tracked.
0000000000000000000000000000000000000000;;		samples Uint64Slice
0000000000000000000000000000000000000000;;		// average from existing samples.
0000000000000000000000000000000000000000;;		mean mean
0000000000000000000000000000000000000000;;		// maximum value seen so far in the added samples.
0000000000000000000000000000000000000000;;		max uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds a new percentile sample.
0000000000000000000000000000000000000000;;	func (self *resource) Add(p info.Percentiles) {
0000000000000000000000000000000000000000;;		if !p.Present {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.Max > self.max {
0000000000000000000000000000000000000000;;			self.max = p.Max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self.mean.Add(p.Mean)
0000000000000000000000000000000000000000;;		// Selecting 90p of 90p :(
0000000000000000000000000000000000000000;;		self.samples = append(self.samples, p.Ninety)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add a single sample. Internally, we convert it to a fake percentile sample.
0000000000000000000000000000000000000000;;	func (self *resource) AddSample(val uint64) {
0000000000000000000000000000000000000000;;		sample := info.Percentiles{
0000000000000000000000000000000000000000;;			Present:    true,
0000000000000000000000000000000000000000;;			Mean:       val,
0000000000000000000000000000000000000000;;			Max:        val,
0000000000000000000000000000000000000000;;			Fifty:      val,
0000000000000000000000000000000000000000;;			Ninety:     val,
0000000000000000000000000000000000000000;;			NinetyFive: val,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self.Add(sample)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get max, average, and 90p from existing samples.
0000000000000000000000000000000000000000;;	func (self *resource) GetAllPercentiles() info.Percentiles {
0000000000000000000000000000000000000000;;		p := info.Percentiles{}
0000000000000000000000000000000000000000;;		p.Mean = uint64(self.mean.Mean)
0000000000000000000000000000000000000000;;		p.Max = self.max
0000000000000000000000000000000000000000;;		p.Fifty = self.samples.GetPercentile(0.5)
0000000000000000000000000000000000000000;;		p.Ninety = self.samples.GetPercentile(0.9)
0000000000000000000000000000000000000000;;		p.NinetyFive = self.samples.GetPercentile(0.95)
0000000000000000000000000000000000000000;;		p.Present = true
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewResource(size int) *resource {
0000000000000000000000000000000000000000;;		return &resource{
0000000000000000000000000000000000000000;;			samples: make(Uint64Slice, 0, size),
0000000000000000000000000000000000000000;;			mean:    mean{count: 0, Mean: 0},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return aggregated percentiles from the provided percentile samples.
0000000000000000000000000000000000000000;;	func GetDerivedPercentiles(stats []*info.Usage) info.Usage {
0000000000000000000000000000000000000000;;		cpu := NewResource(len(stats))
0000000000000000000000000000000000000000;;		memory := NewResource(len(stats))
0000000000000000000000000000000000000000;;		for _, stat := range stats {
0000000000000000000000000000000000000000;;			cpu.Add(stat.Cpu)
0000000000000000000000000000000000000000;;			memory.Add(stat.Memory)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		usage := info.Usage{}
0000000000000000000000000000000000000000;;		usage.Cpu = cpu.GetAllPercentiles()
0000000000000000000000000000000000000000;;		usage.Memory = memory.GetAllPercentiles()
0000000000000000000000000000000000000000;;		return usage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calculate part of a minute this sample set represent.
0000000000000000000000000000000000000000;;	func getPercentComplete(stats []*secondSample) (percent int32) {
0000000000000000000000000000000000000000;;		numSamples := len(stats)
0000000000000000000000000000000000000000;;		if numSamples > 1 {
0000000000000000000000000000000000000000;;			percent = 100
0000000000000000000000000000000000000000;;			timeRange := stats[numSamples-1].Timestamp.Sub(stats[0].Timestamp).Nanoseconds()
0000000000000000000000000000000000000000;;			// allow some slack
0000000000000000000000000000000000000000;;			if timeRange < 58*secondsToNanoSeconds {
0000000000000000000000000000000000000000;;				percent = int32((timeRange * 100) / 60 * secondsToNanoSeconds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calculate cpurate from two consecutive total cpu usage samples.
0000000000000000000000000000000000000000;;	func getCpuRate(latest, previous secondSample) (uint64, error) {
0000000000000000000000000000000000000000;;		var elapsed int64
0000000000000000000000000000000000000000;;		elapsed = latest.Timestamp.Sub(previous.Timestamp).Nanoseconds()
0000000000000000000000000000000000000000;;		if elapsed < 10*milliSecondsToNanoSeconds {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("elapsed time too small: %d ns: time now %s last %s", elapsed, latest.Timestamp.String(), previous.Timestamp.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if latest.Cpu < previous.Cpu {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("bad sample: cumulative cpu usage dropped from %d to %d", latest.Cpu, previous.Cpu)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Cpurate is calculated in cpu-milliseconds per second.
0000000000000000000000000000000000000000;;		cpuRate := (latest.Cpu - previous.Cpu) * secondsToMilliSeconds / uint64(elapsed)
0000000000000000000000000000000000000000;;		return cpuRate, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a percentile sample for a minute by aggregating seconds samples.
0000000000000000000000000000000000000000;;	func GetMinutePercentiles(stats []*secondSample) info.Usage {
0000000000000000000000000000000000000000;;		lastSample := secondSample{}
0000000000000000000000000000000000000000;;		cpu := NewResource(len(stats))
0000000000000000000000000000000000000000;;		memory := NewResource(len(stats))
0000000000000000000000000000000000000000;;		for _, stat := range stats {
0000000000000000000000000000000000000000;;			if !lastSample.Timestamp.IsZero() {
0000000000000000000000000000000000000000;;				cpuRate, err := getCpuRate(*stat, lastSample)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cpu.AddSample(cpuRate)
0000000000000000000000000000000000000000;;				memory.AddSample(stat.Memory)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				memory.AddSample(stat.Memory)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastSample = *stat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		percent := getPercentComplete(stats)
0000000000000000000000000000000000000000;;		return info.Usage{
0000000000000000000000000000000000000000;;			PercentComplete: percent,
0000000000000000000000000000000000000000;;			Cpu:             cpu.GetAllPercentiles(),
0000000000000000000000000000000000000000;;			Memory:          memory.GetAllPercentiles(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
