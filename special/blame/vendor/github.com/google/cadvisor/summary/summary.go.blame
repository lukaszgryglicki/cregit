0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/summary/summary.go[Godeps/_workspace/src/github.com/google/cadvisor/summary/summary.go][vendor/github.com/google/cadvisor/summary/summary.go];	
0000000000000000000000000000000000000000;;	// Maintains the summary of aggregated minute, hour, and day stats.
0000000000000000000000000000000000000000;;	// For a container running for more than a day, amount of tracked data can go up to
0000000000000000000000000000000000000000;;	// 40 KB when cpu and memory are tracked. We'll start by enabling collection for the
0000000000000000000000000000000000000000;;	// node, followed by docker, and then all containers as we understand the usage pattern
0000000000000000000000000000000000000000;;	// better
0000000000000000000000000000000000000000;;	// TODO(rjnagal): Optimize the size if we start running it for every container.
0000000000000000000000000000000000000000;;	package summary
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usage fields we track for generating percentiles.
0000000000000000000000000000000000000000;;	type secondSample struct {
0000000000000000000000000000000000000000;;		Timestamp time.Time // time when the sample was recorded.
0000000000000000000000000000000000000000;;		Cpu       uint64    // cpu usage
0000000000000000000000000000000000000000;;		Memory    uint64    // memory usage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type availableResources struct {
0000000000000000000000000000000000000000;;		Cpu    bool
0000000000000000000000000000000000000000;;		Memory bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatsSummary struct {
0000000000000000000000000000000000000000;;		// Resources being tracked for this container.
0000000000000000000000000000000000000000;;		available availableResources
0000000000000000000000000000000000000000;;		// list of second samples. The list is cleared when a new minute samples is generated.
0000000000000000000000000000000000000000;;		secondSamples []*secondSample
0000000000000000000000000000000000000000;;		// minute percentiles. We track 24 * 60 maximum samples.
0000000000000000000000000000000000000000;;		minuteSamples *SamplesBuffer
0000000000000000000000000000000000000000;;		// latest derived instant, minute, hour, and day stats. Instant sample updated every second.
0000000000000000000000000000000000000000;;		// Others updated every minute.
0000000000000000000000000000000000000000;;		derivedStats info.DerivedStats // Guarded by dataLock.
0000000000000000000000000000000000000000;;		dataLock     sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds a new seconds sample.
0000000000000000000000000000000000000000;;	// If enough seconds samples are collected, a minute sample is generated and derived
0000000000000000000000000000000000000000;;	// stats are updated.
0000000000000000000000000000000000000000;;	func (s *StatsSummary) AddSample(stat v1.ContainerStats) error {
0000000000000000000000000000000000000000;;		sample := secondSample{}
0000000000000000000000000000000000000000;;		sample.Timestamp = stat.Timestamp
0000000000000000000000000000000000000000;;		if s.available.Cpu {
0000000000000000000000000000000000000000;;			sample.Cpu = stat.Cpu.Usage.Total
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.available.Memory {
0000000000000000000000000000000000000000;;			sample.Memory = stat.Memory.WorkingSet
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.secondSamples = append(s.secondSamples, &sample)
0000000000000000000000000000000000000000;;		s.updateLatestUsage()
0000000000000000000000000000000000000000;;		// TODO(jnagal): Use 'available' to avoid unnecessary computation.
0000000000000000000000000000000000000000;;		numSamples := len(s.secondSamples)
0000000000000000000000000000000000000000;;		elapsed := time.Nanosecond
0000000000000000000000000000000000000000;;		if numSamples > 1 {
0000000000000000000000000000000000000000;;			start := s.secondSamples[0].Timestamp
0000000000000000000000000000000000000000;;			end := s.secondSamples[numSamples-1].Timestamp
0000000000000000000000000000000000000000;;			elapsed = end.Sub(start)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if elapsed > 60*time.Second {
0000000000000000000000000000000000000000;;			// Make a minute sample. This works with dynamic housekeeping as long
0000000000000000000000000000000000000000;;			// as we keep max dynamic houskeeping period close to a minute.
0000000000000000000000000000000000000000;;			minuteSample := GetMinutePercentiles(s.secondSamples)
0000000000000000000000000000000000000000;;			// Clear seconds samples. Keep the latest sample for continuity.
0000000000000000000000000000000000000000;;			// Copying and resizing helps avoid slice re-allocation.
0000000000000000000000000000000000000000;;			s.secondSamples[0] = s.secondSamples[numSamples-1]
0000000000000000000000000000000000000000;;			s.secondSamples = s.secondSamples[:1]
0000000000000000000000000000000000000000;;			s.minuteSamples.Add(minuteSample)
0000000000000000000000000000000000000000;;			err := s.updateDerivedStats()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *StatsSummary) updateLatestUsage() {
0000000000000000000000000000000000000000;;		usage := info.InstantUsage{}
0000000000000000000000000000000000000000;;		numStats := len(s.secondSamples)
0000000000000000000000000000000000000000;;		if numStats < 1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		latest := s.secondSamples[numStats-1]
0000000000000000000000000000000000000000;;		usage.Memory = latest.Memory
0000000000000000000000000000000000000000;;		if numStats > 1 {
0000000000000000000000000000000000000000;;			previous := s.secondSamples[numStats-2]
0000000000000000000000000000000000000000;;			cpu, err := getCpuRate(*latest, *previous)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				usage.Cpu = cpu
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.dataLock.Lock()
0000000000000000000000000000000000000000;;		defer s.dataLock.Unlock()
0000000000000000000000000000000000000000;;		s.derivedStats.LatestUsage = usage
0000000000000000000000000000000000000000;;		s.derivedStats.Timestamp = latest.Timestamp
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate new derived stats based on current minute stats samples.
0000000000000000000000000000000000000000;;	func (s *StatsSummary) updateDerivedStats() error {
0000000000000000000000000000000000000000;;		derived := info.DerivedStats{}
0000000000000000000000000000000000000000;;		derived.Timestamp = time.Now()
0000000000000000000000000000000000000000;;		minuteSamples := s.minuteSamples.RecentStats(1)
0000000000000000000000000000000000000000;;		if len(minuteSamples) != 1 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to retrieve minute stats")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		derived.MinuteUsage = *minuteSamples[0]
0000000000000000000000000000000000000000;;		hourUsage, err := s.getDerivedUsage(60)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to compute hour stats: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dayUsage, err := s.getDerivedUsage(60 * 24)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to compute day usage: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		derived.HourUsage = hourUsage
0000000000000000000000000000000000000000;;		derived.DayUsage = dayUsage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.dataLock.Lock()
0000000000000000000000000000000000000000;;		defer s.dataLock.Unlock()
0000000000000000000000000000000000000000;;		derived.LatestUsage = s.derivedStats.LatestUsage
0000000000000000000000000000000000000000;;		s.derivedStats = derived
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper method to get hour and daily derived stats
0000000000000000000000000000000000000000;;	func (s *StatsSummary) getDerivedUsage(n int) (info.Usage, error) {
0000000000000000000000000000000000000000;;		if n < 1 {
0000000000000000000000000000000000000000;;			return info.Usage{}, fmt.Errorf("invalid number of samples requested: %d", n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		samples := s.minuteSamples.RecentStats(n)
0000000000000000000000000000000000000000;;		numSamples := len(samples)
0000000000000000000000000000000000000000;;		if numSamples < 1 {
0000000000000000000000000000000000000000;;			return info.Usage{}, fmt.Errorf("failed to retrieve any minute stats.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// We generate derived stats even with partial data.
0000000000000000000000000000000000000000;;		usage := GetDerivedPercentiles(samples)
0000000000000000000000000000000000000000;;		// Assumes we have equally placed minute samples.
0000000000000000000000000000000000000000;;		usage.PercentComplete = int32(numSamples * 100 / n)
0000000000000000000000000000000000000000;;		return usage, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the latest calculated derived stats.
0000000000000000000000000000000000000000;;	func (s *StatsSummary) DerivedStats() (info.DerivedStats, error) {
0000000000000000000000000000000000000000;;		s.dataLock.RLock()
0000000000000000000000000000000000000000;;		defer s.dataLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.derivedStats, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func New(spec v1.ContainerSpec) (*StatsSummary, error) {
0000000000000000000000000000000000000000;;		summary := StatsSummary{}
0000000000000000000000000000000000000000;;		if spec.HasCpu {
0000000000000000000000000000000000000000;;			summary.available.Cpu = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if spec.HasMemory {
0000000000000000000000000000000000000000;;			summary.available.Memory = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !summary.available.Cpu && !summary.available.Memory {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("none of the resources are being tracked.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		summary.minuteSamples = NewSamplesBuffer(60 /* one hour */)
0000000000000000000000000000000000000000;;		return &summary, nil
0000000000000000000000000000000000000000;;	}
