0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
baeaf2d312f924c834e28f908757163c9de924af;Godeps/_workspace/src/github.com/google/cadvisor/info/v1/container.go[Godeps/_workspace/src/github.com/google/cadvisor/info/v1/container.go][vendor/github.com/google/cadvisor/info/v1/container.go];	
0000000000000000000000000000000000000000;;	package v1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CpuSpec struct {
0000000000000000000000000000000000000000;;		Limit    uint64 `json:"limit"`
0000000000000000000000000000000000000000;;		MaxLimit uint64 `json:"max_limit"`
0000000000000000000000000000000000000000;;		Mask     string `json:"mask,omitempty"`
0000000000000000000000000000000000000000;;		Quota    uint64 `json:"quota,omitempty"`
0000000000000000000000000000000000000000;;		Period   uint64 `json:"period,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MemorySpec struct {
0000000000000000000000000000000000000000;;		// The amount of memory requested. Default is unlimited (-1).
0000000000000000000000000000000000000000;;		// Units: bytes.
0000000000000000000000000000000000000000;;		Limit uint64 `json:"limit,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The amount of guaranteed memory.  Default is 0.
0000000000000000000000000000000000000000;;		// Units: bytes.
0000000000000000000000000000000000000000;;		Reservation uint64 `json:"reservation,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The amount of swap space requested. Default is unlimited (-1).
0000000000000000000000000000000000000000;;		// Units: bytes.
0000000000000000000000000000000000000000;;		SwapLimit uint64 `json:"swap_limit,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerSpec struct {
0000000000000000000000000000000000000000;;		// Time at which the container was created.
0000000000000000000000000000000000000000;;		CreationTime time.Time `json:"creation_time,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata labels associated with this container.
0000000000000000000000000000000000000000;;		Labels map[string]string `json:"labels,omitempty"`
0000000000000000000000000000000000000000;;		// Metadata envs associated with this container. Only whitelisted envs are added.
0000000000000000000000000000000000000000;;		Envs map[string]string `json:"envs,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HasCpu bool    `json:"has_cpu"`
0000000000000000000000000000000000000000;;		Cpu    CpuSpec `json:"cpu,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HasMemory bool       `json:"has_memory"`
0000000000000000000000000000000000000000;;		Memory    MemorySpec `json:"memory,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HasNetwork bool `json:"has_network"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HasFilesystem bool `json:"has_filesystem"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HasDiskIo when true, indicates that DiskIo stats will be available.
0000000000000000000000000000000000000000;;		HasDiskIo bool `json:"has_diskio"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HasCustomMetrics bool         `json:"has_custom_metrics"`
0000000000000000000000000000000000000000;;		CustomMetrics    []MetricSpec `json:"custom_metrics,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Image name used for this container.
0000000000000000000000000000000000000000;;		Image string `json:"image,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Container reference contains enough information to uniquely identify a container
0000000000000000000000000000000000000000;;	type ContainerReference struct {
0000000000000000000000000000000000000000;;		// The container id
0000000000000000000000000000000000000000;;		Id string `json:"id,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The absolute name of the container. This is unique on the machine.
0000000000000000000000000000000000000000;;		Name string `json:"name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Other names by which the container is known within a certain namespace.
0000000000000000000000000000000000000000;;		// This is unique within that namespace.
0000000000000000000000000000000000000000;;		Aliases []string `json:"aliases,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Namespace under which the aliases of a container are unique.
0000000000000000000000000000000000000000;;		// An example of a namespace is "docker" for Docker containers.
0000000000000000000000000000000000000000;;		Namespace string `json:"namespace,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Labels map[string]string `json:"labels,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sorts by container name.
0000000000000000000000000000000000000000;;	type ContainerReferenceSlice []ContainerReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self ContainerReferenceSlice) Len() int           { return len(self) }
0000000000000000000000000000000000000000;;	func (self ContainerReferenceSlice) Swap(i, j int)      { self[i], self[j] = self[j], self[i] }
0000000000000000000000000000000000000000;;	func (self ContainerReferenceSlice) Less(i, j int) bool { return self[i].Name < self[j].Name }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainerInfoRequest is used when users check a container info from the REST API.
0000000000000000000000000000000000000000;;	// It specifies how much data users want to get about a container
0000000000000000000000000000000000000000;;	type ContainerInfoRequest struct {
0000000000000000000000000000000000000000;;		// Max number of stats to return. Specify -1 for all stats currently available.
0000000000000000000000000000000000000000;;		// Default: 60
0000000000000000000000000000000000000000;;		NumStats int `json:"num_stats,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start time for which to query information.
0000000000000000000000000000000000000000;;		// If ommitted, the beginning of time is assumed.
0000000000000000000000000000000000000000;;		Start time.Time `json:"start,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// End time for which to query information.
0000000000000000000000000000000000000000;;		// If ommitted, current time is assumed.
0000000000000000000000000000000000000000;;		End time.Time `json:"end,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a ContainerInfoRequest with all default values specified.
0000000000000000000000000000000000000000;;	func DefaultContainerInfoRequest() ContainerInfoRequest {
0000000000000000000000000000000000000000;;		return ContainerInfoRequest{
0000000000000000000000000000000000000000;;			NumStats: 60,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *ContainerInfoRequest) Equals(other ContainerInfoRequest) bool {
0000000000000000000000000000000000000000;;		return self.NumStats == other.NumStats &&
0000000000000000000000000000000000000000;;			self.Start.Equal(other.Start) &&
0000000000000000000000000000000000000000;;			self.End.Equal(other.End)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerInfo struct {
0000000000000000000000000000000000000000;;		ContainerReference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The direct subcontainers of the current container.
0000000000000000000000000000000000000000;;		Subcontainers []ContainerReference `json:"subcontainers,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The isolation used in the container.
0000000000000000000000000000000000000000;;		Spec ContainerSpec `json:"spec,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Historical statistics gathered from the container.
0000000000000000000000000000000000000000;;		Stats []*ContainerStats `json:"stats,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(vmarmol): Refactor to not need this equality comparison.
0000000000000000000000000000000000000000;;	// ContainerInfo may be (un)marshaled by json or other en/decoder. In that
0000000000000000000000000000000000000000;;	// case, the Timestamp field in each stats/sample may not be precisely
0000000000000000000000000000000000000000;;	// en/decoded.  This will lead to small but acceptable differences between a
0000000000000000000000000000000000000000;;	// ContainerInfo and its encode-then-decode version.  Eq() is used to compare
0000000000000000000000000000000000000000;;	// two ContainerInfo accepting small difference (<10ms) of Time fields.
0000000000000000000000000000000000000000;;	func (self *ContainerInfo) Eq(b *ContainerInfo) bool {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If both self and b are nil, then Eq() returns true
0000000000000000000000000000000000000000;;		if self == nil {
0000000000000000000000000000000000000000;;			return b == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b == nil {
0000000000000000000000000000000000000000;;			return self == nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For fields other than time.Time, we will compare them precisely.
0000000000000000000000000000000000000000;;		// This would require that any slice should have same order.
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(self.ContainerReference, b.ContainerReference) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(self.Subcontainers, b.Subcontainers) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !self.Spec.Eq(&b.Spec) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, expectedStats := range b.Stats {
0000000000000000000000000000000000000000;;			selfStats := self.Stats[i]
0000000000000000000000000000000000000000;;			if !expectedStats.Eq(selfStats) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *ContainerSpec) Eq(b *ContainerSpec) bool {
0000000000000000000000000000000000000000;;		// Creation within 1s of each other.
0000000000000000000000000000000000000000;;		diff := self.CreationTime.Sub(b.CreationTime)
0000000000000000000000000000000000000000;;		if (diff > time.Second) || (diff < -time.Second) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if self.HasCpu != b.HasCpu {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(self.Cpu, b.Cpu) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if self.HasMemory != b.HasMemory {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(self.Memory, b.Memory) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if self.HasNetwork != b.HasNetwork {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if self.HasFilesystem != b.HasFilesystem {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if self.HasDiskIo != b.HasDiskIo {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if self.HasCustomMetrics != b.HasCustomMetrics {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *ContainerInfo) StatsAfter(ref time.Time) []*ContainerStats {
0000000000000000000000000000000000000000;;		n := len(self.Stats) + 1
0000000000000000000000000000000000000000;;		for i, s := range self.Stats {
0000000000000000000000000000000000000000;;			if s.Timestamp.After(ref) {
0000000000000000000000000000000000000000;;				n = i
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n > len(self.Stats) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return self.Stats[n:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *ContainerInfo) StatsStartTime() time.Time {
0000000000000000000000000000000000000000;;		var ret time.Time
0000000000000000000000000000000000000000;;		for _, s := range self.Stats {
0000000000000000000000000000000000000000;;			if s.Timestamp.Before(ret) || ret.IsZero() {
0000000000000000000000000000000000000000;;				ret = s.Timestamp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *ContainerInfo) StatsEndTime() time.Time {
0000000000000000000000000000000000000000;;		var ret time.Time
0000000000000000000000000000000000000000;;		for i := len(self.Stats) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			s := self.Stats[i]
0000000000000000000000000000000000000000;;			if s.Timestamp.After(ret) {
0000000000000000000000000000000000000000;;				ret = s.Timestamp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This mirrors kernel internal structure.
0000000000000000000000000000000000000000;;	type LoadStats struct {
0000000000000000000000000000000000000000;;		// Number of sleeping tasks.
0000000000000000000000000000000000000000;;		NrSleeping uint64 `json:"nr_sleeping"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of running tasks.
0000000000000000000000000000000000000000;;		NrRunning uint64 `json:"nr_running"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of tasks in stopped state
0000000000000000000000000000000000000000;;		NrStopped uint64 `json:"nr_stopped"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of tasks in uninterruptible state
0000000000000000000000000000000000000000;;		NrUninterruptible uint64 `json:"nr_uninterruptible"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of tasks waiting on IO
0000000000000000000000000000000000000000;;		NrIoWait uint64 `json:"nr_io_wait"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CPU usage time statistics.
0000000000000000000000000000000000000000;;	type CpuUsage struct {
0000000000000000000000000000000000000000;;		// Total CPU usage.
0000000000000000000000000000000000000000;;		// Unit: nanoseconds.
0000000000000000000000000000000000000000;;		Total uint64 `json:"total"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Per CPU/core usage of the container.
0000000000000000000000000000000000000000;;		// Unit: nanoseconds.
0000000000000000000000000000000000000000;;		PerCpu []uint64 `json:"per_cpu_usage,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time spent in user space.
0000000000000000000000000000000000000000;;		// Unit: nanoseconds.
0000000000000000000000000000000000000000;;		User uint64 `json:"user"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Time spent in kernel space.
0000000000000000000000000000000000000000;;		// Unit: nanoseconds.
0000000000000000000000000000000000000000;;		System uint64 `json:"system"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cpu Completely Fair Scheduler statistics.
0000000000000000000000000000000000000000;;	type CpuCFS struct {
0000000000000000000000000000000000000000;;		// Total number of elapsed enforcement intervals.
0000000000000000000000000000000000000000;;		Periods uint64 `json:"periods"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total number of times tasks in the cgroup have been throttled.
0000000000000000000000000000000000000000;;		ThrottledPeriods uint64 `json:"throttled_periods"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Total time duration for which tasks in the cgroup have been throttled.
0000000000000000000000000000000000000000;;		// Unit: nanoseconds.
0000000000000000000000000000000000000000;;		ThrottledTime uint64 `json:"throttled_time"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// All CPU usage metrics are cumulative from the creation of the container
0000000000000000000000000000000000000000;;	type CpuStats struct {
0000000000000000000000000000000000000000;;		Usage CpuUsage `json:"usage"`
0000000000000000000000000000000000000000;;		CFS   CpuCFS   `json:"cfs"`
0000000000000000000000000000000000000000;;		// Smoothed average of number of runnable threads x 1000.
0000000000000000000000000000000000000000;;		// We multiply by thousand to avoid using floats, but preserving precision.
0000000000000000000000000000000000000000;;		// Load is smoothed over the last 10 seconds. Instantaneous value can be read
0000000000000000000000000000000000000000;;		// from LoadStats.NrRunning.
0000000000000000000000000000000000000000;;		LoadAverage int32 `json:"load_average"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PerDiskStats struct {
0000000000000000000000000000000000000000;;		Device string            `json:"-"`
0000000000000000000000000000000000000000;;		Major  uint64            `json:"major"`
0000000000000000000000000000000000000000;;		Minor  uint64            `json:"minor"`
0000000000000000000000000000000000000000;;		Stats  map[string]uint64 `json:"stats"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DiskIoStats struct {
0000000000000000000000000000000000000000;;		IoServiceBytes []PerDiskStats `json:"io_service_bytes,omitempty"`
0000000000000000000000000000000000000000;;		IoServiced     []PerDiskStats `json:"io_serviced,omitempty"`
0000000000000000000000000000000000000000;;		IoQueued       []PerDiskStats `json:"io_queued,omitempty"`
0000000000000000000000000000000000000000;;		Sectors        []PerDiskStats `json:"sectors,omitempty"`
0000000000000000000000000000000000000000;;		IoServiceTime  []PerDiskStats `json:"io_service_time,omitempty"`
0000000000000000000000000000000000000000;;		IoWaitTime     []PerDiskStats `json:"io_wait_time,omitempty"`
0000000000000000000000000000000000000000;;		IoMerged       []PerDiskStats `json:"io_merged,omitempty"`
0000000000000000000000000000000000000000;;		IoTime         []PerDiskStats `json:"io_time,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MemoryStats struct {
0000000000000000000000000000000000000000;;		// Current memory usage, this includes all memory regardless of when it was
0000000000000000000000000000000000000000;;		// accessed.
0000000000000000000000000000000000000000;;		// Units: Bytes.
0000000000000000000000000000000000000000;;		Usage uint64 `json:"usage"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of bytes of page cache memory.
0000000000000000000000000000000000000000;;		// Units: Bytes.
0000000000000000000000000000000000000000;;		Cache uint64 `json:"cache"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The amount of anonymous and swap cache memory (includes transparent
0000000000000000000000000000000000000000;;		// hugepages).
0000000000000000000000000000000000000000;;		// Units: Bytes.
0000000000000000000000000000000000000000;;		RSS uint64 `json:"rss"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The amount of swap currently used by the processes in this cgroup
0000000000000000000000000000000000000000;;		// Units: Bytes.
0000000000000000000000000000000000000000;;		Swap uint64 `json:"swap"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The amount of working set memory, this includes recently accessed memory,
0000000000000000000000000000000000000000;;		// dirty memory, and kernel memory. Working set is <= "usage".
0000000000000000000000000000000000000000;;		// Units: Bytes.
0000000000000000000000000000000000000000;;		WorkingSet uint64 `json:"working_set"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Failcnt uint64 `json:"failcnt"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ContainerData    MemoryStatsMemoryData `json:"container_data,omitempty"`
0000000000000000000000000000000000000000;;		HierarchicalData MemoryStatsMemoryData `json:"hierarchical_data,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MemoryStatsMemoryData struct {
0000000000000000000000000000000000000000;;		Pgfault    uint64 `json:"pgfault"`
0000000000000000000000000000000000000000;;		Pgmajfault uint64 `json:"pgmajfault"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InterfaceStats struct {
0000000000000000000000000000000000000000;;		// The name of the interface.
0000000000000000000000000000000000000000;;		Name string `json:"name"`
0000000000000000000000000000000000000000;;		// Cumulative count of bytes received.
0000000000000000000000000000000000000000;;		RxBytes uint64 `json:"rx_bytes"`
0000000000000000000000000000000000000000;;		// Cumulative count of packets received.
0000000000000000000000000000000000000000;;		RxPackets uint64 `json:"rx_packets"`
0000000000000000000000000000000000000000;;		// Cumulative count of receive errors encountered.
0000000000000000000000000000000000000000;;		RxErrors uint64 `json:"rx_errors"`
0000000000000000000000000000000000000000;;		// Cumulative count of packets dropped while receiving.
0000000000000000000000000000000000000000;;		RxDropped uint64 `json:"rx_dropped"`
0000000000000000000000000000000000000000;;		// Cumulative count of bytes transmitted.
0000000000000000000000000000000000000000;;		TxBytes uint64 `json:"tx_bytes"`
0000000000000000000000000000000000000000;;		// Cumulative count of packets transmitted.
0000000000000000000000000000000000000000;;		TxPackets uint64 `json:"tx_packets"`
0000000000000000000000000000000000000000;;		// Cumulative count of transmit errors encountered.
0000000000000000000000000000000000000000;;		TxErrors uint64 `json:"tx_errors"`
0000000000000000000000000000000000000000;;		// Cumulative count of packets dropped while transmitting.
0000000000000000000000000000000000000000;;		TxDropped uint64 `json:"tx_dropped"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NetworkStats struct {
0000000000000000000000000000000000000000;;		InterfaceStats `json:",inline"`
0000000000000000000000000000000000000000;;		Interfaces     []InterfaceStats `json:"interfaces,omitempty"`
0000000000000000000000000000000000000000;;		// TCP connection stats (Established, Listen...)
0000000000000000000000000000000000000000;;		Tcp TcpStat `json:"tcp"`
0000000000000000000000000000000000000000;;		// TCP6 connection stats (Established, Listen...)
0000000000000000000000000000000000000000;;		Tcp6 TcpStat `json:"tcp6"`
0000000000000000000000000000000000000000;;		// UDP connection stats
0000000000000000000000000000000000000000;;		Udp UdpStat `json:"udp"`
0000000000000000000000000000000000000000;;		// UDP6 connection stats
0000000000000000000000000000000000000000;;		Udp6 UdpStat `json:"udp6"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TcpStat struct {
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Established"
0000000000000000000000000000000000000000;;		Established uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Syn_Sent"
0000000000000000000000000000000000000000;;		SynSent uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Syn_Recv"
0000000000000000000000000000000000000000;;		SynRecv uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Fin_Wait1"
0000000000000000000000000000000000000000;;		FinWait1 uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Fin_Wait2"
0000000000000000000000000000000000000000;;		FinWait2 uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Time_Wait
0000000000000000000000000000000000000000;;		TimeWait uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Close"
0000000000000000000000000000000000000000;;		Close uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Close_Wait"
0000000000000000000000000000000000000000;;		CloseWait uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Listen_Ack"
0000000000000000000000000000000000000000;;		LastAck uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Listen"
0000000000000000000000000000000000000000;;		Listen uint64
0000000000000000000000000000000000000000;;		// Count of TCP connections in state "Closing"
0000000000000000000000000000000000000000;;		Closing uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UdpStat struct {
0000000000000000000000000000000000000000;;		// Count of UDP sockets in state "Listen"
0000000000000000000000000000000000000000;;		Listen uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count of UDP packets dropped by the IP stack
0000000000000000000000000000000000000000;;		Dropped uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count of packets Queued for Receieve
0000000000000000000000000000000000000000;;		RxQueued uint64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Count of packets Queued for Transmit
0000000000000000000000000000000000000000;;		TxQueued uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type FsStats struct {
0000000000000000000000000000000000000000;;		// The block device name associated with the filesystem.
0000000000000000000000000000000000000000;;		Device string `json:"device,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Type of the filesytem.
0000000000000000000000000000000000000000;;		Type string `json:"type"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of bytes that can be consumed by the container on this filesystem.
0000000000000000000000000000000000000000;;		Limit uint64 `json:"capacity"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of bytes that is consumed by the container on this filesystem.
0000000000000000000000000000000000000000;;		Usage uint64 `json:"usage"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Base Usage that is consumed by the container's writable layer.
0000000000000000000000000000000000000000;;		// This field is only applicable for docker container's as of now.
0000000000000000000000000000000000000000;;		BaseUsage uint64 `json:"base_usage"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of bytes available for non-root user.
0000000000000000000000000000000000000000;;		Available uint64 `json:"available"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HasInodes when true, indicates that Inodes info will be available.
0000000000000000000000000000000000000000;;		HasInodes bool `json:"has_inodes"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of Inodes
0000000000000000000000000000000000000000;;		Inodes uint64 `json:"inodes"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of available Inodes
0000000000000000000000000000000000000000;;		InodesFree uint64 `json:"inodes_free"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of reads completed
0000000000000000000000000000000000000000;;		// This is the total number of reads completed successfully.
0000000000000000000000000000000000000000;;		ReadsCompleted uint64 `json:"reads_completed"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of reads merged
0000000000000000000000000000000000000000;;		// Reads and writes which are adjacent to each other may be merged for
0000000000000000000000000000000000000000;;		// efficiency.  Thus two 4K reads may become one 8K read before it is
0000000000000000000000000000000000000000;;		// ultimately handed to the disk, and so it will be counted (and queued)
0000000000000000000000000000000000000000;;		// as only one I/O.  This field lets you know how often this was done.
0000000000000000000000000000000000000000;;		ReadsMerged uint64 `json:"reads_merged"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of sectors read
0000000000000000000000000000000000000000;;		// This is the total number of sectors read successfully.
0000000000000000000000000000000000000000;;		SectorsRead uint64 `json:"sectors_read"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of milliseconds spent reading
0000000000000000000000000000000000000000;;		// This is the total number of milliseconds spent by all reads (as
0000000000000000000000000000000000000000;;		// measured from __make_request() to end_that_request_last()).
0000000000000000000000000000000000000000;;		ReadTime uint64 `json:"read_time"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of writes completed
0000000000000000000000000000000000000000;;		// This is the total number of writes completed successfully.
0000000000000000000000000000000000000000;;		WritesCompleted uint64 `json:"writes_completed"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of writes merged
0000000000000000000000000000000000000000;;		// See the description of reads merged.
0000000000000000000000000000000000000000;;		WritesMerged uint64 `json:"writes_merged"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of sectors written
0000000000000000000000000000000000000000;;		// This is the total number of sectors written successfully.
0000000000000000000000000000000000000000;;		SectorsWritten uint64 `json:"sectors_written"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of milliseconds spent writing
0000000000000000000000000000000000000000;;		// This is the total number of milliseconds spent by all writes (as
0000000000000000000000000000000000000000;;		// measured from __make_request() to end_that_request_last()).
0000000000000000000000000000000000000000;;		WriteTime uint64 `json:"write_time"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of I/Os currently in progress
0000000000000000000000000000000000000000;;		// The only field that should go to zero. Incremented as requests are
0000000000000000000000000000000000000000;;		// given to appropriate struct request_queue and decremented as they finish.
0000000000000000000000000000000000000000;;		IoInProgress uint64 `json:"io_in_progress"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Number of milliseconds spent doing I/Os
0000000000000000000000000000000000000000;;		// This field increases so long as field 9 is nonzero.
0000000000000000000000000000000000000000;;		IoTime uint64 `json:"io_time"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// weighted number of milliseconds spent doing I/Os
0000000000000000000000000000000000000000;;		// This field is incremented at each I/O start, I/O completion, I/O
0000000000000000000000000000000000000000;;		// merge, or read of these stats by the number of I/Os in progress
0000000000000000000000000000000000000000;;		// (field 9) times the number of milliseconds spent doing I/O since the
0000000000000000000000000000000000000000;;		// last update of this field.  This can provide an easy measure of both
0000000000000000000000000000000000000000;;		// I/O completion time and the backlog that may be accumulating.
0000000000000000000000000000000000000000;;		WeightedIoTime uint64 `json:"weighted_io_time"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContainerStats struct {
0000000000000000000000000000000000000000;;		// The time of this stat point.
0000000000000000000000000000000000000000;;		Timestamp time.Time    `json:"timestamp"`
0000000000000000000000000000000000000000;;		Cpu       CpuStats     `json:"cpu,omitempty"`
0000000000000000000000000000000000000000;;		DiskIo    DiskIoStats  `json:"diskio,omitempty"`
0000000000000000000000000000000000000000;;		Memory    MemoryStats  `json:"memory,omitempty"`
0000000000000000000000000000000000000000;;		Network   NetworkStats `json:"network,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Filesystem statistics
0000000000000000000000000000000000000000;;		Filesystem []FsStats `json:"filesystem,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Task load stats
0000000000000000000000000000000000000000;;		TaskStats LoadStats `json:"task_stats,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Custom metrics from all collectors
0000000000000000000000000000000000000000;;		CustomMetrics map[string][]MetricVal `json:"custom_metrics,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func timeEq(t1, t2 time.Time, tolerance time.Duration) bool {
0000000000000000000000000000000000000000;;		// t1 should not be later than t2
0000000000000000000000000000000000000000;;		if t1.After(t2) {
0000000000000000000000000000000000000000;;			t1, t2 = t2, t1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		diff := t2.Sub(t1)
0000000000000000000000000000000000000000;;		if diff <= tolerance {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// 10ms, i.e. 0.01s
0000000000000000000000000000000000000000;;		timePrecision time.Duration = 10 * time.Millisecond
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function is useful because we do not require precise time
0000000000000000000000000000000000000000;;	// representation.
0000000000000000000000000000000000000000;;	func (a *ContainerStats) Eq(b *ContainerStats) bool {
0000000000000000000000000000000000000000;;		if !timeEq(a.Timestamp, b.Timestamp, timePrecision) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a.StatsEq(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks equality of the stats values.
0000000000000000000000000000000000000000;;	func (a *ContainerStats) StatsEq(b *ContainerStats) bool {
0000000000000000000000000000000000000000;;		// TODO(vmarmol): Consider using this through reflection.
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(a.Cpu, b.Cpu) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(a.Memory, b.Memory) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(a.DiskIo, b.DiskIo) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(a.Network, b.Network) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(a.Filesystem, b.Filesystem) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Event contains information general to events such as the time at which they
0000000000000000000000000000000000000000;;	// occurred, their specific type, and the actual event. Event types are
0000000000000000000000000000000000000000;;	// differentiated by the EventType field of Event.
0000000000000000000000000000000000000000;;	type Event struct {
0000000000000000000000000000000000000000;;		// the absolute container name for which the event occurred
0000000000000000000000000000000000000000;;		ContainerName string `json:"container_name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the time at which the event occurred
0000000000000000000000000000000000000000;;		Timestamp time.Time `json:"timestamp"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the type of event. EventType is an enumerated type
0000000000000000000000000000000000000000;;		EventType EventType `json:"event_type"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the original event object and all of its extraneous data, ex. an
0000000000000000000000000000000000000000;;		// OomInstance
0000000000000000000000000000000000000000;;		EventData EventData `json:"event_data,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EventType is an enumerated type which lists the categories under which
0000000000000000000000000000000000000000;;	// events may fall. The Event field EventType is populated by this enum.
0000000000000000000000000000000000000000;;	type EventType string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EventOom               EventType = "oom"
0000000000000000000000000000000000000000;;		EventOomKill                     = "oomKill"
0000000000000000000000000000000000000000;;		EventContainerCreation           = "containerCreation"
0000000000000000000000000000000000000000;;		EventContainerDeletion           = "containerDeletion"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extra information about an event. Only one type will be set.
0000000000000000000000000000000000000000;;	type EventData struct {
0000000000000000000000000000000000000000;;		// Information about an OOM kill event.
0000000000000000000000000000000000000000;;		OomKill *OomKillEventData `json:"oom,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Information related to an OOM kill instance
0000000000000000000000000000000000000000;;	type OomKillEventData struct {
0000000000000000000000000000000000000000;;		// process id of the killed process
0000000000000000000000000000000000000000;;		Pid int `json:"pid"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The name of the killed process
0000000000000000000000000000000000000000;;		ProcessName string `json:"process_name"`
0000000000000000000000000000000000000000;;	}
