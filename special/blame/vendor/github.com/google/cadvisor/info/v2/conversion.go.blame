0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
89bc075ca22301fc4fe03dcaa8c8fcf6f0b87b87;Godeps/_workspace/src/github.com/google/cadvisor/info/v2/conversion.go[Godeps/_workspace/src/github.com/google/cadvisor/info/v2/conversion.go][vendor/github.com/google/cadvisor/info/v2/conversion.go];	
0000000000000000000000000000000000000000;;	package v2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func machineFsStatsFromV1(fsStats []v1.FsStats) []MachineFsStats {
0000000000000000000000000000000000000000;;		var result []MachineFsStats
0000000000000000000000000000000000000000;;		for i := range fsStats {
0000000000000000000000000000000000000000;;			stat := fsStats[i]
0000000000000000000000000000000000000000;;			readDuration := time.Millisecond * time.Duration(stat.ReadTime)
0000000000000000000000000000000000000000;;			writeDuration := time.Millisecond * time.Duration(stat.WriteTime)
0000000000000000000000000000000000000000;;			ioDuration := time.Millisecond * time.Duration(stat.IoTime)
0000000000000000000000000000000000000000;;			weightedDuration := time.Millisecond * time.Duration(stat.WeightedIoTime)
0000000000000000000000000000000000000000;;			machineFsStat := MachineFsStats{
0000000000000000000000000000000000000000;;				Device:    stat.Device,
0000000000000000000000000000000000000000;;				Type:      stat.Type,
0000000000000000000000000000000000000000;;				Capacity:  &stat.Limit,
0000000000000000000000000000000000000000;;				Usage:     &stat.Usage,
0000000000000000000000000000000000000000;;				Available: &stat.Available,
0000000000000000000000000000000000000000;;				DiskStats: DiskStats{
0000000000000000000000000000000000000000;;					ReadsCompleted:     &stat.ReadsCompleted,
0000000000000000000000000000000000000000;;					ReadsMerged:        &stat.ReadsMerged,
0000000000000000000000000000000000000000;;					SectorsRead:        &stat.SectorsRead,
0000000000000000000000000000000000000000;;					ReadDuration:       &readDuration,
0000000000000000000000000000000000000000;;					WritesCompleted:    &stat.WritesCompleted,
0000000000000000000000000000000000000000;;					WritesMerged:       &stat.WritesMerged,
0000000000000000000000000000000000000000;;					SectorsWritten:     &stat.SectorsWritten,
0000000000000000000000000000000000000000;;					WriteDuration:      &writeDuration,
0000000000000000000000000000000000000000;;					IoInProgress:       &stat.IoInProgress,
0000000000000000000000000000000000000000;;					IoDuration:         &ioDuration,
0000000000000000000000000000000000000000;;					WeightedIoDuration: &weightedDuration,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.HasInodes {
0000000000000000000000000000000000000000;;				machineFsStat.InodesFree = &stat.InodesFree
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result = append(result, machineFsStat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MachineStatsFromV1(cont *v1.ContainerInfo) []MachineStats {
0000000000000000000000000000000000000000;;		var stats []MachineStats
0000000000000000000000000000000000000000;;		var last *v1.ContainerStats
0000000000000000000000000000000000000000;;		for i := range cont.Stats {
0000000000000000000000000000000000000000;;			val := cont.Stats[i]
0000000000000000000000000000000000000000;;			stat := MachineStats{
0000000000000000000000000000000000000000;;				Timestamp: val.Timestamp,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cont.Spec.HasCpu {
0000000000000000000000000000000000000000;;				stat.Cpu = &val.Cpu
0000000000000000000000000000000000000000;;				cpuInst, err := InstCpuStats(last, val)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Could not get instant cpu stats: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					stat.CpuInst = cpuInst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				last = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cont.Spec.HasMemory {
0000000000000000000000000000000000000000;;				stat.Memory = &val.Memory
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cont.Spec.HasNetwork {
0000000000000000000000000000000000000000;;				stat.Network = &NetworkStats{
0000000000000000000000000000000000000000;;					// FIXME: Use reflection instead.
0000000000000000000000000000000000000000;;					Tcp:        TcpStat(val.Network.Tcp),
0000000000000000000000000000000000000000;;					Tcp6:       TcpStat(val.Network.Tcp6),
0000000000000000000000000000000000000000;;					Interfaces: val.Network.Interfaces,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cont.Spec.HasFilesystem {
0000000000000000000000000000000000000000;;				stat.Filesystem = machineFsStatsFromV1(val.Filesystem)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(rjnagal): Handle load stats.
0000000000000000000000000000000000000000;;			stats = append(stats, stat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ContainerStatsFromV1(containerName string, spec *v1.ContainerSpec, stats []*v1.ContainerStats) []*ContainerStats {
0000000000000000000000000000000000000000;;		newStats := make([]*ContainerStats, 0, len(stats))
0000000000000000000000000000000000000000;;		var last *v1.ContainerStats
0000000000000000000000000000000000000000;;		for _, val := range stats {
0000000000000000000000000000000000000000;;			stat := &ContainerStats{
0000000000000000000000000000000000000000;;				Timestamp: val.Timestamp,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if spec.HasCpu {
0000000000000000000000000000000000000000;;				stat.Cpu = &val.Cpu
0000000000000000000000000000000000000000;;				cpuInst, err := InstCpuStats(last, val)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Could not get instant cpu stats: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					stat.CpuInst = cpuInst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				last = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if spec.HasMemory {
0000000000000000000000000000000000000000;;				stat.Memory = &val.Memory
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if spec.HasNetwork {
0000000000000000000000000000000000000000;;				// TODO: Handle TcpStats
0000000000000000000000000000000000000000;;				stat.Network = &NetworkStats{
0000000000000000000000000000000000000000;;					Tcp:        TcpStat(val.Network.Tcp),
0000000000000000000000000000000000000000;;					Tcp6:       TcpStat(val.Network.Tcp6),
0000000000000000000000000000000000000000;;					Interfaces: val.Network.Interfaces,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if spec.HasFilesystem {
0000000000000000000000000000000000000000;;				if len(val.Filesystem) == 1 {
0000000000000000000000000000000000000000;;					stat.Filesystem = &FilesystemStats{
0000000000000000000000000000000000000000;;						TotalUsageBytes: &val.Filesystem[0].Usage,
0000000000000000000000000000000000000000;;						BaseUsageBytes:  &val.Filesystem[0].BaseUsage,
0000000000000000000000000000000000000000;;						InodeUsage:      &val.Filesystem[0].Inodes,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if len(val.Filesystem) > 1 && containerName != "/" {
0000000000000000000000000000000000000000;;					// Cannot handle multiple devices per container.
0000000000000000000000000000000000000000;;					glog.V(4).Infof("failed to handle multiple devices for container %s. Skipping Filesystem stats", containerName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if spec.HasDiskIo {
0000000000000000000000000000000000000000;;				stat.DiskIo = &val.DiskIo
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if spec.HasCustomMetrics {
0000000000000000000000000000000000000000;;				stat.CustomMetrics = val.CustomMetrics
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(rjnagal): Handle load stats.
0000000000000000000000000000000000000000;;			newStats = append(newStats, stat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return newStats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeprecatedStatsFromV1(cont *v1.ContainerInfo) []DeprecatedContainerStats {
0000000000000000000000000000000000000000;;		stats := make([]DeprecatedContainerStats, 0, len(cont.Stats))
0000000000000000000000000000000000000000;;		var last *v1.ContainerStats
0000000000000000000000000000000000000000;;		for _, val := range cont.Stats {
0000000000000000000000000000000000000000;;			stat := DeprecatedContainerStats{
0000000000000000000000000000000000000000;;				Timestamp:        val.Timestamp,
0000000000000000000000000000000000000000;;				HasCpu:           cont.Spec.HasCpu,
0000000000000000000000000000000000000000;;				HasMemory:        cont.Spec.HasMemory,
0000000000000000000000000000000000000000;;				HasNetwork:       cont.Spec.HasNetwork,
0000000000000000000000000000000000000000;;				HasFilesystem:    cont.Spec.HasFilesystem,
0000000000000000000000000000000000000000;;				HasDiskIo:        cont.Spec.HasDiskIo,
0000000000000000000000000000000000000000;;				HasCustomMetrics: cont.Spec.HasCustomMetrics,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.HasCpu {
0000000000000000000000000000000000000000;;				stat.Cpu = val.Cpu
0000000000000000000000000000000000000000;;				cpuInst, err := InstCpuStats(last, val)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Could not get instant cpu stats: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					stat.CpuInst = cpuInst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				last = val
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.HasMemory {
0000000000000000000000000000000000000000;;				stat.Memory = val.Memory
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.HasNetwork {
0000000000000000000000000000000000000000;;				stat.Network.Interfaces = val.Network.Interfaces
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.HasFilesystem {
0000000000000000000000000000000000000000;;				stat.Filesystem = val.Filesystem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.HasDiskIo {
0000000000000000000000000000000000000000;;				stat.DiskIo = val.DiskIo
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if stat.HasCustomMetrics {
0000000000000000000000000000000000000000;;				stat.CustomMetrics = val.CustomMetrics
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// TODO(rjnagal): Handle load stats.
0000000000000000000000000000000000000000;;			stats = append(stats, stat)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func InstCpuStats(last, cur *v1.ContainerStats) (*CpuInstStats, error) {
0000000000000000000000000000000000000000;;		if last == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !cur.Timestamp.After(last.Timestamp) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("container stats move backwards in time")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(last.Cpu.Usage.PerCpu) != len(cur.Cpu.Usage.PerCpu) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("different number of cpus")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timeDelta := cur.Timestamp.Sub(last.Timestamp)
0000000000000000000000000000000000000000;;		if timeDelta <= 100*time.Millisecond {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("time delta unexpectedly small")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Nanoseconds to gain precision and avoid having zero seconds if the
0000000000000000000000000000000000000000;;		// difference between the timestamps is just under a second
0000000000000000000000000000000000000000;;		timeDeltaNs := uint64(timeDelta.Nanoseconds())
0000000000000000000000000000000000000000;;		convertToRate := func(lastValue, curValue uint64) (uint64, error) {
0000000000000000000000000000000000000000;;			if curValue < lastValue {
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("cumulative stats decrease")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			valueDelta := curValue - lastValue
0000000000000000000000000000000000000000;;			// Use float64 to keep precision
0000000000000000000000000000000000000000;;			return uint64(float64(valueDelta) / float64(timeDeltaNs) * 1e9), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		total, err := convertToRate(last.Cpu.Usage.Total, cur.Cpu.Usage.Total)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		percpu := make([]uint64, len(last.Cpu.Usage.PerCpu))
0000000000000000000000000000000000000000;;		for i := range percpu {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			percpu[i], err = convertToRate(last.Cpu.Usage.PerCpu[i], cur.Cpu.Usage.PerCpu[i])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		user, err := convertToRate(last.Cpu.Usage.User, cur.Cpu.Usage.User)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		system, err := convertToRate(last.Cpu.Usage.System, cur.Cpu.Usage.System)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &CpuInstStats{
0000000000000000000000000000000000000000;;			Usage: CpuInstUsage{
0000000000000000000000000000000000000000;;				Total:  total,
0000000000000000000000000000000000000000;;				PerCpu: percpu,
0000000000000000000000000000000000000000;;				User:   user,
0000000000000000000000000000000000000000;;				System: system,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get V2 container spec from v1 container info.
0000000000000000000000000000000000000000;;	func ContainerSpecFromV1(specV1 *v1.ContainerSpec, aliases []string, namespace string) ContainerSpec {
0000000000000000000000000000000000000000;;		specV2 := ContainerSpec{
0000000000000000000000000000000000000000;;			CreationTime:     specV1.CreationTime,
0000000000000000000000000000000000000000;;			HasCpu:           specV1.HasCpu,
0000000000000000000000000000000000000000;;			HasMemory:        specV1.HasMemory,
0000000000000000000000000000000000000000;;			HasFilesystem:    specV1.HasFilesystem,
0000000000000000000000000000000000000000;;			HasNetwork:       specV1.HasNetwork,
0000000000000000000000000000000000000000;;			HasDiskIo:        specV1.HasDiskIo,
0000000000000000000000000000000000000000;;			HasCustomMetrics: specV1.HasCustomMetrics,
0000000000000000000000000000000000000000;;			Image:            specV1.Image,
0000000000000000000000000000000000000000;;			Labels:           specV1.Labels,
0000000000000000000000000000000000000000;;			Envs:             specV1.Envs,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if specV1.HasCpu {
0000000000000000000000000000000000000000;;			specV2.Cpu.Limit = specV1.Cpu.Limit
0000000000000000000000000000000000000000;;			specV2.Cpu.MaxLimit = specV1.Cpu.MaxLimit
0000000000000000000000000000000000000000;;			specV2.Cpu.Mask = specV1.Cpu.Mask
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if specV1.HasMemory {
0000000000000000000000000000000000000000;;			specV2.Memory.Limit = specV1.Memory.Limit
0000000000000000000000000000000000000000;;			specV2.Memory.Reservation = specV1.Memory.Reservation
0000000000000000000000000000000000000000;;			specV2.Memory.SwapLimit = specV1.Memory.SwapLimit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if specV1.HasCustomMetrics {
0000000000000000000000000000000000000000;;			specV2.CustomMetrics = specV1.CustomMetrics
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		specV2.Aliases = aliases
0000000000000000000000000000000000000000;;		specV2.Namespace = namespace
0000000000000000000000000000000000000000;;		return specV2
0000000000000000000000000000000000000000;;	}
