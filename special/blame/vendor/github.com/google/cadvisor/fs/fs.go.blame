0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/fs/fs.go[Godeps/_workspace/src/github.com/google/cadvisor/fs/fs.go][vendor/github.com/google/cadvisor/fs/fs.go];	
0000000000000000000000000000000000000000;;	// +build linux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Provides Filesystem Stats
0000000000000000000000000000000000000000;;	package fs
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/docker/docker/pkg/mount"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/devicemapper"
0000000000000000000000000000000000000000;;		dockerutil "github.com/google/cadvisor/utils/docker"
0000000000000000000000000000000000000000;;		zfs "github.com/mistifyio/go-zfs"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LabelSystemRoot   = "root"
0000000000000000000000000000000000000000;;		LabelDockerImages = "docker-images"
0000000000000000000000000000000000000000;;		LabelRktImages    = "rkt-images"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The maximum number of `du` and `find` tasks that can be running at once.
0000000000000000000000000000000000000000;;	const maxConcurrentOps = 20
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A pool for restricting the number of consecutive `du` and `find` tasks running.
0000000000000000000000000000000000000000;;	var pool = make(chan struct{}, maxConcurrentOps)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for i := 0; i < maxConcurrentOps; i++ {
0000000000000000000000000000000000000000;;			releaseToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func claimToken() {
0000000000000000000000000000000000000000;;		<-pool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func releaseToken() {
0000000000000000000000000000000000000000;;		pool <- struct{}{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type partition struct {
0000000000000000000000000000000000000000;;		mountpoint string
0000000000000000000000000000000000000000;;		major      uint
0000000000000000000000000000000000000000;;		minor      uint
0000000000000000000000000000000000000000;;		fsType     string
0000000000000000000000000000000000000000;;		blockSize  uint
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RealFsInfo struct {
0000000000000000000000000000000000000000;;		// Map from block device path to partition information.
0000000000000000000000000000000000000000;;		partitions map[string]partition
0000000000000000000000000000000000000000;;		// Map from label to block device path.
0000000000000000000000000000000000000000;;		// Labels are intent-specific tags that are auto-detected.
0000000000000000000000000000000000000000;;		labels map[string]string
0000000000000000000000000000000000000000;;		// devicemapper client
0000000000000000000000000000000000000000;;		dmsetup devicemapper.DmsetupClient
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Context struct {
0000000000000000000000000000000000000000;;		// docker root directory.
0000000000000000000000000000000000000000;;		Docker  DockerContext
0000000000000000000000000000000000000000;;		RktPath string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DockerContext struct {
0000000000000000000000000000000000000000;;		Root         string
0000000000000000000000000000000000000000;;		Driver       string
0000000000000000000000000000000000000000;;		DriverStatus map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewFsInfo(context Context) (FsInfo, error) {
0000000000000000000000000000000000000000;;		mounts, err := mount.GetMounts()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Avoid devicemapper container mounts - these are tracked by the ThinPoolWatcher
0000000000000000000000000000000000000000;;		excluded := []string{fmt.Sprintf("%s/devicemapper/mnt", context.Docker.Root)}
0000000000000000000000000000000000000000;;		fsInfo := &RealFsInfo{
0000000000000000000000000000000000000000;;			partitions: processMounts(mounts, excluded),
0000000000000000000000000000000000000000;;			labels:     make(map[string]string, 0),
0000000000000000000000000000000000000000;;			dmsetup:    devicemapper.NewDmsetupClient(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fsInfo.addRktImagesLabel(context, mounts)
0000000000000000000000000000000000000000;;		// need to call this before the log line below printing out the partitions, as this function may
0000000000000000000000000000000000000000;;		// add a "partition" for devicemapper to fsInfo.partitions
0000000000000000000000000000000000000000;;		fsInfo.addDockerImagesLabel(context, mounts)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.Infof("Filesystem partitions: %+v", fsInfo.partitions)
0000000000000000000000000000000000000000;;		fsInfo.addSystemRootLabel(mounts)
0000000000000000000000000000000000000000;;		return fsInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func processMounts(mounts []*mount.Info, excludedMountpointPrefixes []string) map[string]partition {
0000000000000000000000000000000000000000;;		partitions := make(map[string]partition, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		supportedFsType := map[string]bool{
0000000000000000000000000000000000000000;;			// all ext systems are checked through prefix.
0000000000000000000000000000000000000000;;			"btrfs": true,
0000000000000000000000000000000000000000;;			"xfs":   true,
0000000000000000000000000000000000000000;;			"zfs":   true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, mount := range mounts {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(mount.Fstype, "ext") && !supportedFsType[mount.Fstype] {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Avoid bind mounts.
0000000000000000000000000000000000000000;;			if _, ok := partitions[mount.Source]; ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			hasPrefix := false
0000000000000000000000000000000000000000;;			for _, prefix := range excludedMountpointPrefixes {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(mount.Mountpoint, prefix) {
0000000000000000000000000000000000000000;;					hasPrefix = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if hasPrefix {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// btrfs fix: following workaround fixes wrong btrfs Major and Minor Ids reported in /proc/self/mountinfo.
0000000000000000000000000000000000000000;;			// instead of using values from /proc/self/mountinfo we use stat to get Ids from btrfs mount point
0000000000000000000000000000000000000000;;			if mount.Fstype == "btrfs" && mount.Major == 0 && strings.HasPrefix(mount.Source, "/dev/") {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				buf := new(syscall.Stat_t)
0000000000000000000000000000000000000000;;				err := syscall.Stat(mount.Source, buf)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("stat failed on %s with error: %s", mount.Source, err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					glog.Infof("btrfs mount %#v", mount)
0000000000000000000000000000000000000000;;					if buf.Mode&syscall.S_IFMT == syscall.S_IFBLK {
0000000000000000000000000000000000000000;;						err := syscall.Stat(mount.Mountpoint, buf)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							glog.Warningf("stat failed on %s with error: %s", mount.Mountpoint, err)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							glog.Infof("btrfs dev major:minor %d:%d\n", int(major(buf.Dev)), int(minor(buf.Dev)))
0000000000000000000000000000000000000000;;							glog.Infof("btrfs rdev major:minor %d:%d\n", int(major(buf.Rdev)), int(minor(buf.Rdev)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							mount.Major = int(major(buf.Dev))
0000000000000000000000000000000000000000;;							mount.Minor = int(minor(buf.Dev))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			partitions[mount.Source] = partition{
0000000000000000000000000000000000000000;;				fsType:     mount.Fstype,
0000000000000000000000000000000000000000;;				mountpoint: mount.Mountpoint,
0000000000000000000000000000000000000000;;				major:      uint(mount.Major),
0000000000000000000000000000000000000000;;				minor:      uint(mount.Minor),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return partitions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDockerDeviceMapperInfo returns information about the devicemapper device and "partition" if
0000000000000000000000000000000000000000;;	// docker is using devicemapper for its storage driver. If a loopback device is being used, don't
0000000000000000000000000000000000000000;;	// return any information or error, as we want to report based on the actual partition where the
0000000000000000000000000000000000000000;;	// loopback file resides, inside of the loopback file itself.
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) getDockerDeviceMapperInfo(context DockerContext) (string, *partition, error) {
0000000000000000000000000000000000000000;;		if context.Driver != DeviceMapper.String() {
0000000000000000000000000000000000000000;;			return "", nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dataLoopFile := context.DriverStatus[dockerutil.DriverStatusDataLoopFile]
0000000000000000000000000000000000000000;;		if len(dataLoopFile) > 0 {
0000000000000000000000000000000000000000;;			return "", nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dev, major, minor, blockSize, err := dockerDMDevice(context.DriverStatus, self.dmsetup)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dev, &partition{
0000000000000000000000000000000000000000;;			fsType:    DeviceMapper.String(),
0000000000000000000000000000000000000000;;			major:     major,
0000000000000000000000000000000000000000;;			minor:     minor,
0000000000000000000000000000000000000000;;			blockSize: blockSize,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addSystemRootLabel attempts to determine which device contains the mount for /.
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) addSystemRootLabel(mounts []*mount.Info) {
0000000000000000000000000000000000000000;;		for _, m := range mounts {
0000000000000000000000000000000000000000;;			if m.Mountpoint == "/" {
0000000000000000000000000000000000000000;;				self.partitions[m.Source] = partition{
0000000000000000000000000000000000000000;;					fsType:     m.Fstype,
0000000000000000000000000000000000000000;;					mountpoint: m.Mountpoint,
0000000000000000000000000000000000000000;;					major:      uint(m.Major),
0000000000000000000000000000000000000000;;					minor:      uint(m.Minor),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				self.labels[LabelSystemRoot] = m.Source
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addDockerImagesLabel attempts to determine which device contains the mount for docker images.
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) addDockerImagesLabel(context Context, mounts []*mount.Info) {
0000000000000000000000000000000000000000;;		dockerDev, dockerPartition, err := self.getDockerDeviceMapperInfo(context.Docker)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Could not get Docker devicemapper device: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(dockerDev) > 0 && dockerPartition != nil {
0000000000000000000000000000000000000000;;			self.partitions[dockerDev] = *dockerPartition
0000000000000000000000000000000000000000;;			self.labels[LabelDockerImages] = dockerDev
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			self.updateContainerImagesPath(LabelDockerImages, mounts, getDockerImagePaths(context))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) addRktImagesLabel(context Context, mounts []*mount.Info) {
0000000000000000000000000000000000000000;;		if context.RktPath != "" {
0000000000000000000000000000000000000000;;			rktPath := context.RktPath
0000000000000000000000000000000000000000;;			rktImagesPaths := map[string]struct{}{
0000000000000000000000000000000000000000;;				"/": {},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for rktPath != "/" && rktPath != "." {
0000000000000000000000000000000000000000;;				rktImagesPaths[rktPath] = struct{}{}
0000000000000000000000000000000000000000;;				rktPath = filepath.Dir(rktPath)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			self.updateContainerImagesPath(LabelRktImages, mounts, rktImagesPaths)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate a list of possible mount points for docker image management from the docker root directory.
0000000000000000000000000000000000000000;;	// Right now, we look for each type of supported graph driver directories, but we can do better by parsing
0000000000000000000000000000000000000000;;	// some of the context from `docker info`.
0000000000000000000000000000000000000000;;	func getDockerImagePaths(context Context) map[string]struct{} {
0000000000000000000000000000000000000000;;		dockerImagePaths := map[string]struct{}{
0000000000000000000000000000000000000000;;			"/": {},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(rjnagal): Detect docker root and graphdriver directories from docker info.
0000000000000000000000000000000000000000;;		dockerRoot := context.Docker.Root
0000000000000000000000000000000000000000;;		for _, dir := range []string{"devicemapper", "btrfs", "aufs", "overlay", "overlay2", "zfs"} {
0000000000000000000000000000000000000000;;			dockerImagePaths[path.Join(dockerRoot, dir)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for dockerRoot != "/" && dockerRoot != "." {
0000000000000000000000000000000000000000;;			dockerImagePaths[dockerRoot] = struct{}{}
0000000000000000000000000000000000000000;;			dockerRoot = filepath.Dir(dockerRoot)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dockerImagePaths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This method compares the mountpoints with possible container image mount points. If a match is found,
0000000000000000000000000000000000000000;;	// the label is added to the partition.
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) updateContainerImagesPath(label string, mounts []*mount.Info, containerImagePaths map[string]struct{}) {
0000000000000000000000000000000000000000;;		var useMount *mount.Info
0000000000000000000000000000000000000000;;		for _, m := range mounts {
0000000000000000000000000000000000000000;;			if _, ok := containerImagePaths[m.Mountpoint]; ok {
0000000000000000000000000000000000000000;;				if useMount == nil || (len(useMount.Mountpoint) < len(m.Mountpoint)) {
0000000000000000000000000000000000000000;;					useMount = m
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if useMount != nil {
0000000000000000000000000000000000000000;;			self.partitions[useMount.Source] = partition{
0000000000000000000000000000000000000000;;				fsType:     useMount.Fstype,
0000000000000000000000000000000000000000;;				mountpoint: useMount.Mountpoint,
0000000000000000000000000000000000000000;;				major:      uint(useMount.Major),
0000000000000000000000000000000000000000;;				minor:      uint(useMount.Minor),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			self.labels[label] = useMount.Source
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetDeviceForLabel(label string) (string, error) {
0000000000000000000000000000000000000000;;		dev, ok := self.labels[label]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("non-existent label %q", label)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dev, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetLabelsForDevice(device string) ([]string, error) {
0000000000000000000000000000000000000000;;		labels := []string{}
0000000000000000000000000000000000000000;;		for label, dev := range self.labels {
0000000000000000000000000000000000000000;;			if dev == device {
0000000000000000000000000000000000000000;;				labels = append(labels, label)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetMountpointForDevice(dev string) (string, error) {
0000000000000000000000000000000000000000;;		p, ok := self.partitions[dev]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("no partition info for device %q", dev)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.mountpoint, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetFsInfoForPath(mountSet map[string]struct{}) ([]Fs, error) {
0000000000000000000000000000000000000000;;		filesystems := make([]Fs, 0)
0000000000000000000000000000000000000000;;		deviceSet := make(map[string]struct{})
0000000000000000000000000000000000000000;;		diskStatsMap, err := getDiskStatsMap("/proc/diskstats")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for device, partition := range self.partitions {
0000000000000000000000000000000000000000;;			_, hasMount := mountSet[partition.mountpoint]
0000000000000000000000000000000000000000;;			_, hasDevice := deviceSet[device]
0000000000000000000000000000000000000000;;			if mountSet == nil || (hasMount && !hasDevice) {
0000000000000000000000000000000000000000;;				var (
0000000000000000000000000000000000000000;;					err error
0000000000000000000000000000000000000000;;					fs  Fs
0000000000000000000000000000000000000000;;				)
0000000000000000000000000000000000000000;;				switch partition.fsType {
0000000000000000000000000000000000000000;;				case DeviceMapper.String():
0000000000000000000000000000000000000000;;					fs.Capacity, fs.Free, fs.Available, err = getDMStats(device, partition.blockSize)
0000000000000000000000000000000000000000;;					glog.V(5).Infof("got devicemapper fs capacity stats: capacity: %v free: %v available: %v:", fs.Capacity, fs.Free, fs.Available)
0000000000000000000000000000000000000000;;					fs.Type = DeviceMapper
0000000000000000000000000000000000000000;;				case ZFS.String():
0000000000000000000000000000000000000000;;					fs.Capacity, fs.Free, fs.Available, err = getZfstats(device)
0000000000000000000000000000000000000000;;					fs.Type = ZFS
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					var inodes, inodesFree uint64
0000000000000000000000000000000000000000;;					fs.Capacity, fs.Free, fs.Available, inodes, inodesFree, err = getVfsStats(partition.mountpoint)
0000000000000000000000000000000000000000;;					fs.Inodes = &inodes
0000000000000000000000000000000000000000;;					fs.InodesFree = &inodesFree
0000000000000000000000000000000000000000;;					fs.Type = VFS
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Stat fs failed. Error: %v", err)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					deviceSet[device] = struct{}{}
0000000000000000000000000000000000000000;;					fs.DeviceInfo = DeviceInfo{
0000000000000000000000000000000000000000;;						Device: device,
0000000000000000000000000000000000000000;;						Major:  uint(partition.major),
0000000000000000000000000000000000000000;;						Minor:  uint(partition.minor),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					fs.DiskStats = diskStatsMap[device]
0000000000000000000000000000000000000000;;					filesystems = append(filesystems, fs)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return filesystems, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var partitionRegex = regexp.MustCompile(`^(?:(?:s|v|xv)d[a-z]+\d*|dm-\d+)$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDiskStatsMap(diskStatsFile string) (map[string]DiskStats, error) {
0000000000000000000000000000000000000000;;		diskStatsMap := make(map[string]DiskStats)
0000000000000000000000000000000000000000;;		file, err := os.Open(diskStatsFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;				glog.Infof("not collecting filesystem statistics because file %q was not available", diskStatsFile)
0000000000000000000000000000000000000000;;				return diskStatsMap, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(file)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			line := scanner.Text()
0000000000000000000000000000000000000000;;			words := strings.Fields(line)
0000000000000000000000000000000000000000;;			if !partitionRegex.MatchString(words[2]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// 8      50 sdd2 40 0 280 223 7 0 22 108 0 330 330
0000000000000000000000000000000000000000;;			deviceName := path.Join("/dev", words[2])
0000000000000000000000000000000000000000;;			wordLength := len(words)
0000000000000000000000000000000000000000;;			offset := 3
0000000000000000000000000000000000000000;;			var stats = make([]uint64, wordLength-offset)
0000000000000000000000000000000000000000;;			if len(stats) < 11 {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse all 11 columns of /proc/diskstats")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var error error
0000000000000000000000000000000000000000;;			for i := offset; i < wordLength; i++ {
0000000000000000000000000000000000000000;;				stats[i-offset], error = strconv.ParseUint(words[i], 10, 64)
0000000000000000000000000000000000000000;;				if error != nil {
0000000000000000000000000000000000000000;;					return nil, error
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			diskStats := DiskStats{
0000000000000000000000000000000000000000;;				ReadsCompleted:  stats[0],
0000000000000000000000000000000000000000;;				ReadsMerged:     stats[1],
0000000000000000000000000000000000000000;;				SectorsRead:     stats[2],
0000000000000000000000000000000000000000;;				ReadTime:        stats[3],
0000000000000000000000000000000000000000;;				WritesCompleted: stats[4],
0000000000000000000000000000000000000000;;				WritesMerged:    stats[5],
0000000000000000000000000000000000000000;;				SectorsWritten:  stats[6],
0000000000000000000000000000000000000000;;				WriteTime:       stats[7],
0000000000000000000000000000000000000000;;				IoInProgress:    stats[8],
0000000000000000000000000000000000000000;;				IoTime:          stats[9],
0000000000000000000000000000000000000000;;				WeightedIoTime:  stats[10],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			diskStatsMap[deviceName] = diskStats
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return diskStatsMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetGlobalFsInfo() ([]Fs, error) {
0000000000000000000000000000000000000000;;		return self.GetFsInfoForPath(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func major(devNumber uint64) uint {
0000000000000000000000000000000000000000;;		return uint((devNumber >> 8) & 0xfff)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func minor(devNumber uint64) uint {
0000000000000000000000000000000000000000;;		return uint((devNumber & 0xff) | ((devNumber >> 12) & 0xfff00))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetDirFsDevice(dir string) (*DeviceInfo, error) {
0000000000000000000000000000000000000000;;		buf := new(syscall.Stat_t)
0000000000000000000000000000000000000000;;		err := syscall.Stat(dir, buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("stat failed on %s with error: %s", dir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		major := major(buf.Dev)
0000000000000000000000000000000000000000;;		minor := minor(buf.Dev)
0000000000000000000000000000000000000000;;		for device, partition := range self.partitions {
0000000000000000000000000000000000000000;;			if partition.major == major && partition.minor == minor {
0000000000000000000000000000000000000000;;				return &DeviceInfo{device, major, minor}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("could not find device with major: %d, minor: %d in cached partitions map", major, minor)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetDirDiskUsage(dir string, timeout time.Duration) (uint64, error) {
0000000000000000000000000000000000000000;;		claimToken()
0000000000000000000000000000000000000000;;		defer releaseToken()
0000000000000000000000000000000000000000;;		return GetDirDiskUsage(dir, timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetDirDiskUsage(dir string, timeout time.Duration) (uint64, error) {
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid directory")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cmd := exec.Command("nice", "-n", "19", "du", "-s", dir)
0000000000000000000000000000000000000000;;		stdoutp, err := cmd.StdoutPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to setup stdout for cmd %v - %v", cmd.Args, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stderrp, err := cmd.StderrPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to setup stderr for cmd %v - %v", cmd.Args, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := cmd.Start(); err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to exec du - %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timer := time.AfterFunc(timeout, func() {
0000000000000000000000000000000000000000;;			glog.Infof("killing cmd %v due to timeout(%s)", cmd.Args, timeout.String())
0000000000000000000000000000000000000000;;			cmd.Process.Kill()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		stdoutb, souterr := ioutil.ReadAll(stdoutp)
0000000000000000000000000000000000000000;;		if souterr != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("failed to read from stdout for cmd %v - %v", cmd.Args, souterr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stderrb, _ := ioutil.ReadAll(stderrp)
0000000000000000000000000000000000000000;;		err = cmd.Wait()
0000000000000000000000000000000000000000;;		timer.Stop()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("du command failed on %s with output stdout: %s, stderr: %s - %v", dir, string(stdoutb), string(stderrb), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		stdout := string(stdoutb)
0000000000000000000000000000000000000000;;		usageInKb, err := strconv.ParseUint(strings.Fields(stdout)[0], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("cannot parse 'du' output %s - %s", stdout, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return usageInKb * 1024, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *RealFsInfo) GetDirInodeUsage(dir string, timeout time.Duration) (uint64, error) {
0000000000000000000000000000000000000000;;		claimToken()
0000000000000000000000000000000000000000;;		defer releaseToken()
0000000000000000000000000000000000000000;;		return GetDirInodeUsage(dir, timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetDirInodeUsage(dir string, timeout time.Duration) (uint64, error) {
0000000000000000000000000000000000000000;;		if dir == "" {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("invalid directory")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var counter byteCounter
0000000000000000000000000000000000000000;;		var stderr bytes.Buffer
0000000000000000000000000000000000000000;;		findCmd := exec.Command("find", dir, "-xdev", "-printf", ".")
0000000000000000000000000000000000000000;;		findCmd.Stdout, findCmd.Stderr = &counter, &stderr
0000000000000000000000000000000000000000;;		if err := findCmd.Start(); err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to exec cmd %v - %v; stderr: %v", findCmd.Args, err, stderr.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timer := time.AfterFunc(timeout, func() {
0000000000000000000000000000000000000000;;			glog.Infof("killing cmd %v due to timeout(%s)", findCmd.Args, timeout.String())
0000000000000000000000000000000000000000;;			findCmd.Process.Kill()
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err := findCmd.Wait(); err != nil {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("cmd %v failed. stderr: %s; err: %v", findCmd.Args, stderr.String(), err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		timer.Stop()
0000000000000000000000000000000000000000;;		return counter.bytesWritten, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVfsStats(path string) (total uint64, free uint64, avail uint64, inodes uint64, inodesFree uint64, err error) {
0000000000000000000000000000000000000000;;		var s syscall.Statfs_t
0000000000000000000000000000000000000000;;		if err = syscall.Statfs(path, &s); err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		total = uint64(s.Frsize) * s.Blocks
0000000000000000000000000000000000000000;;		free = uint64(s.Frsize) * s.Bfree
0000000000000000000000000000000000000000;;		avail = uint64(s.Frsize) * s.Bavail
0000000000000000000000000000000000000000;;		inodes = uint64(s.Files)
0000000000000000000000000000000000000000;;		inodesFree = uint64(s.Ffree)
0000000000000000000000000000000000000000;;		return total, free, avail, inodes, inodesFree, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Devicemapper thin provisioning is detailed at
0000000000000000000000000000000000000000;;	// https://www.kernel.org/doc/Documentation/device-mapper/thin-provisioning.txt
0000000000000000000000000000000000000000;;	func dockerDMDevice(driverStatus map[string]string, dmsetup devicemapper.DmsetupClient) (string, uint, uint, uint, error) {
0000000000000000000000000000000000000000;;		poolName, ok := driverStatus[dockerutil.DriverStatusPoolName]
0000000000000000000000000000000000000000;;		if !ok || len(poolName) == 0 {
0000000000000000000000000000000000000000;;			return "", 0, 0, 0, fmt.Errorf("Could not get dm pool name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out, err := dmsetup.Table(poolName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		major, minor, dataBlkSize, err := parseDMTable(string(out))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return poolName, major, minor, dataBlkSize, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseDMTable parses a single line of `dmsetup table` output and returns the
0000000000000000000000000000000000000000;;	// major device, minor device, block size, and an error.
0000000000000000000000000000000000000000;;	func parseDMTable(dmTable string) (uint, uint, uint, error) {
0000000000000000000000000000000000000000;;		dmTable = strings.Replace(dmTable, ":", " ", -1)
0000000000000000000000000000000000000000;;		dmFields := strings.Fields(dmTable)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dmFields) < 8 {
0000000000000000000000000000000000000000;;			return 0, 0, 0, fmt.Errorf("Invalid dmsetup status output: %s", dmTable)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		major, err := strconv.ParseUint(dmFields[5], 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		minor, err := strconv.ParseUint(dmFields[6], 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dataBlkSize, err := strconv.ParseUint(dmFields[7], 10, 32)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return uint(major), uint(minor), uint(dataBlkSize), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getDMStats(poolName string, dataBlkSize uint) (uint64, uint64, uint64, error) {
0000000000000000000000000000000000000000;;		out, err := exec.Command("dmsetup", "status", poolName).Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		used, total, err := parseDMStatus(string(out))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		used *= 512 * uint64(dataBlkSize)
0000000000000000000000000000000000000000;;		total *= 512 * uint64(dataBlkSize)
0000000000000000000000000000000000000000;;		free := total - used
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return total, free, free, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseDMStatus(dmStatus string) (uint64, uint64, error) {
0000000000000000000000000000000000000000;;		dmStatus = strings.Replace(dmStatus, "/", " ", -1)
0000000000000000000000000000000000000000;;		dmFields := strings.Fields(dmStatus)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dmFields) < 8 {
0000000000000000000000000000000000000000;;			return 0, 0, fmt.Errorf("Invalid dmsetup status output: %s", dmStatus)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		used, err := strconv.ParseUint(dmFields[6], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		total, err := strconv.ParseUint(dmFields[7], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return used, total, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getZfstats returns ZFS mount stats using zfsutils
0000000000000000000000000000000000000000;;	func getZfstats(poolName string) (uint64, uint64, uint64, error) {
0000000000000000000000000000000000000000;;		dataset, err := zfs.GetDataset(poolName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, 0, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		total := dataset.Used + dataset.Avail + dataset.Usedbydataset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return total, dataset.Avail, dataset.Avail, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Simple io.Writer implementation that counts how many bytes were written.
0000000000000000000000000000000000000000;;	type byteCounter struct{ bytesWritten uint64 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *byteCounter) Write(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		b.bytesWritten += uint64(len(p))
0000000000000000000000000000000000000000;;		return len(p), nil
0000000000000000000000000000000000000000;;	}
