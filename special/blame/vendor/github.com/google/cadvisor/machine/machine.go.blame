0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
e2a368d09bfda52d5970d2d9e3fd645b4eddb58b;Godeps/_workspace/src/github.com/google/cadvisor/utils/machine/machine.go[Godeps/_workspace/src/github.com/google/cadvisor/utils/machine/machine.go][vendor/github.com/google/cadvisor/machine/machine.go];	
0000000000000000000000000000000000000000;;	// The machine package contains functions that extract machine-level specs.
0000000000000000000000000000000000000000;;	package machine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// s390/s390x changes
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/sysfs"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/sysinfo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		cpuRegExp  = regexp.MustCompile(`^processor\s*:\s*([0-9]+)$`)
0000000000000000000000000000000000000000;;		coreRegExp = regexp.MustCompile(`^core id\s*:\s*([0-9]+)$`)
0000000000000000000000000000000000000000;;		nodeRegExp = regexp.MustCompile(`^physical id\s*:\s*([0-9]+)$`)
0000000000000000000000000000000000000000;;		// Power systems have a different format so cater for both
0000000000000000000000000000000000000000;;		cpuClockSpeedMHz     = regexp.MustCompile(`(?:cpu MHz|clock)\s*:\s*([0-9]+\.[0-9]+)(?:MHz)?`)
0000000000000000000000000000000000000000;;		memoryCapacityRegexp = regexp.MustCompile(`MemTotal:\s*([0-9]+) kB`)
0000000000000000000000000000000000000000;;		swapCapacityRegexp   = regexp.MustCompile(`SwapTotal:\s*([0-9]+) kB`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxFreqFile = "/sys/devices/system/cpu/cpu0/cpufreq/cpuinfo_max_freq"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetClockSpeed returns the CPU clock speed, given a []byte formatted as the /proc/cpuinfo file.
0000000000000000000000000000000000000000;;	func GetClockSpeed(procInfo []byte) (uint64, error) {
0000000000000000000000000000000000000000;;		// s390/s390x, aarch64 and arm32 changes
0000000000000000000000000000000000000000;;		if isSystemZ() || isAArch64() || isArm32() {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First look through sys to find a max supported cpu frequency.
0000000000000000000000000000000000000000;;		if utils.FileExists(maxFreqFile) {
0000000000000000000000000000000000000000;;			val, err := ioutil.ReadFile(maxFreqFile)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var maxFreq uint64
0000000000000000000000000000000000000000;;			n, err := fmt.Sscanf(string(val), "%d", &maxFreq)
0000000000000000000000000000000000000000;;			if err != nil || n != 1 {
0000000000000000000000000000000000000000;;				return 0, fmt.Errorf("could not parse frequency %q", val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return maxFreq, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Fall back to /proc/cpuinfo
0000000000000000000000000000000000000000;;		matches := cpuClockSpeedMHz.FindSubmatch(procInfo)
0000000000000000000000000000000000000000;;		if len(matches) != 2 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("could not detect clock speed from output: %q", string(procInfo))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		speed, err := strconv.ParseFloat(string(matches[1]), 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Convert to kHz
0000000000000000000000000000000000000000;;		return uint64(speed * 1000), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMachineMemoryCapacity returns the machine's total memory from /proc/meminfo.
0000000000000000000000000000000000000000;;	// Returns the total memory capacity as an uint64 (number of bytes).
0000000000000000000000000000000000000000;;	func GetMachineMemoryCapacity() (uint64, error) {
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile("/proc/meminfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		memoryCapacity, err := parseCapacity(out, memoryCapacityRegexp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return memoryCapacity, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMachineSwapCapacity returns the machine's total swap from /proc/meminfo.
0000000000000000000000000000000000000000;;	// Returns the total swap capacity as an uint64 (number of bytes).
0000000000000000000000000000000000000000;;	func GetMachineSwapCapacity() (uint64, error) {
0000000000000000000000000000000000000000;;		out, err := ioutil.ReadFile("/proc/meminfo")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		swapCapacity, err := parseCapacity(out, swapCapacityRegexp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return swapCapacity, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseCapacity matches a Regexp in a []byte, returning the resulting value in bytes.
0000000000000000000000000000000000000000;;	// Assumes that the value matched by the Regexp is in KB.
0000000000000000000000000000000000000000;;	func parseCapacity(b []byte, r *regexp.Regexp) (uint64, error) {
0000000000000000000000000000000000000000;;		matches := r.FindSubmatch(b)
0000000000000000000000000000000000000000;;		if len(matches) != 2 {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("failed to match regexp in output: %q", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m, err := strconv.ParseUint(string(matches[1]), 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert to bytes.
0000000000000000000000000000000000000000;;		return m * 1024, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GetTopology(sysFs sysfs.SysFs, cpuinfo string) ([]info.Node, int, error) {
0000000000000000000000000000000000000000;;		nodes := []info.Node{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// s390/s390x changes
0000000000000000000000000000000000000000;;		if true == isSystemZ() {
0000000000000000000000000000000000000000;;			return nodes, getNumCores(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		numCores := 0
0000000000000000000000000000000000000000;;		lastThread := -1
0000000000000000000000000000000000000000;;		lastCore := -1
0000000000000000000000000000000000000000;;		lastNode := -1
0000000000000000000000000000000000000000;;		for _, line := range strings.Split(cpuinfo, "\n") {
0000000000000000000000000000000000000000;;			if line == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ok, val, err := extractValue(line, cpuRegExp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, -1, fmt.Errorf("could not parse cpu info from %q: %v", line, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				thread := val
0000000000000000000000000000000000000000;;				numCores++
0000000000000000000000000000000000000000;;				if lastThread != -1 {
0000000000000000000000000000000000000000;;					// New cpu section. Save last one.
0000000000000000000000000000000000000000;;					nodeIdx, err := addNode(&nodes, lastNode)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, -1, fmt.Errorf("failed to add node %d: %v", lastNode, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					nodes[nodeIdx].AddThread(lastThread, lastCore)
0000000000000000000000000000000000000000;;					lastCore = -1
0000000000000000000000000000000000000000;;					lastNode = -1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lastThread = thread
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ok, val, err = extractValue(line, coreRegExp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, -1, fmt.Errorf("could not parse core info from %q: %v", line, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				lastCore = val
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ok, val, err = extractValue(line, nodeRegExp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, -1, fmt.Errorf("could not parse node info from %q: %v", line, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				lastNode = val
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodeIdx, err := addNode(&nodes, lastNode)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, -1, fmt.Errorf("failed to add node %d: %v", lastNode, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nodes[nodeIdx].AddThread(lastThread, lastCore)
0000000000000000000000000000000000000000;;		if numCores < 1 {
0000000000000000000000000000000000000000;;			return nil, numCores, fmt.Errorf("could not detect any cores")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for idx, node := range nodes {
0000000000000000000000000000000000000000;;			caches, err := sysinfo.GetCacheInfo(sysFs, node.Cores[0].Threads[0])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("failed to get cache information for node %d: %v", node.Id, err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			numThreadsPerCore := len(node.Cores[0].Threads)
0000000000000000000000000000000000000000;;			numThreadsPerNode := len(node.Cores) * numThreadsPerCore
0000000000000000000000000000000000000000;;			for _, cache := range caches {
0000000000000000000000000000000000000000;;				c := info.Cache{
0000000000000000000000000000000000000000;;					Size:  cache.Size,
0000000000000000000000000000000000000000;;					Level: cache.Level,
0000000000000000000000000000000000000000;;					Type:  cache.Type,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if cache.Cpus == numThreadsPerNode && cache.Level > 2 {
0000000000000000000000000000000000000000;;					// Add a node-level cache.
0000000000000000000000000000000000000000;;					nodes[idx].AddNodeCache(c)
0000000000000000000000000000000000000000;;				} else if cache.Cpus == numThreadsPerCore {
0000000000000000000000000000000000000000;;					// Add to each core.
0000000000000000000000000000000000000000;;					nodes[idx].AddPerCoreCache(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Ignore unknown caches.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes, numCores, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extractValue(s string, r *regexp.Regexp) (bool, int, error) {
0000000000000000000000000000000000000000;;		matches := r.FindSubmatch([]byte(s))
0000000000000000000000000000000000000000;;		if len(matches) == 2 {
0000000000000000000000000000000000000000;;			val, err := strconv.ParseInt(string(matches[1]), 10, 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, -1, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, int(val), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, -1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findNode(nodes []info.Node, id int) (bool, int) {
0000000000000000000000000000000000000000;;		for i, n := range nodes {
0000000000000000000000000000000000000000;;			if n.Id == id {
0000000000000000000000000000000000000000;;				return true, i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addNode(nodes *[]info.Node, id int) (int, error) {
0000000000000000000000000000000000000000;;		var idx int
0000000000000000000000000000000000000000;;		if id == -1 {
0000000000000000000000000000000000000000;;			// Some VMs don't fill topology data. Export single package.
0000000000000000000000000000000000000000;;			id = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ok, idx := findNode(*nodes, id)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// New node
0000000000000000000000000000000000000000;;			node := info.Node{Id: id}
0000000000000000000000000000000000000000;;			// Add per-node memory information.
0000000000000000000000000000000000000000;;			meminfo := fmt.Sprintf("/sys/devices/system/node/node%d/meminfo", id)
0000000000000000000000000000000000000000;;			out, err := ioutil.ReadFile(meminfo)
0000000000000000000000000000000000000000;;			// Ignore if per-node info is not available.
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				m, err := parseCapacity(out, memoryCapacityRegexp)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return -1, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				node.Memory = uint64(m)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*nodes = append(*nodes, node)
0000000000000000000000000000000000000000;;			idx = len(*nodes) - 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return idx, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// s390/s390x changes
0000000000000000000000000000000000000000;;	func getMachineArch() (string, error) {
0000000000000000000000000000000000000000;;		uname := syscall.Utsname{}
0000000000000000000000000000000000000000;;		err := syscall.Uname(&uname)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var arch string
0000000000000000000000000000000000000000;;		for _, val := range uname.Machine {
0000000000000000000000000000000000000000;;			arch += string(int(val))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return arch, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// arm32 chanes
0000000000000000000000000000000000000000;;	func isArm32() bool {
0000000000000000000000000000000000000000;;		arch, err := getMachineArch()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return strings.Contains(arch, "arm")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// aarch64 changes
0000000000000000000000000000000000000000;;	func isAArch64() bool {
0000000000000000000000000000000000000000;;		arch, err := getMachineArch()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return strings.Contains(arch, "aarch64")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// s390/s390x changes
0000000000000000000000000000000000000000;;	func isSystemZ() bool {
0000000000000000000000000000000000000000;;		arch, err := getMachineArch()
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return strings.Contains(arch, "390")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// s390/s390x changes
0000000000000000000000000000000000000000;;	func getNumCores() int {
0000000000000000000000000000000000000000;;		maxProcs := runtime.GOMAXPROCS(0)
0000000000000000000000000000000000000000;;		numCPU := runtime.NumCPU()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if maxProcs < numCPU {
0000000000000000000000000000000000000000;;			return maxProcs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return numCPU
0000000000000000000000000000000000000000;;	}
