0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/manager/machine.go[Godeps/_workspace/src/github.com/google/cadvisor/manager/machine.go][vendor/github.com/google/cadvisor/machine/info.go];	
0000000000000000000000000000000000000000;;	package machine
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/cloudinfo"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/sysfs"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/sysinfo"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var machineIdFilePath = flag.String("machine_id_file", "/etc/machine-id,/var/lib/dbus/machine-id", "Comma-separated list of files to check for machine-id. Use the first one that exists.")
0000000000000000000000000000000000000000;;	var bootIdFilePath = flag.String("boot_id_file", "/proc/sys/kernel/random/boot_id", "Comma-separated list of files to check for boot-id. Use the first one that exists.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getInfoFromFiles(filePaths string) string {
0000000000000000000000000000000000000000;;		if len(filePaths) == 0 {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, file := range strings.Split(filePaths, ",") {
0000000000000000000000000000000000000000;;			id, err := ioutil.ReadFile(file)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return strings.TrimSpace(string(id))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Couldn't collect info from any of the files in %q", filePaths)
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Info(sysFs sysfs.SysFs, fsInfo fs.FsInfo, inHostNamespace bool) (*info.MachineInfo, error) {
0000000000000000000000000000000000000000;;		rootFs := "/"
0000000000000000000000000000000000000000;;		if !inHostNamespace {
0000000000000000000000000000000000000000;;			rootFs = "/rootfs"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cpuinfo, err := ioutil.ReadFile(filepath.Join(rootFs, "/proc/cpuinfo"))
0000000000000000000000000000000000000000;;		clockSpeed, err := GetClockSpeed(cpuinfo)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		memoryCapacity, err := GetMachineMemoryCapacity()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		filesystems, err := fsInfo.GetGlobalFsInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get global filesystem information: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		diskMap, err := sysinfo.GetBlockDeviceInfo(sysFs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get disk map: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netDevices, err := sysinfo.GetNetworkDevices(sysFs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get network devices: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		topology, numCores, err := GetTopology(sysFs, string(cpuinfo))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get topology information: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		systemUUID, err := sysinfo.GetSystemUUID(sysFs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Failed to get system UUID: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		realCloudInfo := cloudinfo.NewRealCloudInfo()
0000000000000000000000000000000000000000;;		cloudProvider := realCloudInfo.GetCloudProvider()
0000000000000000000000000000000000000000;;		instanceType := realCloudInfo.GetInstanceType()
0000000000000000000000000000000000000000;;		instanceID := realCloudInfo.GetInstanceID()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		machineInfo := &info.MachineInfo{
0000000000000000000000000000000000000000;;			NumCores:       numCores,
0000000000000000000000000000000000000000;;			CpuFrequency:   clockSpeed,
0000000000000000000000000000000000000000;;			MemoryCapacity: memoryCapacity,
0000000000000000000000000000000000000000;;			DiskMap:        diskMap,
0000000000000000000000000000000000000000;;			NetworkDevices: netDevices,
0000000000000000000000000000000000000000;;			Topology:       topology,
0000000000000000000000000000000000000000;;			MachineID:      getInfoFromFiles(filepath.Join(rootFs, *machineIdFilePath)),
0000000000000000000000000000000000000000;;			SystemUUID:     systemUUID,
0000000000000000000000000000000000000000;;			BootID:         getInfoFromFiles(filepath.Join(rootFs, *bootIdFilePath)),
0000000000000000000000000000000000000000;;			CloudProvider:  cloudProvider,
0000000000000000000000000000000000000000;;			InstanceType:   instanceType,
0000000000000000000000000000000000000000;;			InstanceID:     instanceID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range filesystems {
0000000000000000000000000000000000000000;;			fs := filesystems[i]
0000000000000000000000000000000000000000;;			inodes := uint64(0)
0000000000000000000000000000000000000000;;			if fs.Inodes != nil {
0000000000000000000000000000000000000000;;				inodes = *fs.Inodes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			machineInfo.Filesystems = append(machineInfo.Filesystems, info.FsInfo{Device: fs.Device, DeviceMajor: uint64(fs.Major), DeviceMinor: uint64(fs.Minor), Type: fs.Type.String(), Capacity: fs.Capacity, Inodes: inodes, HasInodes: fs.Inodes != nil})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return machineInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ContainerOsVersion() string {
0000000000000000000000000000000000000000;;		container_os := "Unknown"
0000000000000000000000000000000000000000;;		os_release, err := ioutil.ReadFile("/etc/os-release")
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			// We might be running in a busybox or some hand-crafted image.
0000000000000000000000000000000000000000;;			// It's useful to know why cadvisor didn't come up.
0000000000000000000000000000000000000000;;			for _, line := range strings.Split(string(os_release), "\n") {
0000000000000000000000000000000000000000;;				parsed := strings.Split(line, "\"")
0000000000000000000000000000000000000000;;				if len(parsed) == 3 && parsed[0] == "PRETTY_NAME=" {
0000000000000000000000000000000000000000;;					container_os = parsed[1]
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return container_os
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func KernelVersion() string {
0000000000000000000000000000000000000000;;		uname := &syscall.Utsname{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := syscall.Uname(uname); err != nil {
0000000000000000000000000000000000000000;;			return "Unknown"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		release := make([]byte, len(uname.Release))
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for _, c := range uname.Release {
0000000000000000000000000000000000000000;;			release[i] = byte(c)
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		release = release[:bytes.IndexByte(release, 0)]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(release)
0000000000000000000000000000000000000000;;	}
