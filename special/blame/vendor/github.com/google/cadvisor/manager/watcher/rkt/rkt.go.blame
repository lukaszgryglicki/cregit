0000000000000000000000000000000000000000;;	// Copyright 2016 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a93fc00f9e3e99c0b1e06ca1ecb0ad623862f330;;	
0000000000000000000000000000000000000000;;	// Package rkt implements the watcher interface for rkt
0000000000000000000000000000000000000000;;	package rkt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/rkt"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager/watcher"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rktapi "github.com/coreos/rkt/api/v1alpha"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rktContainerWatcher struct {
0000000000000000000000000000000000000000;;		// Signal for watcher thread to stop.
0000000000000000000000000000000000000000;;		stopWatcher chan error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRktContainerWatcher() (watcher.ContainerWatcher, error) {
0000000000000000000000000000000000000000;;		watcher := &rktContainerWatcher{
0000000000000000000000000000000000000000;;			stopWatcher: make(chan error),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return watcher, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rktContainerWatcher) Start(events chan watcher.ContainerEvent) error {
0000000000000000000000000000000000000000;;		go self.detectRktContainers(events)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rktContainerWatcher) Stop() error {
0000000000000000000000000000000000000000;;		// Rendezvous with the watcher thread.
0000000000000000000000000000000000000000;;		self.stopWatcher <- nil
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rktContainerWatcher) detectRktContainers(events chan watcher.ContainerEvent) {
0000000000000000000000000000000000000000;;		glog.Infof("starting detectRktContainers thread")
0000000000000000000000000000000000000000;;		ticker := time.Tick(10 * time.Second)
0000000000000000000000000000000000000000;;		curpods := make(map[string]*rktapi.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ticker:
0000000000000000000000000000000000000000;;				pods, err := listRunningPods()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("detectRktContainers: listRunningPods failed: %v", err)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				curpods = self.syncRunningPods(pods, events, curpods)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case <-self.stopWatcher:
0000000000000000000000000000000000000000;;				glog.Infof("Exiting rktContainer Thread")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rktContainerWatcher) syncRunningPods(pods []*rktapi.Pod, events chan watcher.ContainerEvent, curpods map[string]*rktapi.Pod) map[string]*rktapi.Pod {
0000000000000000000000000000000000000000;;		newpods := make(map[string]*rktapi.Pod)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pod := range pods {
0000000000000000000000000000000000000000;;			newpods[pod.Id] = pod
0000000000000000000000000000000000000000;;			// if pods become mutable, have to handle this better
0000000000000000000000000000000000000000;;			if _, ok := curpods[pod.Id]; !ok {
0000000000000000000000000000000000000000;;				// should create all cgroups not including system.slice
0000000000000000000000000000000000000000;;				// i.e. /system.slice/rkt-test.service and /system.slice/rkt-test.service/system.slice/pause.service
0000000000000000000000000000000000000000;;				for _, cgroup := range podToCgroup(pod) {
0000000000000000000000000000000000000000;;					self.sendUpdateEvent(cgroup, events)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for id, pod := range curpods {
0000000000000000000000000000000000000000;;			if _, ok := newpods[id]; !ok {
0000000000000000000000000000000000000000;;				for _, cgroup := range podToCgroup(pod) {
0000000000000000000000000000000000000000;;					glog.Infof("cgroup to delete = %v", cgroup)
0000000000000000000000000000000000000000;;					self.sendDestroyEvent(cgroup, events)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return newpods
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rktContainerWatcher) sendUpdateEvent(cgroup string, events chan watcher.ContainerEvent) {
0000000000000000000000000000000000000000;;		events <- watcher.ContainerEvent{
0000000000000000000000000000000000000000;;			EventType:   watcher.ContainerAdd,
0000000000000000000000000000000000000000;;			Name:        cgroup,
0000000000000000000000000000000000000000;;			WatchSource: watcher.Rkt,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rktContainerWatcher) sendDestroyEvent(cgroup string, events chan watcher.ContainerEvent) {
0000000000000000000000000000000000000000;;		events <- watcher.ContainerEvent{
0000000000000000000000000000000000000000;;			EventType:   watcher.ContainerDelete,
0000000000000000000000000000000000000000;;			Name:        cgroup,
0000000000000000000000000000000000000000;;			WatchSource: watcher.Rkt,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func listRunningPods() ([]*rktapi.Pod, error) {
0000000000000000000000000000000000000000;;		client, err := rkt.Client()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := client.ListPods(context.Background(), &rktapi.ListPodsRequest{
0000000000000000000000000000000000000000;;			// Specify the request: Fetch and print only running pods and their details.
0000000000000000000000000000000000000000;;			Detail: true,
0000000000000000000000000000000000000000;;			Filters: []*rktapi.PodFilter{
0000000000000000000000000000000000000000;;				{
0000000000000000000000000000000000000000;;					States: []rktapi.PodState{rktapi.PodState_POD_STATE_RUNNING},
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return resp.Pods, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func podToCgroup(pod *rktapi.Pod) []string {
0000000000000000000000000000000000000000;;		cgroups := make([]string, 1+len(pod.Apps), 1+len(pod.Apps))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		baseCgroup := pod.Cgroup
0000000000000000000000000000000000000000;;		cgroups[0] = baseCgroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, app := range pod.Apps {
0000000000000000000000000000000000000000;;			cgroups[i+1] = filepath.Join(baseCgroup, "system.slice", app.Name+".service")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cgroups
0000000000000000000000000000000000000000;;	}
