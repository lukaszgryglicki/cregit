0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
a93fc00f9e3e99c0b1e06ca1ecb0ad623862f330;;	
0000000000000000000000000000000000000000;;	// Package container defines types for sub-container events and also
0000000000000000000000000000000000000000;;	// defines an interface for container operation handlers.
0000000000000000000000000000000000000000;;	package raw
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/common"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/libcontainer"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager/watcher"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"golang.org/x/exp/inotify"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rawContainerWatcher struct {
0000000000000000000000000000000000000000;;		// Absolute path to the root of the cgroup hierarchies
0000000000000000000000000000000000000000;;		cgroupPaths map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cgroupSubsystems *libcontainer.CgroupSubsystems
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Inotify event watcher.
0000000000000000000000000000000000000000;;		watcher *common.InotifyWatcher
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Signal for watcher thread to stop.
0000000000000000000000000000000000000000;;		stopWatcher chan error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewRawContainerWatcher() (watcher.ContainerWatcher, error) {
0000000000000000000000000000000000000000;;		cgroupSubsystems, err := libcontainer.GetCgroupSubsystems()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to get cgroup subsystems: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cgroupSubsystems.Mounts) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to find supported cgroup mounts for the raw factory")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		watcher, err := common.NewInotifyWatcher()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawWatcher := &rawContainerWatcher{
0000000000000000000000000000000000000000;;			cgroupPaths:      common.MakeCgroupPaths(cgroupSubsystems.MountPoints, "/"),
0000000000000000000000000000000000000000;;			cgroupSubsystems: &cgroupSubsystems,
0000000000000000000000000000000000000000;;			watcher:          watcher,
0000000000000000000000000000000000000000;;			stopWatcher:      make(chan error),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rawWatcher, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerWatcher) Start(events chan watcher.ContainerEvent) error {
0000000000000000000000000000000000000000;;		// Watch this container (all its cgroups) and all subdirectories.
0000000000000000000000000000000000000000;;		for _, cgroupPath := range self.cgroupPaths {
0000000000000000000000000000000000000000;;			_, err := self.watchDirectory(cgroupPath, "/")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Process the events received from the kernel.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case event := <-self.watcher.Event():
0000000000000000000000000000000000000000;;					err := self.processEvent(event, events)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Warningf("Error while processing event (%+v): %v", event, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case err := <-self.watcher.Error():
0000000000000000000000000000000000000000;;					glog.Warningf("Error while watching %q:", "/", err)
0000000000000000000000000000000000000000;;				case <-self.stopWatcher:
0000000000000000000000000000000000000000;;					err := self.watcher.Close()
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						self.stopWatcher <- err
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerWatcher) Stop() error {
0000000000000000000000000000000000000000;;		// Rendezvous with the watcher thread.
0000000000000000000000000000000000000000;;		self.stopWatcher <- nil
0000000000000000000000000000000000000000;;		return <-self.stopWatcher
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watches the specified directory and all subdirectories. Returns whether the path was
0000000000000000000000000000000000000000;;	// already being watched and an error (if any).
0000000000000000000000000000000000000000;;	func (self *rawContainerWatcher) watchDirectory(dir string, containerName string) (bool, error) {
0000000000000000000000000000000000000000;;		alreadyWatching, err := self.watcher.AddWatch(containerName, dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return alreadyWatching, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the watch if further operations failed.
0000000000000000000000000000000000000000;;		cleanup := true
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if cleanup {
0000000000000000000000000000000000000000;;				_, err := self.watcher.RemoveWatch(containerName, dir)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Warningf("Failed to remove inotify watch for %q: %v", dir, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(vmarmol): We should re-do this once we're done to ensure directories were not added in the meantime.
0000000000000000000000000000000000000000;;		// Watch subdirectories as well.
0000000000000000000000000000000000000000;;		entries, err := ioutil.ReadDir(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return alreadyWatching, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, entry := range entries {
0000000000000000000000000000000000000000;;			if entry.IsDir() {
0000000000000000000000000000000000000000;;				entryPath := path.Join(dir, entry.Name())
0000000000000000000000000000000000000000;;				_, err = self.watchDirectory(entryPath, path.Join(containerName, entry.Name()))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to watch directory %q: %v", entryPath, err)
0000000000000000000000000000000000000000;;					if os.IsNotExist(err) {
0000000000000000000000000000000000000000;;						// The directory may have been removed before watching. Try to watch the other
0000000000000000000000000000000000000000;;						// subdirectories. (https://github.com/kubernetes/kubernetes/issues/28997)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return alreadyWatching, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cleanup = false
0000000000000000000000000000000000000000;;		return alreadyWatching, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *rawContainerWatcher) processEvent(event *inotify.Event, events chan watcher.ContainerEvent) error {
0000000000000000000000000000000000000000;;		// Convert the inotify event type to a container create or delete.
0000000000000000000000000000000000000000;;		var eventType watcher.ContainerEventType
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case (event.Mask & inotify.IN_CREATE) > 0:
0000000000000000000000000000000000000000;;			eventType = watcher.ContainerAdd
0000000000000000000000000000000000000000;;		case (event.Mask & inotify.IN_DELETE) > 0:
0000000000000000000000000000000000000000;;			eventType = watcher.ContainerDelete
0000000000000000000000000000000000000000;;		case (event.Mask & inotify.IN_MOVED_FROM) > 0:
0000000000000000000000000000000000000000;;			eventType = watcher.ContainerDelete
0000000000000000000000000000000000000000;;		case (event.Mask & inotify.IN_MOVED_TO) > 0:
0000000000000000000000000000000000000000;;			eventType = watcher.ContainerAdd
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// Ignore other events.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Derive the container name from the path name.
0000000000000000000000000000000000000000;;		var containerName string
0000000000000000000000000000000000000000;;		for _, mount := range self.cgroupSubsystems.Mounts {
0000000000000000000000000000000000000000;;			mountLocation := path.Clean(mount.Mountpoint) + "/"
0000000000000000000000000000000000000000;;			if strings.HasPrefix(event.Name, mountLocation) {
0000000000000000000000000000000000000000;;				containerName = event.Name[len(mountLocation)-1:]
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if containerName == "" {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unable to detect container from watch event on directory %q", event.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maintain the watch for the new or deleted container.
0000000000000000000000000000000000000000;;		switch eventType {
0000000000000000000000000000000000000000;;		case watcher.ContainerAdd:
0000000000000000000000000000000000000000;;			// New container was created, watch it.
0000000000000000000000000000000000000000;;			alreadyWatched, err := self.watchDirectory(event.Name, containerName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only report container creation once.
0000000000000000000000000000000000000000;;			if alreadyWatched {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case watcher.ContainerDelete:
0000000000000000000000000000000000000000;;			// Container was deleted, stop watching for it.
0000000000000000000000000000000000000000;;			lastWatched, err := self.watcher.RemoveWatch(containerName, event.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Only report container deletion once.
0000000000000000000000000000000000000000;;			if !lastWatched {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unknown event type %v", eventType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deliver the event.
0000000000000000000000000000000000000000;;		events <- watcher.ContainerEvent{
0000000000000000000000000000000000000000;;			EventType:   eventType,
0000000000000000000000000000000000000000;;			Name:        containerName,
0000000000000000000000000000000000000000;;			WatchSource: watcher.Raw,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
