0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/manager/container.go[Godeps/_workspace/src/github.com/google/cadvisor/manager/container.go][vendor/github.com/google/cadvisor/manager/container.go];	
0000000000000000000000000000000000000000;;	package manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"os/exec"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/cache/memory"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/collector"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/summary"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/cpuload"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		units "github.com/docker/go-units"
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Housekeeping interval.
0000000000000000000000000000000000000000;;	var enableLoadReader = flag.Bool("enable_load_reader", false, "Whether to enable cpu load reader")
0000000000000000000000000000000000000000;;	var HousekeepingInterval = flag.Duration("housekeeping_interval", 1*time.Second, "Interval between container housekeepings")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var cgroupPathRegExp = regexp.MustCompile(`devices[^:]*:(.*?)[,;$]`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerInfo struct {
0000000000000000000000000000000000000000;;		info.ContainerReference
0000000000000000000000000000000000000000;;		Subcontainers []info.ContainerReference
0000000000000000000000000000000000000000;;		Spec          info.ContainerSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type containerData struct {
0000000000000000000000000000000000000000;;		handler                  container.ContainerHandler
0000000000000000000000000000000000000000;;		info                     containerInfo
0000000000000000000000000000000000000000;;		memoryCache              *memory.InMemoryCache
0000000000000000000000000000000000000000;;		lock                     sync.Mutex
0000000000000000000000000000000000000000;;		loadReader               cpuload.CpuLoadReader
0000000000000000000000000000000000000000;;		summaryReader            *summary.StatsSummary
0000000000000000000000000000000000000000;;		loadAvg                  float64 // smoothed load average seen so far.
0000000000000000000000000000000000000000;;		housekeepingInterval     time.Duration
0000000000000000000000000000000000000000;;		maxHousekeepingInterval  time.Duration
0000000000000000000000000000000000000000;;		allowDynamicHousekeeping bool
0000000000000000000000000000000000000000;;		lastUpdatedTime          time.Time
0000000000000000000000000000000000000000;;		lastErrorTime            time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Decay value used for load average smoothing. Interval length of 10 seconds is used.
0000000000000000000000000000000000000000;;		loadDecay float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Whether to log the usage of this container when it is updated.
0000000000000000000000000000000000000000;;		logUsage bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tells the container to stop.
0000000000000000000000000000000000000000;;		stop chan bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Runs custom metric collectors.
0000000000000000000000000000000000000000;;		collectorManager collector.CollectorManager
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// jitter returns a time.Duration between duration and duration + maxFactor * duration,
0000000000000000000000000000000000000000;;	// to allow clients to avoid converging on periodic behavior.  If maxFactor is 0.0, a
0000000000000000000000000000000000000000;;	// suggested default value will be chosen.
0000000000000000000000000000000000000000;;	func jitter(duration time.Duration, maxFactor float64) time.Duration {
0000000000000000000000000000000000000000;;		if maxFactor <= 0.0 {
0000000000000000000000000000000000000000;;			maxFactor = 1.0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wait := duration + time.Duration(rand.Float64()*maxFactor*float64(duration))
0000000000000000000000000000000000000000;;		return wait
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) Start() error {
0000000000000000000000000000000000000000;;		go c.housekeeping()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) Stop() error {
0000000000000000000000000000000000000000;;		err := c.memoryCache.RemoveContainer(c.info.Name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.stop <- true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) allowErrorLogging() bool {
0000000000000000000000000000000000000000;;		if time.Since(c.lastErrorTime) > time.Minute {
0000000000000000000000000000000000000000;;			c.lastErrorTime = time.Now()
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) GetInfo() (*containerInfo, error) {
0000000000000000000000000000000000000000;;		// Get spec and subcontainers.
0000000000000000000000000000000000000000;;		if time.Since(c.lastUpdatedTime) > 5*time.Second {
0000000000000000000000000000000000000000;;			err := c.updateSpec()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = c.updateSubcontainers()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.lastUpdatedTime = time.Now()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Make a copy of the info for the user.
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		return &c.info, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) DerivedStats() (v2.DerivedStats, error) {
0000000000000000000000000000000000000000;;		if c.summaryReader == nil {
0000000000000000000000000000000000000000;;			return v2.DerivedStats{}, fmt.Errorf("derived stats not enabled for container %q", c.info.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.summaryReader.DerivedStats()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) getCgroupPath(cgroups string) (string, error) {
0000000000000000000000000000000000000000;;		if cgroups == "-" {
0000000000000000000000000000000000000000;;			return "/", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matches := cgroupPathRegExp.FindSubmatch([]byte(cgroups))
0000000000000000000000000000000000000000;;		if len(matches) != 2 {
0000000000000000000000000000000000000000;;			glog.V(3).Infof("failed to get devices cgroup path from %q", cgroups)
0000000000000000000000000000000000000000;;			// return root in case of failures - devices hierarchy might not be enabled.
0000000000000000000000000000000000000000;;			return "/", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(matches[1]), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns contents of a file inside the container root.
0000000000000000000000000000000000000000;;	// Takes in a path relative to container root.
0000000000000000000000000000000000000000;;	func (c *containerData) ReadFile(filepath string, inHostNamespace bool) ([]byte, error) {
0000000000000000000000000000000000000000;;		pids, err := c.getContainerPids(inHostNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(rjnagal): Optimize by just reading container's cgroup.proc file when in host namespace.
0000000000000000000000000000000000000000;;		rootfs := "/"
0000000000000000000000000000000000000000;;		if !inHostNamespace {
0000000000000000000000000000000000000000;;			rootfs = "/rootfs"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pid := range pids {
0000000000000000000000000000000000000000;;			filePath := path.Join(rootfs, "/proc", pid, "/root", filepath)
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Trying path %q", filePath)
0000000000000000000000000000000000000000;;			data, err := ioutil.ReadFile(filePath)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return data, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// No process paths could be found. Declare config non-existent.
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("file %q does not exist.", filepath)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return output for ps command in host /proc with specified format
0000000000000000000000000000000000000000;;	func (c *containerData) getPsOutput(inHostNamespace bool, format string) ([]byte, error) {
0000000000000000000000000000000000000000;;		args := []string{}
0000000000000000000000000000000000000000;;		command := "ps"
0000000000000000000000000000000000000000;;		if !inHostNamespace {
0000000000000000000000000000000000000000;;			command = "/usr/sbin/chroot"
0000000000000000000000000000000000000000;;			args = append(args, "/rootfs", "ps")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		args = append(args, "-e", "-o", format)
0000000000000000000000000000000000000000;;		out, err := exec.Command(command, args...).Output()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to execute %q command: %v", command, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get pids of processes in this container.
0000000000000000000000000000000000000000;;	// A slightly lighterweight call than GetProcessList if other details are not required.
0000000000000000000000000000000000000000;;	func (c *containerData) getContainerPids(inHostNamespace bool) ([]string, error) {
0000000000000000000000000000000000000000;;		format := "pid,cgroup"
0000000000000000000000000000000000000000;;		out, err := c.getPsOutput(inHostNamespace, format)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFields := 2
0000000000000000000000000000000000000000;;		lines := strings.Split(string(out), "\n")
0000000000000000000000000000000000000000;;		pids := []string{}
0000000000000000000000000000000000000000;;		for _, line := range lines[1:] {
0000000000000000000000000000000000000000;;			if len(line) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Fields(line)
0000000000000000000000000000000000000000;;			if len(fields) < expectedFields {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expected at least %d fields, found %d: output: %q", expectedFields, len(fields), line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pid := fields[0]
0000000000000000000000000000000000000000;;			cgroup, err := c.getCgroupPath(fields[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse cgroup path from %q: %v", fields[1], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.info.Name == cgroup {
0000000000000000000000000000000000000000;;				pids = append(pids, pid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pids, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) GetProcessList(cadvisorContainer string, inHostNamespace bool) ([]v2.ProcessInfo, error) {
0000000000000000000000000000000000000000;;		// report all processes for root.
0000000000000000000000000000000000000000;;		isRoot := c.info.Name == "/"
0000000000000000000000000000000000000000;;		format := "user,pid,ppid,stime,pcpu,pmem,rss,vsz,stat,time,comm,cgroup"
0000000000000000000000000000000000000000;;		out, err := c.getPsOutput(inHostNamespace, format)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expectedFields := 12
0000000000000000000000000000000000000000;;		processes := []v2.ProcessInfo{}
0000000000000000000000000000000000000000;;		lines := strings.Split(string(out), "\n")
0000000000000000000000000000000000000000;;		for _, line := range lines[1:] {
0000000000000000000000000000000000000000;;			if len(line) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fields := strings.Fields(line)
0000000000000000000000000000000000000000;;			if len(fields) < expectedFields {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expected at least %d fields, found %d: output: %q", expectedFields, len(fields), line)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pid, err := strconv.Atoi(fields[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid pid %q: %v", fields[1], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ppid, err := strconv.Atoi(fields[2])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid ppid %q: %v", fields[2], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			percentCpu, err := strconv.ParseFloat(fields[4], 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid cpu percent %q: %v", fields[4], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			percentMem, err := strconv.ParseFloat(fields[5], 32)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid memory percent %q: %v", fields[5], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rss, err := strconv.ParseUint(fields[6], 0, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid rss %q: %v", fields[6], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// convert to bytes
0000000000000000000000000000000000000000;;			rss *= 1024
0000000000000000000000000000000000000000;;			vs, err := strconv.ParseUint(fields[7], 0, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("invalid virtual size %q: %v", fields[7], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// convert to bytes
0000000000000000000000000000000000000000;;			vs *= 1024
0000000000000000000000000000000000000000;;			cgroup, err := c.getCgroupPath(fields[11])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("could not parse cgroup path from %q: %v", fields[11], err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Remove the ps command we just ran from cadvisor container.
0000000000000000000000000000000000000000;;			// Not necessary, but makes the cadvisor page look cleaner.
0000000000000000000000000000000000000000;;			if !inHostNamespace && cadvisorContainer == cgroup && fields[10] == "ps" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var cgroupPath string
0000000000000000000000000000000000000000;;			if isRoot {
0000000000000000000000000000000000000000;;				cgroupPath = cgroup
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isRoot || c.info.Name == cgroup {
0000000000000000000000000000000000000000;;				processes = append(processes, v2.ProcessInfo{
0000000000000000000000000000000000000000;;					User:          fields[0],
0000000000000000000000000000000000000000;;					Pid:           pid,
0000000000000000000000000000000000000000;;					Ppid:          ppid,
0000000000000000000000000000000000000000;;					StartTime:     fields[3],
0000000000000000000000000000000000000000;;					PercentCpu:    float32(percentCpu),
0000000000000000000000000000000000000000;;					PercentMemory: float32(percentMem),
0000000000000000000000000000000000000000;;					RSS:           rss,
0000000000000000000000000000000000000000;;					VirtualSize:   vs,
0000000000000000000000000000000000000000;;					Status:        fields[8],
0000000000000000000000000000000000000000;;					RunningTime:   fields[9],
0000000000000000000000000000000000000000;;					Cmd:           fields[10],
0000000000000000000000000000000000000000;;					CgroupPath:    cgroupPath,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return processes, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newContainerData(containerName string, memoryCache *memory.InMemoryCache, handler container.ContainerHandler, logUsage bool, collectorManager collector.CollectorManager, maxHousekeepingInterval time.Duration, allowDynamicHousekeeping bool) (*containerData, error) {
0000000000000000000000000000000000000000;;		if memoryCache == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("nil memory storage")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if handler == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("nil container handler")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ref, err := handler.ContainerReference()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cont := &containerData{
0000000000000000000000000000000000000000;;			handler:                  handler,
0000000000000000000000000000000000000000;;			memoryCache:              memoryCache,
0000000000000000000000000000000000000000;;			housekeepingInterval:     *HousekeepingInterval,
0000000000000000000000000000000000000000;;			maxHousekeepingInterval:  maxHousekeepingInterval,
0000000000000000000000000000000000000000;;			allowDynamicHousekeeping: allowDynamicHousekeeping,
0000000000000000000000000000000000000000;;			logUsage:                 logUsage,
0000000000000000000000000000000000000000;;			loadAvg:                  -1.0, // negative value indicates uninitialized.
0000000000000000000000000000000000000000;;			stop:                     make(chan bool, 1),
0000000000000000000000000000000000000000;;			collectorManager:         collectorManager,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cont.info.ContainerReference = ref
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cont.loadDecay = math.Exp(float64(-cont.housekeepingInterval.Seconds() / 10))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if *enableLoadReader {
0000000000000000000000000000000000000000;;			// Create cpu load reader.
0000000000000000000000000000000000000000;;			loadReader, err := cpuload.New()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// TODO(rjnagal): Promote to warning once we support cpu load inside namespaces.
0000000000000000000000000000000000000000;;				glog.Infof("Could not initialize cpu load reader for %q: %s", ref.Name, err)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cont.loadReader = loadReader
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = cont.updateSpec()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cont.summaryReader, err = summary.New(cont.info.Spec)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			cont.summaryReader = nil
0000000000000000000000000000000000000000;;			glog.Warningf("Failed to create summary reader for %q: %v", ref.Name, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cont, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Determine when the next housekeeping should occur.
0000000000000000000000000000000000000000;;	func (self *containerData) nextHousekeeping(lastHousekeeping time.Time) time.Time {
0000000000000000000000000000000000000000;;		if self.allowDynamicHousekeeping {
0000000000000000000000000000000000000000;;			var empty time.Time
0000000000000000000000000000000000000000;;			stats, err := self.memoryCache.RecentStats(self.info.Name, empty, empty, 2)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if self.allowErrorLogging() {
0000000000000000000000000000000000000000;;					glog.Warningf("Failed to get RecentStats(%q) while determining the next housekeeping: %v", self.info.Name, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if len(stats) == 2 {
0000000000000000000000000000000000000000;;				// TODO(vishnuk): Use no processes as a signal.
0000000000000000000000000000000000000000;;				// Raise the interval if usage hasn't changed in the last housekeeping.
0000000000000000000000000000000000000000;;				if stats[0].StatsEq(stats[1]) && (self.housekeepingInterval < self.maxHousekeepingInterval) {
0000000000000000000000000000000000000000;;					self.housekeepingInterval *= 2
0000000000000000000000000000000000000000;;					if self.housekeepingInterval > self.maxHousekeepingInterval {
0000000000000000000000000000000000000000;;						self.housekeepingInterval = self.maxHousekeepingInterval
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if self.housekeepingInterval != *HousekeepingInterval {
0000000000000000000000000000000000000000;;					// Lower interval back to the baseline.
0000000000000000000000000000000000000000;;					self.housekeepingInterval = *HousekeepingInterval
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lastHousekeeping.Add(jitter(self.housekeepingInterval, 1.0))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(vmarmol): Implement stats collecting as a custom collector.
0000000000000000000000000000000000000000;;	func (c *containerData) housekeeping() {
0000000000000000000000000000000000000000;;		// Start any background goroutines - must be cleaned up in c.handler.Cleanup().
0000000000000000000000000000000000000000;;		c.handler.Start()
0000000000000000000000000000000000000000;;		defer c.handler.Cleanup()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize cpuload reader - must be cleaned up in c.loadReader.Stop()
0000000000000000000000000000000000000000;;		if c.loadReader != nil {
0000000000000000000000000000000000000000;;			err := c.loadReader.Start()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Could not start cpu load stat collector for %q: %s", c.info.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer c.loadReader.Stop()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Long housekeeping is either 100ms or half of the housekeeping interval.
0000000000000000000000000000000000000000;;		longHousekeeping := 100 * time.Millisecond
0000000000000000000000000000000000000000;;		if *HousekeepingInterval/2 < longHousekeeping {
0000000000000000000000000000000000000000;;			longHousekeeping = *HousekeepingInterval / 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Housekeep every second.
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Start housekeeping for container %q\n", c.info.Name)
0000000000000000000000000000000000000000;;		lastHousekeeping := time.Now()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-c.stop:
0000000000000000000000000000000000000000;;				// Stop housekeeping when signaled.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// Perform housekeeping.
0000000000000000000000000000000000000000;;				start := time.Now()
0000000000000000000000000000000000000000;;				c.housekeepingTick()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Log if housekeeping took too long.
0000000000000000000000000000000000000000;;				duration := time.Since(start)
0000000000000000000000000000000000000000;;				if duration >= longHousekeeping {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("[%s] Housekeeping took %s", c.info.Name, duration)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Log usage if asked to do so.
0000000000000000000000000000000000000000;;			if c.logUsage {
0000000000000000000000000000000000000000;;				const numSamples = 60
0000000000000000000000000000000000000000;;				var empty time.Time
0000000000000000000000000000000000000000;;				stats, err := c.memoryCache.RecentStats(c.info.Name, empty, empty, numSamples)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					if c.allowErrorLogging() {
0000000000000000000000000000000000000000;;						glog.Infof("[%s] Failed to get recent stats for logging usage: %v", c.info.Name, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if len(stats) < numSamples {
0000000000000000000000000000000000000000;;					// Ignore, not enough stats yet.
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					usageCpuNs := uint64(0)
0000000000000000000000000000000000000000;;					for i := range stats {
0000000000000000000000000000000000000000;;						if i > 0 {
0000000000000000000000000000000000000000;;							usageCpuNs += (stats[i].Cpu.Usage.Total - stats[i-1].Cpu.Usage.Total)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					usageMemory := stats[numSamples-1].Memory.Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					instantUsageInCores := float64(stats[numSamples-1].Cpu.Usage.Total-stats[numSamples-2].Cpu.Usage.Total) / float64(stats[numSamples-1].Timestamp.Sub(stats[numSamples-2].Timestamp).Nanoseconds())
0000000000000000000000000000000000000000;;					usageInCores := float64(usageCpuNs) / float64(stats[numSamples-1].Timestamp.Sub(stats[0].Timestamp).Nanoseconds())
0000000000000000000000000000000000000000;;					usageInHuman := units.HumanSize(float64(usageMemory))
0000000000000000000000000000000000000000;;					glog.Infof("[%s] %.3f cores (average: %.3f cores), %s of memory", c.info.Name, instantUsageInCores, usageInCores, usageInHuman)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			next := c.nextHousekeeping(lastHousekeeping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Schedule the next housekeeping. Sleep until that time.
0000000000000000000000000000000000000000;;			if time.Now().Before(next) {
0000000000000000000000000000000000000000;;				time.Sleep(next.Sub(time.Now()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				next = time.Now()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastHousekeeping = next
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) housekeepingTick() {
0000000000000000000000000000000000000000;;		err := c.updateStats()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if c.allowErrorLogging() {
0000000000000000000000000000000000000000;;				glog.Infof("Failed to update stats for container \"%s\": %s", c.info.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) updateSpec() error {
0000000000000000000000000000000000000000;;		spec, err := c.handler.GetSpec()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Ignore errors if the container is dead.
0000000000000000000000000000000000000000;;			if !c.handler.Exists() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		customMetrics, err := c.collectorManager.GetSpec()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(customMetrics) > 0 {
0000000000000000000000000000000000000000;;			spec.HasCustomMetrics = true
0000000000000000000000000000000000000000;;			spec.CustomMetrics = customMetrics
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.info.Spec = spec
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Calculate new smoothed load average using the new sample of runnable threads.
0000000000000000000000000000000000000000;;	// The decay used ensures that the load will stabilize on a new constant value within
0000000000000000000000000000000000000000;;	// 10 seconds.
0000000000000000000000000000000000000000;;	func (c *containerData) updateLoad(newLoad uint64) {
0000000000000000000000000000000000000000;;		if c.loadAvg < 0 {
0000000000000000000000000000000000000000;;			c.loadAvg = float64(newLoad) // initialize to the first seen sample for faster stabilization.
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.loadAvg = c.loadAvg*c.loadDecay + float64(newLoad)*(1.0-c.loadDecay)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) updateStats() error {
0000000000000000000000000000000000000000;;		stats, statsErr := c.handler.GetStats()
0000000000000000000000000000000000000000;;		if statsErr != nil {
0000000000000000000000000000000000000000;;			// Ignore errors if the container is dead.
0000000000000000000000000000000000000000;;			if !c.handler.Exists() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Stats may be partially populated, push those before we return an error.
0000000000000000000000000000000000000000;;			statsErr = fmt.Errorf("%v, continuing to push stats", statsErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stats == nil {
0000000000000000000000000000000000000000;;			return statsErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.loadReader != nil {
0000000000000000000000000000000000000000;;			// TODO(vmarmol): Cache this path.
0000000000000000000000000000000000000000;;			path, err := c.handler.GetCgroupPath("cpu")
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				loadStats, err := c.loadReader.GetCpuLoad(c.info.Name, path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("failed to get load stat for %q - path %q, error %s", c.info.Name, path, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stats.TaskStats = loadStats
0000000000000000000000000000000000000000;;				c.updateLoad(loadStats.NrRunning)
0000000000000000000000000000000000000000;;				// convert to 'milliLoad' to avoid floats and preserve precision.
0000000000000000000000000000000000000000;;				stats.Cpu.LoadAverage = int32(c.loadAvg * 1000)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.summaryReader != nil {
0000000000000000000000000000000000000000;;			err := c.summaryReader.AddSample(*stats)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Ignore summary errors for now.
0000000000000000000000000000000000000000;;				glog.V(2).Infof("Failed to add summary stats for %q: %v", c.info.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var customStatsErr error
0000000000000000000000000000000000000000;;		cm := c.collectorManager.(*collector.GenericCollectorManager)
0000000000000000000000000000000000000000;;		if len(cm.Collectors) > 0 {
0000000000000000000000000000000000000000;;			if cm.NextCollectionTime.Before(time.Now()) {
0000000000000000000000000000000000000000;;				customStats, err := c.updateCustomStats()
0000000000000000000000000000000000000000;;				if customStats != nil {
0000000000000000000000000000000000000000;;					stats.CustomMetrics = customStats
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					customStatsErr = err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ref, err := c.handler.ContainerReference()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Ignore errors if the container is dead.
0000000000000000000000000000000000000000;;			if !c.handler.Exists() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = c.memoryCache.AddStats(ref, stats)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if statsErr != nil {
0000000000000000000000000000000000000000;;			return statsErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return customStatsErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) updateCustomStats() (map[string][]info.MetricVal, error) {
0000000000000000000000000000000000000000;;		_, customStats, customStatsErr := c.collectorManager.Collect()
0000000000000000000000000000000000000000;;		if customStatsErr != nil {
0000000000000000000000000000000000000000;;			if !c.handler.Exists() {
0000000000000000000000000000000000000000;;				return customStats, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			customStatsErr = fmt.Errorf("%v, continuing to push custom stats", customStatsErr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return customStats, customStatsErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *containerData) updateSubcontainers() error {
0000000000000000000000000000000000000000;;		var subcontainers info.ContainerReferenceSlice
0000000000000000000000000000000000000000;;		subcontainers, err := c.handler.ListContainers(container.ListSelf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Ignore errors if the container is dead.
0000000000000000000000000000000000000000;;			if !c.handler.Exists() {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(subcontainers)
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.info.Subcontainers = subcontainers
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
