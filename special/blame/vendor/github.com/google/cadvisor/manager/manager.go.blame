0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
d1c42c1e3fb3b408449f892c0d575bb4d9d885bd;Godeps/_workspace/src/github.com/google/cadvisor/manager/manager.go[Godeps/_workspace/src/github.com/google/cadvisor/manager/manager.go][vendor/github.com/google/cadvisor/manager/manager.go];	
0000000000000000000000000000000000000000;;	// Manager of cAdvisor-monitored containers.
0000000000000000000000000000000000000000;;	package manager
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/cache/memory"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/collector"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/docker"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/raw"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/rkt"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container/systemd"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/events"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/fs"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v2"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/machine"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager/watcher"
0000000000000000000000000000000000000000;;		rawwatcher "github.com/google/cadvisor/manager/watcher/raw"
0000000000000000000000000000000000000000;;		rktwatcher "github.com/google/cadvisor/manager/watcher/rkt"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/oomparser"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/utils/sysfs"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/version"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;		"github.com/opencontainers/runc/libcontainer/cgroups"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var globalHousekeepingInterval = flag.Duration("global_housekeeping_interval", 1*time.Minute, "Interval between global housekeepings")
0000000000000000000000000000000000000000;;	var logCadvisorUsage = flag.Bool("log_cadvisor_usage", false, "Whether to log the usage of the cAdvisor container")
0000000000000000000000000000000000000000;;	var eventStorageAgeLimit = flag.String("event_storage_age_limit", "default=24h", "Max length of time for which to store events (per type). Value is a comma separated list of key values, where the keys are event types (e.g.: creation, oom) or \"default\" and the value is a duration. Default is applied to all non-specified event types")
0000000000000000000000000000000000000000;;	var eventStorageEventLimit = flag.String("event_storage_event_limit", "default=100000", "Max number of events to store (per type). Value is a comma separated list of key values, where the keys are event types (e.g.: creation, oom) or \"default\" and the value is an integer. Default is applied to all non-specified event types")
0000000000000000000000000000000000000000;;	var applicationMetricsCountLimit = flag.Int("application_metrics_count_limit", 100, "Max number of application metrics to store (per container)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Manager interface defines operations for starting a manager and getting
0000000000000000000000000000000000000000;;	// container and machine information.
0000000000000000000000000000000000000000;;	type Manager interface {
0000000000000000000000000000000000000000;;		// Start the manager. Calling other manager methods before this returns
0000000000000000000000000000000000000000;;		// may produce undefined behavior.
0000000000000000000000000000000000000000;;		Start() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Stops the manager.
0000000000000000000000000000000000000000;;		Stop() error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		//  information about a container.
0000000000000000000000000000000000000000;;		GetContainerInfo(containerName string, query *info.ContainerInfoRequest) (*info.ContainerInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get V2 information about a container.
0000000000000000000000000000000000000000;;		// Recursive (subcontainer) requests are best-effort, and may return a partial result alongside an
0000000000000000000000000000000000000000;;		// error in the partial failure case.
0000000000000000000000000000000000000000;;		GetContainerInfoV2(containerName string, options v2.RequestOptions) (map[string]v2.ContainerInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get information about all subcontainers of the specified container (includes self).
0000000000000000000000000000000000000000;;		SubcontainersInfo(containerName string, query *info.ContainerInfoRequest) ([]*info.ContainerInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gets all the Docker containers. Return is a map from full container name to ContainerInfo.
0000000000000000000000000000000000000000;;		AllDockerContainers(query *info.ContainerInfoRequest) (map[string]info.ContainerInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gets information about a specific Docker container. The specified name is within the Docker namespace.
0000000000000000000000000000000000000000;;		DockerContainer(dockerName string, query *info.ContainerInfoRequest) (info.ContainerInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gets spec for all containers based on request options.
0000000000000000000000000000000000000000;;		GetContainerSpec(containerName string, options v2.RequestOptions) (map[string]v2.ContainerSpec, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Gets summary stats for all containers based on request options.
0000000000000000000000000000000000000000;;		GetDerivedStats(containerName string, options v2.RequestOptions) (map[string]v2.DerivedStats, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get info for all requested containers based on the request options.
0000000000000000000000000000000000000000;;		GetRequestedContainersInfo(containerName string, options v2.RequestOptions) (map[string]*info.ContainerInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns true if the named container exists.
0000000000000000000000000000000000000000;;		Exists(containerName string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get information about the machine.
0000000000000000000000000000000000000000;;		GetMachineInfo() (*info.MachineInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get version information about different components we depend on.
0000000000000000000000000000000000000000;;		GetVersionInfo() (*info.VersionInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get filesystem information for the filesystem that contains the given directory
0000000000000000000000000000000000000000;;		GetDirFsInfo(dir string) (v2.FsInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get filesystem information for a given label.
0000000000000000000000000000000000000000;;		// Returns information for all global filesystems if label is empty.
0000000000000000000000000000000000000000;;		GetFsInfo(label string) ([]v2.FsInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get ps output for a container.
0000000000000000000000000000000000000000;;		GetProcessList(containerName string, options v2.RequestOptions) ([]v2.ProcessInfo, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get events streamed through passedChannel that fit the request.
0000000000000000000000000000000000000000;;		WatchForEvents(request *events.Request) (*events.EventChannel, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get past events that have been detected and that fit the request.
0000000000000000000000000000000000000000;;		GetPastEvents(request *events.Request) ([]*info.Event, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CloseEventChannel(watch_id int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get status information about docker.
0000000000000000000000000000000000000000;;		DockerInfo() (info.DockerStatus, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get details about interesting docker images.
0000000000000000000000000000000000000000;;		DockerImages() ([]info.DockerImage, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Returns debugging information. Map of lines per category.
0000000000000000000000000000000000000000;;		DebugInfo() map[string][]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New takes a memory storage and returns a new manager.
0000000000000000000000000000000000000000;;	func New(memoryCache *memory.InMemoryCache, sysfs sysfs.SysFs, maxHousekeepingInterval time.Duration, allowDynamicHousekeeping bool, ignoreMetricsSet container.MetricSet, collectorHttpClient *http.Client) (Manager, error) {
0000000000000000000000000000000000000000;;		if memoryCache == nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("manager requires memory storage")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Detect the container we are running on.
0000000000000000000000000000000000000000;;		selfContainer, err := cgroups.GetThisCgroupDir("cpu")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("cAdvisor running in container: %q", selfContainer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dockerStatus, err := docker.Status()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Unable to connect to Docker: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rktPath, err := rkt.RktPath()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("unable to connect to Rkt api service: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context := fs.Context{
0000000000000000000000000000000000000000;;			Docker: fs.DockerContext{
0000000000000000000000000000000000000000;;				Root:         docker.RootDir(),
0000000000000000000000000000000000000000;;				Driver:       dockerStatus.Driver,
0000000000000000000000000000000000000000;;				DriverStatus: dockerStatus.DriverStatus,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			RktPath: rktPath,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fsInfo, err := fs.NewFsInfo(context)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If cAdvisor was started with host's rootfs mounted, assume that its running
0000000000000000000000000000000000000000;;		// in its own namespaces.
0000000000000000000000000000000000000000;;		inHostNamespace := false
0000000000000000000000000000000000000000;;		if _, err := os.Stat("/rootfs/proc"); os.IsNotExist(err) {
0000000000000000000000000000000000000000;;			inHostNamespace = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Register for new subcontainers.
0000000000000000000000000000000000000000;;		eventsChannel := make(chan watcher.ContainerEvent, 16)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newManager := &manager{
0000000000000000000000000000000000000000;;			containers:               make(map[namespacedContainerName]*containerData),
0000000000000000000000000000000000000000;;			quitChannels:             make([]chan error, 0, 2),
0000000000000000000000000000000000000000;;			memoryCache:              memoryCache,
0000000000000000000000000000000000000000;;			fsInfo:                   fsInfo,
0000000000000000000000000000000000000000;;			cadvisorContainer:        selfContainer,
0000000000000000000000000000000000000000;;			inHostNamespace:          inHostNamespace,
0000000000000000000000000000000000000000;;			startupTime:              time.Now(),
0000000000000000000000000000000000000000;;			maxHousekeepingInterval:  maxHousekeepingInterval,
0000000000000000000000000000000000000000;;			allowDynamicHousekeeping: allowDynamicHousekeeping,
0000000000000000000000000000000000000000;;			ignoreMetrics:            ignoreMetricsSet,
0000000000000000000000000000000000000000;;			containerWatchers:        []watcher.ContainerWatcher{},
0000000000000000000000000000000000000000;;			eventsChannel:            eventsChannel,
0000000000000000000000000000000000000000;;			collectorHttpClient:      collectorHttpClient,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		machineInfo, err := machine.Info(sysfs, fsInfo, inHostNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		newManager.machineInfo = *machineInfo
0000000000000000000000000000000000000000;;		glog.Infof("Machine: %+v", newManager.machineInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		versionInfo, err := getVersionInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Version: %+v", *versionInfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newManager.eventHandler = events.NewEventManager(parseEventsStoragePolicy())
0000000000000000000000000000000000000000;;		return newManager, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A namespaced container name.
0000000000000000000000000000000000000000;;	type namespacedContainerName struct {
0000000000000000000000000000000000000000;;		// The namespace of the container. Can be empty for the root namespace.
0000000000000000000000000000000000000000;;		Namespace string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The name of the container in this namespace.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type manager struct {
0000000000000000000000000000000000000000;;		containers               map[namespacedContainerName]*containerData
0000000000000000000000000000000000000000;;		containersLock           sync.RWMutex
0000000000000000000000000000000000000000;;		memoryCache              *memory.InMemoryCache
0000000000000000000000000000000000000000;;		fsInfo                   fs.FsInfo
0000000000000000000000000000000000000000;;		machineInfo              info.MachineInfo
0000000000000000000000000000000000000000;;		quitChannels             []chan error
0000000000000000000000000000000000000000;;		cadvisorContainer        string
0000000000000000000000000000000000000000;;		inHostNamespace          bool
0000000000000000000000000000000000000000;;		eventHandler             events.EventManager
0000000000000000000000000000000000000000;;		startupTime              time.Time
0000000000000000000000000000000000000000;;		maxHousekeepingInterval  time.Duration
0000000000000000000000000000000000000000;;		allowDynamicHousekeeping bool
0000000000000000000000000000000000000000;;		ignoreMetrics            container.MetricSet
0000000000000000000000000000000000000000;;		containerWatchers        []watcher.ContainerWatcher
0000000000000000000000000000000000000000;;		eventsChannel            chan watcher.ContainerEvent
0000000000000000000000000000000000000000;;		collectorHttpClient      *http.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Start the container manager.
0000000000000000000000000000000000000000;;	func (self *manager) Start() error {
0000000000000000000000000000000000000000;;		err := docker.Register(self, self.fsInfo, self.ignoreMetrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Docker container factory registration failed: %v.", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = rkt.Register(self, self.fsInfo, self.ignoreMetrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Registration of the rkt container factory failed: %v", err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			watcher, err := rktwatcher.NewRktContainerWatcher()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			self.containerWatchers = append(self.containerWatchers, watcher)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = systemd.Register(self, self.fsInfo, self.ignoreMetrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Registration of the systemd container factory failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = raw.Register(self, self.fsInfo, self.ignoreMetrics)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Errorf("Registration of the raw container factory failed: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawWatcher, err := rawwatcher.NewRawContainerWatcher()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self.containerWatchers = append(self.containerWatchers, rawWatcher)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Watch for OOMs.
0000000000000000000000000000000000000000;;		err = self.watchForNewOoms()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Warningf("Could not configure a source for OOM detection, disabling OOM events: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there are no factories, don't start any housekeeping and serve the information we do have.
0000000000000000000000000000000000000000;;		if !container.HasFactories() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create root and then recover all containers.
0000000000000000000000000000000000000000;;		err = self.createContainer("/", watcher.Raw)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Starting recovery of all containers")
0000000000000000000000000000000000000000;;		err = self.detectSubcontainers("/")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.Infof("Recovery completed")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Watch for new container.
0000000000000000000000000000000000000000;;		quitWatcher := make(chan error)
0000000000000000000000000000000000000000;;		err = self.watchForNewContainers(quitWatcher)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self.quitChannels = append(self.quitChannels, quitWatcher)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Look for new containers in the main housekeeping thread.
0000000000000000000000000000000000000000;;		quitGlobalHousekeeping := make(chan error)
0000000000000000000000000000000000000000;;		self.quitChannels = append(self.quitChannels, quitGlobalHousekeeping)
0000000000000000000000000000000000000000;;		go self.globalHousekeeping(quitGlobalHousekeeping)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) Stop() error {
0000000000000000000000000000000000000000;;		// Stop and wait on all quit channels.
0000000000000000000000000000000000000000;;		for i, c := range self.quitChannels {
0000000000000000000000000000000000000000;;			// Send the exit signal and wait on the thread to exit (by closing the channel).
0000000000000000000000000000000000000000;;			c <- nil
0000000000000000000000000000000000000000;;			err := <-c
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Remove the channels that quit successfully.
0000000000000000000000000000000000000000;;				self.quitChannels = self.quitChannels[i:]
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		self.quitChannels = make([]chan error, 0, 2)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) globalHousekeeping(quit chan error) {
0000000000000000000000000000000000000000;;		// Long housekeeping is either 100ms or half of the housekeeping interval.
0000000000000000000000000000000000000000;;		longHousekeeping := 100 * time.Millisecond
0000000000000000000000000000000000000000;;		if *globalHousekeepingInterval/2 < longHousekeeping {
0000000000000000000000000000000000000000;;			longHousekeeping = *globalHousekeepingInterval / 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ticker := time.Tick(*globalHousekeepingInterval)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case t := <-ticker:
0000000000000000000000000000000000000000;;				start := time.Now()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check for new containers.
0000000000000000000000000000000000000000;;				err := self.detectSubcontainers("/")
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("Failed to detect containers: %s", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Log if housekeeping took too long.
0000000000000000000000000000000000000000;;				duration := time.Since(start)
0000000000000000000000000000000000000000;;				if duration >= longHousekeeping {
0000000000000000000000000000000000000000;;					glog.V(3).Infof("Global Housekeeping(%d) took %s", t.Unix(), duration)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case <-quit:
0000000000000000000000000000000000000000;;				// Quit if asked to do so.
0000000000000000000000000000000000000000;;				quit <- nil
0000000000000000000000000000000000000000;;				glog.Infof("Exiting global housekeeping thread")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) getContainerData(containerName string) (*containerData, error) {
0000000000000000000000000000000000000000;;		var cont *containerData
0000000000000000000000000000000000000000;;		var ok bool
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			self.containersLock.RLock()
0000000000000000000000000000000000000000;;			defer self.containersLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Ensure we have the container.
0000000000000000000000000000000000000000;;			cont, ok = self.containers[namespacedContainerName{
0000000000000000000000000000000000000000;;				Name: containerName,
0000000000000000000000000000000000000000;;			}]
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown container %q", containerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cont, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) GetDerivedStats(containerName string, options v2.RequestOptions) (map[string]v2.DerivedStats, error) {
0000000000000000000000000000000000000000;;		conts, err := self.getRequestedContainers(containerName, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var errs partialFailure
0000000000000000000000000000000000000000;;		stats := make(map[string]v2.DerivedStats)
0000000000000000000000000000000000000000;;		for name, cont := range conts {
0000000000000000000000000000000000000000;;			d, err := cont.DerivedStats()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs.append(name, "DerivedStats", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			stats[name] = d
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return stats, errs.OrNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) GetContainerSpec(containerName string, options v2.RequestOptions) (map[string]v2.ContainerSpec, error) {
0000000000000000000000000000000000000000;;		conts, err := self.getRequestedContainers(containerName, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var errs partialFailure
0000000000000000000000000000000000000000;;		specs := make(map[string]v2.ContainerSpec)
0000000000000000000000000000000000000000;;		for name, cont := range conts {
0000000000000000000000000000000000000000;;			cinfo, err := cont.GetInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs.append(name, "GetInfo", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			spec := self.getV2Spec(cinfo)
0000000000000000000000000000000000000000;;			specs[name] = spec
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return specs, errs.OrNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get V2 container spec from v1 container info.
0000000000000000000000000000000000000000;;	func (self *manager) getV2Spec(cinfo *containerInfo) v2.ContainerSpec {
0000000000000000000000000000000000000000;;		spec := self.getAdjustedSpec(cinfo)
0000000000000000000000000000000000000000;;		return v2.ContainerSpecFromV1(&spec, cinfo.Aliases, cinfo.Namespace)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) getAdjustedSpec(cinfo *containerInfo) info.ContainerSpec {
0000000000000000000000000000000000000000;;		spec := cinfo.Spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set default value to an actual value
0000000000000000000000000000000000000000;;		if spec.HasMemory {
0000000000000000000000000000000000000000;;			// Memory.Limit is 0 means there's no limit
0000000000000000000000000000000000000000;;			if spec.Memory.Limit == 0 {
0000000000000000000000000000000000000000;;				spec.Memory.Limit = uint64(self.machineInfo.MemoryCapacity)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return spec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) GetContainerInfo(containerName string, query *info.ContainerInfoRequest) (*info.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		cont, err := self.getContainerData(containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return self.containerDataToContainerInfo(cont, query)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) GetContainerInfoV2(containerName string, options v2.RequestOptions) (map[string]v2.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		containers, err := self.getRequestedContainers(containerName, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errs partialFailure
0000000000000000000000000000000000000000;;		var nilTime time.Time // Ignored.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		infos := make(map[string]v2.ContainerInfo, len(containers))
0000000000000000000000000000000000000000;;		for name, container := range containers {
0000000000000000000000000000000000000000;;			result := v2.ContainerInfo{}
0000000000000000000000000000000000000000;;			cinfo, err := container.GetInfo()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs.append(name, "GetInfo", err)
0000000000000000000000000000000000000000;;				infos[name] = result
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result.Spec = self.getV2Spec(cinfo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			stats, err := self.memoryCache.RecentStats(name, nilTime, nilTime, options.Count)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs.append(name, "RecentStats", err)
0000000000000000000000000000000000000000;;				infos[name] = result
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			result.Stats = v2.ContainerStatsFromV1(containerName, &cinfo.Spec, stats)
0000000000000000000000000000000000000000;;			infos[name] = result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return infos, errs.OrNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) containerDataToContainerInfo(cont *containerData, query *info.ContainerInfoRequest) (*info.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		// Get the info from the container.
0000000000000000000000000000000000000000;;		cinfo, err := cont.GetInfo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		stats, err := self.memoryCache.RecentStats(cinfo.Name, query.Start, query.End, query.NumStats)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a copy of the info for the user.
0000000000000000000000000000000000000000;;		ret := &info.ContainerInfo{
0000000000000000000000000000000000000000;;			ContainerReference: cinfo.ContainerReference,
0000000000000000000000000000000000000000;;			Subcontainers:      cinfo.Subcontainers,
0000000000000000000000000000000000000000;;			Spec:               self.getAdjustedSpec(cinfo),
0000000000000000000000000000000000000000;;			Stats:              stats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) getContainer(containerName string) (*containerData, error) {
0000000000000000000000000000000000000000;;		self.containersLock.RLock()
0000000000000000000000000000000000000000;;		defer self.containersLock.RUnlock()
0000000000000000000000000000000000000000;;		cont, ok := self.containers[namespacedContainerName{Name: containerName}]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown container %q", containerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return cont, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) getSubcontainers(containerName string) map[string]*containerData {
0000000000000000000000000000000000000000;;		self.containersLock.RLock()
0000000000000000000000000000000000000000;;		defer self.containersLock.RUnlock()
0000000000000000000000000000000000000000;;		containersMap := make(map[string]*containerData, len(self.containers))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get all the unique subcontainers of the specified container
0000000000000000000000000000000000000000;;		matchedName := path.Join(containerName, "/")
0000000000000000000000000000000000000000;;		for i := range self.containers {
0000000000000000000000000000000000000000;;			name := self.containers[i].info.Name
0000000000000000000000000000000000000000;;			if name == containerName || strings.HasPrefix(name, matchedName) {
0000000000000000000000000000000000000000;;				containersMap[self.containers[i].info.Name] = self.containers[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containersMap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) SubcontainersInfo(containerName string, query *info.ContainerInfoRequest) ([]*info.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		containersMap := self.getSubcontainers(containerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		containers := make([]*containerData, 0, len(containersMap))
0000000000000000000000000000000000000000;;		for _, cont := range containersMap {
0000000000000000000000000000000000000000;;			containers = append(containers, cont)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return self.containerDataSliceToContainerInfoSlice(containers, query)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) getAllDockerContainers() map[string]*containerData {
0000000000000000000000000000000000000000;;		self.containersLock.RLock()
0000000000000000000000000000000000000000;;		defer self.containersLock.RUnlock()
0000000000000000000000000000000000000000;;		containers := make(map[string]*containerData, len(self.containers))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get containers in the Docker namespace.
0000000000000000000000000000000000000000;;		for name, cont := range self.containers {
0000000000000000000000000000000000000000;;			if name.Namespace == docker.DockerNamespace {
0000000000000000000000000000000000000000;;				containers[cont.info.Name] = cont
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containers
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) AllDockerContainers(query *info.ContainerInfoRequest) (map[string]info.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		containers := self.getAllDockerContainers()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		output := make(map[string]info.ContainerInfo, len(containers))
0000000000000000000000000000000000000000;;		for name, cont := range containers {
0000000000000000000000000000000000000000;;			inf, err := self.containerDataToContainerInfo(cont, query)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			output[name] = *inf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return output, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) getDockerContainer(containerName string) (*containerData, error) {
0000000000000000000000000000000000000000;;		self.containersLock.RLock()
0000000000000000000000000000000000000000;;		defer self.containersLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for the container in the Docker container namespace.
0000000000000000000000000000000000000000;;		cont, ok := self.containers[namespacedContainerName{
0000000000000000000000000000000000000000;;			Namespace: docker.DockerNamespace,
0000000000000000000000000000000000000000;;			Name:      containerName,
0000000000000000000000000000000000000000;;		}]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Look for container by short prefix name if no exact match found.
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			for contName, c := range self.containers {
0000000000000000000000000000000000000000;;				if contName.Namespace == docker.DockerNamespace && strings.HasPrefix(contName.Name, containerName) {
0000000000000000000000000000000000000000;;					if cont == nil {
0000000000000000000000000000000000000000;;						cont = c
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return nil, fmt.Errorf("unable to find container. Container %q is not unique", containerName)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if cont == nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unable to find Docker container %q", containerName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cont, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) DockerContainer(containerName string, query *info.ContainerInfoRequest) (info.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		container, err := self.getDockerContainer(containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return info.ContainerInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inf, err := self.containerDataToContainerInfo(container, query)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return info.ContainerInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return *inf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) containerDataSliceToContainerInfoSlice(containers []*containerData, query *info.ContainerInfoRequest) ([]*info.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		if len(containers) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("no containers found")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the info for each container.
0000000000000000000000000000000000000000;;		output := make([]*info.ContainerInfo, 0, len(containers))
0000000000000000000000000000000000000000;;		for i := range containers {
0000000000000000000000000000000000000000;;			cinfo, err := self.containerDataToContainerInfo(containers[i], query)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Skip containers with errors, we try to degrade gracefully.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			output = append(output, cinfo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) GetRequestedContainersInfo(containerName string, options v2.RequestOptions) (map[string]*info.ContainerInfo, error) {
0000000000000000000000000000000000000000;;		containers, err := self.getRequestedContainers(containerName, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var errs partialFailure
0000000000000000000000000000000000000000;;		containersMap := make(map[string]*info.ContainerInfo)
0000000000000000000000000000000000000000;;		query := info.ContainerInfoRequest{
0000000000000000000000000000000000000000;;			NumStats: options.Count,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for name, data := range containers {
0000000000000000000000000000000000000000;;			info, err := self.containerDataToContainerInfo(data, &query)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				errs.append(name, "containerDataToContainerInfo", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			containersMap[name] = info
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containersMap, errs.OrNil()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) getRequestedContainers(containerName string, options v2.RequestOptions) (map[string]*containerData, error) {
0000000000000000000000000000000000000000;;		containersMap := make(map[string]*containerData)
0000000000000000000000000000000000000000;;		switch options.IdType {
0000000000000000000000000000000000000000;;		case v2.TypeName:
0000000000000000000000000000000000000000;;			if options.Recursive == false {
0000000000000000000000000000000000000000;;				cont, err := self.getContainer(containerName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return containersMap, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containersMap[cont.info.Name] = cont
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				containersMap = self.getSubcontainers(containerName)
0000000000000000000000000000000000000000;;				if len(containersMap) == 0 {
0000000000000000000000000000000000000000;;					return containersMap, fmt.Errorf("unknown container: %q", containerName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case v2.TypeDocker:
0000000000000000000000000000000000000000;;			if options.Recursive == false {
0000000000000000000000000000000000000000;;				containerName = strings.TrimPrefix(containerName, "/")
0000000000000000000000000000000000000000;;				cont, err := self.getDockerContainer(containerName)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return containersMap, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containersMap[cont.info.Name] = cont
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if containerName != "/" {
0000000000000000000000000000000000000000;;					return containersMap, fmt.Errorf("invalid request for docker container %q with subcontainers", containerName)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				containersMap = self.getAllDockerContainers()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return containersMap, fmt.Errorf("invalid request type %q", options.IdType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return containersMap, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) GetDirFsInfo(dir string) (v2.FsInfo, error) {
0000000000000000000000000000000000000000;;		dirDevice, err := self.fsInfo.GetDirFsDevice(dir)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return v2.FsInfo{}, fmt.Errorf("error trying to get filesystem Device for dir %v: err: %v", dir, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dirMountpoint, err := self.fsInfo.GetMountpointForDevice(dirDevice.Device)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return v2.FsInfo{}, fmt.Errorf("error trying to get MountPoint for Root Device: %v, err: %v", dirDevice, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		infos, err := self.GetFsInfo("")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return v2.FsInfo{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, info := range infos {
0000000000000000000000000000000000000000;;			if info.Mountpoint == dirMountpoint {
0000000000000000000000000000000000000000;;				return info, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v2.FsInfo{}, fmt.Errorf("did not find fs info for dir: %v", dir)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) GetFsInfo(label string) ([]v2.FsInfo, error) {
0000000000000000000000000000000000000000;;		var empty time.Time
0000000000000000000000000000000000000000;;		// Get latest data from filesystems hanging off root container.
0000000000000000000000000000000000000000;;		stats, err := self.memoryCache.RecentStats("/", empty, empty, 1)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dev := ""
0000000000000000000000000000000000000000;;		if len(label) != 0 {
0000000000000000000000000000000000000000;;			dev, err = self.fsInfo.GetDeviceForLabel(label)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fsInfo := []v2.FsInfo{}
0000000000000000000000000000000000000000;;		for i := range stats[0].Filesystem {
0000000000000000000000000000000000000000;;			fs := stats[0].Filesystem[i]
0000000000000000000000000000000000000000;;			if len(label) != 0 && fs.Device != dev {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			mountpoint, err := self.fsInfo.GetMountpointForDevice(fs.Device)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			labels, err := self.fsInfo.GetLabelsForDevice(fs.Device)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fi := v2.FsInfo{
0000000000000000000000000000000000000000;;				Device:     fs.Device,
0000000000000000000000000000000000000000;;				Mountpoint: mountpoint,
0000000000000000000000000000000000000000;;				Capacity:   fs.Limit,
0000000000000000000000000000000000000000;;				Usage:      fs.Usage,
0000000000000000000000000000000000000000;;				Available:  fs.Available,
0000000000000000000000000000000000000000;;				Labels:     labels,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if fs.HasInodes {
0000000000000000000000000000000000000000;;				fi.Inodes = &fs.Inodes
0000000000000000000000000000000000000000;;				fi.InodesFree = &fs.InodesFree
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fsInfo = append(fsInfo, fi)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fsInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) GetMachineInfo() (*info.MachineInfo, error) {
0000000000000000000000000000000000000000;;		// Copy and return the MachineInfo.
0000000000000000000000000000000000000000;;		return &m.machineInfo, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) GetVersionInfo() (*info.VersionInfo, error) {
0000000000000000000000000000000000000000;;		// TODO: Consider caching this and periodically updating.  The VersionInfo may change if
0000000000000000000000000000000000000000;;		// the docker daemon is started after the cAdvisor client is created.  Caching the value
0000000000000000000000000000000000000000;;		// would be helpful so we would be able to return the last known docker version if
0000000000000000000000000000000000000000;;		// docker was down at the time of a query.
0000000000000000000000000000000000000000;;		return getVersionInfo()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) Exists(containerName string) bool {
0000000000000000000000000000000000000000;;		m.containersLock.Lock()
0000000000000000000000000000000000000000;;		defer m.containersLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespacedName := namespacedContainerName{
0000000000000000000000000000000000000000;;			Name: containerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, ok := m.containers[namespacedName]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) GetProcessList(containerName string, options v2.RequestOptions) ([]v2.ProcessInfo, error) {
0000000000000000000000000000000000000000;;		// override recursive. Only support single container listing.
0000000000000000000000000000000000000000;;		options.Recursive = false
0000000000000000000000000000000000000000;;		conts, err := m.getRequestedContainers(containerName, options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(conts) != 1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Expected the request to match only one container")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(rjnagal): handle count? Only if we can do count by type (eg. top 5 cpu users)
0000000000000000000000000000000000000000;;		ps := []v2.ProcessInfo{}
0000000000000000000000000000000000000000;;		for _, cont := range conts {
0000000000000000000000000000000000000000;;			ps, err = cont.GetProcessList(m.cadvisorContainer, m.inHostNamespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ps, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) registerCollectors(collectorConfigs map[string]string, cont *containerData) error {
0000000000000000000000000000000000000000;;		for k, v := range collectorConfigs {
0000000000000000000000000000000000000000;;			configFile, err := cont.ReadFile(v, m.inHostNamespace)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to read config file %q for config %q, container %q: %v", k, v, cont.info.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			glog.V(3).Infof("Got config from %q: %q", v, configFile)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.HasPrefix(k, "prometheus") || strings.HasPrefix(k, "Prometheus") {
0000000000000000000000000000000000000000;;				newCollector, err := collector.NewPrometheusCollector(k, configFile, *applicationMetricsCountLimit, cont.handler, m.collectorHttpClient)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Infof("failed to create collector for container %q, config %q: %v", cont.info.Name, k, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = cont.collectorManager.RegisterCollector(newCollector)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Infof("failed to register collector for container %q, config %q: %v", cont.info.Name, k, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				newCollector, err := collector.NewCollector(k, configFile, *applicationMetricsCountLimit, cont.handler, m.collectorHttpClient)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Infof("failed to create collector for container %q, config %q: %v", cont.info.Name, k, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = cont.collectorManager.RegisterCollector(newCollector)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Infof("failed to register collector for container %q, config %q: %v", cont.info.Name, k, err)
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enables overwriting an existing containerData/Handler object for a given containerName.
0000000000000000000000000000000000000000;;	// Can't use createContainer as it just returns if a given containerName has a handler already.
0000000000000000000000000000000000000000;;	// Ex: rkt handler will want to take priority over the raw handler, but the raw handler might be created first.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Only allow raw handler to be overridden
0000000000000000000000000000000000000000;;	func (m *manager) overrideContainer(containerName string, watchSource watcher.ContainerWatchSource) error {
0000000000000000000000000000000000000000;;		m.containersLock.Lock()
0000000000000000000000000000000000000000;;		defer m.containersLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		namespacedName := namespacedContainerName{
0000000000000000000000000000000000000000;;			Name: containerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := m.containers[namespacedName]; ok {
0000000000000000000000000000000000000000;;			containerData := m.containers[namespacedName]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if containerData.handler.Type() != container.ContainerTypeRaw {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := m.destroyContainerLocked(containerName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("overrideContainer: failed to destroy containerData/handler for %v: %v", containerName, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.createContainerLocked(containerName, watchSource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a container.
0000000000000000000000000000000000000000;;	func (m *manager) createContainer(containerName string, watchSource watcher.ContainerWatchSource) error {
0000000000000000000000000000000000000000;;		m.containersLock.Lock()
0000000000000000000000000000000000000000;;		defer m.containersLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.createContainerLocked(containerName, watchSource)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) createContainerLocked(containerName string, watchSource watcher.ContainerWatchSource) error {
0000000000000000000000000000000000000000;;		namespacedName := namespacedContainerName{
0000000000000000000000000000000000000000;;			Name: containerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that the container didn't already exist.
0000000000000000000000000000000000000000;;		if _, ok := m.containers[namespacedName]; ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler, accept, err := container.NewContainerHandler(containerName, watchSource, m.inHostNamespace)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !accept {
0000000000000000000000000000000000000000;;			// ignoring this container.
0000000000000000000000000000000000000000;;			glog.V(4).Infof("ignoring container %q", containerName)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		collectorManager, err := collector.NewCollectorManager()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		logUsage := *logCadvisorUsage && containerName == m.cadvisorContainer
0000000000000000000000000000000000000000;;		cont, err := newContainerData(containerName, m.memoryCache, handler, logUsage, collectorManager, m.maxHousekeepingInterval, m.allowDynamicHousekeeping)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add collectors
0000000000000000000000000000000000000000;;		labels := handler.GetContainerLabels()
0000000000000000000000000000000000000000;;		collectorConfigs := collector.GetCollectorConfigs(labels)
0000000000000000000000000000000000000000;;		err = m.registerCollectors(collectorConfigs, cont)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			glog.Infof("failed to register collectors for %q: %v", containerName, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the container name and all its aliases. The aliases must be within the namespace of the factory.
0000000000000000000000000000000000000000;;		m.containers[namespacedName] = cont
0000000000000000000000000000000000000000;;		for _, alias := range cont.info.Aliases {
0000000000000000000000000000000000000000;;			m.containers[namespacedContainerName{
0000000000000000000000000000000000000000;;				Namespace: cont.info.Namespace,
0000000000000000000000000000000000000000;;				Name:      alias,
0000000000000000000000000000000000000000;;			}] = cont
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Added container: %q (aliases: %v, namespace: %q)", containerName, cont.info.Aliases, cont.info.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contSpec, err := cont.handler.GetSpec()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contRef, err := cont.handler.ContainerReference()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newEvent := &info.Event{
0000000000000000000000000000000000000000;;			ContainerName: contRef.Name,
0000000000000000000000000000000000000000;;			Timestamp:     contSpec.CreationTime,
0000000000000000000000000000000000000000;;			EventType:     info.EventContainerCreation,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = m.eventHandler.AddEvent(newEvent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Start the container's housekeeping.
0000000000000000000000000000000000000000;;		return cont.Start()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) destroyContainer(containerName string) error {
0000000000000000000000000000000000000000;;		m.containersLock.Lock()
0000000000000000000000000000000000000000;;		defer m.containersLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return m.destroyContainerLocked(containerName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) destroyContainerLocked(containerName string) error {
0000000000000000000000000000000000000000;;		namespacedName := namespacedContainerName{
0000000000000000000000000000000000000000;;			Name: containerName,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cont, ok := m.containers[namespacedName]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// Already destroyed, done.
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tell the container to stop.
0000000000000000000000000000000000000000;;		err := cont.Stop()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the container from our records (and all its aliases).
0000000000000000000000000000000000000000;;		delete(m.containers, namespacedName)
0000000000000000000000000000000000000000;;		for _, alias := range cont.info.Aliases {
0000000000000000000000000000000000000000;;			delete(m.containers, namespacedContainerName{
0000000000000000000000000000000000000000;;				Namespace: cont.info.Namespace,
0000000000000000000000000000000000000000;;				Name:      alias,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		glog.V(3).Infof("Destroyed container: %q (aliases: %v, namespace: %q)", containerName, cont.info.Aliases, cont.info.Namespace)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contRef, err := cont.handler.ContainerReference()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newEvent := &info.Event{
0000000000000000000000000000000000000000;;			ContainerName: contRef.Name,
0000000000000000000000000000000000000000;;			Timestamp:     time.Now(),
0000000000000000000000000000000000000000;;			EventType:     info.EventContainerDeletion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = m.eventHandler.AddEvent(newEvent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detect all containers that have been added or deleted from the specified container.
0000000000000000000000000000000000000000;;	func (m *manager) getContainersDiff(containerName string) (added []info.ContainerReference, removed []info.ContainerReference, err error) {
0000000000000000000000000000000000000000;;		m.containersLock.RLock()
0000000000000000000000000000000000000000;;		defer m.containersLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get all subcontainers recursively.
0000000000000000000000000000000000000000;;		cont, ok := m.containers[namespacedContainerName{
0000000000000000000000000000000000000000;;			Name: containerName,
0000000000000000000000000000000000000000;;		}]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, nil, fmt.Errorf("failed to find container %q while checking for new containers", containerName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allContainers, err := cont.handler.ListContainers(container.ListRecursive)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allContainers = append(allContainers, info.ContainerReference{Name: containerName})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine which were added and which were removed.
0000000000000000000000000000000000000000;;		allContainersSet := make(map[string]*containerData)
0000000000000000000000000000000000000000;;		for name, d := range m.containers {
0000000000000000000000000000000000000000;;			// Only add the canonical name.
0000000000000000000000000000000000000000;;			if d.info.Name == name.Name {
0000000000000000000000000000000000000000;;				allContainersSet[name.Name] = d
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Added containers
0000000000000000000000000000000000000000;;		for _, c := range allContainers {
0000000000000000000000000000000000000000;;			delete(allContainersSet, c.Name)
0000000000000000000000000000000000000000;;			_, ok := m.containers[namespacedContainerName{
0000000000000000000000000000000000000000;;				Name: c.Name,
0000000000000000000000000000000000000000;;			}]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				added = append(added, c)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Removed ones are no longer in the container listing.
0000000000000000000000000000000000000000;;		for _, d := range allContainersSet {
0000000000000000000000000000000000000000;;			removed = append(removed, d.info.ContainerReference)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Detect the existing subcontainers and reflect the setup here.
0000000000000000000000000000000000000000;;	func (m *manager) detectSubcontainers(containerName string) error {
0000000000000000000000000000000000000000;;		added, removed, err := m.getContainersDiff(containerName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add the new containers.
0000000000000000000000000000000000000000;;		for _, cont := range added {
0000000000000000000000000000000000000000;;			err = m.createContainer(cont.Name, watcher.Raw)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to create existing container: %s: %s", cont.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove the old containers.
0000000000000000000000000000000000000000;;		for _, cont := range removed {
0000000000000000000000000000000000000000;;			err = m.destroyContainer(cont.Name)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Errorf("Failed to destroy existing container: %s: %s", cont.Name, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Watches for new containers started in the system. Runs forever unless there is a setup error.
0000000000000000000000000000000000000000;;	func (self *manager) watchForNewContainers(quit chan error) error {
0000000000000000000000000000000000000000;;		for _, watcher := range self.containerWatchers {
0000000000000000000000000000000000000000;;			err := watcher.Start(self.eventsChannel)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There is a race between starting the watch and new container creation so we do a detection before we read new containers.
0000000000000000000000000000000000000000;;		err := self.detectSubcontainers("/")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Listen to events from the container handler.
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case event := <-self.eventsChannel:
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case event.EventType == watcher.ContainerAdd:
0000000000000000000000000000000000000000;;						switch event.WatchSource {
0000000000000000000000000000000000000000;;						// the Rkt and Raw watchers can race, and if Raw wins, we want Rkt to override and create a new handler for Rkt containers
0000000000000000000000000000000000000000;;						case watcher.Rkt:
0000000000000000000000000000000000000000;;							err = self.overrideContainer(event.Name, event.WatchSource)
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;							err = self.createContainer(event.Name, event.WatchSource)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case event.EventType == watcher.ContainerDelete:
0000000000000000000000000000000000000000;;						err = self.destroyContainer(event.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						glog.Warningf("Failed to process watch event %+v: %v", event, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case <-quit:
0000000000000000000000000000000000000000;;					var errs partialFailure
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Stop processing events if asked to quit.
0000000000000000000000000000000000000000;;					for i, watcher := range self.containerWatchers {
0000000000000000000000000000000000000000;;						err := watcher.Stop()
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							errs.append(fmt.Sprintf("watcher %d", i), "Stop", err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if len(errs) > 0 {
0000000000000000000000000000000000000000;;						quit <- errs
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						quit <- nil
0000000000000000000000000000000000000000;;						glog.Infof("Exiting thread watching subcontainers")
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (self *manager) watchForNewOoms() error {
0000000000000000000000000000000000000000;;		glog.Infof("Started watching for new ooms in manager")
0000000000000000000000000000000000000000;;		outStream := make(chan *oomparser.OomInstance, 10)
0000000000000000000000000000000000000000;;		oomLog, err := oomparser.New()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go oomLog.StreamOoms(outStream)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			for oomInstance := range outStream {
0000000000000000000000000000000000000000;;				// Surface OOM and OOM kill events.
0000000000000000000000000000000000000000;;				newEvent := &info.Event{
0000000000000000000000000000000000000000;;					ContainerName: oomInstance.ContainerName,
0000000000000000000000000000000000000000;;					Timestamp:     oomInstance.TimeOfDeath,
0000000000000000000000000000000000000000;;					EventType:     info.EventOom,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := self.eventHandler.AddEvent(newEvent)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to add OOM event for %q: %v", oomInstance.ContainerName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				glog.V(3).Infof("Created an OOM event in container %q at %v", oomInstance.ContainerName, oomInstance.TimeOfDeath)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				newEvent = &info.Event{
0000000000000000000000000000000000000000;;					ContainerName: oomInstance.VictimContainerName,
0000000000000000000000000000000000000000;;					Timestamp:     oomInstance.TimeOfDeath,
0000000000000000000000000000000000000000;;					EventType:     info.EventOomKill,
0000000000000000000000000000000000000000;;					EventData: info.EventData{
0000000000000000000000000000000000000000;;						OomKill: &info.OomKillEventData{
0000000000000000000000000000000000000000;;							Pid:         oomInstance.Pid,
0000000000000000000000000000000000000000;;							ProcessName: oomInstance.ProcessName,
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = self.eventHandler.AddEvent(newEvent)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("failed to add OOM kill event for %q: %v", oomInstance.ContainerName, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// can be called by the api which will take events returned on the channel
0000000000000000000000000000000000000000;;	func (self *manager) WatchForEvents(request *events.Request) (*events.EventChannel, error) {
0000000000000000000000000000000000000000;;		return self.eventHandler.WatchEvents(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// can be called by the api which will return all events satisfying the request
0000000000000000000000000000000000000000;;	func (self *manager) GetPastEvents(request *events.Request) ([]*info.Event, error) {
0000000000000000000000000000000000000000;;		return self.eventHandler.GetEvents(request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// called by the api when a client is no longer listening to the channel
0000000000000000000000000000000000000000;;	func (self *manager) CloseEventChannel(watch_id int) {
0000000000000000000000000000000000000000;;		self.eventHandler.StopWatch(watch_id)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parses the events StoragePolicy from the flags.
0000000000000000000000000000000000000000;;	func parseEventsStoragePolicy() events.StoragePolicy {
0000000000000000000000000000000000000000;;		policy := events.DefaultStoragePolicy()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse max age.
0000000000000000000000000000000000000000;;		parts := strings.Split(*eventStorageAgeLimit, ",")
0000000000000000000000000000000000000000;;		for _, part := range parts {
0000000000000000000000000000000000000000;;			items := strings.Split(part, "=")
0000000000000000000000000000000000000000;;			if len(items) != 2 {
0000000000000000000000000000000000000000;;				glog.Warningf("Unknown event storage policy %q when parsing max age", part)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dur, err := time.ParseDuration(items[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Unable to parse event max age duration %q: %v", items[1], err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if items[0] == "default" {
0000000000000000000000000000000000000000;;				policy.DefaultMaxAge = dur
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			policy.PerTypeMaxAge[info.EventType(items[0])] = dur
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Parse max number.
0000000000000000000000000000000000000000;;		parts = strings.Split(*eventStorageEventLimit, ",")
0000000000000000000000000000000000000000;;		for _, part := range parts {
0000000000000000000000000000000000000000;;			items := strings.Split(part, "=")
0000000000000000000000000000000000000000;;			if len(items) != 2 {
0000000000000000000000000000000000000000;;				glog.Warningf("Unknown event storage policy %q when parsing max event limit", part)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val, err := strconv.Atoi(items[1])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				glog.Warningf("Unable to parse integer from %q: %v", items[1], err)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if items[0] == "default" {
0000000000000000000000000000000000000000;;				policy.DefaultMaxNumEvents = val
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			policy.PerTypeMaxNumEvents[info.EventType(items[0])] = val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return policy
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) DockerImages() ([]info.DockerImage, error) {
0000000000000000000000000000000000000000;;		return docker.Images()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) DockerInfo() (info.DockerStatus, error) {
0000000000000000000000000000000000000000;;		return docker.Status()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *manager) DebugInfo() map[string][]string {
0000000000000000000000000000000000000000;;		debugInfo := container.DebugInfo()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get unique containers.
0000000000000000000000000000000000000000;;		var conts map[*containerData]struct{}
0000000000000000000000000000000000000000;;		func() {
0000000000000000000000000000000000000000;;			m.containersLock.RLock()
0000000000000000000000000000000000000000;;			defer m.containersLock.RUnlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			conts = make(map[*containerData]struct{}, len(m.containers))
0000000000000000000000000000000000000000;;			for _, c := range m.containers {
0000000000000000000000000000000000000000;;				conts[c] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// List containers.
0000000000000000000000000000000000000000;;		lines := make([]string, 0, len(conts))
0000000000000000000000000000000000000000;;		for cont := range conts {
0000000000000000000000000000000000000000;;			lines = append(lines, cont.info.Name)
0000000000000000000000000000000000000000;;			if cont.info.Namespace != "" {
0000000000000000000000000000000000000000;;				lines = append(lines, fmt.Sprintf("\tNamespace: %s", cont.info.Namespace))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(cont.info.Aliases) != 0 {
0000000000000000000000000000000000000000;;				lines = append(lines, "\tAliases:")
0000000000000000000000000000000000000000;;				for _, alias := range cont.info.Aliases {
0000000000000000000000000000000000000000;;					lines = append(lines, fmt.Sprintf("\t\t%s", alias))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debugInfo["Managed containers"] = lines
0000000000000000000000000000000000000000;;		return debugInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getVersionInfo() (*info.VersionInfo, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kernel_version := machine.KernelVersion()
0000000000000000000000000000000000000000;;		container_os := machine.ContainerOsVersion()
0000000000000000000000000000000000000000;;		docker_version := docker.VersionString()
0000000000000000000000000000000000000000;;		docker_api_version := docker.APIVersionString()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &info.VersionInfo{
0000000000000000000000000000000000000000;;			KernelVersion:      kernel_version,
0000000000000000000000000000000000000000;;			ContainerOsVersion: container_os,
0000000000000000000000000000000000000000;;			DockerVersion:      docker_version,
0000000000000000000000000000000000000000;;			DockerAPIVersion:   docker_api_version,
0000000000000000000000000000000000000000;;			CadvisorVersion:    version.Info["version"],
0000000000000000000000000000000000000000;;			CadvisorRevision:   version.Info["revision"],
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper for accumulating partial failures.
0000000000000000000000000000000000000000;;	type partialFailure []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *partialFailure) append(id, operation string, err error) {
0000000000000000000000000000000000000000;;		*f = append(*f, fmt.Sprintf("[%q: %s: %s]", id, operation, err))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f partialFailure) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("partial failures: %s", strings.Join(f, ", "))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f partialFailure) OrNil() error {
0000000000000000000000000000000000000000;;		if len(f) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
