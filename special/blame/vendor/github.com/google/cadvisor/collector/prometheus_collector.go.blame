0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
3aca081d5ccd06a4530926d3883dd05106057918;Godeps/_workspace/src/github.com/google/cadvisor/collector/prometheus_collector.go[Godeps/_workspace/src/github.com/google/cadvisor/collector/prometheus_collector.go][vendor/github.com/google/cadvisor/collector/prometheus_collector.go];	
0000000000000000000000000000000000000000;;	package collector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawmodel "github.com/prometheus/client_model/go"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/expfmt"
0000000000000000000000000000000000000000;;		"github.com/prometheus/common/model"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PrometheusCollector struct {
0000000000000000000000000000000000000000;;		// name of the collector
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// rate at which metrics are collected
0000000000000000000000000000000000000000;;		pollingFrequency time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// holds information extracted from the config file for a collector
0000000000000000000000000000000000000000;;		configFile Prometheus
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the metrics to gather (uses a map as a set)
0000000000000000000000000000000000000000;;		metricsSet map[string]bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Limit for the number of scaped metrics. If the count is higher,
0000000000000000000000000000000000000000;;		// no metrics will be returned.
0000000000000000000000000000000000000000;;		metricCountLimit int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Http client to use when connecting to metric endpoints
0000000000000000000000000000000000000000;;		httpClient *http.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a new collector using the information extracted from the configfile
0000000000000000000000000000000000000000;;	func NewPrometheusCollector(collectorName string, configFile []byte, metricCountLimit int, containerHandler container.ContainerHandler, httpClient *http.Client) (*PrometheusCollector, error) {
0000000000000000000000000000000000000000;;		var configInJSON Prometheus
0000000000000000000000000000000000000000;;		err := json.Unmarshal(configFile, &configInJSON)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configInJSON.Endpoint.configure(containerHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minPollingFrequency := configInJSON.PollingFrequency
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum supported frequency is 1s
0000000000000000000000000000000000000000;;		minSupportedFrequency := 1 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if minPollingFrequency < minSupportedFrequency {
0000000000000000000000000000000000000000;;			minPollingFrequency = minSupportedFrequency
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if metricCountLimit < 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Metric count limit must be greater than 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var metricsSet map[string]bool
0000000000000000000000000000000000000000;;		if len(configInJSON.MetricsConfig) > 0 {
0000000000000000000000000000000000000000;;			metricsSet = make(map[string]bool, len(configInJSON.MetricsConfig))
0000000000000000000000000000000000000000;;			for _, name := range configInJSON.MetricsConfig {
0000000000000000000000000000000000000000;;				metricsSet[name] = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(configInJSON.MetricsConfig) > metricCountLimit {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Too many metrics defined: %d limit %d", len(configInJSON.MetricsConfig), metricCountLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO : Add checks for validity of config file (eg : Accurate JSON fields)
0000000000000000000000000000000000000000;;		return &PrometheusCollector{
0000000000000000000000000000000000000000;;			name:             collectorName,
0000000000000000000000000000000000000000;;			pollingFrequency: minPollingFrequency,
0000000000000000000000000000000000000000;;			configFile:       configInJSON,
0000000000000000000000000000000000000000;;			metricsSet:       metricsSet,
0000000000000000000000000000000000000000;;			metricCountLimit: metricCountLimit,
0000000000000000000000000000000000000000;;			httpClient:       httpClient,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns name of the collector
0000000000000000000000000000000000000000;;	func (collector *PrometheusCollector) Name() string {
0000000000000000000000000000000000000000;;		return collector.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (collector *PrometheusCollector) GetSpec() []v1.MetricSpec {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		response, err := collector.httpClient.Get(collector.configFile.Endpoint.URL)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer response.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dec := expfmt.NewDecoder(response.Body, expfmt.ResponseFormat(response.Header))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var specs []v1.MetricSpec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			d := rawmodel.MetricFamily{}
0000000000000000000000000000000000000000;;			if err = dec.Decode(&d); err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			name := d.GetName()
0000000000000000000000000000000000000000;;			if len(name) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If metrics to collect is specified, skip any metrics not in the list to collect.
0000000000000000000000000000000000000000;;			if _, ok := collector.metricsSet[name]; collector.metricsSet != nil && !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			spec := v1.MetricSpec{
0000000000000000000000000000000000000000;;				Name:   name,
0000000000000000000000000000000000000000;;				Type:   metricType(d.GetType()),
0000000000000000000000000000000000000000;;				Format: v1.FloatType,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			specs = append(specs, spec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return specs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// metricType converts Prometheus metric type to cadvisor metric type.
0000000000000000000000000000000000000000;;	// If there is no mapping then just return the name of the Prometheus metric type.
0000000000000000000000000000000000000000;;	func metricType(t rawmodel.MetricType) v1.MetricType {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case rawmodel.MetricType_COUNTER:
0000000000000000000000000000000000000000;;			return v1.MetricCumulative
0000000000000000000000000000000000000000;;		case rawmodel.MetricType_GAUGE:
0000000000000000000000000000000000000000;;			return v1.MetricGauge
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return v1.MetricType(t.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type prometheusLabels []*rawmodel.LabelPair
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func labelSetToLabelPairs(labels model.Metric) prometheusLabels {
0000000000000000000000000000000000000000;;		var promLabels prometheusLabels
0000000000000000000000000000000000000000;;		for k, v := range labels {
0000000000000000000000000000000000000000;;			name := string(k)
0000000000000000000000000000000000000000;;			value := string(v)
0000000000000000000000000000000000000000;;			promLabels = append(promLabels, &rawmodel.LabelPair{Name: &name, Value: &value})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return promLabels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s prometheusLabels) Len() int      { return len(s) }
0000000000000000000000000000000000000000;;	func (s prometheusLabels) Swap(i, j int) { s[i], s[j] = s[j], s[i] }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ByName implements sort.Interface by providing Less and using the Len and
0000000000000000000000000000000000000000;;	// Swap methods of the embedded PrometheusLabels value.
0000000000000000000000000000000000000000;;	type byName struct{ prometheusLabels }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s byName) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return s.prometheusLabels[i].GetName() < s.prometheusLabels[j].GetName()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prometheusLabelSetToCadvisorLabel(promLabels model.Metric) string {
0000000000000000000000000000000000000000;;		labels := labelSetToLabelPairs(promLabels)
0000000000000000000000000000000000000000;;		sort.Sort(byName{labels})
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, l := range labels {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				b.WriteString("\xff")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b.WriteString(l.GetName())
0000000000000000000000000000000000000000;;			b.WriteString("=")
0000000000000000000000000000000000000000;;			b.WriteString(l.GetValue())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(b.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns collected metrics and the next collection time of the collector
0000000000000000000000000000000000000000;;	func (collector *PrometheusCollector) Collect(metrics map[string][]v1.MetricVal) (time.Time, map[string][]v1.MetricVal, error) {
0000000000000000000000000000000000000000;;		currentTime := time.Now()
0000000000000000000000000000000000000000;;		nextCollectionTime := currentTime.Add(time.Duration(collector.pollingFrequency))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := collector.configFile.Endpoint.URL
0000000000000000000000000000000000000000;;		response, err := collector.httpClient.Get(uri)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nextCollectionTime, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer response.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return nextCollectionTime, nil, fmt.Errorf("server returned HTTP status %s", response.Status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sdec := expfmt.SampleDecoder{
0000000000000000000000000000000000000000;;			Dec: expfmt.NewDecoder(response.Body, expfmt.ResponseFormat(response.Header)),
0000000000000000000000000000000000000000;;			Opts: &expfmt.DecodeOptions{
0000000000000000000000000000000000000000;;				Timestamp: model.TimeFromUnixNano(currentTime.UnixNano()),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			// 50 is chosen as a reasonable guesstimate at a number of metrics we can
0000000000000000000000000000000000000000;;			// expect from virtually any endpoint to try to save allocations.
0000000000000000000000000000000000000000;;			decSamples = make(model.Vector, 0, 50)
0000000000000000000000000000000000000000;;			newMetrics = make(map[string][]v1.MetricVal)
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if err = sdec.Decode(&decSamples); err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, sample := range decSamples {
0000000000000000000000000000000000000000;;				metName := string(sample.Metric[model.MetricNameLabel])
0000000000000000000000000000000000000000;;				if len(metName) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// If metrics to collect is specified, skip any metrics not in the list to collect.
0000000000000000000000000000000000000000;;				if _, ok := collector.metricsSet[metName]; collector.metricsSet != nil && !ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// TODO Handle multiple labels nicer. Prometheus metrics can have multiple
0000000000000000000000000000000000000000;;				// labels, cadvisor only accepts a single string for the metric label.
0000000000000000000000000000000000000000;;				label := prometheusLabelSetToCadvisorLabel(sample.Metric)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				metric := v1.MetricVal{
0000000000000000000000000000000000000000;;					FloatValue: float64(sample.Value),
0000000000000000000000000000000000000000;;					Timestamp:  sample.Timestamp.Time(),
0000000000000000000000000000000000000000;;					Label:      label,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				newMetrics[metName] = append(newMetrics[metName], metric)
0000000000000000000000000000000000000000;;				if len(newMetrics) > collector.metricCountLimit {
0000000000000000000000000000000000000000;;					return nextCollectionTime, nil, fmt.Errorf("too many metrics to collect")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			decSamples = decSamples[:0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return nextCollectionTime, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, val := range newMetrics {
0000000000000000000000000000000000000000;;			metrics[key] = append(metrics[key], val...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nextCollectionTime, metrics, nil
0000000000000000000000000000000000000000;;	}
