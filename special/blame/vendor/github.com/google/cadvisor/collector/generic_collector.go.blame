0000000000000000000000000000000000000000;;	// Copyright 2015 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
e2a368d09bfda52d5970d2d9e3fd645b4eddb58b;Godeps/_workspace/src/github.com/google/cadvisor/collector/generic_collector.go[Godeps/_workspace/src/github.com/google/cadvisor/collector/generic_collector.go][vendor/github.com/google/cadvisor/collector/generic_collector.go];	
0000000000000000000000000000000000000000;;	package collector
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/container"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GenericCollector struct {
0000000000000000000000000000000000000000;;		// name of the collector
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// holds information extracted from the config file for a collector
0000000000000000000000000000000000000000;;		configFile Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// holds information necessary to extract metrics
0000000000000000000000000000000000000000;;		info *collectorInfo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Http client to use when connecting to metric endpoints
0000000000000000000000000000000000000000;;		httpClient *http.Client
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type collectorInfo struct {
0000000000000000000000000000000000000000;;		// minimum polling frequency among all metrics
0000000000000000000000000000000000000000;;		minPollingFrequency time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// regular expresssions for all metrics
0000000000000000000000000000000000000000;;		regexps []*regexp.Regexp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Limit for the number of srcaped metrics. If the count is higher,
0000000000000000000000000000000000000000;;		// no metrics will be returned.
0000000000000000000000000000000000000000;;		metricCountLimit int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a new collector using the information extracted from the configfile
0000000000000000000000000000000000000000;;	func NewCollector(collectorName string, configFile []byte, metricCountLimit int, containerHandler container.ContainerHandler, httpClient *http.Client) (*GenericCollector, error) {
0000000000000000000000000000000000000000;;		var configInJSON Config
0000000000000000000000000000000000000000;;		err := json.Unmarshal(configFile, &configInJSON)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		configInJSON.Endpoint.configure(containerHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO : Add checks for validity of config file (eg : Accurate JSON fields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(configInJSON.MetricsConfig) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("No metrics provided in config")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minPollFrequency := time.Duration(0)
0000000000000000000000000000000000000000;;		regexprs := make([]*regexp.Regexp, len(configInJSON.MetricsConfig))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ind, metricConfig := range configInJSON.MetricsConfig {
0000000000000000000000000000000000000000;;			// Find the minimum specified polling frequency in metric config.
0000000000000000000000000000000000000000;;			if metricConfig.PollingFrequency != 0 {
0000000000000000000000000000000000000000;;				if minPollFrequency == 0 || metricConfig.PollingFrequency < minPollFrequency {
0000000000000000000000000000000000000000;;					minPollFrequency = metricConfig.PollingFrequency
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			regexprs[ind], err = regexp.Compile(metricConfig.Regex)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Invalid regexp %v for metric %v", metricConfig.Regex, metricConfig.Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Minimum supported polling frequency is 1s.
0000000000000000000000000000000000000000;;		minSupportedFrequency := 1 * time.Second
0000000000000000000000000000000000000000;;		if minPollFrequency < minSupportedFrequency {
0000000000000000000000000000000000000000;;			minPollFrequency = minSupportedFrequency
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(configInJSON.MetricsConfig) > metricCountLimit {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Too many metrics defined: %d limit: %d", len(configInJSON.MetricsConfig), metricCountLimit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &GenericCollector{
0000000000000000000000000000000000000000;;			name:       collectorName,
0000000000000000000000000000000000000000;;			configFile: configInJSON,
0000000000000000000000000000000000000000;;			info: &collectorInfo{
0000000000000000000000000000000000000000;;				minPollingFrequency: minPollFrequency,
0000000000000000000000000000000000000000;;				regexps:             regexprs,
0000000000000000000000000000000000000000;;				metricCountLimit:    metricCountLimit,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			httpClient: httpClient,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns name of the collector
0000000000000000000000000000000000000000;;	func (collector *GenericCollector) Name() string {
0000000000000000000000000000000000000000;;		return collector.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (collector *GenericCollector) configToSpec(config MetricConfig) v1.MetricSpec {
0000000000000000000000000000000000000000;;		return v1.MetricSpec{
0000000000000000000000000000000000000000;;			Name:   config.Name,
0000000000000000000000000000000000000000;;			Type:   config.MetricType,
0000000000000000000000000000000000000000;;			Format: config.DataType,
0000000000000000000000000000000000000000;;			Units:  config.Units,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (collector *GenericCollector) GetSpec() []v1.MetricSpec {
0000000000000000000000000000000000000000;;		specs := []v1.MetricSpec{}
0000000000000000000000000000000000000000;;		for _, metricConfig := range collector.configFile.MetricsConfig {
0000000000000000000000000000000000000000;;			spec := collector.configToSpec(metricConfig)
0000000000000000000000000000000000000000;;			specs = append(specs, spec)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return specs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns collected metrics and the next collection time of the collector
0000000000000000000000000000000000000000;;	func (collector *GenericCollector) Collect(metrics map[string][]v1.MetricVal) (time.Time, map[string][]v1.MetricVal, error) {
0000000000000000000000000000000000000000;;		currentTime := time.Now()
0000000000000000000000000000000000000000;;		nextCollectionTime := currentTime.Add(time.Duration(collector.info.minPollingFrequency))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		uri := collector.configFile.Endpoint.URL
0000000000000000000000000000000000000000;;		response, err := collector.httpClient.Get(uri)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nextCollectionTime, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer response.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pageContent, err := ioutil.ReadAll(response.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nextCollectionTime, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var errorSlice []error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for ind, metricConfig := range collector.configFile.MetricsConfig {
0000000000000000000000000000000000000000;;			matchString := collector.info.regexps[ind].FindStringSubmatch(string(pageContent))
0000000000000000000000000000000000000000;;			if matchString != nil {
0000000000000000000000000000000000000000;;				if metricConfig.DataType == v1.FloatType {
0000000000000000000000000000000000000000;;					regVal, err := strconv.ParseFloat(strings.TrimSpace(matchString[1]), 64)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errorSlice = append(errorSlice, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics[metricConfig.Name] = []v1.MetricVal{
0000000000000000000000000000000000000000;;						{FloatValue: regVal, Timestamp: currentTime},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if metricConfig.DataType == v1.IntType {
0000000000000000000000000000000000000000;;					regVal, err := strconv.ParseInt(strings.TrimSpace(matchString[1]), 10, 64)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						errorSlice = append(errorSlice, err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					metrics[metricConfig.Name] = []v1.MetricVal{
0000000000000000000000000000000000000000;;						{IntValue: regVal, Timestamp: currentTime},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					errorSlice = append(errorSlice, fmt.Errorf("Unexpected value of 'data_type' for metric '%v' in config ", metricConfig.Name))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errorSlice = append(errorSlice, fmt.Errorf("No match found for regexp: %v for metric '%v' in config", metricConfig.Regex, metricConfig.Name))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nextCollectionTime, metrics, compileErrors(errorSlice)
0000000000000000000000000000000000000000;;	}
