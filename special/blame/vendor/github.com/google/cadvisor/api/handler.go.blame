0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc. All Rights Reserved.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
ddb91896b60df07452d87846c6343678b1c48dde;Godeps/_workspace/src/github.com/google/cadvisor/api/handler.go[Godeps/_workspace/src/github.com/google/cadvisor/api/handler.go][vendor/github.com/google/cadvisor/api/handler.go];	
0000000000000000000000000000000000000000;;	// Package api provides a handler for /api/
0000000000000000000000000000000000000000;;	package api
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/events"
0000000000000000000000000000000000000000;;		httpmux "github.com/google/cadvisor/http/mux"
0000000000000000000000000000000000000000;;		info "github.com/google/cadvisor/info/v1"
0000000000000000000000000000000000000000;;		"github.com/google/cadvisor/manager"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/glog"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		apiResource = "/api/"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func RegisterHandlers(mux httpmux.Mux, m manager.Manager) error {
0000000000000000000000000000000000000000;;		apiVersions := getApiVersions()
0000000000000000000000000000000000000000;;		supportedApiVersions := make(map[string]ApiVersion, len(apiVersions))
0000000000000000000000000000000000000000;;		for _, v := range apiVersions {
0000000000000000000000000000000000000000;;			supportedApiVersions[v.Version()] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mux.HandleFunc(apiResource, func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			err := handleRequest(supportedApiVersions, m, w, r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				http.Error(w, err.Error(), 500)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Captures the API version, requestType [optional], and remaining request [optional].
0000000000000000000000000000000000000000;;	var apiRegexp = regexp.MustCompile(`/api/([^/]+)/?([^/]+)?(.*)`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		apiVersion = iota + 1
0000000000000000000000000000000000000000;;		apiRequestType
0000000000000000000000000000000000000000;;		apiRequestArgs
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handleRequest(supportedApiVersions map[string]ApiVersion, m manager.Manager, w http.ResponseWriter, r *http.Request) error {
0000000000000000000000000000000000000000;;		start := time.Now()
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			glog.V(4).Infof("Request took %s", time.Since(start))
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		request := r.URL.Path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const apiPrefix = "/api"
0000000000000000000000000000000000000000;;		if !strings.HasPrefix(request, apiPrefix) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("incomplete API request %q", request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the request doesn't have an API version, list those.
0000000000000000000000000000000000000000;;		if request == apiPrefix || request == apiResource {
0000000000000000000000000000000000000000;;			versions := make([]string, 0, len(supportedApiVersions))
0000000000000000000000000000000000000000;;			for v := range supportedApiVersions {
0000000000000000000000000000000000000000;;				versions = append(versions, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(versions)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "Supported API versions: %s", strings.Join(versions, ","))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Verify that we have all the elements we expect:
0000000000000000000000000000000000000000;;		// /<version>/<request type>[/<args...>]
0000000000000000000000000000000000000000;;		requestElements := apiRegexp.FindStringSubmatch(request)
0000000000000000000000000000000000000000;;		if len(requestElements) == 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("malformed request %q", request)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		version := requestElements[apiVersion]
0000000000000000000000000000000000000000;;		requestType := requestElements[apiRequestType]
0000000000000000000000000000000000000000;;		requestArgs := strings.Split(requestElements[apiRequestArgs], "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check supported versions.
0000000000000000000000000000000000000000;;		versionHandler, ok := supportedApiVersions[version]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported API version %q", version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If no request type, list possible request types.
0000000000000000000000000000000000000000;;		if requestType == "" {
0000000000000000000000000000000000000000;;			requestTypes := versionHandler.SupportedRequestTypes()
0000000000000000000000000000000000000000;;			sort.Strings(requestTypes)
0000000000000000000000000000000000000000;;			fmt.Fprintf(w, "Supported request types: %q", strings.Join(requestTypes, ","))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Trim the first empty element from the request.
0000000000000000000000000000000000000000;;		if len(requestArgs) > 0 && requestArgs[0] == "" {
0000000000000000000000000000000000000000;;			requestArgs = requestArgs[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return versionHandler.HandleRequest(requestType, requestArgs, m, w, r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeResult(res interface{}, w http.ResponseWriter) error {
0000000000000000000000000000000000000000;;		out, err := json.Marshal(res)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to marshall response %+v with error: %s", res, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		w.Write(out)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func streamResults(eventChannel *events.EventChannel, w http.ResponseWriter, r *http.Request, m manager.Manager) error {
0000000000000000000000000000000000000000;;		cn, ok := w.(http.CloseNotifier)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("could not access http.CloseNotifier")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		flusher, ok := w.(http.Flusher)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return errors.New("could not access http.Flusher")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.Header().Set("Transfer-Encoding", "chunked")
0000000000000000000000000000000000000000;;		w.WriteHeader(http.StatusOK)
0000000000000000000000000000000000000000;;		flusher.Flush()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enc := json.NewEncoder(w)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-cn.CloseNotify():
0000000000000000000000000000000000000000;;				m.CloseEventChannel(eventChannel.GetWatchId())
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case ev := <-eventChannel.GetChannel():
0000000000000000000000000000000000000000;;				err := enc.Encode(ev)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					glog.Errorf("error encoding message %+v for result stream: %v", ev, err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				flusher.Flush()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getContainerInfoRequest(body io.ReadCloser) (*info.ContainerInfoRequest, error) {
0000000000000000000000000000000000000000;;		query := info.DefaultContainerInfoRequest()
0000000000000000000000000000000000000000;;		decoder := json.NewDecoder(body)
0000000000000000000000000000000000000000;;		err := decoder.Decode(&query)
0000000000000000000000000000000000000000;;		if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unable to decode the json value: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &query, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The user can set any or none of the following arguments in any order
0000000000000000000000000000000000000000;;	// with any twice defined arguments being assigned the first value.
0000000000000000000000000000000000000000;;	// If the value type for the argument is wrong the field will be assumed to be
0000000000000000000000000000000000000000;;	// unassigned
0000000000000000000000000000000000000000;;	// bools: stream, subcontainers, oom_events, creation_events, deletion_events
0000000000000000000000000000000000000000;;	// ints: max_events, start_time (unix timestamp), end_time (unix timestamp)
0000000000000000000000000000000000000000;;	// example r.URL: http://localhost:8080/api/v1.3/events?oom_events=true&stream=true
0000000000000000000000000000000000000000;;	func getEventRequest(r *http.Request) (*events.Request, bool, error) {
0000000000000000000000000000000000000000;;		query := events.NewRequest()
0000000000000000000000000000000000000000;;		stream := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		urlMap := r.URL.Query()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val, ok := urlMap["stream"]; ok {
0000000000000000000000000000000000000000;;			newBool, err := strconv.ParseBool(val[0])
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				stream = newBool
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val, ok := urlMap["subcontainers"]; ok {
0000000000000000000000000000000000000000;;			newBool, err := strconv.ParseBool(val[0])
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				query.IncludeSubcontainers = newBool
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		eventTypes := map[string]info.EventType{
0000000000000000000000000000000000000000;;			"oom_events":      info.EventOom,
0000000000000000000000000000000000000000;;			"oom_kill_events": info.EventOomKill,
0000000000000000000000000000000000000000;;			"creation_events": info.EventContainerCreation,
0000000000000000000000000000000000000000;;			"deletion_events": info.EventContainerDeletion,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		allEventTypes := false
0000000000000000000000000000000000000000;;		if val, ok := urlMap["all_events"]; ok {
0000000000000000000000000000000000000000;;			newBool, err := strconv.ParseBool(val[0])
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				allEventTypes = newBool
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for opt, eventType := range eventTypes {
0000000000000000000000000000000000000000;;			if allEventTypes {
0000000000000000000000000000000000000000;;				query.EventType[eventType] = true
0000000000000000000000000000000000000000;;			} else if val, ok := urlMap[opt]; ok {
0000000000000000000000000000000000000000;;				newBool, err := strconv.ParseBool(val[0])
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					query.EventType[eventType] = newBool
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val, ok := urlMap["max_events"]; ok {
0000000000000000000000000000000000000000;;			newInt, err := strconv.Atoi(val[0])
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				query.MaxEventsReturned = int(newInt)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val, ok := urlMap["start_time"]; ok {
0000000000000000000000000000000000000000;;			newTime, err := time.Parse(time.RFC3339, val[0])
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				query.StartTime = newTime
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if val, ok := urlMap["end_time"]; ok {
0000000000000000000000000000000000000000;;			newTime, err := time.Parse(time.RFC3339, val[0])
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				query.EndTime = newTime
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return query, stream, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getContainerName(request []string) string {
0000000000000000000000000000000000000000;;		return path.Join("/", strings.Join(request, "/"))
0000000000000000000000000000000000000000;;	}
