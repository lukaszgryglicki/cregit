0000000000000000000000000000000000000000;;	// Package client is a CT log client implementation and contains types and code
0000000000000000000000000000000000000000;;	// for interacting with RFC6962-compliant CT Log instances.
0000000000000000000000000000000000000000;;	// See http://tools.ietf.org/html/rfc6962 for details
0000000000000000000000000000000000000000;;	package client
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go"
0000000000000000000000000000000000000000;;		"github.com/mreiferson/go-httpclient"
0000000000000000000000000000000000000000;;		"golang.org/x/net/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URI paths for CT Log endpoints
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		AddChainPath    = "/ct/v1/add-chain"
0000000000000000000000000000000000000000;;		AddPreChainPath = "/ct/v1/add-pre-chain"
0000000000000000000000000000000000000000;;		GetSTHPath      = "/ct/v1/get-sth"
0000000000000000000000000000000000000000;;		GetEntriesPath  = "/ct/v1/get-entries"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogClient represents a client for a given CT Log instance
0000000000000000000000000000000000000000;;	type LogClient struct {
0000000000000000000000000000000000000000;;		uri        string       // the base URI of the log. e.g. http://ct.googleapis/pilot
0000000000000000000000000000000000000000;;		httpClient *http.Client // used to interact with the log via HTTP
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//////////////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	// JSON structures follow.
0000000000000000000000000000000000000000;;	// These represent the structures returned by the CT Log server.
0000000000000000000000000000000000000000;;	//////////////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addChainRequest represents the JSON request body sent to the add-chain CT
0000000000000000000000000000000000000000;;	// method.
0000000000000000000000000000000000000000;;	type addChainRequest struct {
0000000000000000000000000000000000000000;;		Chain []string `json:"chain"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addChainResponse represents the JSON response to the add-chain CT method.
0000000000000000000000000000000000000000;;	// An SCT represents a Log's promise to integrate a [pre-]certificate into the
0000000000000000000000000000000000000000;;	// log within a defined period of time.
0000000000000000000000000000000000000000;;	type addChainResponse struct {
0000000000000000000000000000000000000000;;		SCTVersion ct.Version `json:"sct_version"` // SCT structure version
0000000000000000000000000000000000000000;;		ID         string     `json:"id"`          // Log ID
0000000000000000000000000000000000000000;;		Timestamp  uint64     `json:"timestamp"`   // Timestamp of issuance
0000000000000000000000000000000000000000;;		Extensions string     `json:"extensions"`  // Holder for any CT extensions
0000000000000000000000000000000000000000;;		Signature  string     `json:"signature"`   // Log signature for this SCT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getSTHResponse respresents the JSON response to the get-sth CT method
0000000000000000000000000000000000000000;;	type getSTHResponse struct {
0000000000000000000000000000000000000000;;		TreeSize          uint64 `json:"tree_size"`           // Number of certs in the current tree
0000000000000000000000000000000000000000;;		Timestamp         uint64 `json:"timestamp"`           // Time that the tree was created
0000000000000000000000000000000000000000;;		SHA256RootHash    string `json:"sha256_root_hash"`    // Root hash of the tree
0000000000000000000000000000000000000000;;		TreeHeadSignature string `json:"tree_head_signature"` // Log signature for this STH
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// base64LeafEntry respresents a Base64 encoded leaf entry
0000000000000000000000000000000000000000;;	type base64LeafEntry struct {
0000000000000000000000000000000000000000;;		LeafInput string `json:"leaf_input"`
0000000000000000000000000000000000000000;;		ExtraData string `json:"extra_data"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getEntriesReponse respresents the JSON response to the CT get-entries method
0000000000000000000000000000000000000000;;	type getEntriesResponse struct {
0000000000000000000000000000000000000000;;		Entries []base64LeafEntry `json:"entries"` // the list of returned entries
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getConsistencyProofResponse represents the JSON response to the CT get-consistency-proof method
0000000000000000000000000000000000000000;;	type getConsistencyProofResponse struct {
0000000000000000000000000000000000000000;;		Consistency []string `json:"consistency"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAuditProofResponse represents the JSON response to the CT get-audit-proof method
0000000000000000000000000000000000000000;;	type getAuditProofResponse struct {
0000000000000000000000000000000000000000;;		Hash     []string `json:"hash"`      // the hashes which make up the proof
0000000000000000000000000000000000000000;;		TreeSize uint64   `json:"tree_size"` // the tree size against which this proof is constructed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getAcceptedRootsResponse represents the JSON response to the CT get-roots method.
0000000000000000000000000000000000000000;;	type getAcceptedRootsResponse struct {
0000000000000000000000000000000000000000;;		Certificates []string `json:"certificates"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getEntryAndProodReponse represents the JSON response to the CT get-entry-and-proof method
0000000000000000000000000000000000000000;;	type getEntryAndProofResponse struct {
0000000000000000000000000000000000000000;;		LeafInput string   `json:"leaf_input"` // the entry itself
0000000000000000000000000000000000000000;;		ExtraData string   `json:"extra_data"` // any chain provided when the entry was added to the log
0000000000000000000000000000000000000000;;		AuditPath []string `json:"audit_path"` // the corresponding proof
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New constructs a new LogClient instance.
0000000000000000000000000000000000000000;;	// |uri| is the base URI of the CT log instance to interact with, e.g.
0000000000000000000000000000000000000000;;	// http://ct.googleapis.com/pilot
0000000000000000000000000000000000000000;;	func New(uri string) *LogClient {
0000000000000000000000000000000000000000;;		var c LogClient
0000000000000000000000000000000000000000;;		c.uri = uri
0000000000000000000000000000000000000000;;		transport := &httpclient.Transport{
0000000000000000000000000000000000000000;;			ConnectTimeout:        10 * time.Second,
0000000000000000000000000000000000000000;;			RequestTimeout:        30 * time.Second,
0000000000000000000000000000000000000000;;			ResponseHeaderTimeout: 30 * time.Second,
0000000000000000000000000000000000000000;;			MaxIdleConnsPerHost:   10,
0000000000000000000000000000000000000000;;			DisableKeepAlives:     false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.httpClient = &http.Client{Transport: transport}
0000000000000000000000000000000000000000;;		return &c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes a HTTP call to |uri|, and attempts to parse the response as a JSON
0000000000000000000000000000000000000000;;	// representation of the structure in |res|.
0000000000000000000000000000000000000000;;	// Returns a non-nil |error| if there was a problem.
0000000000000000000000000000000000000000;;	func (c *LogClient) fetchAndParse(uri string, res interface{}) error {
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", uri, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Keep-Alive", "timeout=15, max=100")
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(req)
0000000000000000000000000000000000000000;;		var body []byte
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			body, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = json.Unmarshal(body, &res); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Makes a HTTP POST call to |uri|, and attempts to parse the response as a JSON
0000000000000000000000000000000000000000;;	// representation of the structure in |res|.
0000000000000000000000000000000000000000;;	// Returns a non-nil |error| if there was a problem.
0000000000000000000000000000000000000000;;	func (c *LogClient) postAndParse(uri string, req interface{}, res interface{}) (*http.Response, string, error) {
0000000000000000000000000000000000000000;;		postBody, err := json.Marshal(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		httpReq, err := http.NewRequest("POST", uri, bytes.NewReader(postBody))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		httpReq.Header.Set("Keep-Alive", "timeout=15, max=100")
0000000000000000000000000000000000000000;;		httpReq.Header.Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;		resp, err := c.httpClient.Do(httpReq)
0000000000000000000000000000000000000000;;		// Read all of the body, if there is one, so that the http.Client can do
0000000000000000000000000000000000000000;;		// Keep-Alive:
0000000000000000000000000000000000000000;;		var body []byte
0000000000000000000000000000000000000000;;		if resp != nil {
0000000000000000000000000000000000000000;;			body, err = ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return resp, string(body), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode == 200 {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return resp, string(body), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err = json.Unmarshal(body, &res); err != nil {
0000000000000000000000000000000000000000;;				return resp, string(body), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return resp, string(body), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func backoffForRetry(ctx context.Context, d time.Duration) error {
0000000000000000000000000000000000000000;;		backoffTimer := time.NewTimer(d)
0000000000000000000000000000000000000000;;		if ctx != nil {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-ctx.Done():
0000000000000000000000000000000000000000;;				return ctx.Err()
0000000000000000000000000000000000000000;;			case <-backoffTimer.C:
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			<-backoffTimer.C
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attempts to add |chain| to the log, using the api end-point specified by
0000000000000000000000000000000000000000;;	// |path|. If provided context expires before submission is complete an
0000000000000000000000000000000000000000;;	// error will be returned.
0000000000000000000000000000000000000000;;	func (c *LogClient) addChainWithRetry(ctx context.Context, path string, chain []ct.ASN1Cert) (*ct.SignedCertificateTimestamp, error) {
0000000000000000000000000000000000000000;;		var resp addChainResponse
0000000000000000000000000000000000000000;;		var req addChainRequest
0000000000000000000000000000000000000000;;		for _, link := range chain {
0000000000000000000000000000000000000000;;			req.Chain = append(req.Chain, base64.StdEncoding.EncodeToString(link))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		httpStatus := "Unknown"
0000000000000000000000000000000000000000;;		backoffSeconds := 0
0000000000000000000000000000000000000000;;		done := false
0000000000000000000000000000000000000000;;		for !done {
0000000000000000000000000000000000000000;;			if backoffSeconds > 0 {
0000000000000000000000000000000000000000;;				log.Printf("Got %s, backing-off %d seconds", httpStatus, backoffSeconds)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err := backoffForRetry(ctx, time.Second*time.Duration(backoffSeconds))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if backoffSeconds > 0 {
0000000000000000000000000000000000000000;;				backoffSeconds = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			httpResp, errorBody, err := c.postAndParse(c.uri+path, &req, &resp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				backoffSeconds = 10
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case httpResp.StatusCode == 200:
0000000000000000000000000000000000000000;;				done = true
0000000000000000000000000000000000000000;;			case httpResp.StatusCode == 408:
0000000000000000000000000000000000000000;;				// request timeout, retry immediately
0000000000000000000000000000000000000000;;			case httpResp.StatusCode == 503:
0000000000000000000000000000000000000000;;				// Retry
0000000000000000000000000000000000000000;;				backoffSeconds = 10
0000000000000000000000000000000000000000;;				if retryAfter := httpResp.Header.Get("Retry-After"); retryAfter != "" {
0000000000000000000000000000000000000000;;					if seconds, err := strconv.Atoi(retryAfter); err == nil {
0000000000000000000000000000000000000000;;						backoffSeconds = seconds
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("got HTTP Status %s: %s", httpResp.Status, errorBody)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			httpStatus = httpResp.Status
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawLogID, err := base64.StdEncoding.DecodeString(resp.ID)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rawSignature, err := base64.StdEncoding.DecodeString(resp.Signature)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds, err := ct.UnmarshalDigitallySigned(bytes.NewReader(rawSignature))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var logID ct.SHA256Hash
0000000000000000000000000000000000000000;;		copy(logID[:], rawLogID)
0000000000000000000000000000000000000000;;		return &ct.SignedCertificateTimestamp{
0000000000000000000000000000000000000000;;			SCTVersion: resp.SCTVersion,
0000000000000000000000000000000000000000;;			LogID:      logID,
0000000000000000000000000000000000000000;;			Timestamp:  resp.Timestamp,
0000000000000000000000000000000000000000;;			Extensions: ct.CTExtensions(resp.Extensions),
0000000000000000000000000000000000000000;;			Signature:  *ds}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddChain adds the (DER represented) X509 |chain| to the log.
0000000000000000000000000000000000000000;;	func (c *LogClient) AddChain(chain []ct.ASN1Cert) (*ct.SignedCertificateTimestamp, error) {
0000000000000000000000000000000000000000;;		return c.addChainWithRetry(nil, AddChainPath, chain)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddPreChain adds the (DER represented) Precertificate |chain| to the log.
0000000000000000000000000000000000000000;;	func (c *LogClient) AddPreChain(chain []ct.ASN1Cert) (*ct.SignedCertificateTimestamp, error) {
0000000000000000000000000000000000000000;;		return c.addChainWithRetry(nil, AddPreChainPath, chain)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddChainWithContext adds the (DER represented) X509 |chain| to the log and
0000000000000000000000000000000000000000;;	// fails if the provided context expires before the chain is submitted.
0000000000000000000000000000000000000000;;	func (c *LogClient) AddChainWithContext(ctx context.Context, chain []ct.ASN1Cert) (*ct.SignedCertificateTimestamp, error) {
0000000000000000000000000000000000000000;;		return c.addChainWithRetry(ctx, AddChainPath, chain)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetSTH retrieves the current STH from the log.
0000000000000000000000000000000000000000;;	// Returns a populated SignedTreeHead, or a non-nil error.
0000000000000000000000000000000000000000;;	func (c *LogClient) GetSTH() (sth *ct.SignedTreeHead, err error) {
0000000000000000000000000000000000000000;;		var resp getSTHResponse
0000000000000000000000000000000000000000;;		if err = c.fetchAndParse(c.uri+GetSTHPath, &resp); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sth = &ct.SignedTreeHead{
0000000000000000000000000000000000000000;;			TreeSize:  resp.TreeSize,
0000000000000000000000000000000000000000;;			Timestamp: resp.Timestamp,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawRootHash, err := base64.StdEncoding.DecodeString(resp.SHA256RootHash)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid base64 encoding in sha256_root_hash: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rawRootHash) != sha256.Size {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("sha256_root_hash is invalid length, expected %d got %d", sha256.Size, len(rawRootHash))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(sth.SHA256RootHash[:], rawRootHash)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawSignature, err := base64.StdEncoding.DecodeString(resp.TreeHeadSignature)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("invalid base64 encoding in tree_head_signature")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds, err := ct.UnmarshalDigitallySigned(bytes.NewReader(rawSignature))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(alcutter): Verify signature
0000000000000000000000000000000000000000;;		sth.TreeHeadSignature = *ds
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetEntries attempts to retrieve the entries in the sequence [|start|, |end|] from the CT
0000000000000000000000000000000000000000;;	// log server. (see section 4.6.)
0000000000000000000000000000000000000000;;	// Returns a slice of LeafInputs or a non-nil error.
0000000000000000000000000000000000000000;;	func (c *LogClient) GetEntries(start, end int64) ([]ct.LogEntry, error) {
0000000000000000000000000000000000000000;;		if end < 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("end should be >= 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end < start {
0000000000000000000000000000000000000000;;			return nil, errors.New("start should be <= end")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var resp getEntriesResponse
0000000000000000000000000000000000000000;;		err := c.fetchAndParse(fmt.Sprintf("%s%s?start=%d&end=%d", c.uri, GetEntriesPath, start, end), &resp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		entries := make([]ct.LogEntry, len(resp.Entries))
0000000000000000000000000000000000000000;;		for index, entry := range resp.Entries {
0000000000000000000000000000000000000000;;			leafBytes, err := base64.StdEncoding.DecodeString(entry.LeafInput)
0000000000000000000000000000000000000000;;			leaf, err := ct.ReadMerkleTreeLeaf(bytes.NewBuffer(leafBytes))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			entries[index].Leaf = *leaf
0000000000000000000000000000000000000000;;			chainBytes, err := base64.StdEncoding.DecodeString(entry.ExtraData)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var chain []ct.ASN1Cert
0000000000000000000000000000000000000000;;			switch leaf.TimestampedEntry.EntryType {
0000000000000000000000000000000000000000;;			case ct.X509LogEntryType:
0000000000000000000000000000000000000000;;				chain, err = ct.UnmarshalX509ChainArray(chainBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case ct.PrecertLogEntryType:
0000000000000000000000000000000000000000;;				chain, err = ct.UnmarshalPrecertChainArray(chainBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("saw unknown entry type: %v", leaf.TimestampedEntry.EntryType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			entries[index].Chain = chain
0000000000000000000000000000000000000000;;			entries[index].Index = start + int64(index)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return entries, nil
0000000000000000000000000000000000000000;;	}
