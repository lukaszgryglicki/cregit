0000000000000000000000000000000000000000;;	package ct
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go/x509"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		issuerKeyHashLength = 32
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	///////////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	// The following structures represent those outlined in the RFC6962 document:
0000000000000000000000000000000000000000;;	///////////////////////////////////////////////////////////////////////////////
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogEntryType represents the LogEntryType enum from section 3.1 of the RFC:
0000000000000000000000000000000000000000;;	//   enum { x509_entry(0), precert_entry(1), (65535) } LogEntryType;
0000000000000000000000000000000000000000;;	type LogEntryType uint16
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e LogEntryType) String() string {
0000000000000000000000000000000000000000;;		switch e {
0000000000000000000000000000000000000000;;		case X509LogEntryType:
0000000000000000000000000000000000000000;;			return "X509LogEntryType"
0000000000000000000000000000000000000000;;		case PrecertLogEntryType:
0000000000000000000000000000000000000000;;			return "PrecertLogEntryType"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("No string defined for LogEntryType constant value %d", e))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogEntryType constants, see section 3.1 of RFC6962.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		X509LogEntryType    LogEntryType = 0
0000000000000000000000000000000000000000;;		PrecertLogEntryType LogEntryType = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MerkleLeafType represents the MerkleLeafType enum from section 3.4 of the
0000000000000000000000000000000000000000;;	// RFC: enum { timestamped_entry(0), (255) } MerkleLeafType;
0000000000000000000000000000000000000000;;	type MerkleLeafType uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MerkleLeafType) String() string {
0000000000000000000000000000000000000000;;		switch m {
0000000000000000000000000000000000000000;;		case TimestampedEntryLeafType:
0000000000000000000000000000000000000000;;			return "TimestampedEntryLeafType"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("UnknownLeafType(%d)", m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MerkleLeafType constants, see section 3.4 of the RFC.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TimestampedEntryLeafType MerkleLeafType = 0 // Entry type for an SCT
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version represents the Version enum from section 3.2 of the RFC:
0000000000000000000000000000000000000000;;	// enum { v1(0), (255) } Version;
0000000000000000000000000000000000000000;;	type Version uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v Version) String() string {
0000000000000000000000000000000000000000;;		switch v {
0000000000000000000000000000000000000000;;		case V1:
0000000000000000000000000000000000000000;;			return "V1"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("UnknownVersion(%d)", v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CT Version constants, see section 3.2 of the RFC.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		V1 Version = 0
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureType differentiates STH signatures from SCT signatures, see RFC
0000000000000000000000000000000000000000;;	// section 3.2
0000000000000000000000000000000000000000;;	type SignatureType uint8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (st SignatureType) String() string {
0000000000000000000000000000000000000000;;		switch st {
0000000000000000000000000000000000000000;;		case CertificateTimestampSignatureType:
0000000000000000000000000000000000000000;;			return "CertificateTimestamp"
0000000000000000000000000000000000000000;;		case TreeHashSignatureType:
0000000000000000000000000000000000000000;;			return "TreeHash"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("UnknownSignatureType(%d)", st)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureType constants, see RFC section 3.2
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CertificateTimestampSignatureType SignatureType = 0
0000000000000000000000000000000000000000;;		TreeHashSignatureType             SignatureType = 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASN1Cert type for holding the raw DER bytes of an ASN.1 Certificate
0000000000000000000000000000000000000000;;	// (section 3.1)
0000000000000000000000000000000000000000;;	type ASN1Cert []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PreCert represents a Precertificate (section 3.2)
0000000000000000000000000000000000000000;;	type PreCert struct {
0000000000000000000000000000000000000000;;		IssuerKeyHash  [issuerKeyHashLength]byte
0000000000000000000000000000000000000000;;		TBSCertificate []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CTExtensions is a representation of the raw bytes of any CtExtension
0000000000000000000000000000000000000000;;	// structure (see section 3.2)
0000000000000000000000000000000000000000;;	type CTExtensions []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MerkleTreeNode represents an internal node in the CT tree
0000000000000000000000000000000000000000;;	type MerkleTreeNode []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConsistencyProof represents a CT consistency proof (see sections 2.1.2 and
0000000000000000000000000000000000000000;;	// 4.4)
0000000000000000000000000000000000000000;;	type ConsistencyProof []MerkleTreeNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuditPath represents a CT inclusion proof (see sections 2.1.1 and 4.5)
0000000000000000000000000000000000000000;;	type AuditPath []MerkleTreeNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LeafInput represents a serialized MerkleTreeLeaf structure
0000000000000000000000000000000000000000;;	type LeafInput []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashAlgorithm from the DigitallySigned struct
0000000000000000000000000000000000000000;;	type HashAlgorithm byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashAlgorithm constants
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		None   HashAlgorithm = 0
0000000000000000000000000000000000000000;;		MD5    HashAlgorithm = 1
0000000000000000000000000000000000000000;;		SHA1   HashAlgorithm = 2
0000000000000000000000000000000000000000;;		SHA224 HashAlgorithm = 3
0000000000000000000000000000000000000000;;		SHA256 HashAlgorithm = 4
0000000000000000000000000000000000000000;;		SHA384 HashAlgorithm = 5
0000000000000000000000000000000000000000;;		SHA512 HashAlgorithm = 6
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h HashAlgorithm) String() string {
0000000000000000000000000000000000000000;;		switch h {
0000000000000000000000000000000000000000;;		case None:
0000000000000000000000000000000000000000;;			return "None"
0000000000000000000000000000000000000000;;		case MD5:
0000000000000000000000000000000000000000;;			return "MD5"
0000000000000000000000000000000000000000;;		case SHA1:
0000000000000000000000000000000000000000;;			return "SHA1"
0000000000000000000000000000000000000000;;		case SHA224:
0000000000000000000000000000000000000000;;			return "SHA224"
0000000000000000000000000000000000000000;;		case SHA256:
0000000000000000000000000000000000000000;;			return "SHA256"
0000000000000000000000000000000000000000;;		case SHA384:
0000000000000000000000000000000000000000;;			return "SHA384"
0000000000000000000000000000000000000000;;		case SHA512:
0000000000000000000000000000000000000000;;			return "SHA512"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("UNKNOWN(%d)", h)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureAlgorithm from the the DigitallySigned struct
0000000000000000000000000000000000000000;;	type SignatureAlgorithm byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureAlgorithm constants
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Anonymous SignatureAlgorithm = 0
0000000000000000000000000000000000000000;;		RSA       SignatureAlgorithm = 1
0000000000000000000000000000000000000000;;		DSA       SignatureAlgorithm = 2
0000000000000000000000000000000000000000;;		ECDSA     SignatureAlgorithm = 3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SignatureAlgorithm) String() string {
0000000000000000000000000000000000000000;;		switch s {
0000000000000000000000000000000000000000;;		case Anonymous:
0000000000000000000000000000000000000000;;			return "Anonymous"
0000000000000000000000000000000000000000;;		case RSA:
0000000000000000000000000000000000000000;;			return "RSA"
0000000000000000000000000000000000000000;;		case DSA:
0000000000000000000000000000000000000000;;			return "DSA"
0000000000000000000000000000000000000000;;		case ECDSA:
0000000000000000000000000000000000000000;;			return "ECDSA"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Sprintf("UNKNOWN(%d)", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DigitallySigned represents an RFC5246 DigitallySigned structure
0000000000000000000000000000000000000000;;	type DigitallySigned struct {
0000000000000000000000000000000000000000;;		HashAlgorithm      HashAlgorithm
0000000000000000000000000000000000000000;;		SignatureAlgorithm SignatureAlgorithm
0000000000000000000000000000000000000000;;		Signature          []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromBase64String populates the DigitallySigned structure from the base64 data passed in.
0000000000000000000000000000000000000000;;	// Returns an error if the base64 data is invalid.
0000000000000000000000000000000000000000;;	func (d *DigitallySigned) FromBase64String(b64 string) error {
0000000000000000000000000000000000000000;;		raw, err := base64.StdEncoding.DecodeString(b64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to unbase64 DigitallySigned: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds, err := UnmarshalDigitallySigned(bytes.NewReader(raw))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to unmarshal DigitallySigned: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*d = *ds
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Base64String returns the base64 representation of the DigitallySigned struct.
0000000000000000000000000000000000000000;;	func (d DigitallySigned) Base64String() (string, error) {
0000000000000000000000000000000000000000;;		b, err := MarshalDigitallySigned(d)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return base64.StdEncoding.EncodeToString(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaller interface.
0000000000000000000000000000000000000000;;	func (d DigitallySigned) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		b64, err := d.Base64String()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []byte{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []byte(`"` + b64 + `"`), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaler interface.
0000000000000000000000000000000000000000;;	func (d *DigitallySigned) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var content string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &content); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to unmarshal DigitallySigned: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d.FromBase64String(content)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LogEntry represents the contents of an entry in a CT log, see section 3.1.
0000000000000000000000000000000000000000;;	type LogEntry struct {
0000000000000000000000000000000000000000;;		Index    int64
0000000000000000000000000000000000000000;;		Leaf     MerkleTreeLeaf
0000000000000000000000000000000000000000;;		X509Cert *x509.Certificate
0000000000000000000000000000000000000000;;		Precert  *Precertificate
0000000000000000000000000000000000000000;;		Chain    []ASN1Cert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SHA256Hash represents the output from the SHA256 hash function.
0000000000000000000000000000000000000000;;	type SHA256Hash [sha256.Size]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromBase64String populates the SHA256 struct with the contents of the base64 data passed in.
0000000000000000000000000000000000000000;;	func (s *SHA256Hash) FromBase64String(b64 string) error {
0000000000000000000000000000000000000000;;		bs, err := base64.StdEncoding.DecodeString(b64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to unbase64 LogID: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(bs) != sha256.Size {
0000000000000000000000000000000000000000;;			return fmt.Errorf("invalid SHA256 length, expected 32 but got %d", len(bs))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(s[:], bs)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Base64String returns the base64 representation of this SHA256Hash.
0000000000000000000000000000000000000000;;	func (s SHA256Hash) Base64String() string {
0000000000000000000000000000000000000000;;		return base64.StdEncoding.EncodeToString(s[:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON implements the json.Marshaller interface for SHA256Hash.
0000000000000000000000000000000000000000;;	func (s SHA256Hash) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return []byte(`"` + s.Base64String() + `"`), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON implements the json.Unmarshaller interface.
0000000000000000000000000000000000000000;;	func (s *SHA256Hash) UnmarshalJSON(b []byte) error {
0000000000000000000000000000000000000000;;		var content string
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(b, &content); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to unmarshal SHA256Hash: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.FromBase64String(content)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignedTreeHead represents the structure returned by the get-sth CT method
0000000000000000000000000000000000000000;;	// after base64 decoding. See sections 3.5 and 4.3 in the RFC)
0000000000000000000000000000000000000000;;	type SignedTreeHead struct {
0000000000000000000000000000000000000000;;		Version           Version         `json:"sth_version"`         // The version of the protocol to which the STH conforms
0000000000000000000000000000000000000000;;		TreeSize          uint64          `json:"tree_size"`           // The number of entries in the new tree
0000000000000000000000000000000000000000;;		Timestamp         uint64          `json:"timestamp"`           // The time at which the STH was created
0000000000000000000000000000000000000000;;		SHA256RootHash    SHA256Hash      `json:"sha256_root_hash"`    // The root hash of the log's Merkle tree
0000000000000000000000000000000000000000;;		TreeHeadSignature DigitallySigned `json:"tree_head_signature"` // The Log's signature for this STH (see RFC section 3.5)
0000000000000000000000000000000000000000;;		LogID             SHA256Hash      `json:"log_id"`              // The SHA256 hash of the log's public key
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignedCertificateTimestamp represents the structure returned by the
0000000000000000000000000000000000000000;;	// add-chain and add-pre-chain methods after base64 decoding. (see RFC sections
0000000000000000000000000000000000000000;;	// 3.2 ,4.1 and 4.2)
0000000000000000000000000000000000000000;;	type SignedCertificateTimestamp struct {
0000000000000000000000000000000000000000;;		SCTVersion Version    // The version of the protocol to which the SCT conforms
0000000000000000000000000000000000000000;;		LogID      SHA256Hash // the SHA-256 hash of the log's public key, calculated over
0000000000000000000000000000000000000000;;		// the DER encoding of the key represented as SubjectPublicKeyInfo.
0000000000000000000000000000000000000000;;		Timestamp  uint64          // Timestamp (in ms since unix epoc) at which the SCT was issued
0000000000000000000000000000000000000000;;		Extensions CTExtensions    // For future extensions to the protocol
0000000000000000000000000000000000000000;;		Signature  DigitallySigned // The Log's signature for this SCT
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s SignedCertificateTimestamp) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("{Version:%d LogId:%s Timestamp:%d Extensions:'%s' Signature:%v}", s.SCTVersion,
0000000000000000000000000000000000000000;;			base64.StdEncoding.EncodeToString(s.LogID[:]),
0000000000000000000000000000000000000000;;			s.Timestamp,
0000000000000000000000000000000000000000;;			s.Extensions,
0000000000000000000000000000000000000000;;			s.Signature)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimestampedEntry is part of the MerkleTreeLeaf structure.
0000000000000000000000000000000000000000;;	// See RFC section 3.4
0000000000000000000000000000000000000000;;	type TimestampedEntry struct {
0000000000000000000000000000000000000000;;		Timestamp    uint64
0000000000000000000000000000000000000000;;		EntryType    LogEntryType
0000000000000000000000000000000000000000;;		X509Entry    ASN1Cert
0000000000000000000000000000000000000000;;		PrecertEntry PreCert
0000000000000000000000000000000000000000;;		Extensions   CTExtensions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MerkleTreeLeaf represents the deserialized sructure of the hash input for the
0000000000000000000000000000000000000000;;	// leaves of a log's Merkle tree. See RFC section 3.4
0000000000000000000000000000000000000000;;	type MerkleTreeLeaf struct {
0000000000000000000000000000000000000000;;		Version          Version          // the version of the protocol to which the MerkleTreeLeaf corresponds
0000000000000000000000000000000000000000;;		LeafType         MerkleLeafType   // The type of the leaf input, currently only TimestampedEntry can exist
0000000000000000000000000000000000000000;;		TimestampedEntry TimestampedEntry // The entry data itself
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Precertificate represents the parsed CT Precertificate structure.
0000000000000000000000000000000000000000;;	type Precertificate struct {
0000000000000000000000000000000000000000;;		// Raw DER bytes of the precert
0000000000000000000000000000000000000000;;		Raw []byte
0000000000000000000000000000000000000000;;		// SHA256 hash of the issuing key
0000000000000000000000000000000000000000;;		IssuerKeyHash [issuerKeyHashLength]byte
0000000000000000000000000000000000000000;;		// Parsed TBSCertificate structure (held in an x509.Certificate for ease of
0000000000000000000000000000000000000000;;		// access.
0000000000000000000000000000000000000000;;		TBSCertificate x509.Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// X509Certificate returns the X.509 Certificate contained within the
0000000000000000000000000000000000000000;;	// MerkleTreeLeaf.
0000000000000000000000000000000000000000;;	// Returns a pointer to an x509.Certificate or a non-nil error.
0000000000000000000000000000000000000000;;	func (m *MerkleTreeLeaf) X509Certificate() (*x509.Certificate, error) {
0000000000000000000000000000000000000000;;		return x509.ParseCertificate(m.TimestampedEntry.X509Entry)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sctError int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Preallocate errors for performance
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrInvalidVersion  error = sctError(1)
0000000000000000000000000000000000000000;;		ErrNotEnoughBuffer error = sctError(2)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e sctError) Error() string {
0000000000000000000000000000000000000000;;		switch e {
0000000000000000000000000000000000000000;;		case ErrInvalidVersion:
0000000000000000000000000000000000000000;;			return "invalid SCT version detected"
0000000000000000000000000000000000000000;;		case ErrNotEnoughBuffer:
0000000000000000000000000000000000000000;;			return "provided buffer was too small"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "unknown error"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
