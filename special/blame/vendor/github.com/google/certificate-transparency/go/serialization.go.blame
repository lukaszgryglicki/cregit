0000000000000000000000000000000000000000;;	package ct
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Variable size structure prefix-header byte lengths
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CertificateLengthBytes      = 3
0000000000000000000000000000000000000000;;		PreCertificateLengthBytes   = 3
0000000000000000000000000000000000000000;;		ExtensionsLengthBytes       = 2
0000000000000000000000000000000000000000;;		CertificateChainLengthBytes = 3
0000000000000000000000000000000000000000;;		SignatureLengthBytes        = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Max lengths
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MaxCertificateLength = (1 << 24) - 1
0000000000000000000000000000000000000000;;		MaxExtensionsLength  = (1 << 16) - 1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeUint(w io.Writer, value uint64, numBytes int) error {
0000000000000000000000000000000000000000;;		buf := make([]uint8, numBytes)
0000000000000000000000000000000000000000;;		for i := 0; i < numBytes; i++ {
0000000000000000000000000000000000000000;;			buf[numBytes-i-1] = uint8(value & 0xff)
0000000000000000000000000000000000000000;;			value >>= 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if value != 0 {
0000000000000000000000000000000000000000;;			return errors.New("numBytes was insufficiently large to represent value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.Write(buf); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func writeVarBytes(w io.Writer, value []byte, numLenBytes int) error {
0000000000000000000000000000000000000000;;		if err := writeUint(w, uint64(len(value)), numLenBytes); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := w.Write(value); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readUint(r io.Reader, numBytes int) (uint64, error) {
0000000000000000000000000000000000000000;;		var l uint64
0000000000000000000000000000000000000000;;		for i := 0; i < numBytes; i++ {
0000000000000000000000000000000000000000;;			l <<= 8
0000000000000000000000000000000000000000;;			var t uint8
0000000000000000000000000000000000000000;;			if err := binary.Read(r, binary.BigEndian, &t); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l |= uint64(t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reads a variable length array of bytes from |r|. |numLenBytes| specifies the
0000000000000000000000000000000000000000;;	// number of (BigEndian) prefix-bytes which contain the length of the actual
0000000000000000000000000000000000000000;;	// array data bytes that follow.
0000000000000000000000000000000000000000;;	// Allocates an array to hold the contents and returns a slice view into it if
0000000000000000000000000000000000000000;;	// the read was successful, or an error otherwise.
0000000000000000000000000000000000000000;;	func readVarBytes(r io.Reader, numLenBytes int) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case numLenBytes > 8:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("numLenBytes too large (%d)", numLenBytes)
0000000000000000000000000000000000000000;;		case numLenBytes == 0:
0000000000000000000000000000000000000000;;			return nil, errors.New("numLenBytes should be > 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l, err := readUint(r, numLenBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data := make([]byte, l)
0000000000000000000000000000000000000000;;		n, err := r.Read(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != int(l) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("short read: expected %d but got %d", l, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reads a list of ASN1Cert types from |r|
0000000000000000000000000000000000000000;;	func readASN1CertList(r io.Reader, totalLenBytes int, elementLenBytes int) ([]ASN1Cert, error) {
0000000000000000000000000000000000000000;;		listBytes, err := readVarBytes(r, totalLenBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []ASN1Cert{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		list := list.New()
0000000000000000000000000000000000000000;;		listReader := bytes.NewReader(listBytes)
0000000000000000000000000000000000000000;;		var entry []byte
0000000000000000000000000000000000000000;;		for err == nil {
0000000000000000000000000000000000000000;;			entry, err = readVarBytes(listReader, elementLenBytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err != io.EOF {
0000000000000000000000000000000000000000;;					return []ASN1Cert{}, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				list.PushBack(entry)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret := make([]ASN1Cert, list.Len())
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for e := list.Front(); e != nil; e = e.Next() {
0000000000000000000000000000000000000000;;			ret[i] = e.Value.([]byte)
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadTimestampedEntryInto parses the byte-stream representation of a
0000000000000000000000000000000000000000;;	// TimestampedEntry from |r| and populates the struct |t| with the data.  See
0000000000000000000000000000000000000000;;	// RFC section 3.4 for details on the format.
0000000000000000000000000000000000000000;;	// Returns a non-nil error if there was a problem.
0000000000000000000000000000000000000000;;	func ReadTimestampedEntryInto(r io.Reader, t *TimestampedEntry) error {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		if err = binary.Read(r, binary.BigEndian, &t.Timestamp); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err = binary.Read(r, binary.BigEndian, &t.EntryType); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.EntryType {
0000000000000000000000000000000000000000;;		case X509LogEntryType:
0000000000000000000000000000000000000000;;			if t.X509Entry, err = readVarBytes(r, CertificateLengthBytes); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case PrecertLogEntryType:
0000000000000000000000000000000000000000;;			if err := binary.Read(r, binary.BigEndian, &t.PrecertEntry.IssuerKeyHash); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.PrecertEntry.TBSCertificate, err = readVarBytes(r, PreCertificateLengthBytes); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unknown EntryType: %d", t.EntryType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t.Extensions, err = readVarBytes(r, ExtensionsLengthBytes)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadMerkleTreeLeaf parses the byte-stream representation of a MerkleTreeLeaf
0000000000000000000000000000000000000000;;	// and returns a pointer to a new MerkleTreeLeaf structure containing the
0000000000000000000000000000000000000000;;	// parsed data.
0000000000000000000000000000000000000000;;	// See RFC section 3.4 for details on the format.
0000000000000000000000000000000000000000;;	// Returns a pointer to a new MerkleTreeLeaf or non-nil error if there was a
0000000000000000000000000000000000000000;;	// problem
0000000000000000000000000000000000000000;;	func ReadMerkleTreeLeaf(r io.Reader) (*MerkleTreeLeaf, error) {
0000000000000000000000000000000000000000;;		var m MerkleTreeLeaf
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &m.Version); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.Version != V1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown Version %d", m.Version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &m.LeafType); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m.LeafType != TimestampedEntryLeafType {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown LeafType %d", m.LeafType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ReadTimestampedEntryInto(r, &m.TimestampedEntry); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalX509ChainArray unmarshalls the contents of the "chain:" entry in a
0000000000000000000000000000000000000000;;	// GetEntries response in the case where the entry refers to an X509 leaf.
0000000000000000000000000000000000000000;;	func UnmarshalX509ChainArray(b []byte) ([]ASN1Cert, error) {
0000000000000000000000000000000000000000;;		return readASN1CertList(bytes.NewReader(b), CertificateChainLengthBytes, CertificateLengthBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalPrecertChainArray unmarshalls the contents of the "chain:" entry in
0000000000000000000000000000000000000000;;	// a GetEntries response in the case where the entry refers to a Precertificate
0000000000000000000000000000000000000000;;	// leaf.
0000000000000000000000000000000000000000;;	func UnmarshalPrecertChainArray(b []byte) ([]ASN1Cert, error) {
0000000000000000000000000000000000000000;;		var chain []ASN1Cert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := bytes.NewReader(b)
0000000000000000000000000000000000000000;;		// read the pre-cert entry:
0000000000000000000000000000000000000000;;		precert, err := readVarBytes(reader, CertificateLengthBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return chain, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		chain = append(chain, precert)
0000000000000000000000000000000000000000;;		// and then read and return the chain up to the root:
0000000000000000000000000000000000000000;;		remainingChain, err := readASN1CertList(reader, CertificateChainLengthBytes, CertificateLengthBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return chain, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		chain = append(chain, remainingChain...)
0000000000000000000000000000000000000000;;		return chain, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalDigitallySigned reconstructs a DigitallySigned structure from a Reader
0000000000000000000000000000000000000000;;	func UnmarshalDigitallySigned(r io.Reader) (*DigitallySigned, error) {
0000000000000000000000000000000000000000;;		var h byte
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &h); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to read HashAlgorithm: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s byte
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &s); err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to read SignatureAlgorithm: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sig, err := readVarBytes(r, SignatureLengthBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("failed to read Signature bytes: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &DigitallySigned{
0000000000000000000000000000000000000000;;			HashAlgorithm:      HashAlgorithm(h),
0000000000000000000000000000000000000000;;			SignatureAlgorithm: SignatureAlgorithm(s),
0000000000000000000000000000000000000000;;			Signature:          sig,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalDigitallySignedHere(ds DigitallySigned, here []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		sigLen := len(ds.Signature)
0000000000000000000000000000000000000000;;		dsOutLen := 2 + SignatureLengthBytes + sigLen
0000000000000000000000000000000000000000;;		if here == nil {
0000000000000000000000000000000000000000;;			here = make([]byte, dsOutLen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(here) < dsOutLen {
0000000000000000000000000000000000000000;;			return nil, ErrNotEnoughBuffer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		here = here[0:dsOutLen]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		here[0] = byte(ds.HashAlgorithm)
0000000000000000000000000000000000000000;;		here[1] = byte(ds.SignatureAlgorithm)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(here[2:4], uint16(sigLen))
0000000000000000000000000000000000000000;;		copy(here[4:], ds.Signature)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return here, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalDigitallySigned marshalls a DigitallySigned structure into a byte array
0000000000000000000000000000000000000000;;	func MarshalDigitallySigned(ds DigitallySigned) ([]byte, error) {
0000000000000000000000000000000000000000;;		return marshalDigitallySignedHere(ds, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkCertificateFormat(cert ASN1Cert) error {
0000000000000000000000000000000000000000;;		if len(cert) == 0 {
0000000000000000000000000000000000000000;;			return errors.New("certificate is zero length")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(cert) > MaxCertificateLength {
0000000000000000000000000000000000000000;;			return errors.New("certificate too large")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkExtensionsFormat(ext CTExtensions) error {
0000000000000000000000000000000000000000;;		if len(ext) > MaxExtensionsLength {
0000000000000000000000000000000000000000;;			return errors.New("extensions too large")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serializeV1CertSCTSignatureInput(timestamp uint64, cert ASN1Cert, ext CTExtensions) ([]byte, error) {
0000000000000000000000000000000000000000;;		if err := checkCertificateFormat(cert); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkExtensionsFormat(ext); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, V1); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, CertificateTimestampSignatureType); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, timestamp); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, X509LogEntryType); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := writeVarBytes(&buf, cert, CertificateLengthBytes); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := writeVarBytes(&buf, ext, ExtensionsLengthBytes); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serializeV1PrecertSCTSignatureInput(timestamp uint64, issuerKeyHash [issuerKeyHashLength]byte, tbs []byte, ext CTExtensions) ([]byte, error) {
0000000000000000000000000000000000000000;;		if err := checkCertificateFormat(tbs); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkExtensionsFormat(ext); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, V1); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, CertificateTimestampSignatureType); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, timestamp); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, PrecertLogEntryType); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := buf.Write(issuerKeyHash[:]); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := writeVarBytes(&buf, tbs, CertificateLengthBytes); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := writeVarBytes(&buf, ext, ExtensionsLengthBytes); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serializeV1SCTSignatureInput(sct SignedCertificateTimestamp, entry LogEntry) ([]byte, error) {
0000000000000000000000000000000000000000;;		if sct.SCTVersion != V1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported SCT version, expected V1, but got %s", sct.SCTVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if entry.Leaf.LeafType != TimestampedEntryLeafType {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unsupported leaf type %s", entry.Leaf.LeafType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch entry.Leaf.TimestampedEntry.EntryType {
0000000000000000000000000000000000000000;;		case X509LogEntryType:
0000000000000000000000000000000000000000;;			return serializeV1CertSCTSignatureInput(sct.Timestamp, entry.Leaf.TimestampedEntry.X509Entry, entry.Leaf.TimestampedEntry.Extensions)
0000000000000000000000000000000000000000;;		case PrecertLogEntryType:
0000000000000000000000000000000000000000;;			return serializeV1PrecertSCTSignatureInput(sct.Timestamp, entry.Leaf.TimestampedEntry.PrecertEntry.IssuerKeyHash,
0000000000000000000000000000000000000000;;				entry.Leaf.TimestampedEntry.PrecertEntry.TBSCertificate,
0000000000000000000000000000000000000000;;				entry.Leaf.TimestampedEntry.Extensions)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown TimestampedEntryLeafType %s", entry.Leaf.TimestampedEntry.EntryType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializeSCTSignatureInput serializes the passed in sct and log entry into
0000000000000000000000000000000000000000;;	// the correct format for signing.
0000000000000000000000000000000000000000;;	func SerializeSCTSignatureInput(sct SignedCertificateTimestamp, entry LogEntry) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch sct.SCTVersion {
0000000000000000000000000000000000000000;;		case V1:
0000000000000000000000000000000000000000;;			return serializeV1SCTSignatureInput(sct, entry)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown SCT version %d", sct.SCTVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializedLength will return the space (in bytes)
0000000000000000000000000000000000000000;;	func (sct SignedCertificateTimestamp) SerializedLength() (int, error) {
0000000000000000000000000000000000000000;;		switch sct.SCTVersion {
0000000000000000000000000000000000000000;;		case V1:
0000000000000000000000000000000000000000;;			extLen := len(sct.Extensions)
0000000000000000000000000000000000000000;;			sigLen := len(sct.Signature.Signature)
0000000000000000000000000000000000000000;;			return 1 + 32 + 8 + 2 + extLen + 2 + 2 + sigLen, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0, ErrInvalidVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serializeV1SCTHere(sct SignedCertificateTimestamp, here []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		if sct.SCTVersion != V1 {
0000000000000000000000000000000000000000;;			return nil, ErrInvalidVersion
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sctLen, err := sct.SerializedLength()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if here == nil {
0000000000000000000000000000000000000000;;			here = make([]byte, sctLen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(here) < sctLen {
0000000000000000000000000000000000000000;;			return nil, ErrNotEnoughBuffer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := checkExtensionsFormat(sct.Extensions); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		here = here[0:sctLen]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write Version
0000000000000000000000000000000000000000;;		here[0] = byte(sct.SCTVersion)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write LogID
0000000000000000000000000000000000000000;;		copy(here[1:33], sct.LogID[:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write Timestamp
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(here[33:41], sct.Timestamp)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write Extensions
0000000000000000000000000000000000000000;;		extLen := len(sct.Extensions)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(here[41:43], uint16(extLen))
0000000000000000000000000000000000000000;;		n := 43 + extLen
0000000000000000000000000000000000000000;;		copy(here[43:n], sct.Extensions)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write Signature
0000000000000000000000000000000000000000;;		_, err = marshalDigitallySignedHere(sct.Signature, here[n:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return here, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializeSCTHere serializes the passed in sct into the format specified
0000000000000000000000000000000000000000;;	// by RFC6962 section 3.2.
0000000000000000000000000000000000000000;;	// If a bytes slice here is provided then it will attempt to serialize into the
0000000000000000000000000000000000000000;;	// provided byte slice, ErrNotEnoughBuffer will be returned if the buffer is
0000000000000000000000000000000000000000;;	// too small.
0000000000000000000000000000000000000000;;	// If a nil byte slice is provided, a buffer for will be allocated for you
0000000000000000000000000000000000000000;;	// The returned slice will be sliced to the correct length.
0000000000000000000000000000000000000000;;	func SerializeSCTHere(sct SignedCertificateTimestamp, here []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch sct.SCTVersion {
0000000000000000000000000000000000000000;;		case V1:
0000000000000000000000000000000000000000;;			return serializeV1SCTHere(sct, here)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown SCT version %d", sct.SCTVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializeSCT serializes the passed in sct into the format specified
0000000000000000000000000000000000000000;;	// by RFC6962 section 3.2
0000000000000000000000000000000000000000;;	// Equivalent to SerializeSCTHere(sct, nil)
0000000000000000000000000000000000000000;;	func SerializeSCT(sct SignedCertificateTimestamp) ([]byte, error) {
0000000000000000000000000000000000000000;;		return SerializeSCTHere(sct, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deserializeSCTV1(r io.Reader, sct *SignedCertificateTimestamp) error {
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &sct.LogID); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &sct.Timestamp); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ext, err := readVarBytes(r, ExtensionsLengthBytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sct.Extensions = ext
0000000000000000000000000000000000000000;;		ds, err := UnmarshalDigitallySigned(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sct.Signature = *ds
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DeserializeSCT(r io.Reader) (*SignedCertificateTimestamp, error) {
0000000000000000000000000000000000000000;;		var sct SignedCertificateTimestamp
0000000000000000000000000000000000000000;;		if err := binary.Read(r, binary.BigEndian, &sct.SCTVersion); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch sct.SCTVersion {
0000000000000000000000000000000000000000;;		case V1:
0000000000000000000000000000000000000000;;			return &sct, deserializeSCTV1(r, &sct)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unknown SCT version %d", sct.SCTVersion)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func serializeV1STHSignatureInput(sth SignedTreeHead) ([]byte, error) {
0000000000000000000000000000000000000000;;		if sth.Version != V1 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid STH version %d", sth.Version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sth.TreeSize < 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid tree size %d", sth.TreeSize)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(sth.SHA256RootHash) != crypto.SHA256.Size() {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid TreeHash length, got %d expected %d", len(sth.SHA256RootHash), crypto.SHA256.Size())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, V1); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, TreeHashSignatureType); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, sth.Timestamp); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, sth.TreeSize); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(&buf, binary.BigEndian, sth.SHA256RootHash); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Bytes(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SerializeSTHSignatureInput serializes the passed in sth into the correct
0000000000000000000000000000000000000000;;	// format for signing.
0000000000000000000000000000000000000000;;	func SerializeSTHSignatureInput(sth SignedTreeHead) ([]byte, error) {
0000000000000000000000000000000000000000;;		switch sth.Version {
0000000000000000000000000000000000000000;;		case V1:
0000000000000000000000000000000000000000;;			return serializeV1STHSignatureInput(sth)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unsupported STH version %d", sth.Version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
