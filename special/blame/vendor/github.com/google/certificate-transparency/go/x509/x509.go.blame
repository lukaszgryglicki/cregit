0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	// Package x509 parses X.509-encoded keys and certificates.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// START CT CHANGES
0000000000000000000000000000000000000000;;	// This is a fork of the go library crypto/x509 package, it's more relaxed
0000000000000000000000000000000000000000;;	// about certificates that it'll accept, and exports the TBSCertificate
0000000000000000000000000000000000000000;;	// structure.
0000000000000000000000000000000000000000;;	// END CT CHANGES
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/dsa"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go/asn1"
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go/x509/pkix"
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pkixPublicKey reflects a PKIX public key structure. See SubjectPublicKeyInfo
0000000000000000000000000000000000000000;;	// in RFC 3280.
0000000000000000000000000000000000000000;;	type pkixPublicKey struct {
0000000000000000000000000000000000000000;;		Algo      pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		BitString asn1.BitString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePKIXPublicKey parses a DER encoded public key. These values are
0000000000000000000000000000000000000000;;	// typically found in PEM blocks with "BEGIN PUBLIC KEY".
0000000000000000000000000000000000000000;;	func ParsePKIXPublicKey(derBytes []byte) (pub interface{}, err error) {
0000000000000000000000000000000000000000;;		var pki publicKeyInfo
0000000000000000000000000000000000000000;;		if _, err = asn1.Unmarshal(derBytes, &pki); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		algo := getPublicKeyAlgorithmFromOID(pki.Algorithm.Algorithm)
0000000000000000000000000000000000000000;;		if algo == UnknownPublicKeyAlgorithm {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: unknown public key algorithm")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parsePublicKey(algo, &pki)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalPublicKey(pub interface{}) (publicKeyBytes []byte, publicKeyAlgorithm pkix.AlgorithmIdentifier, err error) {
0000000000000000000000000000000000000000;;		switch pub := pub.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			publicKeyBytes, err = asn1.Marshal(rsaPublicKey{
0000000000000000000000000000000000000000;;				N: pub.N,
0000000000000000000000000000000000000000;;				E: pub.E,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			publicKeyAlgorithm.Algorithm = oidPublicKeyRSA
0000000000000000000000000000000000000000;;			// This is a NULL parameters value which is technically
0000000000000000000000000000000000000000;;			// superfluous, but most other code includes it and, by
0000000000000000000000000000000000000000;;			// doing this, we match their public key hashes.
0000000000000000000000000000000000000000;;			publicKeyAlgorithm.Parameters = asn1.RawValue{
0000000000000000000000000000000000000000;;				Tag: 5,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			publicKeyBytes = elliptic.Marshal(pub.Curve, pub.X, pub.Y)
0000000000000000000000000000000000000000;;			oid, ok := oidFromNamedCurve(pub.Curve)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, pkix.AlgorithmIdentifier{}, errors.New("x509: unsupported elliptic curve")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			publicKeyAlgorithm.Algorithm = oidPublicKeyECDSA
0000000000000000000000000000000000000000;;			var paramBytes []byte
0000000000000000000000000000000000000000;;			paramBytes, err = asn1.Marshal(oid)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			publicKeyAlgorithm.Parameters.FullBytes = paramBytes
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, pkix.AlgorithmIdentifier{}, errors.New("x509: only RSA and ECDSA public keys supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return publicKeyBytes, publicKeyAlgorithm, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.
0000000000000000000000000000000000000000;;	func MarshalPKIXPublicKey(pub interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		var publicKeyBytes []byte
0000000000000000000000000000000000000000;;		var publicKeyAlgorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if publicKeyBytes, publicKeyAlgorithm, err = marshalPublicKey(pub); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pkix := pkixPublicKey{
0000000000000000000000000000000000000000;;			Algo: publicKeyAlgorithm,
0000000000000000000000000000000000000000;;			BitString: asn1.BitString{
0000000000000000000000000000000000000000;;				Bytes:     publicKeyBytes,
0000000000000000000000000000000000000000;;				BitLength: 8 * len(publicKeyBytes),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret, _ := asn1.Marshal(pkix)
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These structures reflect the ASN.1 structure of X.509 certificates.:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type certificate struct {
0000000000000000000000000000000000000000;;		Raw                asn1.RawContent
0000000000000000000000000000000000000000;;		TBSCertificate     tbsCertificate
0000000000000000000000000000000000000000;;		SignatureAlgorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		SignatureValue     asn1.BitString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tbsCertificate struct {
0000000000000000000000000000000000000000;;		Raw                asn1.RawContent
0000000000000000000000000000000000000000;;		Version            int `asn1:"optional,explicit,default:1,tag:0"`
0000000000000000000000000000000000000000;;		SerialNumber       *big.Int
0000000000000000000000000000000000000000;;		SignatureAlgorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		Issuer             asn1.RawValue
0000000000000000000000000000000000000000;;		Validity           validity
0000000000000000000000000000000000000000;;		Subject            asn1.RawValue
0000000000000000000000000000000000000000;;		PublicKey          publicKeyInfo
0000000000000000000000000000000000000000;;		UniqueId           asn1.BitString   `asn1:"optional,tag:1"`
0000000000000000000000000000000000000000;;		SubjectUniqueId    asn1.BitString   `asn1:"optional,tag:2"`
0000000000000000000000000000000000000000;;		Extensions         []pkix.Extension `asn1:"optional,explicit,tag:3"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dsaAlgorithmParameters struct {
0000000000000000000000000000000000000000;;		P, Q, G *big.Int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dsaSignature struct {
0000000000000000000000000000000000000000;;		R, S *big.Int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ecdsaSignature dsaSignature
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type validity struct {
0000000000000000000000000000000000000000;;		NotBefore, NotAfter time.Time
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type publicKeyInfo struct {
0000000000000000000000000000000000000000;;		Raw       asn1.RawContent
0000000000000000000000000000000000000000;;		Algorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		PublicKey asn1.BitString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 5280,  4.2.1.1
0000000000000000000000000000000000000000;;	type authKeyId struct {
0000000000000000000000000000000000000000;;		Id []byte `asn1:"optional,tag:0"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SignatureAlgorithm int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		UnknownSignatureAlgorithm SignatureAlgorithm = iota
0000000000000000000000000000000000000000;;		MD2WithRSA
0000000000000000000000000000000000000000;;		MD5WithRSA
0000000000000000000000000000000000000000;;		SHA1WithRSA
0000000000000000000000000000000000000000;;		SHA256WithRSA
0000000000000000000000000000000000000000;;		SHA384WithRSA
0000000000000000000000000000000000000000;;		SHA512WithRSA
0000000000000000000000000000000000000000;;		DSAWithSHA1
0000000000000000000000000000000000000000;;		DSAWithSHA256
0000000000000000000000000000000000000000;;		ECDSAWithSHA1
0000000000000000000000000000000000000000;;		ECDSAWithSHA256
0000000000000000000000000000000000000000;;		ECDSAWithSHA384
0000000000000000000000000000000000000000;;		ECDSAWithSHA512
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PublicKeyAlgorithm int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		UnknownPublicKeyAlgorithm PublicKeyAlgorithm = iota
0000000000000000000000000000000000000000;;		RSA
0000000000000000000000000000000000000000;;		DSA
0000000000000000000000000000000000000000;;		ECDSA
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OIDs for signature algorithms
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// pkcs-1 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//    iso(1) member-body(2) us(840) rsadsi(113549) pkcs(1) 1 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// RFC 3279 2.2.1 RSA Signature Algorithms
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// md2WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 2 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// md5WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 4 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// sha-1WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 5 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// dsaWithSha1 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//    iso(1) member-body(2) us(840) x9-57(10040) x9cm(4) 3 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// RFC 3279 2.2.3 ECDSA Signature Algorithm
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ecdsa-with-SHA1 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	// 	  iso(1) member-body(2) us(840) ansi-x962(10045)
0000000000000000000000000000000000000000;;	//    signatures(4) ecdsa-with-SHA1(1)}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// RFC 4055 5 PKCS #1 Version 1.5
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// sha256WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 11 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// sha384WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 12 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// sha512WithRSAEncryption OBJECT IDENTIFIER ::= { pkcs-1 13 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// RFC 5758 3.1 DSA Signature Algorithms
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// dsaWithSha256 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//    joint-iso-ccitt(2) country(16) us(840) organization(1) gov(101)
0000000000000000000000000000000000000000;;	//    csor(3) algorithms(4) id-dsa-with-sha2(3) 2}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// RFC 5758 3.2 ECDSA Signature Algorithm
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ecdsa-with-SHA256 OBJECT IDENTIFIER ::= { iso(1) member-body(2)
0000000000000000000000000000000000000000;;	//    us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 2 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ecdsa-with-SHA384 OBJECT IDENTIFIER ::= { iso(1) member-body(2)
0000000000000000000000000000000000000000;;	//    us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 3 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ecdsa-with-SHA512 OBJECT IDENTIFIER ::= { iso(1) member-body(2)
0000000000000000000000000000000000000000;;	//    us(840) ansi-X9-62(10045) signatures(4) ecdsa-with-SHA2(3) 4 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidSignatureMD2WithRSA      = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 2}
0000000000000000000000000000000000000000;;		oidSignatureMD5WithRSA      = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 4}
0000000000000000000000000000000000000000;;		oidSignatureSHA1WithRSA     = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 5}
0000000000000000000000000000000000000000;;		oidSignatureSHA256WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 11}
0000000000000000000000000000000000000000;;		oidSignatureSHA384WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 12}
0000000000000000000000000000000000000000;;		oidSignatureSHA512WithRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 13}
0000000000000000000000000000000000000000;;		oidSignatureDSAWithSHA1     = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 3}
0000000000000000000000000000000000000000;;		oidSignatureDSAWithSHA256   = asn1.ObjectIdentifier{2, 16, 840, 1, 101, 4, 3, 2}
0000000000000000000000000000000000000000;;		oidSignatureECDSAWithSHA1   = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 1}
0000000000000000000000000000000000000000;;		oidSignatureECDSAWithSHA256 = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 3, 2}
0000000000000000000000000000000000000000;;		oidSignatureECDSAWithSHA384 = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 3, 3}
0000000000000000000000000000000000000000;;		oidSignatureECDSAWithSHA512 = asn1.ObjectIdentifier{1, 2, 840, 10045, 4, 3, 4}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSignatureAlgorithmFromOID(oid asn1.ObjectIdentifier) SignatureAlgorithm {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureMD2WithRSA):
0000000000000000000000000000000000000000;;			return MD2WithRSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureMD5WithRSA):
0000000000000000000000000000000000000000;;			return MD5WithRSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureSHA1WithRSA):
0000000000000000000000000000000000000000;;			return SHA1WithRSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureSHA256WithRSA):
0000000000000000000000000000000000000000;;			return SHA256WithRSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureSHA384WithRSA):
0000000000000000000000000000000000000000;;			return SHA384WithRSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureSHA512WithRSA):
0000000000000000000000000000000000000000;;			return SHA512WithRSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureDSAWithSHA1):
0000000000000000000000000000000000000000;;			return DSAWithSHA1
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureDSAWithSHA256):
0000000000000000000000000000000000000000;;			return DSAWithSHA256
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureECDSAWithSHA1):
0000000000000000000000000000000000000000;;			return ECDSAWithSHA1
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureECDSAWithSHA256):
0000000000000000000000000000000000000000;;			return ECDSAWithSHA256
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureECDSAWithSHA384):
0000000000000000000000000000000000000000;;			return ECDSAWithSHA384
0000000000000000000000000000000000000000;;		case oid.Equal(oidSignatureECDSAWithSHA512):
0000000000000000000000000000000000000000;;			return ECDSAWithSHA512
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return UnknownSignatureAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 3279, 2.3 Public Key Algorithms
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// pkcs-1 OBJECT IDENTIFIER ::== { iso(1) member-body(2) us(840)
0000000000000000000000000000000000000000;;	//    rsadsi(113549) pkcs(1) 1 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// rsaEncryption OBJECT IDENTIFIER ::== { pkcs1-1 1 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// id-dsa OBJECT IDENTIFIER ::== { iso(1) member-body(2) us(840)
0000000000000000000000000000000000000000;;	//    x9-57(10040) x9cm(4) 1 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// RFC 5480, 2.1.1 Unrestricted Algorithm Identifier and Parameters
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// id-ecPublicKey OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//       iso(1) member-body(2) us(840) ansi-X9-62(10045) keyType(2) 1 }
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidPublicKeyRSA   = asn1.ObjectIdentifier{1, 2, 840, 113549, 1, 1, 1}
0000000000000000000000000000000000000000;;		oidPublicKeyDSA   = asn1.ObjectIdentifier{1, 2, 840, 10040, 4, 1}
0000000000000000000000000000000000000000;;		oidPublicKeyECDSA = asn1.ObjectIdentifier{1, 2, 840, 10045, 2, 1}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getPublicKeyAlgorithmFromOID(oid asn1.ObjectIdentifier) PublicKeyAlgorithm {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case oid.Equal(oidPublicKeyRSA):
0000000000000000000000000000000000000000;;			return RSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidPublicKeyDSA):
0000000000000000000000000000000000000000;;			return DSA
0000000000000000000000000000000000000000;;		case oid.Equal(oidPublicKeyECDSA):
0000000000000000000000000000000000000000;;			return ECDSA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return UnknownPublicKeyAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 5480, 2.1.1.1. Named Curve
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// secp224r1 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//   iso(1) identified-organization(3) certicom(132) curve(0) 33 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// secp256r1 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//   iso(1) member-body(2) us(840) ansi-X9-62(10045) curves(3)
0000000000000000000000000000000000000000;;	//   prime(1) 7 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// secp384r1 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//   iso(1) identified-organization(3) certicom(132) curve(0) 34 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// secp521r1 OBJECT IDENTIFIER ::= {
0000000000000000000000000000000000000000;;	//   iso(1) identified-organization(3) certicom(132) curve(0) 35 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NB: secp256r1 is equivalent to prime256v1
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidNamedCurveP224 = asn1.ObjectIdentifier{1, 3, 132, 0, 33}
0000000000000000000000000000000000000000;;		oidNamedCurveP256 = asn1.ObjectIdentifier{1, 2, 840, 10045, 3, 1, 7}
0000000000000000000000000000000000000000;;		oidNamedCurveP384 = asn1.ObjectIdentifier{1, 3, 132, 0, 34}
0000000000000000000000000000000000000000;;		oidNamedCurveP521 = asn1.ObjectIdentifier{1, 3, 132, 0, 35}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func namedCurveFromOID(oid asn1.ObjectIdentifier) elliptic.Curve {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case oid.Equal(oidNamedCurveP224):
0000000000000000000000000000000000000000;;			return elliptic.P224()
0000000000000000000000000000000000000000;;		case oid.Equal(oidNamedCurveP256):
0000000000000000000000000000000000000000;;			return elliptic.P256()
0000000000000000000000000000000000000000;;		case oid.Equal(oidNamedCurveP384):
0000000000000000000000000000000000000000;;			return elliptic.P384()
0000000000000000000000000000000000000000;;		case oid.Equal(oidNamedCurveP521):
0000000000000000000000000000000000000000;;			return elliptic.P521()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func oidFromNamedCurve(curve elliptic.Curve) (asn1.ObjectIdentifier, bool) {
0000000000000000000000000000000000000000;;		switch curve {
0000000000000000000000000000000000000000;;		case elliptic.P224():
0000000000000000000000000000000000000000;;			return oidNamedCurveP224, true
0000000000000000000000000000000000000000;;		case elliptic.P256():
0000000000000000000000000000000000000000;;			return oidNamedCurveP256, true
0000000000000000000000000000000000000000;;		case elliptic.P384():
0000000000000000000000000000000000000000;;			return oidNamedCurveP384, true
0000000000000000000000000000000000000000;;		case elliptic.P521():
0000000000000000000000000000000000000000;;			return oidNamedCurveP521, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyUsage represents the set of actions that are valid for a given key. It's
0000000000000000000000000000000000000000;;	// a bitmap of the KeyUsage* constants.
0000000000000000000000000000000000000000;;	type KeyUsage int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		KeyUsageDigitalSignature KeyUsage = 1 << iota
0000000000000000000000000000000000000000;;		KeyUsageContentCommitment
0000000000000000000000000000000000000000;;		KeyUsageKeyEncipherment
0000000000000000000000000000000000000000;;		KeyUsageDataEncipherment
0000000000000000000000000000000000000000;;		KeyUsageKeyAgreement
0000000000000000000000000000000000000000;;		KeyUsageCertSign
0000000000000000000000000000000000000000;;		KeyUsageCRLSign
0000000000000000000000000000000000000000;;		KeyUsageEncipherOnly
0000000000000000000000000000000000000000;;		KeyUsageDecipherOnly
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 5280, 4.2.1.12  Extended Key Usage
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// anyExtendedKeyUsage OBJECT IDENTIFIER ::= { id-ce-extKeyUsage 0 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// id-kp OBJECT IDENTIFIER ::= { id-pkix 3 }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// id-kp-serverAuth             OBJECT IDENTIFIER ::= { id-kp 1 }
0000000000000000000000000000000000000000;;	// id-kp-clientAuth             OBJECT IDENTIFIER ::= { id-kp 2 }
0000000000000000000000000000000000000000;;	// id-kp-codeSigning            OBJECT IDENTIFIER ::= { id-kp 3 }
0000000000000000000000000000000000000000;;	// id-kp-emailProtection        OBJECT IDENTIFIER ::= { id-kp 4 }
0000000000000000000000000000000000000000;;	// id-kp-timeStamping           OBJECT IDENTIFIER ::= { id-kp 8 }
0000000000000000000000000000000000000000;;	// id-kp-OCSPSigning            OBJECT IDENTIFIER ::= { id-kp 9 }
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidExtKeyUsageAny                        = asn1.ObjectIdentifier{2, 5, 29, 37, 0}
0000000000000000000000000000000000000000;;		oidExtKeyUsageServerAuth                 = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 1}
0000000000000000000000000000000000000000;;		oidExtKeyUsageClientAuth                 = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 2}
0000000000000000000000000000000000000000;;		oidExtKeyUsageCodeSigning                = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 3}
0000000000000000000000000000000000000000;;		oidExtKeyUsageEmailProtection            = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 4}
0000000000000000000000000000000000000000;;		oidExtKeyUsageIPSECEndSystem             = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 5}
0000000000000000000000000000000000000000;;		oidExtKeyUsageIPSECTunnel                = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 6}
0000000000000000000000000000000000000000;;		oidExtKeyUsageIPSECUser                  = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 7}
0000000000000000000000000000000000000000;;		oidExtKeyUsageTimeStamping               = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 8}
0000000000000000000000000000000000000000;;		oidExtKeyUsageOCSPSigning                = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 3, 9}
0000000000000000000000000000000000000000;;		oidExtKeyUsageMicrosoftServerGatedCrypto = asn1.ObjectIdentifier{1, 3, 6, 1, 4, 1, 311, 10, 3, 3}
0000000000000000000000000000000000000000;;		oidExtKeyUsageNetscapeServerGatedCrypto  = asn1.ObjectIdentifier{2, 16, 840, 1, 113730, 4, 1}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtKeyUsage represents an extended set of actions that are valid for a given key.
0000000000000000000000000000000000000000;;	// Each of the ExtKeyUsage* constants define a unique action.
0000000000000000000000000000000000000000;;	type ExtKeyUsage int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ExtKeyUsageAny ExtKeyUsage = iota
0000000000000000000000000000000000000000;;		ExtKeyUsageServerAuth
0000000000000000000000000000000000000000;;		ExtKeyUsageClientAuth
0000000000000000000000000000000000000000;;		ExtKeyUsageCodeSigning
0000000000000000000000000000000000000000;;		ExtKeyUsageEmailProtection
0000000000000000000000000000000000000000;;		ExtKeyUsageIPSECEndSystem
0000000000000000000000000000000000000000;;		ExtKeyUsageIPSECTunnel
0000000000000000000000000000000000000000;;		ExtKeyUsageIPSECUser
0000000000000000000000000000000000000000;;		ExtKeyUsageTimeStamping
0000000000000000000000000000000000000000;;		ExtKeyUsageOCSPSigning
0000000000000000000000000000000000000000;;		ExtKeyUsageMicrosoftServerGatedCrypto
0000000000000000000000000000000000000000;;		ExtKeyUsageNetscapeServerGatedCrypto
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extKeyUsageOIDs contains the mapping between an ExtKeyUsage and its OID.
0000000000000000000000000000000000000000;;	var extKeyUsageOIDs = []struct {
0000000000000000000000000000000000000000;;		extKeyUsage ExtKeyUsage
0000000000000000000000000000000000000000;;		oid         asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;	}{
0000000000000000000000000000000000000000;;		{ExtKeyUsageAny, oidExtKeyUsageAny},
0000000000000000000000000000000000000000;;		{ExtKeyUsageServerAuth, oidExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;		{ExtKeyUsageClientAuth, oidExtKeyUsageClientAuth},
0000000000000000000000000000000000000000;;		{ExtKeyUsageCodeSigning, oidExtKeyUsageCodeSigning},
0000000000000000000000000000000000000000;;		{ExtKeyUsageEmailProtection, oidExtKeyUsageEmailProtection},
0000000000000000000000000000000000000000;;		{ExtKeyUsageIPSECEndSystem, oidExtKeyUsageIPSECEndSystem},
0000000000000000000000000000000000000000;;		{ExtKeyUsageIPSECTunnel, oidExtKeyUsageIPSECTunnel},
0000000000000000000000000000000000000000;;		{ExtKeyUsageIPSECUser, oidExtKeyUsageIPSECUser},
0000000000000000000000000000000000000000;;		{ExtKeyUsageTimeStamping, oidExtKeyUsageTimeStamping},
0000000000000000000000000000000000000000;;		{ExtKeyUsageOCSPSigning, oidExtKeyUsageOCSPSigning},
0000000000000000000000000000000000000000;;		{ExtKeyUsageMicrosoftServerGatedCrypto, oidExtKeyUsageMicrosoftServerGatedCrypto},
0000000000000000000000000000000000000000;;		{ExtKeyUsageNetscapeServerGatedCrypto, oidExtKeyUsageNetscapeServerGatedCrypto},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func extKeyUsageFromOID(oid asn1.ObjectIdentifier) (eku ExtKeyUsage, ok bool) {
0000000000000000000000000000000000000000;;		for _, pair := range extKeyUsageOIDs {
0000000000000000000000000000000000000000;;			if oid.Equal(pair.oid) {
0000000000000000000000000000000000000000;;				return pair.extKeyUsage, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func oidFromExtKeyUsage(eku ExtKeyUsage) (oid asn1.ObjectIdentifier, ok bool) {
0000000000000000000000000000000000000000;;		for _, pair := range extKeyUsageOIDs {
0000000000000000000000000000000000000000;;			if eku == pair.extKeyUsage {
0000000000000000000000000000000000000000;;				return pair.oid, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Certificate represents an X.509 certificate.
0000000000000000000000000000000000000000;;	type Certificate struct {
0000000000000000000000000000000000000000;;		Raw                     []byte // Complete ASN.1 DER content (certificate, signature algorithm and signature).
0000000000000000000000000000000000000000;;		RawTBSCertificate       []byte // Certificate part of raw ASN.1 DER content.
0000000000000000000000000000000000000000;;		RawSubjectPublicKeyInfo []byte // DER encoded SubjectPublicKeyInfo.
0000000000000000000000000000000000000000;;		RawSubject              []byte // DER encoded Subject
0000000000000000000000000000000000000000;;		RawIssuer               []byte // DER encoded Issuer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Signature          []byte
0000000000000000000000000000000000000000;;		SignatureAlgorithm SignatureAlgorithm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PublicKeyAlgorithm PublicKeyAlgorithm
0000000000000000000000000000000000000000;;		PublicKey          interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Version             int
0000000000000000000000000000000000000000;;		SerialNumber        *big.Int
0000000000000000000000000000000000000000;;		Issuer              pkix.Name
0000000000000000000000000000000000000000;;		Subject             pkix.Name
0000000000000000000000000000000000000000;;		NotBefore, NotAfter time.Time // Validity bounds.
0000000000000000000000000000000000000000;;		KeyUsage            KeyUsage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extensions contains raw X.509 extensions. When parsing certificates,
0000000000000000000000000000000000000000;;		// this can be used to extract non-critical extensions that are not
0000000000000000000000000000000000000000;;		// parsed by this package. When marshaling certificates, the Extensions
0000000000000000000000000000000000000000;;		// field is ignored, see ExtraExtensions.
0000000000000000000000000000000000000000;;		Extensions []pkix.Extension
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExtraExtensions contains extensions to be copied, raw, into any
0000000000000000000000000000000000000000;;		// marshaled certificates. Values override any extensions that would
0000000000000000000000000000000000000000;;		// otherwise be produced based on the other fields. The ExtraExtensions
0000000000000000000000000000000000000000;;		// field is not populated when parsing certificates, see Extensions.
0000000000000000000000000000000000000000;;		ExtraExtensions []pkix.Extension
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ExtKeyUsage        []ExtKeyUsage           // Sequence of extended key usages.
0000000000000000000000000000000000000000;;		UnknownExtKeyUsage []asn1.ObjectIdentifier // Encountered extended key usages unknown to this package.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		BasicConstraintsValid bool // if true then the next two fields are valid.
0000000000000000000000000000000000000000;;		IsCA                  bool
0000000000000000000000000000000000000000;;		MaxPathLen            int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SubjectKeyId   []byte
0000000000000000000000000000000000000000;;		AuthorityKeyId []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RFC 5280, 4.2.2.1 (Authority Information Access)
0000000000000000000000000000000000000000;;		OCSPServer            []string
0000000000000000000000000000000000000000;;		IssuingCertificateURL []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Subject Alternate Name values
0000000000000000000000000000000000000000;;		DNSNames       []string
0000000000000000000000000000000000000000;;		EmailAddresses []string
0000000000000000000000000000000000000000;;		IPAddresses    []net.IP
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name constraints
0000000000000000000000000000000000000000;;		PermittedDNSDomainsCritical bool // if true then the name constraints are marked critical.
0000000000000000000000000000000000000000;;		PermittedDNSDomains         []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CRL Distribution Points
0000000000000000000000000000000000000000;;		CRLDistributionPoints []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		PolicyIdentifiers []asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrUnsupportedAlgorithm results from attempting to perform an operation that
0000000000000000000000000000000000000000;;	// involves algorithms that are not currently implemented.
0000000000000000000000000000000000000000;;	var ErrUnsupportedAlgorithm = errors.New("x509: cannot verify signature: algorithm unimplemented")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConstraintViolationError results when a requested usage is not permitted by
0000000000000000000000000000000000000000;;	// a certificate. For example: checking a signature when the public key isn't a
0000000000000000000000000000000000000000;;	// certificate signing key.
0000000000000000000000000000000000000000;;	type ConstraintViolationError struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ConstraintViolationError) Error() string {
0000000000000000000000000000000000000000;;		return "x509: invalid signature: parent certificate cannot sign this kind of certificate"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Certificate) Equal(other *Certificate) bool {
0000000000000000000000000000000000000000;;		return bytes.Equal(c.Raw, other.Raw)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Entrust have a broken root certificate (CN=Entrust.net Certification
0000000000000000000000000000000000000000;;	// Authority (2048)) which isn't marked as a CA certificate and is thus invalid
0000000000000000000000000000000000000000;;	// according to PKIX.
0000000000000000000000000000000000000000;;	// We recognise this certificate by its SubjectPublicKeyInfo and exempt it
0000000000000000000000000000000000000000;;	// from the Basic Constraints requirement.
0000000000000000000000000000000000000000;;	// See http://www.entrust.net/knowledge-base/technote.cfm?tn=7869
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TODO(agl): remove this hack once their reissued root is sufficiently
0000000000000000000000000000000000000000;;	// widespread.
0000000000000000000000000000000000000000;;	var entrustBrokenSPKI = []byte{
0000000000000000000000000000000000000000;;		0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09,
0000000000000000000000000000000000000000;;		0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
0000000000000000000000000000000000000000;;		0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00,
0000000000000000000000000000000000000000;;		0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
0000000000000000000000000000000000000000;;		0x00, 0x97, 0xa3, 0x2d, 0x3c, 0x9e, 0xde, 0x05,
0000000000000000000000000000000000000000;;		0xda, 0x13, 0xc2, 0x11, 0x8d, 0x9d, 0x8e, 0xe3,
0000000000000000000000000000000000000000;;		0x7f, 0xc7, 0x4b, 0x7e, 0x5a, 0x9f, 0xb3, 0xff,
0000000000000000000000000000000000000000;;		0x62, 0xab, 0x73, 0xc8, 0x28, 0x6b, 0xba, 0x10,
0000000000000000000000000000000000000000;;		0x64, 0x82, 0x87, 0x13, 0xcd, 0x57, 0x18, 0xff,
0000000000000000000000000000000000000000;;		0x28, 0xce, 0xc0, 0xe6, 0x0e, 0x06, 0x91, 0x50,
0000000000000000000000000000000000000000;;		0x29, 0x83, 0xd1, 0xf2, 0xc3, 0x2a, 0xdb, 0xd8,
0000000000000000000000000000000000000000;;		0xdb, 0x4e, 0x04, 0xcc, 0x00, 0xeb, 0x8b, 0xb6,
0000000000000000000000000000000000000000;;		0x96, 0xdc, 0xbc, 0xaa, 0xfa, 0x52, 0x77, 0x04,
0000000000000000000000000000000000000000;;		0xc1, 0xdb, 0x19, 0xe4, 0xae, 0x9c, 0xfd, 0x3c,
0000000000000000000000000000000000000000;;		0x8b, 0x03, 0xef, 0x4d, 0xbc, 0x1a, 0x03, 0x65,
0000000000000000000000000000000000000000;;		0xf9, 0xc1, 0xb1, 0x3f, 0x72, 0x86, 0xf2, 0x38,
0000000000000000000000000000000000000000;;		0xaa, 0x19, 0xae, 0x10, 0x88, 0x78, 0x28, 0xda,
0000000000000000000000000000000000000000;;		0x75, 0xc3, 0x3d, 0x02, 0x82, 0x02, 0x9c, 0xb9,
0000000000000000000000000000000000000000;;		0xc1, 0x65, 0x77, 0x76, 0x24, 0x4c, 0x98, 0xf7,
0000000000000000000000000000000000000000;;		0x6d, 0x31, 0x38, 0xfb, 0xdb, 0xfe, 0xdb, 0x37,
0000000000000000000000000000000000000000;;		0x02, 0x76, 0xa1, 0x18, 0x97, 0xa6, 0xcc, 0xde,
0000000000000000000000000000000000000000;;		0x20, 0x09, 0x49, 0x36, 0x24, 0x69, 0x42, 0xf6,
0000000000000000000000000000000000000000;;		0xe4, 0x37, 0x62, 0xf1, 0x59, 0x6d, 0xa9, 0x3c,
0000000000000000000000000000000000000000;;		0xed, 0x34, 0x9c, 0xa3, 0x8e, 0xdb, 0xdc, 0x3a,
0000000000000000000000000000000000000000;;		0xd7, 0xf7, 0x0a, 0x6f, 0xef, 0x2e, 0xd8, 0xd5,
0000000000000000000000000000000000000000;;		0x93, 0x5a, 0x7a, 0xed, 0x08, 0x49, 0x68, 0xe2,
0000000000000000000000000000000000000000;;		0x41, 0xe3, 0x5a, 0x90, 0xc1, 0x86, 0x55, 0xfc,
0000000000000000000000000000000000000000;;		0x51, 0x43, 0x9d, 0xe0, 0xb2, 0xc4, 0x67, 0xb4,
0000000000000000000000000000000000000000;;		0xcb, 0x32, 0x31, 0x25, 0xf0, 0x54, 0x9f, 0x4b,
0000000000000000000000000000000000000000;;		0xd1, 0x6f, 0xdb, 0xd4, 0xdd, 0xfc, 0xaf, 0x5e,
0000000000000000000000000000000000000000;;		0x6c, 0x78, 0x90, 0x95, 0xde, 0xca, 0x3a, 0x48,
0000000000000000000000000000000000000000;;		0xb9, 0x79, 0x3c, 0x9b, 0x19, 0xd6, 0x75, 0x05,
0000000000000000000000000000000000000000;;		0xa0, 0xf9, 0x88, 0xd7, 0xc1, 0xe8, 0xa5, 0x09,
0000000000000000000000000000000000000000;;		0xe4, 0x1a, 0x15, 0xdc, 0x87, 0x23, 0xaa, 0xb2,
0000000000000000000000000000000000000000;;		0x75, 0x8c, 0x63, 0x25, 0x87, 0xd8, 0xf8, 0x3d,
0000000000000000000000000000000000000000;;		0xa6, 0xc2, 0xcc, 0x66, 0xff, 0xa5, 0x66, 0x68,
0000000000000000000000000000000000000000;;		0x55, 0x02, 0x03, 0x01, 0x00, 0x01,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckSignatureFrom verifies that the signature on c is a valid signature
0000000000000000000000000000000000000000;;	// from parent.
0000000000000000000000000000000000000000;;	func (c *Certificate) CheckSignatureFrom(parent *Certificate) (err error) {
0000000000000000000000000000000000000000;;		// RFC 5280, 4.2.1.9:
0000000000000000000000000000000000000000;;		// "If the basic constraints extension is not present in a version 3
0000000000000000000000000000000000000000;;		// certificate, or the extension is present but the cA boolean is not
0000000000000000000000000000000000000000;;		// asserted, then the certified public key MUST NOT be used to verify
0000000000000000000000000000000000000000;;		// certificate signatures."
0000000000000000000000000000000000000000;;		// (except for Entrust, see comment above entrustBrokenSPKI)
0000000000000000000000000000000000000000;;		if (parent.Version == 3 && !parent.BasicConstraintsValid ||
0000000000000000000000000000000000000000;;			parent.BasicConstraintsValid && !parent.IsCA) &&
0000000000000000000000000000000000000000;;			!bytes.Equal(c.RawSubjectPublicKeyInfo, entrustBrokenSPKI) {
0000000000000000000000000000000000000000;;			return ConstraintViolationError{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parent.KeyUsage != 0 && parent.KeyUsage&KeyUsageCertSign == 0 {
0000000000000000000000000000000000000000;;			return ConstraintViolationError{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if parent.PublicKeyAlgorithm == UnknownPublicKeyAlgorithm {
0000000000000000000000000000000000000000;;			return ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(agl): don't ignore the path length constraint.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parent.CheckSignature(c.SignatureAlgorithm, c.RawTBSCertificate, c.Signature)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckSignature verifies that signature is a valid signature over signed from
0000000000000000000000000000000000000000;;	// c's public key.
0000000000000000000000000000000000000000;;	func (c *Certificate) CheckSignature(algo SignatureAlgorithm, signed, signature []byte) (err error) {
0000000000000000000000000000000000000000;;		var hashType crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch algo {
0000000000000000000000000000000000000000;;		case SHA1WithRSA, DSAWithSHA1, ECDSAWithSHA1:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA1
0000000000000000000000000000000000000000;;		case SHA256WithRSA, DSAWithSHA256, ECDSAWithSHA256:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA256
0000000000000000000000000000000000000000;;		case SHA384WithRSA, ECDSAWithSHA384:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA384
0000000000000000000000000000000000000000;;		case SHA512WithRSA, ECDSAWithSHA512:
0000000000000000000000000000000000000000;;			hashType = crypto.SHA512
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !hashType.Available() {
0000000000000000000000000000000000000000;;			return ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := hashType.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h.Write(signed)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch pub := c.PublicKey.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			return rsa.VerifyPKCS1v15(pub, hashType, digest, signature)
0000000000000000000000000000000000000000;;		case *dsa.PublicKey:
0000000000000000000000000000000000000000;;			dsaSig := new(dsaSignature)
0000000000000000000000000000000000000000;;			if _, err := asn1.Unmarshal(signature, dsaSig); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if dsaSig.R.Sign() <= 0 || dsaSig.S.Sign() <= 0 {
0000000000000000000000000000000000000000;;				return errors.New("x509: DSA signature contained zero or negative values")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !dsa.Verify(pub, digest, dsaSig.R, dsaSig.S) {
0000000000000000000000000000000000000000;;				return errors.New("x509: DSA verification failure")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			ecdsaSig := new(ecdsaSignature)
0000000000000000000000000000000000000000;;			if _, err := asn1.Unmarshal(signature, ecdsaSig); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ecdsaSig.R.Sign() <= 0 || ecdsaSig.S.Sign() <= 0 {
0000000000000000000000000000000000000000;;				return errors.New("x509: ECDSA signature contained zero or negative values")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !ecdsa.Verify(pub, digest, ecdsaSig.R, ecdsaSig.S) {
0000000000000000000000000000000000000000;;				return errors.New("x509: ECDSA verification failure")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrUnsupportedAlgorithm
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckCRLSignature checks that the signature in crl is from c.
0000000000000000000000000000000000000000;;	func (c *Certificate) CheckCRLSignature(crl *pkix.CertificateList) (err error) {
0000000000000000000000000000000000000000;;		algo := getSignatureAlgorithmFromOID(crl.SignatureAlgorithm.Algorithm)
0000000000000000000000000000000000000000;;		return c.CheckSignature(algo, crl.TBSCertList.Raw, crl.SignatureValue.RightAlign())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// START CT CHANGES
0000000000000000000000000000000000000000;;	type UnhandledCriticalExtension struct {
0000000000000000000000000000000000000000;;		ID asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h UnhandledCriticalExtension) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("x509: unhandled critical extension (%v)", h.ID)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// END CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type basicConstraints struct {
0000000000000000000000000000000000000000;;		IsCA       bool `asn1:"optional"`
0000000000000000000000000000000000000000;;		MaxPathLen int  `asn1:"optional,default:-1"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 5280 4.2.1.4
0000000000000000000000000000000000000000;;	type policyInformation struct {
0000000000000000000000000000000000000000;;		Policy asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		// policyQualifiers omitted
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 5280, 4.2.1.10
0000000000000000000000000000000000000000;;	type nameConstraints struct {
0000000000000000000000000000000000000000;;		Permitted []generalSubtree `asn1:"optional,tag:0"`
0000000000000000000000000000000000000000;;		Excluded  []generalSubtree `asn1:"optional,tag:1"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type generalSubtree struct {
0000000000000000000000000000000000000000;;		Name string `asn1:"tag:2,optional,ia5"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 5280, 4.2.2.1
0000000000000000000000000000000000000000;;	type authorityInfoAccess struct {
0000000000000000000000000000000000000000;;		Method   asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Location asn1.RawValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 5280, 4.2.1.14
0000000000000000000000000000000000000000;;	type distributionPoint struct {
0000000000000000000000000000000000000000;;		DistributionPoint distributionPointName `asn1:"optional,tag:0"`
0000000000000000000000000000000000000000;;		Reason            asn1.BitString        `asn1:"optional,tag:1"`
0000000000000000000000000000000000000000;;		CRLIssuer         asn1.RawValue         `asn1:"optional,tag:2"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type distributionPointName struct {
0000000000000000000000000000000000000000;;		FullName     asn1.RawValue    `asn1:"optional,tag:0"`
0000000000000000000000000000000000000000;;		RelativeName pkix.RDNSequence `asn1:"optional,tag:1"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePublicKey(algo PublicKeyAlgorithm, keyData *publicKeyInfo) (interface{}, error) {
0000000000000000000000000000000000000000;;		asn1Data := keyData.PublicKey.RightAlign()
0000000000000000000000000000000000000000;;		switch algo {
0000000000000000000000000000000000000000;;		case RSA:
0000000000000000000000000000000000000000;;			p := new(rsaPublicKey)
0000000000000000000000000000000000000000;;			_, err := asn1.Unmarshal(asn1Data, p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if p.N.Sign() <= 0 {
0000000000000000000000000000000000000000;;				return nil, errors.New("x509: RSA modulus is not a positive number")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.E <= 0 {
0000000000000000000000000000000000000000;;				return nil, errors.New("x509: RSA public exponent is not a positive number")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			pub := &rsa.PublicKey{
0000000000000000000000000000000000000000;;				E: p.E,
0000000000000000000000000000000000000000;;				N: p.N,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pub, nil
0000000000000000000000000000000000000000;;		case DSA:
0000000000000000000000000000000000000000;;			var p *big.Int
0000000000000000000000000000000000000000;;			_, err := asn1.Unmarshal(asn1Data, &p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			paramsData := keyData.Algorithm.Parameters.FullBytes
0000000000000000000000000000000000000000;;			params := new(dsaAlgorithmParameters)
0000000000000000000000000000000000000000;;			_, err = asn1.Unmarshal(paramsData, params)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if p.Sign() <= 0 || params.P.Sign() <= 0 || params.Q.Sign() <= 0 || params.G.Sign() <= 0 {
0000000000000000000000000000000000000000;;				return nil, errors.New("x509: zero or negative DSA parameter")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pub := &dsa.PublicKey{
0000000000000000000000000000000000000000;;				Parameters: dsa.Parameters{
0000000000000000000000000000000000000000;;					P: params.P,
0000000000000000000000000000000000000000;;					Q: params.Q,
0000000000000000000000000000000000000000;;					G: params.G,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				Y: p,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pub, nil
0000000000000000000000000000000000000000;;		case ECDSA:
0000000000000000000000000000000000000000;;			paramsData := keyData.Algorithm.Parameters.FullBytes
0000000000000000000000000000000000000000;;			namedCurveOID := new(asn1.ObjectIdentifier)
0000000000000000000000000000000000000000;;			_, err := asn1.Unmarshal(paramsData, namedCurveOID)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			namedCurve := namedCurveFromOID(*namedCurveOID)
0000000000000000000000000000000000000000;;			if namedCurve == nil {
0000000000000000000000000000000000000000;;				return nil, errors.New("x509: unsupported elliptic curve")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x, y := elliptic.Unmarshal(namedCurve, asn1Data)
0000000000000000000000000000000000000000;;			if x == nil {
0000000000000000000000000000000000000000;;				return nil, errors.New("x509: failed to unmarshal elliptic curve point")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pub := &ecdsa.PublicKey{
0000000000000000000000000000000000000000;;				Curve: namedCurve,
0000000000000000000000000000000000000000;;				X:     x,
0000000000000000000000000000000000000000;;				Y:     y,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return pub, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// START CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NonFatalErrors is an error type which can hold a number of other errors.
0000000000000000000000000000000000000000;;	// It's used to collect a range of non-fatal errors which occur while parsing
0000000000000000000000000000000000000000;;	// a certificate, that way we can still match on certs which technically are
0000000000000000000000000000000000000000;;	// invalid.
0000000000000000000000000000000000000000;;	type NonFatalErrors struct {
0000000000000000000000000000000000000000;;		Errors []error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds an error to the list of errors contained by NonFatalErrors.
0000000000000000000000000000000000000000;;	func (e *NonFatalErrors) AddError(err error) {
0000000000000000000000000000000000000000;;		e.Errors = append(e.Errors, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns a string consisting of the values of Error() from all of the errors
0000000000000000000000000000000000000000;;	// contained in |e|
0000000000000000000000000000000000000000;;	func (e NonFatalErrors) Error() string {
0000000000000000000000000000000000000000;;		r := "NonFatalErrors: "
0000000000000000000000000000000000000000;;		for _, err := range e.Errors {
0000000000000000000000000000000000000000;;			r += err.Error() + "; "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if |e| contains at least one error
0000000000000000000000000000000000000000;;	func (e *NonFatalErrors) HasError() bool {
0000000000000000000000000000000000000000;;		return len(e.Errors) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// END CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseCertificate(in *certificate) (*Certificate, error) {
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		var nfe NonFatalErrors
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := new(Certificate)
0000000000000000000000000000000000000000;;		out.Raw = in.Raw
0000000000000000000000000000000000000000;;		out.RawTBSCertificate = in.TBSCertificate.Raw
0000000000000000000000000000000000000000;;		out.RawSubjectPublicKeyInfo = in.TBSCertificate.PublicKey.Raw
0000000000000000000000000000000000000000;;		out.RawSubject = in.TBSCertificate.Subject.FullBytes
0000000000000000000000000000000000000000;;		out.RawIssuer = in.TBSCertificate.Issuer.FullBytes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Signature = in.SignatureValue.RightAlign()
0000000000000000000000000000000000000000;;		out.SignatureAlgorithm =
0000000000000000000000000000000000000000;;			getSignatureAlgorithmFromOID(in.TBSCertificate.SignatureAlgorithm.Algorithm)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.PublicKeyAlgorithm =
0000000000000000000000000000000000000000;;			getPublicKeyAlgorithmFromOID(in.TBSCertificate.PublicKey.Algorithm.Algorithm)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		out.PublicKey, err = parsePublicKey(out.PublicKeyAlgorithm, &in.TBSCertificate.PublicKey)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if in.TBSCertificate.SerialNumber.Sign() < 0 {
0000000000000000000000000000000000000000;;			// START CT CHANGES
0000000000000000000000000000000000000000;;			nfe.AddError(errors.New("x509: negative serial number"))
0000000000000000000000000000000000000000;;			// END CT CHANGES
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Version = in.TBSCertificate.Version + 1
0000000000000000000000000000000000000000;;		out.SerialNumber = in.TBSCertificate.SerialNumber
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var issuer, subject pkix.RDNSequence
0000000000000000000000000000000000000000;;		if _, err := asn1.Unmarshal(in.TBSCertificate.Subject.FullBytes, &subject); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err := asn1.Unmarshal(in.TBSCertificate.Issuer.FullBytes, &issuer); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Issuer.FillFromRDNSequence(&issuer)
0000000000000000000000000000000000000000;;		out.Subject.FillFromRDNSequence(&subject)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.NotBefore = in.TBSCertificate.Validity.NotBefore
0000000000000000000000000000000000000000;;		out.NotAfter = in.TBSCertificate.Validity.NotAfter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, e := range in.TBSCertificate.Extensions {
0000000000000000000000000000000000000000;;			out.Extensions = append(out.Extensions, e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(e.Id) == 4 && e.Id[0] == 2 && e.Id[1] == 5 && e.Id[2] == 29 {
0000000000000000000000000000000000000000;;				switch e.Id[3] {
0000000000000000000000000000000000000000;;				case 15:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.3
0000000000000000000000000000000000000000;;					var usageBits asn1.BitString
0000000000000000000000000000000000000000;;					_, err := asn1.Unmarshal(e.Value, &usageBits)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						var usage int
0000000000000000000000000000000000000000;;						for i := 0; i < 9; i++ {
0000000000000000000000000000000000000000;;							if usageBits.At(i) != 0 {
0000000000000000000000000000000000000000;;								usage |= 1 << uint(i)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						out.KeyUsage = KeyUsage(usage)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case 19:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.9
0000000000000000000000000000000000000000;;					var constraints basicConstraints
0000000000000000000000000000000000000000;;					_, err := asn1.Unmarshal(e.Value, &constraints)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if err == nil {
0000000000000000000000000000000000000000;;						out.BasicConstraintsValid = true
0000000000000000000000000000000000000000;;						out.IsCA = constraints.IsCA
0000000000000000000000000000000000000000;;						out.MaxPathLen = constraints.MaxPathLen
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case 17:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.6
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// SubjectAltName ::= GeneralNames
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// GeneralName ::= CHOICE {
0000000000000000000000000000000000000000;;					//      otherName                       [0]     OtherName,
0000000000000000000000000000000000000000;;					//      rfc822Name                      [1]     IA5String,
0000000000000000000000000000000000000000;;					//      dNSName                         [2]     IA5String,
0000000000000000000000000000000000000000;;					//      x400Address                     [3]     ORAddress,
0000000000000000000000000000000000000000;;					//      directoryName                   [4]     Name,
0000000000000000000000000000000000000000;;					//      ediPartyName                    [5]     EDIPartyName,
0000000000000000000000000000000000000000;;					//      uniformResourceIdentifier       [6]     IA5String,
0000000000000000000000000000000000000000;;					//      iPAddress                       [7]     OCTET STRING,
0000000000000000000000000000000000000000;;					//      registeredID                    [8]     OBJECT IDENTIFIER }
0000000000000000000000000000000000000000;;					var seq asn1.RawValue
0000000000000000000000000000000000000000;;					_, err := asn1.Unmarshal(e.Value, &seq)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if !seq.IsCompound || seq.Tag != 16 || seq.Class != 0 {
0000000000000000000000000000000000000000;;						return nil, asn1.StructuralError{Msg: "bad SAN sequence"}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					parsedName := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					rest := seq.Bytes
0000000000000000000000000000000000000000;;					for len(rest) > 0 {
0000000000000000000000000000000000000000;;						var v asn1.RawValue
0000000000000000000000000000000000000000;;						rest, err = asn1.Unmarshal(rest, &v)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						switch v.Tag {
0000000000000000000000000000000000000000;;						case 1:
0000000000000000000000000000000000000000;;							out.EmailAddresses = append(out.EmailAddresses, string(v.Bytes))
0000000000000000000000000000000000000000;;							parsedName = true
0000000000000000000000000000000000000000;;						case 2:
0000000000000000000000000000000000000000;;							out.DNSNames = append(out.DNSNames, string(v.Bytes))
0000000000000000000000000000000000000000;;							parsedName = true
0000000000000000000000000000000000000000;;						case 7:
0000000000000000000000000000000000000000;;							switch len(v.Bytes) {
0000000000000000000000000000000000000000;;							case net.IPv4len, net.IPv6len:
0000000000000000000000000000000000000000;;								out.IPAddresses = append(out.IPAddresses, v.Bytes)
0000000000000000000000000000000000000000;;							default:
0000000000000000000000000000000000000000;;								// START CT CHANGES
0000000000000000000000000000000000000000;;								nfe.AddError(fmt.Errorf("x509: certificate contained IP address of length %d : %v", len(v.Bytes), v.Bytes))
0000000000000000000000000000000000000000;;								// END CT CHANGES
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if parsedName {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// If we didn't parse any of the names then we
0000000000000000000000000000000000000000;;					// fall through to the critical check below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case 30:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.10
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// NameConstraints ::= SEQUENCE {
0000000000000000000000000000000000000000;;					//      permittedSubtrees       [0]     GeneralSubtrees OPTIONAL,
0000000000000000000000000000000000000000;;					//      excludedSubtrees        [1]     GeneralSubtrees OPTIONAL }
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// GeneralSubtrees ::= SEQUENCE SIZE (1..MAX) OF GeneralSubtree
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// GeneralSubtree ::= SEQUENCE {
0000000000000000000000000000000000000000;;					//      base                    GeneralName,
0000000000000000000000000000000000000000;;					//      minimum         [0]     BaseDistance DEFAULT 0,
0000000000000000000000000000000000000000;;					//      maximum         [1]     BaseDistance OPTIONAL }
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// BaseDistance ::= INTEGER (0..MAX)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var constraints nameConstraints
0000000000000000000000000000000000000000;;					_, err := asn1.Unmarshal(e.Value, &constraints)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if len(constraints.Excluded) > 0 && e.Critical {
0000000000000000000000000000000000000000;;						// START CT CHANGES
0000000000000000000000000000000000000000;;						nfe.AddError(UnhandledCriticalExtension{e.Id})
0000000000000000000000000000000000000000;;						// END CT CHANGES
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, subtree := range constraints.Permitted {
0000000000000000000000000000000000000000;;						if len(subtree.Name) == 0 {
0000000000000000000000000000000000000000;;							if e.Critical {
0000000000000000000000000000000000000000;;								// START CT CHANGES
0000000000000000000000000000000000000000;;								nfe.AddError(UnhandledCriticalExtension{e.Id})
0000000000000000000000000000000000000000;;								// END CT CHANGES
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						out.PermittedDNSDomains = append(out.PermittedDNSDomains, subtree.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case 31:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.14
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// CRLDistributionPoints ::= SEQUENCE SIZE (1..MAX) OF DistributionPoint
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// DistributionPoint ::= SEQUENCE {
0000000000000000000000000000000000000000;;					//     distributionPoint       [0]     DistributionPointName OPTIONAL,
0000000000000000000000000000000000000000;;					//     reasons                 [1]     ReasonFlags OPTIONAL,
0000000000000000000000000000000000000000;;					//     cRLIssuer               [2]     GeneralNames OPTIONAL }
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// DistributionPointName ::= CHOICE {
0000000000000000000000000000000000000000;;					//     fullName                [0]     GeneralNames,
0000000000000000000000000000000000000000;;					//     nameRelativeToCRLIssuer [1]     RelativeDistinguishedName }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var cdp []distributionPoint
0000000000000000000000000000000000000000;;					_, err := asn1.Unmarshal(e.Value, &cdp)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, dp := range cdp {
0000000000000000000000000000000000000000;;						var n asn1.RawValue
0000000000000000000000000000000000000000;;						_, err = asn1.Unmarshal(dp.DistributionPoint.FullName.Bytes, &n)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return nil, err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						if n.Tag == 6 {
0000000000000000000000000000000000000000;;							out.CRLDistributionPoints = append(out.CRLDistributionPoints, string(n.Bytes))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case 35:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.1
0000000000000000000000000000000000000000;;					var a authKeyId
0000000000000000000000000000000000000000;;					_, err = asn1.Unmarshal(e.Value, &a)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					out.AuthorityKeyId = a.Id
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case 37:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.12.  Extended Key Usage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// id-ce-extKeyUsage OBJECT IDENTIFIER ::= { id-ce 37 }
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
0000000000000000000000000000000000000000;;					//
0000000000000000000000000000000000000000;;					// KeyPurposeId ::= OBJECT IDENTIFIER
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var keyUsage []asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;					_, err = asn1.Unmarshal(e.Value, &keyUsage)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for _, u := range keyUsage {
0000000000000000000000000000000000000000;;						if extKeyUsage, ok := extKeyUsageFromOID(u); ok {
0000000000000000000000000000000000000000;;							out.ExtKeyUsage = append(out.ExtKeyUsage, extKeyUsage)
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							out.UnknownExtKeyUsage = append(out.UnknownExtKeyUsage, u)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case 14:
0000000000000000000000000000000000000000;;					// RFC 5280, 4.2.1.2
0000000000000000000000000000000000000000;;					var keyid []byte
0000000000000000000000000000000000000000;;					_, err = asn1.Unmarshal(e.Value, &keyid)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					out.SubjectKeyId = keyid
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case 32:
0000000000000000000000000000000000000000;;					// RFC 5280 4.2.1.4: Certificate Policies
0000000000000000000000000000000000000000;;					var policies []policyInformation
0000000000000000000000000000000000000000;;					if _, err = asn1.Unmarshal(e.Value, &policies); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					out.PolicyIdentifiers = make([]asn1.ObjectIdentifier, len(policies))
0000000000000000000000000000000000000000;;					for i, policy := range policies {
0000000000000000000000000000000000000000;;						out.PolicyIdentifiers[i] = policy.Policy
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if e.Id.Equal(oidExtensionAuthorityInfoAccess) {
0000000000000000000000000000000000000000;;				// RFC 5280 4.2.2.1: Authority Information Access
0000000000000000000000000000000000000000;;				var aia []authorityInfoAccess
0000000000000000000000000000000000000000;;				if _, err = asn1.Unmarshal(e.Value, &aia); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, v := range aia {
0000000000000000000000000000000000000000;;					// GeneralName: uniformResourceIdentifier [6] IA5String
0000000000000000000000000000000000000000;;					if v.Location.Tag != 6 {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if v.Method.Equal(oidAuthorityInfoAccessOcsp) {
0000000000000000000000000000000000000000;;						out.OCSPServer = append(out.OCSPServer, string(v.Location.Bytes))
0000000000000000000000000000000000000000;;					} else if v.Method.Equal(oidAuthorityInfoAccessIssuers) {
0000000000000000000000000000000000000000;;						out.IssuingCertificateURL = append(out.IssuingCertificateURL, string(v.Location.Bytes))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if e.Critical {
0000000000000000000000000000000000000000;;				// START CT CHANGES
0000000000000000000000000000000000000000;;				nfe.AddError(UnhandledCriticalExtension{e.Id})
0000000000000000000000000000000000000000;;				// END CT CHANGES
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		if nfe.HasError() {
0000000000000000000000000000000000000000;;			return out, nfe
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;		return out, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// START CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseTBSCertificate parses a single TBSCertificate from the given ASN.1 DER data.
0000000000000000000000000000000000000000;;	// The parsed data is returned in a Certificate struct for ease of access.
0000000000000000000000000000000000000000;;	func ParseTBSCertificate(asn1Data []byte) (*Certificate, error) {
0000000000000000000000000000000000000000;;		var tbsCert tbsCertificate
0000000000000000000000000000000000000000;;		rest, err := asn1.Unmarshal(asn1Data, &tbsCert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rest) > 0 {
0000000000000000000000000000000000000000;;			return nil, asn1.SyntaxError{Msg: "trailing data"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return parseCertificate(&certificate{
0000000000000000000000000000000000000000;;			Raw:            tbsCert.Raw,
0000000000000000000000000000000000000000;;			TBSCertificate: tbsCert})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// END CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCertificate parses a single certificate from the given ASN.1 DER data.
0000000000000000000000000000000000000000;;	func ParseCertificate(asn1Data []byte) (*Certificate, error) {
0000000000000000000000000000000000000000;;		var cert certificate
0000000000000000000000000000000000000000;;		rest, err := asn1.Unmarshal(asn1Data, &cert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rest) > 0 {
0000000000000000000000000000000000000000;;			return nil, asn1.SyntaxError{Msg: "trailing data"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return parseCertificate(&cert)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCertificates parses one or more certificates from the given ASN.1 DER
0000000000000000000000000000000000000000;;	// data. The certificates must be concatenated with no intermediate padding.
0000000000000000000000000000000000000000;;	func ParseCertificates(asn1Data []byte) ([]*Certificate, error) {
0000000000000000000000000000000000000000;;		var v []*certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for len(asn1Data) > 0 {
0000000000000000000000000000000000000000;;			cert := new(certificate)
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			asn1Data, err = asn1.Unmarshal(asn1Data, cert)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v = append(v, cert)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := make([]*Certificate, len(v))
0000000000000000000000000000000000000000;;		for i, ci := range v {
0000000000000000000000000000000000000000;;			cert, err := parseCertificate(ci)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret[i] = cert
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func reverseBitsInAByte(in byte) byte {
0000000000000000000000000000000000000000;;		b1 := in>>4 | in<<4
0000000000000000000000000000000000000000;;		b2 := b1>>2&0x33 | b1<<2&0xcc
0000000000000000000000000000000000000000;;		b3 := b2>>1&0x55 | b2<<1&0xaa
0000000000000000000000000000000000000000;;		return b3
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidExtensionSubjectKeyId          = []int{2, 5, 29, 14}
0000000000000000000000000000000000000000;;		oidExtensionKeyUsage              = []int{2, 5, 29, 15}
0000000000000000000000000000000000000000;;		oidExtensionExtendedKeyUsage      = []int{2, 5, 29, 37}
0000000000000000000000000000000000000000;;		oidExtensionAuthorityKeyId        = []int{2, 5, 29, 35}
0000000000000000000000000000000000000000;;		oidExtensionBasicConstraints      = []int{2, 5, 29, 19}
0000000000000000000000000000000000000000;;		oidExtensionSubjectAltName        = []int{2, 5, 29, 17}
0000000000000000000000000000000000000000;;		oidExtensionCertificatePolicies   = []int{2, 5, 29, 32}
0000000000000000000000000000000000000000;;		oidExtensionNameConstraints       = []int{2, 5, 29, 30}
0000000000000000000000000000000000000000;;		oidExtensionCRLDistributionPoints = []int{2, 5, 29, 31}
0000000000000000000000000000000000000000;;		oidExtensionAuthorityInfoAccess   = []int{1, 3, 6, 1, 5, 5, 7, 1, 1}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidAuthorityInfoAccessOcsp    = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 48, 1}
0000000000000000000000000000000000000000;;		oidAuthorityInfoAccessIssuers = asn1.ObjectIdentifier{1, 3, 6, 1, 5, 5, 7, 48, 2}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// oidNotInExtensions returns whether an extension with the given oid exists in
0000000000000000000000000000000000000000;;	// extensions.
0000000000000000000000000000000000000000;;	func oidInExtensions(oid asn1.ObjectIdentifier, extensions []pkix.Extension) bool {
0000000000000000000000000000000000000000;;		for _, e := range extensions {
0000000000000000000000000000000000000000;;			if e.Id.Equal(oid) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildExtensions(template *Certificate) (ret []pkix.Extension, err error) {
0000000000000000000000000000000000000000;;		ret = make([]pkix.Extension, 10 /* maximum number of elements. */)
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if template.KeyUsage != 0 &&
0000000000000000000000000000000000000000;;			!oidInExtensions(oidExtensionKeyUsage, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionKeyUsage
0000000000000000000000000000000000000000;;			ret[n].Critical = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var a [2]byte
0000000000000000000000000000000000000000;;			a[0] = reverseBitsInAByte(byte(template.KeyUsage))
0000000000000000000000000000000000000000;;			a[1] = reverseBitsInAByte(byte(template.KeyUsage >> 8))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			l := 1
0000000000000000000000000000000000000000;;			if a[1] != 0 {
0000000000000000000000000000000000000000;;				l = 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(asn1.BitString{Bytes: a[0:l], BitLength: l * 8})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (len(template.ExtKeyUsage) > 0 || len(template.UnknownExtKeyUsage) > 0) &&
0000000000000000000000000000000000000000;;			!oidInExtensions(oidExtensionExtendedKeyUsage, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionExtendedKeyUsage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var oids []asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;			for _, u := range template.ExtKeyUsage {
0000000000000000000000000000000000000000;;				if oid, ok := oidFromExtKeyUsage(u); ok {
0000000000000000000000000000000000000000;;					oids = append(oids, oid)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					panic("internal error")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			oids = append(oids, template.UnknownExtKeyUsage...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(oids)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if template.BasicConstraintsValid && !oidInExtensions(oidExtensionBasicConstraints, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionBasicConstraints
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(basicConstraints{template.IsCA, template.MaxPathLen})
0000000000000000000000000000000000000000;;			ret[n].Critical = true
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(template.SubjectKeyId) > 0 && !oidInExtensions(oidExtensionSubjectKeyId, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionSubjectKeyId
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(template.SubjectKeyId)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(template.AuthorityKeyId) > 0 && !oidInExtensions(oidExtensionAuthorityKeyId, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionAuthorityKeyId
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(authKeyId{template.AuthorityKeyId})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (len(template.OCSPServer) > 0 || len(template.IssuingCertificateURL) > 0) &&
0000000000000000000000000000000000000000;;			!oidInExtensions(oidExtensionAuthorityInfoAccess, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionAuthorityInfoAccess
0000000000000000000000000000000000000000;;			var aiaValues []authorityInfoAccess
0000000000000000000000000000000000000000;;			for _, name := range template.OCSPServer {
0000000000000000000000000000000000000000;;				aiaValues = append(aiaValues, authorityInfoAccess{
0000000000000000000000000000000000000000;;					Method:   oidAuthorityInfoAccessOcsp,
0000000000000000000000000000000000000000;;					Location: asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, name := range template.IssuingCertificateURL {
0000000000000000000000000000000000000000;;				aiaValues = append(aiaValues, authorityInfoAccess{
0000000000000000000000000000000000000000;;					Method:   oidAuthorityInfoAccessIssuers,
0000000000000000000000000000000000000000;;					Location: asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)},
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(aiaValues)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (len(template.DNSNames) > 0 || len(template.EmailAddresses) > 0 || len(template.IPAddresses) > 0) &&
0000000000000000000000000000000000000000;;			!oidInExtensions(oidExtensionSubjectAltName, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionSubjectAltName
0000000000000000000000000000000000000000;;			var rawValues []asn1.RawValue
0000000000000000000000000000000000000000;;			for _, name := range template.DNSNames {
0000000000000000000000000000000000000000;;				rawValues = append(rawValues, asn1.RawValue{Tag: 2, Class: 2, Bytes: []byte(name)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, email := range template.EmailAddresses {
0000000000000000000000000000000000000000;;				rawValues = append(rawValues, asn1.RawValue{Tag: 1, Class: 2, Bytes: []byte(email)})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, rawIP := range template.IPAddresses {
0000000000000000000000000000000000000000;;				// If possible, we always want to encode IPv4 addresses in 4 bytes.
0000000000000000000000000000000000000000;;				ip := rawIP.To4()
0000000000000000000000000000000000000000;;				if ip == nil {
0000000000000000000000000000000000000000;;					ip = rawIP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rawValues = append(rawValues, asn1.RawValue{Tag: 7, Class: 2, Bytes: ip})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(rawValues)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(template.PolicyIdentifiers) > 0 &&
0000000000000000000000000000000000000000;;			!oidInExtensions(oidExtensionCertificatePolicies, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionCertificatePolicies
0000000000000000000000000000000000000000;;			policies := make([]policyInformation, len(template.PolicyIdentifiers))
0000000000000000000000000000000000000000;;			for i, policy := range template.PolicyIdentifiers {
0000000000000000000000000000000000000000;;				policies[i].Policy = policy
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(policies)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(template.PermittedDNSDomains) > 0 &&
0000000000000000000000000000000000000000;;			!oidInExtensions(oidExtensionNameConstraints, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionNameConstraints
0000000000000000000000000000000000000000;;			ret[n].Critical = template.PermittedDNSDomainsCritical
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var out nameConstraints
0000000000000000000000000000000000000000;;			out.Permitted = make([]generalSubtree, len(template.PermittedDNSDomains))
0000000000000000000000000000000000000000;;			for i, permitted := range template.PermittedDNSDomains {
0000000000000000000000000000000000000000;;				out.Permitted[i] = generalSubtree{Name: permitted}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(out)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(template.CRLDistributionPoints) > 0 &&
0000000000000000000000000000000000000000;;			!oidInExtensions(oidExtensionCRLDistributionPoints, template.ExtraExtensions) {
0000000000000000000000000000000000000000;;			ret[n].Id = oidExtensionCRLDistributionPoints
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var crlDp []distributionPoint
0000000000000000000000000000000000000000;;			for _, name := range template.CRLDistributionPoints {
0000000000000000000000000000000000000000;;				rawFullName, _ := asn1.Marshal(asn1.RawValue{Tag: 6, Class: 2, Bytes: []byte(name)})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dp := distributionPoint{
0000000000000000000000000000000000000000;;					DistributionPoint: distributionPointName{
0000000000000000000000000000000000000000;;						FullName: asn1.RawValue{Tag: 0, Class: 2, Bytes: rawFullName},
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				crlDp = append(crlDp, dp)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ret[n].Value, err = asn1.Marshal(crlDp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Adding another extension here? Remember to update the maximum number
0000000000000000000000000000000000000000;;		// of elements in the make() at the top of the function.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return append(ret[:n], template.ExtraExtensions...), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func subjectBytes(cert *Certificate) ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(cert.RawSubject) > 0 {
0000000000000000000000000000000000000000;;			return cert.RawSubject, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return asn1.Marshal(cert.Subject.ToRDNSequence())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateCertificate creates a new certificate based on a template. The
0000000000000000000000000000000000000000;;	// following members of template are used: SerialNumber, Subject, NotBefore,
0000000000000000000000000000000000000000;;	// NotAfter, KeyUsage, ExtKeyUsage, UnknownExtKeyUsage, BasicConstraintsValid,
0000000000000000000000000000000000000000;;	// IsCA, MaxPathLen, SubjectKeyId, DNSNames, PermittedDNSDomainsCritical,
0000000000000000000000000000000000000000;;	// PermittedDNSDomains.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The certificate is signed by parent. If parent is equal to template then the
0000000000000000000000000000000000000000;;	// certificate is self-signed. The parameter pub is the public key of the
0000000000000000000000000000000000000000;;	// signee and priv is the private key of the signer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned slice is the certificate in DER encoding.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The only supported key types are RSA and ECDSA (*rsa.PublicKey or
0000000000000000000000000000000000000000;;	// *ecdsa.PublicKey for pub, *rsa.PrivateKey or *ecdsa.PublicKey for priv).
0000000000000000000000000000000000000000;;	func CreateCertificate(rand io.Reader, template, parent *Certificate, pub interface{}, priv interface{}) (cert []byte, err error) {
0000000000000000000000000000000000000000;;		var publicKeyBytes []byte
0000000000000000000000000000000000000000;;		var publicKeyAlgorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if publicKeyBytes, publicKeyAlgorithm, err = marshalPublicKey(pub); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var signatureAlgorithm pkix.AlgorithmIdentifier
0000000000000000000000000000000000000000;;		var hashFunc crypto.Hash
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch priv := priv.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			signatureAlgorithm.Algorithm = oidSignatureSHA1WithRSA
0000000000000000000000000000000000000000;;			hashFunc = crypto.SHA1
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			switch priv.Curve {
0000000000000000000000000000000000000000;;			case elliptic.P224(), elliptic.P256():
0000000000000000000000000000000000000000;;				hashFunc = crypto.SHA256
0000000000000000000000000000000000000000;;				signatureAlgorithm.Algorithm = oidSignatureECDSAWithSHA256
0000000000000000000000000000000000000000;;			case elliptic.P384():
0000000000000000000000000000000000000000;;				hashFunc = crypto.SHA384
0000000000000000000000000000000000000000;;				signatureAlgorithm.Algorithm = oidSignatureECDSAWithSHA384
0000000000000000000000000000000000000000;;			case elliptic.P521():
0000000000000000000000000000000000000000;;				hashFunc = crypto.SHA512
0000000000000000000000000000000000000000;;				signatureAlgorithm.Algorithm = oidSignatureECDSAWithSHA512
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, errors.New("x509: unknown elliptic curve")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: only RSA and ECDSA private keys supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(parent.SubjectKeyId) > 0 {
0000000000000000000000000000000000000000;;			template.AuthorityKeyId = parent.SubjectKeyId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extensions, err := buildExtensions(template)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asn1Issuer, err := subjectBytes(parent)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		asn1Subject, err := subjectBytes(template)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		encodedPublicKey := asn1.BitString{BitLength: len(publicKeyBytes) * 8, Bytes: publicKeyBytes}
0000000000000000000000000000000000000000;;		c := tbsCertificate{
0000000000000000000000000000000000000000;;			Version:            2,
0000000000000000000000000000000000000000;;			SerialNumber:       template.SerialNumber,
0000000000000000000000000000000000000000;;			SignatureAlgorithm: signatureAlgorithm,
0000000000000000000000000000000000000000;;			Issuer:             asn1.RawValue{FullBytes: asn1Issuer},
0000000000000000000000000000000000000000;;			Validity:           validity{template.NotBefore.UTC(), template.NotAfter.UTC()},
0000000000000000000000000000000000000000;;			Subject:            asn1.RawValue{FullBytes: asn1Subject},
0000000000000000000000000000000000000000;;			PublicKey:          publicKeyInfo{nil, publicKeyAlgorithm, encodedPublicKey},
0000000000000000000000000000000000000000;;			Extensions:         extensions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tbsCertContents, err := asn1.Marshal(c)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.Raw = tbsCertContents
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := hashFunc.New()
0000000000000000000000000000000000000000;;		h.Write(tbsCertContents)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var signature []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch priv := priv.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			signature, err = rsa.SignPKCS1v15(rand, priv, hashFunc, digest)
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			var r, s *big.Int
0000000000000000000000000000000000000000;;			if r, s, err = ecdsa.Sign(rand, priv, digest); err == nil {
0000000000000000000000000000000000000000;;				signature, err = asn1.Marshal(ecdsaSignature{r, s})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic("internal error")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cert, err = asn1.Marshal(certificate{
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;			c,
0000000000000000000000000000000000000000;;			signatureAlgorithm,
0000000000000000000000000000000000000000;;			asn1.BitString{Bytes: signature, BitLength: len(signature) * 8},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pemCRLPrefix is the magic string that indicates that we have a PEM encoded
0000000000000000000000000000000000000000;;	// CRL.
0000000000000000000000000000000000000000;;	var pemCRLPrefix = []byte("-----BEGIN X509 CRL")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pemType is the type of a PEM encoded CRL.
0000000000000000000000000000000000000000;;	var pemType = "X509 CRL"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseCRL parses a CRL from the given bytes. It's often the case that PEM
0000000000000000000000000000000000000000;;	// encoded CRLs will appear where they should be DER encoded, so this function
0000000000000000000000000000000000000000;;	// will transparently handle PEM encoding as long as there isn't any leading
0000000000000000000000000000000000000000;;	// garbage.
0000000000000000000000000000000000000000;;	func ParseCRL(crlBytes []byte) (certList *pkix.CertificateList, err error) {
0000000000000000000000000000000000000000;;		if bytes.HasPrefix(crlBytes, pemCRLPrefix) {
0000000000000000000000000000000000000000;;			block, _ := pem.Decode(crlBytes)
0000000000000000000000000000000000000000;;			if block != nil && block.Type == pemType {
0000000000000000000000000000000000000000;;				crlBytes = block.Bytes
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ParseDERCRL(crlBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDERCRL parses a DER encoded CRL from the given bytes.
0000000000000000000000000000000000000000;;	func ParseDERCRL(derBytes []byte) (certList *pkix.CertificateList, err error) {
0000000000000000000000000000000000000000;;		certList = new(pkix.CertificateList)
0000000000000000000000000000000000000000;;		_, err = asn1.Unmarshal(derBytes, certList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			certList = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateCRL returns a DER encoded CRL, signed by this Certificate, that
0000000000000000000000000000000000000000;;	// contains the given list of revoked certificates.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The only supported key type is RSA (*rsa.PrivateKey for priv).
0000000000000000000000000000000000000000;;	func (c *Certificate) CreateCRL(rand io.Reader, priv interface{}, revokedCerts []pkix.RevokedCertificate, now, expiry time.Time) (crlBytes []byte, err error) {
0000000000000000000000000000000000000000;;		rsaPriv, ok := priv.(*rsa.PrivateKey)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: non-RSA private keys not supported")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tbsCertList := pkix.TBSCertificateList{
0000000000000000000000000000000000000000;;			Version: 2,
0000000000000000000000000000000000000000;;			Signature: pkix.AlgorithmIdentifier{
0000000000000000000000000000000000000000;;				Algorithm: oidSignatureSHA1WithRSA,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Issuer:              c.Subject.ToRDNSequence(),
0000000000000000000000000000000000000000;;			ThisUpdate:          now.UTC(),
0000000000000000000000000000000000000000;;			NextUpdate:          expiry.UTC(),
0000000000000000000000000000000000000000;;			RevokedCertificates: revokedCerts,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tbsCertListContents, err := asn1.Marshal(tbsCertList)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := sha1.New()
0000000000000000000000000000000000000000;;		h.Write(tbsCertListContents)
0000000000000000000000000000000000000000;;		digest := h.Sum(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signature, err := rsa.SignPKCS1v15(rand, rsaPriv, crypto.SHA1, digest)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return asn1.Marshal(pkix.CertificateList{
0000000000000000000000000000000000000000;;			TBSCertList: tbsCertList,
0000000000000000000000000000000000000000;;			SignatureAlgorithm: pkix.AlgorithmIdentifier{
0000000000000000000000000000000000000000;;				Algorithm: oidSignatureSHA1WithRSA,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			SignatureValue: asn1.BitString{Bytes: signature, BitLength: len(signature) * 8},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
