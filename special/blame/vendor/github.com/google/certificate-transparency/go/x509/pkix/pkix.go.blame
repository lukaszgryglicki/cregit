0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	// Package pkix contains shared, low level structures used for ASN.1 parsing
0000000000000000000000000000000000000000;;	// and serialization of X.509 certificates, CRL and OCSP.
0000000000000000000000000000000000000000;;	package pkix
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go/asn1"
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AlgorithmIdentifier represents the ASN.1 structure of the same name. See RFC
0000000000000000000000000000000000000000;;	// 5280, section 4.1.1.2.
0000000000000000000000000000000000000000;;	type AlgorithmIdentifier struct {
0000000000000000000000000000000000000000;;		Algorithm  asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Parameters asn1.RawValue `asn1:"optional"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RDNSequence []RelativeDistinguishedNameSET
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RelativeDistinguishedNameSET []AttributeTypeAndValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AttributeTypeAndValue mirrors the ASN.1 structure of the same name in
0000000000000000000000000000000000000000;;	// http://tools.ietf.org/html/rfc5280#section-4.1.2.4
0000000000000000000000000000000000000000;;	type AttributeTypeAndValue struct {
0000000000000000000000000000000000000000;;		Type  asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Value interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extension represents the ASN.1 structure of the same name. See RFC
0000000000000000000000000000000000000000;;	// 5280, section 4.2.
0000000000000000000000000000000000000000;;	type Extension struct {
0000000000000000000000000000000000000000;;		Id       asn1.ObjectIdentifier
0000000000000000000000000000000000000000;;		Critical bool `asn1:"optional"`
0000000000000000000000000000000000000000;;		Value    []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name represents an X.509 distinguished name. This only includes the common
0000000000000000000000000000000000000000;;	// elements of a DN.  Additional elements in the name are ignored.
0000000000000000000000000000000000000000;;	type Name struct {
0000000000000000000000000000000000000000;;		Country, Organization, OrganizationalUnit []string
0000000000000000000000000000000000000000;;		Locality, Province                        []string
0000000000000000000000000000000000000000;;		StreetAddress, PostalCode                 []string
0000000000000000000000000000000000000000;;		SerialNumber, CommonName                  string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Names []AttributeTypeAndValue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *Name) FillFromRDNSequence(rdns *RDNSequence) {
0000000000000000000000000000000000000000;;		for _, rdn := range *rdns {
0000000000000000000000000000000000000000;;			if len(rdn) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			atv := rdn[0]
0000000000000000000000000000000000000000;;			n.Names = append(n.Names, atv)
0000000000000000000000000000000000000000;;			value, ok := atv.Value.(string)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			t := atv.Type
0000000000000000000000000000000000000000;;			if len(t) == 4 && t[0] == 2 && t[1] == 5 && t[2] == 4 {
0000000000000000000000000000000000000000;;				switch t[3] {
0000000000000000000000000000000000000000;;				case 3:
0000000000000000000000000000000000000000;;					n.CommonName = value
0000000000000000000000000000000000000000;;				case 5:
0000000000000000000000000000000000000000;;					n.SerialNumber = value
0000000000000000000000000000000000000000;;				case 6:
0000000000000000000000000000000000000000;;					n.Country = append(n.Country, value)
0000000000000000000000000000000000000000;;				case 7:
0000000000000000000000000000000000000000;;					n.Locality = append(n.Locality, value)
0000000000000000000000000000000000000000;;				case 8:
0000000000000000000000000000000000000000;;					n.Province = append(n.Province, value)
0000000000000000000000000000000000000000;;				case 9:
0000000000000000000000000000000000000000;;					n.StreetAddress = append(n.StreetAddress, value)
0000000000000000000000000000000000000000;;				case 10:
0000000000000000000000000000000000000000;;					n.Organization = append(n.Organization, value)
0000000000000000000000000000000000000000;;				case 11:
0000000000000000000000000000000000000000;;					n.OrganizationalUnit = append(n.OrganizationalUnit, value)
0000000000000000000000000000000000000000;;				case 17:
0000000000000000000000000000000000000000;;					n.PostalCode = append(n.PostalCode, value)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		oidCountry            = []int{2, 5, 4, 6}
0000000000000000000000000000000000000000;;		oidOrganization       = []int{2, 5, 4, 10}
0000000000000000000000000000000000000000;;		oidOrganizationalUnit = []int{2, 5, 4, 11}
0000000000000000000000000000000000000000;;		oidCommonName         = []int{2, 5, 4, 3}
0000000000000000000000000000000000000000;;		oidSerialNumber       = []int{2, 5, 4, 5}
0000000000000000000000000000000000000000;;		oidLocality           = []int{2, 5, 4, 7}
0000000000000000000000000000000000000000;;		oidProvince           = []int{2, 5, 4, 8}
0000000000000000000000000000000000000000;;		oidStreetAddress      = []int{2, 5, 4, 9}
0000000000000000000000000000000000000000;;		oidPostalCode         = []int{2, 5, 4, 17}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appendRDNs appends a relativeDistinguishedNameSET to the given RDNSequence
0000000000000000000000000000000000000000;;	// and returns the new value. The relativeDistinguishedNameSET contains an
0000000000000000000000000000000000000000;;	// attributeTypeAndValue for each of the given values. See RFC 5280, A.1, and
0000000000000000000000000000000000000000;;	// search for AttributeTypeAndValue.
0000000000000000000000000000000000000000;;	func appendRDNs(in RDNSequence, values []string, oid asn1.ObjectIdentifier) RDNSequence {
0000000000000000000000000000000000000000;;		if len(values) == 0 {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := make([]AttributeTypeAndValue, len(values))
0000000000000000000000000000000000000000;;		for i, value := range values {
0000000000000000000000000000000000000000;;			s[i].Type = oid
0000000000000000000000000000000000000000;;			s[i].Value = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return append(in, s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n Name) ToRDNSequence() (ret RDNSequence) {
0000000000000000000000000000000000000000;;		ret = appendRDNs(ret, n.Country, oidCountry)
0000000000000000000000000000000000000000;;		ret = appendRDNs(ret, n.Organization, oidOrganization)
0000000000000000000000000000000000000000;;		ret = appendRDNs(ret, n.OrganizationalUnit, oidOrganizationalUnit)
0000000000000000000000000000000000000000;;		ret = appendRDNs(ret, n.Locality, oidLocality)
0000000000000000000000000000000000000000;;		ret = appendRDNs(ret, n.Province, oidProvince)
0000000000000000000000000000000000000000;;		ret = appendRDNs(ret, n.StreetAddress, oidStreetAddress)
0000000000000000000000000000000000000000;;		ret = appendRDNs(ret, n.PostalCode, oidPostalCode)
0000000000000000000000000000000000000000;;		if len(n.CommonName) > 0 {
0000000000000000000000000000000000000000;;			ret = appendRDNs(ret, []string{n.CommonName}, oidCommonName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(n.SerialNumber) > 0 {
0000000000000000000000000000000000000000;;			ret = appendRDNs(ret, []string{n.SerialNumber}, oidSerialNumber)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertificateList represents the ASN.1 structure of the same name. See RFC
0000000000000000000000000000000000000000;;	// 5280, section 5.1. Use Certificate.CheckCRLSignature to verify the
0000000000000000000000000000000000000000;;	// signature.
0000000000000000000000000000000000000000;;	type CertificateList struct {
0000000000000000000000000000000000000000;;		TBSCertList        TBSCertificateList
0000000000000000000000000000000000000000;;		SignatureAlgorithm AlgorithmIdentifier
0000000000000000000000000000000000000000;;		SignatureValue     asn1.BitString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasExpired reports whether now is past the expiry time of certList.
0000000000000000000000000000000000000000;;	func (certList *CertificateList) HasExpired(now time.Time) bool {
0000000000000000000000000000000000000000;;		return now.After(certList.TBSCertList.NextUpdate)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TBSCertificateList represents the ASN.1 structure of the same name. See RFC
0000000000000000000000000000000000000000;;	// 5280, section 5.1.
0000000000000000000000000000000000000000;;	type TBSCertificateList struct {
0000000000000000000000000000000000000000;;		Raw                 asn1.RawContent
0000000000000000000000000000000000000000;;		Version             int `asn1:"optional,default:2"`
0000000000000000000000000000000000000000;;		Signature           AlgorithmIdentifier
0000000000000000000000000000000000000000;;		Issuer              RDNSequence
0000000000000000000000000000000000000000;;		ThisUpdate          time.Time
0000000000000000000000000000000000000000;;		NextUpdate          time.Time
0000000000000000000000000000000000000000;;		RevokedCertificates []RevokedCertificate `asn1:"optional"`
0000000000000000000000000000000000000000;;		Extensions          []Extension          `asn1:"tag:0,optional,explicit"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RevokedCertificate represents the ASN.1 structure of the same name. See RFC
0000000000000000000000000000000000000000;;	// 5280, section 5.1.
0000000000000000000000000000000000000000;;	type RevokedCertificate struct {
0000000000000000000000000000000000000000;;		SerialNumber   *big.Int
0000000000000000000000000000000000000000;;		RevocationTime time.Time
0000000000000000000000000000000000000000;;		Extensions     []Extension `asn1:"optional"`
0000000000000000000000000000000000000000;;	}
