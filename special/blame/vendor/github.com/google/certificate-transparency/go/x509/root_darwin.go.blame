0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	// +build darwin,cgo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	#cgo CFLAGS: -mmacosx-version-min=10.6 -D__MAC_OS_X_VERSION_MAX_ALLOWED=1060
0000000000000000000000000000000000000000;;	#cgo LDFLAGS: -framework CoreFoundation -framework Security
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	#include <CoreFoundation/CoreFoundation.h>
0000000000000000000000000000000000000000;;	#include <Security/Security.h>
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FetchPEMRootsCTX509 fetches the system's list of trusted X.509 root certificates.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// On success it returns 0 and fills pemRoots with a CFDataRef that contains the extracted root
0000000000000000000000000000000000000000;;	// certificates of the system. On failure, the function returns -1.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: The CFDataRef returned in pemRoots must be released (using CFRelease) after
0000000000000000000000000000000000000000;;	// we've consumed its content.
0000000000000000000000000000000000000000;;	int FetchPEMRootsCTX509(CFDataRef *pemRoots) {
0000000000000000000000000000000000000000;;		if (pemRoots == NULL) {
0000000000000000000000000000000000000000;;			return -1;
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CFArrayRef certs = NULL;
0000000000000000000000000000000000000000;;		OSStatus err = SecTrustCopyAnchorCertificates(&certs);
0000000000000000000000000000000000000000;;		if (err != noErr) {
0000000000000000000000000000000000000000;;			return -1;
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CFMutableDataRef combinedData = CFDataCreateMutable(kCFAllocatorDefault, 0);
0000000000000000000000000000000000000000;;		int i, ncerts = CFArrayGetCount(certs);
0000000000000000000000000000000000000000;;		for (i = 0; i < ncerts; i++) {
0000000000000000000000000000000000000000;;			CFDataRef data = NULL;
0000000000000000000000000000000000000000;;			SecCertificateRef cert = (SecCertificateRef)CFArrayGetValueAtIndex(certs, i);
0000000000000000000000000000000000000000;;			if (cert == NULL) {
0000000000000000000000000000000000000000;;				continue;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Note: SecKeychainItemExport is deprecated as of 10.7 in favor of SecItemExport.
0000000000000000000000000000000000000000;;			// Once we support weak imports via cgo we should prefer that, and fall back to this
0000000000000000000000000000000000000000;;			// for older systems.
0000000000000000000000000000000000000000;;			err = SecKeychainItemExport(cert, kSecFormatX509Cert, kSecItemPemArmour, NULL, &data);
0000000000000000000000000000000000000000;;			if (err != noErr) {
0000000000000000000000000000000000000000;;				continue;
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if (data != NULL) {
0000000000000000000000000000000000000000;;				CFDataAppendBytes(combinedData, CFDataGetBytePtr(data), CFDataGetLength(data));
0000000000000000000000000000000000000000;;				CFRelease(data);
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		CFRelease(certs);
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*pemRoots = combinedData;
0000000000000000000000000000000000000000;;		return 0;
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	import "C"
0000000000000000000000000000000000000000;;	import "unsafe"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initSystemRoots() {
0000000000000000000000000000000000000000;;		roots := NewCertPool()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var data C.CFDataRef = nil
0000000000000000000000000000000000000000;;		err := C.FetchPEMRootsCTX509(&data)
0000000000000000000000000000000000000000;;		if err == -1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer C.CFRelease(C.CFTypeRef(data))
0000000000000000000000000000000000000000;;		buf := C.GoBytes(unsafe.Pointer(C.CFDataGetBytePtr(data)), C.int(C.CFDataGetLength(data)))
0000000000000000000000000000000000000000;;		roots.AppendCertsFromPEM(buf)
0000000000000000000000000000000000000000;;		systemRoots = roots
0000000000000000000000000000000000000000;;	}
