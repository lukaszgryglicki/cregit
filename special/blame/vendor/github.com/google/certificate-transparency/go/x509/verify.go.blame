0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type InvalidReason int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// NotAuthorizedToSign results when a certificate is signed by another
0000000000000000000000000000000000000000;;		// which isn't marked as a CA certificate.
0000000000000000000000000000000000000000;;		NotAuthorizedToSign InvalidReason = iota
0000000000000000000000000000000000000000;;		// Expired results when a certificate has expired, based on the time
0000000000000000000000000000000000000000;;		// given in the VerifyOptions.
0000000000000000000000000000000000000000;;		Expired
0000000000000000000000000000000000000000;;		// CANotAuthorizedForThisName results when an intermediate or root
0000000000000000000000000000000000000000;;		// certificate has a name constraint which doesn't include the name
0000000000000000000000000000000000000000;;		// being checked.
0000000000000000000000000000000000000000;;		CANotAuthorizedForThisName
0000000000000000000000000000000000000000;;		// TooManyIntermediates results when a path length constraint is
0000000000000000000000000000000000000000;;		// violated.
0000000000000000000000000000000000000000;;		TooManyIntermediates
0000000000000000000000000000000000000000;;		// IncompatibleUsage results when the certificate's key usage indicates
0000000000000000000000000000000000000000;;		// that it may only be used for a different purpose.
0000000000000000000000000000000000000000;;		IncompatibleUsage
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertificateInvalidError results when an odd error occurs. Users of this
0000000000000000000000000000000000000000;;	// library probably want to handle all these errors uniformly.
0000000000000000000000000000000000000000;;	type CertificateInvalidError struct {
0000000000000000000000000000000000000000;;		Cert   *Certificate
0000000000000000000000000000000000000000;;		Reason InvalidReason
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e CertificateInvalidError) Error() string {
0000000000000000000000000000000000000000;;		switch e.Reason {
0000000000000000000000000000000000000000;;		case NotAuthorizedToSign:
0000000000000000000000000000000000000000;;			return "x509: certificate is not authorized to sign other certificates"
0000000000000000000000000000000000000000;;		case Expired:
0000000000000000000000000000000000000000;;			return "x509: certificate has expired or is not yet valid"
0000000000000000000000000000000000000000;;		case CANotAuthorizedForThisName:
0000000000000000000000000000000000000000;;			return "x509: a root or intermediate certificate is not authorized to sign in this domain"
0000000000000000000000000000000000000000;;		case TooManyIntermediates:
0000000000000000000000000000000000000000;;			return "x509: too many intermediates for path length constraint"
0000000000000000000000000000000000000000;;		case IncompatibleUsage:
0000000000000000000000000000000000000000;;			return "x509: certificate specifies an incompatible key usage"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "x509: unknown error"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HostnameError results when the set of authorized names doesn't match the
0000000000000000000000000000000000000000;;	// requested name.
0000000000000000000000000000000000000000;;	type HostnameError struct {
0000000000000000000000000000000000000000;;		Certificate *Certificate
0000000000000000000000000000000000000000;;		Host        string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h HostnameError) Error() string {
0000000000000000000000000000000000000000;;		c := h.Certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var valid string
0000000000000000000000000000000000000000;;		if ip := net.ParseIP(h.Host); ip != nil {
0000000000000000000000000000000000000000;;			// Trying to validate an IP
0000000000000000000000000000000000000000;;			if len(c.IPAddresses) == 0 {
0000000000000000000000000000000000000000;;				return "x509: cannot validate certificate for " + h.Host + " because it doesn't contain any IP SANs"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, san := range c.IPAddresses {
0000000000000000000000000000000000000000;;				if len(valid) > 0 {
0000000000000000000000000000000000000000;;					valid += ", "
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				valid += san.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if len(c.DNSNames) > 0 {
0000000000000000000000000000000000000000;;				valid = strings.Join(c.DNSNames, ", ")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				valid = c.Subject.CommonName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "x509: certificate is valid for " + valid + ", not " + h.Host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnknownAuthorityError results when the certificate issuer is unknown
0000000000000000000000000000000000000000;;	type UnknownAuthorityError struct {
0000000000000000000000000000000000000000;;		cert *Certificate
0000000000000000000000000000000000000000;;		// hintErr contains an error that may be helpful in determining why an
0000000000000000000000000000000000000000;;		// authority wasn't found.
0000000000000000000000000000000000000000;;		hintErr error
0000000000000000000000000000000000000000;;		// hintCert contains a possible authority certificate that was rejected
0000000000000000000000000000000000000000;;		// because of the error in hintErr.
0000000000000000000000000000000000000000;;		hintCert *Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e UnknownAuthorityError) Error() string {
0000000000000000000000000000000000000000;;		s := "x509: certificate signed by unknown authority"
0000000000000000000000000000000000000000;;		if e.hintErr != nil {
0000000000000000000000000000000000000000;;			certName := e.hintCert.Subject.CommonName
0000000000000000000000000000000000000000;;			if len(certName) == 0 {
0000000000000000000000000000000000000000;;				if len(e.hintCert.Subject.Organization) > 0 {
0000000000000000000000000000000000000000;;					certName = e.hintCert.Subject.Organization[0]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				certName = "serial:" + e.hintCert.SerialNumber.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s += fmt.Sprintf(" (possibly because of %q while trying to verify candidate authority certificate %q)", e.hintErr, certName)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SystemRootsError results when we fail to load the system root certificates.
0000000000000000000000000000000000000000;;	type SystemRootsError struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e SystemRootsError) Error() string {
0000000000000000000000000000000000000000;;		return "x509: failed to load system roots and no roots provided"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyOptions contains parameters for Certificate.Verify. It's a structure
0000000000000000000000000000000000000000;;	// because other PKIX verification APIs have ended up needing many options.
0000000000000000000000000000000000000000;;	type VerifyOptions struct {
0000000000000000000000000000000000000000;;		DNSName           string
0000000000000000000000000000000000000000;;		Intermediates     *CertPool
0000000000000000000000000000000000000000;;		Roots             *CertPool // if nil, the system roots are used
0000000000000000000000000000000000000000;;		CurrentTime       time.Time // if zero, the current time is used
0000000000000000000000000000000000000000;;		DisableTimeChecks bool
0000000000000000000000000000000000000000;;		// KeyUsage specifies which Extended Key Usage values are acceptable.
0000000000000000000000000000000000000000;;		// An empty list means ExtKeyUsageServerAuth. Key usage is considered a
0000000000000000000000000000000000000000;;		// constraint down the chain which mirrors Windows CryptoAPI behaviour,
0000000000000000000000000000000000000000;;		// but not the spec. To accept any key usage, include ExtKeyUsageAny.
0000000000000000000000000000000000000000;;		KeyUsages []ExtKeyUsage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		leafCertificate = iota
0000000000000000000000000000000000000000;;		intermediateCertificate
0000000000000000000000000000000000000000;;		rootCertificate
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isValid performs validity checks on the c.
0000000000000000000000000000000000000000;;	func (c *Certificate) isValid(certType int, currentChain []*Certificate, opts *VerifyOptions) error {
0000000000000000000000000000000000000000;;		if !opts.DisableTimeChecks {
0000000000000000000000000000000000000000;;			now := opts.CurrentTime
0000000000000000000000000000000000000000;;			if now.IsZero() {
0000000000000000000000000000000000000000;;				now = time.Now()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if now.Before(c.NotBefore) || now.After(c.NotAfter) {
0000000000000000000000000000000000000000;;				return CertificateInvalidError{c, Expired}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.PermittedDNSDomains) > 0 {
0000000000000000000000000000000000000000;;			ok := false
0000000000000000000000000000000000000000;;			for _, domain := range c.PermittedDNSDomains {
0000000000000000000000000000000000000000;;				if opts.DNSName == domain ||
0000000000000000000000000000000000000000;;					(strings.HasSuffix(opts.DNSName, domain) &&
0000000000000000000000000000000000000000;;						len(opts.DNSName) >= 1+len(domain) &&
0000000000000000000000000000000000000000;;						opts.DNSName[len(opts.DNSName)-len(domain)-1] == '.') {
0000000000000000000000000000000000000000;;					ok = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return CertificateInvalidError{c, CANotAuthorizedForThisName}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyUsage status flags are ignored. From Engineering Security, Peter
0000000000000000000000000000000000000000;;		// Gutmann: A European government CA marked its signing certificates as
0000000000000000000000000000000000000000;;		// being valid for encryption only, but no-one noticed. Another
0000000000000000000000000000000000000000;;		// European CA marked its signature keys as not being valid for
0000000000000000000000000000000000000000;;		// signatures. A different CA marked its own trusted root certificate
0000000000000000000000000000000000000000;;		// as being invalid for certificate signing.  Another national CA
0000000000000000000000000000000000000000;;		// distributed a certificate to be used to encrypt data for the
0000000000000000000000000000000000000000;;		// countryâ€™s tax authority that was marked as only being usable for
0000000000000000000000000000000000000000;;		// digital signatures but not for encryption. Yet another CA reversed
0000000000000000000000000000000000000000;;		// the order of the bit flags in the keyUsage due to confusion over
0000000000000000000000000000000000000000;;		// encoding endianness, essentially setting a random keyUsage in
0000000000000000000000000000000000000000;;		// certificates that it issued. Another CA created a self-invalidating
0000000000000000000000000000000000000000;;		// certificate by adding a certificate policy statement stipulating
0000000000000000000000000000000000000000;;		// that the certificate had to be used strictly as specified in the
0000000000000000000000000000000000000000;;		// keyUsage, and a keyUsage containing a flag indicating that the RSA
0000000000000000000000000000000000000000;;		// encryption key could only be used for Diffie-Hellman key agreement.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if certType == intermediateCertificate && (!c.BasicConstraintsValid || !c.IsCA) {
0000000000000000000000000000000000000000;;			return CertificateInvalidError{c, NotAuthorizedToSign}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.BasicConstraintsValid && c.MaxPathLen >= 0 {
0000000000000000000000000000000000000000;;			numIntermediates := len(currentChain) - 1
0000000000000000000000000000000000000000;;			if numIntermediates > c.MaxPathLen {
0000000000000000000000000000000000000000;;				return CertificateInvalidError{c, TooManyIntermediates}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify attempts to verify c by building one or more chains from c to a
0000000000000000000000000000000000000000;;	// certificate in opts.Roots, using certificates in opts.Intermediates if
0000000000000000000000000000000000000000;;	// needed. If successful, it returns one or more chains where the first
0000000000000000000000000000000000000000;;	// element of the chain is c and the last element is from opts.Roots.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// WARNING: this doesn't do any revocation checking.
0000000000000000000000000000000000000000;;	func (c *Certificate) Verify(opts VerifyOptions) (chains [][]*Certificate, err error) {
0000000000000000000000000000000000000000;;		// Use Windows's own verification and chain building.
0000000000000000000000000000000000000000;;		if opts.Roots == nil && runtime.GOOS == "windows" {
0000000000000000000000000000000000000000;;			return c.systemVerify(&opts)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.Roots == nil {
0000000000000000000000000000000000000000;;			opts.Roots = systemRootsPool()
0000000000000000000000000000000000000000;;			if opts.Roots == nil {
0000000000000000000000000000000000000000;;				return nil, SystemRootsError{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = c.isValid(leafCertificate, nil, &opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(opts.DNSName) > 0 {
0000000000000000000000000000000000000000;;			err = c.VerifyHostname(opts.DNSName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		candidateChains, err := c.buildChains(make(map[int][][]*Certificate), []*Certificate{c}, &opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keyUsages := opts.KeyUsages
0000000000000000000000000000000000000000;;		if len(keyUsages) == 0 {
0000000000000000000000000000000000000000;;			keyUsages = []ExtKeyUsage{ExtKeyUsageServerAuth}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If any key usage is acceptable then we're done.
0000000000000000000000000000000000000000;;		for _, usage := range keyUsages {
0000000000000000000000000000000000000000;;			if usage == ExtKeyUsageAny {
0000000000000000000000000000000000000000;;				chains = candidateChains
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, candidate := range candidateChains {
0000000000000000000000000000000000000000;;			if checkChainForKeyUsage(candidate, keyUsages) {
0000000000000000000000000000000000000000;;				chains = append(chains, candidate)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(chains) == 0 {
0000000000000000000000000000000000000000;;			err = CertificateInvalidError{c, IncompatibleUsage}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendToFreshChain(chain []*Certificate, cert *Certificate) []*Certificate {
0000000000000000000000000000000000000000;;		n := make([]*Certificate, len(chain)+1)
0000000000000000000000000000000000000000;;		copy(n, chain)
0000000000000000000000000000000000000000;;		n[len(chain)] = cert
0000000000000000000000000000000000000000;;		return n
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Certificate) buildChains(cache map[int][][]*Certificate, currentChain []*Certificate, opts *VerifyOptions) (chains [][]*Certificate, err error) {
0000000000000000000000000000000000000000;;		possibleRoots, failedRoot, rootErr := opts.Roots.findVerifiedParents(c)
0000000000000000000000000000000000000000;;		for _, rootNum := range possibleRoots {
0000000000000000000000000000000000000000;;			root := opts.Roots.certs[rootNum]
0000000000000000000000000000000000000000;;			err = root.isValid(rootCertificate, currentChain, opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chains = append(chains, appendToFreshChain(currentChain, root))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		possibleIntermediates, failedIntermediate, intermediateErr := opts.Intermediates.findVerifiedParents(c)
0000000000000000000000000000000000000000;;	nextIntermediate:
0000000000000000000000000000000000000000;;		for _, intermediateNum := range possibleIntermediates {
0000000000000000000000000000000000000000;;			intermediate := opts.Intermediates.certs[intermediateNum]
0000000000000000000000000000000000000000;;			for _, cert := range currentChain {
0000000000000000000000000000000000000000;;				if cert == intermediate {
0000000000000000000000000000000000000000;;					continue nextIntermediate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = intermediate.isValid(intermediateCertificate, currentChain, opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var childChains [][]*Certificate
0000000000000000000000000000000000000000;;			childChains, ok := cache[intermediateNum]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				childChains, err = intermediate.buildChains(cache, appendToFreshChain(currentChain, intermediate), opts)
0000000000000000000000000000000000000000;;				cache[intermediateNum] = childChains
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chains = append(chains, childChains...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(chains) > 0 {
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(chains) == 0 && err == nil {
0000000000000000000000000000000000000000;;			hintErr := rootErr
0000000000000000000000000000000000000000;;			hintCert := failedRoot
0000000000000000000000000000000000000000;;			if hintErr == nil {
0000000000000000000000000000000000000000;;				hintErr = intermediateErr
0000000000000000000000000000000000000000;;				hintCert = failedIntermediate
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = UnknownAuthorityError{c, hintErr, hintCert}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func matchHostnames(pattern, host string) bool {
0000000000000000000000000000000000000000;;		if len(pattern) == 0 || len(host) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patternParts := strings.Split(pattern, ".")
0000000000000000000000000000000000000000;;		hostParts := strings.Split(host, ".")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(patternParts) != len(hostParts) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, patternPart := range patternParts {
0000000000000000000000000000000000000000;;			if patternPart == "*" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if patternPart != hostParts[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// toLowerCaseASCII returns a lower-case version of in. See RFC 6125 6.4.1. We use
0000000000000000000000000000000000000000;;	// an explicitly ASCII function to avoid any sharp corners resulting from
0000000000000000000000000000000000000000;;	// performing Unicode operations on DNS labels.
0000000000000000000000000000000000000000;;	func toLowerCaseASCII(in string) string {
0000000000000000000000000000000000000000;;		// If the string is already lower-case then there's nothing to do.
0000000000000000000000000000000000000000;;		isAlreadyLowerCase := true
0000000000000000000000000000000000000000;;		for _, c := range in {
0000000000000000000000000000000000000000;;			if c == utf8.RuneError {
0000000000000000000000000000000000000000;;				// If we get a UTF-8 error then there might be
0000000000000000000000000000000000000000;;				// upper-case ASCII bytes in the invalid sequence.
0000000000000000000000000000000000000000;;				isAlreadyLowerCase = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;				isAlreadyLowerCase = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if isAlreadyLowerCase {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out := []byte(in)
0000000000000000000000000000000000000000;;		for i, c := range out {
0000000000000000000000000000000000000000;;			if 'A' <= c && c <= 'Z' {
0000000000000000000000000000000000000000;;				out[i] += 'a' - 'A'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifyHostname returns nil if c is a valid certificate for the named host.
0000000000000000000000000000000000000000;;	// Otherwise it returns an error describing the mismatch.
0000000000000000000000000000000000000000;;	func (c *Certificate) VerifyHostname(h string) error {
0000000000000000000000000000000000000000;;		// IP addresses may be written in [ ].
0000000000000000000000000000000000000000;;		candidateIP := h
0000000000000000000000000000000000000000;;		if len(h) >= 3 && h[0] == '[' && h[len(h)-1] == ']' {
0000000000000000000000000000000000000000;;			candidateIP = h[1 : len(h)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip := net.ParseIP(candidateIP); ip != nil {
0000000000000000000000000000000000000000;;			// We only match IP addresses against IP SANs.
0000000000000000000000000000000000000000;;			// https://tools.ietf.org/html/rfc6125#appendix-B.2
0000000000000000000000000000000000000000;;			for _, candidate := range c.IPAddresses {
0000000000000000000000000000000000000000;;				if ip.Equal(candidate) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return HostnameError{c, candidateIP}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lowered := toLowerCaseASCII(h)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(c.DNSNames) > 0 {
0000000000000000000000000000000000000000;;			for _, match := range c.DNSNames {
0000000000000000000000000000000000000000;;				if matchHostnames(toLowerCaseASCII(match), lowered) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If Subject Alt Name is given, we ignore the common name.
0000000000000000000000000000000000000000;;		} else if matchHostnames(toLowerCaseASCII(c.Subject.CommonName), lowered) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return HostnameError{c, h}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func checkChainForKeyUsage(chain []*Certificate, keyUsages []ExtKeyUsage) bool {
0000000000000000000000000000000000000000;;		usages := make([]ExtKeyUsage, len(keyUsages))
0000000000000000000000000000000000000000;;		copy(usages, keyUsages)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(chain) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usagesRemaining := len(usages)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We walk down the list and cross out any usages that aren't supported
0000000000000000000000000000000000000000;;		// by each certificate. If we cross out all the usages, then the chain
0000000000000000000000000000000000000000;;		// is unacceptable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := len(chain) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			cert := chain[i]
0000000000000000000000000000000000000000;;			if len(cert.ExtKeyUsage) == 0 && len(cert.UnknownExtKeyUsage) == 0 {
0000000000000000000000000000000000000000;;				// The certificate doesn't have any extended key usage specified.
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, usage := range cert.ExtKeyUsage {
0000000000000000000000000000000000000000;;				if usage == ExtKeyUsageAny {
0000000000000000000000000000000000000000;;					// The certificate is explicitly good for any usage.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			const invalidUsage ExtKeyUsage = -1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		NextRequestedUsage:
0000000000000000000000000000000000000000;;			for i, requestedUsage := range usages {
0000000000000000000000000000000000000000;;				if requestedUsage == invalidUsage {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, usage := range cert.ExtKeyUsage {
0000000000000000000000000000000000000000;;					if requestedUsage == usage {
0000000000000000000000000000000000000000;;						continue NextRequestedUsage
0000000000000000000000000000000000000000;;					} else if requestedUsage == ExtKeyUsageServerAuth &&
0000000000000000000000000000000000000000;;						(usage == ExtKeyUsageNetscapeServerGatedCrypto ||
0000000000000000000000000000000000000000;;							usage == ExtKeyUsageMicrosoftServerGatedCrypto) {
0000000000000000000000000000000000000000;;						// In order to support COMODO
0000000000000000000000000000000000000000;;						// certificate chains, we have to
0000000000000000000000000000000000000000;;						// accept Netscape or Microsoft SGC
0000000000000000000000000000000000000000;;						// usages as equal to ServerAuth.
0000000000000000000000000000000000000000;;						continue NextRequestedUsage
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				usages[i] = invalidUsage
0000000000000000000000000000000000000000;;				usagesRemaining--
0000000000000000000000000000000000000000;;				if usagesRemaining == 0 {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
