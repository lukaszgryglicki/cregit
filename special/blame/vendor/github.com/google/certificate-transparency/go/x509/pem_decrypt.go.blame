0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC 1423 describes the encryption of PEM blocks. The algorithm used to
0000000000000000000000000000000000000000;;	// generate a key from the password was derived by looking at the OpenSSL
0000000000000000000000000000000000000000;;	// implementation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/des"
0000000000000000000000000000000000000000;;		"crypto/md5"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PEMCipher int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Possible values for the EncryptPEMBlock encryption algorithm.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_ PEMCipher = iota
0000000000000000000000000000000000000000;;		PEMCipherDES
0000000000000000000000000000000000000000;;		PEMCipher3DES
0000000000000000000000000000000000000000;;		PEMCipherAES128
0000000000000000000000000000000000000000;;		PEMCipherAES192
0000000000000000000000000000000000000000;;		PEMCipherAES256
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rfc1423Algo holds a method for enciphering a PEM block.
0000000000000000000000000000000000000000;;	type rfc1423Algo struct {
0000000000000000000000000000000000000000;;		cipher     PEMCipher
0000000000000000000000000000000000000000;;		name       string
0000000000000000000000000000000000000000;;		cipherFunc func(key []byte) (cipher.Block, error)
0000000000000000000000000000000000000000;;		keySize    int
0000000000000000000000000000000000000000;;		blockSize  int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rfc1423Algos holds a slice of the possible ways to encrypt a PEM
0000000000000000000000000000000000000000;;	// block.  The ivSize numbers were taken from the OpenSSL source.
0000000000000000000000000000000000000000;;	var rfc1423Algos = []rfc1423Algo{{
0000000000000000000000000000000000000000;;		cipher:     PEMCipherDES,
0000000000000000000000000000000000000000;;		name:       "DES-CBC",
0000000000000000000000000000000000000000;;		cipherFunc: des.NewCipher,
0000000000000000000000000000000000000000;;		keySize:    8,
0000000000000000000000000000000000000000;;		blockSize:  des.BlockSize,
0000000000000000000000000000000000000000;;	}, {
0000000000000000000000000000000000000000;;		cipher:     PEMCipher3DES,
0000000000000000000000000000000000000000;;		name:       "DES-EDE3-CBC",
0000000000000000000000000000000000000000;;		cipherFunc: des.NewTripleDESCipher,
0000000000000000000000000000000000000000;;		keySize:    24,
0000000000000000000000000000000000000000;;		blockSize:  des.BlockSize,
0000000000000000000000000000000000000000;;	}, {
0000000000000000000000000000000000000000;;		cipher:     PEMCipherAES128,
0000000000000000000000000000000000000000;;		name:       "AES-128-CBC",
0000000000000000000000000000000000000000;;		cipherFunc: aes.NewCipher,
0000000000000000000000000000000000000000;;		keySize:    16,
0000000000000000000000000000000000000000;;		blockSize:  aes.BlockSize,
0000000000000000000000000000000000000000;;	}, {
0000000000000000000000000000000000000000;;		cipher:     PEMCipherAES192,
0000000000000000000000000000000000000000;;		name:       "AES-192-CBC",
0000000000000000000000000000000000000000;;		cipherFunc: aes.NewCipher,
0000000000000000000000000000000000000000;;		keySize:    24,
0000000000000000000000000000000000000000;;		blockSize:  aes.BlockSize,
0000000000000000000000000000000000000000;;	}, {
0000000000000000000000000000000000000000;;		cipher:     PEMCipherAES256,
0000000000000000000000000000000000000000;;		name:       "AES-256-CBC",
0000000000000000000000000000000000000000;;		cipherFunc: aes.NewCipher,
0000000000000000000000000000000000000000;;		keySize:    32,
0000000000000000000000000000000000000000;;		blockSize:  aes.BlockSize,
0000000000000000000000000000000000000000;;	},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// deriveKey uses a key derivation function to stretch the password into a key
0000000000000000000000000000000000000000;;	// with the number of bits our cipher requires. This algorithm was derived from
0000000000000000000000000000000000000000;;	// the OpenSSL source.
0000000000000000000000000000000000000000;;	func (c rfc1423Algo) deriveKey(password, salt []byte) []byte {
0000000000000000000000000000000000000000;;		hash := md5.New()
0000000000000000000000000000000000000000;;		out := make([]byte, c.keySize)
0000000000000000000000000000000000000000;;		var digest []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < len(out); i += len(digest) {
0000000000000000000000000000000000000000;;			hash.Reset()
0000000000000000000000000000000000000000;;			hash.Write(digest)
0000000000000000000000000000000000000000;;			hash.Write(password)
0000000000000000000000000000000000000000;;			hash.Write(salt)
0000000000000000000000000000000000000000;;			digest = hash.Sum(digest[:0])
0000000000000000000000000000000000000000;;			copy(out[i:], digest)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEncryptedPEMBlock returns if the PEM block is password encrypted.
0000000000000000000000000000000000000000;;	func IsEncryptedPEMBlock(b *pem.Block) bool {
0000000000000000000000000000000000000000;;		_, ok := b.Headers["DEK-Info"]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IncorrectPasswordError is returned when an incorrect password is detected.
0000000000000000000000000000000000000000;;	var IncorrectPasswordError = errors.New("x509: decryption password incorrect")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecryptPEMBlock takes a password encrypted PEM block and the password used to
0000000000000000000000000000000000000000;;	// encrypt it and returns a slice of decrypted DER encoded bytes. It inspects
0000000000000000000000000000000000000000;;	// the DEK-Info header to determine the algorithm used for decryption. If no
0000000000000000000000000000000000000000;;	// DEK-Info header is present, an error is returned. If an incorrect password
0000000000000000000000000000000000000000;;	// is detected an IncorrectPasswordError is returned.
0000000000000000000000000000000000000000;;	func DecryptPEMBlock(b *pem.Block, password []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		dek, ok := b.Headers["DEK-Info"]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: no DEK-Info header in block")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idx := strings.Index(dek, ",")
0000000000000000000000000000000000000000;;		if idx == -1 {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: malformed DEK-Info header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mode, hexIV := dek[:idx], dek[idx+1:]
0000000000000000000000000000000000000000;;		ciph := cipherByName(mode)
0000000000000000000000000000000000000000;;		if ciph == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: unknown encryption mode")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iv, err := hex.DecodeString(hexIV)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(iv) != ciph.blockSize {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: incorrect IV size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Based on the OpenSSL implementation. The salt is the first 8 bytes
0000000000000000000000000000000000000000;;		// of the initialization vector.
0000000000000000000000000000000000000000;;		key := ciph.deriveKey(password, iv[:8])
0000000000000000000000000000000000000000;;		block, err := ciph.cipherFunc(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := make([]byte, len(b.Bytes))
0000000000000000000000000000000000000000;;		dec := cipher.NewCBCDecrypter(block, iv)
0000000000000000000000000000000000000000;;		dec.CryptBlocks(data, b.Bytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Blocks are padded using a scheme where the last n bytes of padding are all
0000000000000000000000000000000000000000;;		// equal to n. It can pad from 1 to blocksize bytes inclusive. See RFC 1423.
0000000000000000000000000000000000000000;;		// For example:
0000000000000000000000000000000000000000;;		//	[x y z 2 2]
0000000000000000000000000000000000000000;;		//	[x y 7 7 7 7 7 7 7]
0000000000000000000000000000000000000000;;		// If we detect a bad padding, we assume it is an invalid password.
0000000000000000000000000000000000000000;;		dlen := len(data)
0000000000000000000000000000000000000000;;		if dlen == 0 || dlen%ciph.blockSize != 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: invalid padding")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		last := int(data[dlen-1])
0000000000000000000000000000000000000000;;		if dlen < last {
0000000000000000000000000000000000000000;;			return nil, IncorrectPasswordError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if last == 0 || last > ciph.blockSize {
0000000000000000000000000000000000000000;;			return nil, IncorrectPasswordError
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, val := range data[dlen-last:] {
0000000000000000000000000000000000000000;;			if int(val) != last {
0000000000000000000000000000000000000000;;				return nil, IncorrectPasswordError
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data[:dlen-last], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncryptPEMBlock returns a PEM block of the specified type holding the
0000000000000000000000000000000000000000;;	// given DER-encoded data encrypted with the specified algorithm and
0000000000000000000000000000000000000000;;	// password.
0000000000000000000000000000000000000000;;	func EncryptPEMBlock(rand io.Reader, blockType string, data, password []byte, alg PEMCipher) (*pem.Block, error) {
0000000000000000000000000000000000000000;;		ciph := cipherByKey(alg)
0000000000000000000000000000000000000000;;		if ciph == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: unknown encryption mode")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		iv := make([]byte, ciph.blockSize)
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rand, iv); err != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: cannot generate IV: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The salt is the first 8 bytes of the initialization vector,
0000000000000000000000000000000000000000;;		// matching the key derivation in DecryptPEMBlock.
0000000000000000000000000000000000000000;;		key := ciph.deriveKey(password, iv[:8])
0000000000000000000000000000000000000000;;		block, err := ciph.cipherFunc(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enc := cipher.NewCBCEncrypter(block, iv)
0000000000000000000000000000000000000000;;		pad := ciph.blockSize - len(data)%ciph.blockSize
0000000000000000000000000000000000000000;;		encrypted := make([]byte, len(data), len(data)+pad)
0000000000000000000000000000000000000000;;		// We could save this copy by encrypting all the whole blocks in
0000000000000000000000000000000000000000;;		// the data separately, but it doesn't seem worth the additional
0000000000000000000000000000000000000000;;		// code.
0000000000000000000000000000000000000000;;		copy(encrypted, data)
0000000000000000000000000000000000000000;;		// See RFC 1423, section 1.1
0000000000000000000000000000000000000000;;		for i := 0; i < pad; i++ {
0000000000000000000000000000000000000000;;			encrypted = append(encrypted, byte(pad))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		enc.CryptBlocks(encrypted, encrypted)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &pem.Block{
0000000000000000000000000000000000000000;;			Type: blockType,
0000000000000000000000000000000000000000;;			Headers: map[string]string{
0000000000000000000000000000000000000000;;				"Proc-Type": "4,ENCRYPTED",
0000000000000000000000000000000000000000;;				"DEK-Info":  ciph.name + "," + hex.EncodeToString(iv),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			Bytes: encrypted,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cipherByName(name string) *rfc1423Algo {
0000000000000000000000000000000000000000;;		for i := range rfc1423Algos {
0000000000000000000000000000000000000000;;			alg := &rfc1423Algos[i]
0000000000000000000000000000000000000000;;			if alg.name == name {
0000000000000000000000000000000000000000;;				return alg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cipherByKey(key PEMCipher) *rfc1423Algo {
0000000000000000000000000000000000000000;;		for i := range rfc1423Algos {
0000000000000000000000000000000000000000;;			alg := &rfc1423Algos[i]
0000000000000000000000000000000000000000;;			if alg.cipher == key {
0000000000000000000000000000000000000000;;				return alg
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
