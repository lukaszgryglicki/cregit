0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a new *syscall.CertContext representing the leaf certificate in an in-memory
0000000000000000000000000000000000000000;;	// certificate store containing itself and all of the intermediate certificates specified
0000000000000000000000000000000000000000;;	// in the opts.Intermediates CertPool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A pointer to the in-memory store is available in the returned CertContext's Store field.
0000000000000000000000000000000000000000;;	// The store is automatically freed when the CertContext is freed using
0000000000000000000000000000000000000000;;	// syscall.CertFreeCertificateContext.
0000000000000000000000000000000000000000;;	func createStoreContext(leaf *Certificate, opts *VerifyOptions) (*syscall.CertContext, error) {
0000000000000000000000000000000000000000;;		var storeCtx *syscall.CertContext
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		leafCtx, err := syscall.CertCreateCertificateContext(syscall.X509_ASN_ENCODING|syscall.PKCS_7_ASN_ENCODING, &leaf.Raw[0], uint32(len(leaf.Raw)))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer syscall.CertFreeCertificateContext(leafCtx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handle, err := syscall.CertOpenStore(syscall.CERT_STORE_PROV_MEMORY, 0, 0, syscall.CERT_STORE_DEFER_CLOSE_UNTIL_LAST_FREE_FLAG, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer syscall.CertCloseStore(handle, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = syscall.CertAddCertificateContextToStore(handle, leafCtx, syscall.CERT_STORE_ADD_ALWAYS, &storeCtx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.Intermediates != nil {
0000000000000000000000000000000000000000;;			for _, intermediate := range opts.Intermediates.certs {
0000000000000000000000000000000000000000;;				ctx, err := syscall.CertCreateCertificateContext(syscall.X509_ASN_ENCODING|syscall.PKCS_7_ASN_ENCODING, &intermediate.Raw[0], uint32(len(intermediate.Raw)))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				err = syscall.CertAddCertificateContextToStore(handle, ctx, syscall.CERT_STORE_ADD_ALWAYS, nil)
0000000000000000000000000000000000000000;;				syscall.CertFreeCertificateContext(ctx)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return storeCtx, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// extractSimpleChain extracts the final certificate chain from a CertSimpleChain.
0000000000000000000000000000000000000000;;	func extractSimpleChain(simpleChain **syscall.CertSimpleChain, count int) (chain []*Certificate, err error) {
0000000000000000000000000000000000000000;;		if simpleChain == nil || count == 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: invalid simple chain")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		simpleChains := (*[1 << 20]*syscall.CertSimpleChain)(unsafe.Pointer(simpleChain))[:]
0000000000000000000000000000000000000000;;		lastChain := simpleChains[count-1]
0000000000000000000000000000000000000000;;		elements := (*[1 << 20]*syscall.CertChainElement)(unsafe.Pointer(lastChain.Elements))[:]
0000000000000000000000000000000000000000;;		for i := 0; i < int(lastChain.NumElements); i++ {
0000000000000000000000000000000000000000;;			// Copy the buf, since ParseCertificate does not create its own copy.
0000000000000000000000000000000000000000;;			cert := elements[i].CertContext
0000000000000000000000000000000000000000;;			encodedCert := (*[1 << 20]byte)(unsafe.Pointer(cert.EncodedCert))[:]
0000000000000000000000000000000000000000;;			buf := make([]byte, cert.Length)
0000000000000000000000000000000000000000;;			copy(buf, encodedCert[:])
0000000000000000000000000000000000000000;;			parsedCert, err := ParseCertificate(buf)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			chain = append(chain, parsedCert)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return chain, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkChainTrustStatus checks the trust status of the certificate chain, translating
0000000000000000000000000000000000000000;;	// any errors it finds into Go errors in the process.
0000000000000000000000000000000000000000;;	func checkChainTrustStatus(c *Certificate, chainCtx *syscall.CertChainContext) error {
0000000000000000000000000000000000000000;;		if chainCtx.TrustStatus.ErrorStatus != syscall.CERT_TRUST_NO_ERROR {
0000000000000000000000000000000000000000;;			status := chainCtx.TrustStatus.ErrorStatus
0000000000000000000000000000000000000000;;			switch status {
0000000000000000000000000000000000000000;;			case syscall.CERT_TRUST_IS_NOT_TIME_VALID:
0000000000000000000000000000000000000000;;				return CertificateInvalidError{c, Expired}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return UnknownAuthorityError{c, nil, nil}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkChainSSLServerPolicy checks that the certificate chain in chainCtx is valid for
0000000000000000000000000000000000000000;;	// use as a certificate chain for a SSL/TLS server.
0000000000000000000000000000000000000000;;	func checkChainSSLServerPolicy(c *Certificate, chainCtx *syscall.CertChainContext, opts *VerifyOptions) error {
0000000000000000000000000000000000000000;;		servernamep, err := syscall.UTF16PtrFromString(opts.DNSName)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sslPara := &syscall.SSLExtraCertChainPolicyPara{
0000000000000000000000000000000000000000;;			AuthType:   syscall.AUTHTYPE_SERVER,
0000000000000000000000000000000000000000;;			ServerName: servernamep,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sslPara.Size = uint32(unsafe.Sizeof(*sslPara))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		para := &syscall.CertChainPolicyPara{
0000000000000000000000000000000000000000;;			ExtraPolicyPara: uintptr(unsafe.Pointer(sslPara)),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		para.Size = uint32(unsafe.Sizeof(*para))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		status := syscall.CertChainPolicyStatus{}
0000000000000000000000000000000000000000;;		err = syscall.CertVerifyCertificateChainPolicy(syscall.CERT_CHAIN_POLICY_SSL, chainCtx, para, &status)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO(mkrautz): use the lChainIndex and lElementIndex fields
0000000000000000000000000000000000000000;;		// of the CertChainPolicyStatus to provide proper context, instead
0000000000000000000000000000000000000000;;		// using c.
0000000000000000000000000000000000000000;;		if status.Error != 0 {
0000000000000000000000000000000000000000;;			switch status.Error {
0000000000000000000000000000000000000000;;			case syscall.CERT_E_EXPIRED:
0000000000000000000000000000000000000000;;				return CertificateInvalidError{c, Expired}
0000000000000000000000000000000000000000;;			case syscall.CERT_E_CN_NO_MATCH:
0000000000000000000000000000000000000000;;				return HostnameError{c, opts.DNSName}
0000000000000000000000000000000000000000;;			case syscall.CERT_E_UNTRUSTEDROOT:
0000000000000000000000000000000000000000;;				return UnknownAuthorityError{c, nil, nil}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return UnknownAuthorityError{c, nil, nil}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// systemVerify is like Verify, except that it uses CryptoAPI calls
0000000000000000000000000000000000000000;;	// to build certificate chains and verify them.
0000000000000000000000000000000000000000;;	func (c *Certificate) systemVerify(opts *VerifyOptions) (chains [][]*Certificate, err error) {
0000000000000000000000000000000000000000;;		hasDNSName := opts != nil && len(opts.DNSName) > 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		storeCtx, err := createStoreContext(c, opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer syscall.CertFreeCertificateContext(storeCtx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		para := new(syscall.CertChainPara)
0000000000000000000000000000000000000000;;		para.Size = uint32(unsafe.Sizeof(*para))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there's a DNSName set in opts, assume we're verifying
0000000000000000000000000000000000000000;;		// a certificate from a TLS server.
0000000000000000000000000000000000000000;;		if hasDNSName {
0000000000000000000000000000000000000000;;			oids := []*byte{
0000000000000000000000000000000000000000;;				&syscall.OID_PKIX_KP_SERVER_AUTH[0],
0000000000000000000000000000000000000000;;				// Both IE and Chrome allow certificates with
0000000000000000000000000000000000000000;;				// Server Gated Crypto as well. Some certificates
0000000000000000000000000000000000000000;;				// in the wild require them.
0000000000000000000000000000000000000000;;				&syscall.OID_SERVER_GATED_CRYPTO[0],
0000000000000000000000000000000000000000;;				&syscall.OID_SGC_NETSCAPE[0],
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			para.RequestedUsage.Type = syscall.USAGE_MATCH_TYPE_OR
0000000000000000000000000000000000000000;;			para.RequestedUsage.Usage.Length = uint32(len(oids))
0000000000000000000000000000000000000000;;			para.RequestedUsage.Usage.UsageIdentifiers = &oids[0]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			para.RequestedUsage.Type = syscall.USAGE_MATCH_TYPE_AND
0000000000000000000000000000000000000000;;			para.RequestedUsage.Usage.Length = 0
0000000000000000000000000000000000000000;;			para.RequestedUsage.Usage.UsageIdentifiers = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var verifyTime *syscall.Filetime
0000000000000000000000000000000000000000;;		if opts != nil && !opts.CurrentTime.IsZero() {
0000000000000000000000000000000000000000;;			ft := syscall.NsecToFiletime(opts.CurrentTime.UnixNano())
0000000000000000000000000000000000000000;;			verifyTime = &ft
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CertGetCertificateChain will traverse Windows's root stores
0000000000000000000000000000000000000000;;		// in an attempt to build a verified certificate chain.  Once
0000000000000000000000000000000000000000;;		// it has found a verified chain, it stops. MSDN docs on
0000000000000000000000000000000000000000;;		// CERT_CHAIN_CONTEXT:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//   When a CERT_CHAIN_CONTEXT is built, the first simple chain
0000000000000000000000000000000000000000;;		//   begins with an end certificate and ends with a self-signed
0000000000000000000000000000000000000000;;		//   certificate. If that self-signed certificate is not a root
0000000000000000000000000000000000000000;;		//   or otherwise trusted certificate, an attempt is made to
0000000000000000000000000000000000000000;;		//   build a new chain. CTLs are used to create the new chain
0000000000000000000000000000000000000000;;		//   beginning with the self-signed certificate from the original
0000000000000000000000000000000000000000;;		//   chain as the end certificate of the new chain. This process
0000000000000000000000000000000000000000;;		//   continues building additional simple chains until the first
0000000000000000000000000000000000000000;;		//   self-signed certificate is a trusted certificate or until
0000000000000000000000000000000000000000;;		//   an additional simple chain cannot be built.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// The result is that we'll only get a single trusted chain to
0000000000000000000000000000000000000000;;		// return to our caller.
0000000000000000000000000000000000000000;;		var chainCtx *syscall.CertChainContext
0000000000000000000000000000000000000000;;		err = syscall.CertGetCertificateChain(syscall.Handle(0), storeCtx, verifyTime, storeCtx.Store, para, 0, 0, &chainCtx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer syscall.CertFreeCertificateChain(chainCtx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = checkChainTrustStatus(c, chainCtx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if hasDNSName {
0000000000000000000000000000000000000000;;			err = checkChainSSLServerPolicy(c, chainCtx, opts)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chain, err := extractSimpleChain(chainCtx.Chains, int(chainCtx.ChainCount))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chains = append(chains, chain)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return chains, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initSystemRoots() {
0000000000000000000000000000000000000000;;	}
