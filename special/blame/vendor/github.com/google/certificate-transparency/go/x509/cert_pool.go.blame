0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertPool is a set of certificates.
0000000000000000000000000000000000000000;;	type CertPool struct {
0000000000000000000000000000000000000000;;		bySubjectKeyId map[string][]int
0000000000000000000000000000000000000000;;		byName         map[string][]int
0000000000000000000000000000000000000000;;		certs          []*Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCertPool returns a new, empty CertPool.
0000000000000000000000000000000000000000;;	func NewCertPool() *CertPool {
0000000000000000000000000000000000000000;;		return &CertPool{
0000000000000000000000000000000000000000;;			make(map[string][]int),
0000000000000000000000000000000000000000;;			make(map[string][]int),
0000000000000000000000000000000000000000;;			nil,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findVerifiedParents attempts to find certificates in s which have signed the
0000000000000000000000000000000000000000;;	// given certificate. If any candidates were rejected then errCert will be set
0000000000000000000000000000000000000000;;	// to one of them, arbitrarily, and err will contain the reason that it was
0000000000000000000000000000000000000000;;	// rejected.
0000000000000000000000000000000000000000;;	func (s *CertPool) findVerifiedParents(cert *Certificate) (parents []int, errCert *Certificate, err error) {
0000000000000000000000000000000000000000;;		if s == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var candidates []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cert.AuthorityKeyId) > 0 {
0000000000000000000000000000000000000000;;			candidates = s.bySubjectKeyId[string(cert.AuthorityKeyId)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(candidates) == 0 {
0000000000000000000000000000000000000000;;			candidates = s.byName[string(cert.RawIssuer)]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range candidates {
0000000000000000000000000000000000000000;;			if err = cert.CheckSignatureFrom(s.certs[c]); err == nil {
0000000000000000000000000000000000000000;;				parents = append(parents, c)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				errCert = s.certs[c]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddCert adds a certificate to a pool.
0000000000000000000000000000000000000000;;	func (s *CertPool) AddCert(cert *Certificate) {
0000000000000000000000000000000000000000;;		if cert == nil {
0000000000000000000000000000000000000000;;			panic("adding nil Certificate to CertPool")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check that the certificate isn't being added twice.
0000000000000000000000000000000000000000;;		for _, c := range s.certs {
0000000000000000000000000000000000000000;;			if c.Equal(cert) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n := len(s.certs)
0000000000000000000000000000000000000000;;		s.certs = append(s.certs, cert)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(cert.SubjectKeyId) > 0 {
0000000000000000000000000000000000000000;;			keyId := string(cert.SubjectKeyId)
0000000000000000000000000000000000000000;;			s.bySubjectKeyId[keyId] = append(s.bySubjectKeyId[keyId], n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := string(cert.RawSubject)
0000000000000000000000000000000000000000;;		s.byName[name] = append(s.byName[name], n)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AppendCertsFromPEM attempts to parse a series of PEM encoded certificates.
0000000000000000000000000000000000000000;;	// It appends any certificates found to s and returns true if any certificates
0000000000000000000000000000000000000000;;	// were successfully parsed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// On many Linux systems, /etc/ssl/cert.pem will contain the system wide set
0000000000000000000000000000000000000000;;	// of root CAs in a format suitable for this function.
0000000000000000000000000000000000000000;;	func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool) {
0000000000000000000000000000000000000000;;		for len(pemCerts) > 0 {
0000000000000000000000000000000000000000;;			var block *pem.Block
0000000000000000000000000000000000000000;;			block, pemCerts = pem.Decode(pemCerts)
0000000000000000000000000000000000000000;;			if block == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if block.Type != "CERTIFICATE" || len(block.Headers) != 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cert, err := ParseCertificate(block.Bytes)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			s.AddCert(cert)
0000000000000000000000000000000000000000;;			ok = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subjects returns a list of the DER-encoded subjects of
0000000000000000000000000000000000000000;;	// all of the certificates in the pool.
0000000000000000000000000000000000000000;;	func (s *CertPool) Subjects() (res [][]byte) {
0000000000000000000000000000000000000000;;		res = make([][]byte, len(s.certs))
0000000000000000000000000000000000000000;;		for i, c := range s.certs {
0000000000000000000000000000000000000000;;			res[i] = c.RawSubject
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
