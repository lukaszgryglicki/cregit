0000000000000000000000000000000000000000;;	// Copyright 2012 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go/asn1"
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const ecPrivKeyVersion = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ecPrivateKey reflects an ASN.1 Elliptic Curve Private Key Structure.
0000000000000000000000000000000000000000;;	// References:
0000000000000000000000000000000000000000;;	//   RFC5915
0000000000000000000000000000000000000000;;	//   SEC1 - http://www.secg.org/download/aid-780/sec1-v2.pdf
0000000000000000000000000000000000000000;;	// Per RFC5915 the NamedCurveOID is marked as ASN.1 OPTIONAL, however in
0000000000000000000000000000000000000000;;	// most cases it is not.
0000000000000000000000000000000000000000;;	type ecPrivateKey struct {
0000000000000000000000000000000000000000;;		Version       int
0000000000000000000000000000000000000000;;		PrivateKey    []byte
0000000000000000000000000000000000000000;;		NamedCurveOID asn1.ObjectIdentifier `asn1:"optional,explicit,tag:0"`
0000000000000000000000000000000000000000;;		PublicKey     asn1.BitString        `asn1:"optional,explicit,tag:1"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.
0000000000000000000000000000000000000000;;	func ParseECPrivateKey(der []byte) (key *ecdsa.PrivateKey, err error) {
0000000000000000000000000000000000000000;;		return parseECPrivateKey(nil, der)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.
0000000000000000000000000000000000000000;;	func MarshalECPrivateKey(key *ecdsa.PrivateKey) ([]byte, error) {
0000000000000000000000000000000000000000;;		oid, ok := oidFromNamedCurve(key.Curve)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: unknown elliptic curve")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return asn1.Marshal(ecPrivateKey{
0000000000000000000000000000000000000000;;			Version:       1,
0000000000000000000000000000000000000000;;			PrivateKey:    key.D.Bytes(),
0000000000000000000000000000000000000000;;			NamedCurveOID: oid,
0000000000000000000000000000000000000000;;			PublicKey:     asn1.BitString{Bytes: elliptic.Marshal(key.Curve, key.X, key.Y)},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.
0000000000000000000000000000000000000000;;	// The OID for the named curve may be provided from another source (such as
0000000000000000000000000000000000000000;;	// the PKCS8 container) - if it is provided then use this instead of the OID
0000000000000000000000000000000000000000;;	// that may exist in the EC private key structure.
0000000000000000000000000000000000000000;;	func parseECPrivateKey(namedCurveOID *asn1.ObjectIdentifier, der []byte) (key *ecdsa.PrivateKey, err error) {
0000000000000000000000000000000000000000;;		var privKey ecPrivateKey
0000000000000000000000000000000000000000;;		if _, err := asn1.Unmarshal(der, &privKey); err != nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: failed to parse EC private key: " + err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if privKey.Version != ecPrivKeyVersion {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("x509: unknown EC private key version %d", privKey.Version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var curve elliptic.Curve
0000000000000000000000000000000000000000;;		if namedCurveOID != nil {
0000000000000000000000000000000000000000;;			curve = namedCurveFromOID(*namedCurveOID)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			curve = namedCurveFromOID(privKey.NamedCurveOID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if curve == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: unknown elliptic curve")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		k := new(big.Int).SetBytes(privKey.PrivateKey)
0000000000000000000000000000000000000000;;		if k.Cmp(curve.Params().N) >= 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: invalid elliptic curve private key value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		priv := new(ecdsa.PrivateKey)
0000000000000000000000000000000000000000;;		priv.Curve = curve
0000000000000000000000000000000000000000;;		priv.D = k
0000000000000000000000000000000000000000;;		priv.X, priv.Y = curve.ScalarBaseMult(privKey.PrivateKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return priv, nil
0000000000000000000000000000000000000000;;	}
