0000000000000000000000000000000000000000;;	// Copyright 2011 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package x509
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"github.com/google/certificate-transparency/go/asn1"
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pkcs1PrivateKey is a structure which mirrors the PKCS#1 ASN.1 for an RSA private key.
0000000000000000000000000000000000000000;;	type pkcs1PrivateKey struct {
0000000000000000000000000000000000000000;;		Version int
0000000000000000000000000000000000000000;;		N       *big.Int
0000000000000000000000000000000000000000;;		E       int
0000000000000000000000000000000000000000;;		D       *big.Int
0000000000000000000000000000000000000000;;		P       *big.Int
0000000000000000000000000000000000000000;;		Q       *big.Int
0000000000000000000000000000000000000000;;		// We ignore these values, if present, because rsa will calculate them.
0000000000000000000000000000000000000000;;		Dp   *big.Int `asn1:"optional"`
0000000000000000000000000000000000000000;;		Dq   *big.Int `asn1:"optional"`
0000000000000000000000000000000000000000;;		Qinv *big.Int `asn1:"optional"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		AdditionalPrimes []pkcs1AdditionalRSAPrime `asn1:"optional,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pkcs1AdditionalRSAPrime struct {
0000000000000000000000000000000000000000;;		Prime *big.Int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We ignore these values because rsa will calculate them.
0000000000000000000000000000000000000000;;		Exp   *big.Int
0000000000000000000000000000000000000000;;		Coeff *big.Int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.
0000000000000000000000000000000000000000;;	func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err error) {
0000000000000000000000000000000000000000;;		var priv pkcs1PrivateKey
0000000000000000000000000000000000000000;;		rest, err := asn1.Unmarshal(der, &priv)
0000000000000000000000000000000000000000;;		if len(rest) > 0 {
0000000000000000000000000000000000000000;;			err = asn1.SyntaxError{Msg: "trailing data"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if priv.Version > 1 {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: unsupported private key version")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if priv.N.Sign() <= 0 || priv.D.Sign() <= 0 || priv.P.Sign() <= 0 || priv.Q.Sign() <= 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("x509: private key contains zero or negative value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key = new(rsa.PrivateKey)
0000000000000000000000000000000000000000;;		key.PublicKey = rsa.PublicKey{
0000000000000000000000000000000000000000;;			E: priv.E,
0000000000000000000000000000000000000000;;			N: priv.N,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key.D = priv.D
0000000000000000000000000000000000000000;;		key.Primes = make([]*big.Int, 2+len(priv.AdditionalPrimes))
0000000000000000000000000000000000000000;;		key.Primes[0] = priv.P
0000000000000000000000000000000000000000;;		key.Primes[1] = priv.Q
0000000000000000000000000000000000000000;;		for i, a := range priv.AdditionalPrimes {
0000000000000000000000000000000000000000;;			if a.Prime.Sign() <= 0 {
0000000000000000000000000000000000000000;;				return nil, errors.New("x509: private key contains zero or negative prime")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			key.Primes[i+2] = a.Prime
0000000000000000000000000000000000000000;;			// We ignore the other two values because rsa will calculate
0000000000000000000000000000000000000000;;			// them as needed.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = key.Validate()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key.Precompute()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.
0000000000000000000000000000000000000000;;	func MarshalPKCS1PrivateKey(key *rsa.PrivateKey) []byte {
0000000000000000000000000000000000000000;;		key.Precompute()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version := 0
0000000000000000000000000000000000000000;;		if len(key.Primes) > 2 {
0000000000000000000000000000000000000000;;			version = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priv := pkcs1PrivateKey{
0000000000000000000000000000000000000000;;			Version: version,
0000000000000000000000000000000000000000;;			N:       key.N,
0000000000000000000000000000000000000000;;			E:       key.PublicKey.E,
0000000000000000000000000000000000000000;;			D:       key.D,
0000000000000000000000000000000000000000;;			P:       key.Primes[0],
0000000000000000000000000000000000000000;;			Q:       key.Primes[1],
0000000000000000000000000000000000000000;;			Dp:      key.Precomputed.Dp,
0000000000000000000000000000000000000000;;			Dq:      key.Precomputed.Dq,
0000000000000000000000000000000000000000;;			Qinv:    key.Precomputed.Qinv,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		priv.AdditionalPrimes = make([]pkcs1AdditionalRSAPrime, len(key.Precomputed.CRTValues))
0000000000000000000000000000000000000000;;		for i, values := range key.Precomputed.CRTValues {
0000000000000000000000000000000000000000;;			priv.AdditionalPrimes[i].Prime = key.Primes[2+i]
0000000000000000000000000000000000000000;;			priv.AdditionalPrimes[i].Exp = values.Exp
0000000000000000000000000000000000000000;;			priv.AdditionalPrimes[i].Coeff = values.Coeff
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b, _ := asn1.Marshal(priv)
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rsaPublicKey reflects the ASN.1 structure of a PKCS#1 public key.
0000000000000000000000000000000000000000;;	type rsaPublicKey struct {
0000000000000000000000000000000000000000;;		N *big.Int
0000000000000000000000000000000000000000;;		E int
0000000000000000000000000000000000000000;;	}
