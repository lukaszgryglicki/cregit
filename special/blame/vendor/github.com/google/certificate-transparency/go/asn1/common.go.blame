0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	package asn1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASN.1 objects have metadata preceding them:
0000000000000000000000000000000000000000;;	//   the tag: the type of the object
0000000000000000000000000000000000000000;;	//   a flag denoting if this object is compound or not
0000000000000000000000000000000000000000;;	//   the class type: the namespace of the tag
0000000000000000000000000000000000000000;;	//   the length of the object, in bytes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Here are some standard tags and classes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		tagBoolean         = 1
0000000000000000000000000000000000000000;;		tagInteger         = 2
0000000000000000000000000000000000000000;;		tagBitString       = 3
0000000000000000000000000000000000000000;;		tagOctetString     = 4
0000000000000000000000000000000000000000;;		tagOID             = 6
0000000000000000000000000000000000000000;;		tagEnum            = 10
0000000000000000000000000000000000000000;;		tagUTF8String      = 12
0000000000000000000000000000000000000000;;		tagSequence        = 16
0000000000000000000000000000000000000000;;		tagSet             = 17
0000000000000000000000000000000000000000;;		tagPrintableString = 19
0000000000000000000000000000000000000000;;		tagT61String       = 20
0000000000000000000000000000000000000000;;		tagIA5String       = 22
0000000000000000000000000000000000000000;;		tagUTCTime         = 23
0000000000000000000000000000000000000000;;		tagGeneralizedTime = 24
0000000000000000000000000000000000000000;;		tagGeneralString   = 27
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		classUniversal       = 0
0000000000000000000000000000000000000000;;		classApplication     = 1
0000000000000000000000000000000000000000;;		classContextSpecific = 2
0000000000000000000000000000000000000000;;		classPrivate         = 3
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tagAndLength struct {
0000000000000000000000000000000000000000;;		class, tag, length int
0000000000000000000000000000000000000000;;		isCompound         bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASN.1 has IMPLICIT and EXPLICIT tags, which can be translated as "instead
0000000000000000000000000000000000000000;;	// of" and "in addition to". When not specified, every primitive type has a
0000000000000000000000000000000000000000;;	// default tag in the UNIVERSAL class.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example: a BIT STRING is tagged [UNIVERSAL 3] by default (although ASN.1
0000000000000000000000000000000000000000;;	// doesn't actually have a UNIVERSAL keyword). However, by saying [IMPLICIT
0000000000000000000000000000000000000000;;	// CONTEXT-SPECIFIC 42], that means that the tag is replaced by another.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// On the other hand, if it said [EXPLICIT CONTEXT-SPECIFIC 10], then an
0000000000000000000000000000000000000000;;	// /additional/ tag would wrap the default tag. This explicit tag will have the
0000000000000000000000000000000000000000;;	// compound flag set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// (This is used in order to remove ambiguity with optional elements.)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// You can layer EXPLICIT and IMPLICIT tags to an arbitrary depth, however we
0000000000000000000000000000000000000000;;	// don't support that here. We support a single layer of EXPLICIT or IMPLICIT
0000000000000000000000000000000000000000;;	// tagging with tag strings on the fields of a structure.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fieldParameters is the parsed representation of tag string from a structure field.
0000000000000000000000000000000000000000;;	type fieldParameters struct {
0000000000000000000000000000000000000000;;		optional     bool   // true iff the field is OPTIONAL
0000000000000000000000000000000000000000;;		explicit     bool   // true iff an EXPLICIT tag is in use.
0000000000000000000000000000000000000000;;		application  bool   // true iff an APPLICATION tag is in use.
0000000000000000000000000000000000000000;;		defaultValue *int64 // a default value for INTEGER typed fields (maybe nil).
0000000000000000000000000000000000000000;;		tag          *int   // the EXPLICIT or IMPLICIT tag (maybe nil).
0000000000000000000000000000000000000000;;		stringType   int    // the string tag to use when marshaling.
0000000000000000000000000000000000000000;;		set          bool   // true iff this should be encoded as a SET
0000000000000000000000000000000000000000;;		omitEmpty    bool   // true iff this should be omitted if empty when marshaling.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Invariants:
0000000000000000000000000000000000000000;;		//   if explicit is set, tag is non-nil.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Given a tag string with the format specified in the package comment,
0000000000000000000000000000000000000000;;	// parseFieldParameters will parse it into a fieldParameters structure,
0000000000000000000000000000000000000000;;	// ignoring unknown parts of the string.
0000000000000000000000000000000000000000;;	func parseFieldParameters(str string) (ret fieldParameters) {
0000000000000000000000000000000000000000;;		for _, part := range strings.Split(str, ",") {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case part == "optional":
0000000000000000000000000000000000000000;;				ret.optional = true
0000000000000000000000000000000000000000;;			case part == "explicit":
0000000000000000000000000000000000000000;;				ret.explicit = true
0000000000000000000000000000000000000000;;				if ret.tag == nil {
0000000000000000000000000000000000000000;;					ret.tag = new(int)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case part == "ia5":
0000000000000000000000000000000000000000;;				ret.stringType = tagIA5String
0000000000000000000000000000000000000000;;			case part == "printable":
0000000000000000000000000000000000000000;;				ret.stringType = tagPrintableString
0000000000000000000000000000000000000000;;			case part == "utf8":
0000000000000000000000000000000000000000;;				ret.stringType = tagUTF8String
0000000000000000000000000000000000000000;;			case strings.HasPrefix(part, "default:"):
0000000000000000000000000000000000000000;;				i, err := strconv.ParseInt(part[8:], 10, 64)
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					ret.defaultValue = new(int64)
0000000000000000000000000000000000000000;;					*ret.defaultValue = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case strings.HasPrefix(part, "tag:"):
0000000000000000000000000000000000000000;;				i, err := strconv.Atoi(part[4:])
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					ret.tag = new(int)
0000000000000000000000000000000000000000;;					*ret.tag = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case part == "set":
0000000000000000000000000000000000000000;;				ret.set = true
0000000000000000000000000000000000000000;;			case part == "application":
0000000000000000000000000000000000000000;;				ret.application = true
0000000000000000000000000000000000000000;;				if ret.tag == nil {
0000000000000000000000000000000000000000;;					ret.tag = new(int)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case part == "omitempty":
0000000000000000000000000000000000000000;;				ret.omitEmpty = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Given a reflected Go type, getUniversalType returns the default tag number
0000000000000000000000000000000000000000;;	// and expected compound flag.
0000000000000000000000000000000000000000;;	func getUniversalType(t reflect.Type) (tagNumber int, isCompound, ok bool) {
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case objectIdentifierType:
0000000000000000000000000000000000000000;;			return tagOID, false, true
0000000000000000000000000000000000000000;;		case bitStringType:
0000000000000000000000000000000000000000;;			return tagBitString, false, true
0000000000000000000000000000000000000000;;		case timeType:
0000000000000000000000000000000000000000;;			return tagUTCTime, false, true
0000000000000000000000000000000000000000;;		case enumeratedType:
0000000000000000000000000000000000000000;;			return tagEnum, false, true
0000000000000000000000000000000000000000;;		case bigIntType:
0000000000000000000000000000000000000000;;			return tagInteger, false, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return tagBoolean, false, true
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return tagInteger, false, true
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return tagSequence, true, true
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if t.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				return tagOctetString, false, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if strings.HasSuffix(t.Name(), "SET") {
0000000000000000000000000000000000000000;;				return tagSet, true, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return tagSequence, true, true
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return tagPrintableString, false, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false, false
0000000000000000000000000000000000000000;;	}
