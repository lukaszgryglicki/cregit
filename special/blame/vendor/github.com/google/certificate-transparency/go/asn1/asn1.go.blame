0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	// Package asn1 implements parsing of DER-encoded ASN.1 data structures,
0000000000000000000000000000000000000000;;	// as defined in ITU-T Rec X.690.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See also ``A Layman's Guide to a Subset of ASN.1, BER, and DER,''
0000000000000000000000000000000000000000;;	// http://luca.ntop.org/Teaching/Appunti/asn1.html.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// START CT CHANGES
0000000000000000000000000000000000000000;;	// This is a fork of the Go standard library ASN.1 implementation
0000000000000000000000000000000000000000;;	// (encoding/asn1).  The main difference is that this version tries to correct
0000000000000000000000000000000000000000;;	// for errors (e.g. use of tagPrintableString when the string data is really
0000000000000000000000000000000000000000;;	// ISO8859-1 - a common error present in many x509 certificates in the wild.)
0000000000000000000000000000000000000000;;	// END CT CHANGES
0000000000000000000000000000000000000000;;	package asn1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ASN.1 is a syntax for specifying abstract objects and BER, DER, PER, XER etc
0000000000000000000000000000000000000000;;	// are different encoding formats for those objects. Here, we'll be dealing
0000000000000000000000000000000000000000;;	// with DER, the Distinguished Encoding Rules. DER is used in X.509 because
0000000000000000000000000000000000000000;;	// it's fast to parse and, unlike BER, has a unique encoding for every object.
0000000000000000000000000000000000000000;;	// When calculating hashes over objects, it's important that the resulting
0000000000000000000000000000000000000000;;	// bytes be the same at both ends and DER removes this margin of error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ASN.1 is very complex and this package doesn't attempt to implement
0000000000000000000000000000000000000000;;	// everything by any means.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		// START CT CHANGES
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		// END CT CHANGES
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A StructuralError suggests that the ASN.1 data is valid, but the Go type
0000000000000000000000000000000000000000;;	// which is receiving it doesn't match.
0000000000000000000000000000000000000000;;	type StructuralError struct {
0000000000000000000000000000000000000000;;		Msg string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e StructuralError) Error() string { return "asn1: structure error: " + e.Msg }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A SyntaxError suggests that the ASN.1 data is invalid.
0000000000000000000000000000000000000000;;	type SyntaxError struct {
0000000000000000000000000000000000000000;;		Msg string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e SyntaxError) Error() string { return "asn1: syntax error: " + e.Msg }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// We start by dealing with each of the primitive types in turn.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BOOLEAN
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseBool(bytes []byte) (ret bool, err error) {
0000000000000000000000000000000000000000;;		if len(bytes) != 1 {
0000000000000000000000000000000000000000;;			err = SyntaxError{"invalid boolean"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DER demands that "If the encoding represents the boolean value TRUE,
0000000000000000000000000000000000000000;;		// its single contents octet shall have all eight bits set to one."
0000000000000000000000000000000000000000;;		// Thus only 0 and 255 are valid encoded values.
0000000000000000000000000000000000000000;;		switch bytes[0] {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			ret = false
0000000000000000000000000000000000000000;;		case 0xff:
0000000000000000000000000000000000000000;;			ret = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = SyntaxError{"invalid boolean"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// INTEGER
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseInt64 treats the given bytes as a big-endian, signed integer and
0000000000000000000000000000000000000000;;	// returns the result.
0000000000000000000000000000000000000000;;	func parseInt64(bytes []byte) (ret int64, err error) {
0000000000000000000000000000000000000000;;		if len(bytes) > 8 {
0000000000000000000000000000000000000000;;			// We'll overflow an int64 in this case.
0000000000000000000000000000000000000000;;			err = StructuralError{"integer too large"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for bytesRead := 0; bytesRead < len(bytes); bytesRead++ {
0000000000000000000000000000000000000000;;			ret <<= 8
0000000000000000000000000000000000000000;;			ret |= int64(bytes[bytesRead])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Shift up and down in order to sign extend the result.
0000000000000000000000000000000000000000;;		ret <<= 64 - uint8(len(bytes))*8
0000000000000000000000000000000000000000;;		ret >>= 64 - uint8(len(bytes))*8
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseInt treats the given bytes as a big-endian, signed integer and returns
0000000000000000000000000000000000000000;;	// the result.
0000000000000000000000000000000000000000;;	func parseInt32(bytes []byte) (int32, error) {
0000000000000000000000000000000000000000;;		ret64, err := parseInt64(bytes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ret64 != int64(int32(ret64)) {
0000000000000000000000000000000000000000;;			return 0, StructuralError{"integer too large"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int32(ret64), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var bigOne = big.NewInt(1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseBigInt treats the given bytes as a big-endian, signed integer and returns
0000000000000000000000000000000000000000;;	// the result.
0000000000000000000000000000000000000000;;	func parseBigInt(bytes []byte) *big.Int {
0000000000000000000000000000000000000000;;		ret := new(big.Int)
0000000000000000000000000000000000000000;;		if len(bytes) > 0 && bytes[0]&0x80 == 0x80 {
0000000000000000000000000000000000000000;;			// This is a negative number.
0000000000000000000000000000000000000000;;			notBytes := make([]byte, len(bytes))
0000000000000000000000000000000000000000;;			for i := range notBytes {
0000000000000000000000000000000000000000;;				notBytes[i] = ^bytes[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret.SetBytes(notBytes)
0000000000000000000000000000000000000000;;			ret.Add(ret, bigOne)
0000000000000000000000000000000000000000;;			ret.Neg(ret)
0000000000000000000000000000000000000000;;			return ret
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret.SetBytes(bytes)
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BIT STRING
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BitString is the structure to use when you want an ASN.1 BIT STRING type. A
0000000000000000000000000000000000000000;;	// bit string is padded up to the nearest byte in memory and the number of
0000000000000000000000000000000000000000;;	// valid bits is recorded. Padding bits will be zero.
0000000000000000000000000000000000000000;;	type BitString struct {
0000000000000000000000000000000000000000;;		Bytes     []byte // bits packed into bytes.
0000000000000000000000000000000000000000;;		BitLength int    // length in bits.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// At returns the bit at the given index. If the index is out of range it
0000000000000000000000000000000000000000;;	// returns false.
0000000000000000000000000000000000000000;;	func (b BitString) At(i int) int {
0000000000000000000000000000000000000000;;		if i < 0 || i >= b.BitLength {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		x := i / 8
0000000000000000000000000000000000000000;;		y := 7 - uint(i%8)
0000000000000000000000000000000000000000;;		return int(b.Bytes[x]>>y) & 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RightAlign returns a slice where the padding bits are at the beginning. The
0000000000000000000000000000000000000000;;	// slice may share memory with the BitString.
0000000000000000000000000000000000000000;;	func (b BitString) RightAlign() []byte {
0000000000000000000000000000000000000000;;		shift := uint(8 - (b.BitLength % 8))
0000000000000000000000000000000000000000;;		if shift == 8 || len(b.Bytes) == 0 {
0000000000000000000000000000000000000000;;			return b.Bytes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		a := make([]byte, len(b.Bytes))
0000000000000000000000000000000000000000;;		a[0] = b.Bytes[0] >> shift
0000000000000000000000000000000000000000;;		for i := 1; i < len(b.Bytes); i++ {
0000000000000000000000000000000000000000;;			a[i] = b.Bytes[i-1] << (8 - shift)
0000000000000000000000000000000000000000;;			a[i] |= b.Bytes[i] >> shift
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseBitString parses an ASN.1 bit string from the given byte slice and returns it.
0000000000000000000000000000000000000000;;	func parseBitString(bytes []byte) (ret BitString, err error) {
0000000000000000000000000000000000000000;;		if len(bytes) == 0 {
0000000000000000000000000000000000000000;;			err = SyntaxError{"zero length BIT STRING"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		paddingBits := int(bytes[0])
0000000000000000000000000000000000000000;;		if paddingBits > 7 ||
0000000000000000000000000000000000000000;;			len(bytes) == 1 && paddingBits > 0 ||
0000000000000000000000000000000000000000;;			bytes[len(bytes)-1]&((1<<bytes[0])-1) != 0 {
0000000000000000000000000000000000000000;;			err = SyntaxError{"invalid padding bits in BIT STRING"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret.BitLength = (len(bytes)-1)*8 - paddingBits
0000000000000000000000000000000000000000;;		ret.Bytes = bytes[1:]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OBJECT IDENTIFIER
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An ObjectIdentifier represents an ASN.1 OBJECT IDENTIFIER.
0000000000000000000000000000000000000000;;	type ObjectIdentifier []int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal reports whether oi and other represent the same identifier.
0000000000000000000000000000000000000000;;	func (oi ObjectIdentifier) Equal(other ObjectIdentifier) bool {
0000000000000000000000000000000000000000;;		if len(oi) != len(other) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(oi); i++ {
0000000000000000000000000000000000000000;;			if oi[i] != other[i] {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseObjectIdentifier parses an OBJECT IDENTIFIER from the given bytes and
0000000000000000000000000000000000000000;;	// returns it. An object identifier is a sequence of variable length integers
0000000000000000000000000000000000000000;;	// that are assigned in a hierarchy.
0000000000000000000000000000000000000000;;	func parseObjectIdentifier(bytes []byte) (s []int, err error) {
0000000000000000000000000000000000000000;;		if len(bytes) == 0 {
0000000000000000000000000000000000000000;;			err = SyntaxError{"zero length OBJECT IDENTIFIER"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// In the worst case, we get two elements from the first byte (which is
0000000000000000000000000000000000000000;;		// encoded differently) and then every varint is a single byte long.
0000000000000000000000000000000000000000;;		s = make([]int, len(bytes)+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The first varint is 40*value1 + value2:
0000000000000000000000000000000000000000;;		// According to this packing, value1 can take the values 0, 1 and 2 only.
0000000000000000000000000000000000000000;;		// When value1 = 0 or value1 = 1, then value2 is <= 39. When value1 = 2,
0000000000000000000000000000000000000000;;		// then there are no restrictions on value2.
0000000000000000000000000000000000000000;;		v, offset, err := parseBase128Int(bytes, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v < 80 {
0000000000000000000000000000000000000000;;			s[0] = v / 40
0000000000000000000000000000000000000000;;			s[1] = v % 40
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s[0] = 2
0000000000000000000000000000000000000000;;			s[1] = v - 80
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 2
0000000000000000000000000000000000000000;;		for ; offset < len(bytes); i++ {
0000000000000000000000000000000000000000;;			v, offset, err = parseBase128Int(bytes, offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s[i] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = s[0:i]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ENUMERATED
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An Enumerated is represented as a plain int.
0000000000000000000000000000000000000000;;	type Enumerated int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FLAG
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Flag accepts any data and is set to true if present.
0000000000000000000000000000000000000000;;	type Flag bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseBase128Int parses a base-128 encoded int from the given offset in the
0000000000000000000000000000000000000000;;	// given byte slice. It returns the value and the new offset.
0000000000000000000000000000000000000000;;	func parseBase128Int(bytes []byte, initOffset int) (ret, offset int, err error) {
0000000000000000000000000000000000000000;;		offset = initOffset
0000000000000000000000000000000000000000;;		for shifted := 0; offset < len(bytes); shifted++ {
0000000000000000000000000000000000000000;;			if shifted > 4 {
0000000000000000000000000000000000000000;;				err = StructuralError{"base 128 integer too large"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret <<= 7
0000000000000000000000000000000000000000;;			b := bytes[offset]
0000000000000000000000000000000000000000;;			ret |= int(b & 0x7f)
0000000000000000000000000000000000000000;;			offset++
0000000000000000000000000000000000000000;;			if b&0x80 == 0 {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = SyntaxError{"truncated base 128 integer"}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTCTime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseUTCTime(bytes []byte) (ret time.Time, err error) {
0000000000000000000000000000000000000000;;		s := string(bytes)
0000000000000000000000000000000000000000;;		ret, err = time.Parse("0601021504Z0700", s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			ret, err = time.Parse("060102150405Z0700", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == nil && ret.Year() >= 2050 {
0000000000000000000000000000000000000000;;			// UTCTime only encodes times prior to 2050. See https://tools.ietf.org/html/rfc5280#section-4.1.2.5.1
0000000000000000000000000000000000000000;;			ret = ret.AddDate(-100, 0, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseGeneralizedTime parses the GeneralizedTime from the given byte slice
0000000000000000000000000000000000000000;;	// and returns the resulting time.
0000000000000000000000000000000000000000;;	func parseGeneralizedTime(bytes []byte) (ret time.Time, err error) {
0000000000000000000000000000000000000000;;		return time.Parse("20060102150405Z0700", string(bytes))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrintableString
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parsePrintableString parses a ASN.1 PrintableString from the given byte
0000000000000000000000000000000000000000;;	// array and returns it.
0000000000000000000000000000000000000000;;	func parsePrintableString(bytes []byte) (ret string, err error) {
0000000000000000000000000000000000000000;;		for _, b := range bytes {
0000000000000000000000000000000000000000;;			if !isPrintable(b) {
0000000000000000000000000000000000000000;;				err = SyntaxError{"PrintableString contains invalid character"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret = string(bytes)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isPrintable returns true iff the given b is in the ASN.1 PrintableString set.
0000000000000000000000000000000000000000;;	func isPrintable(b byte) bool {
0000000000000000000000000000000000000000;;		return 'a' <= b && b <= 'z' ||
0000000000000000000000000000000000000000;;			'A' <= b && b <= 'Z' ||
0000000000000000000000000000000000000000;;			'0' <= b && b <= '9' ||
0000000000000000000000000000000000000000;;			'\'' <= b && b <= ')' ||
0000000000000000000000000000000000000000;;			'+' <= b && b <= '/' ||
0000000000000000000000000000000000000000;;			b == ' ' ||
0000000000000000000000000000000000000000;;			b == ':' ||
0000000000000000000000000000000000000000;;			b == '=' ||
0000000000000000000000000000000000000000;;			b == '?' ||
0000000000000000000000000000000000000000;;			// This is technically not allowed in a PrintableString.
0000000000000000000000000000000000000000;;			// However, x509 certificates with wildcard strings don't
0000000000000000000000000000000000000000;;			// always use the correct string type so we permit it.
0000000000000000000000000000000000000000;;			b == '*'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IA5String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseIA5String parses a ASN.1 IA5String (ASCII string) from the given
0000000000000000000000000000000000000000;;	// byte slice and returns it.
0000000000000000000000000000000000000000;;	func parseIA5String(bytes []byte) (ret string, err error) {
0000000000000000000000000000000000000000;;		for _, b := range bytes {
0000000000000000000000000000000000000000;;			if b >= 0x80 {
0000000000000000000000000000000000000000;;				err = SyntaxError{"IA5String contains invalid character"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret = string(bytes)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// T61String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseT61String parses a ASN.1 T61String (8-bit clean string) from the given
0000000000000000000000000000000000000000;;	// byte slice and returns it.
0000000000000000000000000000000000000000;;	func parseT61String(bytes []byte) (ret string, err error) {
0000000000000000000000000000000000000000;;		return string(bytes), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UTF8String
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseUTF8String parses a ASN.1 UTF8String (raw UTF-8) from the given byte
0000000000000000000000000000000000000000;;	// array and returns it.
0000000000000000000000000000000000000000;;	func parseUTF8String(bytes []byte) (ret string, err error) {
0000000000000000000000000000000000000000;;		return string(bytes), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A RawValue represents an undecoded ASN.1 object.
0000000000000000000000000000000000000000;;	type RawValue struct {
0000000000000000000000000000000000000000;;		Class, Tag int
0000000000000000000000000000000000000000;;		IsCompound bool
0000000000000000000000000000000000000000;;		Bytes      []byte
0000000000000000000000000000000000000000;;		FullBytes  []byte // includes the tag and length
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RawContent is used to signal that the undecoded, DER data needs to be
0000000000000000000000000000000000000000;;	// preserved for a struct. To use it, the first field of the struct must have
0000000000000000000000000000000000000000;;	// this type. It's an error for any of the other fields to have this type.
0000000000000000000000000000000000000000;;	type RawContent []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tagging
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseTagAndLength parses an ASN.1 tag and length pair from the given offset
0000000000000000000000000000000000000000;;	// into a byte slice. It returns the parsed data and the new offset. SET and
0000000000000000000000000000000000000000;;	// SET OF (tag 17) are mapped to SEQUENCE and SEQUENCE OF (tag 16) since we
0000000000000000000000000000000000000000;;	// don't distinguish between ordered and unordered objects in this code.
0000000000000000000000000000000000000000;;	func parseTagAndLength(bytes []byte, initOffset int) (ret tagAndLength, offset int, err error) {
0000000000000000000000000000000000000000;;		offset = initOffset
0000000000000000000000000000000000000000;;		b := bytes[offset]
0000000000000000000000000000000000000000;;		offset++
0000000000000000000000000000000000000000;;		ret.class = int(b >> 6)
0000000000000000000000000000000000000000;;		ret.isCompound = b&0x20 == 0x20
0000000000000000000000000000000000000000;;		ret.tag = int(b & 0x1f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the bottom five bits are set, then the tag number is actually base 128
0000000000000000000000000000000000000000;;		// encoded afterwards
0000000000000000000000000000000000000000;;		if ret.tag == 0x1f {
0000000000000000000000000000000000000000;;			ret.tag, offset, err = parseBase128Int(bytes, offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if offset >= len(bytes) {
0000000000000000000000000000000000000000;;			err = SyntaxError{"truncated tag or length"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b = bytes[offset]
0000000000000000000000000000000000000000;;		offset++
0000000000000000000000000000000000000000;;		if b&0x80 == 0 {
0000000000000000000000000000000000000000;;			// The length is encoded in the bottom 7 bits.
0000000000000000000000000000000000000000;;			ret.length = int(b & 0x7f)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Bottom 7 bits give the number of length bytes to follow.
0000000000000000000000000000000000000000;;			numBytes := int(b & 0x7f)
0000000000000000000000000000000000000000;;			if numBytes == 0 {
0000000000000000000000000000000000000000;;				err = SyntaxError{"indefinite length found (not DER)"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ret.length = 0
0000000000000000000000000000000000000000;;			for i := 0; i < numBytes; i++ {
0000000000000000000000000000000000000000;;				if offset >= len(bytes) {
0000000000000000000000000000000000000000;;					err = SyntaxError{"truncated tag or length"}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				b = bytes[offset]
0000000000000000000000000000000000000000;;				offset++
0000000000000000000000000000000000000000;;				if ret.length >= 1<<23 {
0000000000000000000000000000000000000000;;					// We can't shift ret.length up without
0000000000000000000000000000000000000000;;					// overflowing.
0000000000000000000000000000000000000000;;					err = StructuralError{"length too large"}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ret.length <<= 8
0000000000000000000000000000000000000000;;				ret.length |= int(b)
0000000000000000000000000000000000000000;;				if ret.length == 0 {
0000000000000000000000000000000000000000;;					// DER requires that lengths be minimal.
0000000000000000000000000000000000000000;;					err = StructuralError{"superfluous leading zeros in length"}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseSequenceOf is used for SEQUENCE OF and SET OF values. It tries to parse
0000000000000000000000000000000000000000;;	// a number of ASN.1 values from the given byte slice and returns them as a
0000000000000000000000000000000000000000;;	// slice of Go values of the given type.
0000000000000000000000000000000000000000;;	func parseSequenceOf(bytes []byte, sliceType reflect.Type, elemType reflect.Type) (ret reflect.Value, err error) {
0000000000000000000000000000000000000000;;		expectedTag, compoundType, ok := getUniversalType(elemType)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			err = StructuralError{"unknown Go type for slice"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// First we iterate over the input and count the number of elements,
0000000000000000000000000000000000000000;;		// checking that the types are correct in each case.
0000000000000000000000000000000000000000;;		numElements := 0
0000000000000000000000000000000000000000;;		for offset := 0; offset < len(bytes); {
0000000000000000000000000000000000000000;;			var t tagAndLength
0000000000000000000000000000000000000000;;			t, offset, err = parseTagAndLength(bytes, offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We pretend that GENERAL STRINGs are PRINTABLE STRINGs so
0000000000000000000000000000000000000000;;			// that a sequence of them can be parsed into a []string.
0000000000000000000000000000000000000000;;			if t.tag == tagGeneralString {
0000000000000000000000000000000000000000;;				t.tag = tagPrintableString
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.class != classUniversal || t.isCompound != compoundType || t.tag != expectedTag {
0000000000000000000000000000000000000000;;				err = StructuralError{"sequence tag mismatch"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if invalidLength(offset, t.length, len(bytes)) {
0000000000000000000000000000000000000000;;				err = SyntaxError{"truncated sequence"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			offset += t.length
0000000000000000000000000000000000000000;;			numElements++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ret = reflect.MakeSlice(sliceType, numElements, numElements)
0000000000000000000000000000000000000000;;		params := fieldParameters{}
0000000000000000000000000000000000000000;;		offset := 0
0000000000000000000000000000000000000000;;		for i := 0; i < numElements; i++ {
0000000000000000000000000000000000000000;;			offset, err = parseField(ret.Index(i), bytes, offset, params)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		bitStringType        = reflect.TypeOf(BitString{})
0000000000000000000000000000000000000000;;		objectIdentifierType = reflect.TypeOf(ObjectIdentifier{})
0000000000000000000000000000000000000000;;		enumeratedType       = reflect.TypeOf(Enumerated(0))
0000000000000000000000000000000000000000;;		flagType             = reflect.TypeOf(Flag(false))
0000000000000000000000000000000000000000;;		timeType             = reflect.TypeOf(time.Time{})
0000000000000000000000000000000000000000;;		rawValueType         = reflect.TypeOf(RawValue{})
0000000000000000000000000000000000000000;;		rawContentsType      = reflect.TypeOf(RawContent(nil))
0000000000000000000000000000000000000000;;		bigIntType           = reflect.TypeOf(new(big.Int))
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// invalidLength returns true iff offset + length > sliceLength, or if the
0000000000000000000000000000000000000000;;	// addition would overflow.
0000000000000000000000000000000000000000;;	func invalidLength(offset, length, sliceLength int) bool {
0000000000000000000000000000000000000000;;		return offset+length < offset || offset+length > sliceLength
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// START CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tests whether the data in |bytes| would be a valid ISO8859-1 string.
0000000000000000000000000000000000000000;;	// Clearly, a sequence of bytes comprised solely of valid ISO8859-1
0000000000000000000000000000000000000000;;	// codepoints does not imply that the encoding MUST be ISO8859-1, rather that
0000000000000000000000000000000000000000;;	// you would not encounter an error trying to interpret the data as such.
0000000000000000000000000000000000000000;;	func couldBeISO8859_1(bytes []byte) bool {
0000000000000000000000000000000000000000;;		for _, b := range bytes {
0000000000000000000000000000000000000000;;			if b < 0x20 || (b >= 0x7F && b < 0xA0) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Checks whether the data in |bytes| would be a valid T.61 string.
0000000000000000000000000000000000000000;;	// Clearly, a sequence of bytes comprised solely of valid T.61
0000000000000000000000000000000000000000;;	// codepoints does not imply that the encoding MUST be T.61, rather that
0000000000000000000000000000000000000000;;	// you would not encounter an error trying to interpret the data as such.
0000000000000000000000000000000000000000;;	func couldBeT61(bytes []byte) bool {
0000000000000000000000000000000000000000;;		for _, b := range bytes {
0000000000000000000000000000000000000000;;			switch b {
0000000000000000000000000000000000000000;;			case 0x00:
0000000000000000000000000000000000000000;;				// Since we're guessing at (incorrect) encodings for a
0000000000000000000000000000000000000000;;				// PrintableString, we'll err on the side of caution and disallow
0000000000000000000000000000000000000000;;				// strings with a NUL in them, don't want to re-create a PayPal NUL
0000000000000000000000000000000000000000;;				// situation in monitors.
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case 0x23, 0x24, 0x5C, 0x5E, 0x60, 0x7B, 0x7D, 0x7E, 0xA5, 0xA6, 0xAC, 0xAD, 0xAE, 0xAF,
0000000000000000000000000000000000000000;;				0xB9, 0xBA, 0xC0, 0xC9, 0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9,
0000000000000000000000000000000000000000;;				0xDA, 0xDB, 0xDC, 0xDE, 0xDF, 0xE5, 0xFF:
0000000000000000000000000000000000000000;;				// These are all invalid code points in T.61, so it can't be a T.61 string.
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Converts the data in |bytes| to the equivalent UTF-8 string.
0000000000000000000000000000000000000000;;	func iso8859_1ToUTF8(bytes []byte) string {
0000000000000000000000000000000000000000;;		buf := make([]rune, len(bytes))
0000000000000000000000000000000000000000;;		for i, b := range bytes {
0000000000000000000000000000000000000000;;			buf[i] = rune(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// END CT CHANGES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseField is the main parsing function. Given a byte slice and an offset
0000000000000000000000000000000000000000;;	// into the array, it will try to parse a suitable ASN.1 value out and store it
0000000000000000000000000000000000000000;;	// in the given Value.
0000000000000000000000000000000000000000;;	func parseField(v reflect.Value, bytes []byte, initOffset int, params fieldParameters) (offset int, err error) {
0000000000000000000000000000000000000000;;		offset = initOffset
0000000000000000000000000000000000000000;;		fieldType := v.Type()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have run out of data, it may be that there are optional elements at the end.
0000000000000000000000000000000000000000;;		if offset == len(bytes) {
0000000000000000000000000000000000000000;;			if !setDefaultValue(v, params) {
0000000000000000000000000000000000000000;;				err = SyntaxError{"sequence truncated"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deal with raw values.
0000000000000000000000000000000000000000;;		if fieldType == rawValueType {
0000000000000000000000000000000000000000;;			var t tagAndLength
0000000000000000000000000000000000000000;;			t, offset, err = parseTagAndLength(bytes, offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if invalidLength(offset, t.length, len(bytes)) {
0000000000000000000000000000000000000000;;				err = SyntaxError{"data truncated"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			result := RawValue{t.class, t.tag, t.isCompound, bytes[offset : offset+t.length], bytes[initOffset : offset+t.length]}
0000000000000000000000000000000000000000;;			offset += t.length
0000000000000000000000000000000000000000;;			v.Set(reflect.ValueOf(result))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Deal with the ANY type.
0000000000000000000000000000000000000000;;		if ifaceType := fieldType; ifaceType.Kind() == reflect.Interface && ifaceType.NumMethod() == 0 {
0000000000000000000000000000000000000000;;			var t tagAndLength
0000000000000000000000000000000000000000;;			t, offset, err = parseTagAndLength(bytes, offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if invalidLength(offset, t.length, len(bytes)) {
0000000000000000000000000000000000000000;;				err = SyntaxError{"data truncated"}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var result interface{}
0000000000000000000000000000000000000000;;			if !t.isCompound && t.class == classUniversal {
0000000000000000000000000000000000000000;;				innerBytes := bytes[offset : offset+t.length]
0000000000000000000000000000000000000000;;				switch t.tag {
0000000000000000000000000000000000000000;;				case tagPrintableString:
0000000000000000000000000000000000000000;;					result, err = parsePrintableString(innerBytes)
0000000000000000000000000000000000000000;;					// START CT CHANGES
0000000000000000000000000000000000000000;;					if err != nil && strings.Contains(err.Error(), "PrintableString contains invalid character") {
0000000000000000000000000000000000000000;;						// Probably an ISO8859-1 string stuffed in, check if it
0000000000000000000000000000000000000000;;						// would be valid and assume that's what's happened if so,
0000000000000000000000000000000000000000;;						// otherwise try T.61, failing that give up and just assign
0000000000000000000000000000000000000000;;						// the bytes
0000000000000000000000000000000000000000;;						switch {
0000000000000000000000000000000000000000;;						case couldBeISO8859_1(innerBytes):
0000000000000000000000000000000000000000;;							result, err = iso8859_1ToUTF8(innerBytes), nil
0000000000000000000000000000000000000000;;						case couldBeT61(innerBytes):
0000000000000000000000000000000000000000;;							result, err = parseT61String(innerBytes)
0000000000000000000000000000000000000000;;						default:
0000000000000000000000000000000000000000;;							result = nil
0000000000000000000000000000000000000000;;							err = errors.New("PrintableString contains invalid character, but couldn't determine correct String type.")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// END CT CHANGES
0000000000000000000000000000000000000000;;				case tagIA5String:
0000000000000000000000000000000000000000;;					result, err = parseIA5String(innerBytes)
0000000000000000000000000000000000000000;;				case tagT61String:
0000000000000000000000000000000000000000;;					result, err = parseT61String(innerBytes)
0000000000000000000000000000000000000000;;				case tagUTF8String:
0000000000000000000000000000000000000000;;					result, err = parseUTF8String(innerBytes)
0000000000000000000000000000000000000000;;				case tagInteger:
0000000000000000000000000000000000000000;;					result, err = parseInt64(innerBytes)
0000000000000000000000000000000000000000;;				case tagBitString:
0000000000000000000000000000000000000000;;					result, err = parseBitString(innerBytes)
0000000000000000000000000000000000000000;;				case tagOID:
0000000000000000000000000000000000000000;;					result, err = parseObjectIdentifier(innerBytes)
0000000000000000000000000000000000000000;;				case tagUTCTime:
0000000000000000000000000000000000000000;;					result, err = parseUTCTime(innerBytes)
0000000000000000000000000000000000000000;;				case tagOctetString:
0000000000000000000000000000000000000000;;					result = innerBytes
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// If we don't know how to handle the type, we just leave Value as nil.
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			offset += t.length
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if result != nil {
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(result))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		universalTag, compoundType, ok1 := getUniversalType(fieldType)
0000000000000000000000000000000000000000;;		if !ok1 {
0000000000000000000000000000000000000000;;			err = StructuralError{fmt.Sprintf("unknown Go type: %v", fieldType)}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t, offset, err := parseTagAndLength(bytes, offset)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if params.explicit {
0000000000000000000000000000000000000000;;			expectedClass := classContextSpecific
0000000000000000000000000000000000000000;;			if params.application {
0000000000000000000000000000000000000000;;				expectedClass = classApplication
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.class == expectedClass && t.tag == *params.tag && (t.length == 0 || t.isCompound) {
0000000000000000000000000000000000000000;;				if t.length > 0 {
0000000000000000000000000000000000000000;;					t, offset, err = parseTagAndLength(bytes, offset)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if fieldType != flagType {
0000000000000000000000000000000000000000;;						err = StructuralError{"zero length explicit tag was not an asn1.Flag"}
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					v.SetBool(true)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// The tags didn't match, it might be an optional element.
0000000000000000000000000000000000000000;;				ok := setDefaultValue(v, params)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					offset = initOffset
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					err = StructuralError{"explicitly tagged member didn't match"}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Special case for strings: all the ASN.1 string types map to the Go
0000000000000000000000000000000000000000;;		// type string. getUniversalType returns the tag for PrintableString
0000000000000000000000000000000000000000;;		// when it sees a string, so if we see a different string type on the
0000000000000000000000000000000000000000;;		// wire, we change the universal type to match.
0000000000000000000000000000000000000000;;		if universalTag == tagPrintableString {
0000000000000000000000000000000000000000;;			switch t.tag {
0000000000000000000000000000000000000000;;			case tagIA5String, tagGeneralString, tagT61String, tagUTF8String:
0000000000000000000000000000000000000000;;				universalTag = t.tag
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Special case for time: UTCTime and GeneralizedTime both map to the
0000000000000000000000000000000000000000;;		// Go type time.Time.
0000000000000000000000000000000000000000;;		if universalTag == tagUTCTime && t.tag == tagGeneralizedTime {
0000000000000000000000000000000000000000;;			universalTag = tagGeneralizedTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedClass := classUniversal
0000000000000000000000000000000000000000;;		expectedTag := universalTag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !params.explicit && params.tag != nil {
0000000000000000000000000000000000000000;;			expectedClass = classContextSpecific
0000000000000000000000000000000000000000;;			expectedTag = *params.tag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !params.explicit && params.application && params.tag != nil {
0000000000000000000000000000000000000000;;			expectedClass = classApplication
0000000000000000000000000000000000000000;;			expectedTag = *params.tag
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We have unwrapped any explicit tagging at this point.
0000000000000000000000000000000000000000;;		if t.class != expectedClass || t.tag != expectedTag || t.isCompound != compoundType {
0000000000000000000000000000000000000000;;			// Tags don't match. Again, it could be an optional element.
0000000000000000000000000000000000000000;;			ok := setDefaultValue(v, params)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				offset = initOffset
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = StructuralError{fmt.Sprintf("tags don't match (%d vs %+v) %+v %s @%d", expectedTag, t, params, fieldType.Name(), offset)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if invalidLength(offset, t.length, len(bytes)) {
0000000000000000000000000000000000000000;;			err = SyntaxError{"data truncated"}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		innerBytes := bytes[offset : offset+t.length]
0000000000000000000000000000000000000000;;		offset += t.length
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We deal with the structures defined in this package first.
0000000000000000000000000000000000000000;;		switch fieldType {
0000000000000000000000000000000000000000;;		case objectIdentifierType:
0000000000000000000000000000000000000000;;			newSlice, err1 := parseObjectIdentifier(innerBytes)
0000000000000000000000000000000000000000;;			v.Set(reflect.MakeSlice(v.Type(), len(newSlice), len(newSlice)))
0000000000000000000000000000000000000000;;			if err1 == nil {
0000000000000000000000000000000000000000;;				reflect.Copy(v, reflect.ValueOf(newSlice))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case bitStringType:
0000000000000000000000000000000000000000;;			bs, err1 := parseBitString(innerBytes)
0000000000000000000000000000000000000000;;			if err1 == nil {
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(bs))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case timeType:
0000000000000000000000000000000000000000;;			var time time.Time
0000000000000000000000000000000000000000;;			var err1 error
0000000000000000000000000000000000000000;;			if universalTag == tagUTCTime {
0000000000000000000000000000000000000000;;				time, err1 = parseUTCTime(innerBytes)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				time, err1 = parseGeneralizedTime(innerBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err1 == nil {
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(time))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case enumeratedType:
0000000000000000000000000000000000000000;;			parsedInt, err1 := parseInt32(innerBytes)
0000000000000000000000000000000000000000;;			if err1 == nil {
0000000000000000000000000000000000000000;;				v.SetInt(int64(parsedInt))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case flagType:
0000000000000000000000000000000000000000;;			v.SetBool(true)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case bigIntType:
0000000000000000000000000000000000000000;;			parsedInt := parseBigInt(innerBytes)
0000000000000000000000000000000000000000;;			v.Set(reflect.ValueOf(parsedInt))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch val := v; val.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			parsedBool, err1 := parseBool(innerBytes)
0000000000000000000000000000000000000000;;			if err1 == nil {
0000000000000000000000000000000000000000;;				val.SetBool(parsedBool)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			if val.Type().Size() == 4 {
0000000000000000000000000000000000000000;;				parsedInt, err1 := parseInt32(innerBytes)
0000000000000000000000000000000000000000;;				if err1 == nil {
0000000000000000000000000000000000000000;;					val.SetInt(int64(parsedInt))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				parsedInt, err1 := parseInt64(innerBytes)
0000000000000000000000000000000000000000;;				if err1 == nil {
0000000000000000000000000000000000000000;;					val.SetInt(parsedInt)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		// TODO(dfc) Add support for the remaining integer types
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			structType := fieldType
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if structType.NumField() > 0 &&
0000000000000000000000000000000000000000;;				structType.Field(0).Type == rawContentsType {
0000000000000000000000000000000000000000;;				bytes := bytes[initOffset:offset]
0000000000000000000000000000000000000000;;				val.Field(0).Set(reflect.ValueOf(RawContent(bytes)))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			innerOffset := 0
0000000000000000000000000000000000000000;;			for i := 0; i < structType.NumField(); i++ {
0000000000000000000000000000000000000000;;				field := structType.Field(i)
0000000000000000000000000000000000000000;;				if i == 0 && field.Type == rawContentsType {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				innerOffset, err = parseField(val.Field(i), innerBytes, innerOffset, parseFieldParameters(field.Tag.Get("asn1")))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We allow extra bytes at the end of the SEQUENCE because
0000000000000000000000000000000000000000;;			// adding elements to the end has been used in X.509 as the
0000000000000000000000000000000000000000;;			// version numbers have increased.
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			sliceType := fieldType
0000000000000000000000000000000000000000;;			if sliceType.Elem().Kind() == reflect.Uint8 {
0000000000000000000000000000000000000000;;				val.Set(reflect.MakeSlice(sliceType, len(innerBytes), len(innerBytes)))
0000000000000000000000000000000000000000;;				reflect.Copy(val, reflect.ValueOf(innerBytes))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			newSlice, err1 := parseSequenceOf(innerBytes, sliceType, sliceType.Elem())
0000000000000000000000000000000000000000;;			if err1 == nil {
0000000000000000000000000000000000000000;;				val.Set(newSlice)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = err1
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			var v string
0000000000000000000000000000000000000000;;			switch universalTag {
0000000000000000000000000000000000000000;;			case tagPrintableString:
0000000000000000000000000000000000000000;;				v, err = parsePrintableString(innerBytes)
0000000000000000000000000000000000000000;;			case tagIA5String:
0000000000000000000000000000000000000000;;				v, err = parseIA5String(innerBytes)
0000000000000000000000000000000000000000;;			case tagT61String:
0000000000000000000000000000000000000000;;				v, err = parseT61String(innerBytes)
0000000000000000000000000000000000000000;;			case tagUTF8String:
0000000000000000000000000000000000000000;;				v, err = parseUTF8String(innerBytes)
0000000000000000000000000000000000000000;;			case tagGeneralString:
0000000000000000000000000000000000000000;;				// GeneralString is specified in ISO-2022/ECMA-35,
0000000000000000000000000000000000000000;;				// A brief review suggests that it includes structures
0000000000000000000000000000000000000000;;				// that allow the encoding to change midstring and
0000000000000000000000000000000000000000;;				// such. We give up and pass it as an 8-bit string.
0000000000000000000000000000000000000000;;				v, err = parseT61String(innerBytes)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				err = SyntaxError{fmt.Sprintf("internal error: unknown string type %d", universalTag)}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				val.SetString(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = StructuralError{"unsupported: " + v.Type().String()}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setDefaultValue is used to install a default value, from a tag string, into
0000000000000000000000000000000000000000;;	// a Value. It is successful is the field was optional, even if a default value
0000000000000000000000000000000000000000;;	// wasn't provided or it failed to install it into the Value.
0000000000000000000000000000000000000000;;	func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {
0000000000000000000000000000000000000000;;		if !params.optional {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok = true
0000000000000000000000000000000000000000;;		if params.defaultValue == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch val := v; val.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			val.SetInt(*params.defaultValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal parses the DER-encoded ASN.1 data structure b
0000000000000000000000000000000000000000;;	// and uses the reflect package to fill in an arbitrary value pointed at by val.
0000000000000000000000000000000000000000;;	// Because Unmarshal uses the reflect package, the structs
0000000000000000000000000000000000000000;;	// being written to must use upper case field names.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 INTEGER can be written to an int, int32, int64,
0000000000000000000000000000000000000000;;	// or *big.Int (from the math/big package).
0000000000000000000000000000000000000000;;	// If the encoded value does not fit in the Go type,
0000000000000000000000000000000000000000;;	// Unmarshal returns a parse error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 BIT STRING can be written to a BitString.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 OCTET STRING can be written to a []byte.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 OBJECT IDENTIFIER can be written to an
0000000000000000000000000000000000000000;;	// ObjectIdentifier.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 ENUMERATED can be written to an Enumerated.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 PrintableString or IA5String can be written to a string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Any of the above ASN.1 values can be written to an interface{}.
0000000000000000000000000000000000000000;;	// The value stored in the interface has the corresponding Go type.
0000000000000000000000000000000000000000;;	// For integers, that type is int64.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 SEQUENCE OF x or SET OF x can be written
0000000000000000000000000000000000000000;;	// to a slice if an x can be written to the slice's element type.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An ASN.1 SEQUENCE or SET can be written to a struct
0000000000000000000000000000000000000000;;	// if each of the elements in the sequence can be
0000000000000000000000000000000000000000;;	// written to the corresponding element in the struct.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following tags on struct fields have special meaning to Unmarshal:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	optional		marks the field as ASN.1 OPTIONAL
0000000000000000000000000000000000000000;;	//	[explicit] tag:x	specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC
0000000000000000000000000000000000000000;;	//	default:x		sets the default value for optional integer fields
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the type of the first field of a structure is RawContent then the raw
0000000000000000000000000000000000000000;;	// ASN1 contents of the struct will be stored in it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Other ASN.1 types are not supported; if it encounters them,
0000000000000000000000000000000000000000;;	// Unmarshal returns a parse error.
0000000000000000000000000000000000000000;;	func Unmarshal(b []byte, val interface{}) (rest []byte, err error) {
0000000000000000000000000000000000000000;;		return UnmarshalWithParams(b, val, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalWithParams allows field parameters to be specified for the
0000000000000000000000000000000000000000;;	// top-level element. The form of the params is the same as the field tags.
0000000000000000000000000000000000000000;;	func UnmarshalWithParams(b []byte, val interface{}, params string) (rest []byte, err error) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(val).Elem()
0000000000000000000000000000000000000000;;		offset, err := parseField(v, b, 0, parseFieldParameters(params))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b[offset:], nil
0000000000000000000000000000000000000000;;	}
