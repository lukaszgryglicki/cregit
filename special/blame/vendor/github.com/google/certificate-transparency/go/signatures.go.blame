0000000000000000000000000000000000000000;;	package ct
4719f97477417ada91b80cafeecea0dd05c6fdd6;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"encoding/pem"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"flag"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var allowVerificationWithNonCompliantKeys = flag.Bool("allow_verification_with_non_compliant_keys", false,
0000000000000000000000000000000000000000;;		"Allow a SignatureVerifier to use keys which are technically non-compliant with RFC6962.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PublicKeyFromPEM parses a PEM formatted block and returns the public key contained within and any remaining unread bytes, or an error.
0000000000000000000000000000000000000000;;	func PublicKeyFromPEM(b []byte) (crypto.PublicKey, SHA256Hash, []byte, error) {
0000000000000000000000000000000000000000;;		p, rest := pem.Decode(b)
0000000000000000000000000000000000000000;;		if p == nil {
0000000000000000000000000000000000000000;;			return nil, [sha256.Size]byte{}, rest, fmt.Errorf("no PEM block found in %s", string(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		k, err := x509.ParsePKIXPublicKey(p.Bytes)
0000000000000000000000000000000000000000;;		return k, sha256.Sum256(p.Bytes), rest, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SignatureVerifier can verify signatures on SCTs and STHs
0000000000000000000000000000000000000000;;	type SignatureVerifier struct {
0000000000000000000000000000000000000000;;		pubKey crypto.PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSignatureVerifier creates a new SignatureVerifier using the passed in PublicKey.
0000000000000000000000000000000000000000;;	func NewSignatureVerifier(pk crypto.PublicKey) (*SignatureVerifier, error) {
0000000000000000000000000000000000000000;;		switch pkType := pk.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PublicKey:
0000000000000000000000000000000000000000;;			if pkType.N.BitLen() < 2048 {
0000000000000000000000000000000000000000;;				e := fmt.Errorf("public key is RSA with < 2048 bits (size:%d)", pkType.N.BitLen())
0000000000000000000000000000000000000000;;				if !(*allowVerificationWithNonCompliantKeys) {
0000000000000000000000000000000000000000;;					return nil, e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				log.Printf("WARNING: %v", e)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ecdsa.PublicKey:
0000000000000000000000000000000000000000;;			params := *(pkType.Params())
0000000000000000000000000000000000000000;;			if params != *elliptic.P256().Params() {
0000000000000000000000000000000000000000;;				e := fmt.Errorf("public is ECDSA, but not on the P256 curve")
0000000000000000000000000000000000000000;;				if !(*allowVerificationWithNonCompliantKeys) {
0000000000000000000000000000000000000000;;					return nil, e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				log.Printf("WARNING: %v", e)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unsupported public key type %v", pkType)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &SignatureVerifier{
0000000000000000000000000000000000000000;;			pubKey: pk,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verifySignature verifies that the passed in signature over data was created by our PublicKey.
0000000000000000000000000000000000000000;;	// Currently, only SHA256 is supported as a HashAlgorithm, and only ECDSA and RSA signatures are supported.
0000000000000000000000000000000000000000;;	func (s SignatureVerifier) verifySignature(data []byte, sig DigitallySigned) error {
0000000000000000000000000000000000000000;;		if sig.HashAlgorithm != SHA256 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported HashAlgorithm in signature: %v", sig.HashAlgorithm)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasherType := crypto.SHA256
0000000000000000000000000000000000000000;;		hasher := hasherType.New()
0000000000000000000000000000000000000000;;		if _, err := hasher.Write(data); err != nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("failed to write to hasher: %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := hasher.Sum([]byte{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch sig.SignatureAlgorithm {
0000000000000000000000000000000000000000;;		case RSA:
0000000000000000000000000000000000000000;;			rsaKey, ok := s.pubKey.(*rsa.PublicKey)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot verify RSA signature with %T key", s.pubKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := rsa.VerifyPKCS1v15(rsaKey, hasherType, hash, sig.Signature); err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to verify rsa signature: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ECDSA:
0000000000000000000000000000000000000000;;			ecdsaKey, ok := s.pubKey.(*ecdsa.PublicKey)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return fmt.Errorf("cannot verify ECDSA signature with %T key", s.pubKey)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var ecdsaSig struct {
0000000000000000000000000000000000000000;;				R, S *big.Int
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rest, err := asn1.Unmarshal(sig.Signature, &ecdsaSig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return fmt.Errorf("failed to unmarshal ECDSA signature: %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(rest) != 0 {
0000000000000000000000000000000000000000;;				log.Printf("Garbage following signature %v", rest)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !ecdsa.Verify(ecdsaKey, hash, ecdsaSig.R, ecdsaSig.S) {
0000000000000000000000000000000000000000;;				return errors.New("failed to verify ecdsa signature")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("unsupported signature type %v", sig.SignatureAlgorithm)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifySCTSignature verifies that the SCT's signature is valid for the given LogEntry
0000000000000000000000000000000000000000;;	func (s SignatureVerifier) VerifySCTSignature(sct SignedCertificateTimestamp, entry LogEntry) error {
0000000000000000000000000000000000000000;;		sctData, err := SerializeSCTSignatureInput(sct, entry)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.verifySignature(sctData, sct.Signature)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VerifySTHSignature verifies that the STH's signature is valid.
0000000000000000000000000000000000000000;;	func (s SignatureVerifier) VerifySTHSignature(sth SignedTreeHead) error {
0000000000000000000000000000000000000000;;		sthData, err := SerializeSTHSignatureInput(sth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.verifySignature(sthData, sth.TreeHeadSignature)
0000000000000000000000000000000000000000;;	}
