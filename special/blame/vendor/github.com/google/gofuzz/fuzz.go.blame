0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Copyright 2014 Google Inc. All rights reserved.
11ce82f07aace6e268f7eda235779fc16a281c0a;third_party/src/github.com/google/gofuzz/fuzz.go[third_party/src/github.com/google/gofuzz/fuzz.go][vendor/github.com/google/gofuzz/fuzz.go];	
0000000000000000000000000000000000000000;;	Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	limitations under the License.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package fuzz
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fuzzFuncMap is a map from a type to a fuzzFunc that handles that type.
0000000000000000000000000000000000000000;;	type fuzzFuncMap map[reflect.Type]reflect.Value
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fuzzer knows how to fill any object with random fields.
0000000000000000000000000000000000000000;;	type Fuzzer struct {
0000000000000000000000000000000000000000;;		fuzzFuncs        fuzzFuncMap
0000000000000000000000000000000000000000;;		defaultFuzzFuncs fuzzFuncMap
0000000000000000000000000000000000000000;;		r                *rand.Rand
0000000000000000000000000000000000000000;;		nilChance        float64
0000000000000000000000000000000000000000;;		minElements      int
0000000000000000000000000000000000000000;;		maxElements      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns a new Fuzzer. Customize your Fuzzer further by calling Funcs,
0000000000000000000000000000000000000000;;	// RandSource, NilChance, or NumElements in any order.
0000000000000000000000000000000000000000;;	func New() *Fuzzer {
0000000000000000000000000000000000000000;;		f := &Fuzzer{
0000000000000000000000000000000000000000;;			defaultFuzzFuncs: fuzzFuncMap{
0000000000000000000000000000000000000000;;				reflect.TypeOf(&time.Time{}): reflect.ValueOf(fuzzTime),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fuzzFuncs:   fuzzFuncMap{},
0000000000000000000000000000000000000000;;			r:           rand.New(rand.NewSource(time.Now().UnixNano())),
0000000000000000000000000000000000000000;;			nilChance:   .2,
0000000000000000000000000000000000000000;;			minElements: 1,
0000000000000000000000000000000000000000;;			maxElements: 10,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Funcs adds each entry in fuzzFuncs as a custom fuzzing function.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each entry in fuzzFuncs must be a function taking two parameters.
0000000000000000000000000000000000000000;;	// The first parameter must be a pointer or map. It is the variable that
0000000000000000000000000000000000000000;;	// function will fill with random data. The second parameter must be a
0000000000000000000000000000000000000000;;	// fuzz.Continue, which will provide a source of randomness and a way
0000000000000000000000000000000000000000;;	// to automatically continue fuzzing smaller pieces of the first parameter.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// These functions are called sensibly, e.g., if you wanted custom string
0000000000000000000000000000000000000000;;	// fuzzing, the function `func(s *string, c fuzz.Continue)` would get
0000000000000000000000000000000000000000;;	// called and passed the address of strings. Maps and pointers will always
0000000000000000000000000000000000000000;;	// be made/new'd for you, ignoring the NilChange option. For slices, it
0000000000000000000000000000000000000000;;	// doesn't make much sense to  pre-create them--Fuzzer doesn't know how
0000000000000000000000000000000000000000;;	// long you want your slice--so take a pointer to a slice, and make it
0000000000000000000000000000000000000000;;	// yourself. (If you don't want your map/pointer type pre-made, take a
0000000000000000000000000000000000000000;;	// pointer to it, and make it yourself.) See the examples for a range of
0000000000000000000000000000000000000000;;	// custom functions.
0000000000000000000000000000000000000000;;	func (f *Fuzzer) Funcs(fuzzFuncs ...interface{}) *Fuzzer {
0000000000000000000000000000000000000000;;		for i := range fuzzFuncs {
0000000000000000000000000000000000000000;;			v := reflect.ValueOf(fuzzFuncs[i])
0000000000000000000000000000000000000000;;			if v.Kind() != reflect.Func {
0000000000000000000000000000000000000000;;				panic("Need only funcs!")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t := v.Type()
0000000000000000000000000000000000000000;;			if t.NumIn() != 2 || t.NumOut() != 0 {
0000000000000000000000000000000000000000;;				panic("Need 2 in and 0 out params!")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			argT := t.In(0)
0000000000000000000000000000000000000000;;			switch argT.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Ptr, reflect.Map:
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic("fuzzFunc must take pointer or map type")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t.In(1) != reflect.TypeOf(Continue{}) {
0000000000000000000000000000000000000000;;				panic("fuzzFunc's second parameter must be type fuzz.Continue")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.fuzzFuncs[argT] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RandSource causes f to get values from the given source of randomness.
0000000000000000000000000000000000000000;;	// Use if you want deterministic fuzzing.
0000000000000000000000000000000000000000;;	func (f *Fuzzer) RandSource(s rand.Source) *Fuzzer {
0000000000000000000000000000000000000000;;		f.r = rand.New(s)
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NilChance sets the probability of creating a nil pointer, map, or slice to
0000000000000000000000000000000000000000;;	// 'p'. 'p' should be between 0 (no nils) and 1 (all nils), inclusive.
0000000000000000000000000000000000000000;;	func (f *Fuzzer) NilChance(p float64) *Fuzzer {
0000000000000000000000000000000000000000;;		if p < 0 || p > 1 {
0000000000000000000000000000000000000000;;			panic("p should be between 0 and 1, inclusive.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.nilChance = p
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NumElements sets the minimum and maximum number of elements that will be
0000000000000000000000000000000000000000;;	// added to a non-nil map or slice.
0000000000000000000000000000000000000000;;	func (f *Fuzzer) NumElements(atLeast, atMost int) *Fuzzer {
0000000000000000000000000000000000000000;;		if atLeast > atMost {
0000000000000000000000000000000000000000;;			panic("atLeast must be <= atMost")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if atLeast < 0 {
0000000000000000000000000000000000000000;;			panic("atLeast must be >= 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.minElements = atLeast
0000000000000000000000000000000000000000;;		f.maxElements = atMost
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Fuzzer) genElementCount() int {
0000000000000000000000000000000000000000;;		if f.minElements == f.maxElements {
0000000000000000000000000000000000000000;;			return f.minElements
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.minElements + f.r.Intn(f.maxElements-f.minElements+1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Fuzzer) genShouldFill() bool {
0000000000000000000000000000000000000000;;		return f.r.Float64() > f.nilChance
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fuzz recursively fills all of obj's fields with something random.  First
0000000000000000000000000000000000000000;;	// this tries to find a custom fuzz function (see Funcs).  If there is no
0000000000000000000000000000000000000000;;	// custom function this tests whether the object implements fuzz.Interface and,
0000000000000000000000000000000000000000;;	// if so, calls Fuzz on it to fuzz itself.  If that fails, this will see if
0000000000000000000000000000000000000000;;	// there is a default fuzz function provided by this package.  If all of that
0000000000000000000000000000000000000000;;	// fails, this will generate random values for all primitive fields and then
0000000000000000000000000000000000000000;;	// recurse for all non-primitives.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Not safe for cyclic or tree-like structs!
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// obj must be a pointer. Only exported (public) fields can be set (thanks, golang :/ )
0000000000000000000000000000000000000000;;	// Intended for tests, so will panic on bad input or unimplemented fields.
0000000000000000000000000000000000000000;;	func (f *Fuzzer) Fuzz(obj interface{}) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;		if v.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			panic("needed ptr!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = v.Elem()
0000000000000000000000000000000000000000;;		f.doFuzz(v, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FuzzNoCustom is just like Fuzz, except that any custom fuzz function for
0000000000000000000000000000000000000000;;	// obj's type will not be called and obj will not be tested for fuzz.Interface
0000000000000000000000000000000000000000;;	// conformance.  This applies only to obj and not other instances of obj's
0000000000000000000000000000000000000000;;	// type.
0000000000000000000000000000000000000000;;	// Not safe for cyclic or tree-like structs!
0000000000000000000000000000000000000000;;	// obj must be a pointer. Only exported (public) fields can be set (thanks, golang :/ )
0000000000000000000000000000000000000000;;	// Intended for tests, so will panic on bad input or unimplemented fields.
0000000000000000000000000000000000000000;;	func (f *Fuzzer) FuzzNoCustom(obj interface{}) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;		if v.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			panic("needed ptr!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = v.Elem()
0000000000000000000000000000000000000000;;		f.doFuzz(v, flagNoCustomFuzz)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Do not try to find a custom fuzz function.  Does not apply recursively.
0000000000000000000000000000000000000000;;		flagNoCustomFuzz uint64 = 1 << iota
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *Fuzzer) doFuzz(v reflect.Value, flags uint64) {
0000000000000000000000000000000000000000;;		if !v.CanSet() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flags&flagNoCustomFuzz == 0 {
0000000000000000000000000000000000000000;;			// Check for both pointer and non-pointer custom functions.
0000000000000000000000000000000000000000;;			if v.CanAddr() && f.tryCustom(v.Addr()) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if f.tryCustom(v) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fn, ok := fillFuncMap[v.Kind()]; ok {
0000000000000000000000000000000000000000;;			fn(v, f.r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if f.genShouldFill() {
0000000000000000000000000000000000000000;;				v.Set(reflect.MakeMap(v.Type()))
0000000000000000000000000000000000000000;;				n := f.genElementCount()
0000000000000000000000000000000000000000;;				for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;					key := reflect.New(v.Type().Key()).Elem()
0000000000000000000000000000000000000000;;					f.doFuzz(key, 0)
0000000000000000000000000000000000000000;;					val := reflect.New(v.Type().Elem()).Elem()
0000000000000000000000000000000000000000;;					f.doFuzz(val, 0)
0000000000000000000000000000000000000000;;					v.SetMapIndex(key, val)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if f.genShouldFill() {
0000000000000000000000000000000000000000;;				v.Set(reflect.New(v.Type().Elem()))
0000000000000000000000000000000000000000;;				f.doFuzz(v.Elem(), 0)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if f.genShouldFill() {
0000000000000000000000000000000000000000;;				n := f.genElementCount()
0000000000000000000000000000000000000000;;				v.Set(reflect.MakeSlice(v.Type(), n, n))
0000000000000000000000000000000000000000;;				for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;					f.doFuzz(v.Index(i), 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			if f.genShouldFill() {
0000000000000000000000000000000000000000;;				n := v.Len()
0000000000000000000000000000000000000000;;				for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;					f.doFuzz(v.Index(i), 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			v.Set(reflect.Zero(v.Type()))
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;				f.doFuzz(v.Field(i), 0)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Chan:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case reflect.Func:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("Can't handle %#v", v.Interface()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tryCustom searches for custom handlers, and returns true iff it finds a match
0000000000000000000000000000000000000000;;	// and successfully randomizes v.
0000000000000000000000000000000000000000;;	func (f *Fuzzer) tryCustom(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		// First: see if we have a fuzz function for it.
0000000000000000000000000000000000000000;;		doCustom, ok := f.fuzzFuncs[v.Type()]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			// Second: see if it can fuzz itself.
0000000000000000000000000000000000000000;;			if v.CanInterface() {
0000000000000000000000000000000000000000;;				intf := v.Interface()
0000000000000000000000000000000000000000;;				if fuzzable, ok := intf.(Interface); ok {
0000000000000000000000000000000000000000;;					fuzzable.Fuzz(Continue{f: f, Rand: f.r})
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Finally: see if there is a default fuzz function.
0000000000000000000000000000000000000000;;			doCustom, ok = f.defaultFuzzFuncs[v.Type()]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				if !v.CanSet() {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.Set(reflect.New(v.Type().Elem()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if v.IsNil() {
0000000000000000000000000000000000000000;;				if !v.CanSet() {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.Set(reflect.MakeMap(v.Type()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doCustom.Call([]reflect.Value{v, reflect.ValueOf(Continue{
0000000000000000000000000000000000000000;;			f:    f,
0000000000000000000000000000000000000000;;			Rand: f.r,
0000000000000000000000000000000000000000;;		})})
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Interface represents an object that knows how to fuzz itself.  Any time we
0000000000000000000000000000000000000000;;	// find a type that implements this interface we will delegate the act of
0000000000000000000000000000000000000000;;	// fuzzing itself.
0000000000000000000000000000000000000000;;	type Interface interface {
0000000000000000000000000000000000000000;;		Fuzz(c Continue)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Continue can be passed to custom fuzzing functions to allow them to use
0000000000000000000000000000000000000000;;	// the correct source of randomness and to continue fuzzing their members.
0000000000000000000000000000000000000000;;	type Continue struct {
0000000000000000000000000000000000000000;;		f *Fuzzer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For convenience, Continue implements rand.Rand via embedding.
0000000000000000000000000000000000000000;;		// Use this for generating any randomness if you want your fuzzing
0000000000000000000000000000000000000000;;		// to be repeatable for a given seed.
0000000000000000000000000000000000000000;;		*rand.Rand
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fuzz continues fuzzing obj. obj must be a pointer.
0000000000000000000000000000000000000000;;	func (c Continue) Fuzz(obj interface{}) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;		if v.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			panic("needed ptr!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = v.Elem()
0000000000000000000000000000000000000000;;		c.f.doFuzz(v, 0)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FuzzNoCustom continues fuzzing obj, except that any custom fuzz function for
0000000000000000000000000000000000000000;;	// obj's type will not be called and obj will not be tested for fuzz.Interface
0000000000000000000000000000000000000000;;	// conformance.  This applies only to obj and not other instances of obj's
0000000000000000000000000000000000000000;;	// type.
0000000000000000000000000000000000000000;;	func (c Continue) FuzzNoCustom(obj interface{}) {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(obj)
0000000000000000000000000000000000000000;;		if v.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			panic("needed ptr!")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v = v.Elem()
0000000000000000000000000000000000000000;;		c.f.doFuzz(v, flagNoCustomFuzz)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RandString makes a random string up to 20 characters long. The returned string
0000000000000000000000000000000000000000;;	// may include a variety of (valid) UTF-8 encodings.
0000000000000000000000000000000000000000;;	func (c Continue) RandString() string {
0000000000000000000000000000000000000000;;		return randString(c.Rand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RandUint64 makes random 64 bit numbers.
0000000000000000000000000000000000000000;;	// Weirdly, rand doesn't have a function that gives you 64 random bits.
0000000000000000000000000000000000000000;;	func (c Continue) RandUint64() uint64 {
0000000000000000000000000000000000000000;;		return randUint64(c.Rand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RandBool returns true or false randomly.
0000000000000000000000000000000000000000;;	func (c Continue) RandBool() bool {
0000000000000000000000000000000000000000;;		return randBool(c.Rand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fuzzInt(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;		v.SetInt(int64(randUint64(r)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fuzzUint(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;		v.SetUint(randUint64(r))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fuzzTime(t *time.Time, c Continue) {
0000000000000000000000000000000000000000;;		var sec, nsec int64
0000000000000000000000000000000000000000;;		// Allow for about 1000 years of random time values, which keeps things
0000000000000000000000000000000000000000;;		// like JSON parsing reasonably happy.
0000000000000000000000000000000000000000;;		sec = c.Rand.Int63n(1000 * 365 * 24 * 60 * 60)
0000000000000000000000000000000000000000;;		c.Fuzz(&nsec)
0000000000000000000000000000000000000000;;		*t = time.Unix(sec, nsec)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var fillFuncMap = map[reflect.Kind]func(reflect.Value, *rand.Rand){
0000000000000000000000000000000000000000;;		reflect.Bool: func(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;			v.SetBool(randBool(r))
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		reflect.Int:     fuzzInt,
0000000000000000000000000000000000000000;;		reflect.Int8:    fuzzInt,
0000000000000000000000000000000000000000;;		reflect.Int16:   fuzzInt,
0000000000000000000000000000000000000000;;		reflect.Int32:   fuzzInt,
0000000000000000000000000000000000000000;;		reflect.Int64:   fuzzInt,
0000000000000000000000000000000000000000;;		reflect.Uint:    fuzzUint,
0000000000000000000000000000000000000000;;		reflect.Uint8:   fuzzUint,
0000000000000000000000000000000000000000;;		reflect.Uint16:  fuzzUint,
0000000000000000000000000000000000000000;;		reflect.Uint32:  fuzzUint,
0000000000000000000000000000000000000000;;		reflect.Uint64:  fuzzUint,
0000000000000000000000000000000000000000;;		reflect.Uintptr: fuzzUint,
0000000000000000000000000000000000000000;;		reflect.Float32: func(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;			v.SetFloat(float64(r.Float32()))
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		reflect.Float64: func(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;			v.SetFloat(r.Float64())
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		reflect.Complex64: func(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;			panic("unimplemented")
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		reflect.Complex128: func(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;			panic("unimplemented")
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		reflect.String: func(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;			v.SetString(randString(r))
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		reflect.UnsafePointer: func(v reflect.Value, r *rand.Rand) {
0000000000000000000000000000000000000000;;			panic("unimplemented")
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// randBool returns true or false randomly.
0000000000000000000000000000000000000000;;	func randBool(r *rand.Rand) bool {
0000000000000000000000000000000000000000;;		if r.Int()&1 == 1 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type charRange struct {
0000000000000000000000000000000000000000;;		first, last rune
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// choose returns a random unicode character from the given range, using the
0000000000000000000000000000000000000000;;	// given randomness source.
0000000000000000000000000000000000000000;;	func (r *charRange) choose(rand *rand.Rand) rune {
0000000000000000000000000000000000000000;;		count := int64(r.last - r.first)
0000000000000000000000000000000000000000;;		return r.first + rune(rand.Int63n(count))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var unicodeRanges = []charRange{
0000000000000000000000000000000000000000;;		{' ', '~'},           // ASCII characters
0000000000000000000000000000000000000000;;		{'\u00a0', '\u02af'}, // Multi-byte encoded characters
0000000000000000000000000000000000000000;;		{'\u4e00', '\u9fff'}, // Common CJK (even longer encodings)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// randString makes a random string up to 20 characters long. The returned string
0000000000000000000000000000000000000000;;	// may include a variety of (valid) UTF-8 encodings.
0000000000000000000000000000000000000000;;	func randString(r *rand.Rand) string {
0000000000000000000000000000000000000000;;		n := r.Intn(20)
0000000000000000000000000000000000000000;;		runes := make([]rune, n)
0000000000000000000000000000000000000000;;		for i := range runes {
0000000000000000000000000000000000000000;;			runes[i] = unicodeRanges[r.Intn(len(unicodeRanges))].choose(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(runes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// randUint64 makes random 64 bit numbers.
0000000000000000000000000000000000000000;;	// Weirdly, rand doesn't have a function that gives you 64 random bits.
0000000000000000000000000000000000000000;;	func randUint64(r *rand.Rand) uint64 {
0000000000000000000000000000000000000000;;		return uint64(r.Uint32())<<32 | uint64(r.Uint32())
0000000000000000000000000000000000000000;;	}
