0000000000000000000000000000000000000000;;	gofuzz
0000000000000000000000000000000000000000;;	======
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	gofuzz is a library for populating go objects with random values.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![GoDoc](https://godoc.org/github.com/google/gofuzz?status.png)](https://godoc.org/github.com/google/gofuzz)
0000000000000000000000000000000000000000;;	[![Travis](https://travis-ci.org/google/gofuzz.svg?branch=master)](https://travis-ci.org/google/gofuzz)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This is useful for testing:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* Do your project's objects really serialize/unserialize correctly in all cases?
0000000000000000000000000000000000000000;;	* Is there an incorrectly formatted object that will cause your project to panic?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Import with ```import "github.com/google/gofuzz"```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can use it on single variables:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	f := fuzz.New()
0000000000000000000000000000000000000000;;	var myInt int
0000000000000000000000000000000000000000;;	f.Fuzz(&myInt) // myInt gets a random value.
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can use it on maps:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	f := fuzz.New().NilChance(0).NumElements(1, 1)
0000000000000000000000000000000000000000;;	var myMap map[ComplexKeyType]string
0000000000000000000000000000000000000000;;	f.Fuzz(&myMap) // myMap will have exactly one element.
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Customize the chance of getting a nil pointer:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	f := fuzz.New().NilChance(.5)
0000000000000000000000000000000000000000;;	var fancyStruct struct {
0000000000000000000000000000000000000000;;	  A, B, C, D *string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	f.Fuzz(&fancyStruct) // About half the pointers should be set.
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can even customize the randomization completely if needed:
0000000000000000000000000000000000000000;;	```go
0000000000000000000000000000000000000000;;	type MyEnum string
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;	        A MyEnum = "A"
0000000000000000000000000000000000000000;;	        B MyEnum = "B"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	type MyInfo struct {
0000000000000000000000000000000000000000;;	        Type MyEnum
0000000000000000000000000000000000000000;;	        AInfo *string
0000000000000000000000000000000000000000;;	        BInfo *string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	f := fuzz.New().NilChance(0).Funcs(
0000000000000000000000000000000000000000;;	        func(e *MyInfo, c fuzz.Continue) {
0000000000000000000000000000000000000000;;	                switch c.Intn(2) {
0000000000000000000000000000000000000000;;	                case 0:
0000000000000000000000000000000000000000;;	                        e.Type = A
0000000000000000000000000000000000000000;;	                        c.Fuzz(&e.AInfo)
0000000000000000000000000000000000000000;;	                case 1:
0000000000000000000000000000000000000000;;	                        e.Type = B
0000000000000000000000000000000000000000;;	                        c.Fuzz(&e.BInfo)
0000000000000000000000000000000000000000;;	                }
0000000000000000000000000000000000000000;;	        },
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var myObject MyInfo
0000000000000000000000000000000000000000;;	f.Fuzz(&myObject) // Type will correspond to whether A or B info is set.
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	See more examples in ```example_test.go```.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Happy testing!
