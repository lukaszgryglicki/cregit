0000000000000000000000000000000000000000;;	package gziphandler
43b9462ca2f561c16e8a5871711e2a7273a39d24;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"compress/gzip"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		vary            = "Vary"
0000000000000000000000000000000000000000;;		acceptEncoding  = "Accept-Encoding"
0000000000000000000000000000000000000000;;		contentEncoding = "Content-Encoding"
0000000000000000000000000000000000000000;;		contentType     = "Content-Type"
0000000000000000000000000000000000000000;;		contentLength   = "Content-Length"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type codings map[string]float64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// DefaultQValue is the default qvalue to assign to an encoding if no explicit qvalue is set.
0000000000000000000000000000000000000000;;		// This is actually kind of ambiguous in RFC 2616, so hopefully it's correct.
0000000000000000000000000000000000000000;;		// The examples seem to indicate that it is.
0000000000000000000000000000000000000000;;		DefaultQValue = 1.0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DefaultMinSize defines the minimum size to reach to enable compression.
0000000000000000000000000000000000000000;;		// It's 512 bytes.
0000000000000000000000000000000000000000;;		DefaultMinSize = 512
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// gzipWriterPools stores a sync.Pool for each compression level for reuse of
0000000000000000000000000000000000000000;;	// gzip.Writers. Use poolIndex to covert a compression level to an index into
0000000000000000000000000000000000000000;;	// gzipWriterPools.
0000000000000000000000000000000000000000;;	var gzipWriterPools [gzip.BestCompression - gzip.BestSpeed + 2]*sync.Pool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for i := gzip.BestSpeed; i <= gzip.BestCompression; i++ {
0000000000000000000000000000000000000000;;			addLevelPool(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addLevelPool(gzip.DefaultCompression)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// poolIndex maps a compression level to its index into gzipWriterPools. It
0000000000000000000000000000000000000000;;	// assumes that level is a valid gzip compression level.
0000000000000000000000000000000000000000;;	func poolIndex(level int) int {
0000000000000000000000000000000000000000;;		// gzip.DefaultCompression == -1, so we need to treat it special.
0000000000000000000000000000000000000000;;		if level == gzip.DefaultCompression {
0000000000000000000000000000000000000000;;			return gzip.BestCompression - gzip.BestSpeed + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return level - gzip.BestSpeed
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addLevelPool(level int) {
0000000000000000000000000000000000000000;;		gzipWriterPools[poolIndex(level)] = &sync.Pool{
0000000000000000000000000000000000000000;;			New: func() interface{} {
0000000000000000000000000000000000000000;;				// NewWriterLevel only returns error on a bad level, we are guaranteeing
0000000000000000000000000000000000000000;;				// that this will be a valid level so it is okay to ignore the returned
0000000000000000000000000000000000000000;;				// error.
0000000000000000000000000000000000000000;;				w, _ := gzip.NewWriterLevel(nil, level)
0000000000000000000000000000000000000000;;				return w
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GzipResponseWriter provides an http.ResponseWriter interface, which gzips
0000000000000000000000000000000000000000;;	// bytes before writing them to the underlying response. This doesn't close the
0000000000000000000000000000000000000000;;	// writers, so don't forget to do that.
0000000000000000000000000000000000000000;;	// It can be configured to skip response smaller than minSize.
0000000000000000000000000000000000000000;;	type GzipResponseWriter struct {
0000000000000000000000000000000000000000;;		http.ResponseWriter
0000000000000000000000000000000000000000;;		index int // Index for gzipWriterPools.
0000000000000000000000000000000000000000;;		gw    *gzip.Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		code int // Saves the WriteHeader value.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		minSize int    // Specifed the minimum response size to gzip. If the response length is bigger than this value, it is compressed.
0000000000000000000000000000000000000000;;		buf     []byte // Holds the first part of the write before reaching the minSize or the end of the write.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write appends data to the gzip writer.
0000000000000000000000000000000000000000;;	func (w *GzipResponseWriter) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		// If content type is not set.
0000000000000000000000000000000000000000;;		if _, ok := w.Header()[contentType]; !ok {
0000000000000000000000000000000000000000;;			// It infer it from the uncompressed body.
0000000000000000000000000000000000000000;;			w.Header().Set(contentType, http.DetectContentType(b))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GZIP responseWriter is initialized. Use the GZIP responseWriter.
0000000000000000000000000000000000000000;;		if w.gw != nil {
0000000000000000000000000000000000000000;;			n, err := w.gw.Write(b)
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save the write into a buffer for later use in GZIP responseWriter (if content is long enough) or at close with regular responseWriter.
0000000000000000000000000000000000000000;;		// On the first write, w.buf changes from nil to a valid slice
0000000000000000000000000000000000000000;;		w.buf = append(w.buf, b...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the global writes are bigger than the minSize, compression is enable.
0000000000000000000000000000000000000000;;		if len(w.buf) >= w.minSize {
0000000000000000000000000000000000000000;;			err := w.startGzip()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// startGzip initialize any GZIP specific informations.
0000000000000000000000000000000000000000;;	func (w *GzipResponseWriter) startGzip() error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the GZIP header.
0000000000000000000000000000000000000000;;		w.Header().Set(contentEncoding, "gzip")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if the Content-Length is already set, then calls to Write on gzip
0000000000000000000000000000000000000000;;		// will fail to set the Content-Length header since its already set
0000000000000000000000000000000000000000;;		// See: https://github.com/golang/go/issues/14975.
0000000000000000000000000000000000000000;;		w.Header().Del(contentLength)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the header to gzip response.
0000000000000000000000000000000000000000;;		if w.code != 0 {
0000000000000000000000000000000000000000;;			w.ResponseWriter.WriteHeader(w.code)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize the GZIP response.
0000000000000000000000000000000000000000;;		w.init()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flush the buffer into the gzip reponse.
0000000000000000000000000000000000000000;;		n, err := w.gw.Write(w.buf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This should never happen (per io.Writer docs), but if the write didn't
0000000000000000000000000000000000000000;;		// accept the entire buffer but returned no specific error, we have no clue
0000000000000000000000000000000000000000;;		// what's going on, so abort just to be safe.
0000000000000000000000000000000000000000;;		if err == nil && n < len(w.buf) {
0000000000000000000000000000000000000000;;			return io.ErrShortWrite
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.buf = nil
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeader just saves the response code until close or GZIP effective writes.
0000000000000000000000000000000000000000;;	func (w *GzipResponseWriter) WriteHeader(code int) {
0000000000000000000000000000000000000000;;		w.code = code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// init graps a new gzip writer from the gzipWriterPool and writes the correct
0000000000000000000000000000000000000000;;	// content encoding header.
0000000000000000000000000000000000000000;;	func (w *GzipResponseWriter) init() {
0000000000000000000000000000000000000000;;		// Bytes written during ServeHTTP are redirected to this gzip writer
0000000000000000000000000000000000000000;;		// before being written to the underlying response.
0000000000000000000000000000000000000000;;		gzw := gzipWriterPools[w.index].Get().(*gzip.Writer)
0000000000000000000000000000000000000000;;		gzw.Reset(w.ResponseWriter)
0000000000000000000000000000000000000000;;		w.gw = gzw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close will close the gzip.Writer and will put it back in the gzipWriterPool.
0000000000000000000000000000000000000000;;	func (w *GzipResponseWriter) Close() error {
0000000000000000000000000000000000000000;;		if w.gw == nil {
0000000000000000000000000000000000000000;;			// Gzip not trigged yet, write out regular response.
0000000000000000000000000000000000000000;;			if w.code != 0 {
0000000000000000000000000000000000000000;;				w.ResponseWriter.WriteHeader(w.code)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if w.buf != nil {
0000000000000000000000000000000000000000;;				_, writeErr := w.ResponseWriter.Write(w.buf)
0000000000000000000000000000000000000000;;				// Returns the error if any at write.
0000000000000000000000000000000000000000;;				if writeErr != nil {
0000000000000000000000000000000000000000;;					return fmt.Errorf("gziphandler: write to regular responseWriter at close gets error: %q", writeErr.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := w.gw.Close()
0000000000000000000000000000000000000000;;		gzipWriterPools[w.index].Put(w.gw)
0000000000000000000000000000000000000000;;		w.gw = nil
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flush flushes the underlying *gzip.Writer and then the underlying
0000000000000000000000000000000000000000;;	// http.ResponseWriter if it is an http.Flusher. This makes GzipResponseWriter
0000000000000000000000000000000000000000;;	// an http.Flusher.
0000000000000000000000000000000000000000;;	func (w *GzipResponseWriter) Flush() {
0000000000000000000000000000000000000000;;		if w.gw != nil {
0000000000000000000000000000000000000000;;			w.gw.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fw, ok := w.ResponseWriter.(http.Flusher); ok {
0000000000000000000000000000000000000000;;			fw.Flush()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hijack implements http.Hijacker. If the underlying ResponseWriter is a
0000000000000000000000000000000000000000;;	// Hijacker, its Hijack method is returned. Otherwise an error is returned.
0000000000000000000000000000000000000000;;	func (w *GzipResponseWriter) Hijack() (net.Conn, *bufio.ReadWriter, error) {
0000000000000000000000000000000000000000;;		if hj, ok := w.ResponseWriter.(http.Hijacker); ok {
0000000000000000000000000000000000000000;;			return hj.Hijack()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil, fmt.Errorf("http.Hijacker interface is not supported")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// verify Hijacker interface implementation
0000000000000000000000000000000000000000;;	var _ http.Hijacker = &GzipResponseWriter{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustNewGzipLevelHandler behaves just like NewGzipLevelHandler except that in
0000000000000000000000000000000000000000;;	// an error case it panics rather than returning an error.
0000000000000000000000000000000000000000;;	func MustNewGzipLevelHandler(level int) func(http.Handler) http.Handler {
0000000000000000000000000000000000000000;;		wrap, err := NewGzipLevelHandler(level)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return wrap
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGzipLevelHandler returns a wrapper function (often known as middleware)
0000000000000000000000000000000000000000;;	// which can be used to wrap an HTTP handler to transparently gzip the response
0000000000000000000000000000000000000000;;	// body if the client supports it (via the Accept-Encoding header). Responses will
0000000000000000000000000000000000000000;;	// be encoded at the given gzip compression level. An error will be returned only
0000000000000000000000000000000000000000;;	// if an invalid gzip compression level is given, so if one can ensure the level
0000000000000000000000000000000000000000;;	// is valid, the returned error can be safely ignored.
0000000000000000000000000000000000000000;;	func NewGzipLevelHandler(level int) (func(http.Handler) http.Handler, error) {
0000000000000000000000000000000000000000;;		return NewGzipLevelAndMinSize(level, DefaultMinSize)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewGzipLevelAndMinSize behave as NewGzipLevelHandler except it let the caller
0000000000000000000000000000000000000000;;	// specify the minimum size before compression.
0000000000000000000000000000000000000000;;	func NewGzipLevelAndMinSize(level, minSize int) (func(http.Handler) http.Handler, error) {
0000000000000000000000000000000000000000;;		if level != gzip.DefaultCompression && (level < gzip.BestSpeed || level > gzip.BestCompression) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid compression level requested: %d", level)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if minSize < 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("minimum size must be more than zero")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(h http.Handler) http.Handler {
0000000000000000000000000000000000000000;;			index := poolIndex(level)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;				w.Header().Add(vary, acceptEncoding)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if acceptsGzip(r) {
0000000000000000000000000000000000000000;;					gw := &GzipResponseWriter{
0000000000000000000000000000000000000000;;						ResponseWriter: w,
0000000000000000000000000000000000000000;;						index:          index,
0000000000000000000000000000000000000000;;						minSize:        minSize,
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer gw.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					h.ServeHTTP(gw, r)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					h.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GzipHandler wraps an HTTP handler, to transparently gzip the response body if
0000000000000000000000000000000000000000;;	// the client supports it (via the Accept-Encoding header). This will compress at
0000000000000000000000000000000000000000;;	// the default compression level.
0000000000000000000000000000000000000000;;	func GzipHandler(h http.Handler) http.Handler {
0000000000000000000000000000000000000000;;		wrapper, _ := NewGzipLevelHandler(gzip.DefaultCompression)
0000000000000000000000000000000000000000;;		return wrapper(h)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// acceptsGzip returns true if the given HTTP request indicates that it will
0000000000000000000000000000000000000000;;	// accept a gzipped response.
0000000000000000000000000000000000000000;;	func acceptsGzip(r *http.Request) bool {
0000000000000000000000000000000000000000;;		acceptedEncodings, _ := parseEncodings(r.Header.Get(acceptEncoding))
0000000000000000000000000000000000000000;;		return acceptedEncodings["gzip"] > 0.0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseEncodings attempts to parse a list of codings, per RFC 2616, as might
0000000000000000000000000000000000000000;;	// appear in an Accept-Encoding header. It returns a map of content-codings to
0000000000000000000000000000000000000000;;	// quality values, and an error containing the errors encountered. It's probably
0000000000000000000000000000000000000000;;	// safe to ignore those, because silently ignoring errors is how the internet
0000000000000000000000000000000000000000;;	// works.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See: http://tools.ietf.org/html/rfc2616#section-14.3.
0000000000000000000000000000000000000000;;	func parseEncodings(s string) (codings, error) {
0000000000000000000000000000000000000000;;		c := make(codings)
0000000000000000000000000000000000000000;;		var e []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ss := range strings.Split(s, ",") {
0000000000000000000000000000000000000000;;			coding, qvalue, err := parseCoding(ss)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				e = append(e, err.Error())
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c[coding] = qvalue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO (adammck): Use a proper multi-error struct, so the individual errors
0000000000000000000000000000000000000000;;		//                 can be extracted if anyone cares.
0000000000000000000000000000000000000000;;		if len(e) > 0 {
0000000000000000000000000000000000000000;;			return c, fmt.Errorf("errors while parsing encodings: %s", strings.Join(e, ", "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseCoding parses a single conding (content-coding with an optional qvalue),
0000000000000000000000000000000000000000;;	// as might appear in an Accept-Encoding header. It attempts to forgive minor
0000000000000000000000000000000000000000;;	// formatting errors.
0000000000000000000000000000000000000000;;	func parseCoding(s string) (coding string, qvalue float64, err error) {
0000000000000000000000000000000000000000;;		for n, part := range strings.Split(s, ";") {
0000000000000000000000000000000000000000;;			part = strings.TrimSpace(part)
0000000000000000000000000000000000000000;;			qvalue = DefaultQValue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if n == 0 {
0000000000000000000000000000000000000000;;				coding = strings.ToLower(part)
0000000000000000000000000000000000000000;;			} else if strings.HasPrefix(part, "q=") {
0000000000000000000000000000000000000000;;				qvalue, err = strconv.ParseFloat(strings.TrimPrefix(part, "q="), 64)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if qvalue < 0.0 {
0000000000000000000000000000000000000000;;					qvalue = 0.0
0000000000000000000000000000000000000000;;				} else if qvalue > 1.0 {
0000000000000000000000000000000000000000;;					qvalue = 1.0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if coding == "" {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("empty content-coding")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
