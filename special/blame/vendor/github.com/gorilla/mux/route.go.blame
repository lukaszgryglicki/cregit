0000000000000000000000000000000000000000;;	// Copyright 2012 The Gorilla Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/gorilla/mux/route.go[Godeps/_workspace/src/github.com/gorilla/mux/route.go][vendor/github.com/gorilla/mux/route.go];	
0000000000000000000000000000000000000000;;	package mux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Route stores information to match a request and build URLs.
0000000000000000000000000000000000000000;;	type Route struct {
0000000000000000000000000000000000000000;;		// Parent where the route was registered (a Router).
0000000000000000000000000000000000000000;;		parent parentRoute
0000000000000000000000000000000000000000;;		// Request handler for the route.
0000000000000000000000000000000000000000;;		handler http.Handler
0000000000000000000000000000000000000000;;		// List of matchers.
0000000000000000000000000000000000000000;;		matchers []matcher
0000000000000000000000000000000000000000;;		// Manager for the variables from host and path.
0000000000000000000000000000000000000000;;		regexp *routeRegexpGroup
0000000000000000000000000000000000000000;;		// If true, when the path pattern is "/path/", accessing "/path" will
0000000000000000000000000000000000000000;;		// redirect to the former and vice versa.
0000000000000000000000000000000000000000;;		strictSlash bool
0000000000000000000000000000000000000000;;		// If true, this route never matches: it is only used to build URLs.
0000000000000000000000000000000000000000;;		buildOnly bool
0000000000000000000000000000000000000000;;		// The name used to build URLs.
0000000000000000000000000000000000000000;;		name string
0000000000000000000000000000000000000000;;		// Error resulted from building a route.
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buildVarsFunc BuildVarsFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match matches the route against the request.
0000000000000000000000000000000000000000;;	func (r *Route) Match(req *http.Request, match *RouteMatch) bool {
0000000000000000000000000000000000000000;;		if r.buildOnly || r.err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Match everything.
0000000000000000000000000000000000000000;;		for _, m := range r.matchers {
0000000000000000000000000000000000000000;;			if matched := m.Match(req, match); !matched {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Yay, we have a match. Let's collect some info about it.
0000000000000000000000000000000000000000;;		if match.Route == nil {
0000000000000000000000000000000000000000;;			match.Route = r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if match.Handler == nil {
0000000000000000000000000000000000000000;;			match.Handler = r.handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if match.Vars == nil {
0000000000000000000000000000000000000000;;			match.Vars = make(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set variables.
0000000000000000000000000000000000000000;;		if r.regexp != nil {
0000000000000000000000000000000000000000;;			r.regexp.setMatch(req, match, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Route attributes
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetError returns an error resulted from building the route, if any.
0000000000000000000000000000000000000000;;	func (r *Route) GetError() error {
0000000000000000000000000000000000000000;;		return r.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildOnly sets the route to never match: it is only used to build URLs.
0000000000000000000000000000000000000000;;	func (r *Route) BuildOnly() *Route {
0000000000000000000000000000000000000000;;		r.buildOnly = true
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler --------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler sets a handler for the route.
0000000000000000000000000000000000000000;;	func (r *Route) Handler(handler http.Handler) *Route {
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			r.handler = handler
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandlerFunc sets a handler function for the route.
0000000000000000000000000000000000000000;;	func (r *Route) HandlerFunc(f func(http.ResponseWriter, *http.Request)) *Route {
0000000000000000000000000000000000000000;;		return r.Handler(http.HandlerFunc(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetHandler returns the handler for the route, if any.
0000000000000000000000000000000000000000;;	func (r *Route) GetHandler() http.Handler {
0000000000000000000000000000000000000000;;		return r.handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name -----------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name sets the name for the route, used to build URLs.
0000000000000000000000000000000000000000;;	// If the name was registered already it will be overwritten.
0000000000000000000000000000000000000000;;	func (r *Route) Name(name string) *Route {
0000000000000000000000000000000000000000;;		if r.name != "" {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf("mux: route already has name %q, can't set %q",
0000000000000000000000000000000000000000;;				r.name, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			r.name = name
0000000000000000000000000000000000000000;;			r.getNamedRoutes()[name] = r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetName returns the name for the route, if any.
0000000000000000000000000000000000000000;;	func (r *Route) GetName() string {
0000000000000000000000000000000000000000;;		return r.name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Matchers
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matcher types try to match a request.
0000000000000000000000000000000000000000;;	type matcher interface {
0000000000000000000000000000000000000000;;		Match(*http.Request, *RouteMatch) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addMatcher adds a matcher to the route.
0000000000000000000000000000000000000000;;	func (r *Route) addMatcher(m matcher) *Route {
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			r.matchers = append(r.matchers, m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// addRegexpMatcher adds a host or path matcher and builder to a route.
0000000000000000000000000000000000000000;;	func (r *Route) addRegexpMatcher(tpl string, matchHost, matchPrefix, matchQuery bool) error {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.regexp = r.getRegexpGroup()
0000000000000000000000000000000000000000;;		if !matchHost && !matchQuery {
0000000000000000000000000000000000000000;;			if len(tpl) == 0 || tpl[0] != '/' {
0000000000000000000000000000000000000000;;				return fmt.Errorf("mux: path must start with a slash, got %q", tpl)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if r.regexp.path != nil {
0000000000000000000000000000000000000000;;				tpl = strings.TrimRight(r.regexp.path.template, "/") + tpl
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr, err := newRouteRegexp(tpl, matchHost, matchPrefix, matchQuery, r.strictSlash)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, q := range r.regexp.queries {
0000000000000000000000000000000000000000;;			if err = uniqueVars(rr.varsN, q.varsN); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if matchHost {
0000000000000000000000000000000000000000;;			if r.regexp.path != nil {
0000000000000000000000000000000000000000;;				if err = uniqueVars(rr.varsN, r.regexp.path.varsN); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.regexp.host = rr
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if r.regexp.host != nil {
0000000000000000000000000000000000000000;;				if err = uniqueVars(rr.varsN, r.regexp.host.varsN); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if matchQuery {
0000000000000000000000000000000000000000;;				r.regexp.queries = append(r.regexp.queries, rr)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.regexp.path = rr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.addMatcher(rr)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Headers --------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// headerMatcher matches the request against header values.
0000000000000000000000000000000000000000;;	type headerMatcher map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m headerMatcher) Match(r *http.Request, match *RouteMatch) bool {
0000000000000000000000000000000000000000;;		return matchMap(m, r.Header, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Headers adds a matcher for request header values.
0000000000000000000000000000000000000000;;	// It accepts a sequence of key/value pairs to be matched. For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     r := mux.NewRouter()
0000000000000000000000000000000000000000;;	//     r.Headers("Content-Type", "application/json",
0000000000000000000000000000000000000000;;	//               "X-Requested-With", "XMLHttpRequest")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The above route will only match if both request header values match.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It the value is an empty string, it will match any value if the key is set.
0000000000000000000000000000000000000000;;	func (r *Route) Headers(pairs ...string) *Route {
0000000000000000000000000000000000000000;;		if r.err == nil {
0000000000000000000000000000000000000000;;			var headers map[string]string
0000000000000000000000000000000000000000;;			headers, r.err = mapFromPairs(pairs...)
0000000000000000000000000000000000000000;;			return r.addMatcher(headerMatcher(headers))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Host -----------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Host adds a matcher for the URL host.
0000000000000000000000000000000000000000;;	// It accepts a template with zero or more URL variables enclosed by {}.
0000000000000000000000000000000000000000;;	// Variables can define an optional regexp pattern to me matched:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - {name} matches anything until the next dot.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - {name:pattern} matches the given regexp pattern.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     r := mux.NewRouter()
0000000000000000000000000000000000000000;;	//     r.Host("www.domain.com")
0000000000000000000000000000000000000000;;	//     r.Host("{subdomain}.domain.com")
0000000000000000000000000000000000000000;;	//     r.Host("{subdomain:[a-z]+}.domain.com")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Variable names must be unique in a given route. They can be retrieved
0000000000000000000000000000000000000000;;	// calling mux.Vars(request).
0000000000000000000000000000000000000000;;	func (r *Route) Host(tpl string) *Route {
0000000000000000000000000000000000000000;;		r.err = r.addRegexpMatcher(tpl, true, false, false)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatcherFunc ----------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatcherFunc is the function signature used by custom matchers.
0000000000000000000000000000000000000000;;	type MatcherFunc func(*http.Request, *RouteMatch) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m MatcherFunc) Match(r *http.Request, match *RouteMatch) bool {
0000000000000000000000000000000000000000;;		return m(r, match)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatcherFunc adds a custom function to be used as request matcher.
0000000000000000000000000000000000000000;;	func (r *Route) MatcherFunc(f MatcherFunc) *Route {
0000000000000000000000000000000000000000;;		return r.addMatcher(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Methods --------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// methodMatcher matches the request against HTTP methods.
0000000000000000000000000000000000000000;;	type methodMatcher []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m methodMatcher) Match(r *http.Request, match *RouteMatch) bool {
0000000000000000000000000000000000000000;;		return matchInArray(m, r.Method)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Methods adds a matcher for HTTP methods.
0000000000000000000000000000000000000000;;	// It accepts a sequence of one or more methods to be matched, e.g.:
0000000000000000000000000000000000000000;;	// "GET", "POST", "PUT".
0000000000000000000000000000000000000000;;	func (r *Route) Methods(methods ...string) *Route {
0000000000000000000000000000000000000000;;		for k, v := range methods {
0000000000000000000000000000000000000000;;			methods[k] = strings.ToUpper(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.addMatcher(methodMatcher(methods))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path -----------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path adds a matcher for the URL path.
0000000000000000000000000000000000000000;;	// It accepts a template with zero or more URL variables enclosed by {}. The
0000000000000000000000000000000000000000;;	// template must start with a "/".
0000000000000000000000000000000000000000;;	// Variables can define an optional regexp pattern to me matched:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - {name} matches anything until the next slash.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - {name:pattern} matches the given regexp pattern.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     r := mux.NewRouter()
0000000000000000000000000000000000000000;;	//     r.Path("/products/").Handler(ProductsHandler)
0000000000000000000000000000000000000000;;	//     r.Path("/products/{key}").Handler(ProductsHandler)
0000000000000000000000000000000000000000;;	//     r.Path("/articles/{category}/{id:[0-9]+}").
0000000000000000000000000000000000000000;;	//       Handler(ArticleHandler)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Variable names must be unique in a given route. They can be retrieved
0000000000000000000000000000000000000000;;	// calling mux.Vars(request).
0000000000000000000000000000000000000000;;	func (r *Route) Path(tpl string) *Route {
0000000000000000000000000000000000000000;;		r.err = r.addRegexpMatcher(tpl, false, false, false)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathPrefix -----------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathPrefix adds a matcher for the URL path prefix. This matches if the given
0000000000000000000000000000000000000000;;	// template is a prefix of the full URL path. See Route.Path() for details on
0000000000000000000000000000000000000000;;	// the tpl argument.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that it does not treat slashes specially ("/foobar/" will be matched by
0000000000000000000000000000000000000000;;	// the prefix "/foo") so you may want to use a trailing slash here.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Also note that the setting of Router.StrictSlash() has no effect on routes
0000000000000000000000000000000000000000;;	// with a PathPrefix matcher.
0000000000000000000000000000000000000000;;	func (r *Route) PathPrefix(tpl string) *Route {
0000000000000000000000000000000000000000;;		r.err = r.addRegexpMatcher(tpl, false, true, false)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query ----------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Queries adds a matcher for URL query values.
0000000000000000000000000000000000000000;;	// It accepts a sequence of key/value pairs. Values may define variables.
0000000000000000000000000000000000000000;;	// For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     r := mux.NewRouter()
0000000000000000000000000000000000000000;;	//     r.Queries("foo", "bar", "id", "{id:[0-9]+}")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The above route will only match if the URL contains the defined queries
0000000000000000000000000000000000000000;;	// values, e.g.: ?foo=bar&id=42.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It the value is an empty string, it will match any value if the key is set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Variables can define an optional regexp pattern to me matched:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - {name} matches anything until the next slash.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - {name:pattern} matches the given regexp pattern.
0000000000000000000000000000000000000000;;	func (r *Route) Queries(pairs ...string) *Route {
0000000000000000000000000000000000000000;;		length := len(pairs)
0000000000000000000000000000000000000000;;		if length%2 != 0 {
0000000000000000000000000000000000000000;;			r.err = fmt.Errorf(
0000000000000000000000000000000000000000;;				"mux: number of parameters must be multiple of 2, got %v", pairs)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < length; i += 2 {
0000000000000000000000000000000000000000;;			if r.err = r.addRegexpMatcher(pairs[i]+"="+pairs[i+1], false, true, true); r.err != nil {
0000000000000000000000000000000000000000;;				return r
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Schemes --------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// schemeMatcher matches the request against URL schemes.
0000000000000000000000000000000000000000;;	type schemeMatcher []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m schemeMatcher) Match(r *http.Request, match *RouteMatch) bool {
0000000000000000000000000000000000000000;;		return matchInArray(m, r.URL.Scheme)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Schemes adds a matcher for URL schemes.
0000000000000000000000000000000000000000;;	// It accepts a sequence of schemes to be matched, e.g.: "http", "https".
0000000000000000000000000000000000000000;;	func (r *Route) Schemes(schemes ...string) *Route {
0000000000000000000000000000000000000000;;		for k, v := range schemes {
0000000000000000000000000000000000000000;;			schemes[k] = strings.ToLower(v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.addMatcher(schemeMatcher(schemes))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildVarsFunc --------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildVarsFunc is the function signature used by custom build variable
0000000000000000000000000000000000000000;;	// functions (which can modify route variables before a route's URL is built).
0000000000000000000000000000000000000000;;	type BuildVarsFunc func(map[string]string) map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildVarsFunc adds a custom function to be used to modify build variables
0000000000000000000000000000000000000000;;	// before a route's URL is built.
0000000000000000000000000000000000000000;;	func (r *Route) BuildVarsFunc(f BuildVarsFunc) *Route {
0000000000000000000000000000000000000000;;		r.buildVarsFunc = f
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subrouter ------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subrouter creates a subrouter for the route.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will test the inner routes only if the parent route matched. For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     r := mux.NewRouter()
0000000000000000000000000000000000000000;;	//     s := r.Host("www.domain.com").Subrouter()
0000000000000000000000000000000000000000;;	//     s.HandleFunc("/products/", ProductsHandler)
0000000000000000000000000000000000000000;;	//     s.HandleFunc("/products/{key}", ProductHandler)
0000000000000000000000000000000000000000;;	//     s.HandleFunc("/articles/{category}/{id:[0-9]+}"), ArticleHandler)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Here, the routes registered in the subrouter won't be tested if the host
0000000000000000000000000000000000000000;;	// doesn't match.
0000000000000000000000000000000000000000;;	func (r *Route) Subrouter() *Router {
0000000000000000000000000000000000000000;;		router := &Router{parent: r, strictSlash: r.strictSlash}
0000000000000000000000000000000000000000;;		r.addMatcher(router)
0000000000000000000000000000000000000000;;		return router
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// URL building
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URL builds a URL for the route.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It accepts a sequence of key/value pairs for the route variables. For
0000000000000000000000000000000000000000;;	// example, given this route:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     r := mux.NewRouter()
0000000000000000000000000000000000000000;;	//     r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
0000000000000000000000000000000000000000;;	//       Name("article")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ...a URL for it can be built using:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     url, err := r.Get("article").URL("category", "technology", "id", "42")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// ...which will return an url.URL with the following path:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     "/articles/technology/42"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This also works for host variables:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     r := mux.NewRouter()
0000000000000000000000000000000000000000;;	//     r.Host("{subdomain}.domain.com").
0000000000000000000000000000000000000000;;	//       HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
0000000000000000000000000000000000000000;;	//       Name("article")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     // url.String() will be "http://news.domain.com/articles/technology/42"
0000000000000000000000000000000000000000;;	//     url, err := r.Get("article").URL("subdomain", "news",
0000000000000000000000000000000000000000;;	//                                      "category", "technology",
0000000000000000000000000000000000000000;;	//                                      "id", "42")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All variables defined in the route are required, and their values must
0000000000000000000000000000000000000000;;	// conform to the corresponding patterns.
0000000000000000000000000000000000000000;;	func (r *Route) URL(pairs ...string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.regexp == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("mux: route doesn't have a host or path")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		values, err := r.prepareVars(pairs...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var scheme, host, path string
0000000000000000000000000000000000000000;;		if r.regexp.host != nil {
0000000000000000000000000000000000000000;;			// Set a default scheme.
0000000000000000000000000000000000000000;;			scheme = "http"
0000000000000000000000000000000000000000;;			if host, err = r.regexp.host.url(values); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.regexp.path != nil {
0000000000000000000000000000000000000000;;			if path, err = r.regexp.path.url(values); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &url.URL{
0000000000000000000000000000000000000000;;			Scheme: scheme,
0000000000000000000000000000000000000000;;			Host:   host,
0000000000000000000000000000000000000000;;			Path:   path,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLHost builds the host part of the URL for a route. See Route.URL().
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The route must have a host defined.
0000000000000000000000000000000000000000;;	func (r *Route) URLHost(pairs ...string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.regexp == nil || r.regexp.host == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("mux: route doesn't have a host")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		values, err := r.prepareVars(pairs...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		host, err := r.regexp.host.url(values)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &url.URL{
0000000000000000000000000000000000000000;;			Scheme: "http",
0000000000000000000000000000000000000000;;			Host:   host,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// URLPath builds the path part of the URL for a route. See Route.URL().
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The route must have a path defined.
0000000000000000000000000000000000000000;;	func (r *Route) URLPath(pairs ...string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		if r.err != nil {
0000000000000000000000000000000000000000;;			return nil, r.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.regexp == nil || r.regexp.path == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("mux: route doesn't have a path")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		values, err := r.prepareVars(pairs...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		path, err := r.regexp.path.url(values)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &url.URL{
0000000000000000000000000000000000000000;;			Path: path,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prepareVars converts the route variable pairs into a map. If the route has a
0000000000000000000000000000000000000000;;	// BuildVarsFunc, it is invoked.
0000000000000000000000000000000000000000;;	func (r *Route) prepareVars(pairs ...string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		m, err := mapFromPairs(pairs...)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.buildVars(m), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Route) buildVars(m map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		if r.parent != nil {
0000000000000000000000000000000000000000;;			m = r.parent.buildVars(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.buildVarsFunc != nil {
0000000000000000000000000000000000000000;;			m = r.buildVarsFunc(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// parentRoute
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parentRoute allows routes to know about parent host and path definitions.
0000000000000000000000000000000000000000;;	type parentRoute interface {
0000000000000000000000000000000000000000;;		getNamedRoutes() map[string]*Route
0000000000000000000000000000000000000000;;		getRegexpGroup() *routeRegexpGroup
0000000000000000000000000000000000000000;;		buildVars(map[string]string) map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNamedRoutes returns the map where named routes are registered.
0000000000000000000000000000000000000000;;	func (r *Route) getNamedRoutes() map[string]*Route {
0000000000000000000000000000000000000000;;		if r.parent == nil {
0000000000000000000000000000000000000000;;			// During tests router is not always set.
0000000000000000000000000000000000000000;;			r.parent = NewRouter()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.parent.getNamedRoutes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRegexpGroup returns regexp definitions from this route.
0000000000000000000000000000000000000000;;	func (r *Route) getRegexpGroup() *routeRegexpGroup {
0000000000000000000000000000000000000000;;		if r.regexp == nil {
0000000000000000000000000000000000000000;;			if r.parent == nil {
0000000000000000000000000000000000000000;;				// During tests router is not always set.
0000000000000000000000000000000000000000;;				r.parent = NewRouter()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			regexp := r.parent.getRegexpGroup()
0000000000000000000000000000000000000000;;			if regexp == nil {
0000000000000000000000000000000000000000;;				r.regexp = new(routeRegexpGroup)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Copy.
0000000000000000000000000000000000000000;;				r.regexp = &routeRegexpGroup{
0000000000000000000000000000000000000000;;					host:    regexp.host,
0000000000000000000000000000000000000000;;					path:    regexp.path,
0000000000000000000000000000000000000000;;					queries: regexp.queries,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.regexp
0000000000000000000000000000000000000000;;	}
