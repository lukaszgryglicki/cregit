0000000000000000000000000000000000000000;;	// Copyright 2012 The Gorilla Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/gorilla/mux/mux.go[Godeps/_workspace/src/github.com/gorilla/mux/mux.go][vendor/github.com/gorilla/mux/mux.go];	
0000000000000000000000000000000000000000;;	package mux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/gorilla/context"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRouter returns a new router instance.
0000000000000000000000000000000000000000;;	func NewRouter() *Router {
0000000000000000000000000000000000000000;;		return &Router{namedRoutes: make(map[string]*Route), KeepContext: false}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Router registers routes to be matched and dispatches a handler.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It implements the http.Handler interface, so it can be registered to serve
0000000000000000000000000000000000000000;;	// requests:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     var router = mux.NewRouter()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     func main() {
0000000000000000000000000000000000000000;;	//         http.Handle("/", router)
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Or, for Google App Engine, register it in a init() function:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     func init() {
0000000000000000000000000000000000000000;;	//         http.Handle("/", router)
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This will send all incoming requests to the router.
0000000000000000000000000000000000000000;;	type Router struct {
0000000000000000000000000000000000000000;;		// Configurable Handler to be used when no route matches.
0000000000000000000000000000000000000000;;		NotFoundHandler http.Handler
0000000000000000000000000000000000000000;;		// Parent route, if this is a subrouter.
0000000000000000000000000000000000000000;;		parent parentRoute
0000000000000000000000000000000000000000;;		// Routes to be matched, in order.
0000000000000000000000000000000000000000;;		routes []*Route
0000000000000000000000000000000000000000;;		// Routes by name for URL building.
0000000000000000000000000000000000000000;;		namedRoutes map[string]*Route
0000000000000000000000000000000000000000;;		// See Router.StrictSlash(). This defines the flag for new routes.
0000000000000000000000000000000000000000;;		strictSlash bool
0000000000000000000000000000000000000000;;		// If true, do not clear the request context after handling the request
0000000000000000000000000000000000000000;;		KeepContext bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match matches registered routes against the request.
0000000000000000000000000000000000000000;;	func (r *Router) Match(req *http.Request, match *RouteMatch) bool {
0000000000000000000000000000000000000000;;		for _, route := range r.routes {
0000000000000000000000000000000000000000;;			if route.Match(req, match) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeHTTP dispatches the handler registered in the matched route.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When there is a match, the route variables can be retrieved calling
0000000000000000000000000000000000000000;;	// mux.Vars(request).
0000000000000000000000000000000000000000;;	func (r *Router) ServeHTTP(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;		// Clean path to canonical form and redirect.
0000000000000000000000000000000000000000;;		if p := cleanPath(req.URL.Path); p != req.URL.Path {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Added 3 lines (Philip Schlump) - It was droping the query string and #whatever from query.
0000000000000000000000000000000000000000;;			// This matches with fix in go 1.2 r.c. 4 for same problem.  Go Issue:
0000000000000000000000000000000000000000;;			// http://code.google.com/p/go/issues/detail?id=5252
0000000000000000000000000000000000000000;;			url := *req.URL
0000000000000000000000000000000000000000;;			url.Path = p
0000000000000000000000000000000000000000;;			p = url.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			w.Header().Set("Location", p)
0000000000000000000000000000000000000000;;			w.WriteHeader(http.StatusMovedPermanently)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var match RouteMatch
0000000000000000000000000000000000000000;;		var handler http.Handler
0000000000000000000000000000000000000000;;		if r.Match(req, &match) {
0000000000000000000000000000000000000000;;			handler = match.Handler
0000000000000000000000000000000000000000;;			setVars(req, match.Vars)
0000000000000000000000000000000000000000;;			setCurrentRoute(req, match.Route)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if handler == nil {
0000000000000000000000000000000000000000;;			handler = r.NotFoundHandler
0000000000000000000000000000000000000000;;			if handler == nil {
0000000000000000000000000000000000000000;;				handler = http.NotFoundHandler()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !r.KeepContext {
0000000000000000000000000000000000000000;;			defer context.Clear(req)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		handler.ServeHTTP(w, req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get returns a route registered with the given name.
0000000000000000000000000000000000000000;;	func (r *Router) Get(name string) *Route {
0000000000000000000000000000000000000000;;		return r.getNamedRoutes()[name]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetRoute returns a route registered with the given name. This method
0000000000000000000000000000000000000000;;	// was renamed to Get() and remains here for backwards compatibility.
0000000000000000000000000000000000000000;;	func (r *Router) GetRoute(name string) *Route {
0000000000000000000000000000000000000000;;		return r.getNamedRoutes()[name]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrictSlash defines the trailing slash behavior for new routes. The initial
0000000000000000000000000000000000000000;;	// value is false.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When true, if the route path is "/path/", accessing "/path" will redirect
0000000000000000000000000000000000000000;;	// to the former and vice versa. In other words, your application will always
0000000000000000000000000000000000000000;;	// see the path as specified in the route.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When false, if the route path is "/path", accessing "/path/" will not match
0000000000000000000000000000000000000000;;	// this route and vice versa.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Special case: when a route sets a path prefix using the PathPrefix() method,
0000000000000000000000000000000000000000;;	// strict slash is ignored for that route because the redirect behavior can't
0000000000000000000000000000000000000000;;	// be determined from a prefix alone. However, any subrouters created from that
0000000000000000000000000000000000000000;;	// route inherit the original StrictSlash setting.
0000000000000000000000000000000000000000;;	func (r *Router) StrictSlash(value bool) *Router {
0000000000000000000000000000000000000000;;		r.strictSlash = value
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// parentRoute
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getNamedRoutes returns the map where named routes are registered.
0000000000000000000000000000000000000000;;	func (r *Router) getNamedRoutes() map[string]*Route {
0000000000000000000000000000000000000000;;		if r.namedRoutes == nil {
0000000000000000000000000000000000000000;;			if r.parent != nil {
0000000000000000000000000000000000000000;;				r.namedRoutes = r.parent.getNamedRoutes()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r.namedRoutes = make(map[string]*Route)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.namedRoutes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getRegexpGroup returns regexp definitions from the parent route, if any.
0000000000000000000000000000000000000000;;	func (r *Router) getRegexpGroup() *routeRegexpGroup {
0000000000000000000000000000000000000000;;		if r.parent != nil {
0000000000000000000000000000000000000000;;			return r.parent.getRegexpGroup()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *Router) buildVars(m map[string]string) map[string]string {
0000000000000000000000000000000000000000;;		if r.parent != nil {
0000000000000000000000000000000000000000;;			m = r.parent.buildVars(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Route factories
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRoute registers an empty route.
0000000000000000000000000000000000000000;;	func (r *Router) NewRoute() *Route {
0000000000000000000000000000000000000000;;		route := &Route{parent: r, strictSlash: r.strictSlash}
0000000000000000000000000000000000000000;;		r.routes = append(r.routes, route)
0000000000000000000000000000000000000000;;		return route
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle registers a new route with a matcher for the URL path.
0000000000000000000000000000000000000000;;	// See Route.Path() and Route.Handler().
0000000000000000000000000000000000000000;;	func (r *Router) Handle(path string, handler http.Handler) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Path(path).Handler(handler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleFunc registers a new route with a matcher for the URL path.
0000000000000000000000000000000000000000;;	// See Route.Path() and Route.HandlerFunc().
0000000000000000000000000000000000000000;;	func (r *Router) HandleFunc(path string, f func(http.ResponseWriter,
0000000000000000000000000000000000000000;;		*http.Request)) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Path(path).HandlerFunc(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Headers registers a new route with a matcher for request header values.
0000000000000000000000000000000000000000;;	// See Route.Headers().
0000000000000000000000000000000000000000;;	func (r *Router) Headers(pairs ...string) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Headers(pairs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Host registers a new route with a matcher for the URL host.
0000000000000000000000000000000000000000;;	// See Route.Host().
0000000000000000000000000000000000000000;;	func (r *Router) Host(tpl string) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Host(tpl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MatcherFunc registers a new route with a custom matcher function.
0000000000000000000000000000000000000000;;	// See Route.MatcherFunc().
0000000000000000000000000000000000000000;;	func (r *Router) MatcherFunc(f MatcherFunc) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().MatcherFunc(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Methods registers a new route with a matcher for HTTP methods.
0000000000000000000000000000000000000000;;	// See Route.Methods().
0000000000000000000000000000000000000000;;	func (r *Router) Methods(methods ...string) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Methods(methods...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Path registers a new route with a matcher for the URL path.
0000000000000000000000000000000000000000;;	// See Route.Path().
0000000000000000000000000000000000000000;;	func (r *Router) Path(tpl string) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Path(tpl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PathPrefix registers a new route with a matcher for the URL path prefix.
0000000000000000000000000000000000000000;;	// See Route.PathPrefix().
0000000000000000000000000000000000000000;;	func (r *Router) PathPrefix(tpl string) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().PathPrefix(tpl)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Queries registers a new route with a matcher for URL query values.
0000000000000000000000000000000000000000;;	// See Route.Queries().
0000000000000000000000000000000000000000;;	func (r *Router) Queries(pairs ...string) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Queries(pairs...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Schemes registers a new route with a matcher for URL schemes.
0000000000000000000000000000000000000000;;	// See Route.Schemes().
0000000000000000000000000000000000000000;;	func (r *Router) Schemes(schemes ...string) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().Schemes(schemes...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BuildVars registers a new route with a custom function for modifying
0000000000000000000000000000000000000000;;	// route variables before building a URL.
0000000000000000000000000000000000000000;;	func (r *Router) BuildVarsFunc(f BuildVarsFunc) *Route {
0000000000000000000000000000000000000000;;		return r.NewRoute().BuildVarsFunc(f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Context
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RouteMatch stores information about a matched route.
0000000000000000000000000000000000000000;;	type RouteMatch struct {
0000000000000000000000000000000000000000;;		Route   *Route
0000000000000000000000000000000000000000;;		Handler http.Handler
0000000000000000000000000000000000000000;;		Vars    map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type contextKey int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		varsKey contextKey = iota
0000000000000000000000000000000000000000;;		routeKey
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Vars returns the route variables for the current request, if any.
0000000000000000000000000000000000000000;;	func Vars(r *http.Request) map[string]string {
0000000000000000000000000000000000000000;;		if rv := context.Get(r, varsKey); rv != nil {
0000000000000000000000000000000000000000;;			return rv.(map[string]string)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CurrentRoute returns the matched route for the current request, if any.
0000000000000000000000000000000000000000;;	func CurrentRoute(r *http.Request) *Route {
0000000000000000000000000000000000000000;;		if rv := context.Get(r, routeKey); rv != nil {
0000000000000000000000000000000000000000;;			return rv.(*Route)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setVars(r *http.Request, val interface{}) {
0000000000000000000000000000000000000000;;		context.Set(r, varsKey, val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCurrentRoute(r *http.Request, val interface{}) {
0000000000000000000000000000000000000000;;		context.Set(r, routeKey, val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Helpers
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cleanPath returns the canonical path for p, eliminating . and .. elements.
0000000000000000000000000000000000000000;;	// Borrowed from the net/http package.
0000000000000000000000000000000000000000;;	func cleanPath(p string) string {
0000000000000000000000000000000000000000;;		if p == "" {
0000000000000000000000000000000000000000;;			return "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p[0] != '/' {
0000000000000000000000000000000000000000;;			p = "/" + p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		np := path.Clean(p)
0000000000000000000000000000000000000000;;		// path.Clean removes trailing slash except for root;
0000000000000000000000000000000000000000;;		// put the trailing slash back if necessary.
0000000000000000000000000000000000000000;;		if p[len(p)-1] == '/' && np != "/" {
0000000000000000000000000000000000000000;;			np += "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return np
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// uniqueVars returns an error if two slices contain duplicated strings.
0000000000000000000000000000000000000000;;	func uniqueVars(s1, s2 []string) error {
0000000000000000000000000000000000000000;;		for _, v1 := range s1 {
0000000000000000000000000000000000000000;;			for _, v2 := range s2 {
0000000000000000000000000000000000000000;;				if v1 == v2 {
0000000000000000000000000000000000000000;;					return fmt.Errorf("mux: duplicated route variable %q", v2)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// mapFromPairs converts variadic string parameters to a string map.
0000000000000000000000000000000000000000;;	func mapFromPairs(pairs ...string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		length := len(pairs)
0000000000000000000000000000000000000000;;		if length%2 != 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;				"mux: number of parameters must be multiple of 2, got %v", pairs)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := make(map[string]string, length/2)
0000000000000000000000000000000000000000;;		for i := 0; i < length; i += 2 {
0000000000000000000000000000000000000000;;			m[pairs[i]] = pairs[i+1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchInArray returns true if the given string value is in the array.
0000000000000000000000000000000000000000;;	func matchInArray(arr []string, value string) bool {
0000000000000000000000000000000000000000;;		for _, v := range arr {
0000000000000000000000000000000000000000;;			if v == value {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// matchMap returns true if the given key/value pairs exist in a given map.
0000000000000000000000000000000000000000;;	func matchMap(toCheck map[string]string, toMatch map[string][]string,
0000000000000000000000000000000000000000;;		canonicalKey bool) bool {
0000000000000000000000000000000000000000;;		for k, v := range toCheck {
0000000000000000000000000000000000000000;;			// Check if key exists.
0000000000000000000000000000000000000000;;			if canonicalKey {
0000000000000000000000000000000000000000;;				k = http.CanonicalHeaderKey(k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if values := toMatch[k]; values == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			} else if v != "" {
0000000000000000000000000000000000000000;;				// If value was defined as an empty string we only check that the
0000000000000000000000000000000000000000;;				// key exists. Otherwise we also check for equality.
0000000000000000000000000000000000000000;;				valueExists := false
0000000000000000000000000000000000000000;;				for _, value := range values {
0000000000000000000000000000000000000000;;					if v == value {
0000000000000000000000000000000000000000;;						valueExists = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !valueExists {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
