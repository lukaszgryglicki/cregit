0000000000000000000000000000000000000000;;	// Copyright 2012 The Gorilla Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/gorilla/mux/regexp.go[Godeps/_workspace/src/github.com/gorilla/mux/regexp.go][vendor/github.com/gorilla/mux/regexp.go];	
0000000000000000000000000000000000000000;;	package mux
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newRouteRegexp parses a route template and returns a routeRegexp,
0000000000000000000000000000000000000000;;	// used to match a host, a path or a query string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It will extract named variables, assemble a regexp to be matched, create
0000000000000000000000000000000000000000;;	// a "reverse" template to build URLs and compile regexps to validate variable
0000000000000000000000000000000000000000;;	// values used in URL building.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Previously we accepted only Python-like identifiers for variable
0000000000000000000000000000000000000000;;	// names ([a-zA-Z_][a-zA-Z0-9_]*), but currently the only restriction is that
0000000000000000000000000000000000000000;;	// name and pattern can't be empty, and names can't contain a colon.
0000000000000000000000000000000000000000;;	func newRouteRegexp(tpl string, matchHost, matchPrefix, matchQuery, strictSlash bool) (*routeRegexp, error) {
0000000000000000000000000000000000000000;;		// Check if it is well-formed.
0000000000000000000000000000000000000000;;		idxs, errBraces := braceIndices(tpl)
0000000000000000000000000000000000000000;;		if errBraces != nil {
0000000000000000000000000000000000000000;;			return nil, errBraces
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Backup the original.
0000000000000000000000000000000000000000;;		template := tpl
0000000000000000000000000000000000000000;;		// Now let's parse it.
0000000000000000000000000000000000000000;;		defaultPattern := "[^/]+"
0000000000000000000000000000000000000000;;		if matchQuery {
0000000000000000000000000000000000000000;;			defaultPattern = "[^?&]+"
0000000000000000000000000000000000000000;;			matchPrefix = true
0000000000000000000000000000000000000000;;		} else if matchHost {
0000000000000000000000000000000000000000;;			defaultPattern = "[^.]+"
0000000000000000000000000000000000000000;;			matchPrefix = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Only match strict slash if not matching
0000000000000000000000000000000000000000;;		if matchPrefix || matchHost || matchQuery {
0000000000000000000000000000000000000000;;			strictSlash = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Set a flag for strictSlash.
0000000000000000000000000000000000000000;;		endSlash := false
0000000000000000000000000000000000000000;;		if strictSlash && strings.HasSuffix(tpl, "/") {
0000000000000000000000000000000000000000;;			tpl = tpl[:len(tpl)-1]
0000000000000000000000000000000000000000;;			endSlash = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		varsN := make([]string, len(idxs)/2)
0000000000000000000000000000000000000000;;		varsR := make([]*regexp.Regexp, len(idxs)/2)
0000000000000000000000000000000000000000;;		pattern := bytes.NewBufferString("")
0000000000000000000000000000000000000000;;		if !matchQuery {
0000000000000000000000000000000000000000;;			pattern.WriteByte('^')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reverse := bytes.NewBufferString("")
0000000000000000000000000000000000000000;;		var end int
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := 0; i < len(idxs); i += 2 {
0000000000000000000000000000000000000000;;			// Set all values we are interested in.
0000000000000000000000000000000000000000;;			raw := tpl[end:idxs[i]]
0000000000000000000000000000000000000000;;			end = idxs[i+1]
0000000000000000000000000000000000000000;;			parts := strings.SplitN(tpl[idxs[i]+1:end-1], ":", 2)
0000000000000000000000000000000000000000;;			name := parts[0]
0000000000000000000000000000000000000000;;			patt := defaultPattern
0000000000000000000000000000000000000000;;			if len(parts) == 2 {
0000000000000000000000000000000000000000;;				patt = parts[1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Name or pattern can't be empty.
0000000000000000000000000000000000000000;;			if name == "" || patt == "" {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("mux: missing name or pattern in %q",
0000000000000000000000000000000000000000;;					tpl[idxs[i]:end])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Build the regexp pattern.
0000000000000000000000000000000000000000;;			fmt.Fprintf(pattern, "%s(%s)", regexp.QuoteMeta(raw), patt)
0000000000000000000000000000000000000000;;			// Build the reverse template.
0000000000000000000000000000000000000000;;			fmt.Fprintf(reverse, "%s%%s", raw)
0000000000000000000000000000000000000000;;			// Append variable name and compiled pattern.
0000000000000000000000000000000000000000;;			varsN[i/2] = name
0000000000000000000000000000000000000000;;			varsR[i/2], err = regexp.Compile(fmt.Sprintf("^%s$", patt))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Add the remaining.
0000000000000000000000000000000000000000;;		raw := tpl[end:]
0000000000000000000000000000000000000000;;		pattern.WriteString(regexp.QuoteMeta(raw))
0000000000000000000000000000000000000000;;		if strictSlash {
0000000000000000000000000000000000000000;;			pattern.WriteString("[/]?")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !matchPrefix {
0000000000000000000000000000000000000000;;			pattern.WriteByte('$')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reverse.WriteString(raw)
0000000000000000000000000000000000000000;;		if endSlash {
0000000000000000000000000000000000000000;;			reverse.WriteByte('/')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Compile full regexp.
0000000000000000000000000000000000000000;;		reg, errCompile := regexp.Compile(pattern.String())
0000000000000000000000000000000000000000;;		if errCompile != nil {
0000000000000000000000000000000000000000;;			return nil, errCompile
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Done!
0000000000000000000000000000000000000000;;		return &routeRegexp{
0000000000000000000000000000000000000000;;			template:    template,
0000000000000000000000000000000000000000;;			matchHost:   matchHost,
0000000000000000000000000000000000000000;;			matchQuery:  matchQuery,
0000000000000000000000000000000000000000;;			strictSlash: strictSlash,
0000000000000000000000000000000000000000;;			regexp:      reg,
0000000000000000000000000000000000000000;;			reverse:     reverse.String(),
0000000000000000000000000000000000000000;;			varsN:       varsN,
0000000000000000000000000000000000000000;;			varsR:       varsR,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// routeRegexp stores a regexp to match a host or path and information to
0000000000000000000000000000000000000000;;	// collect and validate route variables.
0000000000000000000000000000000000000000;;	type routeRegexp struct {
0000000000000000000000000000000000000000;;		// The unmodified template.
0000000000000000000000000000000000000000;;		template string
0000000000000000000000000000000000000000;;		// True for host match, false for path or query string match.
0000000000000000000000000000000000000000;;		matchHost bool
0000000000000000000000000000000000000000;;		// True for query string match, false for path and host match.
0000000000000000000000000000000000000000;;		matchQuery bool
0000000000000000000000000000000000000000;;		// The strictSlash value defined on the route, but disabled if PathPrefix was used.
0000000000000000000000000000000000000000;;		strictSlash bool
0000000000000000000000000000000000000000;;		// Expanded regexp.
0000000000000000000000000000000000000000;;		regexp *regexp.Regexp
0000000000000000000000000000000000000000;;		// Reverse template.
0000000000000000000000000000000000000000;;		reverse string
0000000000000000000000000000000000000000;;		// Variable names.
0000000000000000000000000000000000000000;;		varsN []string
0000000000000000000000000000000000000000;;		// Variable regexps (validators).
0000000000000000000000000000000000000000;;		varsR []*regexp.Regexp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match matches the regexp against the URL host or path.
0000000000000000000000000000000000000000;;	func (r *routeRegexp) Match(req *http.Request, match *RouteMatch) bool {
0000000000000000000000000000000000000000;;		if !r.matchHost {
0000000000000000000000000000000000000000;;			if r.matchQuery {
0000000000000000000000000000000000000000;;				return r.regexp.MatchString(req.URL.RawQuery)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return r.regexp.MatchString(req.URL.Path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.regexp.MatchString(getHost(req))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// url builds a URL part using the given values.
0000000000000000000000000000000000000000;;	func (r *routeRegexp) url(values map[string]string) (string, error) {
0000000000000000000000000000000000000000;;		urlValues := make([]interface{}, len(r.varsN))
0000000000000000000000000000000000000000;;		for k, v := range r.varsN {
0000000000000000000000000000000000000000;;			value, ok := values[v]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return "", fmt.Errorf("mux: missing route variable %q", v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			urlValues[k] = value
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rv := fmt.Sprintf(r.reverse, urlValues...)
0000000000000000000000000000000000000000;;		if !r.regexp.MatchString(rv) {
0000000000000000000000000000000000000000;;			// The URL is checked against the full regexp, instead of checking
0000000000000000000000000000000000000000;;			// individual variables. This is faster but to provide a good error
0000000000000000000000000000000000000000;;			// message, we check individual regexps if the URL doesn't match.
0000000000000000000000000000000000000000;;			for k, v := range r.varsN {
0000000000000000000000000000000000000000;;				if !r.varsR[k].MatchString(values[v]) {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf(
0000000000000000000000000000000000000000;;						"mux: variable %q doesn't match, expected %q", values[v],
0000000000000000000000000000000000000000;;						r.varsR[k].String())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// braceIndices returns the first level curly brace indices from a string.
0000000000000000000000000000000000000000;;	// It returns an error in case of unbalanced braces.
0000000000000000000000000000000000000000;;	func braceIndices(s string) ([]int, error) {
0000000000000000000000000000000000000000;;		var level, idx int
0000000000000000000000000000000000000000;;		idxs := make([]int, 0)
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			switch s[i] {
0000000000000000000000000000000000000000;;			case '{':
0000000000000000000000000000000000000000;;				if level++; level == 1 {
0000000000000000000000000000000000000000;;					idx = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '}':
0000000000000000000000000000000000000000;;				if level--; level == 0 {
0000000000000000000000000000000000000000;;					idxs = append(idxs, idx, i+1)
0000000000000000000000000000000000000000;;				} else if level < 0 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("mux: unbalanced braces in %q", s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if level != 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("mux: unbalanced braces in %q", s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return idxs, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// routeRegexpGroup
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// routeRegexpGroup groups the route matchers that carry variables.
0000000000000000000000000000000000000000;;	type routeRegexpGroup struct {
0000000000000000000000000000000000000000;;		host    *routeRegexp
0000000000000000000000000000000000000000;;		path    *routeRegexp
0000000000000000000000000000000000000000;;		queries []*routeRegexp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setMatch extracts the variables from the URL once a route matches.
0000000000000000000000000000000000000000;;	func (v *routeRegexpGroup) setMatch(req *http.Request, m *RouteMatch, r *Route) {
0000000000000000000000000000000000000000;;		// Store host variables.
0000000000000000000000000000000000000000;;		if v.host != nil {
0000000000000000000000000000000000000000;;			hostVars := v.host.regexp.FindStringSubmatch(getHost(req))
0000000000000000000000000000000000000000;;			if hostVars != nil {
0000000000000000000000000000000000000000;;				for k, v := range v.host.varsN {
0000000000000000000000000000000000000000;;					m.Vars[v] = hostVars[k+1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Store path variables.
0000000000000000000000000000000000000000;;		if v.path != nil {
0000000000000000000000000000000000000000;;			pathVars := v.path.regexp.FindStringSubmatch(req.URL.Path)
0000000000000000000000000000000000000000;;			if pathVars != nil {
0000000000000000000000000000000000000000;;				for k, v := range v.path.varsN {
0000000000000000000000000000000000000000;;					m.Vars[v] = pathVars[k+1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Check if we should redirect.
0000000000000000000000000000000000000000;;				if v.path.strictSlash {
0000000000000000000000000000000000000000;;					p1 := strings.HasSuffix(req.URL.Path, "/")
0000000000000000000000000000000000000000;;					p2 := strings.HasSuffix(v.path.template, "/")
0000000000000000000000000000000000000000;;					if p1 != p2 {
0000000000000000000000000000000000000000;;						u, _ := url.Parse(req.URL.String())
0000000000000000000000000000000000000000;;						if p1 {
0000000000000000000000000000000000000000;;							u.Path = u.Path[:len(u.Path)-1]
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							u.Path += "/"
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						m.Handler = http.RedirectHandler(u.String(), 301)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Store query string variables.
0000000000000000000000000000000000000000;;		rawQuery := req.URL.RawQuery
0000000000000000000000000000000000000000;;		for _, q := range v.queries {
0000000000000000000000000000000000000000;;			queryVars := q.regexp.FindStringSubmatch(rawQuery)
0000000000000000000000000000000000000000;;			if queryVars != nil {
0000000000000000000000000000000000000000;;				for k, v := range q.varsN {
0000000000000000000000000000000000000000;;					m.Vars[v] = queryVars[k+1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getHost tries its best to return the request host.
0000000000000000000000000000000000000000;;	func getHost(r *http.Request) string {
0000000000000000000000000000000000000000;;		if r.URL.IsAbs() {
0000000000000000000000000000000000000000;;			return r.URL.Host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		host := r.Host
0000000000000000000000000000000000000000;;		// Slice off any port information.
0000000000000000000000000000000000000000;;		if i := strings.Index(host, ":"); i != -1 {
0000000000000000000000000000000000000000;;			host = host[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return host
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
