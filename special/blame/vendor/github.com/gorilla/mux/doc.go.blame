0000000000000000000000000000000000000000;;	// Copyright 2012 The Gorilla Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/gorilla/mux/doc.go[Godeps/_workspace/src/github.com/gorilla/mux/doc.go][vendor/github.com/gorilla/mux/doc.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package gorilla/mux implements a request router and dispatcher.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The name mux stands for "HTTP request multiplexer". Like the standard
0000000000000000000000000000000000000000;;	http.ServeMux, mux.Router matches incoming requests against a list of
0000000000000000000000000000000000000000;;	registered routes and calls a handler for the route that matches the URL
0000000000000000000000000000000000000000;;	or other conditions. The main features are:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		* Requests can be matched based on URL host, path, path prefix, schemes,
0000000000000000000000000000000000000000;;		  header and query values, HTTP methods or using custom matchers.
0000000000000000000000000000000000000000;;		* URL hosts and paths can have variables with an optional regular
0000000000000000000000000000000000000000;;		  expression.
0000000000000000000000000000000000000000;;		* Registered URLs can be built, or "reversed", which helps maintaining
0000000000000000000000000000000000000000;;		  references to resources.
0000000000000000000000000000000000000000;;		* Routes can be used as subrouters: nested routes are only tested if the
0000000000000000000000000000000000000000;;		  parent route matches. This is useful to define groups of routes that
0000000000000000000000000000000000000000;;		  share common conditions like a host, a path prefix or other repeated
0000000000000000000000000000000000000000;;		  attributes. As a bonus, this optimizes request matching.
0000000000000000000000000000000000000000;;		* It implements the http.Handler interface so it is compatible with the
0000000000000000000000000000000000000000;;		  standard http.ServeMux.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Let's start registering a couple of URL paths and handlers:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func main() {
0000000000000000000000000000000000000000;;			r := mux.NewRouter()
0000000000000000000000000000000000000000;;			r.HandleFunc("/", HomeHandler)
0000000000000000000000000000000000000000;;			r.HandleFunc("/products", ProductsHandler)
0000000000000000000000000000000000000000;;			r.HandleFunc("/articles", ArticlesHandler)
0000000000000000000000000000000000000000;;			http.Handle("/", r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here we register three routes mapping URL paths to handlers. This is
0000000000000000000000000000000000000000;;	equivalent to how http.HandleFunc() works: if an incoming request URL matches
0000000000000000000000000000000000000000;;	one of the paths, the corresponding handler is called passing
0000000000000000000000000000000000000000;;	(http.ResponseWriter, *http.Request) as parameters.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Paths can have variables. They are defined using the format {name} or
0000000000000000000000000000000000000000;;	{name:pattern}. If a regular expression pattern is not defined, the matched
0000000000000000000000000000000000000000;;	variable will be anything until the next slash. For example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := mux.NewRouter()
0000000000000000000000000000000000000000;;		r.HandleFunc("/products/{key}", ProductHandler)
0000000000000000000000000000000000000000;;		r.HandleFunc("/articles/{category}/", ArticlesCategoryHandler)
0000000000000000000000000000000000000000;;		r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The names are used to create a map of route variables which can be retrieved
0000000000000000000000000000000000000000;;	calling mux.Vars():
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		vars := mux.Vars(request)
0000000000000000000000000000000000000000;;		category := vars["category"]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	And this is all you need to know about the basic usage. More advanced options
0000000000000000000000000000000000000000;;	are explained below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Routes can also be restricted to a domain or subdomain. Just define a host
0000000000000000000000000000000000000000;;	pattern to be matched. They can also have variables:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := mux.NewRouter()
0000000000000000000000000000000000000000;;		// Only matches if domain is "www.domain.com".
0000000000000000000000000000000000000000;;		r.Host("www.domain.com")
0000000000000000000000000000000000000000;;		// Matches a dynamic subdomain.
0000000000000000000000000000000000000000;;		r.Host("{subdomain:[a-z]+}.domain.com")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There are several other matchers that can be added. To match path prefixes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.PathPrefix("/products/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...or HTTP methods:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Methods("GET", "POST")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...or URL schemes:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Schemes("https")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...or header values:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Headers("X-Requested-With", "XMLHttpRequest")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...or query values:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Queries("key", "value")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...or to use a custom matcher function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.MatcherFunc(func(r *http.Request, rm *RouteMatch) bool {
0000000000000000000000000000000000000000;;			return r.ProtoMajor == 0
0000000000000000000000000000000000000000;;	    })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...and finally, it is possible to combine several matchers in a single route:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.HandleFunc("/products", ProductsHandler).
0000000000000000000000000000000000000000;;		  Host("www.domain.com").
0000000000000000000000000000000000000000;;		  Methods("GET").
0000000000000000000000000000000000000000;;		  Schemes("http")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Setting the same matching conditions again and again can be boring, so we have
0000000000000000000000000000000000000000;;	a way to group several routes that share the same requirements.
0000000000000000000000000000000000000000;;	We call it "subrouting".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example, let's say we have several URLs that should only match when the
0000000000000000000000000000000000000000;;	host is "www.domain.com". Create a route for that host and get a "subrouter"
0000000000000000000000000000000000000000;;	from it:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := mux.NewRouter()
0000000000000000000000000000000000000000;;		s := r.Host("www.domain.com").Subrouter()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then register routes in the subrouter:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.HandleFunc("/products/", ProductsHandler)
0000000000000000000000000000000000000000;;		s.HandleFunc("/products/{key}", ProductHandler)
0000000000000000000000000000000000000000;;		s.HandleFunc("/articles/{category}/{id:[0-9]+}"), ArticleHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The three URL paths we registered above will only be tested if the domain is
0000000000000000000000000000000000000000;;	"www.domain.com", because the subrouter is tested first. This is not
0000000000000000000000000000000000000000;;	only convenient, but also optimizes request matching. You can create
0000000000000000000000000000000000000000;;	subrouters combining any attribute matchers accepted by a route.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Subrouters can be used to create domain or path "namespaces": you define
0000000000000000000000000000000000000000;;	subrouters in a central place and then parts of the app can register its
0000000000000000000000000000000000000000;;	paths relatively to a given subrouter.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There's one more thing about subroutes. When a subrouter has a path prefix,
0000000000000000000000000000000000000000;;	the inner routes use it as base for their paths:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := mux.NewRouter()
0000000000000000000000000000000000000000;;		s := r.PathPrefix("/products").Subrouter()
0000000000000000000000000000000000000000;;		// "/products/"
0000000000000000000000000000000000000000;;		s.HandleFunc("/", ProductsHandler)
0000000000000000000000000000000000000000;;		// "/products/{key}/"
0000000000000000000000000000000000000000;;		s.HandleFunc("/{key}/", ProductHandler)
0000000000000000000000000000000000000000;;		// "/products/{key}/details"
0000000000000000000000000000000000000000;;		s.HandleFunc("/{key}/details", ProductDetailsHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Now let's see how to build registered URLs.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Routes can be named. All routes that define a name can have their URLs built,
0000000000000000000000000000000000000000;;	or "reversed". We define a name calling Name() on a route. For example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := mux.NewRouter()
0000000000000000000000000000000000000000;;		r.HandleFunc("/articles/{category}/{id:[0-9]+}", ArticleHandler).
0000000000000000000000000000000000000000;;		  Name("article")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To build a URL, get the route and call the URL() method, passing a sequence of
0000000000000000000000000000000000000000;;	key/value pairs for the route variables. For the previous route, we would do:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url, err := r.Get("article").URL("category", "technology", "id", "42")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...and the result will be a url.URL with the following path:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"/articles/technology/42"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This also works for host variables:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := mux.NewRouter()
0000000000000000000000000000000000000000;;		r.Host("{subdomain}.domain.com").
0000000000000000000000000000000000000000;;		  Path("/articles/{category}/{id:[0-9]+}").
0000000000000000000000000000000000000000;;		  HandlerFunc(ArticleHandler).
0000000000000000000000000000000000000000;;		  Name("article")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// url.String() will be "http://news.domain.com/articles/technology/42"
0000000000000000000000000000000000000000;;		url, err := r.Get("article").URL("subdomain", "news",
0000000000000000000000000000000000000000;;										 "category", "technology",
0000000000000000000000000000000000000000;;										 "id", "42")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	All variables defined in the route are required, and their values must
0000000000000000000000000000000000000000;;	conform to the corresponding patterns. These requirements guarantee that a
0000000000000000000000000000000000000000;;	generated URL will always match a registered route -- the only exception is
0000000000000000000000000000000000000000;;	for explicitly defined "build-only" routes which never match.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	There's also a way to build only the URL host or path for a route:
0000000000000000000000000000000000000000;;	use the methods URLHost() or URLPath() instead. For the previous route,
0000000000000000000000000000000000000000;;	we would do:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "http://news.domain.com/"
0000000000000000000000000000000000000000;;		host, err := r.Get("article").URLHost("subdomain", "news")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "/articles/technology/42"
0000000000000000000000000000000000000000;;		path, err := r.Get("article").URLPath("category", "technology", "id", "42")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	And if you use subrouters, host and path defined separately can be built
0000000000000000000000000000000000000000;;	as well:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := mux.NewRouter()
0000000000000000000000000000000000000000;;		s := r.Host("{subdomain}.domain.com").Subrouter()
0000000000000000000000000000000000000000;;		s.Path("/articles/{category}/{id:[0-9]+}").
0000000000000000000000000000000000000000;;		  HandlerFunc(ArticleHandler).
0000000000000000000000000000000000000000;;		  Name("article")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// "http://news.domain.com/articles/technology/42"
0000000000000000000000000000000000000000;;		url, err := r.Get("article").URL("subdomain", "news",
0000000000000000000000000000000000000000;;										 "category", "technology",
0000000000000000000000000000000000000000;;										 "id", "42")
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package mux
