0000000000000000000000000000000000000000;;	// Copyright 2012 The Gorilla Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
1112581bf14ecbe49da5663b4a1980f25a695031;Godeps/_workspace/src/github.com/fsouza/go-dockerclient/vendor/github.com/gorilla/context/doc.go[Godeps/_workspace/src/github.com/fsouza/go-dockerclient/vendor/github.com/gorilla/context/doc.go][vendor/github.com/gorilla/context/doc.go];	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package context stores values shared during a request lifetime.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For example, a router can set variables extracted from the URL and later
0000000000000000000000000000000000000000;;	application handlers can access those values, or it can be used to store
0000000000000000000000000000000000000000;;	sessions values to be saved at the end of a request. There are several
0000000000000000000000000000000000000000;;	others common uses.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The idea was posted by Brad Fitzpatrick to the go-nuts mailing list:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		http://groups.google.com/group/golang-nuts/msg/e2d679d303aa5d53
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here's the basic usage: first define the keys that you will need. The key
0000000000000000000000000000000000000000;;	type is interface{} so a key can be of any type that supports equality.
0000000000000000000000000000000000000000;;	Here we define a key using a custom int type to avoid name collisions:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		package foo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		import (
0000000000000000000000000000000000000000;;			"github.com/gorilla/context"
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type key int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const MyKey key = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then set a variable. Variables are bound to an http.Request object, so you
0000000000000000000000000000000000000000;;	need a request instance to set a value:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context.Set(r, MyKey, "bar")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The application can later access the variable using the same key you provided:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func MyHandler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;			// val is "bar".
0000000000000000000000000000000000000000;;			val := context.Get(r, foo.MyKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// returns ("bar", true)
0000000000000000000000000000000000000000;;			val, ok := context.GetOk(r, foo.MyKey)
0000000000000000000000000000000000000000;;			// ...
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	And that's all about the basic usage. We discuss some other ideas below.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Any type can be stored in the context. To enforce a given type, make the key
0000000000000000000000000000000000000000;;	private and wrap Get() and Set() to accept and return values of a specific
0000000000000000000000000000000000000000;;	type:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type key int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const mykey key = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// GetMyKey returns a value for this package from the request values.
0000000000000000000000000000000000000000;;		func GetMyKey(r *http.Request) SomeType {
0000000000000000000000000000000000000000;;			if rv := context.Get(r, mykey); rv != nil {
0000000000000000000000000000000000000000;;				return rv.(SomeType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SetMyKey sets a value for this package in the request values.
0000000000000000000000000000000000000000;;		func SetMyKey(r *http.Request, val SomeType) {
0000000000000000000000000000000000000000;;			context.Set(r, mykey, val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Variables must be cleared at the end of a request, to remove all values
0000000000000000000000000000000000000000;;	that were stored. This can be done in an http.Handler, after a request was
0000000000000000000000000000000000000000;;	served. Just call Clear() passing the request:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		context.Clear(r)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	...or use ClearHandler(), which conveniently wraps an http.Handler to clear
0000000000000000000000000000000000000000;;	variables at the end of a request lifetime.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The Routers from the packages gorilla/mux and gorilla/pat call Clear()
0000000000000000000000000000000000000000;;	so if you are using either of them you don't need to clear the context manually.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package context
