0000000000000000000000000000000000000000;;	// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
a70eec3531b96f9fd5397f7cec9cd89ffcaafa47;;	
0000000000000000000000000000000000000000;;	// Package websocket implements the WebSocket protocol defined in RFC 6455.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Overview
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Conn type represents a WebSocket connection. A server application uses
0000000000000000000000000000000000000000;;	// the Upgrade function from an Upgrader object with a HTTP request handler
0000000000000000000000000000000000000000;;	// to get a pointer to a Conn:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  var upgrader = websocket.Upgrader{
0000000000000000000000000000000000000000;;	//      ReadBufferSize:  1024,
0000000000000000000000000000000000000000;;	//      WriteBufferSize: 1024,
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  func handler(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;	//      conn, err := upgrader.Upgrade(w, r, nil)
0000000000000000000000000000000000000000;;	//      if err != nil {
0000000000000000000000000000000000000000;;	//          log.Println(err)
0000000000000000000000000000000000000000;;	//          return
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//      ... Use conn to send and receive messages.
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Call the connection's WriteMessage and ReadMessage methods to send and
0000000000000000000000000000000000000000;;	// receive messages as a slice of bytes. This snippet of code shows how to echo
0000000000000000000000000000000000000000;;	// messages using these methods:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  for {
0000000000000000000000000000000000000000;;	//      messageType, p, err := conn.ReadMessage()
0000000000000000000000000000000000000000;;	//      if err != nil {
0000000000000000000000000000000000000000;;	//          return
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//      if err = conn.WriteMessage(messageType, p); err != nil {
0000000000000000000000000000000000000000;;	//          return err
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In above snippet of code, p is a []byte and messageType is an int with value
0000000000000000000000000000000000000000;;	// websocket.BinaryMessage or websocket.TextMessage.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An application can also send and receive messages using the io.WriteCloser
0000000000000000000000000000000000000000;;	// and io.Reader interfaces. To send a message, call the connection NextWriter
0000000000000000000000000000000000000000;;	// method to get an io.WriteCloser, write the message to the writer and close
0000000000000000000000000000000000000000;;	// the writer when done. To receive a message, call the connection NextReader
0000000000000000000000000000000000000000;;	// method to get an io.Reader and read until io.EOF is returned. This snippet
0000000000000000000000000000000000000000;;	// snippet shows how to echo messages using the NextWriter and NextReader
0000000000000000000000000000000000000000;;	// methods:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  for {
0000000000000000000000000000000000000000;;	//      messageType, r, err := conn.NextReader()
0000000000000000000000000000000000000000;;	//      if err != nil {
0000000000000000000000000000000000000000;;	//          return
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//      w, err := conn.NextWriter(messageType)
0000000000000000000000000000000000000000;;	//      if err != nil {
0000000000000000000000000000000000000000;;	//          return err
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//      if _, err := io.Copy(w, r); err != nil {
0000000000000000000000000000000000000000;;	//          return err
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//      if err := w.Close(); err != nil {
0000000000000000000000000000000000000000;;	//          return err
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Data Messages
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The WebSocket protocol distinguishes between text and binary data messages.
0000000000000000000000000000000000000000;;	// Text messages are interpreted as UTF-8 encoded text. The interpretation of
0000000000000000000000000000000000000000;;	// binary messages is left to the application.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This package uses the TextMessage and BinaryMessage integer constants to
0000000000000000000000000000000000000000;;	// identify the two data message types. The ReadMessage and NextReader methods
0000000000000000000000000000000000000000;;	// return the type of the received message. The messageType argument to the
0000000000000000000000000000000000000000;;	// WriteMessage and NextWriter methods specifies the type of a sent message.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It is the application's responsibility to ensure that text messages are
0000000000000000000000000000000000000000;;	// valid UTF-8 encoded text.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Control Messages
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The WebSocket protocol defines three types of control messages: close, ping
0000000000000000000000000000000000000000;;	// and pong. Call the connection WriteControl, WriteMessage or NextWriter
0000000000000000000000000000000000000000;;	// methods to send a control message to the peer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Connections handle received ping and pong messages by invoking a callback
0000000000000000000000000000000000000000;;	// function set with SetPingHandler and SetPongHandler methods. These callback
0000000000000000000000000000000000000000;;	// functions can be invoked from the ReadMessage method, the NextReader method
0000000000000000000000000000000000000000;;	// or from a call to the data message reader returned from NextReader.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Connections handle received close messages by returning an error from the
0000000000000000000000000000000000000000;;	// ReadMessage method, the NextReader method or from a call to the data message
0000000000000000000000000000000000000000;;	// reader returned from NextReader.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Concurrency
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Connections do not support concurrent calls to the write methods
0000000000000000000000000000000000000000;;	// (NextWriter, SetWriteDeadline, WriteMessage) or concurrent calls to the read
0000000000000000000000000000000000000000;;	// methods methods (NextReader, SetReadDeadline, ReadMessage).  Connections do
0000000000000000000000000000000000000000;;	// support a concurrent reader and writer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Close and WriteControl methods can be called concurrently with all other
0000000000000000000000000000000000000000;;	// methods.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Read is Required
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The application must read the connection to process ping and close messages
0000000000000000000000000000000000000000;;	// sent from the peer. If the application is not otherwise interested in
0000000000000000000000000000000000000000;;	// messages from the peer, then the application should start a goroutine to read
0000000000000000000000000000000000000000;;	// and discard messages from the peer. A simple example is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//  func readLoop(c *websocket.Conn) {
0000000000000000000000000000000000000000;;	//      for {
0000000000000000000000000000000000000000;;	//          if _, _, err := c.NextReader(); err != nil {
0000000000000000000000000000000000000000;;	//              c.Close()
0000000000000000000000000000000000000000;;	//              break
0000000000000000000000000000000000000000;;	//          }
0000000000000000000000000000000000000000;;	//      }
0000000000000000000000000000000000000000;;	//  }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Origin Considerations
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Web browsers allow Javascript applications to open a WebSocket connection to
0000000000000000000000000000000000000000;;	// any host. It's up to the server to enforce an origin policy using the Origin
0000000000000000000000000000000000000000;;	// request header sent by the browser.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Upgrader calls the function specified in the CheckOrigin field to check
0000000000000000000000000000000000000000;;	// the origin. If the CheckOrigin function returns false, then the Upgrade
0000000000000000000000000000000000000000;;	// method fails the WebSocket handshake with HTTP status 403.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the CheckOrigin field is nil, then the Upgrader uses a safe default: fail
0000000000000000000000000000000000000000;;	// the handshake if the Origin request header is present and not equal to the
0000000000000000000000000000000000000000;;	// Host request header.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An application can allow connections from any origin by specifying a
0000000000000000000000000000000000000000;;	// function that always returns true:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    var upgrader = websocket.Upgrader{
0000000000000000000000000000000000000000;;	//      CheckOrigin: func(r *http.Request) bool { return true },
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The deprecated Upgrade function does not enforce an origin policy. It's the
0000000000000000000000000000000000000000;;	// application's responsibility to check the Origin header before calling
0000000000000000000000000000000000000000;;	// Upgrade.
0000000000000000000000000000000000000000;;	package websocket
