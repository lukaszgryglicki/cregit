0000000000000000000000000000000000000000;;	// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
a70eec3531b96f9fd5397f7cec9cd89ffcaafa47;;	
0000000000000000000000000000000000000000;;	package websocket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandshakeError describes an error with the handshake from the peer.
0000000000000000000000000000000000000000;;	type HandshakeError struct {
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e HandshakeError) Error() string { return e.message }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Upgrader specifies parameters for upgrading an HTTP connection to a
0000000000000000000000000000000000000000;;	// WebSocket connection.
0000000000000000000000000000000000000000;;	type Upgrader struct {
0000000000000000000000000000000000000000;;		// HandshakeTimeout specifies the duration for the handshake to complete.
0000000000000000000000000000000000000000;;		HandshakeTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReadBufferSize and WriteBufferSize specify I/O buffer sizes. If a buffer
0000000000000000000000000000000000000000;;		// size is zero, then a default value of 4096 is used. The I/O buffer sizes
0000000000000000000000000000000000000000;;		// do not limit the size of the messages that can be sent or received.
0000000000000000000000000000000000000000;;		ReadBufferSize, WriteBufferSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Subprotocols specifies the server's supported protocols in order of
0000000000000000000000000000000000000000;;		// preference. If this field is set, then the Upgrade method negotiates a
0000000000000000000000000000000000000000;;		// subprotocol by selecting the first match in this list with a protocol
0000000000000000000000000000000000000000;;		// requested by the client.
0000000000000000000000000000000000000000;;		Subprotocols []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error specifies the function for generating HTTP error responses. If Error
0000000000000000000000000000000000000000;;		// is nil, then http.Error is used to generate the HTTP response.
0000000000000000000000000000000000000000;;		Error func(w http.ResponseWriter, r *http.Request, status int, reason error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CheckOrigin returns true if the request Origin header is acceptable. If
0000000000000000000000000000000000000000;;		// CheckOrigin is nil, the host in the Origin header must not be set or
0000000000000000000000000000000000000000;;		// must match the host of the request.
0000000000000000000000000000000000000000;;		CheckOrigin func(r *http.Request) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Upgrader) returnError(w http.ResponseWriter, r *http.Request, status int, reason string) (*Conn, error) {
0000000000000000000000000000000000000000;;		err := HandshakeError{reason}
0000000000000000000000000000000000000000;;		if u.Error != nil {
0000000000000000000000000000000000000000;;			u.Error(w, r, status, err)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			http.Error(w, http.StatusText(status), status)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// checkSameOrigin returns true if the origin is not set or is equal to the request host.
0000000000000000000000000000000000000000;;	func checkSameOrigin(r *http.Request) bool {
0000000000000000000000000000000000000000;;		origin := r.Header["Origin"]
0000000000000000000000000000000000000000;;		if len(origin) == 0 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u, err := url.Parse(origin[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.Host == r.Host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (u *Upgrader) selectSubprotocol(r *http.Request, responseHeader http.Header) string {
0000000000000000000000000000000000000000;;		if u.Subprotocols != nil {
0000000000000000000000000000000000000000;;			clientProtocols := Subprotocols(r)
0000000000000000000000000000000000000000;;			for _, serverProtocol := range u.Subprotocols {
0000000000000000000000000000000000000000;;				for _, clientProtocol := range clientProtocols {
0000000000000000000000000000000000000000;;					if clientProtocol == serverProtocol {
0000000000000000000000000000000000000000;;						return clientProtocol
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if responseHeader != nil {
0000000000000000000000000000000000000000;;			return responseHeader.Get("Sec-Websocket-Protocol")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Upgrade upgrades the HTTP server connection to the WebSocket protocol.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The responseHeader is included in the response to the client's upgrade
0000000000000000000000000000000000000000;;	// request. Use the responseHeader to specify cookies (Set-Cookie) and the
0000000000000000000000000000000000000000;;	// application negotiated subprotocol (Sec-Websocket-Protocol).
0000000000000000000000000000000000000000;;	func (u *Upgrader) Upgrade(w http.ResponseWriter, r *http.Request, responseHeader http.Header) (*Conn, error) {
0000000000000000000000000000000000000000;;		if values := r.Header["Sec-Websocket-Version"]; len(values) == 0 || values[0] != "13" {
0000000000000000000000000000000000000000;;			return u.returnError(w, r, http.StatusBadRequest, "websocket: version != 13")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !tokenListContainsValue(r.Header, "Connection", "upgrade") {
0000000000000000000000000000000000000000;;			return u.returnError(w, r, http.StatusBadRequest, "websocket: could not find connection header with token 'upgrade'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !tokenListContainsValue(r.Header, "Upgrade", "websocket") {
0000000000000000000000000000000000000000;;			return u.returnError(w, r, http.StatusBadRequest, "websocket: could not find upgrade header with token 'websocket'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		checkOrigin := u.CheckOrigin
0000000000000000000000000000000000000000;;		if checkOrigin == nil {
0000000000000000000000000000000000000000;;			checkOrigin = checkSameOrigin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !checkOrigin(r) {
0000000000000000000000000000000000000000;;			return u.returnError(w, r, http.StatusForbidden, "websocket: origin not allowed")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		challengeKey := r.Header.Get("Sec-Websocket-Key")
0000000000000000000000000000000000000000;;		if challengeKey == "" {
0000000000000000000000000000000000000000;;			return u.returnError(w, r, http.StatusBadRequest, "websocket: key missing or blank")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subprotocol := u.selectSubprotocol(r, responseHeader)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			netConn net.Conn
0000000000000000000000000000000000000000;;			br      *bufio.Reader
0000000000000000000000000000000000000000;;			err     error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h, ok := w.(http.Hijacker)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return u.returnError(w, r, http.StatusInternalServerError, "websocket: response does not implement http.Hijacker")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var rw *bufio.ReadWriter
0000000000000000000000000000000000000000;;		netConn, rw, err = h.Hijack()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return u.returnError(w, r, http.StatusInternalServerError, err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		br = rw.Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if br.Buffered() > 0 {
0000000000000000000000000000000000000000;;			netConn.Close()
0000000000000000000000000000000000000000;;			return nil, errors.New("websocket: client sent data before handshake is complete")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := newConn(netConn, true, u.ReadBufferSize, u.WriteBufferSize)
0000000000000000000000000000000000000000;;		c.subprotocol = subprotocol
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p := c.writeBuf[:0]
0000000000000000000000000000000000000000;;		p = append(p, "HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Accept: "...)
0000000000000000000000000000000000000000;;		p = append(p, computeAcceptKey(challengeKey)...)
0000000000000000000000000000000000000000;;		p = append(p, "\r\n"...)
0000000000000000000000000000000000000000;;		if c.subprotocol != "" {
0000000000000000000000000000000000000000;;			p = append(p, "Sec-Websocket-Protocol: "...)
0000000000000000000000000000000000000000;;			p = append(p, c.subprotocol...)
0000000000000000000000000000000000000000;;			p = append(p, "\r\n"...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, vs := range responseHeader {
0000000000000000000000000000000000000000;;			if k == "Sec-Websocket-Protocol" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, v := range vs {
0000000000000000000000000000000000000000;;				p = append(p, k...)
0000000000000000000000000000000000000000;;				p = append(p, ": "...)
0000000000000000000000000000000000000000;;				for i := 0; i < len(v); i++ {
0000000000000000000000000000000000000000;;					b := v[i]
0000000000000000000000000000000000000000;;					if b <= 31 {
0000000000000000000000000000000000000000;;						// prevent response splitting.
0000000000000000000000000000000000000000;;						b = ' '
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p = append(p, b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p = append(p, "\r\n"...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p = append(p, "\r\n"...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Clear deadlines set by HTTP server.
0000000000000000000000000000000000000000;;		netConn.SetDeadline(time.Time{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.HandshakeTimeout > 0 {
0000000000000000000000000000000000000000;;			netConn.SetWriteDeadline(time.Now().Add(u.HandshakeTimeout))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = netConn.Write(p); err != nil {
0000000000000000000000000000000000000000;;			netConn.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.HandshakeTimeout > 0 {
0000000000000000000000000000000000000000;;			netConn.SetWriteDeadline(time.Time{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Upgrade upgrades the HTTP server connection to the WebSocket protocol.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This function is deprecated, use websocket.Upgrader instead.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The application is responsible for checking the request origin before
0000000000000000000000000000000000000000;;	// calling Upgrade. An example implementation of the same origin policy is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	if req.Header.Get("Origin") != "http://"+req.Host {
0000000000000000000000000000000000000000;;	//		http.Error(w, "Origin not allowed", 403)
0000000000000000000000000000000000000000;;	//		return
0000000000000000000000000000000000000000;;	//	}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the endpoint supports subprotocols, then the application is responsible
0000000000000000000000000000000000000000;;	// for negotiating the protocol used on the connection. Use the Subprotocols()
0000000000000000000000000000000000000000;;	// function to get the subprotocols requested by the client. Use the
0000000000000000000000000000000000000000;;	// Sec-Websocket-Protocol response header to specify the subprotocol selected
0000000000000000000000000000000000000000;;	// by the application.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The responseHeader is included in the response to the client's upgrade
0000000000000000000000000000000000000000;;	// request. Use the responseHeader to specify cookies (Set-Cookie) and the
0000000000000000000000000000000000000000;;	// negotiated subprotocol (Sec-Websocket-Protocol).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The connection buffers IO to the underlying network connection. The
0000000000000000000000000000000000000000;;	// readBufSize and writeBufSize parameters specify the size of the buffers to
0000000000000000000000000000000000000000;;	// use. Messages can be larger than the buffers.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the request is not a valid WebSocket handshake, then Upgrade returns an
0000000000000000000000000000000000000000;;	// error of type HandshakeError. Applications should handle this error by
0000000000000000000000000000000000000000;;	// replying to the client with an HTTP error response.
0000000000000000000000000000000000000000;;	func Upgrade(w http.ResponseWriter, r *http.Request, responseHeader http.Header, readBufSize, writeBufSize int) (*Conn, error) {
0000000000000000000000000000000000000000;;		u := Upgrader{ReadBufferSize: readBufSize, WriteBufferSize: writeBufSize}
0000000000000000000000000000000000000000;;		u.Error = func(w http.ResponseWriter, r *http.Request, status int, reason error) {
0000000000000000000000000000000000000000;;			// don't return errors to maintain backwards compatibility
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.CheckOrigin = func(r *http.Request) bool {
0000000000000000000000000000000000000000;;			// allow all connections by default
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u.Upgrade(w, r, responseHeader)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subprotocols returns the subprotocols requested by the client in the
0000000000000000000000000000000000000000;;	// Sec-Websocket-Protocol header.
0000000000000000000000000000000000000000;;	func Subprotocols(r *http.Request) []string {
0000000000000000000000000000000000000000;;		h := strings.TrimSpace(r.Header.Get("Sec-Websocket-Protocol"))
0000000000000000000000000000000000000000;;		if h == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		protocols := strings.Split(h, ",")
0000000000000000000000000000000000000000;;		for i := range protocols {
0000000000000000000000000000000000000000;;			protocols[i] = strings.TrimSpace(protocols[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return protocols
0000000000000000000000000000000000000000;;	}
