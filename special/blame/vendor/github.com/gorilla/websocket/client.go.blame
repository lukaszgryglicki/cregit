0000000000000000000000000000000000000000;;	// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
a70eec3531b96f9fd5397f7cec9cd89ffcaafa47;;	
0000000000000000000000000000000000000000;;	package websocket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrBadHandshake is returned when the server response to opening handshake is
0000000000000000000000000000000000000000;;	// invalid.
0000000000000000000000000000000000000000;;	var ErrBadHandshake = errors.New("websocket: bad handshake")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient creates a new client connection using the given net connection.
0000000000000000000000000000000000000000;;	// The URL u specifies the host and request URI. Use requestHeader to specify
0000000000000000000000000000000000000000;;	// the origin (Origin), subprotocols (Sec-WebSocket-Protocol) and cookies
0000000000000000000000000000000000000000;;	// (Cookie). Use the response.Header to get the selected subprotocol
0000000000000000000000000000000000000000;;	// (Sec-WebSocket-Protocol) and cookies (Set-Cookie).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the WebSocket handshake fails, ErrBadHandshake is returned along with a
0000000000000000000000000000000000000000;;	// non-nil *http.Response so that callers can handle redirects, authentication,
0000000000000000000000000000000000000000;;	// etc.
0000000000000000000000000000000000000000;;	func NewClient(netConn net.Conn, u *url.URL, requestHeader http.Header, readBufSize, writeBufSize int) (c *Conn, response *http.Response, err error) {
0000000000000000000000000000000000000000;;		challengeKey, err := generateChallengeKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		acceptKey := computeAcceptKey(challengeKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c = newConn(netConn, false, readBufSize, writeBufSize)
0000000000000000000000000000000000000000;;		p := c.writeBuf[:0]
0000000000000000000000000000000000000000;;		p = append(p, "GET "...)
0000000000000000000000000000000000000000;;		p = append(p, u.RequestURI()...)
0000000000000000000000000000000000000000;;		p = append(p, " HTTP/1.1\r\nHost: "...)
0000000000000000000000000000000000000000;;		p = append(p, u.Host...)
0000000000000000000000000000000000000000;;		// "Upgrade" is capitalized for servers that do not use case insensitive
0000000000000000000000000000000000000000;;		// comparisons on header tokens.
0000000000000000000000000000000000000000;;		p = append(p, "\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-WebSocket-Version: 13\r\nSec-WebSocket-Key: "...)
0000000000000000000000000000000000000000;;		p = append(p, challengeKey...)
0000000000000000000000000000000000000000;;		p = append(p, "\r\n"...)
0000000000000000000000000000000000000000;;		for k, vs := range requestHeader {
0000000000000000000000000000000000000000;;			for _, v := range vs {
0000000000000000000000000000000000000000;;				p = append(p, k...)
0000000000000000000000000000000000000000;;				p = append(p, ": "...)
0000000000000000000000000000000000000000;;				p = append(p, v...)
0000000000000000000000000000000000000000;;				p = append(p, "\r\n"...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p = append(p, "\r\n"...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, err := netConn.Write(p); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := http.ReadResponse(c.br, &http.Request{Method: "GET", URL: u})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if resp.StatusCode != 101 ||
0000000000000000000000000000000000000000;;			!strings.EqualFold(resp.Header.Get("Upgrade"), "websocket") ||
0000000000000000000000000000000000000000;;			!strings.EqualFold(resp.Header.Get("Connection"), "upgrade") ||
0000000000000000000000000000000000000000;;			resp.Header.Get("Sec-Websocket-Accept") != acceptKey {
0000000000000000000000000000000000000000;;			return nil, resp, ErrBadHandshake
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.subprotocol = resp.Header.Get("Sec-Websocket-Protocol")
0000000000000000000000000000000000000000;;		return c, resp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Dialer contains options for connecting to WebSocket server.
0000000000000000000000000000000000000000;;	type Dialer struct {
0000000000000000000000000000000000000000;;		// NetDial specifies the dial function for creating TCP connections. If
0000000000000000000000000000000000000000;;		// NetDial is nil, net.Dial is used.
0000000000000000000000000000000000000000;;		NetDial func(network, addr string) (net.Conn, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TLSClientConfig specifies the TLS configuration to use with tls.Client.
0000000000000000000000000000000000000000;;		// If nil, the default configuration is used.
0000000000000000000000000000000000000000;;		TLSClientConfig *tls.Config
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HandshakeTimeout specifies the duration for the handshake to complete.
0000000000000000000000000000000000000000;;		HandshakeTimeout time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Input and output buffer sizes. If the buffer size is zero, then a
0000000000000000000000000000000000000000;;		// default value of 4096 is used.
0000000000000000000000000000000000000000;;		ReadBufferSize, WriteBufferSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Subprotocols specifies the client's requested subprotocols.
0000000000000000000000000000000000000000;;		Subprotocols []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errMalformedURL = errors.New("malformed ws or wss URL")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseURL parses the URL. The url.Parse function is not used here because
0000000000000000000000000000000000000000;;	// url.Parse mangles the path.
0000000000000000000000000000000000000000;;	func parseURL(s string) (*url.URL, error) {
0000000000000000000000000000000000000000;;		// From the RFC:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// ws-URI = "ws:" "//" host [ ":" port ] path [ "?" query ]
0000000000000000000000000000000000000000;;		// wss-URI = "wss:" "//" host [ ":" port ] path [ "?" query ]
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We don't use the net/url parser here because the dialer interface does
0000000000000000000000000000000000000000;;		// not provide a way for applications to work around percent deocding in
0000000000000000000000000000000000000000;;		// the net/url parser.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var u url.URL
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case strings.HasPrefix(s, "ws://"):
0000000000000000000000000000000000000000;;			u.Scheme = "ws"
0000000000000000000000000000000000000000;;			s = s[len("ws://"):]
0000000000000000000000000000000000000000;;		case strings.HasPrefix(s, "wss://"):
0000000000000000000000000000000000000000;;			u.Scheme = "wss"
0000000000000000000000000000000000000000;;			s = s[len("wss://"):]
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errMalformedURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u.Host = s
0000000000000000000000000000000000000000;;		u.Opaque = "/"
0000000000000000000000000000000000000000;;		if i := strings.Index(s, "/"); i >= 0 {
0000000000000000000000000000000000000000;;			u.Host = s[:i]
0000000000000000000000000000000000000000;;			u.Opaque = s[i:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.Contains(u.Host, "@") {
0000000000000000000000000000000000000000;;			// WebSocket URIs do not contain user information.
0000000000000000000000000000000000000000;;			return nil, errMalformedURL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &u, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hostPortNoPort(u *url.URL) (hostPort, hostNoPort string) {
0000000000000000000000000000000000000000;;		hostPort = u.Host
0000000000000000000000000000000000000000;;		hostNoPort = u.Host
0000000000000000000000000000000000000000;;		if i := strings.LastIndex(u.Host, ":"); i > strings.LastIndex(u.Host, "]") {
0000000000000000000000000000000000000000;;			hostNoPort = hostNoPort[:i]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if u.Scheme == "wss" {
0000000000000000000000000000000000000000;;				hostPort += ":443"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				hostPort += ":80"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return hostPort, hostNoPort
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultDialer is a dialer with all fields set to the default zero values.
0000000000000000000000000000000000000000;;	var DefaultDialer *Dialer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial creates a new client connection. Use requestHeader to specify the
0000000000000000000000000000000000000000;;	// origin (Origin), subprotocols (Sec-WebSocket-Protocol) and cookies (Cookie).
0000000000000000000000000000000000000000;;	// Use the response.Header to get the selected subprotocol
0000000000000000000000000000000000000000;;	// (Sec-WebSocket-Protocol) and cookies (Set-Cookie).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the WebSocket handshake fails, ErrBadHandshake is returned along with a
0000000000000000000000000000000000000000;;	// non-nil *http.Response so that callers can handle redirects, authentication,
0000000000000000000000000000000000000000;;	// etcetera. The response body may not contain the entire response and does not
0000000000000000000000000000000000000000;;	// need to be closed by the application.
0000000000000000000000000000000000000000;;	func (d *Dialer) Dial(urlStr string, requestHeader http.Header) (*Conn, *http.Response, error) {
0000000000000000000000000000000000000000;;		u, err := parseURL(urlStr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hostPort, hostNoPort := hostPortNoPort(u)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d == nil {
0000000000000000000000000000000000000000;;			d = &Dialer{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var deadline time.Time
0000000000000000000000000000000000000000;;		if d.HandshakeTimeout != 0 {
0000000000000000000000000000000000000000;;			deadline = time.Now().Add(d.HandshakeTimeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netDial := d.NetDial
0000000000000000000000000000000000000000;;		if netDial == nil {
0000000000000000000000000000000000000000;;			netDialer := &net.Dialer{Deadline: deadline}
0000000000000000000000000000000000000000;;			netDial = netDialer.Dial
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netConn, err := netDial("tcp", hostPort)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if netConn != nil {
0000000000000000000000000000000000000000;;				netConn.Close()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := netConn.SetDeadline(deadline); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if u.Scheme == "wss" {
0000000000000000000000000000000000000000;;			cfg := d.TLSClientConfig
0000000000000000000000000000000000000000;;			if cfg == nil {
0000000000000000000000000000000000000000;;				cfg = &tls.Config{ServerName: hostNoPort}
0000000000000000000000000000000000000000;;			} else if cfg.ServerName == "" {
0000000000000000000000000000000000000000;;				shallowCopy := *cfg
0000000000000000000000000000000000000000;;				cfg = &shallowCopy
0000000000000000000000000000000000000000;;				cfg.ServerName = hostNoPort
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tlsConn := tls.Client(netConn, cfg)
0000000000000000000000000000000000000000;;			netConn = tlsConn
0000000000000000000000000000000000000000;;			if err := tlsConn.Handshake(); err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !cfg.InsecureSkipVerify {
0000000000000000000000000000000000000000;;				if err := tlsConn.VerifyHostname(cfg.ServerName); err != nil {
0000000000000000000000000000000000000000;;					return nil, nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(d.Subprotocols) > 0 {
0000000000000000000000000000000000000000;;			h := http.Header{}
0000000000000000000000000000000000000000;;			for k, v := range requestHeader {
0000000000000000000000000000000000000000;;				h[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			h.Set("Sec-Websocket-Protocol", strings.Join(d.Subprotocols, ", "))
0000000000000000000000000000000000000000;;			requestHeader = h
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(requestHeader["Host"]) > 0 {
0000000000000000000000000000000000000000;;			// This can be used to supply a Host: header which is different from
0000000000000000000000000000000000000000;;			// the dial address.
0000000000000000000000000000000000000000;;			u.Host = requestHeader.Get("Host")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Drop "Host" header
0000000000000000000000000000000000000000;;			h := http.Header{}
0000000000000000000000000000000000000000;;			for k, v := range requestHeader {
0000000000000000000000000000000000000000;;				if k == "Host" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				h[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			requestHeader = h
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn, resp, err := NewClient(netConn, u, requestHeader, d.ReadBufferSize, d.WriteBufferSize)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err == ErrBadHandshake {
0000000000000000000000000000000000000000;;				// Before closing the network connection on return from this
0000000000000000000000000000000000000000;;				// function, slurp up some of the response to aid application
0000000000000000000000000000000000000000;;				// debugging.
0000000000000000000000000000000000000000;;				buf := make([]byte, 1024)
0000000000000000000000000000000000000000;;				n, _ := io.ReadFull(resp.Body, buf)
0000000000000000000000000000000000000000;;				resp.Body = ioutil.NopCloser(bytes.NewReader(buf[:n]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, resp, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		netConn.SetDeadline(time.Time{})
0000000000000000000000000000000000000000;;		netConn = nil // to avoid close in defer.
0000000000000000000000000000000000000000;;		return conn, resp, nil
0000000000000000000000000000000000000000;;	}
