0000000000000000000000000000000000000000;;	// Copyright 2013 The Gorilla WebSocket Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
a70eec3531b96f9fd5397f7cec9cd89ffcaafa47;;	
0000000000000000000000000000000000000000;;	package websocket
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		maxFrameHeaderSize         = 2 + 8 + 4 // Fixed header + length + mask
0000000000000000000000000000000000000000;;		maxControlFramePayloadSize = 125
0000000000000000000000000000000000000000;;		finalBit                   = 1 << 7
0000000000000000000000000000000000000000;;		maskBit                    = 1 << 7
0000000000000000000000000000000000000000;;		writeWait                  = time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defaultReadBufferSize  = 4096
0000000000000000000000000000000000000000;;		defaultWriteBufferSize = 4096
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		continuationFrame = 0
0000000000000000000000000000000000000000;;		noFrame           = -1
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close codes defined in RFC 6455, section 11.7.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CloseNormalClosure           = 1000
0000000000000000000000000000000000000000;;		CloseGoingAway               = 1001
0000000000000000000000000000000000000000;;		CloseProtocolError           = 1002
0000000000000000000000000000000000000000;;		CloseUnsupportedData         = 1003
0000000000000000000000000000000000000000;;		CloseNoStatusReceived        = 1005
0000000000000000000000000000000000000000;;		CloseAbnormalClosure         = 1006
0000000000000000000000000000000000000000;;		CloseInvalidFramePayloadData = 1007
0000000000000000000000000000000000000000;;		ClosePolicyViolation         = 1008
0000000000000000000000000000000000000000;;		CloseMessageTooBig           = 1009
0000000000000000000000000000000000000000;;		CloseMandatoryExtension      = 1010
0000000000000000000000000000000000000000;;		CloseInternalServerErr       = 1011
0000000000000000000000000000000000000000;;		CloseTLSHandshake            = 1015
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The message types are defined in RFC 6455, section 11.8.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// TextMessage denotes a text data message. The text message payload is
0000000000000000000000000000000000000000;;		// interpreted as UTF-8 encoded text data.
0000000000000000000000000000000000000000;;		TextMessage = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BinaryMessage denotes a binary data message.
0000000000000000000000000000000000000000;;		BinaryMessage = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// CloseMessage denotes a close control message. The optional message
0000000000000000000000000000000000000000;;		// payload contains a numeric code and text. Use the FormatCloseMessage
0000000000000000000000000000000000000000;;		// function to format a close message payload.
0000000000000000000000000000000000000000;;		CloseMessage = 8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PingMessage denotes a ping control message. The optional message payload
0000000000000000000000000000000000000000;;		// is UTF-8 encoded text.
0000000000000000000000000000000000000000;;		PingMessage = 9
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// PongMessage denotes a ping control message. The optional message payload
0000000000000000000000000000000000000000;;		// is UTF-8 encoded text.
0000000000000000000000000000000000000000;;		PongMessage = 10
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrCloseSent is returned when the application writes a message to the
0000000000000000000000000000000000000000;;	// connection after sending a close message.
0000000000000000000000000000000000000000;;	var ErrCloseSent = errors.New("websocket: close sent")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrReadLimit is returned when reading a message that is larger than the
0000000000000000000000000000000000000000;;	// read limit set for the connection.
0000000000000000000000000000000000000000;;	var ErrReadLimit = errors.New("websocket: read limit exceeded")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// netError satisfies the net Error interface.
0000000000000000000000000000000000000000;;	type netError struct {
0000000000000000000000000000000000000000;;		msg       string
0000000000000000000000000000000000000000;;		temporary bool
0000000000000000000000000000000000000000;;		timeout   bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *netError) Error() string   { return e.msg }
0000000000000000000000000000000000000000;;	func (e *netError) Temporary() bool { return e.temporary }
0000000000000000000000000000000000000000;;	func (e *netError) Timeout() bool   { return e.timeout }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// closeError represents close frame.
0000000000000000000000000000000000000000;;	type closeError struct {
0000000000000000000000000000000000000000;;		code int
0000000000000000000000000000000000000000;;		text string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *closeError) Error() string {
0000000000000000000000000000000000000000;;		return "websocket: close " + strconv.Itoa(e.code) + " " + e.text
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		errWriteTimeout        = &netError{msg: "websocket: write timeout", timeout: true}
0000000000000000000000000000000000000000;;		errUnexpectedEOF       = &closeError{code: CloseAbnormalClosure, text: io.ErrUnexpectedEOF.Error()}
0000000000000000000000000000000000000000;;		errBadWriteOpCode      = errors.New("websocket: bad write message type")
0000000000000000000000000000000000000000;;		errWriteClosed         = errors.New("websocket: write closed")
0000000000000000000000000000000000000000;;		errInvalidControlFrame = errors.New("websocket: invalid control frame")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hideTempErr(err error) error {
0000000000000000000000000000000000000000;;		if e, ok := err.(net.Error); ok && e.Temporary() {
0000000000000000000000000000000000000000;;			err = &netError{msg: e.Error(), timeout: e.Timeout()}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isControl(frameType int) bool {
0000000000000000000000000000000000000000;;		return frameType == CloseMessage || frameType == PingMessage || frameType == PongMessage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isData(frameType int) bool {
0000000000000000000000000000000000000000;;		return frameType == TextMessage || frameType == BinaryMessage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func maskBytes(key [4]byte, pos int, b []byte) int {
0000000000000000000000000000000000000000;;		for i := range b {
0000000000000000000000000000000000000000;;			b[i] ^= key[pos&3]
0000000000000000000000000000000000000000;;			pos++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pos & 3
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMaskKey() [4]byte {
0000000000000000000000000000000000000000;;		n := rand.Uint32()
0000000000000000000000000000000000000000;;		return [4]byte{byte(n), byte(n >> 8), byte(n >> 16), byte(n >> 24)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Conn represents a WebSocket connection.
0000000000000000000000000000000000000000;;	type Conn struct {
0000000000000000000000000000000000000000;;		conn        net.Conn
0000000000000000000000000000000000000000;;		isServer    bool
0000000000000000000000000000000000000000;;		subprotocol string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write fields
0000000000000000000000000000000000000000;;		mu        chan bool // used as mutex to protect write to conn and closeSent
0000000000000000000000000000000000000000;;		closeSent bool      // true if close message was sent
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Message writer fields.
0000000000000000000000000000000000000000;;		writeErr       error
0000000000000000000000000000000000000000;;		writeBuf       []byte // frame is constructed in this buffer.
0000000000000000000000000000000000000000;;		writePos       int    // end of data in writeBuf.
0000000000000000000000000000000000000000;;		writeFrameType int    // type of the current frame.
0000000000000000000000000000000000000000;;		writeSeq       int    // incremented to invalidate message writers.
0000000000000000000000000000000000000000;;		writeDeadline  time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read fields
0000000000000000000000000000000000000000;;		readErr       error
0000000000000000000000000000000000000000;;		br            *bufio.Reader
0000000000000000000000000000000000000000;;		readRemaining int64 // bytes remaining in current frame.
0000000000000000000000000000000000000000;;		readFinal     bool  // true the current message has more frames.
0000000000000000000000000000000000000000;;		readSeq       int   // incremented to invalidate message readers.
0000000000000000000000000000000000000000;;		readLength    int64 // Message size.
0000000000000000000000000000000000000000;;		readLimit     int64 // Maximum message size.
0000000000000000000000000000000000000000;;		readMaskPos   int
0000000000000000000000000000000000000000;;		readMaskKey   [4]byte
0000000000000000000000000000000000000000;;		handlePong    func(string) error
0000000000000000000000000000000000000000;;		handlePing    func(string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newConn(conn net.Conn, isServer bool, readBufferSize, writeBufferSize int) *Conn {
0000000000000000000000000000000000000000;;		mu := make(chan bool, 1)
0000000000000000000000000000000000000000;;		mu <- true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if readBufferSize == 0 {
0000000000000000000000000000000000000000;;			readBufferSize = defaultReadBufferSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if writeBufferSize == 0 {
0000000000000000000000000000000000000000;;			writeBufferSize = defaultWriteBufferSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := &Conn{
0000000000000000000000000000000000000000;;			isServer:       isServer,
0000000000000000000000000000000000000000;;			br:             bufio.NewReaderSize(conn, readBufferSize),
0000000000000000000000000000000000000000;;			conn:           conn,
0000000000000000000000000000000000000000;;			mu:             mu,
0000000000000000000000000000000000000000;;			readFinal:      true,
0000000000000000000000000000000000000000;;			writeBuf:       make([]byte, writeBufferSize+maxFrameHeaderSize),
0000000000000000000000000000000000000000;;			writeFrameType: noFrame,
0000000000000000000000000000000000000000;;			writePos:       maxFrameHeaderSize,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.SetPingHandler(nil)
0000000000000000000000000000000000000000;;		c.SetPongHandler(nil)
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Subprotocol returns the negotiated protocol for the connection.
0000000000000000000000000000000000000000;;	func (c *Conn) Subprotocol() string {
0000000000000000000000000000000000000000;;		return c.subprotocol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the underlying network connection without sending or waiting for a close frame.
0000000000000000000000000000000000000000;;	func (c *Conn) Close() error {
0000000000000000000000000000000000000000;;		return c.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalAddr returns the local network address.
0000000000000000000000000000000000000000;;	func (c *Conn) LocalAddr() net.Addr {
0000000000000000000000000000000000000000;;		return c.conn.LocalAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteAddr returns the remote network address.
0000000000000000000000000000000000000000;;	func (c *Conn) RemoteAddr() net.Addr {
0000000000000000000000000000000000000000;;		return c.conn.RemoteAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write methods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) write(frameType int, deadline time.Time, bufs ...[]byte) error {
0000000000000000000000000000000000000000;;		<-c.mu
0000000000000000000000000000000000000000;;		defer func() { c.mu <- true }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.closeSent {
0000000000000000000000000000000000000000;;			return ErrCloseSent
0000000000000000000000000000000000000000;;		} else if frameType == CloseMessage {
0000000000000000000000000000000000000000;;			c.closeSent = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.conn.SetWriteDeadline(deadline)
0000000000000000000000000000000000000000;;		for _, buf := range bufs {
0000000000000000000000000000000000000000;;			if len(buf) > 0 {
0000000000000000000000000000000000000000;;				n, err := c.conn.Write(buf)
0000000000000000000000000000000000000000;;				if n != len(buf) {
0000000000000000000000000000000000000000;;					// Close on partial write.
0000000000000000000000000000000000000000;;					c.conn.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteControl writes a control message with the given deadline. The allowed
0000000000000000000000000000000000000000;;	// message types are CloseMessage, PingMessage and PongMessage.
0000000000000000000000000000000000000000;;	func (c *Conn) WriteControl(messageType int, data []byte, deadline time.Time) error {
0000000000000000000000000000000000000000;;		if !isControl(messageType) {
0000000000000000000000000000000000000000;;			return errBadWriteOpCode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(data) > maxControlFramePayloadSize {
0000000000000000000000000000000000000000;;			return errInvalidControlFrame
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b0 := byte(messageType) | finalBit
0000000000000000000000000000000000000000;;		b1 := byte(len(data))
0000000000000000000000000000000000000000;;		if !c.isServer {
0000000000000000000000000000000000000000;;			b1 |= maskBit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]byte, 0, maxFrameHeaderSize+maxControlFramePayloadSize)
0000000000000000000000000000000000000000;;		buf = append(buf, b0, b1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.isServer {
0000000000000000000000000000000000000000;;			buf = append(buf, data...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			key := newMaskKey()
0000000000000000000000000000000000000000;;			buf = append(buf, key[:]...)
0000000000000000000000000000000000000000;;			buf = append(buf, data...)
0000000000000000000000000000000000000000;;			maskBytes(key, 0, buf[6:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := time.Hour * 1000
0000000000000000000000000000000000000000;;		if !deadline.IsZero() {
0000000000000000000000000000000000000000;;			d = deadline.Sub(time.Now())
0000000000000000000000000000000000000000;;			if d < 0 {
0000000000000000000000000000000000000000;;				return errWriteTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timer := time.NewTimer(d)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-c.mu:
0000000000000000000000000000000000000000;;			timer.Stop()
0000000000000000000000000000000000000000;;		case <-timer.C:
0000000000000000000000000000000000000000;;			return errWriteTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer func() { c.mu <- true }()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.closeSent {
0000000000000000000000000000000000000000;;			return ErrCloseSent
0000000000000000000000000000000000000000;;		} else if messageType == CloseMessage {
0000000000000000000000000000000000000000;;			c.closeSent = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.conn.SetWriteDeadline(deadline)
0000000000000000000000000000000000000000;;		n, err := c.conn.Write(buf)
0000000000000000000000000000000000000000;;		if n != 0 && n != len(buf) {
0000000000000000000000000000000000000000;;			c.conn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextWriter returns a writer for the next message to send.  The writer's
0000000000000000000000000000000000000000;;	// Close method flushes the complete message to the network.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There can be at most one open writer on a connection. NextWriter closes the
0000000000000000000000000000000000000000;;	// previous writer if the application has not already done so.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The NextWriter method and the writers returned from the method cannot be
0000000000000000000000000000000000000000;;	// accessed by more than one goroutine at a time.
0000000000000000000000000000000000000000;;	func (c *Conn) NextWriter(messageType int) (io.WriteCloser, error) {
0000000000000000000000000000000000000000;;		if c.writeErr != nil {
0000000000000000000000000000000000000000;;			return nil, c.writeErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.writeFrameType != noFrame {
0000000000000000000000000000000000000000;;			if err := c.flushFrame(true, nil); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !isControl(messageType) && !isData(messageType) {
0000000000000000000000000000000000000000;;			return nil, errBadWriteOpCode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.writeFrameType = messageType
0000000000000000000000000000000000000000;;		return messageWriter{c, c.writeSeq}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) flushFrame(final bool, extra []byte) error {
0000000000000000000000000000000000000000;;		length := c.writePos - maxFrameHeaderSize + len(extra)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check for invalid control frames.
0000000000000000000000000000000000000000;;		if isControl(c.writeFrameType) &&
0000000000000000000000000000000000000000;;			(!final || length > maxControlFramePayloadSize) {
0000000000000000000000000000000000000000;;			c.writeSeq++
0000000000000000000000000000000000000000;;			c.writeFrameType = noFrame
0000000000000000000000000000000000000000;;			c.writePos = maxFrameHeaderSize
0000000000000000000000000000000000000000;;			return errInvalidControlFrame
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		b0 := byte(c.writeFrameType)
0000000000000000000000000000000000000000;;		if final {
0000000000000000000000000000000000000000;;			b0 |= finalBit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b1 := byte(0)
0000000000000000000000000000000000000000;;		if !c.isServer {
0000000000000000000000000000000000000000;;			b1 |= maskBit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Assume that the frame starts at beginning of c.writeBuf.
0000000000000000000000000000000000000000;;		framePos := 0
0000000000000000000000000000000000000000;;		if c.isServer {
0000000000000000000000000000000000000000;;			// Adjust up if mask not included in the header.
0000000000000000000000000000000000000000;;			framePos = 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case length >= 65536:
0000000000000000000000000000000000000000;;			c.writeBuf[framePos] = b0
0000000000000000000000000000000000000000;;			c.writeBuf[framePos+1] = b1 | 127
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint64(c.writeBuf[framePos+2:], uint64(length))
0000000000000000000000000000000000000000;;		case length > 125:
0000000000000000000000000000000000000000;;			framePos += 6
0000000000000000000000000000000000000000;;			c.writeBuf[framePos] = b0
0000000000000000000000000000000000000000;;			c.writeBuf[framePos+1] = b1 | 126
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint16(c.writeBuf[framePos+2:], uint16(length))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			framePos += 8
0000000000000000000000000000000000000000;;			c.writeBuf[framePos] = b0
0000000000000000000000000000000000000000;;			c.writeBuf[framePos+1] = b1 | byte(length)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !c.isServer {
0000000000000000000000000000000000000000;;			key := newMaskKey()
0000000000000000000000000000000000000000;;			copy(c.writeBuf[maxFrameHeaderSize-4:], key[:])
0000000000000000000000000000000000000000;;			maskBytes(key, 0, c.writeBuf[maxFrameHeaderSize:c.writePos])
0000000000000000000000000000000000000000;;			if len(extra) > 0 {
0000000000000000000000000000000000000000;;				c.writeErr = errors.New("websocket: internal error, extra used in client mode")
0000000000000000000000000000000000000000;;				return c.writeErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Write the buffers to the connection.
0000000000000000000000000000000000000000;;		c.writeErr = c.write(c.writeFrameType, c.writeDeadline, c.writeBuf[framePos:c.writePos], extra)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Setup for next frame.
0000000000000000000000000000000000000000;;		c.writePos = maxFrameHeaderSize
0000000000000000000000000000000000000000;;		c.writeFrameType = continuationFrame
0000000000000000000000000000000000000000;;		if final {
0000000000000000000000000000000000000000;;			c.writeSeq++
0000000000000000000000000000000000000000;;			c.writeFrameType = noFrame
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.writeErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type messageWriter struct {
0000000000000000000000000000000000000000;;		c   *Conn
0000000000000000000000000000000000000000;;		seq int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w messageWriter) err() error {
0000000000000000000000000000000000000000;;		c := w.c
0000000000000000000000000000000000000000;;		if c.writeSeq != w.seq {
0000000000000000000000000000000000000000;;			return errWriteClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.writeErr != nil {
0000000000000000000000000000000000000000;;			return c.writeErr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w messageWriter) ncopy(max int) (int, error) {
0000000000000000000000000000000000000000;;		n := len(w.c.writeBuf) - w.c.writePos
0000000000000000000000000000000000000000;;		if n <= 0 {
0000000000000000000000000000000000000000;;			if err := w.c.flushFrame(false, nil); err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n = len(w.c.writeBuf) - w.c.writePos
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n > max {
0000000000000000000000000000000000000000;;			n = max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w messageWriter) write(final bool, p []byte) (int, error) {
0000000000000000000000000000000000000000;;		if err := w.err(); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(p) > 2*len(w.c.writeBuf) && w.c.isServer {
0000000000000000000000000000000000000000;;			// Don't buffer large messages.
0000000000000000000000000000000000000000;;			err := w.c.flushFrame(final, p)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return len(p), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nn := len(p)
0000000000000000000000000000000000000000;;		for len(p) > 0 {
0000000000000000000000000000000000000000;;			n, err := w.ncopy(len(p))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(w.c.writeBuf[w.c.writePos:], p[:n])
0000000000000000000000000000000000000000;;			w.c.writePos += n
0000000000000000000000000000000000000000;;			p = p[n:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w messageWriter) Write(p []byte) (int, error) {
0000000000000000000000000000000000000000;;		return w.write(false, p)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w messageWriter) WriteString(p string) (int, error) {
0000000000000000000000000000000000000000;;		if err := w.err(); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nn := len(p)
0000000000000000000000000000000000000000;;		for len(p) > 0 {
0000000000000000000000000000000000000000;;			n, err := w.ncopy(len(p))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copy(w.c.writeBuf[w.c.writePos:], p[:n])
0000000000000000000000000000000000000000;;			w.c.writePos += n
0000000000000000000000000000000000000000;;			p = p[n:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w messageWriter) ReadFrom(r io.Reader) (nn int64, err error) {
0000000000000000000000000000000000000000;;		if err := w.err(); err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if w.c.writePos == len(w.c.writeBuf) {
0000000000000000000000000000000000000000;;				err = w.c.flushFrame(false, nil)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var n int
0000000000000000000000000000000000000000;;			n, err = r.Read(w.c.writeBuf[w.c.writePos:])
0000000000000000000000000000000000000000;;			w.c.writePos += n
0000000000000000000000000000000000000000;;			nn += int64(n)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == io.EOF {
0000000000000000000000000000000000000000;;					err = nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nn, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w messageWriter) Close() error {
0000000000000000000000000000000000000000;;		if err := w.err(); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.c.flushFrame(true, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteMessage is a helper method for getting a writer using NextWriter,
0000000000000000000000000000000000000000;;	// writing the message and closing the writer.
0000000000000000000000000000000000000000;;	func (c *Conn) WriteMessage(messageType int, data []byte) error {
0000000000000000000000000000000000000000;;		wr, err := c.NextWriter(messageType)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w := wr.(messageWriter)
0000000000000000000000000000000000000000;;		if _, err := w.write(true, data); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.writeSeq == w.seq {
0000000000000000000000000000000000000000;;			if err := c.flushFrame(true, nil); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetWriteDeadline sets the write deadline on the underlying network
0000000000000000000000000000000000000000;;	// connection. After a write has timed out, the websocket state is corrupt and
0000000000000000000000000000000000000000;;	// all future writes will return an error. A zero value for t means writes will
0000000000000000000000000000000000000000;;	// not time out.
0000000000000000000000000000000000000000;;	func (c *Conn) SetWriteDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		c.writeDeadline = t
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read methods
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// readFull is like io.ReadFull except that io.EOF is never returned.
0000000000000000000000000000000000000000;;	func (c *Conn) readFull(p []byte) (err error) {
0000000000000000000000000000000000000000;;		var n int
0000000000000000000000000000000000000000;;		for n < len(p) && err == nil {
0000000000000000000000000000000000000000;;			var nn int
0000000000000000000000000000000000000000;;			nn, err = c.br.Read(p[n:])
0000000000000000000000000000000000000000;;			n += nn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n == len(p) {
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		} else if err == io.EOF {
0000000000000000000000000000000000000000;;			err = errUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) advanceFrame() (int, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 1. Skip remainder of previous frame.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.readRemaining > 0 {
0000000000000000000000000000000000000000;;			if _, err := io.CopyN(ioutil.Discard, c.br, c.readRemaining); err != nil {
0000000000000000000000000000000000000000;;				return noFrame, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2. Read and parse first two bytes of frame header.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var b [8]byte
0000000000000000000000000000000000000000;;		if err := c.readFull(b[:2]); err != nil {
0000000000000000000000000000000000000000;;			return noFrame, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		final := b[0]&finalBit != 0
0000000000000000000000000000000000000000;;		frameType := int(b[0] & 0xf)
0000000000000000000000000000000000000000;;		reserved := int((b[0] >> 4) & 0x7)
0000000000000000000000000000000000000000;;		mask := b[1]&maskBit != 0
0000000000000000000000000000000000000000;;		c.readRemaining = int64(b[1] & 0x7f)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if reserved != 0 {
0000000000000000000000000000000000000000;;			return noFrame, c.handleProtocolError("unexpected reserved bits " + strconv.Itoa(reserved))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch frameType {
0000000000000000000000000000000000000000;;		case CloseMessage, PingMessage, PongMessage:
0000000000000000000000000000000000000000;;			if c.readRemaining > maxControlFramePayloadSize {
0000000000000000000000000000000000000000;;				return noFrame, c.handleProtocolError("control frame length > 125")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !final {
0000000000000000000000000000000000000000;;				return noFrame, c.handleProtocolError("control frame not final")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case TextMessage, BinaryMessage:
0000000000000000000000000000000000000000;;			if !c.readFinal {
0000000000000000000000000000000000000000;;				return noFrame, c.handleProtocolError("message start before final message frame")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.readFinal = final
0000000000000000000000000000000000000000;;		case continuationFrame:
0000000000000000000000000000000000000000;;			if c.readFinal {
0000000000000000000000000000000000000000;;				return noFrame, c.handleProtocolError("continuation after final message frame")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.readFinal = final
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return noFrame, c.handleProtocolError("unknown opcode " + strconv.Itoa(frameType))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3. Read and parse frame length.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c.readRemaining {
0000000000000000000000000000000000000000;;		case 126:
0000000000000000000000000000000000000000;;			if err := c.readFull(b[:2]); err != nil {
0000000000000000000000000000000000000000;;				return noFrame, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.readRemaining = int64(binary.BigEndian.Uint16(b[:2]))
0000000000000000000000000000000000000000;;		case 127:
0000000000000000000000000000000000000000;;			if err := c.readFull(b[:8]); err != nil {
0000000000000000000000000000000000000000;;				return noFrame, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.readRemaining = int64(binary.BigEndian.Uint64(b[:8]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 4. Handle frame masking.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mask != c.isServer {
0000000000000000000000000000000000000000;;			return noFrame, c.handleProtocolError("incorrect mask flag")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mask {
0000000000000000000000000000000000000000;;			c.readMaskPos = 0
0000000000000000000000000000000000000000;;			if err := c.readFull(c.readMaskKey[:]); err != nil {
0000000000000000000000000000000000000000;;				return noFrame, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 5. For text and binary messages, enforce read limit and return.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if frameType == continuationFrame || frameType == TextMessage || frameType == BinaryMessage {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c.readLength += c.readRemaining
0000000000000000000000000000000000000000;;			if c.readLimit > 0 && c.readLength > c.readLimit {
0000000000000000000000000000000000000000;;				c.WriteControl(CloseMessage, FormatCloseMessage(CloseMessageTooBig, ""), time.Now().Add(writeWait))
0000000000000000000000000000000000000000;;				return noFrame, ErrReadLimit
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return frameType, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 6. Read control frame payload.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var payload []byte
0000000000000000000000000000000000000000;;		if c.readRemaining > 0 {
0000000000000000000000000000000000000000;;			payload = make([]byte, c.readRemaining)
0000000000000000000000000000000000000000;;			c.readRemaining = 0
0000000000000000000000000000000000000000;;			if err := c.readFull(payload); err != nil {
0000000000000000000000000000000000000000;;				return noFrame, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.isServer {
0000000000000000000000000000000000000000;;				maskBytes(c.readMaskKey, 0, payload)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 7. Process control frame payload.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch frameType {
0000000000000000000000000000000000000000;;		case PongMessage:
0000000000000000000000000000000000000000;;			if err := c.handlePong(string(payload)); err != nil {
0000000000000000000000000000000000000000;;				return noFrame, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case PingMessage:
0000000000000000000000000000000000000000;;			if err := c.handlePing(string(payload)); err != nil {
0000000000000000000000000000000000000000;;				return noFrame, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case CloseMessage:
0000000000000000000000000000000000000000;;			c.WriteControl(CloseMessage, []byte{}, time.Now().Add(writeWait))
0000000000000000000000000000000000000000;;			closeCode := CloseNoStatusReceived
0000000000000000000000000000000000000000;;			closeText := ""
0000000000000000000000000000000000000000;;			if len(payload) >= 2 {
0000000000000000000000000000000000000000;;				closeCode = int(binary.BigEndian.Uint16(payload))
0000000000000000000000000000000000000000;;				closeText = string(payload[2:])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch closeCode {
0000000000000000000000000000000000000000;;			case CloseNormalClosure, CloseGoingAway:
0000000000000000000000000000000000000000;;				return noFrame, io.EOF
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return noFrame, &closeError{code: closeCode, text: closeText}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return frameType, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Conn) handleProtocolError(message string) error {
0000000000000000000000000000000000000000;;		c.WriteControl(CloseMessage, FormatCloseMessage(CloseProtocolError, message), time.Now().Add(writeWait))
0000000000000000000000000000000000000000;;		return errors.New("websocket: " + message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextReader returns the next data message received from the peer. The
0000000000000000000000000000000000000000;;	// returned messageType is either TextMessage or BinaryMessage.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There can be at most one open reader on a connection. NextReader discards
0000000000000000000000000000000000000000;;	// the previous message if the application has not already consumed it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The NextReader method and the readers returned from the method cannot be
0000000000000000000000000000000000000000;;	// accessed by more than one goroutine at a time.
0000000000000000000000000000000000000000;;	func (c *Conn) NextReader() (messageType int, r io.Reader, err error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.readSeq++
0000000000000000000000000000000000000000;;		c.readLength = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for c.readErr == nil {
0000000000000000000000000000000000000000;;			frameType, err := c.advanceFrame()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				c.readErr = hideTempErr(err)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if frameType == TextMessage || frameType == BinaryMessage {
0000000000000000000000000000000000000000;;				return frameType, messageReader{c, c.readSeq}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return noFrame, nil, c.readErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type messageReader struct {
0000000000000000000000000000000000000000;;		c   *Conn
0000000000000000000000000000000000000000;;		seq int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r messageReader) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.seq != r.c.readSeq {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for r.c.readErr == nil {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.c.readRemaining > 0 {
0000000000000000000000000000000000000000;;				if int64(len(b)) > r.c.readRemaining {
0000000000000000000000000000000000000000;;					b = b[:r.c.readRemaining]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				n, err := r.c.br.Read(b)
0000000000000000000000000000000000000000;;				r.c.readErr = hideTempErr(err)
0000000000000000000000000000000000000000;;				if r.c.isServer {
0000000000000000000000000000000000000000;;					r.c.readMaskPos = maskBytes(r.c.readMaskKey, r.c.readMaskPos, b[:n])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				r.c.readRemaining -= int64(n)
0000000000000000000000000000000000000000;;				return n, r.c.readErr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if r.c.readFinal {
0000000000000000000000000000000000000000;;				r.c.readSeq++
0000000000000000000000000000000000000000;;				return 0, io.EOF
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			frameType, err := r.c.advanceFrame()
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case err != nil:
0000000000000000000000000000000000000000;;				r.c.readErr = hideTempErr(err)
0000000000000000000000000000000000000000;;			case frameType == TextMessage || frameType == BinaryMessage:
0000000000000000000000000000000000000000;;				r.c.readErr = errors.New("websocket: internal error, unexpected text or binary in Reader")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := r.c.readErr
0000000000000000000000000000000000000000;;		if err == io.EOF && r.seq == r.c.readSeq {
0000000000000000000000000000000000000000;;			err = errUnexpectedEOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadMessage is a helper method for getting a reader using NextReader and
0000000000000000000000000000000000000000;;	// reading from that reader to a buffer.
0000000000000000000000000000000000000000;;	func (c *Conn) ReadMessage() (messageType int, p []byte, err error) {
0000000000000000000000000000000000000000;;		var r io.Reader
0000000000000000000000000000000000000000;;		messageType, r, err = c.NextReader()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return messageType, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err = ioutil.ReadAll(r)
0000000000000000000000000000000000000000;;		return messageType, p, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReadDeadline sets the read deadline on the underlying network connection.
0000000000000000000000000000000000000000;;	// After a read has timed out, the websocket connection state is corrupt and
0000000000000000000000000000000000000000;;	// all future reads will return an error. A zero value for t means reads will
0000000000000000000000000000000000000000;;	// not time out.
0000000000000000000000000000000000000000;;	func (c *Conn) SetReadDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		return c.conn.SetReadDeadline(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReadLimit sets the maximum size for a message read from the peer. If a
0000000000000000000000000000000000000000;;	// message exceeds the limit, the connection sends a close frame to the peer
0000000000000000000000000000000000000000;;	// and returns ErrReadLimit to the application.
0000000000000000000000000000000000000000;;	func (c *Conn) SetReadLimit(limit int64) {
0000000000000000000000000000000000000000;;		c.readLimit = limit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPingHandler sets the handler for ping messages received from the peer.
0000000000000000000000000000000000000000;;	// The default ping handler sends a pong to the peer.
0000000000000000000000000000000000000000;;	func (c *Conn) SetPingHandler(h func(string) error) {
0000000000000000000000000000000000000000;;		if h == nil {
0000000000000000000000000000000000000000;;			h = func(message string) error {
0000000000000000000000000000000000000000;;				c.WriteControl(PongMessage, []byte(message), time.Now().Add(writeWait))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.handlePing = h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPongHandler sets the handler for pong messages received from the peer.
0000000000000000000000000000000000000000;;	// The default pong handler does nothing.
0000000000000000000000000000000000000000;;	func (c *Conn) SetPongHandler(h func(string) error) {
0000000000000000000000000000000000000000;;		if h == nil {
0000000000000000000000000000000000000000;;			h = func(string) error { return nil }
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.handlePong = h
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnderlyingConn returns the internal net.Conn. This can be used to further
0000000000000000000000000000000000000000;;	// modifications to connection specific flags.
0000000000000000000000000000000000000000;;	func (c *Conn) UnderlyingConn() net.Conn {
0000000000000000000000000000000000000000;;		return c.conn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatCloseMessage formats closeCode and text as a WebSocket close message.
0000000000000000000000000000000000000000;;	func FormatCloseMessage(closeCode int, text string) []byte {
0000000000000000000000000000000000000000;;		buf := make([]byte, 2+len(text))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(buf, uint16(closeCode))
0000000000000000000000000000000000000000;;		copy(buf[2:], text)
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
