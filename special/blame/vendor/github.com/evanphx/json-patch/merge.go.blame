0000000000000000000000000000000000000000;;	package jsonpatch
f06dc45dd4de32066490696c552abfbefcb390fd;Godeps/_workspace/src/github.com/evanphx/json-patch/merge.go[Godeps/_workspace/src/github.com/evanphx/json-patch/merge.go][vendor/github.com/evanphx/json-patch/merge.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func merge(cur, patch *lazyNode, mergeMerge bool) *lazyNode {
0000000000000000000000000000000000000000;;		curDoc, err := cur.intoDoc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			pruneNulls(patch)
0000000000000000000000000000000000000000;;			return patch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchDoc, err := patch.intoDoc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return patch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mergeDocs(curDoc, patchDoc, mergeMerge)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return cur
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mergeDocs(doc, patch *partialDoc, mergeMerge bool) {
0000000000000000000000000000000000000000;;		for k, v := range *patch {
0000000000000000000000000000000000000000;;			k := decodePatchKey(k)
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				if mergeMerge {
0000000000000000000000000000000000000000;;					(*doc)[k] = nil
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					delete(*doc, k)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				cur, ok := (*doc)[k]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !ok || cur == nil {
0000000000000000000000000000000000000000;;					pruneNulls(v)
0000000000000000000000000000000000000000;;					(*doc)[k] = v
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					(*doc)[k] = merge(cur, v, mergeMerge)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pruneNulls(n *lazyNode) {
0000000000000000000000000000000000000000;;		sub, err := n.intoDoc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			pruneDocNulls(sub)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ary, err := n.intoAry()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				pruneAryNulls(ary)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pruneDocNulls(doc *partialDoc) *partialDoc {
0000000000000000000000000000000000000000;;		for k, v := range *doc {
0000000000000000000000000000000000000000;;			if v == nil {
0000000000000000000000000000000000000000;;				delete(*doc, k)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				pruneNulls(v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return doc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func pruneAryNulls(ary *partialArray) *partialArray {
0000000000000000000000000000000000000000;;		newAry := []*lazyNode{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range *ary {
0000000000000000000000000000000000000000;;			if v != nil {
0000000000000000000000000000000000000000;;				pruneNulls(v)
0000000000000000000000000000000000000000;;				newAry = append(newAry, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*ary = newAry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ary
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errBadJSONDoc = fmt.Errorf("Invalid JSON Document")
0000000000000000000000000000000000000000;;	var errBadJSONPatch = fmt.Errorf("Invalid JSON Patch")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergeMergePatches merges two merge patches together, such that
0000000000000000000000000000000000000000;;	// applying this resulting merged merge patch to a document yields the same
0000000000000000000000000000000000000000;;	// as merging each merge patch to the document in succession.
0000000000000000000000000000000000000000;;	func MergeMergePatches(patch1Data, patch2Data []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		return doMergePatch(patch1Data, patch2Data, true)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MergePatch merges the patchData into the docData.
0000000000000000000000000000000000000000;;	func MergePatch(docData, patchData []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		return doMergePatch(docData, patchData, false)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doMergePatch(docData, patchData []byte, mergeMerge bool) ([]byte, error) {
0000000000000000000000000000000000000000;;		doc := &partialDoc{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		docErr := json.Unmarshal(docData, doc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patch := &partialDoc{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		patchErr := json.Unmarshal(patchData, patch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := docErr.(*json.SyntaxError); ok {
0000000000000000000000000000000000000000;;			return nil, errBadJSONDoc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, ok := patchErr.(*json.SyntaxError); ok {
0000000000000000000000000000000000000000;;			return nil, errBadJSONPatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if docErr == nil && *doc == nil {
0000000000000000000000000000000000000000;;			return nil, errBadJSONDoc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if patchErr == nil && *patch == nil {
0000000000000000000000000000000000000000;;			return nil, errBadJSONPatch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if docErr != nil || patchErr != nil {
0000000000000000000000000000000000000000;;			// Not an error, just not a doc, so we turn straight into the patch
0000000000000000000000000000000000000000;;			if patchErr == nil {
0000000000000000000000000000000000000000;;				if mergeMerge {
0000000000000000000000000000000000000000;;					doc = patch
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					doc = pruneDocNulls(patch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				patchAry := &partialArray{}
0000000000000000000000000000000000000000;;				patchErr = json.Unmarshal(patchData, patchAry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if patchErr != nil {
0000000000000000000000000000000000000000;;					return nil, errBadJSONPatch
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				pruneAryNulls(patchAry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				out, patchErr := json.Marshal(patchAry)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if patchErr != nil {
0000000000000000000000000000000000000000;;					return nil, errBadJSONPatch
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return out, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			mergeDocs(doc, patch, mergeMerge)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(doc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateMergePatch creates a merge patch as specified in http://tools.ietf.org/html/draft-ietf-appsawg-json-merge-patch-07
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'a' is original, 'b' is the modified document. Both are to be given as json encoded content.
0000000000000000000000000000000000000000;;	// The function will return a mergeable json document with differences from a to b.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An error will be returned if any of the two documents are invalid.
0000000000000000000000000000000000000000;;	func CreateMergePatch(a, b []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		aI := map[string]interface{}{}
0000000000000000000000000000000000000000;;		bI := map[string]interface{}{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal(a, &aI)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, errBadJSONDoc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = json.Unmarshal(b, &bI)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, errBadJSONDoc
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dest, err := getDiff(aI, bI)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(dest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if the array matches (must be json types).
0000000000000000000000000000000000000000;;	// As is idiomatic for go, an empty array is not the same as a nil array.
0000000000000000000000000000000000000000;;	func matchesArray(a, b []interface{}) bool {
0000000000000000000000000000000000000000;;		if len(a) != len(b) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (a == nil && b != nil) || (a != nil && b == nil) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range a {
0000000000000000000000000000000000000000;;			if !matchesValue(a[i], b[i]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns true if the values matches (must be json types)
0000000000000000000000000000000000000000;;	// The types of the values must match, otherwise it will always return false
0000000000000000000000000000000000000000;;	// If two map[string]interface{} are given, all elements must match.
0000000000000000000000000000000000000000;;	func matchesValue(av, bv interface{}) bool {
0000000000000000000000000000000000000000;;		if reflect.TypeOf(av) != reflect.TypeOf(bv) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch at := av.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			bt := bv.(string)
0000000000000000000000000000000000000000;;			if bt == at {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			bt := bv.(float64)
0000000000000000000000000000000000000000;;			if bt == at {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			bt := bv.(bool)
0000000000000000000000000000000000000000;;			if bt == at {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case map[string]interface{}:
0000000000000000000000000000000000000000;;			bt := bv.(map[string]interface{})
0000000000000000000000000000000000000000;;			for key := range at {
0000000000000000000000000000000000000000;;				if !matchesValue(at[key], bt[key]) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for key := range bt {
0000000000000000000000000000000000000000;;				if !matchesValue(at[key], bt[key]) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			bt := bv.([]interface{})
0000000000000000000000000000000000000000;;			return matchesArray(at, bt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getDiff returns the (recursive) difference between a and b as a map[string]interface{}.
0000000000000000000000000000000000000000;;	func getDiff(a, b map[string]interface{}) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		into := map[string]interface{}{}
0000000000000000000000000000000000000000;;		for key, bv := range b {
0000000000000000000000000000000000000000;;			escapedKey := encodePatchKey(key)
0000000000000000000000000000000000000000;;			av, ok := a[key]
0000000000000000000000000000000000000000;;			// value was added
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				into[escapedKey] = bv
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If types have changed, replace completely
0000000000000000000000000000000000000000;;			if reflect.TypeOf(av) != reflect.TypeOf(bv) {
0000000000000000000000000000000000000000;;				into[escapedKey] = bv
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Types are the same, compare values
0000000000000000000000000000000000000000;;			switch at := av.(type) {
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				bt := bv.(map[string]interface{})
0000000000000000000000000000000000000000;;				dst := make(map[string]interface{}, len(bt))
0000000000000000000000000000000000000000;;				dst, err := getDiff(at, bt)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(dst) > 0 {
0000000000000000000000000000000000000000;;					into[escapedKey] = dst
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case string, float64, bool:
0000000000000000000000000000000000000000;;				if !matchesValue(av, bv) {
0000000000000000000000000000000000000000;;					into[escapedKey] = bv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case []interface{}:
0000000000000000000000000000000000000000;;				bt := bv.([]interface{})
0000000000000000000000000000000000000000;;				if !matchesArray(at, bt) {
0000000000000000000000000000000000000000;;					into[escapedKey] = bv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case nil:
0000000000000000000000000000000000000000;;				switch bv.(type) {
0000000000000000000000000000000000000000;;				case nil:
0000000000000000000000000000000000000000;;					// Both nil, fine.
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					into[escapedKey] = bv
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("Unknown type:%T in key %s", av, key))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Now add all deleted values as nil
0000000000000000000000000000000000000000;;		for key := range a {
0000000000000000000000000000000000000000;;			_, found := b[key]
0000000000000000000000000000000000000000;;			if !found {
0000000000000000000000000000000000000000;;				into[key] = nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return into, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From http://tools.ietf.org/html/rfc6901#section-4 :
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Evaluation of each reference token begins by decoding any escaped
0000000000000000000000000000000000000000;;	// character sequence.  This is performed by first transforming any
0000000000000000000000000000000000000000;;	// occurrence of the sequence '~1' to '/', and then transforming any
0000000000000000000000000000000000000000;;	// occurrence of the sequence '~0' to '~'.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		rfc6901Encoder = strings.NewReplacer("~", "~0", "/", "~1")
0000000000000000000000000000000000000000;;		rfc6901Decoder = strings.NewReplacer("~1", "/", "~0", "~")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodePatchKey(k string) string {
0000000000000000000000000000000000000000;;		return rfc6901Decoder.Replace(k)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func encodePatchKey(k string) string {
0000000000000000000000000000000000000000;;		return rfc6901Encoder.Replace(k)
0000000000000000000000000000000000000000;;	}
