0000000000000000000000000000000000000000;;	package jsonpatch
f06dc45dd4de32066490696c552abfbefcb390fd;Godeps/_workspace/src/github.com/evanphx/json-patch/patch.go[Godeps/_workspace/src/github.com/evanphx/json-patch/patch.go][vendor/github.com/evanphx/json-patch/patch.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		eRaw = iota
0000000000000000000000000000000000000000;;		eDoc
0000000000000000000000000000000000000000;;		eAry
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lazyNode struct {
0000000000000000000000000000000000000000;;		raw   *json.RawMessage
0000000000000000000000000000000000000000;;		doc   partialDoc
0000000000000000000000000000000000000000;;		ary   partialArray
0000000000000000000000000000000000000000;;		which int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type operation map[string]*json.RawMessage
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Patch is an ordered collection of operations.
0000000000000000000000000000000000000000;;	type Patch []operation
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type partialDoc map[string]*lazyNode
0000000000000000000000000000000000000000;;	type partialArray []*lazyNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type container interface {
0000000000000000000000000000000000000000;;		get(key string) (*lazyNode, error)
0000000000000000000000000000000000000000;;		set(key string, val *lazyNode) error
0000000000000000000000000000000000000000;;		add(key string, val *lazyNode) error
0000000000000000000000000000000000000000;;		remove(key string) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newLazyNode(raw *json.RawMessage) *lazyNode {
0000000000000000000000000000000000000000;;		return &lazyNode{raw: raw, doc: nil, ary: nil, which: eRaw}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		switch n.which {
0000000000000000000000000000000000000000;;		case eRaw:
0000000000000000000000000000000000000000;;			return json.Marshal(n.raw)
0000000000000000000000000000000000000000;;		case eDoc:
0000000000000000000000000000000000000000;;			return json.Marshal(n.doc)
0000000000000000000000000000000000000000;;		case eAry:
0000000000000000000000000000000000000000;;			return json.Marshal(n.ary)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unknown type")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		dest := make(json.RawMessage, len(data))
0000000000000000000000000000000000000000;;		copy(dest, data)
0000000000000000000000000000000000000000;;		n.raw = &dest
0000000000000000000000000000000000000000;;		n.which = eRaw
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) intoDoc() (*partialDoc, error) {
0000000000000000000000000000000000000000;;		if n.which == eDoc {
0000000000000000000000000000000000000000;;			return &n.doc, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.Unmarshal(*n.raw, &n.doc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.which = eDoc
0000000000000000000000000000000000000000;;		return &n.doc, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) intoAry() (*partialArray, error) {
0000000000000000000000000000000000000000;;		if n.which == eAry {
0000000000000000000000000000000000000000;;			return &n.ary, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.Unmarshal(*n.raw, &n.ary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.which = eAry
0000000000000000000000000000000000000000;;		return &n.ary, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) compact() []byte {
0000000000000000000000000000000000000000;;		buf := &bytes.Buffer{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.Compact(buf, *n.raw)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return *n.raw
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return buf.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) tryDoc() bool {
0000000000000000000000000000000000000000;;		err := json.Unmarshal(*n.raw, &n.doc)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.which = eDoc
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) tryAry() bool {
0000000000000000000000000000000000000000;;		err := json.Unmarshal(*n.raw, &n.ary)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n.which = eAry
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *lazyNode) equal(o *lazyNode) bool {
0000000000000000000000000000000000000000;;		if n.which == eRaw {
0000000000000000000000000000000000000000;;			if !n.tryDoc() && !n.tryAry() {
0000000000000000000000000000000000000000;;				if o.which != eRaw {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return bytes.Equal(n.compact(), o.compact())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n.which == eDoc {
0000000000000000000000000000000000000000;;			if o.which == eRaw {
0000000000000000000000000000000000000000;;				if !o.tryDoc() {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if o.which != eDoc {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for k, v := range n.doc {
0000000000000000000000000000000000000000;;				ov, ok := o.doc[k]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if v == nil && ov == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !v.equal(ov) {
0000000000000000000000000000000000000000;;					return false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.which != eAry && !o.tryAry() {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(n.ary) != len(o.ary) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for idx, val := range n.ary {
0000000000000000000000000000000000000000;;			if !val.equal(o.ary[idx]) {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o operation) kind() string {
0000000000000000000000000000000000000000;;		if obj, ok := o["op"]; ok {
0000000000000000000000000000000000000000;;			var op string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := json.Unmarshal(*obj, &op)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "unknown"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return op
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "unknown"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o operation) path() string {
0000000000000000000000000000000000000000;;		if obj, ok := o["path"]; ok {
0000000000000000000000000000000000000000;;			var op string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := json.Unmarshal(*obj, &op)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "unknown"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return op
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "unknown"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o operation) from() string {
0000000000000000000000000000000000000000;;		if obj, ok := o["from"]; ok {
0000000000000000000000000000000000000000;;			var op string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := json.Unmarshal(*obj, &op)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "unknown"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return op
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "unknown"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o operation) value() *lazyNode {
0000000000000000000000000000000000000000;;		if obj, ok := o["value"]; ok {
0000000000000000000000000000000000000000;;			return newLazyNode(obj)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isArray(buf []byte) bool {
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for _, c := range buf {
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case ' ':
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;			case '\t':
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findObject(pd *container, path string) (container, string) {
0000000000000000000000000000000000000000;;		doc := *pd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		split := strings.Split(path, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(split) < 2 {
0000000000000000000000000000000000000000;;			return nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parts := split[1 : len(split)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		key := split[len(split)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, part := range parts {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			next, ok := doc.get(decodePatchKey(part))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if next == nil || ok != nil {
0000000000000000000000000000000000000000;;				return nil, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isArray(*next.raw) {
0000000000000000000000000000000000000000;;				doc, err = next.intoAry()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				doc, err = next.intoDoc()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return doc, decodePatchKey(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialDoc) set(key string, val *lazyNode) error {
0000000000000000000000000000000000000000;;		(*d)[key] = val
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialDoc) add(key string, val *lazyNode) error {
0000000000000000000000000000000000000000;;		(*d)[key] = val
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialDoc) get(key string) (*lazyNode, error) {
0000000000000000000000000000000000000000;;		return (*d)[key], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialDoc) remove(key string) error {
0000000000000000000000000000000000000000;;		_, ok := (*d)[key]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unable to remove nonexistent key: %s", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(*d, key)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialArray) set(key string, val *lazyNode) error {
0000000000000000000000000000000000000000;;		if key == "-" {
0000000000000000000000000000000000000000;;			*d = append(*d, val)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idx, err := strconv.Atoi(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sz := len(*d)
0000000000000000000000000000000000000000;;		if idx+1 > sz {
0000000000000000000000000000000000000000;;			sz = idx + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ary := make([]*lazyNode, sz)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cur := *d
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(ary, cur)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if idx >= len(ary) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unable to access invalid index: %d", idx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ary[idx] = val
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*d = ary
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialArray) add(key string, val *lazyNode) error {
0000000000000000000000000000000000000000;;		if key == "-" {
0000000000000000000000000000000000000000;;			*d = append(*d, val)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		idx, err := strconv.Atoi(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ary := make([]*lazyNode, len(*d)+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cur := *d
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(ary[0:idx], cur[0:idx])
0000000000000000000000000000000000000000;;		ary[idx] = val
0000000000000000000000000000000000000000;;		copy(ary[idx+1:], cur[idx:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*d = ary
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialArray) get(key string) (*lazyNode, error) {
0000000000000000000000000000000000000000;;		idx, err := strconv.Atoi(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if idx >= len(*d) {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Unable to access invalid index: %d", idx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return (*d)[idx], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *partialArray) remove(key string) error {
0000000000000000000000000000000000000000;;		idx, err := strconv.Atoi(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cur := *d
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if idx >= len(cur) {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Unable to remove invalid index: %d", idx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ary := make([]*lazyNode, len(cur)-1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		copy(ary[0:idx], cur[0:idx])
0000000000000000000000000000000000000000;;		copy(ary[idx:], cur[idx+1:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*d = ary
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Patch) add(doc *container, op operation) error {
0000000000000000000000000000000000000000;;		path := op.path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, key := findObject(doc, path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if con == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("jsonpatch add operation does not apply: doc is missing path: %s", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return con.add(key, op.value())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Patch) remove(doc *container, op operation) error {
0000000000000000000000000000000000000000;;		path := op.path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, key := findObject(doc, path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if con == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("jsonpatch remove operation does not apply: doc is missing path: %s", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return con.remove(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Patch) replace(doc *container, op operation) error {
0000000000000000000000000000000000000000;;		path := op.path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, key := findObject(doc, path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if con == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("jsonpatch replace operation does not apply: doc is missing path: %s", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return con.set(key, op.value())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Patch) move(doc *container, op operation) error {
0000000000000000000000000000000000000000;;		from := op.from()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, key := findObject(doc, from)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if con == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("jsonpatch move operation does not apply: doc is missing from path: %s", from)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, err := con.get(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = con.remove(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		path := op.path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, key = findObject(doc, path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if con == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("jsonpatch move operation does not apply: doc is missing destination path: %s", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return con.set(key, val)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p Patch) test(doc *container, op operation) error {
0000000000000000000000000000000000000000;;		path := op.path()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		con, key := findObject(doc, path)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if con == nil {
0000000000000000000000000000000000000000;;			return fmt.Errorf("jsonpatch test operation does not apply: is missing path: %s", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val, err := con.get(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val == nil {
0000000000000000000000000000000000000000;;			if op.value().raw == nil {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return fmt.Errorf("Testing value %s failed", path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if val.equal(op.value()) {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return fmt.Errorf("Testing value %s failed", path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Equal indicates if 2 JSON documents have the same structural equality.
0000000000000000000000000000000000000000;;	func Equal(a, b []byte) bool {
0000000000000000000000000000000000000000;;		ra := make(json.RawMessage, len(a))
0000000000000000000000000000000000000000;;		copy(ra, a)
0000000000000000000000000000000000000000;;		la := newLazyNode(&ra)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rb := make(json.RawMessage, len(b))
0000000000000000000000000000000000000000;;		copy(rb, b)
0000000000000000000000000000000000000000;;		lb := newLazyNode(&rb)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return la.equal(lb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodePatch decodes the passed JSON document as an RFC 6902 patch.
0000000000000000000000000000000000000000;;	func DecodePatch(buf []byte) (Patch, error) {
0000000000000000000000000000000000000000;;		var p Patch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.Unmarshal(buf, &p)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Apply mutates a JSON document according to the patch, and returns the new
0000000000000000000000000000000000000000;;	// document.
0000000000000000000000000000000000000000;;	func (p Patch) Apply(doc []byte) ([]byte, error) {
0000000000000000000000000000000000000000;;		return p.ApplyIndent(doc, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ApplyIndent mutates a JSON document according to the patch, and returns the new
0000000000000000000000000000000000000000;;	// document indented.
0000000000000000000000000000000000000000;;	func (p Patch) ApplyIndent(doc []byte, indent string) ([]byte, error) {
0000000000000000000000000000000000000000;;		var pd container
0000000000000000000000000000000000000000;;		if doc[0] == '[' {
0000000000000000000000000000000000000000;;			pd = &partialArray{}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			pd = &partialDoc{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := json.Unmarshal(doc, pd)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, op := range p {
0000000000000000000000000000000000000000;;			switch op.kind() {
0000000000000000000000000000000000000000;;			case "add":
0000000000000000000000000000000000000000;;				err = p.add(&pd, op)
0000000000000000000000000000000000000000;;			case "remove":
0000000000000000000000000000000000000000;;				err = p.remove(&pd, op)
0000000000000000000000000000000000000000;;			case "replace":
0000000000000000000000000000000000000000;;				err = p.replace(&pd, op)
0000000000000000000000000000000000000000;;			case "move":
0000000000000000000000000000000000000000;;				err = p.move(&pd, op)
0000000000000000000000000000000000000000;;			case "test":
0000000000000000000000000000000000000000;;				err = p.test(&pd, op)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				err = fmt.Errorf("Unexpected kind: %s", op.kind())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if indent != "" {
0000000000000000000000000000000000000000;;			return json.MarshalIndent(pd, "", indent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return json.Marshal(pd)
0000000000000000000000000000000000000000;;	}
