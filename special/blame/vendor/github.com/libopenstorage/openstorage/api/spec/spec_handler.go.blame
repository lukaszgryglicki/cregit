0000000000000000000000000000000000000000;;	package spec
53795d8dd25f2c7edfe0581e1b07058df18938f5;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/libopenstorage/openstorage/api"
0000000000000000000000000000000000000000;;		"github.com/libopenstorage/openstorage/pkg/units"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SpecHandler provides conversion function from what gets passed in over the
0000000000000000000000000000000000000000;;	// plugin API to an api.VolumeSpec object.
0000000000000000000000000000000000000000;;	type SpecHandler interface {
0000000000000000000000000000000000000000;;		// SpecFromString parses options from the name.
0000000000000000000000000000000000000000;;		// If the scheduler was unable to pass in the volume spec via the API,
0000000000000000000000000000000000000000;;		// the spec can be passed in via the name in the format:
0000000000000000000000000000000000000000;;		// "key=value;key=value;name=volname"
0000000000000000000000000000000000000000;;		// If the spec was parsed, it returns:
0000000000000000000000000000000000000000;;		//  	(true, parsed_spec, parsed_name)
0000000000000000000000000000000000000000;;		// If the input string didn't contain the string, it returns:
0000000000000000000000000000000000000000;;		// 	(false, DefaultSpec(), inputString)
0000000000000000000000000000000000000000;;		SpecFromString(inputString string) (bool, *api.VolumeSpec, string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SpecFromOpts parses in docker options passed in the the docker run
0000000000000000000000000000000000000000;;		// command of the form --opt name=value
0000000000000000000000000000000000000000;;		// If the options are validated then it returns:
0000000000000000000000000000000000000000;;		// 	(resultant_VolumeSpec, nil)
0000000000000000000000000000000000000000;;		// If the options have invalid values then it returns:
0000000000000000000000000000000000000000;;		//	(nil, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		SpecFromOpts(opts map[string]string) (*api.VolumeSpec, error)
0000000000000000000000000000000000000000;;		// Returns a default VolumeSpec if no docker options or string encoding
0000000000000000000000000000000000000000;;		// was provided.
0000000000000000000000000000000000000000;;		DefaultSpec() *api.VolumeSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		nameRegex       = regexp.MustCompile(api.Name + "=([0-9A-Za-z]+),?")
0000000000000000000000000000000000000000;;		sizeRegex       = regexp.MustCompile(api.SpecSize + "=([0-9A-Za-z]+),?")
0000000000000000000000000000000000000000;;		scaleRegex      = regexp.MustCompile(api.SpecScale + "=([0-9A-Za-z]+),?")
0000000000000000000000000000000000000000;;		fsRegex         = regexp.MustCompile(api.SpecFilesystem + "=([0-9A-Za-z]+),?")
0000000000000000000000000000000000000000;;		bsRegex         = regexp.MustCompile(api.SpecBlockSize + "=([0-9]+),?")
0000000000000000000000000000000000000000;;		haRegex         = regexp.MustCompile(api.SpecHaLevel + "=([0-9]+),?")
0000000000000000000000000000000000000000;;		cosRegex        = regexp.MustCompile(api.SpecPriority + "=([A-Za-z]+),?")
0000000000000000000000000000000000000000;;		sharedRegex     = regexp.MustCompile(api.SpecShared + "=([A-Za-z]+),?")
0000000000000000000000000000000000000000;;		passphraseRegex = regexp.MustCompile(api.SpecPassphrase + "=([0-9A-Za-z_@./#&+-]+),?")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type specHandler struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewSpecHandler() SpecHandler {
0000000000000000000000000000000000000000;;		return &specHandler{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *specHandler) cosLevel(cos string) (uint32, error) {
0000000000000000000000000000000000000000;;		switch cos {
0000000000000000000000000000000000000000;;		case "high", "3":
0000000000000000000000000000000000000000;;			return uint32(api.CosType_HIGH), nil
0000000000000000000000000000000000000000;;		case "medium", "2":
0000000000000000000000000000000000000000;;			return uint32(api.CosType_MEDIUM), nil
0000000000000000000000000000000000000000;;		case "low", "1", "":
0000000000000000000000000000000000000000;;			return uint32(api.CosType_LOW), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint32(api.CosType_LOW),
0000000000000000000000000000000000000000;;			fmt.Errorf("Cos must be one of %q | %q | %q", "high", "medium", "low")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *specHandler) getVal(r *regexp.Regexp, str string) (bool, string) {
0000000000000000000000000000000000000000;;		found := r.FindString(str)
0000000000000000000000000000000000000000;;		if found == "" {
0000000000000000000000000000000000000000;;			return false, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		submatches := r.FindStringSubmatch(str)
0000000000000000000000000000000000000000;;		if len(submatches) < 2 {
0000000000000000000000000000000000000000;;			return false, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		val := submatches[1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true, val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *specHandler) DefaultSpec() *api.VolumeSpec {
0000000000000000000000000000000000000000;;		return &api.VolumeSpec{
0000000000000000000000000000000000000000;;			VolumeLabels: make(map[string]string),
0000000000000000000000000000000000000000;;			Format:       api.FSType_FS_TYPE_EXT4,
0000000000000000000000000000000000000000;;			HaLevel:      1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *specHandler) SpecFromOpts(
0000000000000000000000000000000000000000;;		opts map[string]string,
0000000000000000000000000000000000000000;;	) (*api.VolumeSpec, error) {
0000000000000000000000000000000000000000;;		spec := d.DefaultSpec()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range opts {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case api.SpecEphemeral:
0000000000000000000000000000000000000000;;				spec.Ephemeral, _ = strconv.ParseBool(v)
0000000000000000000000000000000000000000;;			case api.SpecSize:
0000000000000000000000000000000000000000;;				if size, err := units.Parse(v); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					spec.Size = uint64(size)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case api.SpecFilesystem:
0000000000000000000000000000000000000000;;				if value, err := api.FSTypeSimpleValueOf(v); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					spec.Format = value
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case api.SpecBlockSize:
0000000000000000000000000000000000000000;;				if blockSize, err := units.Parse(v); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					spec.BlockSize = blockSize
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case api.SpecHaLevel:
0000000000000000000000000000000000000000;;				haLevel, _ := strconv.ParseInt(v, 10, 64)
0000000000000000000000000000000000000000;;				spec.HaLevel = haLevel
0000000000000000000000000000000000000000;;			case api.SpecPriority:
0000000000000000000000000000000000000000;;				cos, _ := api.CosTypeSimpleValueOf(v)
0000000000000000000000000000000000000000;;				spec.Cos = cos
0000000000000000000000000000000000000000;;			case api.SpecDedupe:
0000000000000000000000000000000000000000;;				spec.Dedupe, _ = strconv.ParseBool(v)
0000000000000000000000000000000000000000;;			case api.SpecSnapshotInterval:
0000000000000000000000000000000000000000;;				snapshotInterval, _ := strconv.ParseUint(v, 10, 32)
0000000000000000000000000000000000000000;;				spec.SnapshotInterval = uint32(snapshotInterval)
0000000000000000000000000000000000000000;;			case api.SpecAggregationLevel:
0000000000000000000000000000000000000000;;				aggregationLevel, _ := strconv.ParseUint(v, 10, 32)
0000000000000000000000000000000000000000;;				spec.AggregationLevel = uint32(aggregationLevel)
0000000000000000000000000000000000000000;;			case api.SpecShared:
0000000000000000000000000000000000000000;;				if shared, err := strconv.ParseBool(v); err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					spec.Shared = shared
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case api.SpecPassphrase:
0000000000000000000000000000000000000000;;				spec.Encrypted = true
0000000000000000000000000000000000000000;;				spec.Passphrase = v
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				spec.VolumeLabels[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return spec, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *specHandler) SpecFromString(
0000000000000000000000000000000000000000;;		str string,
0000000000000000000000000000000000000000;;	) (bool, *api.VolumeSpec, string) {
0000000000000000000000000000000000000000;;		// If we can't parse the name, the rest of the spec is invalid.
0000000000000000000000000000000000000000;;		ok, name := d.getVal(nameRegex, str)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return false, d.DefaultSpec(), str
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opts := make(map[string]string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok, sz := d.getVal(sizeRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecSize] = sz
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, scale := d.getVal(scaleRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecScale] = scale
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, fs := d.getVal(fsRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecFilesystem] = fs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, bs := d.getVal(bsRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecBlockSize] = bs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, ha := d.getVal(haRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecHaLevel] = ha
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, priority := d.getVal(cosRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecPriority] = priority
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, shared := d.getVal(sharedRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecShared] = shared
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok, passphrase := d.getVal(passphraseRegex, str); ok {
0000000000000000000000000000000000000000;;			opts[api.SpecPassphrase] = passphrase
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		spec, err := d.SpecFromOpts(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, d.DefaultSpec(), name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true, spec, name
0000000000000000000000000000000000000000;;	}
