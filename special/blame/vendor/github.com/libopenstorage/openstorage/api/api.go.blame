0000000000000000000000000000000000000000;;	package api
53795d8dd25f2c7edfe0581e1b07058df18938f5;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Strings for VolumeSpec
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		Name                 = "name"
0000000000000000000000000000000000000000;;		SpecEphemeral        = "ephemeral"
0000000000000000000000000000000000000000;;		SpecShared           = "shared"
0000000000000000000000000000000000000000;;		SpecSize             = "size"
0000000000000000000000000000000000000000;;		SpecScale            = "scale"
0000000000000000000000000000000000000000;;		SpecFilesystem       = "fs"
0000000000000000000000000000000000000000;;		SpecBlockSize        = "block_size"
0000000000000000000000000000000000000000;;		SpecHaLevel          = "repl"
0000000000000000000000000000000000000000;;		SpecPriority         = "io_priority"
0000000000000000000000000000000000000000;;		SpecSnapshotInterval = "snap_interval"
0000000000000000000000000000000000000000;;		SpecAggregationLevel = "aggregation_level"
0000000000000000000000000000000000000000;;		SpecDedupe           = "dedupe"
0000000000000000000000000000000000000000;;		SpecPassphrase       = "passphrase"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OptionKey specifies a set of recognized query params.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// OptName query parameter used to lookup volume by name.
0000000000000000000000000000000000000000;;		OptName = "Name"
0000000000000000000000000000000000000000;;		// OptVolumeID query parameter used to lookup volume by ID.
0000000000000000000000000000000000000000;;		OptVolumeID = "VolumeID"
0000000000000000000000000000000000000000;;		// OptLabel query parameter used to lookup volume by set of labels.
0000000000000000000000000000000000000000;;		OptLabel = "Label"
0000000000000000000000000000000000000000;;		// OptConfigLabel query parameter used to lookup volume by set of labels.
0000000000000000000000000000000000000000;;		OptConfigLabel = "ConfigLabel"
0000000000000000000000000000000000000000;;		// OptCumulative query parameter used to request cumulative stats.
0000000000000000000000000000000000000000;;		OptCumulative = "Cumulative"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Api client-server Constants
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		OsdVolumePath = "osd-volumes"
0000000000000000000000000000000000000000;;		OsdSnapshotPath = "osd-snapshot"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	// Node describes the state of a node.
0000000000000000000000000000000000000000;;	// It includes the current physical state (CPU, memory, storage, network usage) as
0000000000000000000000000000000000000000;;	// well as the containers running on the system.
0000000000000000000000000000000000000000;;	type Node struct {
0000000000000000000000000000000000000000;;		Id        string
0000000000000000000000000000000000000000;;		Cpu       float64 // percentage.
0000000000000000000000000000000000000000;;		MemTotal  uint64
0000000000000000000000000000000000000000;;		MemUsed   uint64
0000000000000000000000000000000000000000;;		MemFree   uint64
0000000000000000000000000000000000000000;;		Avgload   int
0000000000000000000000000000000000000000;;		Status    Status
0000000000000000000000000000000000000000;;		GenNumber uint64
0000000000000000000000000000000000000000;;		Disks     map[string]StorageResource
0000000000000000000000000000000000000000;;		MgmtIp    string
0000000000000000000000000000000000000000;;		DataIp    string
0000000000000000000000000000000000000000;;		Timestamp time.Time
0000000000000000000000000000000000000000;;		StartTime time.Time
0000000000000000000000000000000000000000;;		Hostname  string
0000000000000000000000000000000000000000;;		NodeData  map[string]interface{}
0000000000000000000000000000000000000000;;		// User defined labels for node. Key Value pairs
0000000000000000000000000000000000000000;;		NodeLabels map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cluster represents the state of the cluster.
0000000000000000000000000000000000000000;;	type Cluster struct {
0000000000000000000000000000000000000000;;		Status Status
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Id is the ID of the cluster.
0000000000000000000000000000000000000000;;		Id string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// NodeId is the ID of the node on which this cluster object
0000000000000000000000000000000000000000;;		// is initialized
0000000000000000000000000000000000000000;;		NodeId string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Nodes is an array of all the nodes in the cluster.
0000000000000000000000000000000000000000;;		Nodes []Node
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatPoint represents the basic structure of a single Stat reported
0000000000000000000000000000000000000000;;	// TODO: This is the first step to introduce stats in openstorage.
0000000000000000000000000000000000000000;;	//       Follow up task is to introduce an API for logging stats
0000000000000000000000000000000000000000;;	type StatPoint struct {
0000000000000000000000000000000000000000;;		// Name of the Stat
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Tags for the Stat
0000000000000000000000000000000000000000;;		Tags map[string]string
0000000000000000000000000000000000000000;;		// Fields and values of the stat
0000000000000000000000000000000000000000;;		Fields map[string]interface{}
0000000000000000000000000000000000000000;;		// Timestamp in Unix format
0000000000000000000000000000000000000000;;		Timestamp int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DriverTypeSimpleValueOf(s string) (DriverType, error) {
0000000000000000000000000000000000000000;;		obj, err := simpleValueOf("driver_type", DriverType_value, s)
0000000000000000000000000000000000000000;;		return DriverType(obj), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x DriverType) SimpleString() string {
0000000000000000000000000000000000000000;;		return simpleString("driver_type", DriverType_name, int32(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func FSTypeSimpleValueOf(s string) (FSType, error) {
0000000000000000000000000000000000000000;;		obj, err := simpleValueOf("fs_type", FSType_value, s)
0000000000000000000000000000000000000000;;		return FSType(obj), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x FSType) SimpleString() string {
0000000000000000000000000000000000000000;;		return simpleString("fs_type", FSType_name, int32(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func CosTypeSimpleValueOf(s string) (CosType, error) {
0000000000000000000000000000000000000000;;		obj, err := simpleValueOf("cos_type", CosType_value, s)
0000000000000000000000000000000000000000;;		return CosType(obj), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x CosType) SimpleString() string {
0000000000000000000000000000000000000000;;		return simpleString("cos_type", CosType_name, int32(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func GraphDriverChangeTypeSimpleValueOf(s string) (GraphDriverChangeType, error) {
0000000000000000000000000000000000000000;;		obj, err := simpleValueOf("graph_driver_change_type", GraphDriverChangeType_value, s)
0000000000000000000000000000000000000000;;		return GraphDriverChangeType(obj), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x GraphDriverChangeType) SimpleString() string {
0000000000000000000000000000000000000000;;		return simpleString("graph_driver_change_type", GraphDriverChangeType_name, int32(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VolumeActionParamSimpleValueOf(s string) (VolumeActionParam, error) {
0000000000000000000000000000000000000000;;		obj, err := simpleValueOf("volume_action_param", VolumeActionParam_value, s)
0000000000000000000000000000000000000000;;		return VolumeActionParam(obj), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x VolumeActionParam) SimpleString() string {
0000000000000000000000000000000000000000;;		return simpleString("volume_action_param", VolumeActionParam_name, int32(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VolumeStateSimpleValueOf(s string) (VolumeState, error) {
0000000000000000000000000000000000000000;;		obj, err := simpleValueOf("volume_state", VolumeState_value, s)
0000000000000000000000000000000000000000;;		return VolumeState(obj), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x VolumeState) SimpleString() string {
0000000000000000000000000000000000000000;;		return simpleString("volume_state", VolumeState_name, int32(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func VolumeStatusSimpleValueOf(s string) (VolumeStatus, error) {
0000000000000000000000000000000000000000;;		obj, err := simpleValueOf("volume_status", VolumeStatus_value, s)
0000000000000000000000000000000000000000;;		return VolumeStatus(obj), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (x VolumeStatus) SimpleString() string {
0000000000000000000000000000000000000000;;		return simpleString("volume_status", VolumeStatus_name, int32(x))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func simpleValueOf(typeString string, valueMap map[string]int32, s string) (int32, error) {
0000000000000000000000000000000000000000;;		obj, ok := valueMap[strings.ToUpper(fmt.Sprintf("%s_%s", typeString, s))]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("no openstorage.%s for %s", strings.ToUpper(typeString), s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return obj, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func simpleString(typeString string, nameMap map[int32]string, v int32) string {
0000000000000000000000000000000000000000;;		s, ok := nameMap[v]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return strconv.Itoa(int(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.TrimPrefix(strings.ToLower(s), fmt.Sprintf("%s_", strings.ToLower(typeString)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toSec(ms uint64) uint64 {
0000000000000000000000000000000000000000;;		return ms / 1000
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Stats) WriteThroughput() uint64 {
0000000000000000000000000000000000000000;;		if v.IntervalMs == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (v.WriteBytes) / toSec(v.IntervalMs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Stats) ReadThroughput() uint64 {
0000000000000000000000000000000000000000;;		if v.IntervalMs == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (v.ReadBytes) / toSec(v.IntervalMs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Stats) Latency() uint64 {
0000000000000000000000000000000000000000;;		ops := v.Writes + v.Reads
0000000000000000000000000000000000000000;;		if ops == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (uint64)((v.IoMs * 1000) / (v.Writes + v.Reads))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (v *Stats) Iops() uint64 {
0000000000000000000000000000000000000000;;		if v.IntervalMs == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return (v.Writes + v.Reads) / toSec(v.IntervalMs)
0000000000000000000000000000000000000000;;	}
