0000000000000000000000000000000000000000;;	package units
53795d8dd25f2c7edfe0581e1b07058df18938f5;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_ = iota
0000000000000000000000000000000000000000;;		// KiB 1024 bytes
0000000000000000000000000000000000000000;;		KiB = 1 << (10 * iota)
0000000000000000000000000000000000000000;;		// MiB 1024 KiB
0000000000000000000000000000000000000000;;		MiB
0000000000000000000000000000000000000000;;		// GiB 1024 MiB
0000000000000000000000000000000000000000;;		GiB
0000000000000000000000000000000000000000;;		// TiB 1024 GiB
0000000000000000000000000000000000000000;;		TiB
0000000000000000000000000000000000000000;;		// PiB 1024 TiB
0000000000000000000000000000000000000000;;		PiB
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// KB 1000 bytes
0000000000000000000000000000000000000000;;		KB = 1000
0000000000000000000000000000000000000000;;		// MB 1000 KB
0000000000000000000000000000000000000000;;		MB = KB * 1000
0000000000000000000000000000000000000000;;		// GB 1000 MB
0000000000000000000000000000000000000000;;		GB = MB * 1000
0000000000000000000000000000000000000000;;		// TB 1000 GB
0000000000000000000000000000000000000000;;		TB = GB * 1000
0000000000000000000000000000000000000000;;		// PB 1000 TB
0000000000000000000000000000000000000000;;		PB = TB * 1000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		unitMap = map[string]int64{
0000000000000000000000000000000000000000;;			"B": 1,
0000000000000000000000000000000000000000;;			"b": 1,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"KB": KB,
0000000000000000000000000000000000000000;;			"kb": KB,
0000000000000000000000000000000000000000;;			"MB": MB,
0000000000000000000000000000000000000000;;			"mb": MB,
0000000000000000000000000000000000000000;;			"GB": GB,
0000000000000000000000000000000000000000;;			"gb": GB,
0000000000000000000000000000000000000000;;			"TB": TB,
0000000000000000000000000000000000000000;;			"tb": TB,
0000000000000000000000000000000000000000;;			"PB": PB,
0000000000000000000000000000000000000000;;			"pb": PB,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"K": KiB,
0000000000000000000000000000000000000000;;			"k": KiB,
0000000000000000000000000000000000000000;;			"M": MiB,
0000000000000000000000000000000000000000;;			"m": MiB,
0000000000000000000000000000000000000000;;			"G": GiB,
0000000000000000000000000000000000000000;;			"g": GiB,
0000000000000000000000000000000000000000;;			"T": TiB,
0000000000000000000000000000000000000000;;			"t": TiB,
0000000000000000000000000000000000000000;;			"P": PiB,
0000000000000000000000000000000000000000;;			"p": PiB,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"KiB": KiB,
0000000000000000000000000000000000000000;;			"MiB": MiB,
0000000000000000000000000000000000000000;;			"GiB": GiB,
0000000000000000000000000000000000000000;;			"TiB": TiB,
0000000000000000000000000000000000000000;;			"PiB": PiB,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			"Mi": MiB,
0000000000000000000000000000000000000000;;			"Gi": GiB,
0000000000000000000000000000000000000000;;			"Ti": TiB,
0000000000000000000000000000000000000000;;			"Pi": PiB,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var unitPattern = regexp.MustCompile(
0000000000000000000000000000000000000000;;		"([0-9]+)(.[0-9]+)*\\s*(B|b|K|k|M|m|G|g|T|t|P|p|KB|kb|KiB|MB|mb|MiB|Mi|GB|gb|GiB|Gi|TB|tb|TiB|Ti|PB|pb|PiB|Pi|)")
0000000000000000000000000000000000000000;;	var BadUnit = errors.New("Bad unit")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func String(b uint64) string {
0000000000000000000000000000000000000000;;		if b > PiB {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%.2f PiB", float64(b)/float64(PiB))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b > TiB {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%.2f TiB", float64(b)/float64(TiB))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b > GiB {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%.1f TiB", float64(b)/float64(GiB))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b > MiB {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v MiB", b/MiB)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b > KiB {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%v KiB", b/KiB)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%v bytes", b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func Parse(bUnit string) (int64, error) {
0000000000000000000000000000000000000000;;		ustring := strings.TrimSpace(bUnit)
0000000000000000000000000000000000000000;;		unitPattern.Longest()
0000000000000000000000000000000000000000;;		if !unitPattern.MatchString(ustring) {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf("Unit parse error: %s", bUnit)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matches := unitPattern.FindStringSubmatch(ustring)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(matches) == 0 || len(matches) > 4 {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf(
0000000000000000000000000000000000000000;;				"Unit parse error: invalid count of fields (%v)",
0000000000000000000000000000000000000000;;				len(matches))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matches) == 1 {
0000000000000000000000000000000000000000;;			return strconv.ParseInt(ustring, 10, 64)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		shift := 0
0000000000000000000000000000000000000000;;		if len(matches) == 4 {
0000000000000000000000000000000000000000;;			shift = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(matches) == 2 {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf("Unit parse error: invalid fields %v",
0000000000000000000000000000000000000000;;				matches)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ustring != matches[0] {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf("Unit parse error: invalid fields %v",
0000000000000000000000000000000000000000;;				matches)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		multiplier, ok := unitMap[matches[2+shift]]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			multiplier = unitMap["G"]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		base, err := strconv.ParseInt(matches[1], 10, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return -1, fmt.Errorf("Invalid number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return base * multiplier, nil
0000000000000000000000000000000000000000;;	}
