0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2015 The heketi Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This file is licensed to you under your choice of the GNU Lesser
0000000000000000000000000000000000000000;;	// General Public License, version 3 or any later version (LGPLv3 or
0000000000000000000000000000000000000000;;	// later), or the GNU General Public License, version 2 (GPLv2), in all
0000000000000000000000000000000000000000;;	// cases as published by the Free Software Foundation.
0000000000000000000000000000000000000000;;	//
4f4f87343f0629f7e0147e976fa9be85e68cda09;;	
0000000000000000000000000000000000000000;;	package utils
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type StatusGroup struct {
0000000000000000000000000000000000000000;;		wg      sync.WaitGroup
0000000000000000000000000000000000000000;;		results chan error
0000000000000000000000000000000000000000;;		err     error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new goroutine error status collector
0000000000000000000000000000000000000000;;	func NewStatusGroup() *StatusGroup {
0000000000000000000000000000000000000000;;		s := &StatusGroup{}
0000000000000000000000000000000000000000;;		s.results = make(chan error, 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Adds to the number of goroutines it should wait
0000000000000000000000000000000000000000;;	func (s *StatusGroup) Add(delta int) {
0000000000000000000000000000000000000000;;		s.wg.Add(delta)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes the number of pending goroutines by one
0000000000000000000000000000000000000000;;	func (s *StatusGroup) Done() {
0000000000000000000000000000000000000000;;		s.wg.Done()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Goroutine can return an error back to caller
0000000000000000000000000000000000000000;;	func (s *StatusGroup) Err(err error) {
0000000000000000000000000000000000000000;;		s.results <- err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns an error if any of the spawned goroutines
0000000000000000000000000000000000000000;;	// return an error.  Only the last error is saved.
0000000000000000000000000000000000000000;;	// This function must be called last after the last
0000000000000000000000000000000000000000;;	// s.Register() function
0000000000000000000000000000000000000000;;	func (s *StatusGroup) Result() error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This goroutine will wait until all
0000000000000000000000000000000000000000;;		// other privously spawned goroutines finish.
0000000000000000000000000000000000000000;;		// Once they finish, it will close the channel
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			s.wg.Wait()
0000000000000000000000000000000000000000;;			close(s.results)
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read from the channel until close
0000000000000000000000000000000000000000;;		for err := range s.results {
0000000000000000000000000000000000000000;;			// Only save the last one
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				s.err = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s.err
0000000000000000000000000000000000000000;;	}
