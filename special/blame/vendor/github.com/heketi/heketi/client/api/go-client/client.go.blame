0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright (c) 2015 The heketi Authors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This file is licensed to you under your choice of the GNU Lesser
0000000000000000000000000000000000000000;;	// General Public License, version 3 or any later version (LGPLv3 or
0000000000000000000000000000000000000000;;	// later), as published by the Free Software Foundation,
0000000000000000000000000000000000000000;;	// or under the Apache License, Version 2.0 <LICENSE-APACHE2 or
0000000000000000000000000000000000000000;;	// http://www.apache.org/licenses/LICENSE-2.0>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// You may not use this file except in compliance with those terms.
0000000000000000000000000000000000000000;;	//
4f4f87343f0629f7e0147e976fa9be85e68cda09;;	
0000000000000000000000000000000000000000;;	package client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jwt "github.com/dgrijalva/jwt-go"
0000000000000000000000000000000000000000;;		"github.com/heketi/heketi/pkg/utils"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		MAX_CONCURRENT_REQUESTS = 32
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client object
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		host     string
0000000000000000000000000000000000000000;;		key      string
0000000000000000000000000000000000000000;;		user     string
0000000000000000000000000000000000000000;;		throttle chan bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Creates a new client to access a Heketi server
0000000000000000000000000000000000000000;;	func NewClient(host, user, key string) *Client {
0000000000000000000000000000000000000000;;		c := &Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.key = key
0000000000000000000000000000000000000000;;		c.host = host
0000000000000000000000000000000000000000;;		c.user = user
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Maximum concurrent requests
0000000000000000000000000000000000000000;;		c.throttle = make(chan bool, MAX_CONCURRENT_REQUESTS)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a client to access a Heketi server without authentication enabled
0000000000000000000000000000000000000000;;	func NewClientNoAuth(host string) *Client {
0000000000000000000000000000000000000000;;		return NewClient(host, "", "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Simple Hello test to check if the server is up
0000000000000000000000000000000000000000;;	func (c *Client) Hello() error {
0000000000000000000000000000000000000000;;		// Create request
0000000000000000000000000000000000000000;;		req, err := http.NewRequest("GET", c.host+"/hello", nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set token
0000000000000000000000000000000000000000;;		err = c.setToken(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get info
0000000000000000000000000000000000000000;;		r, err := c.do(req)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;			return utils.GetErrorFromResponse(r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Make sure we do not run out of fds by throttling the requests
0000000000000000000000000000000000000000;;	func (c *Client) do(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		c.throttle <- true
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			<-c.throttle
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		httpClient := &http.Client{}
0000000000000000000000000000000000000000;;		httpClient.CheckRedirect = c.checkRedirect
0000000000000000000000000000000000000000;;		return httpClient.Do(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This function is called by the http package if it detects that it needs to
0000000000000000000000000000000000000000;;	// be redirected.  This happens when the server returns a 303 HTTP Status.
0000000000000000000000000000000000000000;;	// Here we create a new token before it makes the next request.
0000000000000000000000000000000000000000;;	func (c *Client) checkRedirect(req *http.Request, via []*http.Request) error {
0000000000000000000000000000000000000000;;		return c.setToken(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait for the job to finish, waiting waitTime on every loop
0000000000000000000000000000000000000000;;	func (c *Client) waitForResponseWithTimer(r *http.Response,
0000000000000000000000000000000000000000;;		waitTime time.Duration) (*http.Response, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get temp resource
0000000000000000000000000000000000000000;;		location, err := r.Location()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Create request
0000000000000000000000000000000000000000;;			req, err := http.NewRequest("GET", location.String(), nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set token
0000000000000000000000000000000000000000;;			err = c.setToken(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Wait for response
0000000000000000000000000000000000000000;;			r, err = c.do(req)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check if the request is pending
0000000000000000000000000000000000000000;;			if r.Header.Get("X-Pending") == "true" {
0000000000000000000000000000000000000000;;				if r.StatusCode != http.StatusOK {
0000000000000000000000000000000000000000;;					return nil, utils.GetErrorFromResponse(r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				time.Sleep(waitTime)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return r, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create JSON Web Token
0000000000000000000000000000000000000000;;	func (c *Client) setToken(r *http.Request) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create qsh hash
0000000000000000000000000000000000000000;;		qshstring := r.Method + "&" + r.URL.Path
0000000000000000000000000000000000000000;;		hash := sha256.New()
0000000000000000000000000000000000000000;;		hash.Write([]byte(qshstring))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create Token
0000000000000000000000000000000000000000;;		token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
0000000000000000000000000000000000000000;;			// Set issuer
0000000000000000000000000000000000000000;;			"iss": c.user,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set issued at time
0000000000000000000000000000000000000000;;			"iat": time.Now().Unix(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set expiration
0000000000000000000000000000000000000000;;			"exp": time.Now().Add(time.Minute * 5).Unix(),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set qsh
0000000000000000000000000000000000000000;;			"qsh": hex.EncodeToString(hash.Sum(nil)),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Sign the token
0000000000000000000000000000000000000000;;		signedtoken, err := token.SignedString([]byte(c.key))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Save it in the header
0000000000000000000000000000000000000000;;		r.Header.Set("Authorization", "bearer "+signedtoken)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
