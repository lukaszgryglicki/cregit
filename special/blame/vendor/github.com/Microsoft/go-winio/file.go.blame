0000000000000000000000000000000000000000;;	// +build windows
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/Microsoft/go-winio/file.go[Godeps/_workspace/src/github.com/Microsoft/go-winio/file.go][vendor/github.com/Microsoft/go-winio/file.go];	
0000000000000000000000000000000000000000;;	package winio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys cancelIoEx(file syscall.Handle, o *syscall.Overlapped) (err error) = CancelIoEx
0000000000000000000000000000000000000000;;	//sys createIoCompletionPort(file syscall.Handle, port syscall.Handle, key uintptr, threadCount uint32) (newport syscall.Handle, err error) = CreateIoCompletionPort
0000000000000000000000000000000000000000;;	//sys getQueuedCompletionStatus(port syscall.Handle, bytes *uint32, key *uintptr, o **ioOperation, timeout uint32) (err error) = GetQueuedCompletionStatus
0000000000000000000000000000000000000000;;	//sys setFileCompletionNotificationModes(h syscall.Handle, flags uint8) (err error) = SetFileCompletionNotificationModes
0000000000000000000000000000000000000000;;	//sys timeBeginPeriod(period uint32) (n int32) = winmm.timeBeginPeriod
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type atomicBool int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *atomicBool) isSet() bool { return atomic.LoadInt32((*int32)(b)) != 0 }
0000000000000000000000000000000000000000;;	func (b *atomicBool) setFalse()   { atomic.StoreInt32((*int32)(b), 0) }
0000000000000000000000000000000000000000;;	func (b *atomicBool) setTrue()    { atomic.StoreInt32((*int32)(b), 1) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cFILE_SKIP_COMPLETION_PORT_ON_SUCCESS = 1
0000000000000000000000000000000000000000;;		cFILE_SKIP_SET_EVENT_ON_HANDLE        = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrFileClosed = errors.New("file has already been closed")
0000000000000000000000000000000000000000;;		ErrTimeout    = &timeoutError{}
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timeoutError struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *timeoutError) Error() string   { return "i/o timeout" }
0000000000000000000000000000000000000000;;	func (e *timeoutError) Timeout() bool   { return true }
0000000000000000000000000000000000000000;;	func (e *timeoutError) Temporary() bool { return true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type timeoutChan chan struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var ioInitOnce sync.Once
0000000000000000000000000000000000000000;;	var ioCompletionPort syscall.Handle
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ioResult contains the result of an asynchronous IO operation
0000000000000000000000000000000000000000;;	type ioResult struct {
0000000000000000000000000000000000000000;;		bytes uint32
0000000000000000000000000000000000000000;;		err   error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ioOperation represents an outstanding asynchronous Win32 IO
0000000000000000000000000000000000000000;;	type ioOperation struct {
0000000000000000000000000000000000000000;;		o  syscall.Overlapped
0000000000000000000000000000000000000000;;		ch chan ioResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initIo() {
0000000000000000000000000000000000000000;;		h, err := createIoCompletionPort(syscall.InvalidHandle, 0, 0, 0xffffffff)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ioCompletionPort = h
0000000000000000000000000000000000000000;;		go ioCompletionProcessor(h)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// win32File implements Reader, Writer, and Closer on a Win32 handle without blocking in a syscall.
0000000000000000000000000000000000000000;;	// It takes ownership of this handle and will close it if it is garbage collected.
0000000000000000000000000000000000000000;;	type win32File struct {
0000000000000000000000000000000000000000;;		handle        syscall.Handle
0000000000000000000000000000000000000000;;		wg            sync.WaitGroup
0000000000000000000000000000000000000000;;		closing       bool
0000000000000000000000000000000000000000;;		readDeadline  deadlineHandler
0000000000000000000000000000000000000000;;		writeDeadline deadlineHandler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type deadlineHandler struct {
0000000000000000000000000000000000000000;;		setLock     sync.Mutex
0000000000000000000000000000000000000000;;		channel     timeoutChan
0000000000000000000000000000000000000000;;		channelLock sync.RWMutex
0000000000000000000000000000000000000000;;		timer       *time.Timer
0000000000000000000000000000000000000000;;		timedout    atomicBool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeWin32File makes a new win32File from an existing file handle
0000000000000000000000000000000000000000;;	func makeWin32File(h syscall.Handle) (*win32File, error) {
0000000000000000000000000000000000000000;;		f := &win32File{handle: h}
0000000000000000000000000000000000000000;;		ioInitOnce.Do(initIo)
0000000000000000000000000000000000000000;;		_, err := createIoCompletionPort(h, ioCompletionPort, 0, 0xffffffff)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = setFileCompletionNotificationModes(h, cFILE_SKIP_COMPLETION_PORT_ON_SUCCESS|cFILE_SKIP_SET_EVENT_ON_HANDLE)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.readDeadline.channel = make(timeoutChan)
0000000000000000000000000000000000000000;;		f.writeDeadline.channel = make(timeoutChan)
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func MakeOpenFile(h syscall.Handle) (io.ReadWriteCloser, error) {
0000000000000000000000000000000000000000;;		return makeWin32File(h)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// closeHandle closes the resources associated with a Win32 handle
0000000000000000000000000000000000000000;;	func (f *win32File) closeHandle() {
0000000000000000000000000000000000000000;;		if !f.closing {
0000000000000000000000000000000000000000;;			// cancel all IO and wait for it to complete
0000000000000000000000000000000000000000;;			f.closing = true
0000000000000000000000000000000000000000;;			cancelIoEx(f.handle, nil)
0000000000000000000000000000000000000000;;			f.wg.Wait()
0000000000000000000000000000000000000000;;			// at this point, no new IO can start
0000000000000000000000000000000000000000;;			syscall.Close(f.handle)
0000000000000000000000000000000000000000;;			f.handle = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes a win32File.
0000000000000000000000000000000000000000;;	func (f *win32File) Close() error {
0000000000000000000000000000000000000000;;		f.closeHandle()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// prepareIo prepares for a new IO operation.
0000000000000000000000000000000000000000;;	// The caller must call f.wg.Done() when the IO is finished, prior to Close() returning.
0000000000000000000000000000000000000000;;	func (f *win32File) prepareIo() (*ioOperation, error) {
0000000000000000000000000000000000000000;;		f.wg.Add(1)
0000000000000000000000000000000000000000;;		if f.closing {
0000000000000000000000000000000000000000;;			return nil, ErrFileClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &ioOperation{}
0000000000000000000000000000000000000000;;		c.ch = make(chan ioResult)
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ioCompletionProcessor processes completed async IOs forever
0000000000000000000000000000000000000000;;	func ioCompletionProcessor(h syscall.Handle) {
0000000000000000000000000000000000000000;;		// Set the timer resolution to 1. This fixes a performance regression in golang 1.6.
0000000000000000000000000000000000000000;;		timeBeginPeriod(1)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var bytes uint32
0000000000000000000000000000000000000000;;			var key uintptr
0000000000000000000000000000000000000000;;			var op *ioOperation
0000000000000000000000000000000000000000;;			err := getQueuedCompletionStatus(h, &bytes, &key, &op, syscall.INFINITE)
0000000000000000000000000000000000000000;;			if op == nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			op.ch <- ioResult{bytes, err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// asyncIo processes the return value from ReadFile or WriteFile, blocking until
0000000000000000000000000000000000000000;;	// the operation has actually completed.
0000000000000000000000000000000000000000;;	func (f *win32File) asyncIo(c *ioOperation, d *deadlineHandler, bytes uint32, err error) (int, error) {
0000000000000000000000000000000000000000;;		if err != syscall.ERROR_IO_PENDING {
0000000000000000000000000000000000000000;;			return int(bytes), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.closing {
0000000000000000000000000000000000000000;;			cancelIoEx(f.handle, &c.o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var timeout timeoutChan
0000000000000000000000000000000000000000;;		if d != nil {
0000000000000000000000000000000000000000;;			d.channelLock.Lock()
0000000000000000000000000000000000000000;;			timeout = d.channel
0000000000000000000000000000000000000000;;			d.channelLock.Unlock()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r ioResult
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case r = <-c.ch:
0000000000000000000000000000000000000000;;			err = r.err
0000000000000000000000000000000000000000;;			if err == syscall.ERROR_OPERATION_ABORTED {
0000000000000000000000000000000000000000;;				if f.closing {
0000000000000000000000000000000000000000;;					err = ErrFileClosed
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case <-timeout:
0000000000000000000000000000000000000000;;			cancelIoEx(f.handle, &c.o)
0000000000000000000000000000000000000000;;			r = <-c.ch
0000000000000000000000000000000000000000;;			err = r.err
0000000000000000000000000000000000000000;;			if err == syscall.ERROR_OPERATION_ABORTED {
0000000000000000000000000000000000000000;;				err = ErrTimeout
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// runtime.KeepAlive is needed, as c is passed via native
0000000000000000000000000000000000000000;;		// code to ioCompletionProcessor, c must remain alive
0000000000000000000000000000000000000000;;		// until the channel read is complete.
0000000000000000000000000000000000000000;;		runtime.KeepAlive(c)
0000000000000000000000000000000000000000;;		return int(r.bytes), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads from a file handle.
0000000000000000000000000000000000000000;;	func (f *win32File) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		c, err := f.prepareIo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.readDeadline.timedout.isSet() {
0000000000000000000000000000000000000000;;			return 0, ErrTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var bytes uint32
0000000000000000000000000000000000000000;;		err = syscall.ReadFile(f.handle, b, &bytes, &c.o)
0000000000000000000000000000000000000000;;		n, err := f.asyncIo(c, &f.readDeadline, bytes, err)
0000000000000000000000000000000000000000;;		runtime.KeepAlive(b)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle EOF conditions.
0000000000000000000000000000000000000000;;		if err == nil && n == 0 && len(b) != 0 {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		} else if err == syscall.ERROR_BROKEN_PIPE {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes to a file handle.
0000000000000000000000000000000000000000;;	func (f *win32File) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		c, err := f.prepareIo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if f.writeDeadline.timedout.isSet() {
0000000000000000000000000000000000000000;;			return 0, ErrTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var bytes uint32
0000000000000000000000000000000000000000;;		err = syscall.WriteFile(f.handle, b, &bytes, &c.o)
0000000000000000000000000000000000000000;;		n, err := f.asyncIo(c, &f.writeDeadline, bytes, err)
0000000000000000000000000000000000000000;;		runtime.KeepAlive(b)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *win32File) SetReadDeadline(deadline time.Time) error {
0000000000000000000000000000000000000000;;		return f.readDeadline.set(deadline)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *win32File) SetWriteDeadline(deadline time.Time) error {
0000000000000000000000000000000000000000;;		return f.writeDeadline.set(deadline)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *win32File) Flush() error {
0000000000000000000000000000000000000000;;		return syscall.FlushFileBuffers(f.handle)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *deadlineHandler) set(deadline time.Time) error {
0000000000000000000000000000000000000000;;		d.setLock.Lock()
0000000000000000000000000000000000000000;;		defer d.setLock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if d.timer != nil {
0000000000000000000000000000000000000000;;			if !d.timer.Stop() {
0000000000000000000000000000000000000000;;				<-d.channel
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			d.timer = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d.timedout.setFalse()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-d.channel:
0000000000000000000000000000000000000000;;			d.channelLock.Lock()
0000000000000000000000000000000000000000;;			d.channel = make(chan struct{})
0000000000000000000000000000000000000000;;			d.channelLock.Unlock()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if deadline.IsZero() {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeoutIO := func() {
0000000000000000000000000000000000000000;;			d.timedout.setTrue()
0000000000000000000000000000000000000000;;			close(d.channel)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		now := time.Now()
0000000000000000000000000000000000000000;;		duration := deadline.Sub(now)
0000000000000000000000000000000000000000;;		if deadline.After(now) {
0000000000000000000000000000000000000000;;			// Deadline is in the future, set a timer to wait
0000000000000000000000000000000000000000;;			d.timer = time.AfterFunc(duration, timeoutIO)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Deadline is in the past. Cancel all pending IO now.
0000000000000000000000000000000000000000;;			timeoutIO()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
