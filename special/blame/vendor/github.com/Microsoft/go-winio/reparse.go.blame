0000000000000000000000000000000000000000;;	package winio
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/Microsoft/go-winio/reparse.go[Godeps/_workspace/src/github.com/Microsoft/go-winio/reparse.go][vendor/github.com/Microsoft/go-winio/reparse.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf16"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		reparseTagMountPoint = 0xA0000003
0000000000000000000000000000000000000000;;		reparseTagSymlink    = 0xA000000C
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type reparseDataBuffer struct {
0000000000000000000000000000000000000000;;		ReparseTag           uint32
0000000000000000000000000000000000000000;;		ReparseDataLength    uint16
0000000000000000000000000000000000000000;;		Reserved             uint16
0000000000000000000000000000000000000000;;		SubstituteNameOffset uint16
0000000000000000000000000000000000000000;;		SubstituteNameLength uint16
0000000000000000000000000000000000000000;;		PrintNameOffset      uint16
0000000000000000000000000000000000000000;;		PrintNameLength      uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReparsePoint describes a Win32 symlink or mount point.
0000000000000000000000000000000000000000;;	type ReparsePoint struct {
0000000000000000000000000000000000000000;;		Target       string
0000000000000000000000000000000000000000;;		IsMountPoint bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnsupportedReparsePointError is returned when trying to decode a non-symlink or
0000000000000000000000000000000000000000;;	// mount point reparse point.
0000000000000000000000000000000000000000;;	type UnsupportedReparsePointError struct {
0000000000000000000000000000000000000000;;		Tag uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *UnsupportedReparsePointError) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("unsupported reparse point %x", e.Tag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeReparsePoint decodes a Win32 REPARSE_DATA_BUFFER structure containing either a symlink
0000000000000000000000000000000000000000;;	// or a mount point.
0000000000000000000000000000000000000000;;	func DecodeReparsePoint(b []byte) (*ReparsePoint, error) {
0000000000000000000000000000000000000000;;		tag := binary.LittleEndian.Uint32(b[0:4])
0000000000000000000000000000000000000000;;		return DecodeReparsePointData(tag, b[8:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func DecodeReparsePointData(tag uint32, b []byte) (*ReparsePoint, error) {
0000000000000000000000000000000000000000;;		isMountPoint := false
0000000000000000000000000000000000000000;;		switch tag {
0000000000000000000000000000000000000000;;		case reparseTagMountPoint:
0000000000000000000000000000000000000000;;			isMountPoint = true
0000000000000000000000000000000000000000;;		case reparseTagSymlink:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, &UnsupportedReparsePointError{tag}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nameOffset := 8 + binary.LittleEndian.Uint16(b[4:6])
0000000000000000000000000000000000000000;;		if !isMountPoint {
0000000000000000000000000000000000000000;;			nameOffset += 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nameLength := binary.LittleEndian.Uint16(b[6:8])
0000000000000000000000000000000000000000;;		name := make([]uint16, nameLength/2)
0000000000000000000000000000000000000000;;		err := binary.Read(bytes.NewReader(b[nameOffset:nameOffset+nameLength]), binary.LittleEndian, &name)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ReparsePoint{string(utf16.Decode(name)), isMountPoint}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isDriveLetter(c byte) bool {
0000000000000000000000000000000000000000;;		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EncodeReparsePoint encodes a Win32 REPARSE_DATA_BUFFER structure describing a symlink or
0000000000000000000000000000000000000000;;	// mount point.
0000000000000000000000000000000000000000;;	func EncodeReparsePoint(rp *ReparsePoint) []byte {
0000000000000000000000000000000000000000;;		// Generate an NT path and determine if this is a relative path.
0000000000000000000000000000000000000000;;		var ntTarget string
0000000000000000000000000000000000000000;;		relative := false
0000000000000000000000000000000000000000;;		if strings.HasPrefix(rp.Target, `\\?\`) {
0000000000000000000000000000000000000000;;			ntTarget = `\??\` + rp.Target[4:]
0000000000000000000000000000000000000000;;		} else if strings.HasPrefix(rp.Target, `\\`) {
0000000000000000000000000000000000000000;;			ntTarget = `\??\UNC\` + rp.Target[2:]
0000000000000000000000000000000000000000;;		} else if len(rp.Target) >= 2 && isDriveLetter(rp.Target[0]) && rp.Target[1] == ':' {
0000000000000000000000000000000000000000;;			ntTarget = `\??\` + rp.Target
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ntTarget = rp.Target
0000000000000000000000000000000000000000;;			relative = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The paths must be NUL-terminated even though they are counted strings.
0000000000000000000000000000000000000000;;		target16 := utf16.Encode([]rune(rp.Target + "\x00"))
0000000000000000000000000000000000000000;;		ntTarget16 := utf16.Encode([]rune(ntTarget + "\x00"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size := int(unsafe.Sizeof(reparseDataBuffer{})) - 8
0000000000000000000000000000000000000000;;		size += len(ntTarget16)*2 + len(target16)*2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tag := uint32(reparseTagMountPoint)
0000000000000000000000000000000000000000;;		if !rp.IsMountPoint {
0000000000000000000000000000000000000000;;			tag = reparseTagSymlink
0000000000000000000000000000000000000000;;			size += 4 // Add room for symlink flags
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data := reparseDataBuffer{
0000000000000000000000000000000000000000;;			ReparseTag:           tag,
0000000000000000000000000000000000000000;;			ReparseDataLength:    uint16(size),
0000000000000000000000000000000000000000;;			SubstituteNameOffset: 0,
0000000000000000000000000000000000000000;;			SubstituteNameLength: uint16((len(ntTarget16) - 1) * 2),
0000000000000000000000000000000000000000;;			PrintNameOffset:      uint16(len(ntTarget16) * 2),
0000000000000000000000000000000000000000;;			PrintNameLength:      uint16((len(target16) - 1) * 2),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var b bytes.Buffer
0000000000000000000000000000000000000000;;		binary.Write(&b, binary.LittleEndian, &data)
0000000000000000000000000000000000000000;;		if !rp.IsMountPoint {
0000000000000000000000000000000000000000;;			flags := uint32(0)
0000000000000000000000000000000000000000;;			if relative {
0000000000000000000000000000000000000000;;				flags |= 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			binary.Write(&b, binary.LittleEndian, flags)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		binary.Write(&b, binary.LittleEndian, ntTarget16)
0000000000000000000000000000000000000000;;		binary.Write(&b, binary.LittleEndian, target16)
0000000000000000000000000000000000000000;;		return b.Bytes()
0000000000000000000000000000000000000000;;	}
