0000000000000000000000000000000000000000;;	// +build windows
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/Microsoft/go-winio/backup.go[Godeps/_workspace/src/github.com/Microsoft/go-winio/backup.go][vendor/github.com/Microsoft/go-winio/backup.go];	
0000000000000000000000000000000000000000;;	package winio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"unicode/utf16"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys backupRead(h syscall.Handle, b []byte, bytesRead *uint32, abort bool, processSecurity bool, context *uintptr) (err error) = BackupRead
0000000000000000000000000000000000000000;;	//sys backupWrite(h syscall.Handle, b []byte, bytesWritten *uint32, abort bool, processSecurity bool, context *uintptr) (err error) = BackupWrite
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		BackupData = uint32(iota + 1)
0000000000000000000000000000000000000000;;		BackupEaData
0000000000000000000000000000000000000000;;		BackupSecurity
0000000000000000000000000000000000000000;;		BackupAlternateData
0000000000000000000000000000000000000000;;		BackupLink
0000000000000000000000000000000000000000;;		BackupPropertyData
0000000000000000000000000000000000000000;;		BackupObjectId
0000000000000000000000000000000000000000;;		BackupReparseData
0000000000000000000000000000000000000000;;		BackupSparseBlock
0000000000000000000000000000000000000000;;		BackupTxfsData
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		StreamSparseAttributes = uint32(8)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		WRITE_DAC              = 0x40000
0000000000000000000000000000000000000000;;		WRITE_OWNER            = 0x80000
0000000000000000000000000000000000000000;;		ACCESS_SYSTEM_SECURITY = 0x1000000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BackupHeader represents a backup stream of a file.
0000000000000000000000000000000000000000;;	type BackupHeader struct {
0000000000000000000000000000000000000000;;		Id         uint32 // The backup stream ID
0000000000000000000000000000000000000000;;		Attributes uint32 // Stream attributes
0000000000000000000000000000000000000000;;		Size       int64  // The size of the stream in bytes
0000000000000000000000000000000000000000;;		Name       string // The name of the stream (for BackupAlternateData only).
0000000000000000000000000000000000000000;;		Offset     int64  // The offset of the stream in the file (for BackupSparseBlock only).
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type win32StreamId struct {
0000000000000000000000000000000000000000;;		StreamId   uint32
0000000000000000000000000000000000000000;;		Attributes uint32
0000000000000000000000000000000000000000;;		Size       uint64
0000000000000000000000000000000000000000;;		NameSize   uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BackupStreamReader reads from a stream produced by the BackupRead Win32 API and produces a series
0000000000000000000000000000000000000000;;	// of BackupHeader values.
0000000000000000000000000000000000000000;;	type BackupStreamReader struct {
0000000000000000000000000000000000000000;;		r         io.Reader
0000000000000000000000000000000000000000;;		bytesLeft int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBackupStreamReader produces a BackupStreamReader from any io.Reader.
0000000000000000000000000000000000000000;;	func NewBackupStreamReader(r io.Reader) *BackupStreamReader {
0000000000000000000000000000000000000000;;		return &BackupStreamReader{r, 0}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Next returns the next backup stream and prepares for calls to Write(). It skips the remainder of the current stream if
0000000000000000000000000000000000000000;;	// it was not completely read.
0000000000000000000000000000000000000000;;	func (r *BackupStreamReader) Next() (*BackupHeader, error) {
0000000000000000000000000000000000000000;;		if r.bytesLeft > 0 {
0000000000000000000000000000000000000000;;			if _, err := io.Copy(ioutil.Discard, r); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var wsi win32StreamId
0000000000000000000000000000000000000000;;		if err := binary.Read(r.r, binary.LittleEndian, &wsi); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr := &BackupHeader{
0000000000000000000000000000000000000000;;			Id:         wsi.StreamId,
0000000000000000000000000000000000000000;;			Attributes: wsi.Attributes,
0000000000000000000000000000000000000000;;			Size:       int64(wsi.Size),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wsi.NameSize != 0 {
0000000000000000000000000000000000000000;;			name := make([]uint16, int(wsi.NameSize/2))
0000000000000000000000000000000000000000;;			if err := binary.Read(r.r, binary.LittleEndian, name); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hdr.Name = syscall.UTF16ToString(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if wsi.StreamId == BackupSparseBlock {
0000000000000000000000000000000000000000;;			if err := binary.Read(r.r, binary.LittleEndian, &hdr.Offset); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			hdr.Size -= 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.bytesLeft = hdr.Size
0000000000000000000000000000000000000000;;		return hdr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads from the current backup stream.
0000000000000000000000000000000000000000;;	func (r *BackupStreamReader) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if r.bytesLeft == 0 {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if int64(len(b)) > r.bytesLeft {
0000000000000000000000000000000000000000;;			b = b[:r.bytesLeft]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := r.r.Read(b)
0000000000000000000000000000000000000000;;		r.bytesLeft -= int64(n)
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			err = io.ErrUnexpectedEOF
0000000000000000000000000000000000000000;;		} else if r.bytesLeft == 0 && err == nil {
0000000000000000000000000000000000000000;;			err = io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BackupStreamWriter writes a stream compatible with the BackupWrite Win32 API.
0000000000000000000000000000000000000000;;	type BackupStreamWriter struct {
0000000000000000000000000000000000000000;;		w         io.Writer
0000000000000000000000000000000000000000;;		bytesLeft int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBackupStreamWriter produces a BackupStreamWriter on top of an io.Writer.
0000000000000000000000000000000000000000;;	func NewBackupStreamWriter(w io.Writer) *BackupStreamWriter {
0000000000000000000000000000000000000000;;		return &BackupStreamWriter{w, 0}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteHeader writes the next backup stream header and prepares for calls to Write().
0000000000000000000000000000000000000000;;	func (w *BackupStreamWriter) WriteHeader(hdr *BackupHeader) error {
0000000000000000000000000000000000000000;;		if w.bytesLeft != 0 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("missing %d bytes", w.bytesLeft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := utf16.Encode([]rune(hdr.Name))
0000000000000000000000000000000000000000;;		wsi := win32StreamId{
0000000000000000000000000000000000000000;;			StreamId:   hdr.Id,
0000000000000000000000000000000000000000;;			Attributes: hdr.Attributes,
0000000000000000000000000000000000000000;;			Size:       uint64(hdr.Size),
0000000000000000000000000000000000000000;;			NameSize:   uint32(len(name) * 2),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hdr.Id == BackupSparseBlock {
0000000000000000000000000000000000000000;;			// Include space for the int64 block offset
0000000000000000000000000000000000000000;;			wsi.Size += 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := binary.Write(w.w, binary.LittleEndian, &wsi); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(name) != 0 {
0000000000000000000000000000000000000000;;			if err := binary.Write(w.w, binary.LittleEndian, name); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hdr.Id == BackupSparseBlock {
0000000000000000000000000000000000000000;;			if err := binary.Write(w.w, binary.LittleEndian, hdr.Offset); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.bytesLeft = hdr.Size
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes to the current backup stream.
0000000000000000000000000000000000000000;;	func (w *BackupStreamWriter) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if w.bytesLeft < int64(len(b)) {
0000000000000000000000000000000000000000;;			return 0, fmt.Errorf("too many bytes by %d", int64(len(b))-w.bytesLeft)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := w.w.Write(b)
0000000000000000000000000000000000000000;;		w.bytesLeft -= int64(n)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BackupFileReader provides an io.ReadCloser interface on top of the BackupRead Win32 API.
0000000000000000000000000000000000000000;;	type BackupFileReader struct {
0000000000000000000000000000000000000000;;		f               *os.File
0000000000000000000000000000000000000000;;		includeSecurity bool
0000000000000000000000000000000000000000;;		ctx             uintptr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBackupFileReader returns a new BackupFileReader from a file handle. If includeSecurity is true,
0000000000000000000000000000000000000000;;	// Read will attempt to read the security descriptor of the file.
0000000000000000000000000000000000000000;;	func NewBackupFileReader(f *os.File, includeSecurity bool) *BackupFileReader {
0000000000000000000000000000000000000000;;		r := &BackupFileReader{f, includeSecurity, 0}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads a backup stream from the file by calling the Win32 API BackupRead().
0000000000000000000000000000000000000000;;	func (r *BackupFileReader) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		var bytesRead uint32
0000000000000000000000000000000000000000;;		err := backupRead(syscall.Handle(r.f.Fd()), b, &bytesRead, false, r.includeSecurity, &r.ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, &os.PathError{"BackupRead", r.f.Name(), err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runtime.KeepAlive(r.f)
0000000000000000000000000000000000000000;;		if bytesRead == 0 {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(bytesRead), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close frees Win32 resources associated with the BackupFileReader. It does not close
0000000000000000000000000000000000000000;;	// the underlying file.
0000000000000000000000000000000000000000;;	func (r *BackupFileReader) Close() error {
0000000000000000000000000000000000000000;;		if r.ctx != 0 {
0000000000000000000000000000000000000000;;			backupRead(syscall.Handle(r.f.Fd()), nil, nil, true, false, &r.ctx)
0000000000000000000000000000000000000000;;			runtime.KeepAlive(r.f)
0000000000000000000000000000000000000000;;			r.ctx = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BackupFileWriter provides an io.WriteCloser interface on top of the BackupWrite Win32 API.
0000000000000000000000000000000000000000;;	type BackupFileWriter struct {
0000000000000000000000000000000000000000;;		f               *os.File
0000000000000000000000000000000000000000;;		includeSecurity bool
0000000000000000000000000000000000000000;;		ctx             uintptr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBackupFileWrtier returns a new BackupFileWriter from a file handle. If includeSecurity is true,
0000000000000000000000000000000000000000;;	// Write() will attempt to restore the security descriptor from the stream.
0000000000000000000000000000000000000000;;	func NewBackupFileWriter(f *os.File, includeSecurity bool) *BackupFileWriter {
0000000000000000000000000000000000000000;;		w := &BackupFileWriter{f, includeSecurity, 0}
0000000000000000000000000000000000000000;;		return w
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write restores a portion of the file using the provided backup stream.
0000000000000000000000000000000000000000;;	func (w *BackupFileWriter) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		var bytesWritten uint32
0000000000000000000000000000000000000000;;		err := backupWrite(syscall.Handle(w.f.Fd()), b, &bytesWritten, false, w.includeSecurity, &w.ctx)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, &os.PathError{"BackupWrite", w.f.Name(), err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		runtime.KeepAlive(w.f)
0000000000000000000000000000000000000000;;		if int(bytesWritten) != len(b) {
0000000000000000000000000000000000000000;;			return int(bytesWritten), errors.New("not all bytes could be written")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(b), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close frees Win32 resources associated with the BackupFileWriter. It does not
0000000000000000000000000000000000000000;;	// close the underlying file.
0000000000000000000000000000000000000000;;	func (w *BackupFileWriter) Close() error {
0000000000000000000000000000000000000000;;		if w.ctx != 0 {
0000000000000000000000000000000000000000;;			backupWrite(syscall.Handle(w.f.Fd()), nil, nil, true, false, &w.ctx)
0000000000000000000000000000000000000000;;			runtime.KeepAlive(w.f)
0000000000000000000000000000000000000000;;			w.ctx = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenForBackup opens a file or directory, potentially skipping access checks if the backup
0000000000000000000000000000000000000000;;	// or restore privileges have been acquired.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the file opened was a directory, it cannot be used with Readdir().
0000000000000000000000000000000000000000;;	func OpenForBackup(path string, access uint32, share uint32, createmode uint32) (*os.File, error) {
0000000000000000000000000000000000000000;;		winPath, err := syscall.UTF16FromString(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, err := syscall.CreateFile(&winPath[0], access, share, nil, createmode, syscall.FILE_FLAG_BACKUP_SEMANTICS|syscall.FILE_FLAG_OPEN_REPARSE_POINT, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			err = &os.PathError{Op: "open", Path: path, Err: err}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return os.NewFile(uintptr(h), path), nil
0000000000000000000000000000000000000000;;	}
