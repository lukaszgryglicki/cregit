0000000000000000000000000000000000000000;;	// +build windows
4fd292dfb7492cc1ce958d1370115de07503bc67;Godeps/_workspace/src/github.com/Microsoft/go-winio/pipe.go[Godeps/_workspace/src/github.com/Microsoft/go-winio/pipe.go][vendor/github.com/Microsoft/go-winio/pipe.go];	
0000000000000000000000000000000000000000;;	package winio
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;		"unsafe"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//sys connectNamedPipe(pipe syscall.Handle, o *syscall.Overlapped) (err error) = ConnectNamedPipe
0000000000000000000000000000000000000000;;	//sys createNamedPipe(name string, flags uint32, pipeMode uint32, maxInstances uint32, outSize uint32, inSize uint32, defaultTimeout uint32, sa *syscall.SecurityAttributes) (handle syscall.Handle, err error)  [failretval==syscall.InvalidHandle] = CreateNamedPipeW
0000000000000000000000000000000000000000;;	//sys createFile(name string, access uint32, mode uint32, sa *syscall.SecurityAttributes, createmode uint32, attrs uint32, templatefile syscall.Handle) (handle syscall.Handle, err error) [failretval==syscall.InvalidHandle] = CreateFileW
0000000000000000000000000000000000000000;;	//sys waitNamedPipe(name string, timeout uint32) (err error) = WaitNamedPipeW
0000000000000000000000000000000000000000;;	//sys getNamedPipeInfo(pipe syscall.Handle, flags *uint32, outSize *uint32, inSize *uint32, maxInstances *uint32) (err error) = GetNamedPipeInfo
0000000000000000000000000000000000000000;;	//sys getNamedPipeHandleState(pipe syscall.Handle, state *uint32, curInstances *uint32, maxCollectionCount *uint32, collectDataTimeout *uint32, userName *uint16, maxUserNameSize uint32) (err error) = GetNamedPipeHandleStateW
0000000000000000000000000000000000000000;;	//sys localAlloc(uFlags uint32, length uint32) (ptr uintptr) = LocalAlloc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		cERROR_PIPE_BUSY      = syscall.Errno(231)
0000000000000000000000000000000000000000;;		cERROR_PIPE_CONNECTED = syscall.Errno(535)
0000000000000000000000000000000000000000;;		cERROR_SEM_TIMEOUT    = syscall.Errno(121)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cPIPE_ACCESS_DUPLEX            = 0x3
0000000000000000000000000000000000000000;;		cFILE_FLAG_FIRST_PIPE_INSTANCE = 0x80000
0000000000000000000000000000000000000000;;		cSECURITY_SQOS_PRESENT         = 0x100000
0000000000000000000000000000000000000000;;		cSECURITY_ANONYMOUS            = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cPIPE_REJECT_REMOTE_CLIENTS = 0x8
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cPIPE_UNLIMITED_INSTANCES = 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cNMPWAIT_USE_DEFAULT_WAIT = 0
0000000000000000000000000000000000000000;;		cNMPWAIT_NOWAIT           = 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cPIPE_TYPE_MESSAGE = 4
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cPIPE_READMODE_MESSAGE = 2
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// ErrPipeListenerClosed is returned for pipe operations on listeners that have been closed.
0000000000000000000000000000000000000000;;		// This error should match net.errClosing since docker takes a dependency on its text.
0000000000000000000000000000000000000000;;		ErrPipeListenerClosed = errors.New("use of closed network connection")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errPipeWriteClosed = errors.New("pipe has been closed for write")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type win32Pipe struct {
0000000000000000000000000000000000000000;;		*win32File
0000000000000000000000000000000000000000;;		path string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type win32MessageBytePipe struct {
0000000000000000000000000000000000000000;;		win32Pipe
0000000000000000000000000000000000000000;;		writeClosed bool
0000000000000000000000000000000000000000;;		readEOF     bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type pipeAddress string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *win32Pipe) LocalAddr() net.Addr {
0000000000000000000000000000000000000000;;		return pipeAddress(f.path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *win32Pipe) RemoteAddr() net.Addr {
0000000000000000000000000000000000000000;;		return pipeAddress(f.path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *win32Pipe) SetDeadline(t time.Time) error {
0000000000000000000000000000000000000000;;		f.SetReadDeadline(t)
0000000000000000000000000000000000000000;;		f.SetWriteDeadline(t)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CloseWrite closes the write side of a message pipe in byte mode.
0000000000000000000000000000000000000000;;	func (f *win32MessageBytePipe) CloseWrite() error {
0000000000000000000000000000000000000000;;		if f.writeClosed {
0000000000000000000000000000000000000000;;			return errPipeWriteClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err := f.win32File.Flush()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = f.win32File.Write(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.writeClosed = true
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes bytes to a message pipe in byte mode. Zero-byte writes are ignored, since
0000000000000000000000000000000000000000;;	// they are used to implement CloseWrite().
0000000000000000000000000000000000000000;;	func (f *win32MessageBytePipe) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if f.writeClosed {
0000000000000000000000000000000000000000;;			return 0, errPipeWriteClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(b) == 0 {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f.win32File.Write(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads bytes from a message pipe in byte mode. A read of a zero-byte message on a message
0000000000000000000000000000000000000000;;	// mode pipe will return io.EOF, as will all subsequent reads.
0000000000000000000000000000000000000000;;	func (f *win32MessageBytePipe) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		if f.readEOF {
0000000000000000000000000000000000000000;;			return 0, io.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err := f.win32File.Read(b)
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			// If this was the result of a zero-byte read, then
0000000000000000000000000000000000000000;;			// it is possible that the read was due to a zero-size
0000000000000000000000000000000000000000;;			// message. Since we are simulating CloseWrite with a
0000000000000000000000000000000000000000;;			// zero-byte message, ensure that all future Read() calls
0000000000000000000000000000000000000000;;			// also return EOF.
0000000000000000000000000000000000000000;;			f.readEOF = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s pipeAddress) Network() string {
0000000000000000000000000000000000000000;;		return "pipe"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s pipeAddress) String() string {
0000000000000000000000000000000000000000;;		return string(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialPipe connects to a named pipe by path, timing out if the connection
0000000000000000000000000000000000000000;;	// takes longer than the specified duration. If timeout is nil, then the timeout
0000000000000000000000000000000000000000;;	// is the default timeout established by the pipe server.
0000000000000000000000000000000000000000;;	func DialPipe(path string, timeout *time.Duration) (net.Conn, error) {
0000000000000000000000000000000000000000;;		var absTimeout time.Time
0000000000000000000000000000000000000000;;		if timeout != nil {
0000000000000000000000000000000000000000;;			absTimeout = time.Now().Add(*timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var h syscall.Handle
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			h, err = createFile(path, syscall.GENERIC_READ|syscall.GENERIC_WRITE, 0, nil, syscall.OPEN_EXISTING, syscall.FILE_FLAG_OVERLAPPED|cSECURITY_SQOS_PRESENT|cSECURITY_ANONYMOUS, 0)
0000000000000000000000000000000000000000;;			if err != cERROR_PIPE_BUSY {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			now := time.Now()
0000000000000000000000000000000000000000;;			var ms uint32
0000000000000000000000000000000000000000;;			if absTimeout.IsZero() {
0000000000000000000000000000000000000000;;				ms = cNMPWAIT_USE_DEFAULT_WAIT
0000000000000000000000000000000000000000;;			} else if now.After(absTimeout) {
0000000000000000000000000000000000000000;;				ms = cNMPWAIT_NOWAIT
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				ms = uint32(absTimeout.Sub(now).Nanoseconds() / 1000 / 1000)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = waitNamedPipe(path, ms)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if err == cERROR_SEM_TIMEOUT {
0000000000000000000000000000000000000000;;					return nil, ErrTimeout
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{Op: "open", Path: path, Err: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var flags uint32
0000000000000000000000000000000000000000;;		err = getNamedPipeInfo(h, &flags, nil, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var state uint32
0000000000000000000000000000000000000000;;		err = getNamedPipeHandleState(h, &state, nil, nil, nil, nil, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if state&cPIPE_READMODE_MESSAGE != 0 {
0000000000000000000000000000000000000000;;			return nil, &os.PathError{Op: "open", Path: path, Err: errors.New("message readmode pipes not supported")}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := makeWin32File(h)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			syscall.Close(h)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the pipe is in message mode, return a message byte pipe, which
0000000000000000000000000000000000000000;;		// supports CloseWrite().
0000000000000000000000000000000000000000;;		if flags&cPIPE_TYPE_MESSAGE != 0 {
0000000000000000000000000000000000000000;;			return &win32MessageBytePipe{
0000000000000000000000000000000000000000;;				win32Pipe: win32Pipe{win32File: f, path: path},
0000000000000000000000000000000000000000;;			}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &win32Pipe{win32File: f, path: path}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type acceptResponse struct {
0000000000000000000000000000000000000000;;		f   *win32File
0000000000000000000000000000000000000000;;		err error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type win32PipeListener struct {
0000000000000000000000000000000000000000;;		firstHandle        syscall.Handle
0000000000000000000000000000000000000000;;		path               string
0000000000000000000000000000000000000000;;		securityDescriptor []byte
0000000000000000000000000000000000000000;;		config             PipeConfig
0000000000000000000000000000000000000000;;		acceptCh           chan (chan acceptResponse)
0000000000000000000000000000000000000000;;		closeCh            chan int
0000000000000000000000000000000000000000;;		doneCh             chan int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func makeServerPipeHandle(path string, securityDescriptor []byte, c *PipeConfig, first bool) (syscall.Handle, error) {
0000000000000000000000000000000000000000;;		var flags uint32 = cPIPE_ACCESS_DUPLEX | syscall.FILE_FLAG_OVERLAPPED
0000000000000000000000000000000000000000;;		if first {
0000000000000000000000000000000000000000;;			flags |= cFILE_FLAG_FIRST_PIPE_INSTANCE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var mode uint32 = cPIPE_REJECT_REMOTE_CLIENTS
0000000000000000000000000000000000000000;;		if c.MessageMode {
0000000000000000000000000000000000000000;;			mode |= cPIPE_TYPE_MESSAGE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sa := &syscall.SecurityAttributes{}
0000000000000000000000000000000000000000;;		sa.Length = uint32(unsafe.Sizeof(*sa))
0000000000000000000000000000000000000000;;		if securityDescriptor != nil {
0000000000000000000000000000000000000000;;			len := uint32(len(securityDescriptor))
0000000000000000000000000000000000000000;;			sa.SecurityDescriptor = localAlloc(0, len)
0000000000000000000000000000000000000000;;			defer localFree(sa.SecurityDescriptor)
0000000000000000000000000000000000000000;;			copy((*[0xffff]byte)(unsafe.Pointer(sa.SecurityDescriptor))[:], securityDescriptor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, err := createNamedPipe(path, flags, mode, cPIPE_UNLIMITED_INSTANCES, uint32(c.OutputBufferSize), uint32(c.InputBufferSize), 0, sa)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, &os.PathError{Op: "open", Path: path, Err: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *win32PipeListener) makeServerPipe() (*win32File, error) {
0000000000000000000000000000000000000000;;		h, err := makeServerPipeHandle(l.path, l.securityDescriptor, &l.config, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := makeWin32File(h)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			syscall.Close(h)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *win32PipeListener) listenerRoutine() {
0000000000000000000000000000000000000000;;		closed := false
0000000000000000000000000000000000000000;;		for !closed {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-l.closeCh:
0000000000000000000000000000000000000000;;				closed = true
0000000000000000000000000000000000000000;;			case responseCh := <-l.acceptCh:
0000000000000000000000000000000000000000;;				p, err := l.makeServerPipe()
0000000000000000000000000000000000000000;;				if err == nil {
0000000000000000000000000000000000000000;;					// Wait for the client to connect.
0000000000000000000000000000000000000000;;					ch := make(chan error)
0000000000000000000000000000000000000000;;					go func() {
0000000000000000000000000000000000000000;;						ch <- connectPipe(p)
0000000000000000000000000000000000000000;;					}()
0000000000000000000000000000000000000000;;					select {
0000000000000000000000000000000000000000;;					case err = <-ch:
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							p.Close()
0000000000000000000000000000000000000000;;							p = nil
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					case <-l.closeCh:
0000000000000000000000000000000000000000;;						// Abort the connect request by closing the handle.
0000000000000000000000000000000000000000;;						p.Close()
0000000000000000000000000000000000000000;;						p = nil
0000000000000000000000000000000000000000;;						err = <-ch
0000000000000000000000000000000000000000;;						if err == nil || err == ErrFileClosed {
0000000000000000000000000000000000000000;;							err = ErrPipeListenerClosed
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						closed = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				responseCh <- acceptResponse{p, err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syscall.Close(l.firstHandle)
0000000000000000000000000000000000000000;;		l.firstHandle = 0
0000000000000000000000000000000000000000;;		// Notify Close() and Accept() callers that the handle has been closed.
0000000000000000000000000000000000000000;;		close(l.doneCh)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PipeConfig contain configuration for the pipe listener.
0000000000000000000000000000000000000000;;	type PipeConfig struct {
0000000000000000000000000000000000000000;;		// SecurityDescriptor contains a Windows security descriptor in SDDL format.
0000000000000000000000000000000000000000;;		SecurityDescriptor string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// MessageMode determines whether the pipe is in byte or message mode. In either
0000000000000000000000000000000000000000;;		// case the pipe is read in byte mode by default. The only practical difference in
0000000000000000000000000000000000000000;;		// this implementation is that CloseWrite() is only supported for message mode pipes;
0000000000000000000000000000000000000000;;		// CloseWrite() is implemented as a zero-byte write, but zero-byte writes are only
0000000000000000000000000000000000000000;;		// transferred to the reader (and returned as io.EOF in this implementation)
0000000000000000000000000000000000000000;;		// when the pipe is in message mode.
0000000000000000000000000000000000000000;;		MessageMode bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// InputBufferSize specifies the size the input buffer, in bytes.
0000000000000000000000000000000000000000;;		InputBufferSize int32
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// OutputBufferSize specifies the size the input buffer, in bytes.
0000000000000000000000000000000000000000;;		OutputBufferSize int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenPipe creates a listener on a Windows named pipe path, e.g. \\.\pipe\mypipe.
0000000000000000000000000000000000000000;;	// The pipe must not already exist.
0000000000000000000000000000000000000000;;	func ListenPipe(path string, c *PipeConfig) (net.Listener, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			sd  []byte
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if c == nil {
0000000000000000000000000000000000000000;;			c = &PipeConfig{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.SecurityDescriptor != "" {
0000000000000000000000000000000000000000;;			sd, err = SddlToSecurityDescriptor(c.SecurityDescriptor)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h, err := makeServerPipeHandle(path, sd, c, true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Immediately open and then close a client handle so that the named pipe is
0000000000000000000000000000000000000000;;		// created but not currently accepting connections.
0000000000000000000000000000000000000000;;		h2, err := createFile(path, 0, 0, nil, syscall.OPEN_EXISTING, cSECURITY_SQOS_PRESENT|cSECURITY_ANONYMOUS, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			syscall.Close(h)
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		syscall.Close(h2)
0000000000000000000000000000000000000000;;		l := &win32PipeListener{
0000000000000000000000000000000000000000;;			firstHandle:        h,
0000000000000000000000000000000000000000;;			path:               path,
0000000000000000000000000000000000000000;;			securityDescriptor: sd,
0000000000000000000000000000000000000000;;			config:             *c,
0000000000000000000000000000000000000000;;			acceptCh:           make(chan (chan acceptResponse)),
0000000000000000000000000000000000000000;;			closeCh:            make(chan int),
0000000000000000000000000000000000000000;;			doneCh:             make(chan int),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go l.listenerRoutine()
0000000000000000000000000000000000000000;;		return l, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func connectPipe(p *win32File) error {
0000000000000000000000000000000000000000;;		c, err := p.prepareIo()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer p.wg.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = connectNamedPipe(p.handle, &c.o)
0000000000000000000000000000000000000000;;		_, err = p.asyncIo(c, nil, 0, err)
0000000000000000000000000000000000000000;;		if err != nil && err != cERROR_PIPE_CONNECTED {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *win32PipeListener) Accept() (net.Conn, error) {
0000000000000000000000000000000000000000;;		ch := make(chan acceptResponse)
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case l.acceptCh <- ch:
0000000000000000000000000000000000000000;;			response := <-ch
0000000000000000000000000000000000000000;;			err := response.err
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if l.config.MessageMode {
0000000000000000000000000000000000000000;;				return &win32MessageBytePipe{
0000000000000000000000000000000000000000;;					win32Pipe: win32Pipe{win32File: response.f, path: l.path},
0000000000000000000000000000000000000000;;				}, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return &win32Pipe{win32File: response.f, path: l.path}, nil
0000000000000000000000000000000000000000;;		case <-l.doneCh:
0000000000000000000000000000000000000000;;			return nil, ErrPipeListenerClosed
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *win32PipeListener) Close() error {
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case l.closeCh <- 1:
0000000000000000000000000000000000000000;;			<-l.doneCh
0000000000000000000000000000000000000000;;		case <-l.doneCh:
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *win32PipeListener) Addr() net.Addr {
0000000000000000000000000000000000000000;;		return pipeAddress(l.path)
0000000000000000000000000000000000000000;;	}
