0000000000000000000000000000000000000000;;	# Negroni [![GoDoc](https://godoc.org/github.com/codegangsta/negroni?status.svg)](http://godoc.org/github.com/codegangsta/negroni) [![wercker status](https://app.wercker.com/status/13688a4a94b82d84a0b8d038c4965b61/s "wercker status")](https://app.wercker.com/project/bykey/13688a4a94b82d84a0b8d038c4965b61)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Negroni is an idiomatic approach to web middleware in Go. It is tiny, non-intrusive, and encourages use of `net/http` Handlers.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If you like the idea of [Martini](http://github.com/go-martini/martini), but you think it contains too much magic, then Negroni is a great fit.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Language Translations:
0000000000000000000000000000000000000000;;	* [Português Brasileiro (pt_BR)](translations/README_pt_br.md)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Getting Started
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After installing Go and setting up your [GOPATH](http://golang.org/doc/code.html#GOPATH), create your first `.go` file. We'll call it `server.go`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	package main
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;	  "github.com/codegangsta/negroni"
0000000000000000000000000000000000000000;;	  "net/http"
0000000000000000000000000000000000000000;;	  "fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func main() {
0000000000000000000000000000000000000000;;	  mux := http.NewServeMux()
0000000000000000000000000000000000000000;;	  mux.HandleFunc("/", func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;	    fmt.Fprintf(w, "Welcome to the home page!")
0000000000000000000000000000000000000000;;	  })
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  n := negroni.Classic()
0000000000000000000000000000000000000000;;	  n.UseHandler(mux)
0000000000000000000000000000000000000000;;	  n.Run(":3000")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then install the Negroni package (**go 1.1** and greater is required):
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	go get github.com/codegangsta/negroni
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Then run your server:
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	go run server.go
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You will now have a Go net/http webserver running on `localhost:3000`.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Need Help?
0000000000000000000000000000000000000000;;	If you have a question or feature request, [go ask the mailing list](https://groups.google.com/forum/#!forum/negroni-users). The GitHub issues for Negroni will be used exclusively for bug reports and pull requests.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Is Negroni a Framework?
0000000000000000000000000000000000000000;;	Negroni is **not** a framework. It is a library that is designed to work directly with net/http.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Routing?
0000000000000000000000000000000000000000;;	Negroni is BYOR (Bring your own Router). The Go community already has a number of great http routers available, Negroni tries to play well with all of them by fully supporting `net/http`. For instance, integrating with [Gorilla Mux](http://github.com/gorilla/mux) looks like so:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	router := mux.NewRouter()
0000000000000000000000000000000000000000;;	router.HandleFunc("/", HomeHandler)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	n := negroni.New(Middleware1, Middleware2)
0000000000000000000000000000000000000000;;	// Or use a middleware with the Use() function
0000000000000000000000000000000000000000;;	n.Use(Middleware3)
0000000000000000000000000000000000000000;;	// router goes last
0000000000000000000000000000000000000000;;	n.UseHandler(router)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	n.Run(":3000")
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## `negroni.Classic()`
0000000000000000000000000000000000000000;;	`negroni.Classic()` provides some default middleware that is useful for most applications:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* `negroni.Recovery` - Panic Recovery Middleware.
0000000000000000000000000000000000000000;;	* `negroni.Logging` - Request/Response Logging Middleware.
0000000000000000000000000000000000000000;;	* `negroni.Static` - Static File serving under the "public" directory.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This makes it really easy to get started with some useful features from Negroni.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Handlers
0000000000000000000000000000000000000000;;	Negroni provides a bidirectional middleware flow. This is done through the `negroni.Handler` interface:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	type Handler interface {
0000000000000000000000000000000000000000;;	  ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If a middleware hasn't already written to the ResponseWriter, it should call the next `http.HandlerFunc` in the chain to yield to the next middleware handler. This can be used for great good:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	func MyMiddleware(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
0000000000000000000000000000000000000000;;	  // do some stuff before
0000000000000000000000000000000000000000;;	  next(rw, r)
0000000000000000000000000000000000000000;;	  // do some stuff after
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	And you can map it to the handler chain with the `Use` function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	n := negroni.New()
0000000000000000000000000000000000000000;;	n.Use(negroni.HandlerFunc(MyMiddleware))
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can also map plain old `http.Handler`s:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	n := negroni.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	mux := http.NewServeMux()
0000000000000000000000000000000000000000;;	// map your routes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	n.UseHandler(mux)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	n.Run(":3000")
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## `Run()`
0000000000000000000000000000000000000000;;	Negroni has a convenience function called `Run`. `Run` takes an addr string identical to [http.ListenAndServe](http://golang.org/pkg/net/http#ListenAndServe).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	n := negroni.Classic()
0000000000000000000000000000000000000000;;	// ...
0000000000000000000000000000000000000000;;	log.Fatal(http.ListenAndServe(":8080", n))
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Route Specific Middleware
0000000000000000000000000000000000000000;;	If you have a route group of routes that need specific middleware to be executed, you can simply create a new Negroni instance and use it as your route handler.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	~~~ go
0000000000000000000000000000000000000000;;	router := mux.NewRouter()
0000000000000000000000000000000000000000;;	adminRoutes := mux.NewRouter()
0000000000000000000000000000000000000000;;	// add admin routes here
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new negroni for the admin middleware
0000000000000000000000000000000000000000;;	router.Handle("/admin", negroni.New(
0000000000000000000000000000000000000000;;	  Middleware1,
0000000000000000000000000000000000000000;;	  Middleware2,
0000000000000000000000000000000000000000;;	  negroni.Wrap(adminRoutes),
0000000000000000000000000000000000000000;;	))
0000000000000000000000000000000000000000;;	~~~
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Third Party Middleware
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Here is a current list of Negroni compatible middlware. Feel free to put up a PR linking your middleware if you have built one:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	| Middleware | Author | Description |
0000000000000000000000000000000000000000;;	| -----------|--------|-------------|
0000000000000000000000000000000000000000;;	| [RestGate](https://github.com/pjebs/restgate) | [Prasanga Siripala](https://github.com/pjebs) | Secure authentication for REST API endpoints |
0000000000000000000000000000000000000000;;	| [Graceful](https://github.com/stretchr/graceful) | [Tyler Bunnell](https://github.com/tylerb) | Graceful HTTP Shutdown |
0000000000000000000000000000000000000000;;	| [secure](https://github.com/unrolled/secure) | [Cory Jacobsen](https://github.com/unrolled) | Middleware that implements a few quick security wins |
0000000000000000000000000000000000000000;;	| [JWT Middleware](https://github.com/auth0/go-jwt-middleware) | [Auth0](https://github.com/auth0) | Middleware checks for a JWT on the `Authorization` header on incoming requests and decodes it|
0000000000000000000000000000000000000000;;	| [binding](https://github.com/mholt/binding) | [Matt Holt](https://github.com/mholt) | Data binding from HTTP requests into structs |
0000000000000000000000000000000000000000;;	| [logrus](https://github.com/meatballhat/negroni-logrus) | [Dan Buch](https://github.com/meatballhat) | Logrus-based logger |
0000000000000000000000000000000000000000;;	| [render](https://github.com/unrolled/render) | [Cory Jacobsen](https://github.com/unrolled) | Render JSON, XML and HTML templates |
0000000000000000000000000000000000000000;;	| [gorelic](https://github.com/jingweno/negroni-gorelic) | [Jingwen Owen Ou](https://github.com/jingweno) | New Relic agent for Go runtime |
0000000000000000000000000000000000000000;;	| [gzip](https://github.com/phyber/negroni-gzip) | [phyber](https://github.com/phyber) | GZIP response compression |
0000000000000000000000000000000000000000;;	| [oauth2](https://github.com/goincremental/negroni-oauth2) | [David Bochenski](https://github.com/bochenski) | oAuth2 middleware |
0000000000000000000000000000000000000000;;	| [sessions](https://github.com/goincremental/negroni-sessions) | [David Bochenski](https://github.com/bochenski) | Session Management |
0000000000000000000000000000000000000000;;	| [permissions2](https://github.com/xyproto/permissions2) | [Alexander Rødseth](https://github.com/xyproto) | Cookies, users and permissions |
0000000000000000000000000000000000000000;;	| [onthefly](https://github.com/xyproto/onthefly) | [Alexander Rødseth](https://github.com/xyproto) | Generate TinySVG, HTML and CSS on the fly |
0000000000000000000000000000000000000000;;	| [cors](https://github.com/rs/cors) | [Olivier Poitrey](https://github.com/rs) | [Cross Origin Resource Sharing](http://www.w3.org/TR/cors/) (CORS) support |
0000000000000000000000000000000000000000;;	| [xrequestid](https://github.com/pilu/xrequestid) | [Andrea Franz](https://github.com/pilu) | Middleware that assigns a random X-Request-Id header to each request |
0000000000000000000000000000000000000000;;	| [VanGoH](https://github.com/auroratechnologies/vangoh) | [Taylor Wrobel](https://github.com/twrobel3) | Configurable [AWS-Style](http://docs.aws.amazon.com/AmazonS3/latest/dev/RESTAuthentication.html) HMAC authentication middleware |
0000000000000000000000000000000000000000;;	| [stats](https://github.com/thoas/stats) | [Florent Messa](https://github.com/thoas) | Store information about your web application (response time, etc.) |
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Examples
0000000000000000000000000000000000000000;;	[Alexander Rødseth](https://github.com/xyproto) created [mooseware](https://github.com/xyproto/mooseware), a skeleton for writing a Negroni middleware handler.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Live code reload?
0000000000000000000000000000000000000000;;	[gin](https://github.com/codegangsta/gin) and [fresh](https://github.com/pilu/fresh) both live reload negroni apps.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Essential Reading for Beginners of Go & Negroni
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	* [Using a Context to pass information from middleware to end handler](http://elithrar.github.io/article/map-string-interface/)
0000000000000000000000000000000000000000;;	* [Understanding middleware](http://mattstauffer.co/blog/laravel-5.0-middleware-replacing-filters)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## About
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Negroni is obsessively designed by none other than the [Code Gangsta](http://codegangsta.io/)
