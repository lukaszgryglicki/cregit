0000000000000000000000000000000000000000;;	package negroni
2300ac0e08fc49b83d6c5f7668561f728a0b380c;Godeps/_workspace/src/github.com/codegangsta/negroni/static.go[Godeps/_workspace/src/github.com/codegangsta/negroni/static.go][vendor/github.com/codegangsta/negroni/static.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Static is a middleware handler that serves static files in the given directory/filesystem.
0000000000000000000000000000000000000000;;	type Static struct {
0000000000000000000000000000000000000000;;		// Dir is the directory to serve static files from
0000000000000000000000000000000000000000;;		Dir http.FileSystem
0000000000000000000000000000000000000000;;		// Prefix is the optional prefix used to serve the static directory content
0000000000000000000000000000000000000000;;		Prefix string
0000000000000000000000000000000000000000;;		// IndexFile defines which file to serve as index if it exists.
0000000000000000000000000000000000000000;;		IndexFile string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewStatic returns a new instance of Static
0000000000000000000000000000000000000000;;	func NewStatic(directory http.FileSystem) *Static {
0000000000000000000000000000000000000000;;		return &Static{
0000000000000000000000000000000000000000;;			Dir:       directory,
0000000000000000000000000000000000000000;;			Prefix:    "",
0000000000000000000000000000000000000000;;			IndexFile: "index.html",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Static) ServeHTTP(rw http.ResponseWriter, r *http.Request, next http.HandlerFunc) {
0000000000000000000000000000000000000000;;		if r.Method != "GET" && r.Method != "HEAD" {
0000000000000000000000000000000000000000;;			next(rw, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		file := r.URL.Path
0000000000000000000000000000000000000000;;		// if we have a prefix, filter requests by stripping the prefix
0000000000000000000000000000000000000000;;		if s.Prefix != "" {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(file, s.Prefix) {
0000000000000000000000000000000000000000;;				next(rw, r)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			file = file[len(s.Prefix):]
0000000000000000000000000000000000000000;;			if file != "" && file[0] != '/' {
0000000000000000000000000000000000000000;;				next(rw, r)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f, err := s.Dir.Open(file)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// discard the error?
0000000000000000000000000000000000000000;;			next(rw, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fi, err := f.Stat()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			next(rw, r)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to serve index file
0000000000000000000000000000000000000000;;		if fi.IsDir() {
0000000000000000000000000000000000000000;;			// redirect if missing trailing slash
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(r.URL.Path, "/") {
0000000000000000000000000000000000000000;;				http.Redirect(rw, r, r.URL.Path+"/", http.StatusFound)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			file = path.Join(file, s.IndexFile)
0000000000000000000000000000000000000000;;			f, err = s.Dir.Open(file)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				next(rw, r)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			defer f.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fi, err = f.Stat()
0000000000000000000000000000000000000000;;			if err != nil || fi.IsDir() {
0000000000000000000000000000000000000000;;				next(rw, r)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		http.ServeContent(rw, r, file, fi.ModTime(), f)
0000000000000000000000000000000000000000;;	}
