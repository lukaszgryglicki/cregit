0000000000000000000000000000000000000000;;	package probing
5da4772d7eee0df4a5bf872fd32f72643fc2e5c9;Godeps/_workspace/src/github.com/xiang90/probing/prober.go[Godeps/_workspace/src/github.com/xiang90/probing/prober.go][vendor/github.com/xiang90/probing/prober.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrNotFound = errors.New("probing: id not found")
0000000000000000000000000000000000000000;;		ErrExist    = errors.New("probing: id exists")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Prober interface {
0000000000000000000000000000000000000000;;		AddHTTP(id string, probingInterval time.Duration, endpoints []string) error
0000000000000000000000000000000000000000;;		Remove(id string) error
0000000000000000000000000000000000000000;;		RemoveAll()
0000000000000000000000000000000000000000;;		Reset(id string) error
0000000000000000000000000000000000000000;;		Status(id string) (Status, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type prober struct {
0000000000000000000000000000000000000000;;		mu      sync.Mutex
0000000000000000000000000000000000000000;;		targets map[string]*status
0000000000000000000000000000000000000000;;		tr      http.RoundTripper
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewProber(tr http.RoundTripper) Prober {
0000000000000000000000000000000000000000;;		p := &prober{targets: make(map[string]*status)}
0000000000000000000000000000000000000000;;		if tr == nil {
0000000000000000000000000000000000000000;;			p.tr = http.DefaultTransport
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.tr = tr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *prober) AddHTTP(id string, probingInterval time.Duration, endpoints []string) error {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;		if _, ok := p.targets[id]; ok {
0000000000000000000000000000000000000000;;			return ErrExist
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := &status{stopC: make(chan struct{})}
0000000000000000000000000000000000000000;;		p.targets[id] = s
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ticker := time.NewTicker(probingInterval)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			pinned := 0
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				select {
0000000000000000000000000000000000000000;;				case <-ticker.C:
0000000000000000000000000000000000000000;;					start := time.Now()
0000000000000000000000000000000000000000;;					req, err := http.NewRequest("GET", endpoints[pinned], nil)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						panic(err)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					resp, err := p.tr.RoundTrip(req)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						s.recordFailure(err)
0000000000000000000000000000000000000000;;						pinned = (pinned + 1) % len(endpoints)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					var hh Health
0000000000000000000000000000000000000000;;					d := json.NewDecoder(resp.Body)
0000000000000000000000000000000000000000;;					err = d.Decode(&hh)
0000000000000000000000000000000000000000;;					resp.Body.Close()
0000000000000000000000000000000000000000;;					if err != nil || !hh.OK {
0000000000000000000000000000000000000000;;						s.recordFailure(err)
0000000000000000000000000000000000000000;;						pinned = (pinned + 1) % len(endpoints)
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					s.record(time.Since(start), hh.Now)
0000000000000000000000000000000000000000;;				case <-s.stopC:
0000000000000000000000000000000000000000;;					ticker.Stop()
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *prober) Remove(id string) error {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, ok := p.targets[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(s.stopC)
0000000000000000000000000000000000000000;;		delete(p.targets, id)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *prober) RemoveAll() {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, s := range p.targets {
0000000000000000000000000000000000000000;;			close(s.stopC)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.targets = make(map[string]*status)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *prober) Reset(id string) error {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, ok := p.targets[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.reset()
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *prober) Status(id string) (Status, error) {
0000000000000000000000000000000000000000;;		p.mu.Lock()
0000000000000000000000000000000000000000;;		defer p.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, ok := p.targets[id]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, ErrNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
