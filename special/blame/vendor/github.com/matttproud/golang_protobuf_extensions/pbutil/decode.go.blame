0000000000000000000000000000000000000000;;	// Copyright 2013 Matt T. Proud
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
877581fa542c3af74aa2ed7addf6c8f7c20680ee;Godeps/_workspace/src/github.com/matttproud/golang_protobuf_extensions/ext/decode.go[Godeps/_workspace/src/github.com/matttproud/golang_protobuf_extensions/ext/decode.go][vendor/github.com/matttproud/golang_protobuf_extensions/pbutil/decode.go];	
0000000000000000000000000000000000000000;;	package pbutil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/golang/protobuf/proto"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errInvalidVarint = errors.New("invalid varint32 encountered")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadDelimited decodes a message from the provided length-delimited stream,
0000000000000000000000000000000000000000;;	// where the length is encoded as 32-bit varint prefix to the message body.
0000000000000000000000000000000000000000;;	// It returns the total number of bytes read and any applicable error.  This is
0000000000000000000000000000000000000000;;	// roughly equivalent to the companion Java API's
0000000000000000000000000000000000000000;;	// MessageLite#parseDelimitedFrom.  As per the reader contract, this function
0000000000000000000000000000000000000000;;	// calls r.Read repeatedly as required until exactly one message including its
0000000000000000000000000000000000000000;;	// prefix is read and decoded (or an error has occurred).  The function never
0000000000000000000000000000000000000000;;	// reads more bytes from the stream than required.  The function never returns
0000000000000000000000000000000000000000;;	// an error if a message has been read and decoded correctly, even if the end
0000000000000000000000000000000000000000;;	// of the stream has been reached in doing so.  In that case, any subsequent
0000000000000000000000000000000000000000;;	// calls return (0, io.EOF).
0000000000000000000000000000000000000000;;	func ReadDelimited(r io.Reader, m proto.Message) (n int, err error) {
0000000000000000000000000000000000000000;;		// Per AbstractParser#parsePartialDelimitedFrom with
0000000000000000000000000000000000000000;;		// CodedInputStream#readRawVarint32.
0000000000000000000000000000000000000000;;		headerBuf := make([]byte, binary.MaxVarintLen32)
0000000000000000000000000000000000000000;;		var bytesRead, varIntBytes int
0000000000000000000000000000000000000000;;		var messageLength uint64
0000000000000000000000000000000000000000;;		for varIntBytes == 0 { // i.e. no varint has been decoded yet.
0000000000000000000000000000000000000000;;			if bytesRead >= len(headerBuf) {
0000000000000000000000000000000000000000;;				return bytesRead, errInvalidVarint
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// We have to read byte by byte here to avoid reading more bytes
0000000000000000000000000000000000000000;;			// than required. Each read byte is appended to what we have
0000000000000000000000000000000000000000;;			// read before.
0000000000000000000000000000000000000000;;			newBytesRead, err := r.Read(headerBuf[bytesRead : bytesRead+1])
0000000000000000000000000000000000000000;;			if newBytesRead == 0 {
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return bytesRead, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// A Reader should not return (0, nil), but if it does,
0000000000000000000000000000000000000000;;				// it should be treated as no-op (according to the
0000000000000000000000000000000000000000;;				// Reader contract). So let's go on...
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bytesRead += newBytesRead
0000000000000000000000000000000000000000;;			// Now present everything read so far to the varint decoder and
0000000000000000000000000000000000000000;;			// see if a varint can be decoded already.
0000000000000000000000000000000000000000;;			messageLength, varIntBytes = proto.DecodeVarint(headerBuf[:bytesRead])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		messageBuf := make([]byte, messageLength)
0000000000000000000000000000000000000000;;		newBytesRead, err := io.ReadFull(r, messageBuf)
0000000000000000000000000000000000000000;;		bytesRead += newBytesRead
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return bytesRead, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return bytesRead, proto.Unmarshal(messageBuf, m)
0000000000000000000000000000000000000000;;	}
