0000000000000000000000000000000000000000;;	package assetfs
1d2ee0aad713dc52fcf5041bd5c8c56db4ebfbe2;Godeps/_workspace/src/github.com/elazarl/go-bindata-assetfs/assetfs.go[Godeps/_workspace/src/github.com/elazarl/go-bindata-assetfs/assetfs.go][vendor/github.com/elazarl/go-bindata-assetfs/assetfs.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		fileTimestamp = time.Now()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FakeFile implements os.FileInfo interface for a given path and size
0000000000000000000000000000000000000000;;	type FakeFile struct {
0000000000000000000000000000000000000000;;		// Path is the path of this file
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		// Dir marks of the path is a directory
0000000000000000000000000000000000000000;;		Dir bool
0000000000000000000000000000000000000000;;		// Len is the length of the fake file, zero if it is a directory
0000000000000000000000000000000000000000;;		Len int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeFile) Name() string {
0000000000000000000000000000000000000000;;		_, name := filepath.Split(f.Path)
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeFile) Mode() os.FileMode {
0000000000000000000000000000000000000000;;		mode := os.FileMode(0644)
0000000000000000000000000000000000000000;;		if f.Dir {
0000000000000000000000000000000000000000;;			return mode | os.ModeDir
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeFile) ModTime() time.Time {
0000000000000000000000000000000000000000;;		return fileTimestamp
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeFile) Size() int64 {
0000000000000000000000000000000000000000;;		return f.Len
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeFile) IsDir() bool {
0000000000000000000000000000000000000000;;		return f.Mode().IsDir()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *FakeFile) Sys() interface{} {
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssetFile implements http.File interface for a no-directory file with content
0000000000000000000000000000000000000000;;	type AssetFile struct {
0000000000000000000000000000000000000000;;		*bytes.Reader
0000000000000000000000000000000000000000;;		io.Closer
0000000000000000000000000000000000000000;;		FakeFile
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAssetFile(name string, content []byte) *AssetFile {
0000000000000000000000000000000000000000;;		return &AssetFile{
0000000000000000000000000000000000000000;;			bytes.NewReader(content),
0000000000000000000000000000000000000000;;			ioutil.NopCloser(nil),
0000000000000000000000000000000000000000;;			FakeFile{name, false, int64(len(content))}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *AssetFile) Readdir(count int) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return nil, errors.New("not a directory")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *AssetFile) Size() int64 {
0000000000000000000000000000000000000000;;		return f.FakeFile.Size()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *AssetFile) Stat() (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssetDirectory implements http.File interface for a directory
0000000000000000000000000000000000000000;;	type AssetDirectory struct {
0000000000000000000000000000000000000000;;		AssetFile
0000000000000000000000000000000000000000;;		ChildrenRead int
0000000000000000000000000000000000000000;;		Children     []os.FileInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewAssetDirectory(name string, children []string, fs *AssetFS) *AssetDirectory {
0000000000000000000000000000000000000000;;		fileinfos := make([]os.FileInfo, 0, len(children))
0000000000000000000000000000000000000000;;		for _, child := range children {
0000000000000000000000000000000000000000;;			_, err := fs.AssetDir(filepath.Join(name, child))
0000000000000000000000000000000000000000;;			fileinfos = append(fileinfos, &FakeFile{child, err == nil, 0})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &AssetDirectory{
0000000000000000000000000000000000000000;;			AssetFile{
0000000000000000000000000000000000000000;;				bytes.NewReader(nil),
0000000000000000000000000000000000000000;;				ioutil.NopCloser(nil),
0000000000000000000000000000000000000000;;				FakeFile{name, true, 0},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			0,
0000000000000000000000000000000000000000;;			fileinfos}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *AssetDirectory) Readdir(count int) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		if count <= 0 {
0000000000000000000000000000000000000000;;			return f.Children, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f.ChildrenRead+count > len(f.Children) {
0000000000000000000000000000000000000000;;			count = len(f.Children) - f.ChildrenRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rv := f.Children[f.ChildrenRead : f.ChildrenRead+count]
0000000000000000000000000000000000000000;;		f.ChildrenRead += count
0000000000000000000000000000000000000000;;		return rv, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *AssetDirectory) Stat() (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssetFS implements http.FileSystem, allowing
0000000000000000000000000000000000000000;;	// embedded files to be served from net/http package.
0000000000000000000000000000000000000000;;	type AssetFS struct {
0000000000000000000000000000000000000000;;		// Asset should return content of file in path if exists
0000000000000000000000000000000000000000;;		Asset func(path string) ([]byte, error)
0000000000000000000000000000000000000000;;		// AssetDir should return list of files in the path
0000000000000000000000000000000000000000;;		AssetDir func(path string) ([]string, error)
0000000000000000000000000000000000000000;;		// Prefix would be prepended to http requests
0000000000000000000000000000000000000000;;		Prefix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (fs *AssetFS) Open(name string) (http.File, error) {
0000000000000000000000000000000000000000;;		name = path.Join(fs.Prefix, name)
0000000000000000000000000000000000000000;;		if len(name) > 0 && name[0] == '/' {
0000000000000000000000000000000000000000;;			name = name[1:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b, err := fs.Asset(name); err == nil {
0000000000000000000000000000000000000000;;			return NewAssetFile(name, b), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if children, err := fs.AssetDir(name); err == nil {
0000000000000000000000000000000000000000;;			return NewAssetDirectory(name, children, fs), nil
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
