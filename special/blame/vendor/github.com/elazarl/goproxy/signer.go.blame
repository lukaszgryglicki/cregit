0000000000000000000000000000000000000000;;	package goproxy
d1fe717eabb388da4fbd9a76bce087a5ce94de70;Godeps/_workspace/src/github.com/elazarl/goproxy/signer.go[Godeps/_workspace/src/github.com/elazarl/goproxy/signer.go][vendor/github.com/elazarl/goproxy/signer.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"crypto/x509/pkix"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hashSorted(lst []string) []byte {
0000000000000000000000000000000000000000;;		c := make([]string, len(lst))
0000000000000000000000000000000000000000;;		copy(c, lst)
0000000000000000000000000000000000000000;;		sort.Strings(c)
0000000000000000000000000000000000000000;;		h := sha1.New()
0000000000000000000000000000000000000000;;		for _, s := range c {
0000000000000000000000000000000000000000;;			h.Write([]byte(s + ","))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h.Sum(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func hashSortedBigInt(lst []string) *big.Int {
0000000000000000000000000000000000000000;;		rv := new(big.Int)
0000000000000000000000000000000000000000;;		rv.SetBytes(hashSorted(lst))
0000000000000000000000000000000000000000;;		return rv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var goproxySignerVersion = ":goroxy1"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func signHost(ca tls.Certificate, hosts []string) (cert tls.Certificate, err error) {
0000000000000000000000000000000000000000;;		var x509ca *x509.Certificate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Use the provided ca and not the global GoproxyCa for certificate generation.
0000000000000000000000000000000000000000;;		if x509ca, err = x509.ParseCertificate(ca.Certificate[0]); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start := time.Unix(0, 0)
0000000000000000000000000000000000000000;;		end, err := time.Parse("2006-01-02", "2049-12-31")
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := hashSorted(append(hosts, goproxySignerVersion, ":"+runtime.Version()))
0000000000000000000000000000000000000000;;		serial := new(big.Int)
0000000000000000000000000000000000000000;;		serial.SetBytes(hash)
0000000000000000000000000000000000000000;;		template := x509.Certificate{
0000000000000000000000000000000000000000;;			// TODO(elazar): instead of this ugly hack, just encode the certificate and hash the binary form.
0000000000000000000000000000000000000000;;			SerialNumber: serial,
0000000000000000000000000000000000000000;;			Issuer:       x509ca.Subject,
0000000000000000000000000000000000000000;;			Subject: pkix.Name{
0000000000000000000000000000000000000000;;				Organization: []string{"GoProxy untrusted MITM proxy Inc"},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			NotBefore: start,
0000000000000000000000000000000000000000;;			NotAfter:  end,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			KeyUsage:              x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,
0000000000000000000000000000000000000000;;			ExtKeyUsage:           []x509.ExtKeyUsage{x509.ExtKeyUsageServerAuth},
0000000000000000000000000000000000000000;;			BasicConstraintsValid: true,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, h := range hosts {
0000000000000000000000000000000000000000;;			if ip := net.ParseIP(h); ip != nil {
0000000000000000000000000000000000000000;;				template.IPAddresses = append(template.IPAddresses, ip)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				template.DNSNames = append(template.DNSNames, h)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var csprng CounterEncryptorRand
0000000000000000000000000000000000000000;;		if csprng, err = NewCounterEncryptorRandFromKey(ca.PrivateKey, hash); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var certpriv *rsa.PrivateKey
0000000000000000000000000000000000000000;;		if certpriv, err = rsa.GenerateKey(&csprng, 1024); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var derBytes []byte
0000000000000000000000000000000000000000;;		if derBytes, err = x509.CreateCertificate(&csprng, &template, x509ca, &certpriv.PublicKey, ca.PrivateKey); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tls.Certificate{
0000000000000000000000000000000000000000;;			Certificate: [][]byte{derBytes, ca.Certificate[0]},
0000000000000000000000000000000000000000;;			PrivateKey:  certpriv,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
