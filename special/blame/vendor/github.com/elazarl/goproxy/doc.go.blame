0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package goproxy provides a customizable HTTP proxy,
0000000000000000000000000000000000000000;;	supporting hijacking HTTPS connection.
d1fe717eabb388da4fbd9a76bce087a5ce94de70;Godeps/_workspace/src/github.com/elazarl/goproxy/doc.go[Godeps/_workspace/src/github.com/elazarl/goproxy/doc.go][vendor/github.com/elazarl/goproxy/doc.go];	
0000000000000000000000000000000000000000;;	The intent of the proxy, is to be usable with reasonable amount of traffic
0000000000000000000000000000000000000000;;	yet, customizable and programable.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The proxy itself is simply an `net/http` handler.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Typical usage is
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy := goproxy.NewProxyHttpServer()
0000000000000000000000000000000000000000;;		proxy.OnRequest(..conditions..).Do(..requesthandler..)
0000000000000000000000000000000000000000;;		proxy.OnRequest(..conditions..).DoFunc(..requesthandlerFunction..)
0000000000000000000000000000000000000000;;		proxy.OnResponse(..conditions..).Do(..responesHandler..)
0000000000000000000000000000000000000000;;		proxy.OnResponse(..conditions..).DoFunc(..responesHandlerFunction..)
0000000000000000000000000000000000000000;;		http.ListenAndServe(":8080", proxy)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Adding a header to each request
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy.OnRequest().DoFunc(func(r *http.Request,ctx *goproxy.ProxyCtx) (*http.Request, *http.Response){
0000000000000000000000000000000000000000;;			r.Header.Set("X-GoProxy","1")
0000000000000000000000000000000000000000;;			return r, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note that the function is called before the proxy sends the request to the server
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For printing the content type of all incoming responses
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy.OnResponse().DoFunc(func(r *http.Response, ctx *goproxy.ProxyCtx)*http.Response{
0000000000000000000000000000000000000000;;			println(ctx.Req.Host,"->",r.Header.Get("Content-Type"))
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	note that we used the ProxyCtx context variable here. It contains the request
0000000000000000000000000000000000000000;;	and the response (Req and Resp, Resp is nil if unavailable) of this specific client
0000000000000000000000000000000000000000;;	interaction with the proxy.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To print the content type of all responses from a certain url, we'll add a
0000000000000000000000000000000000000000;;	ReqCondition to the OnResponse function:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy.OnResponse(goproxy.UrlIs("golang.org/pkg")).DoFunc(func(r *http.Response, ctx *goproxy.ProxyCtx)*http.Response{
0000000000000000000000000000000000000000;;			println(ctx.Req.Host,"->",r.Header.Get("Content-Type"))
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	We can write the condition ourselves, conditions can be set on request and on response
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var random = ReqConditionFunc(func(r *http.Request) bool {
0000000000000000000000000000000000000000;;			return rand.Intn(1) == 0
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		var hasGoProxyHeader = RespConditionFunc(func(resp *http.Response,req *http.Request)bool {
0000000000000000000000000000000000000000;;			return resp.Header.Get("X-GoProxy") != ""
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Caution! If you give a RespCondition to the OnRequest function, you'll get a run time panic! It doesn't
0000000000000000000000000000000000000000;;	make sense to read the response, if you still haven't got it!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Finally, we have convenience function to throw a quick response
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxy.OnResponse(hasGoProxyHeader).DoFunc(func(r*http.Response,ctx *goproxy.ProxyCtx)*http.Response {
0000000000000000000000000000000000000000;;			r.Body.Close()
0000000000000000000000000000000000000000;;			return goproxy.ForbiddenTextResponse(ctx.Req,"Can't see response with X-GoProxy header!")
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	we close the body of the original repsonse, and return a new 403 response with a short message.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Example use cases:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. https://github.com/elazarl/goproxy/tree/master/examples/goproxy-avgsize
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	To measure the average size of an Html served in your site. One can ask
0000000000000000000000000000000000000000;;	all the QA team to access the website by a proxy, and the proxy will
0000000000000000000000000000000000000000;;	measure the average size of all text/html responses from your host.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	2. [not yet implemented]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	All requests to your web servers should be directed through the proxy,
0000000000000000000000000000000000000000;;	when the proxy will detect html pieces sent as a response to AJAX
0000000000000000000000000000000000000000;;	request, it'll send a warning email.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	3. https://github.com/elazarl/goproxy/blob/master/examples/goproxy-httpdump/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Generate a real traffic to your website by real users using through
0000000000000000000000000000000000000000;;	proxy. Record the traffic, and try it again for more real load testing.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	4. https://github.com/elazarl/goproxy/tree/master/examples/goproxy-no-reddit-at-worktime
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Will allow browsing to reddit.com between 8:00am and 17:00pm
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	5. https://github.com/elazarl/goproxy/tree/master/examples/goproxy-jquery-version
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Will warn if multiple versions of jquery are used in the same domain.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	6. https://github.com/elazarl/goproxy/blob/master/examples/goproxy-upside-down-ternet/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Modifies image files in an HTTP response via goproxy's image extension found in ext/.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package goproxy
