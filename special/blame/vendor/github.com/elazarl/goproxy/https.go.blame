0000000000000000000000000000000000000000;;	package goproxy
d1fe717eabb388da4fbd9a76bce087a5ce94de70;Godeps/_workspace/src/github.com/elazarl/goproxy/https.go[Godeps/_workspace/src/github.com/elazarl/goproxy/https.go][vendor/github.com/elazarl/goproxy/https.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConnectActionLiteral int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		ConnectAccept = iota
0000000000000000000000000000000000000000;;		ConnectReject
0000000000000000000000000000000000000000;;		ConnectMitm
0000000000000000000000000000000000000000;;		ConnectHijack
0000000000000000000000000000000000000000;;		ConnectHTTPMitm
0000000000000000000000000000000000000000;;		ConnectProxyAuthHijack
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		OkConnect       = &ConnectAction{Action: ConnectAccept, TLSConfig: TLSConfigFromCA(&GoproxyCa)}
0000000000000000000000000000000000000000;;		MitmConnect     = &ConnectAction{Action: ConnectMitm, TLSConfig: TLSConfigFromCA(&GoproxyCa)}
0000000000000000000000000000000000000000;;		HTTPMitmConnect = &ConnectAction{Action: ConnectHTTPMitm, TLSConfig: TLSConfigFromCA(&GoproxyCa)}
0000000000000000000000000000000000000000;;		RejectConnect   = &ConnectAction{Action: ConnectReject, TLSConfig: TLSConfigFromCA(&GoproxyCa)}
0000000000000000000000000000000000000000;;		httpsRegexp     = regexp.MustCompile(`^https:\/\/`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ConnectAction struct {
0000000000000000000000000000000000000000;;		Action    ConnectActionLiteral
0000000000000000000000000000000000000000;;		Hijack    func(req *http.Request, client net.Conn, ctx *ProxyCtx)
0000000000000000000000000000000000000000;;		TLSConfig func(host string, ctx *ProxyCtx) (*tls.Config, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func stripPort(s string) string {
0000000000000000000000000000000000000000;;		ix := strings.IndexRune(s, ':')
0000000000000000000000000000000000000000;;		if ix == -1 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s[:ix]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) dial(network, addr string) (c net.Conn, err error) {
0000000000000000000000000000000000000000;;		if proxy.Tr.Dial != nil {
0000000000000000000000000000000000000000;;			return proxy.Tr.Dial(network, addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return net.Dial(network, addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) connectDial(network, addr string) (c net.Conn, err error) {
0000000000000000000000000000000000000000;;		if proxy.ConnectDial == nil {
0000000000000000000000000000000000000000;;			return proxy.dial(network, addr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return proxy.ConnectDial(network, addr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) handleHttps(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		ctx := &ProxyCtx{Req: r, Session: atomic.AddInt64(&proxy.sess, 1), proxy: proxy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hij, ok := w.(http.Hijacker)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic("httpserver does not support hijacking")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		proxyClient, _, e := hij.Hijack()
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			panic("Cannot hijack connection " + e.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ctx.Logf("Running %d CONNECT handlers", len(proxy.httpsHandlers))
0000000000000000000000000000000000000000;;		todo, host := OkConnect, r.URL.Host
0000000000000000000000000000000000000000;;		for i, h := range proxy.httpsHandlers {
0000000000000000000000000000000000000000;;			newtodo, newhost := h.HandleConnect(host, ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If found a result, break the loop immediately
0000000000000000000000000000000000000000;;			if newtodo != nil {
0000000000000000000000000000000000000000;;				todo, host = newtodo, newhost
0000000000000000000000000000000000000000;;				ctx.Logf("on %dth handler: %v %s", i, todo, host)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch todo.Action {
0000000000000000000000000000000000000000;;		case ConnectAccept:
0000000000000000000000000000000000000000;;			if !hasPort.MatchString(host) {
0000000000000000000000000000000000000000;;				host += ":80"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			targetSiteCon, err := proxy.connectDial("tcp", host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				httpError(proxyClient, ctx, err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx.Logf("Accepting CONNECT to %s", host)
0000000000000000000000000000000000000000;;			proxyClient.Write([]byte("HTTP/1.0 200 OK\r\n\r\n"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			targetTCP, targetOK := targetSiteCon.(*net.TCPConn)
0000000000000000000000000000000000000000;;			proxyClientTCP, clientOK := proxyClient.(*net.TCPConn)
0000000000000000000000000000000000000000;;			if targetOK && clientOK {
0000000000000000000000000000000000000000;;				go copyAndClose(ctx, targetTCP, proxyClientTCP)
0000000000000000000000000000000000000000;;				go copyAndClose(ctx, proxyClientTCP, targetTCP)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				go func() {
0000000000000000000000000000000000000000;;					var wg sync.WaitGroup
0000000000000000000000000000000000000000;;					wg.Add(2)
0000000000000000000000000000000000000000;;					go copyOrWarn(ctx, targetSiteCon, proxyClient, &wg)
0000000000000000000000000000000000000000;;					go copyOrWarn(ctx, proxyClient, targetSiteCon, &wg)
0000000000000000000000000000000000000000;;					wg.Wait()
0000000000000000000000000000000000000000;;					proxyClient.Close()
0000000000000000000000000000000000000000;;					targetSiteCon.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ConnectHijack:
0000000000000000000000000000000000000000;;			ctx.Logf("Hijacking CONNECT to %s", host)
0000000000000000000000000000000000000000;;			proxyClient.Write([]byte("HTTP/1.0 200 OK\r\n\r\n"))
0000000000000000000000000000000000000000;;			todo.Hijack(r, proxyClient, ctx)
0000000000000000000000000000000000000000;;		case ConnectHTTPMitm:
0000000000000000000000000000000000000000;;			proxyClient.Write([]byte("HTTP/1.0 200 OK\r\n\r\n"))
0000000000000000000000000000000000000000;;			ctx.Logf("Assuming CONNECT is plain HTTP tunneling, mitm proxying it")
0000000000000000000000000000000000000000;;			targetSiteCon, err := proxy.connectDial("tcp", host)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				ctx.Warnf("Error dialing to %s: %s", host, err.Error())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				client := bufio.NewReader(proxyClient)
0000000000000000000000000000000000000000;;				remote := bufio.NewReader(targetSiteCon)
0000000000000000000000000000000000000000;;				req, err := http.ReadRequest(client)
0000000000000000000000000000000000000000;;				if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;					ctx.Warnf("cannot read request of MITM HTTP client: %+#v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				req, resp := proxy.filterRequest(req, ctx)
0000000000000000000000000000000000000000;;				if resp == nil {
0000000000000000000000000000000000000000;;					if err := req.Write(targetSiteCon); err != nil {
0000000000000000000000000000000000000000;;						httpError(proxyClient, ctx, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					resp, err = http.ReadResponse(remote, req)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						httpError(proxyClient, ctx, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					defer resp.Body.Close()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				resp = proxy.filterResponse(resp, ctx)
0000000000000000000000000000000000000000;;				if err := resp.Write(proxyClient); err != nil {
0000000000000000000000000000000000000000;;					httpError(proxyClient, ctx, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ConnectMitm:
0000000000000000000000000000000000000000;;			proxyClient.Write([]byte("HTTP/1.0 200 OK\r\n\r\n"))
0000000000000000000000000000000000000000;;			ctx.Logf("Assuming CONNECT is TLS, mitm proxying it")
0000000000000000000000000000000000000000;;			// this goes in a separate goroutine, so that the net/http server won't think we're
0000000000000000000000000000000000000000;;			// still handling the request even after hijacking the connection. Those HTTP CONNECT
0000000000000000000000000000000000000000;;			// request can take forever, and the server will be stuck when "closed".
0000000000000000000000000000000000000000;;			// TODO: Allow Server.Close() mechanism to shut down this connection as nicely as possible
0000000000000000000000000000000000000000;;			tlsConfig := defaultTLSConfig
0000000000000000000000000000000000000000;;			if todo.TLSConfig != nil {
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;				tlsConfig, err = todo.TLSConfig(host, ctx)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					httpError(proxyClient, ctx, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				//TODO: cache connections to the remote website
0000000000000000000000000000000000000000;;				rawClientTls := tls.Server(proxyClient, tlsConfig)
0000000000000000000000000000000000000000;;				if err := rawClientTls.Handshake(); err != nil {
0000000000000000000000000000000000000000;;					ctx.Warnf("Cannot handshake client %v %v", r.Host, err)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer rawClientTls.Close()
0000000000000000000000000000000000000000;;				clientTlsReader := bufio.NewReader(rawClientTls)
0000000000000000000000000000000000000000;;				for !isEof(clientTlsReader) {
0000000000000000000000000000000000000000;;					req, err := http.ReadRequest(clientTlsReader)
0000000000000000000000000000000000000000;;					var ctx = &ProxyCtx{Req: req, Session: atomic.AddInt64(&proxy.sess, 1), proxy: proxy}
0000000000000000000000000000000000000000;;					if err != nil && err != io.EOF {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						ctx.Warnf("Cannot read TLS request from mitm'd client %v %v", r.Host, err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					req.RemoteAddr = r.RemoteAddr // since we're converting the request, need to carry over the original connecting IP as well
0000000000000000000000000000000000000000;;					ctx.Logf("req %v", r.Host)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if !httpsRegexp.MatchString(req.URL.String()) {
0000000000000000000000000000000000000000;;						req.URL, err = url.Parse("https://" + r.Host + req.URL.String())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Bug fix which goproxy fails to provide request
0000000000000000000000000000000000000000;;					// information URL in the context when does HTTPS MITM
0000000000000000000000000000000000000000;;					ctx.Req = req
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					req, resp := proxy.filterRequest(req, ctx)
0000000000000000000000000000000000000000;;					if resp == nil {
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							ctx.Warnf("Illegal URL %s", "https://"+r.Host+req.URL.Path)
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						removeProxyHeaders(ctx, req)
0000000000000000000000000000000000000000;;						resp, err = ctx.RoundTrip(req)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							ctx.Warnf("Cannot read TLS response from mitm'd server %v", err)
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						ctx.Logf("resp %v", resp.Status)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					resp = proxy.filterResponse(resp, ctx)
0000000000000000000000000000000000000000;;					defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					text := resp.Status
0000000000000000000000000000000000000000;;					statusCode := strconv.Itoa(resp.StatusCode) + " "
0000000000000000000000000000000000000000;;					if strings.HasPrefix(text, statusCode) {
0000000000000000000000000000000000000000;;						text = text[len(statusCode):]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// always use 1.1 to support chunked encoding
0000000000000000000000000000000000000000;;					if _, err := io.WriteString(rawClientTls, "HTTP/1.1"+" "+statusCode+text+"\r\n"); err != nil {
0000000000000000000000000000000000000000;;						ctx.Warnf("Cannot write TLS response HTTP status from mitm'd client: %v", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Since we don't know the length of resp, return chunked encoded response
0000000000000000000000000000000000000000;;					// TODO: use a more reasonable scheme
0000000000000000000000000000000000000000;;					resp.Header.Del("Content-Length")
0000000000000000000000000000000000000000;;					resp.Header.Set("Transfer-Encoding", "chunked")
0000000000000000000000000000000000000000;;					if err := resp.Header.Write(rawClientTls); err != nil {
0000000000000000000000000000000000000000;;						ctx.Warnf("Cannot write TLS response header from mitm'd client: %v", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if _, err = io.WriteString(rawClientTls, "\r\n"); err != nil {
0000000000000000000000000000000000000000;;						ctx.Warnf("Cannot write TLS response header end from mitm'd client: %v", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					chunked := newChunkedWriter(rawClientTls)
0000000000000000000000000000000000000000;;					if _, err := io.Copy(chunked, resp.Body); err != nil {
0000000000000000000000000000000000000000;;						ctx.Warnf("Cannot write TLS response body from mitm'd client: %v", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if err := chunked.Close(); err != nil {
0000000000000000000000000000000000000000;;						ctx.Warnf("Cannot write TLS chunked EOF from mitm'd client: %v", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if _, err = io.WriteString(rawClientTls, "\r\n"); err != nil {
0000000000000000000000000000000000000000;;						ctx.Warnf("Cannot write TLS response chunked trailer from mitm'd client: %v", err)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ctx.Logf("Exiting on EOF")
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		case ConnectProxyAuthHijack:
0000000000000000000000000000000000000000;;			proxyClient.Write([]byte("HTTP/1.1 407 Proxy Authentication Required\r\n"))
0000000000000000000000000000000000000000;;			todo.Hijack(r, proxyClient, ctx)
0000000000000000000000000000000000000000;;		case ConnectReject:
0000000000000000000000000000000000000000;;			if ctx.Resp != nil {
0000000000000000000000000000000000000000;;				if err := ctx.Resp.Write(proxyClient); err != nil {
0000000000000000000000000000000000000000;;					ctx.Warnf("Cannot write response that reject http CONNECT: %v", err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			proxyClient.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func httpError(w io.WriteCloser, ctx *ProxyCtx, err error) {
0000000000000000000000000000000000000000;;		if _, err := io.WriteString(w, "HTTP/1.1 502 Bad Gateway\r\n\r\n"); err != nil {
0000000000000000000000000000000000000000;;			ctx.Warnf("Error responding to client: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := w.Close(); err != nil {
0000000000000000000000000000000000000000;;			ctx.Warnf("Error closing client connection: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyOrWarn(ctx *ProxyCtx, dst io.Writer, src io.Reader, wg *sync.WaitGroup) {
0000000000000000000000000000000000000000;;		if _, err := io.Copy(dst, src); err != nil {
0000000000000000000000000000000000000000;;			ctx.Warnf("Error copying to client: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wg.Done()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyAndClose(ctx *ProxyCtx, dst, src *net.TCPConn) {
0000000000000000000000000000000000000000;;		if _, err := io.Copy(dst, src); err != nil {
0000000000000000000000000000000000000000;;			ctx.Warnf("Error copying to client: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dst.CloseWrite()
0000000000000000000000000000000000000000;;		src.CloseRead()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dialerFromEnv(proxy *ProxyHttpServer) func(network, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		https_proxy := os.Getenv("HTTPS_PROXY")
0000000000000000000000000000000000000000;;		if https_proxy == "" {
0000000000000000000000000000000000000000;;			https_proxy = os.Getenv("https_proxy")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if https_proxy == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return proxy.NewConnectDialToProxy(https_proxy)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) NewConnectDialToProxy(https_proxy string) func(network, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;		u, err := url.Parse(https_proxy)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.Scheme == "" || u.Scheme == "http" {
0000000000000000000000000000000000000000;;			if strings.IndexRune(u.Host, ':') == -1 {
0000000000000000000000000000000000000000;;				u.Host += ":80"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return func(network, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;				connectReq := &http.Request{
0000000000000000000000000000000000000000;;					Method: "CONNECT",
0000000000000000000000000000000000000000;;					URL:    &url.URL{Opaque: addr},
0000000000000000000000000000000000000000;;					Host:   addr,
0000000000000000000000000000000000000000;;					Header: make(http.Header),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c, err := proxy.dial(network, u.Host)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				connectReq.Write(c)
0000000000000000000000000000000000000000;;				// Read response.
0000000000000000000000000000000000000000;;				// Okay to use and discard buffered reader here, because
0000000000000000000000000000000000000000;;				// TLS server will not speak until spoken to.
0000000000000000000000000000000000000000;;				br := bufio.NewReader(c)
0000000000000000000000000000000000000000;;				resp, err := http.ReadResponse(br, connectReq)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					c.Close()
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;					resp, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					c.Close()
0000000000000000000000000000000000000000;;					return nil, errors.New("proxy refused connection" + string(resp))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.Scheme == "https" {
0000000000000000000000000000000000000000;;			if strings.IndexRune(u.Host, ':') == -1 {
0000000000000000000000000000000000000000;;				u.Host += ":443"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return func(network, addr string) (net.Conn, error) {
0000000000000000000000000000000000000000;;				c, err := proxy.dial(network, u.Host)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c = tls.Client(c, proxy.Tr.TLSClientConfig)
0000000000000000000000000000000000000000;;				connectReq := &http.Request{
0000000000000000000000000000000000000000;;					Method: "CONNECT",
0000000000000000000000000000000000000000;;					URL:    &url.URL{Opaque: addr},
0000000000000000000000000000000000000000;;					Host:   addr,
0000000000000000000000000000000000000000;;					Header: make(http.Header),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				connectReq.Write(c)
0000000000000000000000000000000000000000;;				// Read response.
0000000000000000000000000000000000000000;;				// Okay to use and discard buffered reader here, because
0000000000000000000000000000000000000000;;				// TLS server will not speak until spoken to.
0000000000000000000000000000000000000000;;				br := bufio.NewReader(c)
0000000000000000000000000000000000000000;;				resp, err := http.ReadResponse(br, connectReq)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					c.Close()
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defer resp.Body.Close()
0000000000000000000000000000000000000000;;				if resp.StatusCode != 200 {
0000000000000000000000000000000000000000;;					body, err := ioutil.ReadAll(io.LimitReader(resp.Body, 500))
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					c.Close()
0000000000000000000000000000000000000000;;					return nil, errors.New("proxy refused connection" + string(body))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return c, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func TLSConfigFromCA(ca *tls.Certificate) func(host string, ctx *ProxyCtx) (*tls.Config, error) {
0000000000000000000000000000000000000000;;		return func(host string, ctx *ProxyCtx) (*tls.Config, error) {
0000000000000000000000000000000000000000;;			config := *defaultTLSConfig
0000000000000000000000000000000000000000;;			ctx.Logf("signing for %s", stripPort(host))
0000000000000000000000000000000000000000;;			cert, err := signHost(*ca, []string{stripPort(host)})
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				ctx.Warnf("Cannot sign host certificate with provided CA: %s", err)
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			config.Certificates = append(config.Certificates, cert)
0000000000000000000000000000000000000000;;			return &config, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
