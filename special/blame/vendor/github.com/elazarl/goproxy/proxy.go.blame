0000000000000000000000000000000000000000;;	package goproxy
d1fe717eabb388da4fbd9a76bce087a5ce94de70;Godeps/_workspace/src/github.com/elazarl/goproxy/proxy.go[Godeps/_workspace/src/github.com/elazarl/goproxy/proxy.go][vendor/github.com/elazarl/goproxy/proxy.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The basic proxy type. Implements http.Handler.
0000000000000000000000000000000000000000;;	type ProxyHttpServer struct {
0000000000000000000000000000000000000000;;		// session variable must be aligned in i386
0000000000000000000000000000000000000000;;		// see http://golang.org/src/pkg/sync/atomic/doc.go#L41
0000000000000000000000000000000000000000;;		sess int64
0000000000000000000000000000000000000000;;		// setting Verbose to true will log information on each request sent to the proxy
0000000000000000000000000000000000000000;;		Verbose         bool
0000000000000000000000000000000000000000;;		Logger          *log.Logger
0000000000000000000000000000000000000000;;		NonproxyHandler http.Handler
0000000000000000000000000000000000000000;;		reqHandlers     []ReqHandler
0000000000000000000000000000000000000000;;		respHandlers    []RespHandler
0000000000000000000000000000000000000000;;		httpsHandlers   []HttpsHandler
0000000000000000000000000000000000000000;;		Tr              *http.Transport
0000000000000000000000000000000000000000;;		// ConnectDial will be used to create TCP connections for CONNECT requests
0000000000000000000000000000000000000000;;		// if nil Tr.Dial will be used
0000000000000000000000000000000000000000;;		ConnectDial func(network string, addr string) (net.Conn, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var hasPort = regexp.MustCompile(`:\d+$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func copyHeaders(dst, src http.Header) {
0000000000000000000000000000000000000000;;		for k, _ := range dst {
0000000000000000000000000000000000000000;;			dst.Del(k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, vs := range src {
0000000000000000000000000000000000000000;;			for _, v := range vs {
0000000000000000000000000000000000000000;;				dst.Add(k, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEof(r *bufio.Reader) bool {
0000000000000000000000000000000000000000;;		_, err := r.Peek(1)
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) filterRequest(r *http.Request, ctx *ProxyCtx) (req *http.Request, resp *http.Response) {
0000000000000000000000000000000000000000;;		req = r
0000000000000000000000000000000000000000;;		for _, h := range proxy.reqHandlers {
0000000000000000000000000000000000000000;;			req, resp = h.Handle(r, ctx)
0000000000000000000000000000000000000000;;			// non-nil resp means the handler decided to skip sending the request
0000000000000000000000000000000000000000;;			// and return canned response instead.
0000000000000000000000000000000000000000;;			if resp != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) filterResponse(respOrig *http.Response, ctx *ProxyCtx) (resp *http.Response) {
0000000000000000000000000000000000000000;;		resp = respOrig
0000000000000000000000000000000000000000;;		for _, h := range proxy.respHandlers {
0000000000000000000000000000000000000000;;			ctx.Resp = resp
0000000000000000000000000000000000000000;;			resp = h.Handle(resp, ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeProxyHeaders(ctx *ProxyCtx, r *http.Request) {
0000000000000000000000000000000000000000;;		r.RequestURI = "" // this must be reset when serving a request with the client
0000000000000000000000000000000000000000;;		ctx.Logf("Sending request %v %v", r.Method, r.URL.String())
0000000000000000000000000000000000000000;;		// If no Accept-Encoding header exists, Transport will add the headers it can accept
0000000000000000000000000000000000000000;;		// and would wrap the response body with the relevant reader.
0000000000000000000000000000000000000000;;		r.Header.Del("Accept-Encoding")
0000000000000000000000000000000000000000;;		// curl can add that, see
0000000000000000000000000000000000000000;;		// https://jdebp.eu./FGA/web-proxy-connection-header.html
0000000000000000000000000000000000000000;;		r.Header.Del("Proxy-Connection")
0000000000000000000000000000000000000000;;		r.Header.Del("Proxy-Authenticate")
0000000000000000000000000000000000000000;;		r.Header.Del("Proxy-Authorization")
0000000000000000000000000000000000000000;;		// Connection, Authenticate and Authorization are single hop Header:
0000000000000000000000000000000000000000;;		// http://www.w3.org/Protocols/rfc2616/rfc2616.txt
0000000000000000000000000000000000000000;;		// 14.10 Connection
0000000000000000000000000000000000000000;;		//   The Connection general-header field allows the sender to specify
0000000000000000000000000000000000000000;;		//   options that are desired for that particular connection and MUST NOT
0000000000000000000000000000000000000000;;		//   be communicated by proxies over further connections.
0000000000000000000000000000000000000000;;		r.Header.Del("Connection")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Standard net/http function. Shouldn't be used directly, http.Serve will use it.
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
0000000000000000000000000000000000000000;;		//r.Header["X-Forwarded-For"] = w.RemoteAddr()
0000000000000000000000000000000000000000;;		if r.Method == "CONNECT" {
0000000000000000000000000000000000000000;;			proxy.handleHttps(w, r)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ctx := &ProxyCtx{Req: r, Session: atomic.AddInt64(&proxy.sess, 1), proxy: proxy}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			ctx.Logf("Got request %v %v %v %v", r.URL.Path, r.Host, r.Method, r.URL.String())
0000000000000000000000000000000000000000;;			if !r.URL.IsAbs() {
0000000000000000000000000000000000000000;;				proxy.NonproxyHandler.ServeHTTP(w, r)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r, resp := proxy.filterRequest(r, ctx)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if resp == nil {
0000000000000000000000000000000000000000;;				removeProxyHeaders(ctx, r)
0000000000000000000000000000000000000000;;				resp, err = ctx.RoundTrip(r)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					ctx.Error = err
0000000000000000000000000000000000000000;;					resp = proxy.filterResponse(nil, ctx)
0000000000000000000000000000000000000000;;					if resp == nil {
0000000000000000000000000000000000000000;;						ctx.Logf("error read response %v %v:", r.URL.Host, err.Error())
0000000000000000000000000000000000000000;;						http.Error(w, err.Error(), 500)
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ctx.Logf("Received response %v", resp.Status)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			origBody := resp.Body
0000000000000000000000000000000000000000;;			resp = proxy.filterResponse(resp, ctx)
0000000000000000000000000000000000000000;;			defer origBody.Close()
0000000000000000000000000000000000000000;;			ctx.Logf("Copying response to client %v [%d]", resp.Status, resp.StatusCode)
0000000000000000000000000000000000000000;;			// http.ResponseWriter will take care of filling the correct response length
0000000000000000000000000000000000000000;;			// Setting it now, might impose wrong value, contradicting the actual new
0000000000000000000000000000000000000000;;			// body the user returned.
0000000000000000000000000000000000000000;;			// We keep the original body to remove the header only if things changed.
0000000000000000000000000000000000000000;;			// This will prevent problems with HEAD requests where there's no body, yet,
0000000000000000000000000000000000000000;;			// the Content-Length header should be set.
0000000000000000000000000000000000000000;;			if origBody != resp.Body {
0000000000000000000000000000000000000000;;				resp.Header.Del("Content-Length")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			copyHeaders(w.Header(), resp.Header)
0000000000000000000000000000000000000000;;			w.WriteHeader(resp.StatusCode)
0000000000000000000000000000000000000000;;			nr, err := io.Copy(w, resp.Body)
0000000000000000000000000000000000000000;;			if err := resp.Body.Close(); err != nil {
0000000000000000000000000000000000000000;;				ctx.Warnf("Can't close response body %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ctx.Logf("Copied %v bytes to client error=%v", nr, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New proxy server, logs to StdErr by default
0000000000000000000000000000000000000000;;	func NewProxyHttpServer() *ProxyHttpServer {
0000000000000000000000000000000000000000;;		proxy := ProxyHttpServer{
0000000000000000000000000000000000000000;;			Logger:        log.New(os.Stderr, "", log.LstdFlags),
0000000000000000000000000000000000000000;;			reqHandlers:   []ReqHandler{},
0000000000000000000000000000000000000000;;			respHandlers:  []RespHandler{},
0000000000000000000000000000000000000000;;			httpsHandlers: []HttpsHandler{},
0000000000000000000000000000000000000000;;			NonproxyHandler: http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
0000000000000000000000000000000000000000;;				http.Error(w, "This is a proxy server. Does not respond to non-proxy requests.", 500)
0000000000000000000000000000000000000000;;			}),
0000000000000000000000000000000000000000;;			Tr: &http.Transport{TLSClientConfig: tlsClientSkipVerify,
0000000000000000000000000000000000000000;;				Proxy: http.ProxyFromEnvironment},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		proxy.ConnectDial = dialerFromEnv(&proxy)
0000000000000000000000000000000000000000;;		return &proxy
0000000000000000000000000000000000000000;;	}
