0000000000000000000000000000000000000000;;	package goproxy
d1fe717eabb388da4fbd9a76bce087a5ce94de70;Godeps/_workspace/src/github.com/elazarl/goproxy/ctx.go[Godeps/_workspace/src/github.com/elazarl/goproxy/ctx.go][vendor/github.com/elazarl/goproxy/ctx.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyCtx is the Proxy context, contains useful information about every request. It is passed to
0000000000000000000000000000000000000000;;	// every user function. Also used as a logger.
0000000000000000000000000000000000000000;;	type ProxyCtx struct {
0000000000000000000000000000000000000000;;		// Will contain the client request from the proxy
0000000000000000000000000000000000000000;;		Req *http.Request
0000000000000000000000000000000000000000;;		// Will contain the remote server's response (if available. nil if the request wasn't send yet)
0000000000000000000000000000000000000000;;		Resp         *http.Response
0000000000000000000000000000000000000000;;		RoundTripper RoundTripper
0000000000000000000000000000000000000000;;		// will contain the recent error that occured while trying to send receive or parse traffic
0000000000000000000000000000000000000000;;		Error error
0000000000000000000000000000000000000000;;		// A handle for the user to keep data in the context, from the call of ReqHandler to the
0000000000000000000000000000000000000000;;		// call of RespHandler
0000000000000000000000000000000000000000;;		UserData interface{}
0000000000000000000000000000000000000000;;		// Will connect a request to a response
0000000000000000000000000000000000000000;;		Session int64
0000000000000000000000000000000000000000;;		proxy   *ProxyHttpServer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoundTripper interface {
0000000000000000000000000000000000000000;;		RoundTrip(req *http.Request, ctx *ProxyCtx) (*http.Response, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RoundTripperFunc func(req *http.Request, ctx *ProxyCtx) (*http.Response, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f RoundTripperFunc) RoundTrip(req *http.Request, ctx *ProxyCtx) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return f(req, ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *ProxyCtx) RoundTrip(req *http.Request) (*http.Response, error) {
0000000000000000000000000000000000000000;;		if ctx.RoundTripper != nil {
0000000000000000000000000000000000000000;;			return ctx.RoundTripper.RoundTrip(req, ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ctx.proxy.Tr.RoundTrip(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (ctx *ProxyCtx) printf(msg string, argv ...interface{}) {
0000000000000000000000000000000000000000;;		ctx.proxy.Logger.Printf("[%03d] "+msg+"\n", append([]interface{}{ctx.Session & 0xFF}, argv...)...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Logf prints a message to the proxy's log. Should be used in a ProxyHttpServer's filter
0000000000000000000000000000000000000000;;	// This message will be printed only if the Verbose field of the ProxyHttpServer is set to true
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	proxy.OnRequest().DoFunc(func(r *http.Request,ctx *goproxy.ProxyCtx) (*http.Request, *http.Response){
0000000000000000000000000000000000000000;;	//		nr := atomic.AddInt32(&counter,1)
0000000000000000000000000000000000000000;;	//		ctx.Printf("So far %d requests",nr)
0000000000000000000000000000000000000000;;	//		return r, nil
0000000000000000000000000000000000000000;;	//	})
0000000000000000000000000000000000000000;;	func (ctx *ProxyCtx) Logf(msg string, argv ...interface{}) {
0000000000000000000000000000000000000000;;		if ctx.proxy.Verbose {
0000000000000000000000000000000000000000;;			ctx.printf("INFO: "+msg, argv...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Warnf prints a message to the proxy's log. Should be used in a ProxyHttpServer's filter
0000000000000000000000000000000000000000;;	// This message will always be printed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	proxy.OnRequest().DoFunc(func(r *http.Request,ctx *goproxy.ProxyCtx) (*http.Request, *http.Response){
0000000000000000000000000000000000000000;;	//		f,err := os.OpenFile(cachedContent)
0000000000000000000000000000000000000000;;	//		if err != nil {
0000000000000000000000000000000000000000;;	//			ctx.Warnf("error open file %v: %v",cachedContent,err)
0000000000000000000000000000000000000000;;	//			return r, nil
0000000000000000000000000000000000000000;;	//		}
0000000000000000000000000000000000000000;;	//		return r, nil
0000000000000000000000000000000000000000;;	//	})
0000000000000000000000000000000000000000;;	func (ctx *ProxyCtx) Warnf(msg string, argv ...interface{}) {
0000000000000000000000000000000000000000;;		ctx.printf("WARN: "+msg, argv...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var charsetFinder = regexp.MustCompile("charset=([^ ;]*)")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Will try to infer the character set of the request from the headers.
0000000000000000000000000000000000000000;;	// Returns the empty string if we don't know which character set it used.
0000000000000000000000000000000000000000;;	// Currently it will look for charset=<charset> in the Content-Type header of the request.
0000000000000000000000000000000000000000;;	func (ctx *ProxyCtx) Charset() string {
0000000000000000000000000000000000000000;;		charsets := charsetFinder.FindStringSubmatch(ctx.Resp.Header.Get("Content-Type"))
0000000000000000000000000000000000000000;;		if charsets == nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return charsets[1]
0000000000000000000000000000000000000000;;	}
