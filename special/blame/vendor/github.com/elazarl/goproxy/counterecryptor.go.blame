0000000000000000000000000000000000000000;;	package goproxy
d1fe717eabb388da4fbd9a76bce087a5ce94de70;Godeps/_workspace/src/github.com/elazarl/goproxy/counterecryptor.go[Godeps/_workspace/src/github.com/elazarl/goproxy/counterecryptor.go][vendor/github.com/elazarl/goproxy/counterecryptor.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/aes"
0000000000000000000000000000000000000000;;		"crypto/cipher"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CounterEncryptorRand struct {
0000000000000000000000000000000000000000;;		cipher  cipher.Block
0000000000000000000000000000000000000000;;		counter []byte
0000000000000000000000000000000000000000;;		rand    []byte
0000000000000000000000000000000000000000;;		ix      int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewCounterEncryptorRandFromKey(key interface{}, seed []byte) (r CounterEncryptorRand, err error) {
0000000000000000000000000000000000000000;;		var keyBytes []byte
0000000000000000000000000000000000000000;;		switch key := key.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			keyBytes = x509.MarshalPKCS1PrivateKey(key)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = errors.New("only RSA keys supported")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := sha256.New()
0000000000000000000000000000000000000000;;		if r.cipher, err = aes.NewCipher(h.Sum(keyBytes)[:aes.BlockSize]); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.counter = make([]byte, r.cipher.BlockSize())
0000000000000000000000000000000000000000;;		if seed != nil {
0000000000000000000000000000000000000000;;			copy(r.counter, h.Sum(seed)[:r.cipher.BlockSize()])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r.rand = make([]byte, r.cipher.BlockSize())
0000000000000000000000000000000000000000;;		r.ix = len(r.rand)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CounterEncryptorRand) Seed(b []byte) {
0000000000000000000000000000000000000000;;		if len(b) != len(c.counter) {
0000000000000000000000000000000000000000;;			panic("SetCounter: wrong counter size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(c.counter, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CounterEncryptorRand) refill() {
0000000000000000000000000000000000000000;;		c.cipher.Encrypt(c.rand, c.counter)
0000000000000000000000000000000000000000;;		for i := 0; i < len(c.counter); i++ {
0000000000000000000000000000000000000000;;			if c.counter[i]++; c.counter[i] != 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.ix = 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CounterEncryptorRand) Read(b []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if c.ix == len(c.rand) {
0000000000000000000000000000000000000000;;			c.refill()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n = len(c.rand) - c.ix; n > len(b) {
0000000000000000000000000000000000000000;;			n = len(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(b, c.rand[c.ix:c.ix+n])
0000000000000000000000000000000000000000;;		c.ix += n
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
