0000000000000000000000000000000000000000;;	package goproxy
d1fe717eabb388da4fbd9a76bce087a5ce94de70;Godeps/_workspace/src/github.com/elazarl/goproxy/dispatcher.go[Godeps/_workspace/src/github.com/elazarl/goproxy/dispatcher.go][vendor/github.com/elazarl/goproxy/dispatcher.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReqCondition.HandleReq will decide whether or not to use the ReqHandler on an HTTP request
0000000000000000000000000000000000000000;;	// before sending it to the remote server
0000000000000000000000000000000000000000;;	type ReqCondition interface {
0000000000000000000000000000000000000000;;		RespCondition
0000000000000000000000000000000000000000;;		HandleReq(req *http.Request, ctx *ProxyCtx) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RespCondition.HandleReq will decide whether or not to use the RespHandler on an HTTP response
0000000000000000000000000000000000000000;;	// before sending it to the proxy client. Note that resp might be nil, in case there was an
0000000000000000000000000000000000000000;;	// error sending the request.
0000000000000000000000000000000000000000;;	type RespCondition interface {
0000000000000000000000000000000000000000;;		HandleResp(resp *http.Response, ctx *ProxyCtx) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReqConditionFunc.HandleReq(req,ctx) <=> ReqConditionFunc(req,ctx)
0000000000000000000000000000000000000000;;	type ReqConditionFunc func(req *http.Request, ctx *ProxyCtx) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RespConditionFunc.HandleResp(resp,ctx) <=> RespConditionFunc(resp,ctx)
0000000000000000000000000000000000000000;;	type RespConditionFunc func(resp *http.Response, ctx *ProxyCtx) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c ReqConditionFunc) HandleReq(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;		return c(req, ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReqConditionFunc cannot test responses. It only satisfies RespCondition interface so that
0000000000000000000000000000000000000000;;	// to be usable as RespCondition.
0000000000000000000000000000000000000000;;	func (c ReqConditionFunc) HandleResp(resp *http.Response, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;		return c(ctx.Req, ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c RespConditionFunc) HandleResp(resp *http.Response, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;		return c(resp, ctx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UrlHasPrefix returns a ReqCondition checking wether the destination URL the proxy client has requested
0000000000000000000000000000000000000000;;	// has the given prefix, with or without the host.
0000000000000000000000000000000000000000;;	// For example UrlHasPrefix("host/x") will match requests of the form 'GET host/x', and will match
0000000000000000000000000000000000000000;;	// requests to url 'http://host/x'
0000000000000000000000000000000000000000;;	func UrlHasPrefix(prefix string) ReqConditionFunc {
0000000000000000000000000000000000000000;;		return func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			return strings.HasPrefix(req.URL.Path, prefix) ||
0000000000000000000000000000000000000000;;				strings.HasPrefix(req.URL.Host+req.URL.Path, prefix) ||
0000000000000000000000000000000000000000;;				strings.HasPrefix(req.URL.Scheme+req.URL.Host+req.URL.Path, prefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UrlIs returns a ReqCondition, testing whether or not the request URL is one of the given strings
0000000000000000000000000000000000000000;;	// with or without the host prefix.
0000000000000000000000000000000000000000;;	// UrlIs("google.com/","foo") will match requests 'GET /' to 'google.com', requests `'GET google.com/' to
0000000000000000000000000000000000000000;;	// any host, and requests of the form 'GET foo'.
0000000000000000000000000000000000000000;;	func UrlIs(urls ...string) ReqConditionFunc {
0000000000000000000000000000000000000000;;		urlSet := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, u := range urls {
0000000000000000000000000000000000000000;;			urlSet[u] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			_, pathOk := urlSet[req.URL.Path]
0000000000000000000000000000000000000000;;			_, hostAndOk := urlSet[req.URL.Host+req.URL.Path]
0000000000000000000000000000000000000000;;			return pathOk || hostAndOk
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReqHostMatches returns a ReqCondition, testing whether the host to which the request was directed to matches
0000000000000000000000000000000000000000;;	// any of the given regular expressions.
0000000000000000000000000000000000000000;;	func ReqHostMatches(regexps ...*regexp.Regexp) ReqConditionFunc {
0000000000000000000000000000000000000000;;		return func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			for _, re := range regexps {
0000000000000000000000000000000000000000;;				if re.MatchString(req.Host) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReqHostIs returns a ReqCondition, testing whether the host to which the request is directed to equal
0000000000000000000000000000000000000000;;	// to one of the given strings
0000000000000000000000000000000000000000;;	func ReqHostIs(hosts ...string) ReqConditionFunc {
0000000000000000000000000000000000000000;;		hostSet := make(map[string]bool)
0000000000000000000000000000000000000000;;		for _, h := range hosts {
0000000000000000000000000000000000000000;;			hostSet[h] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			_, ok := hostSet[req.URL.Host]
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var localHostIpv4 = regexp.MustCompile(`127\.0\.0\.\d+`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLocalHost checks whether the destination host is explicitly local host
0000000000000000000000000000000000000000;;	// (buggy, there can be IPv6 addresses it doesn't catch)
0000000000000000000000000000000000000000;;	var IsLocalHost ReqConditionFunc = func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;		return req.URL.Host == "::1" ||
0000000000000000000000000000000000000000;;			req.URL.Host == "0:0:0:0:0:0:0:1" ||
0000000000000000000000000000000000000000;;			localHostIpv4.MatchString(req.URL.Host) ||
0000000000000000000000000000000000000000;;			req.URL.Host == "localhost"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UrlMatches returns a ReqCondition testing whether the destination URL
0000000000000000000000000000000000000000;;	// of the request matches the given regexp, with or without prefix
0000000000000000000000000000000000000000;;	func UrlMatches(re *regexp.Regexp) ReqConditionFunc {
0000000000000000000000000000000000000000;;		return func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			return re.MatchString(req.URL.Path) ||
0000000000000000000000000000000000000000;;				re.MatchString(req.URL.Host+req.URL.Path)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DstHostIs returns a ReqCondition testing wether the host in the request url is the given string
0000000000000000000000000000000000000000;;	func DstHostIs(host string) ReqConditionFunc {
0000000000000000000000000000000000000000;;		return func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			return req.URL.Host == host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SrcIpIs returns a ReqCondition testing whether the source IP of the request is one of the given strings
0000000000000000000000000000000000000000;;	func SrcIpIs(ips ...string) ReqCondition {
0000000000000000000000000000000000000000;;		return ReqConditionFunc(func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			for _, ip := range ips {
0000000000000000000000000000000000000000;;				if strings.HasPrefix(req.RemoteAddr, ip+":") {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Not returns a ReqCondition negating the given ReqCondition
0000000000000000000000000000000000000000;;	func Not(r ReqCondition) ReqConditionFunc {
0000000000000000000000000000000000000000;;		return func(req *http.Request, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			return !r.HandleReq(req, ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContentTypeIs returns a RespCondition testing whether the HTTP response has Content-Type header equal
0000000000000000000000000000000000000000;;	// to one of the given strings.
0000000000000000000000000000000000000000;;	func ContentTypeIs(typ string, types ...string) RespCondition {
0000000000000000000000000000000000000000;;		types = append(types, typ)
0000000000000000000000000000000000000000;;		return RespConditionFunc(func(resp *http.Response, ctx *ProxyCtx) bool {
0000000000000000000000000000000000000000;;			if resp == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			contentType := resp.Header.Get("Content-Type")
0000000000000000000000000000000000000000;;			for _, typ := range types {
0000000000000000000000000000000000000000;;				if contentType == typ || strings.HasPrefix(contentType, typ+";") {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyHttpServer.OnRequest Will return a temporary ReqProxyConds struct, aggregating the given condtions.
0000000000000000000000000000000000000000;;	// You will use the ReqProxyConds struct to register a ReqHandler, that would filter
0000000000000000000000000000000000000000;;	// the request, only if all the given ReqCondition matched.
0000000000000000000000000000000000000000;;	// Typical usage:
0000000000000000000000000000000000000000;;	//	proxy.OnRequest(UrlIs("example.com/foo"),UrlMatches(regexp.MustParse(`.*\.exampl.\com\./.*`)).Do(...)
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) OnRequest(conds ...ReqCondition) *ReqProxyConds {
0000000000000000000000000000000000000000;;		return &ReqProxyConds{proxy, conds}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReqProxyConds aggregate ReqConditions for a ProxyHttpServer. Upon calling Do, it will register a ReqHandler that would
0000000000000000000000000000000000000000;;	// handle the request if all conditions on the HTTP request are met.
0000000000000000000000000000000000000000;;	type ReqProxyConds struct {
0000000000000000000000000000000000000000;;		proxy    *ProxyHttpServer
0000000000000000000000000000000000000000;;		reqConds []ReqCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DoFunc is equivalent to proxy.OnRequest().Do(FuncReqHandler(f))
0000000000000000000000000000000000000000;;	func (pcond *ReqProxyConds) DoFunc(f func(req *http.Request, ctx *ProxyCtx) (*http.Request, *http.Response)) {
0000000000000000000000000000000000000000;;		pcond.Do(FuncReqHandler(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReqProxyConds.Do will register the ReqHandler on the proxy,
0000000000000000000000000000000000000000;;	// the ReqHandler will handle the HTTP request if all the conditions
0000000000000000000000000000000000000000;;	// aggregated in the ReqProxyConds are met. Typical usage:
0000000000000000000000000000000000000000;;	//	proxy.OnRequest().Do(handler) // will call handler.Handle(req,ctx) on every request to the proxy
0000000000000000000000000000000000000000;;	//	proxy.OnRequest(cond1,cond2).Do(handler)
0000000000000000000000000000000000000000;;	//	// given request to the proxy, will test if cond1.HandleReq(req,ctx) && cond2.HandleReq(req,ctx) are true
0000000000000000000000000000000000000000;;	//	// if they are, will call handler.Handle(req,ctx)
0000000000000000000000000000000000000000;;	func (pcond *ReqProxyConds) Do(h ReqHandler) {
0000000000000000000000000000000000000000;;		pcond.proxy.reqHandlers = append(pcond.proxy.reqHandlers,
0000000000000000000000000000000000000000;;			FuncReqHandler(func(r *http.Request, ctx *ProxyCtx) (*http.Request, *http.Response) {
0000000000000000000000000000000000000000;;				for _, cond := range pcond.reqConds {
0000000000000000000000000000000000000000;;					if !cond.HandleReq(r, ctx) {
0000000000000000000000000000000000000000;;						return r, nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return h.Handle(r, ctx)
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleConnect is used when proxy receives an HTTP CONNECT request,
0000000000000000000000000000000000000000;;	// it'll then use the HttpsHandler to determine what should it
0000000000000000000000000000000000000000;;	// do with this request. The handler returns a ConnectAction struct, the Action field in the ConnectAction
0000000000000000000000000000000000000000;;	// struct returned will determine what to do with this request. ConnectAccept will simply accept the request
0000000000000000000000000000000000000000;;	// forwarding all bytes from the client to the remote host, ConnectReject will close the connection with the
0000000000000000000000000000000000000000;;	// client, and ConnectMitm, will assume the underlying connection is an HTTPS connection, and will use Man
0000000000000000000000000000000000000000;;	// in the Middle attack to eavesdrop the connection. All regular handler will be active on this eavesdropped
0000000000000000000000000000000000000000;;	// connection.
0000000000000000000000000000000000000000;;	// The ConnectAction struct contains possible tlsConfig that will be used for eavesdropping. If nil, the proxy
0000000000000000000000000000000000000000;;	// will use the default tls configuration.
0000000000000000000000000000000000000000;;	//	proxy.OnRequest().HandleConnect(goproxy.AlwaysReject) // rejects all CONNECT requests
0000000000000000000000000000000000000000;;	func (pcond *ReqProxyConds) HandleConnect(h HttpsHandler) {
0000000000000000000000000000000000000000;;		pcond.proxy.httpsHandlers = append(pcond.proxy.httpsHandlers,
0000000000000000000000000000000000000000;;			FuncHttpsHandler(func(host string, ctx *ProxyCtx) (*ConnectAction, string) {
0000000000000000000000000000000000000000;;				for _, cond := range pcond.reqConds {
0000000000000000000000000000000000000000;;					if !cond.HandleReq(ctx.Req, ctx) {
0000000000000000000000000000000000000000;;						return nil, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return h.HandleConnect(host, ctx)
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleConnectFunc is equivalent to HandleConnect,
0000000000000000000000000000000000000000;;	// for example, accepting CONNECT request if they contain a password in header
0000000000000000000000000000000000000000;;	//	io.WriteString(h,password)
0000000000000000000000000000000000000000;;	//	passHash := h.Sum(nil)
0000000000000000000000000000000000000000;;	//	proxy.OnRequest().HandleConnectFunc(func(host string, ctx *ProxyCtx) (*ConnectAction, string) {
0000000000000000000000000000000000000000;;	//		c := sha1.New()
0000000000000000000000000000000000000000;;	//		io.WriteString(c,ctx.Req.Header.Get("X-GoProxy-Auth"))
0000000000000000000000000000000000000000;;	//		if c.Sum(nil) == passHash {
0000000000000000000000000000000000000000;;	//			return OkConnect, host
0000000000000000000000000000000000000000;;	//		}
0000000000000000000000000000000000000000;;	//		return RejectConnect, host
0000000000000000000000000000000000000000;;	//	})
0000000000000000000000000000000000000000;;	func (pcond *ReqProxyConds) HandleConnectFunc(f func(host string, ctx *ProxyCtx) (*ConnectAction, string)) {
0000000000000000000000000000000000000000;;		pcond.HandleConnect(FuncHttpsHandler(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (pcond *ReqProxyConds) HijackConnect(f func(req *http.Request, client net.Conn, ctx *ProxyCtx)) {
0000000000000000000000000000000000000000;;		pcond.proxy.httpsHandlers = append(pcond.proxy.httpsHandlers,
0000000000000000000000000000000000000000;;			FuncHttpsHandler(func(host string, ctx *ProxyCtx) (*ConnectAction, string) {
0000000000000000000000000000000000000000;;				for _, cond := range pcond.reqConds {
0000000000000000000000000000000000000000;;					if !cond.HandleReq(ctx.Req, ctx) {
0000000000000000000000000000000000000000;;						return nil, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return &ConnectAction{Action: ConnectHijack, Hijack: f}, host
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyConds is used to aggregate RespConditions for a ProxyHttpServer.
0000000000000000000000000000000000000000;;	// Upon calling ProxyConds.Do, it will register a RespHandler that would
0000000000000000000000000000000000000000;;	// handle the HTTP response from remote server if all conditions on the HTTP response are met.
0000000000000000000000000000000000000000;;	type ProxyConds struct {
0000000000000000000000000000000000000000;;		proxy    *ProxyHttpServer
0000000000000000000000000000000000000000;;		reqConds []ReqCondition
0000000000000000000000000000000000000000;;		respCond []RespCondition
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyConds.DoFunc is equivalent to proxy.OnResponse().Do(FuncRespHandler(f))
0000000000000000000000000000000000000000;;	func (pcond *ProxyConds) DoFunc(f func(resp *http.Response, ctx *ProxyCtx) *http.Response) {
0000000000000000000000000000000000000000;;		pcond.Do(FuncRespHandler(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProxyConds.Do will register the RespHandler on the proxy, h.Handle(resp,ctx) will be called on every
0000000000000000000000000000000000000000;;	// request that matches the conditions aggregated in pcond.
0000000000000000000000000000000000000000;;	func (pcond *ProxyConds) Do(h RespHandler) {
0000000000000000000000000000000000000000;;		pcond.proxy.respHandlers = append(pcond.proxy.respHandlers,
0000000000000000000000000000000000000000;;			FuncRespHandler(func(resp *http.Response, ctx *ProxyCtx) *http.Response {
0000000000000000000000000000000000000000;;				for _, cond := range pcond.reqConds {
0000000000000000000000000000000000000000;;					if !cond.HandleReq(ctx.Req, ctx) {
0000000000000000000000000000000000000000;;						return resp
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, cond := range pcond.respCond {
0000000000000000000000000000000000000000;;					if !cond.HandleResp(resp, ctx) {
0000000000000000000000000000000000000000;;						return resp
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return h.Handle(resp, ctx)
0000000000000000000000000000000000000000;;			}))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OnResponse is used when adding a response-filter to the HTTP proxy, usual pattern is
0000000000000000000000000000000000000000;;	//	proxy.OnResponse(cond1,cond2).Do(handler) // handler.Handle(resp,ctx) will be used
0000000000000000000000000000000000000000;;	//				// if cond1.HandleResp(resp) && cond2.HandleResp(resp)
0000000000000000000000000000000000000000;;	func (proxy *ProxyHttpServer) OnResponse(conds ...RespCondition) *ProxyConds {
0000000000000000000000000000000000000000;;		return &ProxyConds{proxy, make([]ReqCondition, 0), conds}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AlwaysMitm is a HttpsHandler that always eavesdrop https connections, for example to
0000000000000000000000000000000000000000;;	// eavesdrop all https connections to www.google.com, we can use
0000000000000000000000000000000000000000;;	//	proxy.OnRequest(goproxy.ReqHostIs("www.google.com")).HandleConnect(goproxy.AlwaysMitm)
0000000000000000000000000000000000000000;;	var AlwaysMitm FuncHttpsHandler = func(host string, ctx *ProxyCtx) (*ConnectAction, string) {
0000000000000000000000000000000000000000;;		return MitmConnect, host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AlwaysReject is a HttpsHandler that drops any CONNECT request, for example, this code will disallow
0000000000000000000000000000000000000000;;	// connections to hosts on any other port than 443
0000000000000000000000000000000000000000;;	//	proxy.OnRequest(goproxy.Not(goproxy.ReqHostMatches(regexp.MustCompile(":443$"))).
0000000000000000000000000000000000000000;;	//		HandleConnect(goproxy.AlwaysReject)
0000000000000000000000000000000000000000;;	var AlwaysReject FuncHttpsHandler = func(host string, ctx *ProxyCtx) (*ConnectAction, string) {
0000000000000000000000000000000000000000;;		return RejectConnect, host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleBytes will return a RespHandler that read the entire body of the request
0000000000000000000000000000000000000000;;	// to a byte array in memory, would run the user supplied f function on the byte arra,
0000000000000000000000000000000000000000;;	// and will replace the body of the original response with the resulting byte array.
0000000000000000000000000000000000000000;;	func HandleBytes(f func(b []byte, ctx *ProxyCtx) []byte) RespHandler {
0000000000000000000000000000000000000000;;		return FuncRespHandler(func(resp *http.Response, ctx *ProxyCtx) *http.Response {
0000000000000000000000000000000000000000;;			b, err := ioutil.ReadAll(resp.Body)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				ctx.Warnf("Cannot read response %s", err)
0000000000000000000000000000000000000000;;				return resp
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			resp.Body = ioutil.NopCloser(bytes.NewBuffer(f(b, ctx)))
0000000000000000000000000000000000000000;;			return resp
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
