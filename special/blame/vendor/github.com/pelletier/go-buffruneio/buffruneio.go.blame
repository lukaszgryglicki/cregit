0000000000000000000000000000000000000000;;	// Package buffruneio is a wrapper around bufio to provide buffered runes access with unlimited unreads.
0000000000000000000000000000000000000000;;	package buffruneio
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rune to indicate end of file.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EOF = -(iota + 1)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrNoRuneToUnread is returned by UnreadRune() when the read index is already at the beginning of the buffer.
0000000000000000000000000000000000000000;;	var ErrNoRuneToUnread = errors.New("no rune to unwind")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reader implements runes buffering for an io.Reader object.
0000000000000000000000000000000000000000;;	type Reader struct {
0000000000000000000000000000000000000000;;		buffer  *list.List
0000000000000000000000000000000000000000;;		current *list.Element
0000000000000000000000000000000000000000;;		input   *bufio.Reader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewReader returns a new Reader.
0000000000000000000000000000000000000000;;	func NewReader(rd io.Reader) *Reader {
0000000000000000000000000000000000000000;;		return &Reader{
0000000000000000000000000000000000000000;;			buffer: list.New(),
0000000000000000000000000000000000000000;;			input:  bufio.NewReader(rd),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rd *Reader) feedBuffer() error {
0000000000000000000000000000000000000000;;		r, _, err := rd.input.ReadRune()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			if err != io.EOF {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r = EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rd.buffer.PushBack(r)
0000000000000000000000000000000000000000;;		if rd.current == nil {
0000000000000000000000000000000000000000;;			rd.current = rd.buffer.Back()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadRune reads the next rune from buffer, or from the underlying reader if needed.
0000000000000000000000000000000000000000;;	func (rd *Reader) ReadRune() (rune, error) {
0000000000000000000000000000000000000000;;		if rd.current == rd.buffer.Back() || rd.current == nil {
0000000000000000000000000000000000000000;;			err := rd.feedBuffer()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return EOF, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r := rd.current.Value
0000000000000000000000000000000000000000;;		rd.current = rd.current.Next()
0000000000000000000000000000000000000000;;		return r.(rune), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnreadRune pushes back the previously read rune in the buffer, extending it if needed.
0000000000000000000000000000000000000000;;	func (rd *Reader) UnreadRune() error {
0000000000000000000000000000000000000000;;		if rd.current == rd.buffer.Front() {
0000000000000000000000000000000000000000;;			return ErrNoRuneToUnread
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rd.current == nil {
0000000000000000000000000000000000000000;;			rd.current = rd.buffer.Back()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rd.current = rd.current.Prev()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Forget removes runes stored before the current stream position index.
0000000000000000000000000000000000000000;;	func (rd *Reader) Forget() {
0000000000000000000000000000000000000000;;		if rd.current == nil {
0000000000000000000000000000000000000000;;			rd.current = rd.buffer.Back()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for ; rd.current != rd.buffer.Front(); rd.buffer.Remove(rd.current.Prev()) {
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Peek returns at most the next n runes, reading from the uderlying source if
0000000000000000000000000000000000000000;;	// needed. Does not move the current index. It includes EOF if reached.
0000000000000000000000000000000000000000;;	func (rd *Reader) Peek(n int) []rune {
0000000000000000000000000000000000000000;;		res := make([]rune, 0, n)
0000000000000000000000000000000000000000;;		cursor := rd.current
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			if cursor == nil {
0000000000000000000000000000000000000000;;				err := rd.feedBuffer()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return res
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cursor = rd.buffer.Back()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if cursor != nil {
0000000000000000000000000000000000000000;;				r := cursor.Value.(rune)
0000000000000000000000000000000000000000;;				res = append(res, r)
0000000000000000000000000000000000000000;;				if r == EOF {
0000000000000000000000000000000000000000;;					return res
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cursor = cursor.Next()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
