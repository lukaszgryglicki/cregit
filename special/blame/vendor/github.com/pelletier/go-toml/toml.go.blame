0000000000000000000000000000000000000000;;	package toml
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tomlValue struct {
0000000000000000000000000000000000000000;;		value    interface{}
0000000000000000000000000000000000000000;;		position Position
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TomlTree is the result of the parsing of a TOML file.
0000000000000000000000000000000000000000;;	type TomlTree struct {
0000000000000000000000000000000000000000;;		values   map[string]interface{}
0000000000000000000000000000000000000000;;		position Position
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTomlTree() *TomlTree {
0000000000000000000000000000000000000000;;		return &TomlTree{
0000000000000000000000000000000000000000;;			values:   make(map[string]interface{}),
0000000000000000000000000000000000000000;;			position: Position{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TreeFromMap initializes a new TomlTree object using the given map.
0000000000000000000000000000000000000000;;	func TreeFromMap(m map[string]interface{}) *TomlTree {
0000000000000000000000000000000000000000;;		return &TomlTree{
0000000000000000000000000000000000000000;;			values: m,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Has returns a boolean indicating if the given key exists.
0000000000000000000000000000000000000000;;	func (t *TomlTree) Has(key string) bool {
0000000000000000000000000000000000000000;;		if key == "" {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.HasPath(strings.Split(key, "."))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HasPath returns true if the given path of keys exists, false otherwise.
0000000000000000000000000000000000000000;;	func (t *TomlTree) HasPath(keys []string) bool {
0000000000000000000000000000000000000000;;		return t.GetPath(keys) != nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns the keys of the toplevel tree.
0000000000000000000000000000000000000000;;	// Warning: this is a costly operation.
0000000000000000000000000000000000000000;;	func (t *TomlTree) Keys() []string {
0000000000000000000000000000000000000000;;		var keys []string
0000000000000000000000000000000000000000;;		for k := range t.values {
0000000000000000000000000000000000000000;;			keys = append(keys, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the value at key in the TomlTree.
0000000000000000000000000000000000000000;;	// Key is a dot-separated path (e.g. a.b.c).
0000000000000000000000000000000000000000;;	// Returns nil if the path does not exist in the tree.
0000000000000000000000000000000000000000;;	// If keys is of length zero, the current tree is returned.
0000000000000000000000000000000000000000;;	func (t *TomlTree) Get(key string) interface{} {
0000000000000000000000000000000000000000;;		if key == "" {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		comps, err := parseKey(key)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.GetPath(comps)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPath returns the element in the tree indicated by 'keys'.
0000000000000000000000000000000000000000;;	// If keys is of length zero, the current tree is returned.
0000000000000000000000000000000000000000;;	func (t *TomlTree) GetPath(keys []string) interface{} {
0000000000000000000000000000000000000000;;		if len(keys) == 0 {
0000000000000000000000000000000000000000;;			return t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		subtree := t
0000000000000000000000000000000000000000;;		for _, intermediateKey := range keys[:len(keys)-1] {
0000000000000000000000000000000000000000;;			value, exists := subtree.values[intermediateKey]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch node := value.(type) {
0000000000000000000000000000000000000000;;			case *TomlTree:
0000000000000000000000000000000000000000;;				subtree = node
0000000000000000000000000000000000000000;;			case []*TomlTree:
0000000000000000000000000000000000000000;;				// go to most recent element
0000000000000000000000000000000000000000;;				if len(node) == 0 {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subtree = node[len(node)-1]
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil // cannot navigate through other node types
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// branch based on final node type
0000000000000000000000000000000000000000;;		switch node := subtree.values[keys[len(keys)-1]].(type) {
0000000000000000000000000000000000000000;;		case *tomlValue:
0000000000000000000000000000000000000000;;			return node.value
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPosition returns the position of the given key.
0000000000000000000000000000000000000000;;	func (t *TomlTree) GetPosition(key string) Position {
0000000000000000000000000000000000000000;;		if key == "" {
0000000000000000000000000000000000000000;;			return t.position
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return t.GetPositionPath(strings.Split(key, "."))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPositionPath returns the element in the tree indicated by 'keys'.
0000000000000000000000000000000000000000;;	// If keys is of length zero, the current tree is returned.
0000000000000000000000000000000000000000;;	func (t *TomlTree) GetPositionPath(keys []string) Position {
0000000000000000000000000000000000000000;;		if len(keys) == 0 {
0000000000000000000000000000000000000000;;			return t.position
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		subtree := t
0000000000000000000000000000000000000000;;		for _, intermediateKey := range keys[:len(keys)-1] {
0000000000000000000000000000000000000000;;			value, exists := subtree.values[intermediateKey]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				return Position{0, 0}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch node := value.(type) {
0000000000000000000000000000000000000000;;			case *TomlTree:
0000000000000000000000000000000000000000;;				subtree = node
0000000000000000000000000000000000000000;;			case []*TomlTree:
0000000000000000000000000000000000000000;;				// go to most recent element
0000000000000000000000000000000000000000;;				if len(node) == 0 {
0000000000000000000000000000000000000000;;					return Position{0, 0}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subtree = node[len(node)-1]
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return Position{0, 0}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// branch based on final node type
0000000000000000000000000000000000000000;;		switch node := subtree.values[keys[len(keys)-1]].(type) {
0000000000000000000000000000000000000000;;		case *tomlValue:
0000000000000000000000000000000000000000;;			return node.position
0000000000000000000000000000000000000000;;		case *TomlTree:
0000000000000000000000000000000000000000;;			return node.position
0000000000000000000000000000000000000000;;		case []*TomlTree:
0000000000000000000000000000000000000000;;			// go to most recent element
0000000000000000000000000000000000000000;;			if len(node) == 0 {
0000000000000000000000000000000000000000;;				return Position{0, 0}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return node[len(node)-1].position
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return Position{0, 0}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDefault works like Get but with a default value
0000000000000000000000000000000000000000;;	func (t *TomlTree) GetDefault(key string, def interface{}) interface{} {
0000000000000000000000000000000000000000;;		val := t.Get(key)
0000000000000000000000000000000000000000;;		if val == nil {
0000000000000000000000000000000000000000;;			return def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return val
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set an element in the tree.
0000000000000000000000000000000000000000;;	// Key is a dot-separated path (e.g. a.b.c).
0000000000000000000000000000000000000000;;	// Creates all necessary intermediates trees, if needed.
0000000000000000000000000000000000000000;;	func (t *TomlTree) Set(key string, value interface{}) {
0000000000000000000000000000000000000000;;		t.SetPath(strings.Split(key, "."), value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPath sets an element in the tree.
0000000000000000000000000000000000000000;;	// Keys is an array of path elements (e.g. {"a","b","c"}).
0000000000000000000000000000000000000000;;	// Creates all necessary intermediates trees, if needed.
0000000000000000000000000000000000000000;;	func (t *TomlTree) SetPath(keys []string, value interface{}) {
0000000000000000000000000000000000000000;;		subtree := t
0000000000000000000000000000000000000000;;		for _, intermediateKey := range keys[:len(keys)-1] {
0000000000000000000000000000000000000000;;			nextTree, exists := subtree.values[intermediateKey]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				nextTree = newTomlTree()
0000000000000000000000000000000000000000;;				subtree.values[intermediateKey] = nextTree // add new element here
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch node := nextTree.(type) {
0000000000000000000000000000000000000000;;			case *TomlTree:
0000000000000000000000000000000000000000;;				subtree = node
0000000000000000000000000000000000000000;;			case []*TomlTree:
0000000000000000000000000000000000000000;;				// go to most recent element
0000000000000000000000000000000000000000;;				if len(node) == 0 {
0000000000000000000000000000000000000000;;					// create element if it does not exist
0000000000000000000000000000000000000000;;					subtree.values[intermediateKey] = append(node, newTomlTree())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				subtree = node[len(node)-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var toInsert interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch value.(type) {
0000000000000000000000000000000000000000;;		case *TomlTree:
0000000000000000000000000000000000000000;;			toInsert = value
0000000000000000000000000000000000000000;;		case []*TomlTree:
0000000000000000000000000000000000000000;;			toInsert = value
0000000000000000000000000000000000000000;;		case *tomlValue:
0000000000000000000000000000000000000000;;			toInsert = value
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			toInsert = &tomlValue{value: value}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		subtree.values[keys[len(keys)-1]] = toInsert
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createSubTree takes a tree and a key and create the necessary intermediate
0000000000000000000000000000000000000000;;	// subtrees to create a subtree at that point. In-place.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// e.g. passing a.b.c will create (assuming tree is empty) tree[a], tree[a][b]
0000000000000000000000000000000000000000;;	// and tree[a][b][c]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Returns nil on success, error object on failure
0000000000000000000000000000000000000000;;	func (t *TomlTree) createSubTree(keys []string, pos Position) error {
0000000000000000000000000000000000000000;;		subtree := t
0000000000000000000000000000000000000000;;		for _, intermediateKey := range keys {
0000000000000000000000000000000000000000;;			if intermediateKey == "" {
0000000000000000000000000000000000000000;;				return fmt.Errorf("empty intermediate table")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nextTree, exists := subtree.values[intermediateKey]
0000000000000000000000000000000000000000;;			if !exists {
0000000000000000000000000000000000000000;;				tree := newTomlTree()
0000000000000000000000000000000000000000;;				tree.position = pos
0000000000000000000000000000000000000000;;				subtree.values[intermediateKey] = tree
0000000000000000000000000000000000000000;;				nextTree = tree
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch node := nextTree.(type) {
0000000000000000000000000000000000000000;;			case []*TomlTree:
0000000000000000000000000000000000000000;;				subtree = node[len(node)-1]
0000000000000000000000000000000000000000;;			case *TomlTree:
0000000000000000000000000000000000000000;;				subtree = node
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return fmt.Errorf("unknown type for path %s (%s): %T (%#v)",
0000000000000000000000000000000000000000;;					strings.Join(keys, "."), intermediateKey, nextTree, nextTree)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Query compiles and executes a query on a tree and returns the query result.
0000000000000000000000000000000000000000;;	func (t *TomlTree) Query(query string) (*QueryResult, error) {
0000000000000000000000000000000000000000;;		q, err := CompileQuery(query)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.Execute(t), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadReader creates a TomlTree from any io.Reader.
0000000000000000000000000000000000000000;;	func LoadReader(reader io.Reader) (tree *TomlTree, err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if r := recover(); r != nil {
0000000000000000000000000000000000000000;;				if _, ok := r.(runtime.Error); ok {
0000000000000000000000000000000000000000;;					panic(r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = errors.New(r.(string))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		tree = parseToml(lexToml(reader))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Load creates a TomlTree from a string.
0000000000000000000000000000000000000000;;	func Load(content string) (tree *TomlTree, err error) {
0000000000000000000000000000000000000000;;		return LoadReader(strings.NewReader(content))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LoadFile creates a TomlTree from a file.
0000000000000000000000000000000000000000;;	func LoadFile(path string) (tree *TomlTree, err error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		return LoadReader(file)
0000000000000000000000000000000000000000;;	}
