0000000000000000000000000000000000000000;;	// TOML JSONPath lexer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Written using the principles developed by Rob Pike in
0000000000000000000000000000000000000000;;	// http://www.youtube.com/watch?v=HxaD_trXwRE
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package toml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lexer state function
0000000000000000000000000000000000000000;;	type queryLexStateFn func() queryLexStateFn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lexer definition
0000000000000000000000000000000000000000;;	type queryLexer struct {
0000000000000000000000000000000000000000;;		input      string
0000000000000000000000000000000000000000;;		start      int
0000000000000000000000000000000000000000;;		pos        int
0000000000000000000000000000000000000000;;		width      int
0000000000000000000000000000000000000000;;		tokens     chan token
0000000000000000000000000000000000000000;;		depth      int
0000000000000000000000000000000000000000;;		line       int
0000000000000000000000000000000000000000;;		col        int
0000000000000000000000000000000000000000;;		stringTerm string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) run() {
0000000000000000000000000000000000000000;;		for state := l.lexVoid; state != nil; {
0000000000000000000000000000000000000000;;			state = state()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(l.tokens)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) nextStart() {
0000000000000000000000000000000000000000;;		// iterate by runes (utf8 characters)
0000000000000000000000000000000000000000;;		// search for newlines and advance line/col counts
0000000000000000000000000000000000000000;;		for i := l.start; i < l.pos; {
0000000000000000000000000000000000000000;;			r, width := utf8.DecodeRuneInString(l.input[i:])
0000000000000000000000000000000000000000;;			if r == '\n' {
0000000000000000000000000000000000000000;;				l.line++
0000000000000000000000000000000000000000;;				l.col = 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				l.col++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += width
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// advance start position to next token
0000000000000000000000000000000000000000;;		l.start = l.pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) emit(t tokenType) {
0000000000000000000000000000000000000000;;		l.tokens <- token{
0000000000000000000000000000000000000000;;			Position: Position{l.line, l.col},
0000000000000000000000000000000000000000;;			typ:      t,
0000000000000000000000000000000000000000;;			val:      l.input[l.start:l.pos],
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.nextStart()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) emitWithValue(t tokenType, value string) {
0000000000000000000000000000000000000000;;		l.tokens <- token{
0000000000000000000000000000000000000000;;			Position: Position{l.line, l.col},
0000000000000000000000000000000000000000;;			typ:      t,
0000000000000000000000000000000000000000;;			val:      value,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.nextStart()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) next() rune {
0000000000000000000000000000000000000000;;		if l.pos >= len(l.input) {
0000000000000000000000000000000000000000;;			l.width = 0
0000000000000000000000000000000000000000;;			return eof
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var r rune
0000000000000000000000000000000000000000;;		r, l.width = utf8.DecodeRuneInString(l.input[l.pos:])
0000000000000000000000000000000000000000;;		l.pos += l.width
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) ignore() {
0000000000000000000000000000000000000000;;		l.nextStart()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) backup() {
0000000000000000000000000000000000000000;;		l.pos -= l.width
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) errorf(format string, args ...interface{}) queryLexStateFn {
0000000000000000000000000000000000000000;;		l.tokens <- token{
0000000000000000000000000000000000000000;;			Position: Position{l.line, l.col},
0000000000000000000000000000000000000000;;			typ:      tokenError,
0000000000000000000000000000000000000000;;			val:      fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) peek() rune {
0000000000000000000000000000000000000000;;		r := l.next()
0000000000000000000000000000000000000000;;		l.backup()
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) accept(valid string) bool {
0000000000000000000000000000000000000000;;		if strings.ContainsRune(valid, l.next()) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.backup()
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) follow(next string) bool {
0000000000000000000000000000000000000000;;		return strings.HasPrefix(l.input[l.pos:], next)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) lexVoid() queryLexStateFn {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			next := l.peek()
0000000000000000000000000000000000000000;;			switch next {
0000000000000000000000000000000000000000;;			case '$':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenDollar)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '.':
0000000000000000000000000000000000000000;;				if l.follow("..") {
0000000000000000000000000000000000000000;;					l.pos += 2
0000000000000000000000000000000000000000;;					l.emit(tokenDotDot)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					l.pos++
0000000000000000000000000000000000000000;;					l.emit(tokenDot)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenLeftBracket)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenRightBracket)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case ',':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenComma)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '*':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenStar)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '(':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenLeftParen)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case ')':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenRightParen)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '?':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenQuestion)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case ':':
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.emit(tokenColon)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '\'':
0000000000000000000000000000000000000000;;				l.ignore()
0000000000000000000000000000000000000000;;				l.stringTerm = string(next)
0000000000000000000000000000000000000000;;				return l.lexString
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				l.ignore()
0000000000000000000000000000000000000000;;				l.stringTerm = string(next)
0000000000000000000000000000000000000000;;				return l.lexString
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isSpace(next) {
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				l.ignore()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isAlphanumeric(next) {
0000000000000000000000000000000000000000;;				return l.lexKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if next == '+' || next == '-' || isDigit(next) {
0000000000000000000000000000000000000000;;				return l.lexNumber
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.next() == eof {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return l.errorf("unexpected char: '%v'", next)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.emit(tokenEOF)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) lexKey() queryLexStateFn {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			next := l.peek()
0000000000000000000000000000000000000000;;			if !isAlphanumeric(next) {
0000000000000000000000000000000000000000;;				l.emit(tokenKey)
0000000000000000000000000000000000000000;;				return l.lexVoid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.next() == eof {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.emit(tokenEOF)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) lexString() queryLexStateFn {
0000000000000000000000000000000000000000;;		l.pos++
0000000000000000000000000000000000000000;;		l.ignore()
0000000000000000000000000000000000000000;;		growingString := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if l.follow(l.stringTerm) {
0000000000000000000000000000000000000000;;				l.emitWithValue(tokenString, growingString)
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				l.ignore()
0000000000000000000000000000000000000000;;				return l.lexVoid
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.follow("\\\"") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "\""
0000000000000000000000000000000000000000;;			} else if l.follow("\\'") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "'"
0000000000000000000000000000000000000000;;			} else if l.follow("\\n") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "\n"
0000000000000000000000000000000000000000;;			} else if l.follow("\\b") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "\b"
0000000000000000000000000000000000000000;;			} else if l.follow("\\f") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "\f"
0000000000000000000000000000000000000000;;			} else if l.follow("\\/") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "/"
0000000000000000000000000000000000000000;;			} else if l.follow("\\t") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "\t"
0000000000000000000000000000000000000000;;			} else if l.follow("\\r") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "\r"
0000000000000000000000000000000000000000;;			} else if l.follow("\\\\") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				growingString += "\\"
0000000000000000000000000000000000000000;;			} else if l.follow("\\u") {
0000000000000000000000000000000000000000;;				l.pos += 2
0000000000000000000000000000000000000000;;				code := ""
0000000000000000000000000000000000000000;;				for i := 0; i < 4; i++ {
0000000000000000000000000000000000000000;;					c := l.peek()
0000000000000000000000000000000000000000;;					l.pos++
0000000000000000000000000000000000000000;;					if !isHexDigit(c) {
0000000000000000000000000000000000000000;;						return l.errorf("unfinished unicode escape")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					code = code + string(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.pos--
0000000000000000000000000000000000000000;;				intcode, err := strconv.ParseInt(code, 16, 32)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return l.errorf("invalid unicode escape: \\u" + code)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				growingString += string(rune(intcode))
0000000000000000000000000000000000000000;;			} else if l.follow("\\U") {
0000000000000000000000000000000000000000;;				l.pos += 2
0000000000000000000000000000000000000000;;				code := ""
0000000000000000000000000000000000000000;;				for i := 0; i < 8; i++ {
0000000000000000000000000000000000000000;;					c := l.peek()
0000000000000000000000000000000000000000;;					l.pos++
0000000000000000000000000000000000000000;;					if !isHexDigit(c) {
0000000000000000000000000000000000000000;;						return l.errorf("unfinished unicode escape")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					code = code + string(c)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.pos--
0000000000000000000000000000000000000000;;				intcode, err := strconv.ParseInt(code, 16, 32)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return l.errorf("invalid unicode escape: \\u" + code)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				growingString += string(rune(intcode))
0000000000000000000000000000000000000000;;			} else if l.follow("\\") {
0000000000000000000000000000000000000000;;				l.pos++
0000000000000000000000000000000000000000;;				return l.errorf("invalid escape sequence: \\" + string(l.peek()))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				growingString += string(l.peek())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.next() == eof {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return l.errorf("unclosed string")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *queryLexer) lexNumber() queryLexStateFn {
0000000000000000000000000000000000000000;;		l.ignore()
0000000000000000000000000000000000000000;;		if !l.accept("+") {
0000000000000000000000000000000000000000;;			l.accept("-")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pointSeen := false
0000000000000000000000000000000000000000;;		digitSeen := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			next := l.next()
0000000000000000000000000000000000000000;;			if next == '.' {
0000000000000000000000000000000000000000;;				if pointSeen {
0000000000000000000000000000000000000000;;					return l.errorf("cannot have two dots in one float")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !isDigit(l.peek()) {
0000000000000000000000000000000000000000;;					return l.errorf("float cannot end with a dot")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pointSeen = true
0000000000000000000000000000000000000000;;			} else if isDigit(next) {
0000000000000000000000000000000000000000;;				digitSeen = true
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				l.backup()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pointSeen && !digitSeen {
0000000000000000000000000000000000000000;;				return l.errorf("cannot start float with a dot")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !digitSeen {
0000000000000000000000000000000000000000;;			return l.errorf("no digit in that number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pointSeen {
0000000000000000000000000000000000000000;;			l.emit(tokenFloat)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			l.emit(tokenInteger)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.lexVoid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Entry point
0000000000000000000000000000000000000000;;	func lexQuery(input string) chan token {
0000000000000000000000000000000000000000;;		l := &queryLexer{
0000000000000000000000000000000000000000;;			input:  input,
0000000000000000000000000000000000000000;;			tokens: make(chan token),
0000000000000000000000000000000000000000;;			line:   1,
0000000000000000000000000000000000000000;;			col:    1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go l.run()
0000000000000000000000000000000000000000;;		return l.tokens
0000000000000000000000000000000000000000;;	}
