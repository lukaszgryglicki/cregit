0000000000000000000000000000000000000000;;	// TOML lexer.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Written using the principles developped by Rob Pike in
0000000000000000000000000000000000000000;;	// http://www.youtube.com/watch?v=HxaD_trXwRE
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package toml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pelletier/go-buffruneio"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var dateRegexp *regexp.Regexp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Define state functions
0000000000000000000000000000000000000000;;	type tomlLexStateFn func() tomlLexStateFn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Define lexer
0000000000000000000000000000000000000000;;	type tomlLexer struct {
0000000000000000000000000000000000000000;;		input         *buffruneio.Reader // Textual source
0000000000000000000000000000000000000000;;		buffer        []rune             // Runes composing the current token
0000000000000000000000000000000000000000;;		tokens        chan token
0000000000000000000000000000000000000000;;		depth         int
0000000000000000000000000000000000000000;;		line          int
0000000000000000000000000000000000000000;;		col           int
0000000000000000000000000000000000000000;;		endbufferLine int
0000000000000000000000000000000000000000;;		endbufferCol  int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Basic read operations on input
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) read() rune {
0000000000000000000000000000000000000000;;		r, err := l.input.ReadRune()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r == '\n' {
0000000000000000000000000000000000000000;;			l.endbufferLine++
0000000000000000000000000000000000000000;;			l.endbufferCol = 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			l.endbufferCol++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) next() rune {
0000000000000000000000000000000000000000;;		r := l.read()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r != eof {
0000000000000000000000000000000000000000;;			l.buffer = append(l.buffer, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) ignore() {
0000000000000000000000000000000000000000;;		l.buffer = make([]rune, 0)
0000000000000000000000000000000000000000;;		l.line = l.endbufferLine
0000000000000000000000000000000000000000;;		l.col = l.endbufferCol
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) skip() {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;		l.ignore()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) fastForward(n int) {
0000000000000000000000000000000000000000;;		for i := 0; i < n; i++ {
0000000000000000000000000000000000000000;;			l.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) emitWithValue(t tokenType, value string) {
0000000000000000000000000000000000000000;;		l.tokens <- token{
0000000000000000000000000000000000000000;;			Position: Position{l.line, l.col},
0000000000000000000000000000000000000000;;			typ:      t,
0000000000000000000000000000000000000000;;			val:      value,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.ignore()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) emit(t tokenType) {
0000000000000000000000000000000000000000;;		l.emitWithValue(t, string(l.buffer))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) peek() rune {
0000000000000000000000000000000000000000;;		r, err := l.input.ReadRune()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.input.UnreadRune()
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) follow(next string) bool {
0000000000000000000000000000000000000000;;		for _, expectedRune := range next {
0000000000000000000000000000000000000000;;			r, err := l.input.ReadRune()
0000000000000000000000000000000000000000;;			defer l.input.UnreadRune()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if expectedRune != r {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error management
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) errorf(format string, args ...interface{}) tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.tokens <- token{
0000000000000000000000000000000000000000;;			Position: Position{l.line, l.col},
0000000000000000000000000000000000000000;;			typ:      tokenError,
0000000000000000000000000000000000000000;;			val:      fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// State functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexVoid() tomlLexStateFn {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			next := l.peek()
0000000000000000000000000000000000000000;;			switch next {
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				return l.lexKeyGroup
0000000000000000000000000000000000000000;;			case '#':
0000000000000000000000000000000000000000;;				return l.lexComment
0000000000000000000000000000000000000000;;			case '=':
0000000000000000000000000000000000000000;;				return l.lexEqual
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isSpace(next) {
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.depth > 0 {
0000000000000000000000000000000000000000;;				return l.lexRvalue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isKeyStartChar(next) {
0000000000000000000000000000000000000000;;				return l.lexKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if next == eof {
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.emit(tokenEOF)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexRvalue() tomlLexStateFn {
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			next := l.peek()
0000000000000000000000000000000000000000;;			switch next {
0000000000000000000000000000000000000000;;			case '.':
0000000000000000000000000000000000000000;;				return l.errorf("cannot start float with a dot")
0000000000000000000000000000000000000000;;			case '=':
0000000000000000000000000000000000000000;;				return l.lexEqual
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				l.depth++
0000000000000000000000000000000000000000;;				return l.lexLeftBracket
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				l.depth--
0000000000000000000000000000000000000000;;				return l.lexRightBracket
0000000000000000000000000000000000000000;;			case '{':
0000000000000000000000000000000000000000;;				return l.lexLeftCurlyBrace
0000000000000000000000000000000000000000;;			case '}':
0000000000000000000000000000000000000000;;				return l.lexRightCurlyBrace
0000000000000000000000000000000000000000;;			case '#':
0000000000000000000000000000000000000000;;				return l.lexComment
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				return l.lexString
0000000000000000000000000000000000000000;;			case '\'':
0000000000000000000000000000000000000000;;				return l.lexLiteralString
0000000000000000000000000000000000000000;;			case ',':
0000000000000000000000000000000000000000;;				return l.lexComma
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				fallthrough
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;				if l.depth == 0 {
0000000000000000000000000000000000000000;;					return l.lexVoid
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return l.lexRvalue
0000000000000000000000000000000000000000;;			case '_':
0000000000000000000000000000000000000000;;				return l.errorf("cannot start number with underscore")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.follow("true") {
0000000000000000000000000000000000000000;;				return l.lexTrue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.follow("false") {
0000000000000000000000000000000000000000;;				return l.lexFalse
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isSpace(next) {
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if next == eof {
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			possibleDate := string(l.input.Peek(35))
0000000000000000000000000000000000000000;;			dateMatch := dateRegexp.FindString(possibleDate)
0000000000000000000000000000000000000000;;			if dateMatch != "" {
0000000000000000000000000000000000000000;;				l.fastForward(len(dateMatch))
0000000000000000000000000000000000000000;;				return l.lexDate
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if next == '+' || next == '-' || isDigit(next) {
0000000000000000000000000000000000000000;;				return l.lexNumber
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if isAlphanumeric(next) {
0000000000000000000000000000000000000000;;				return l.lexKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return l.errorf("no value can start with %c", next)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.emit(tokenEOF)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexLeftCurlyBrace() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;		l.emit(tokenLeftCurlyBrace)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexRightCurlyBrace() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;		l.emit(tokenRightCurlyBrace)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexDate() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.emit(tokenDate)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexTrue() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.fastForward(4)
0000000000000000000000000000000000000000;;		l.emit(tokenTrue)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexFalse() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.fastForward(5)
0000000000000000000000000000000000000000;;		l.emit(tokenFalse)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexEqual() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;		l.emit(tokenEqual)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexComma() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;		l.emit(tokenComma)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexKey() tomlLexStateFn {
0000000000000000000000000000000000000000;;		growingString := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for r := l.peek(); isKeyChar(r) || r == '\n' || r == '\r'; r = l.peek() {
0000000000000000000000000000000000000000;;			if r == '"' {
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				str, err := l.lexStringAsString(`"`, false, true)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return l.errorf(err.Error())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				growingString += `"` + str + `"`
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else if r == '\n' {
0000000000000000000000000000000000000000;;				return l.errorf("keys cannot contain new lines")
0000000000000000000000000000000000000000;;			} else if isSpace(r) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if !isValidBareChar(r) {
0000000000000000000000000000000000000000;;				return l.errorf("keys cannot contain %c character", r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			growingString += string(r)
0000000000000000000000000000000000000000;;			l.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.emitWithValue(tokenKey, growingString)
0000000000000000000000000000000000000000;;		return l.lexVoid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexComment() tomlLexStateFn {
0000000000000000000000000000000000000000;;		for next := l.peek(); next != '\n' && next != eof; next = l.peek() {
0000000000000000000000000000000000000000;;			if next == '\r' && l.follow("\r\n") {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l.ignore()
0000000000000000000000000000000000000000;;		return l.lexVoid
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexLeftBracket() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;		l.emit(tokenLeftBracket)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexLiteralStringAsString(terminator string, discardLeadingNewLine bool) (string, error) {
0000000000000000000000000000000000000000;;		growingString := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if discardLeadingNewLine {
0000000000000000000000000000000000000000;;			if l.follow("\r\n") {
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;			} else if l.peek() == '\n' {
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find end of string
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if l.follow(terminator) {
0000000000000000000000000000000000000000;;				return growingString, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			next := l.peek()
0000000000000000000000000000000000000000;;			if next == eof {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			growingString += string(l.next())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", errors.New("unclosed string")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexLiteralString() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.skip()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle special case for triple-quote
0000000000000000000000000000000000000000;;		terminator := "'"
0000000000000000000000000000000000000000;;		discardLeadingNewLine := false
0000000000000000000000000000000000000000;;		if l.follow("''") {
0000000000000000000000000000000000000000;;			l.skip()
0000000000000000000000000000000000000000;;			l.skip()
0000000000000000000000000000000000000000;;			terminator = "'''"
0000000000000000000000000000000000000000;;			discardLeadingNewLine = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		str, err := l.lexLiteralStringAsString(terminator, discardLeadingNewLine)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return l.errorf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.emitWithValue(tokenString, str)
0000000000000000000000000000000000000000;;		l.fastForward(len(terminator))
0000000000000000000000000000000000000000;;		l.ignore()
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lex a string and return the results as a string.
0000000000000000000000000000000000000000;;	// Terminator is the substring indicating the end of the token.
0000000000000000000000000000000000000000;;	// The resulting string does not include the terminator.
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexStringAsString(terminator string, discardLeadingNewLine, acceptNewLines bool) (string, error) {
0000000000000000000000000000000000000000;;		growingString := ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if discardLeadingNewLine {
0000000000000000000000000000000000000000;;			if l.follow("\r\n") {
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;			} else if l.peek() == '\n' {
0000000000000000000000000000000000000000;;				l.skip()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if l.follow(terminator) {
0000000000000000000000000000000000000000;;				return growingString, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.follow("\\") {
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				switch l.peek() {
0000000000000000000000000000000000000000;;				case '\r':
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case '\n':
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case '\t':
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case ' ':
0000000000000000000000000000000000000000;;					// skip all whitespace chars following backslash
0000000000000000000000000000000000000000;;					for strings.ContainsRune("\r\n\t ", l.peek()) {
0000000000000000000000000000000000000000;;						l.next()
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case '"':
0000000000000000000000000000000000000000;;					growingString += "\""
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case 'n':
0000000000000000000000000000000000000000;;					growingString += "\n"
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case 'b':
0000000000000000000000000000000000000000;;					growingString += "\b"
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case 'f':
0000000000000000000000000000000000000000;;					growingString += "\f"
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case '/':
0000000000000000000000000000000000000000;;					growingString += "/"
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case 't':
0000000000000000000000000000000000000000;;					growingString += "\t"
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case 'r':
0000000000000000000000000000000000000000;;					growingString += "\r"
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case '\\':
0000000000000000000000000000000000000000;;					growingString += "\\"
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				case 'u':
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;					code := ""
0000000000000000000000000000000000000000;;					for i := 0; i < 4; i++ {
0000000000000000000000000000000000000000;;						c := l.peek()
0000000000000000000000000000000000000000;;						if !isHexDigit(c) {
0000000000000000000000000000000000000000;;							return "", errors.New("unfinished unicode escape")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						l.next()
0000000000000000000000000000000000000000;;						code = code + string(c)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					intcode, err := strconv.ParseInt(code, 16, 32)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return "", errors.New("invalid unicode escape: \\u" + code)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					growingString += string(rune(intcode))
0000000000000000000000000000000000000000;;				case 'U':
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;					code := ""
0000000000000000000000000000000000000000;;					for i := 0; i < 8; i++ {
0000000000000000000000000000000000000000;;						c := l.peek()
0000000000000000000000000000000000000000;;						if !isHexDigit(c) {
0000000000000000000000000000000000000000;;							return "", errors.New("unfinished unicode escape")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						l.next()
0000000000000000000000000000000000000000;;						code = code + string(c)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					intcode, err := strconv.ParseInt(code, 16, 64)
0000000000000000000000000000000000000000;;					if err != nil {
0000000000000000000000000000000000000000;;						return "", errors.New("invalid unicode escape: \\U" + code)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					growingString += string(rune(intcode))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return "", errors.New("invalid escape sequence: \\" + string(l.peek()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r := l.peek()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if 0x00 <= r && r <= 0x1F && !(acceptNewLines && (r == '\n' || r == '\r')) {
0000000000000000000000000000000000000000;;					return "", fmt.Errorf("unescaped control character %U", r)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				growingString += string(r)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if l.peek() == eof {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return "", errors.New("unclosed string")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexString() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.skip()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle special case for triple-quote
0000000000000000000000000000000000000000;;		terminator := `"`
0000000000000000000000000000000000000000;;		discardLeadingNewLine := false
0000000000000000000000000000000000000000;;		acceptNewLines := false
0000000000000000000000000000000000000000;;		if l.follow(`""`) {
0000000000000000000000000000000000000000;;			l.skip()
0000000000000000000000000000000000000000;;			l.skip()
0000000000000000000000000000000000000000;;			terminator = `"""`
0000000000000000000000000000000000000000;;			discardLeadingNewLine = true
0000000000000000000000000000000000000000;;			acceptNewLines = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		str, err := l.lexStringAsString(terminator, discardLeadingNewLine, acceptNewLines)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return l.errorf(err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l.emitWithValue(tokenString, str)
0000000000000000000000000000000000000000;;		l.fastForward(len(terminator))
0000000000000000000000000000000000000000;;		l.ignore()
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexKeyGroup() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l.peek() == '[' {
0000000000000000000000000000000000000000;;			// token '[[' signifies an array of anonymous key groups
0000000000000000000000000000000000000000;;			l.next()
0000000000000000000000000000000000000000;;			l.emit(tokenDoubleLeftBracket)
0000000000000000000000000000000000000000;;			return l.lexInsideKeyGroupArray
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// vanilla key group
0000000000000000000000000000000000000000;;		l.emit(tokenLeftBracket)
0000000000000000000000000000000000000000;;		return l.lexInsideKeyGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexInsideKeyGroupArray() tomlLexStateFn {
0000000000000000000000000000000000000000;;		for r := l.peek(); r != eof; r = l.peek() {
0000000000000000000000000000000000000000;;			switch r {
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				if len(l.buffer) > 0 {
0000000000000000000000000000000000000000;;					l.emit(tokenKeyGroupArray)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				if l.peek() != ']' {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				l.emit(tokenDoubleRightBracket)
0000000000000000000000000000000000000000;;				return l.lexVoid
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				return l.errorf("group name cannot contain ']'")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.errorf("unclosed key group array")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexInsideKeyGroup() tomlLexStateFn {
0000000000000000000000000000000000000000;;		for r := l.peek(); r != eof; r = l.peek() {
0000000000000000000000000000000000000000;;			switch r {
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				if len(l.buffer) > 0 {
0000000000000000000000000000000000000000;;					l.emit(tokenKeyGroup)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				l.emit(tokenRightBracket)
0000000000000000000000000000000000000000;;				return l.lexVoid
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				return l.errorf("group name cannot contain ']'")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.errorf("unclosed key group")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexRightBracket() tomlLexStateFn {
0000000000000000000000000000000000000000;;		l.next()
0000000000000000000000000000000000000000;;		l.emit(tokenRightBracket)
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) lexNumber() tomlLexStateFn {
0000000000000000000000000000000000000000;;		r := l.peek()
0000000000000000000000000000000000000000;;		if r == '+' || r == '-' {
0000000000000000000000000000000000000000;;			l.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pointSeen := false
0000000000000000000000000000000000000000;;		expSeen := false
0000000000000000000000000000000000000000;;		digitSeen := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			next := l.peek()
0000000000000000000000000000000000000000;;			if next == '.' {
0000000000000000000000000000000000000000;;				if pointSeen {
0000000000000000000000000000000000000000;;					return l.errorf("cannot have two dots in one float")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				if !isDigit(l.peek()) {
0000000000000000000000000000000000000000;;					return l.errorf("float cannot end with a dot")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pointSeen = true
0000000000000000000000000000000000000000;;			} else if next == 'e' || next == 'E' {
0000000000000000000000000000000000000000;;				expSeen = true
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;				r := l.peek()
0000000000000000000000000000000000000000;;				if r == '+' || r == '-' {
0000000000000000000000000000000000000000;;					l.next()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if isDigit(next) {
0000000000000000000000000000000000000000;;				digitSeen = true
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;			} else if next == '_' {
0000000000000000000000000000000000000000;;				l.next()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pointSeen && !digitSeen {
0000000000000000000000000000000000000000;;				return l.errorf("cannot start float with a dot")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !digitSeen {
0000000000000000000000000000000000000000;;			return l.errorf("no digit in that number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pointSeen || expSeen {
0000000000000000000000000000000000000000;;			l.emit(tokenFloat)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			l.emit(tokenInteger)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l.lexRvalue
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *tomlLexer) run() {
0000000000000000000000000000000000000000;;		for state := l.lexVoid; state != nil; {
0000000000000000000000000000000000000000;;			state = state()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		close(l.tokens)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		dateRegexp = regexp.MustCompile(`^\d{1,4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{1,9})?(Z|[+-]\d{2}:\d{2})`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Entry point
0000000000000000000000000000000000000000;;	func lexToml(input io.Reader) chan token {
0000000000000000000000000000000000000000;;		bufferedInput := buffruneio.NewReader(input)
0000000000000000000000000000000000000000;;		l := &tomlLexer{
0000000000000000000000000000000000000000;;			input:         bufferedInput,
0000000000000000000000000000000000000000;;			tokens:        make(chan token),
0000000000000000000000000000000000000000;;			line:          1,
0000000000000000000000000000000000000000;;			col:           1,
0000000000000000000000000000000000000000;;			endbufferLine: 1,
0000000000000000000000000000000000000000;;			endbufferCol:  1,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		go l.run()
0000000000000000000000000000000000000000;;		return l.tokens
0000000000000000000000000000000000000000;;	}
