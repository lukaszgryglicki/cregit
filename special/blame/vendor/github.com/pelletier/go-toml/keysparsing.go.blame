0000000000000000000000000000000000000000;;	// Parsing keys handling both bare and quoted keys.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package toml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseKey(key string) ([]string, error) {
0000000000000000000000000000000000000000;;		groups := []string{}
0000000000000000000000000000000000000000;;		var buffer bytes.Buffer
0000000000000000000000000000000000000000;;		inQuotes := false
0000000000000000000000000000000000000000;;		escapeNext := false
0000000000000000000000000000000000000000;;		ignoreSpace := true
0000000000000000000000000000000000000000;;		expectDot := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, char := range key {
0000000000000000000000000000000000000000;;			if ignoreSpace {
0000000000000000000000000000000000000000;;				if char == ' ' {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ignoreSpace = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if escapeNext {
0000000000000000000000000000000000000000;;				buffer.WriteRune(char)
0000000000000000000000000000000000000000;;				escapeNext = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch char {
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				escapeNext = true
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				inQuotes = !inQuotes
0000000000000000000000000000000000000000;;				expectDot = false
0000000000000000000000000000000000000000;;			case '.':
0000000000000000000000000000000000000000;;				if inQuotes {
0000000000000000000000000000000000000000;;					buffer.WriteRune(char)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					groups = append(groups, buffer.String())
0000000000000000000000000000000000000000;;					buffer.Reset()
0000000000000000000000000000000000000000;;					ignoreSpace = true
0000000000000000000000000000000000000000;;					expectDot = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ' ':
0000000000000000000000000000000000000000;;				if inQuotes {
0000000000000000000000000000000000000000;;					buffer.WriteRune(char)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					expectDot = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if !inQuotes && !isValidBareChar(char) {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("invalid bare character: %c", char)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !inQuotes && expectDot {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("what?")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				buffer.WriteRune(char)
0000000000000000000000000000000000000000;;				expectDot = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if inQuotes {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("mismatched quotes")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if escapeNext {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("unfinished escape sequence")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if buffer.Len() > 0 {
0000000000000000000000000000000000000000;;			groups = append(groups, buffer.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(groups) == 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("empty key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return groups, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isValidBareChar(r rune) bool {
0000000000000000000000000000000000000000;;		return isAlphanumeric(r) || r == '-' || unicode.IsNumber(r)
0000000000000000000000000000000000000000;;	}
