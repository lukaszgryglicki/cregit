0000000000000000000000000000000000000000;;	package toml
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NodeFilterFn represents a user-defined filter function, for use with
0000000000000000000000000000000000000000;;	// Query.SetFilter().
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The return value of the function must indicate if 'node' is to be included
0000000000000000000000000000000000000000;;	// at this stage of the TOML path.  Returning true will include the node, and
0000000000000000000000000000000000000000;;	// returning false will exclude it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// NOTE: Care should be taken to write script callbacks such that they are safe
0000000000000000000000000000000000000000;;	// to use from multiple goroutines.
0000000000000000000000000000000000000000;;	type NodeFilterFn func(node interface{}) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryResult is the result of Executing a Query.
0000000000000000000000000000000000000000;;	type QueryResult struct {
0000000000000000000000000000000000000000;;		items     []interface{}
0000000000000000000000000000000000000000;;		positions []Position
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// appends a value/position pair to the result set.
0000000000000000000000000000000000000000;;	func (r *QueryResult) appendResult(node interface{}, pos Position) {
0000000000000000000000000000000000000000;;		r.items = append(r.items, node)
0000000000000000000000000000000000000000;;		r.positions = append(r.positions, pos)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Values is a set of values within a QueryResult.  The order of values is not
0000000000000000000000000000000000000000;;	// guaranteed to be in document order, and may be different each time a query is
0000000000000000000000000000000000000000;;	// executed.
0000000000000000000000000000000000000000;;	func (r QueryResult) Values() []interface{} {
0000000000000000000000000000000000000000;;		values := make([]interface{}, len(r.items))
0000000000000000000000000000000000000000;;		for i, v := range r.items {
0000000000000000000000000000000000000000;;			o, ok := v.(*tomlValue)
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				values[i] = o.value
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				values[i] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return values
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Positions is a set of positions for values within a QueryResult.  Each index
0000000000000000000000000000000000000000;;	// in Positions() corresponds to the entry in Value() of the same index.
0000000000000000000000000000000000000000;;	func (r QueryResult) Positions() []Position {
0000000000000000000000000000000000000000;;		return r.positions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// runtime context for executing query paths
0000000000000000000000000000000000000000;;	type queryContext struct {
0000000000000000000000000000000000000000;;		result       *QueryResult
0000000000000000000000000000000000000000;;		filters      *map[string]NodeFilterFn
0000000000000000000000000000000000000000;;		lastPosition Position
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// generic path functor interface
0000000000000000000000000000000000000000;;	type pathFn interface {
0000000000000000000000000000000000000000;;		setNext(next pathFn)
0000000000000000000000000000000000000000;;		call(node interface{}, ctx *queryContext)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Query is the representation of a compiled TOML path.  A Query is safe
0000000000000000000000000000000000000000;;	// for concurrent use by multiple goroutines.
0000000000000000000000000000000000000000;;	type Query struct {
0000000000000000000000000000000000000000;;		root    pathFn
0000000000000000000000000000000000000000;;		tail    pathFn
0000000000000000000000000000000000000000;;		filters *map[string]NodeFilterFn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newQuery() *Query {
0000000000000000000000000000000000000000;;		return &Query{
0000000000000000000000000000000000000000;;			root:    nil,
0000000000000000000000000000000000000000;;			tail:    nil,
0000000000000000000000000000000000000000;;			filters: &defaultFilterFunctions,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *Query) appendPath(next pathFn) {
0000000000000000000000000000000000000000;;		if q.root == nil {
0000000000000000000000000000000000000000;;			q.root = next
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			q.tail.setNext(next)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.tail = next
0000000000000000000000000000000000000000;;		next.setNext(newTerminatingFn()) // init the next functor
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompileQuery compiles a TOML path expression.  The returned Query can be used
0000000000000000000000000000000000000000;;	// to match elements within a TomlTree and its descendants.
0000000000000000000000000000000000000000;;	func CompileQuery(path string) (*Query, error) {
0000000000000000000000000000000000000000;;		return parseQuery(lexQuery(path))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Execute executes a query against a TomlTree, and returns the result of the query.
0000000000000000000000000000000000000000;;	func (q *Query) Execute(tree *TomlTree) *QueryResult {
0000000000000000000000000000000000000000;;		result := &QueryResult{
0000000000000000000000000000000000000000;;			items:     []interface{}{},
0000000000000000000000000000000000000000;;			positions: []Position{},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if q.root == nil {
0000000000000000000000000000000000000000;;			result.appendResult(tree, tree.GetPosition(""))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ctx := &queryContext{
0000000000000000000000000000000000000000;;				result:  result,
0000000000000000000000000000000000000000;;				filters: q.filters,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			q.root.call(tree, ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetFilter sets a user-defined filter function.  These may be used inside
0000000000000000000000000000000000000000;;	// "?(..)" query expressions to filter TOML document elements within a query.
0000000000000000000000000000000000000000;;	func (q *Query) SetFilter(name string, fn NodeFilterFn) {
0000000000000000000000000000000000000000;;		if q.filters == &defaultFilterFunctions {
0000000000000000000000000000000000000000;;			// clone the static table
0000000000000000000000000000000000000000;;			q.filters = &map[string]NodeFilterFn{}
0000000000000000000000000000000000000000;;			for k, v := range defaultFilterFunctions {
0000000000000000000000000000000000000000;;				(*q.filters)[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		(*q.filters)[name] = fn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var defaultFilterFunctions = map[string]NodeFilterFn{
0000000000000000000000000000000000000000;;		"tree": func(node interface{}) bool {
0000000000000000000000000000000000000000;;			_, ok := node.(*TomlTree)
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		"int": func(node interface{}) bool {
0000000000000000000000000000000000000000;;			_, ok := node.(int64)
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		"float": func(node interface{}) bool {
0000000000000000000000000000000000000000;;			_, ok := node.(float64)
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		"string": func(node interface{}) bool {
0000000000000000000000000000000000000000;;			_, ok := node.(string)
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		"time": func(node interface{}) bool {
0000000000000000000000000000000000000000;;			_, ok := node.(time.Time)
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;		"bool": func(node interface{}) bool {
0000000000000000000000000000000000000000;;			_, ok := node.(bool)
0000000000000000000000000000000000000000;;			return ok
0000000000000000000000000000000000000000;;		},
0000000000000000000000000000000000000000;;	}
