0000000000000000000000000000000000000000;;	package toml
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// support function to set positions for tomlValues
0000000000000000000000000000000000000000;;	// NOTE: this is done to allow ctx.lastPosition to indicate the start of any
0000000000000000000000000000000000000000;;	// values returned by the query engines
0000000000000000000000000000000000000000;;	func tomlValueCheck(node interface{}, ctx *queryContext) interface{} {
0000000000000000000000000000000000000000;;		switch castNode := node.(type) {
0000000000000000000000000000000000000000;;		case *tomlValue:
0000000000000000000000000000000000000000;;			ctx.lastPosition = castNode.position
0000000000000000000000000000000000000000;;			return castNode.value
0000000000000000000000000000000000000000;;		case []*TomlTree:
0000000000000000000000000000000000000000;;			if len(castNode) > 0 {
0000000000000000000000000000000000000000;;				ctx.lastPosition = castNode[0].position
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return node
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// base match
0000000000000000000000000000000000000000;;	type matchBase struct {
0000000000000000000000000000000000000000;;		next pathFn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchBase) setNext(next pathFn) {
0000000000000000000000000000000000000000;;		f.next = next
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// terminating functor - gathers results
0000000000000000000000000000000000000000;;	type terminatingFn struct {
0000000000000000000000000000000000000000;;		// empty
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newTerminatingFn() *terminatingFn {
0000000000000000000000000000000000000000;;		return &terminatingFn{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *terminatingFn) setNext(next pathFn) {
0000000000000000000000000000000000000000;;		// do nothing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *terminatingFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		switch castNode := node.(type) {
0000000000000000000000000000000000000000;;		case *TomlTree:
0000000000000000000000000000000000000000;;			ctx.result.appendResult(node, castNode.position)
0000000000000000000000000000000000000000;;		case *tomlValue:
0000000000000000000000000000000000000000;;			ctx.result.appendResult(node, castNode.position)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// use last position for scalars
0000000000000000000000000000000000000000;;			ctx.result.appendResult(node, ctx.lastPosition)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match single key
0000000000000000000000000000000000000000;;	type matchKeyFn struct {
0000000000000000000000000000000000000000;;		matchBase
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchKeyFn(name string) *matchKeyFn {
0000000000000000000000000000000000000000;;		return &matchKeyFn{Name: name}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchKeyFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		if array, ok := node.([]*TomlTree); ok {
0000000000000000000000000000000000000000;;			for _, tree := range array {
0000000000000000000000000000000000000000;;				item := tree.values[f.Name]
0000000000000000000000000000000000000000;;				if item != nil {
0000000000000000000000000000000000000000;;					f.next.call(item, ctx)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if tree, ok := node.(*TomlTree); ok {
0000000000000000000000000000000000000000;;			item := tree.values[f.Name]
0000000000000000000000000000000000000000;;			if item != nil {
0000000000000000000000000000000000000000;;				f.next.call(item, ctx)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match single index
0000000000000000000000000000000000000000;;	type matchIndexFn struct {
0000000000000000000000000000000000000000;;		matchBase
0000000000000000000000000000000000000000;;		Idx int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchIndexFn(idx int) *matchIndexFn {
0000000000000000000000000000000000000000;;		return &matchIndexFn{Idx: idx}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchIndexFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		if arr, ok := tomlValueCheck(node, ctx).([]interface{}); ok {
0000000000000000000000000000000000000000;;			if f.Idx < len(arr) && f.Idx >= 0 {
0000000000000000000000000000000000000000;;				f.next.call(arr[f.Idx], ctx)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filter by slicing
0000000000000000000000000000000000000000;;	type matchSliceFn struct {
0000000000000000000000000000000000000000;;		matchBase
0000000000000000000000000000000000000000;;		Start, End, Step int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchSliceFn(start, end, step int) *matchSliceFn {
0000000000000000000000000000000000000000;;		return &matchSliceFn{Start: start, End: end, Step: step}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchSliceFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		if arr, ok := tomlValueCheck(node, ctx).([]interface{}); ok {
0000000000000000000000000000000000000000;;			// adjust indexes for negative values, reverse ordering
0000000000000000000000000000000000000000;;			realStart, realEnd := f.Start, f.End
0000000000000000000000000000000000000000;;			if realStart < 0 {
0000000000000000000000000000000000000000;;				realStart = len(arr) + realStart
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if realEnd < 0 {
0000000000000000000000000000000000000000;;				realEnd = len(arr) + realEnd
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if realEnd < realStart {
0000000000000000000000000000000000000000;;				realEnd, realStart = realStart, realEnd // swap
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// loop and gather
0000000000000000000000000000000000000000;;			for idx := realStart; idx < realEnd; idx += f.Step {
0000000000000000000000000000000000000000;;				f.next.call(arr[idx], ctx)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match anything
0000000000000000000000000000000000000000;;	type matchAnyFn struct {
0000000000000000000000000000000000000000;;		matchBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchAnyFn() *matchAnyFn {
0000000000000000000000000000000000000000;;		return &matchAnyFn{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchAnyFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		if tree, ok := node.(*TomlTree); ok {
0000000000000000000000000000000000000000;;			for _, v := range tree.values {
0000000000000000000000000000000000000000;;				f.next.call(v, ctx)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// filter through union
0000000000000000000000000000000000000000;;	type matchUnionFn struct {
0000000000000000000000000000000000000000;;		Union []pathFn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchUnionFn) setNext(next pathFn) {
0000000000000000000000000000000000000000;;		for _, fn := range f.Union {
0000000000000000000000000000000000000000;;			fn.setNext(next)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchUnionFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		for _, fn := range f.Union {
0000000000000000000000000000000000000000;;			fn.call(node, ctx)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match every single last node in the tree
0000000000000000000000000000000000000000;;	type matchRecursiveFn struct {
0000000000000000000000000000000000000000;;		matchBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchRecursiveFn() *matchRecursiveFn {
0000000000000000000000000000000000000000;;		return &matchRecursiveFn{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchRecursiveFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		if tree, ok := node.(*TomlTree); ok {
0000000000000000000000000000000000000000;;			var visit func(tree *TomlTree)
0000000000000000000000000000000000000000;;			visit = func(tree *TomlTree) {
0000000000000000000000000000000000000000;;				for _, v := range tree.values {
0000000000000000000000000000000000000000;;					f.next.call(v, ctx)
0000000000000000000000000000000000000000;;					switch node := v.(type) {
0000000000000000000000000000000000000000;;					case *TomlTree:
0000000000000000000000000000000000000000;;						visit(node)
0000000000000000000000000000000000000000;;					case []*TomlTree:
0000000000000000000000000000000000000000;;						for _, subtree := range node {
0000000000000000000000000000000000000000;;							visit(subtree)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.next.call(tree, ctx)
0000000000000000000000000000000000000000;;			visit(tree)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// match based on an externally provided functional filter
0000000000000000000000000000000000000000;;	type matchFilterFn struct {
0000000000000000000000000000000000000000;;		matchBase
0000000000000000000000000000000000000000;;		Pos  Position
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newMatchFilterFn(name string, pos Position) *matchFilterFn {
0000000000000000000000000000000000000000;;		return &matchFilterFn{Name: name, Pos: pos}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *matchFilterFn) call(node interface{}, ctx *queryContext) {
0000000000000000000000000000000000000000;;		fn, ok := (*ctx.filters)[f.Name]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("%s: query context does not have filter '%s'",
0000000000000000000000000000000000000000;;				f.Pos.String(), f.Name))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch castNode := tomlValueCheck(node, ctx).(type) {
0000000000000000000000000000000000000000;;		case *TomlTree:
0000000000000000000000000000000000000000;;			for _, v := range castNode.values {
0000000000000000000000000000000000000000;;				if tv, ok := v.(*tomlValue); ok {
0000000000000000000000000000000000000000;;					if fn(tv.value) {
0000000000000000000000000000000000000000;;						f.next.call(v, ctx)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if fn(v) {
0000000000000000000000000000000000000000;;						f.next.call(v, ctx)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			for _, v := range castNode {
0000000000000000000000000000000000000000;;				if fn(v) {
0000000000000000000000000000000000000000;;					f.next.call(v, ctx)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
