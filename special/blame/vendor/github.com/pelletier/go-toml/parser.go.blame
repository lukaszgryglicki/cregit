0000000000000000000000000000000000000000;;	// TOML Parser.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	package toml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tomlParser struct {
0000000000000000000000000000000000000000;;		flow          chan token
0000000000000000000000000000000000000000;;		tree          *TomlTree
0000000000000000000000000000000000000000;;		tokensBuffer  []token
0000000000000000000000000000000000000000;;		currentGroup  []string
0000000000000000000000000000000000000000;;		seenGroupKeys []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type tomlParserStateFn func() tomlParserStateFn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Formats and panics an error message based on a token
0000000000000000000000000000000000000000;;	func (p *tomlParser) raiseError(tok *token, msg string, args ...interface{}) {
0000000000000000000000000000000000000000;;		panic(tok.Position.String() + ": " + fmt.Sprintf(msg, args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) run() {
0000000000000000000000000000000000000000;;		for state := p.parseStart; state != nil; {
0000000000000000000000000000000000000000;;			state = state()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) peek() *token {
0000000000000000000000000000000000000000;;		if len(p.tokensBuffer) != 0 {
0000000000000000000000000000000000000000;;			return &(p.tokensBuffer[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tok, ok := <-p.flow
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.tokensBuffer = append(p.tokensBuffer, tok)
0000000000000000000000000000000000000000;;		return &tok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) assume(typ tokenType) {
0000000000000000000000000000000000000000;;		tok := p.getToken()
0000000000000000000000000000000000000000;;		if tok == nil {
0000000000000000000000000000000000000000;;			p.raiseError(tok, "was expecting token %s, but token stream is empty", tok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.typ != typ {
0000000000000000000000000000000000000000;;			p.raiseError(tok, "was expecting token %s, but got %s instead", typ, tok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) getToken() *token {
0000000000000000000000000000000000000000;;		if len(p.tokensBuffer) != 0 {
0000000000000000000000000000000000000000;;			tok := p.tokensBuffer[0]
0000000000000000000000000000000000000000;;			p.tokensBuffer = p.tokensBuffer[1:]
0000000000000000000000000000000000000000;;			return &tok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tok, ok := <-p.flow
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &tok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) parseStart() tomlParserStateFn {
0000000000000000000000000000000000000000;;		tok := p.peek()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// end of stream, parsing is finished
0000000000000000000000000000000000000000;;		if tok == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tok.typ {
0000000000000000000000000000000000000000;;		case tokenDoubleLeftBracket:
0000000000000000000000000000000000000000;;			return p.parseGroupArray
0000000000000000000000000000000000000000;;		case tokenLeftBracket:
0000000000000000000000000000000000000000;;			return p.parseGroup
0000000000000000000000000000000000000000;;		case tokenKey:
0000000000000000000000000000000000000000;;			return p.parseAssign
0000000000000000000000000000000000000000;;		case tokenEOF:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			p.raiseError(tok, "unexpected token")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) parseGroupArray() tomlParserStateFn {
0000000000000000000000000000000000000000;;		startToken := p.getToken() // discard the [[
0000000000000000000000000000000000000000;;		key := p.getToken()
0000000000000000000000000000000000000000;;		if key.typ != tokenKeyGroupArray {
0000000000000000000000000000000000000000;;			p.raiseError(key, "unexpected token %s, was expecting a key group array", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get or create group array element at the indicated part in the path
0000000000000000000000000000000000000000;;		keys, err := parseKey(key.val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.raiseError(key, "invalid group array key: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.tree.createSubTree(keys[:len(keys)-1], startToken.Position) // create parent entries
0000000000000000000000000000000000000000;;		destTree := p.tree.GetPath(keys)
0000000000000000000000000000000000000000;;		var array []*TomlTree
0000000000000000000000000000000000000000;;		if destTree == nil {
0000000000000000000000000000000000000000;;			array = make([]*TomlTree, 0)
0000000000000000000000000000000000000000;;		} else if target, ok := destTree.([]*TomlTree); ok && target != nil {
0000000000000000000000000000000000000000;;			array = destTree.([]*TomlTree)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.raiseError(key, "key %s is already assigned and not of type group array", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.currentGroup = keys
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add a new tree to the end of the group array
0000000000000000000000000000000000000000;;		newTree := newTomlTree()
0000000000000000000000000000000000000000;;		newTree.position = startToken.Position
0000000000000000000000000000000000000000;;		array = append(array, newTree)
0000000000000000000000000000000000000000;;		p.tree.SetPath(p.currentGroup, array)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove all keys that were children of this group array
0000000000000000000000000000000000000000;;		prefix := key.val + "."
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		for ii := 0; ii < len(p.seenGroupKeys); {
0000000000000000000000000000000000000000;;			groupKey := p.seenGroupKeys[ii]
0000000000000000000000000000000000000000;;			if strings.HasPrefix(groupKey, prefix) {
0000000000000000000000000000000000000000;;				p.seenGroupKeys = append(p.seenGroupKeys[:ii], p.seenGroupKeys[ii+1:]...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				found = (groupKey == key.val)
0000000000000000000000000000000000000000;;				ii++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keep this key name from use by other kinds of assignments
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			p.seenGroupKeys = append(p.seenGroupKeys, key.val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// move to next parser state
0000000000000000000000000000000000000000;;		p.assume(tokenDoubleRightBracket)
0000000000000000000000000000000000000000;;		return p.parseStart
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) parseGroup() tomlParserStateFn {
0000000000000000000000000000000000000000;;		startToken := p.getToken() // discard the [
0000000000000000000000000000000000000000;;		key := p.getToken()
0000000000000000000000000000000000000000;;		if key.typ != tokenKeyGroup {
0000000000000000000000000000000000000000;;			p.raiseError(key, "unexpected token %s, was expecting a key group", key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, item := range p.seenGroupKeys {
0000000000000000000000000000000000000000;;			if item == key.val {
0000000000000000000000000000000000000000;;				p.raiseError(key, "duplicated tables")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.seenGroupKeys = append(p.seenGroupKeys, key.val)
0000000000000000000000000000000000000000;;		keys, err := parseKey(key.val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.raiseError(key, "invalid group array key: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := p.tree.createSubTree(keys, startToken.Position); err != nil {
0000000000000000000000000000000000000000;;			p.raiseError(key, "%s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.assume(tokenRightBracket)
0000000000000000000000000000000000000000;;		p.currentGroup = keys
0000000000000000000000000000000000000000;;		return p.parseStart
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) parseAssign() tomlParserStateFn {
0000000000000000000000000000000000000000;;		key := p.getToken()
0000000000000000000000000000000000000000;;		p.assume(tokenEqual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		value := p.parseRvalue()
0000000000000000000000000000000000000000;;		var groupKey []string
0000000000000000000000000000000000000000;;		if len(p.currentGroup) > 0 {
0000000000000000000000000000000000000000;;			groupKey = p.currentGroup
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			groupKey = []string{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the group to assign, looking out for arrays of groups
0000000000000000000000000000000000000000;;		var targetNode *TomlTree
0000000000000000000000000000000000000000;;		switch node := p.tree.GetPath(groupKey).(type) {
0000000000000000000000000000000000000000;;		case []*TomlTree:
0000000000000000000000000000000000000000;;			targetNode = node[len(node)-1]
0000000000000000000000000000000000000000;;		case *TomlTree:
0000000000000000000000000000000000000000;;			targetNode = node
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			p.raiseError(key, "Unknown group type for path: %s",
0000000000000000000000000000000000000000;;				strings.Join(groupKey, "."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assign value to the found group
0000000000000000000000000000000000000000;;		keyVals, err := parseKey(key.val)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			p.raiseError(key, "%s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(keyVals) != 1 {
0000000000000000000000000000000000000000;;			p.raiseError(key, "Invalid key")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		keyVal := keyVals[0]
0000000000000000000000000000000000000000;;		localKey := []string{keyVal}
0000000000000000000000000000000000000000;;		finalKey := append(groupKey, keyVal)
0000000000000000000000000000000000000000;;		if targetNode.GetPath(localKey) != nil {
0000000000000000000000000000000000000000;;			p.raiseError(key, "The following key was defined twice: %s",
0000000000000000000000000000000000000000;;				strings.Join(finalKey, "."))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var toInsert interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch value.(type) {
0000000000000000000000000000000000000000;;		case *TomlTree:
0000000000000000000000000000000000000000;;			toInsert = value
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			toInsert = &tomlValue{value, key.Position}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		targetNode.values[keyVal] = toInsert
0000000000000000000000000000000000000000;;		return p.parseStart
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var numberUnderscoreInvalidRegexp *regexp.Regexp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func cleanupNumberToken(value string) (string, error) {
0000000000000000000000000000000000000000;;		if numberUnderscoreInvalidRegexp.MatchString(value) {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("invalid use of _ in number")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cleanedVal := strings.Replace(value, "_", "", -1)
0000000000000000000000000000000000000000;;		return cleanedVal, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) parseRvalue() interface{} {
0000000000000000000000000000000000000000;;		tok := p.getToken()
0000000000000000000000000000000000000000;;		if tok == nil || tok.typ == tokenEOF {
0000000000000000000000000000000000000000;;			p.raiseError(tok, "expecting a value")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tok.typ {
0000000000000000000000000000000000000000;;		case tokenString:
0000000000000000000000000000000000000000;;			return tok.val
0000000000000000000000000000000000000000;;		case tokenTrue:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		case tokenFalse:
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		case tokenInteger:
0000000000000000000000000000000000000000;;			cleanedVal, err := cleanupNumberToken(tok.val)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				p.raiseError(tok, "%s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val, err := strconv.ParseInt(cleanedVal, 10, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				p.raiseError(tok, "%s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		case tokenFloat:
0000000000000000000000000000000000000000;;			cleanedVal, err := cleanupNumberToken(tok.val)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				p.raiseError(tok, "%s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val, err := strconv.ParseFloat(cleanedVal, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				p.raiseError(tok, "%s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		case tokenDate:
0000000000000000000000000000000000000000;;			val, err := time.ParseInLocation(time.RFC3339Nano, tok.val, time.UTC)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				p.raiseError(tok, "%s", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return val
0000000000000000000000000000000000000000;;		case tokenLeftBracket:
0000000000000000000000000000000000000000;;			return p.parseArray()
0000000000000000000000000000000000000000;;		case tokenLeftCurlyBrace:
0000000000000000000000000000000000000000;;			return p.parseInlineTable()
0000000000000000000000000000000000000000;;		case tokenEqual:
0000000000000000000000000000000000000000;;			p.raiseError(tok, "cannot have multiple equals for the same key")
0000000000000000000000000000000000000000;;		case tokenError:
0000000000000000000000000000000000000000;;			p.raiseError(tok, "%s", tok)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.raiseError(tok, "never reached")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tokenIsComma(t *token) bool {
0000000000000000000000000000000000000000;;		return t != nil && t.typ == tokenComma
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) parseInlineTable() *TomlTree {
0000000000000000000000000000000000000000;;		tree := newTomlTree()
0000000000000000000000000000000000000000;;		var previous *token
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			follow := p.peek()
0000000000000000000000000000000000000000;;			if follow == nil || follow.typ == tokenEOF {
0000000000000000000000000000000000000000;;				p.raiseError(follow, "unterminated inline table")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch follow.typ {
0000000000000000000000000000000000000000;;			case tokenRightCurlyBrace:
0000000000000000000000000000000000000000;;				p.getToken()
0000000000000000000000000000000000000000;;				break Loop
0000000000000000000000000000000000000000;;			case tokenKey:
0000000000000000000000000000000000000000;;				if !tokenIsComma(previous) && previous != nil {
0000000000000000000000000000000000000000;;					p.raiseError(follow, "comma expected between fields in inline table")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				key := p.getToken()
0000000000000000000000000000000000000000;;				p.assume(tokenEqual)
0000000000000000000000000000000000000000;;				value := p.parseRvalue()
0000000000000000000000000000000000000000;;				tree.Set(key.val, value)
0000000000000000000000000000000000000000;;			case tokenComma:
0000000000000000000000000000000000000000;;				if previous == nil {
0000000000000000000000000000000000000000;;					p.raiseError(follow, "inline table cannot start with a comma")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if tokenIsComma(previous) {
0000000000000000000000000000000000000000;;					p.raiseError(follow, "need field between two commas in inline table")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.getToken()
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				p.raiseError(follow, "unexpected token type in inline table: %s", follow.typ.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			previous = follow
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tokenIsComma(previous) {
0000000000000000000000000000000000000000;;			p.raiseError(previous, "trailing comma at the end of inline table")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return tree
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *tomlParser) parseArray() interface{} {
0000000000000000000000000000000000000000;;		var array []interface{}
0000000000000000000000000000000000000000;;		arrayType := reflect.TypeOf(nil)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			follow := p.peek()
0000000000000000000000000000000000000000;;			if follow == nil || follow.typ == tokenEOF {
0000000000000000000000000000000000000000;;				p.raiseError(follow, "unterminated array")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if follow.typ == tokenRightBracket {
0000000000000000000000000000000000000000;;				p.getToken()
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			val := p.parseRvalue()
0000000000000000000000000000000000000000;;			if arrayType == nil {
0000000000000000000000000000000000000000;;				arrayType = reflect.TypeOf(val)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if reflect.TypeOf(val) != arrayType {
0000000000000000000000000000000000000000;;				p.raiseError(follow, "mixed types in array")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			array = append(array, val)
0000000000000000000000000000000000000000;;			follow = p.peek()
0000000000000000000000000000000000000000;;			if follow == nil || follow.typ == tokenEOF {
0000000000000000000000000000000000000000;;				p.raiseError(follow, "unterminated array")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if follow.typ != tokenRightBracket && follow.typ != tokenComma {
0000000000000000000000000000000000000000;;				p.raiseError(follow, "missing comma")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if follow.typ == tokenComma {
0000000000000000000000000000000000000000;;				p.getToken()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// An array of TomlTrees is actually an array of inline
0000000000000000000000000000000000000000;;		// tables, which is a shorthand for a table array. If the
0000000000000000000000000000000000000000;;		// array was not converted from []interface{} to []*TomlTree,
0000000000000000000000000000000000000000;;		// the two notations would not be equivalent.
0000000000000000000000000000000000000000;;		if arrayType == reflect.TypeOf(newTomlTree()) {
0000000000000000000000000000000000000000;;			tomlArray := make([]*TomlTree, len(array))
0000000000000000000000000000000000000000;;			for i, v := range array {
0000000000000000000000000000000000000000;;				tomlArray[i] = v.(*TomlTree)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return tomlArray
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return array
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseToml(flow chan token) *TomlTree {
0000000000000000000000000000000000000000;;		result := newTomlTree()
0000000000000000000000000000000000000000;;		result.position = Position{1, 1}
0000000000000000000000000000000000000000;;		parser := &tomlParser{
0000000000000000000000000000000000000000;;			flow:          flow,
0000000000000000000000000000000000000000;;			tree:          result,
0000000000000000000000000000000000000000;;			tokensBuffer:  make([]token, 0),
0000000000000000000000000000000000000000;;			currentGroup:  make([]string, 0),
0000000000000000000000000000000000000000;;			seenGroupKeys: make([]string, 0),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.run()
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		numberUnderscoreInvalidRegexp = regexp.MustCompile(`([^\d]_|_[^\d]|_$|^_)`)
0000000000000000000000000000000000000000;;	}
