0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	  Based on the "jsonpath" spec/concept.
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	  http://goessner.net/articles/JsonPath/
0000000000000000000000000000000000000000;;	  https://code.google.com/p/json-path/
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package toml
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxInt = int(^uint(0) >> 1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type queryParser struct {
0000000000000000000000000000000000000000;;		flow         chan token
0000000000000000000000000000000000000000;;		tokensBuffer []token
0000000000000000000000000000000000000000;;		query        *Query
0000000000000000000000000000000000000000;;		union        []pathFn
0000000000000000000000000000000000000000;;		err          error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type queryParserStateFn func() queryParserStateFn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Formats and panics an error message based on a token
0000000000000000000000000000000000000000;;	func (p *queryParser) parseError(tok *token, msg string, args ...interface{}) queryParserStateFn {
0000000000000000000000000000000000000000;;		p.err = fmt.Errorf(tok.Position.String()+": "+msg, args...)
0000000000000000000000000000000000000000;;		return nil // trigger parse to end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) run() {
0000000000000000000000000000000000000000;;		for state := p.parseStart; state != nil; {
0000000000000000000000000000000000000000;;			state = state()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) backup(tok *token) {
0000000000000000000000000000000000000000;;		p.tokensBuffer = append(p.tokensBuffer, *tok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) peek() *token {
0000000000000000000000000000000000000000;;		if len(p.tokensBuffer) != 0 {
0000000000000000000000000000000000000000;;			return &(p.tokensBuffer[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tok, ok := <-p.flow
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.backup(&tok)
0000000000000000000000000000000000000000;;		return &tok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) lookahead(types ...tokenType) bool {
0000000000000000000000000000000000000000;;		result := true
0000000000000000000000000000000000000000;;		buffer := []token{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, typ := range types {
0000000000000000000000000000000000000000;;			tok := p.getToken()
0000000000000000000000000000000000000000;;			if tok == nil {
0000000000000000000000000000000000000000;;				result = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buffer = append(buffer, *tok)
0000000000000000000000000000000000000000;;			if tok.typ != typ {
0000000000000000000000000000000000000000;;				result = false
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// add the tokens back to the buffer, and return
0000000000000000000000000000000000000000;;		p.tokensBuffer = append(p.tokensBuffer, buffer...)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) getToken() *token {
0000000000000000000000000000000000000000;;		if len(p.tokensBuffer) != 0 {
0000000000000000000000000000000000000000;;			tok := p.tokensBuffer[0]
0000000000000000000000000000000000000000;;			p.tokensBuffer = p.tokensBuffer[1:]
0000000000000000000000000000000000000000;;			return &tok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tok, ok := <-p.flow
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &tok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) parseStart() queryParserStateFn {
0000000000000000000000000000000000000000;;		tok := p.getToken()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tok == nil || tok.typ == tokenEOF {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tok.typ != tokenDollar {
0000000000000000000000000000000000000000;;			return p.parseError(tok, "Expected '$' at start of expression")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.parseMatchExpr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// handle '.' prefix, '[]', and '..'
0000000000000000000000000000000000000000;;	func (p *queryParser) parseMatchExpr() queryParserStateFn {
0000000000000000000000000000000000000000;;		tok := p.getToken()
0000000000000000000000000000000000000000;;		switch tok.typ {
0000000000000000000000000000000000000000;;		case tokenDotDot:
0000000000000000000000000000000000000000;;			p.query.appendPath(&matchRecursiveFn{})
0000000000000000000000000000000000000000;;			// nested parse for '..'
0000000000000000000000000000000000000000;;			tok := p.getToken()
0000000000000000000000000000000000000000;;			switch tok.typ {
0000000000000000000000000000000000000000;;			case tokenKey:
0000000000000000000000000000000000000000;;				p.query.appendPath(newMatchKeyFn(tok.val))
0000000000000000000000000000000000000000;;				return p.parseMatchExpr
0000000000000000000000000000000000000000;;			case tokenLeftBracket:
0000000000000000000000000000000000000000;;				return p.parseBracketExpr
0000000000000000000000000000000000000000;;			case tokenStar:
0000000000000000000000000000000000000000;;				// do nothing - the recursive predicate is enough
0000000000000000000000000000000000000000;;				return p.parseMatchExpr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case tokenDot:
0000000000000000000000000000000000000000;;			// nested parse for '.'
0000000000000000000000000000000000000000;;			tok := p.getToken()
0000000000000000000000000000000000000000;;			switch tok.typ {
0000000000000000000000000000000000000000;;			case tokenKey:
0000000000000000000000000000000000000000;;				p.query.appendPath(newMatchKeyFn(tok.val))
0000000000000000000000000000000000000000;;				return p.parseMatchExpr
0000000000000000000000000000000000000000;;			case tokenStar:
0000000000000000000000000000000000000000;;				p.query.appendPath(&matchAnyFn{})
0000000000000000000000000000000000000000;;				return p.parseMatchExpr
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case tokenLeftBracket:
0000000000000000000000000000000000000000;;			return p.parseBracketExpr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case tokenEOF:
0000000000000000000000000000000000000000;;			return nil // allow EOF at this stage
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.parseError(tok, "expected match expression")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) parseBracketExpr() queryParserStateFn {
0000000000000000000000000000000000000000;;		if p.lookahead(tokenInteger, tokenColon) {
0000000000000000000000000000000000000000;;			return p.parseSliceExpr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.peek().typ == tokenColon {
0000000000000000000000000000000000000000;;			return p.parseSliceExpr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.parseUnionExpr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) parseUnionExpr() queryParserStateFn {
0000000000000000000000000000000000000000;;		var tok *token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this state can be traversed after some sub-expressions
0000000000000000000000000000000000000000;;		// so be careful when setting up state in the parser
0000000000000000000000000000000000000000;;		if p.union == nil {
0000000000000000000000000000000000000000;;			p.union = []pathFn{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	loop: // labeled loop for easy breaking
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if len(p.union) > 0 {
0000000000000000000000000000000000000000;;				// parse delimiter or terminator
0000000000000000000000000000000000000000;;				tok = p.getToken()
0000000000000000000000000000000000000000;;				switch tok.typ {
0000000000000000000000000000000000000000;;				case tokenComma:
0000000000000000000000000000000000000000;;					// do nothing
0000000000000000000000000000000000000000;;				case tokenRightBracket:
0000000000000000000000000000000000000000;;					break loop
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return p.parseError(tok, "expected ',' or ']', not '%s'", tok.val)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// parse sub expression
0000000000000000000000000000000000000000;;			tok = p.getToken()
0000000000000000000000000000000000000000;;			switch tok.typ {
0000000000000000000000000000000000000000;;			case tokenInteger:
0000000000000000000000000000000000000000;;				p.union = append(p.union, newMatchIndexFn(tok.Int()))
0000000000000000000000000000000000000000;;			case tokenKey:
0000000000000000000000000000000000000000;;				p.union = append(p.union, newMatchKeyFn(tok.val))
0000000000000000000000000000000000000000;;			case tokenString:
0000000000000000000000000000000000000000;;				p.union = append(p.union, newMatchKeyFn(tok.val))
0000000000000000000000000000000000000000;;			case tokenQuestion:
0000000000000000000000000000000000000000;;				return p.parseFilterExpr
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return p.parseError(tok, "expected union sub expression, not '%s', %d", tok.val, len(p.union))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if there is only one sub-expression, use that instead
0000000000000000000000000000000000000000;;		if len(p.union) == 1 {
0000000000000000000000000000000000000000;;			p.query.appendPath(p.union[0])
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			p.query.appendPath(&matchUnionFn{p.union})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.union = nil // clear out state
0000000000000000000000000000000000000000;;		return p.parseMatchExpr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) parseSliceExpr() queryParserStateFn {
0000000000000000000000000000000000000000;;		// init slice to grab all elements
0000000000000000000000000000000000000000;;		start, end, step := 0, maxInt, 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse optional start
0000000000000000000000000000000000000000;;		tok := p.getToken()
0000000000000000000000000000000000000000;;		if tok.typ == tokenInteger {
0000000000000000000000000000000000000000;;			start = tok.Int()
0000000000000000000000000000000000000000;;			tok = p.getToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.typ != tokenColon {
0000000000000000000000000000000000000000;;			return p.parseError(tok, "expected ':'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse optional end
0000000000000000000000000000000000000000;;		tok = p.getToken()
0000000000000000000000000000000000000000;;		if tok.typ == tokenInteger {
0000000000000000000000000000000000000000;;			end = tok.Int()
0000000000000000000000000000000000000000;;			tok = p.getToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.typ == tokenRightBracket {
0000000000000000000000000000000000000000;;			p.query.appendPath(newMatchSliceFn(start, end, step))
0000000000000000000000000000000000000000;;			return p.parseMatchExpr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.typ != tokenColon {
0000000000000000000000000000000000000000;;			return p.parseError(tok, "expected ']' or ':'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse optional step
0000000000000000000000000000000000000000;;		tok = p.getToken()
0000000000000000000000000000000000000000;;		if tok.typ == tokenInteger {
0000000000000000000000000000000000000000;;			step = tok.Int()
0000000000000000000000000000000000000000;;			if step < 0 {
0000000000000000000000000000000000000000;;				return p.parseError(tok, "step must be a positive value")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tok = p.getToken()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if tok.typ != tokenRightBracket {
0000000000000000000000000000000000000000;;			return p.parseError(tok, "expected ']'")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.query.appendPath(newMatchSliceFn(start, end, step))
0000000000000000000000000000000000000000;;		return p.parseMatchExpr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *queryParser) parseFilterExpr() queryParserStateFn {
0000000000000000000000000000000000000000;;		tok := p.getToken()
0000000000000000000000000000000000000000;;		if tok.typ != tokenLeftParen {
0000000000000000000000000000000000000000;;			return p.parseError(tok, "expected left-parenthesis for filter expression")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tok = p.getToken()
0000000000000000000000000000000000000000;;		if tok.typ != tokenKey && tok.typ != tokenString {
0000000000000000000000000000000000000000;;			return p.parseError(tok, "expected key or string for filter funciton name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name := tok.val
0000000000000000000000000000000000000000;;		tok = p.getToken()
0000000000000000000000000000000000000000;;		if tok.typ != tokenRightParen {
0000000000000000000000000000000000000000;;			return p.parseError(tok, "expected right-parenthesis for filter expression")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.union = append(p.union, newMatchFilterFn(name, tok.Position))
0000000000000000000000000000000000000000;;		return p.parseUnionExpr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseQuery(flow chan token) (*Query, error) {
0000000000000000000000000000000000000000;;		parser := &queryParser{
0000000000000000000000000000000000000000;;			flow:         flow,
0000000000000000000000000000000000000000;;			tokensBuffer: []token{},
0000000000000000000000000000000000000000;;			query:        newQuery(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		parser.run()
0000000000000000000000000000000000000000;;		return parser.query, parser.err
0000000000000000000000000000000000000000;;	}
