0000000000000000000000000000000000000000;;	package toml
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// Tools to convert a TomlTree to different representations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// encodes a string to a TOML-compliant string value
0000000000000000000000000000000000000000;;	func encodeTomlString(value string) string {
0000000000000000000000000000000000000000;;		result := ""
0000000000000000000000000000000000000000;;		for _, rr := range value {
0000000000000000000000000000000000000000;;			intRr := uint16(rr)
0000000000000000000000000000000000000000;;			switch rr {
0000000000000000000000000000000000000000;;			case '\b':
0000000000000000000000000000000000000000;;				result += "\\b"
0000000000000000000000000000000000000000;;			case '\t':
0000000000000000000000000000000000000000;;				result += "\\t"
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				result += "\\n"
0000000000000000000000000000000000000000;;			case '\f':
0000000000000000000000000000000000000000;;				result += "\\f"
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				result += "\\r"
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				result += "\\\""
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				result += "\\\\"
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if intRr < 0x001F {
0000000000000000000000000000000000000000;;					result += fmt.Sprintf("\\u%0.4X", intRr)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					result += string(rr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value print support function for ToString()
0000000000000000000000000000000000000000;;	// Outputs the TOML compliant string representation of a value
0000000000000000000000000000000000000000;;	func toTomlValue(item interface{}, indent int) string {
0000000000000000000000000000000000000000;;		tab := strings.Repeat(" ", indent)
0000000000000000000000000000000000000000;;		switch value := item.(type) {
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			return tab + strconv.FormatInt(value, 10)
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			return tab + strconv.FormatFloat(value, 'f', -1, 64)
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			return tab + "\"" + encodeTomlString(value) + "\""
0000000000000000000000000000000000000000;;		case bool:
0000000000000000000000000000000000000000;;			if value {
0000000000000000000000000000000000000000;;				return "true"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "false"
0000000000000000000000000000000000000000;;		case time.Time:
0000000000000000000000000000000000000000;;			return tab + value.Format(time.RFC3339)
0000000000000000000000000000000000000000;;		case []interface{}:
0000000000000000000000000000000000000000;;			result := tab + "[\n"
0000000000000000000000000000000000000000;;			for _, item := range value {
0000000000000000000000000000000000000000;;				result += toTomlValue(item, indent+2) + ",\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result + tab + "]"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unsupported value type: %v", value))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recursive support function for ToString()
0000000000000000000000000000000000000000;;	// Outputs a tree, using the provided keyspace to prefix group names
0000000000000000000000000000000000000000;;	func (t *TomlTree) toToml(indent, keyspace string) string {
0000000000000000000000000000000000000000;;		result := ""
0000000000000000000000000000000000000000;;		for k, v := range t.values {
0000000000000000000000000000000000000000;;			// figure out the keyspace
0000000000000000000000000000000000000000;;			combinedKey := k
0000000000000000000000000000000000000000;;			if keyspace != "" {
0000000000000000000000000000000000000000;;				combinedKey = keyspace + "." + combinedKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// output based on type
0000000000000000000000000000000000000000;;			switch node := v.(type) {
0000000000000000000000000000000000000000;;			case []*TomlTree:
0000000000000000000000000000000000000000;;				for _, item := range node {
0000000000000000000000000000000000000000;;					if len(item.Keys()) > 0 {
0000000000000000000000000000000000000000;;						result += fmt.Sprintf("\n%s[[%s]]\n", indent, combinedKey)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					result += item.toToml(indent+"  ", combinedKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *TomlTree:
0000000000000000000000000000000000000000;;				if len(node.Keys()) > 0 {
0000000000000000000000000000000000000000;;					result += fmt.Sprintf("\n%s[%s]\n", indent, combinedKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result += node.toToml(indent+"  ", combinedKey)
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				sub := TreeFromMap(node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if len(sub.Keys()) > 0 {
0000000000000000000000000000000000000000;;					result += fmt.Sprintf("\n%s[%s]\n", indent, combinedKey)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result += sub.toToml(indent+"  ", combinedKey)
0000000000000000000000000000000000000000;;			case *tomlValue:
0000000000000000000000000000000000000000;;				result += fmt.Sprintf("%s%s = %s\n", indent, k, toTomlValue(node.value, 0))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				result += fmt.Sprintf("%s%s = %s\n", indent, k, toTomlValue(v, 0))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToString is an alias for String
0000000000000000000000000000000000000000;;	func (t *TomlTree) ToString() string {
0000000000000000000000000000000000000000;;		return t.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String generates a human-readable representation of the current tree.
0000000000000000000000000000000000000000;;	// Output spans multiple lines, and is suitable for ingest by a TOML parser
0000000000000000000000000000000000000000;;	func (t *TomlTree) String() string {
0000000000000000000000000000000000000000;;		return t.toToml("", "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToMap recursively generates a representation of the current tree using map[string]interface{}.
0000000000000000000000000000000000000000;;	func (t *TomlTree) ToMap() map[string]interface{} {
0000000000000000000000000000000000000000;;		result := map[string]interface{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, v := range t.values {
0000000000000000000000000000000000000000;;			switch node := v.(type) {
0000000000000000000000000000000000000000;;			case []*TomlTree:
0000000000000000000000000000000000000000;;				var array []interface{}
0000000000000000000000000000000000000000;;				for _, item := range node {
0000000000000000000000000000000000000000;;					array = append(array, item.ToMap())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				result[k] = array
0000000000000000000000000000000000000000;;			case *TomlTree:
0000000000000000000000000000000000000000;;				result[k] = node.ToMap()
0000000000000000000000000000000000000000;;			case map[string]interface{}:
0000000000000000000000000000000000000000;;				sub := TreeFromMap(node)
0000000000000000000000000000000000000000;;				result[k] = sub.ToMap()
0000000000000000000000000000000000000000;;			case *tomlValue:
0000000000000000000000000000000000000000;;				result[k] = node.value
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
