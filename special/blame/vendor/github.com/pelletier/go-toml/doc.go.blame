0000000000000000000000000000000000000000;;	// Package toml is a TOML markup language parser.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This version supports the specification as described in
0000000000000000000000000000000000000000;;	// https://github.com/toml-lang/toml/blob/master/versions/en/toml-v0.4.0.md
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TOML Parsing
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TOML data may be parsed in two ways: by file, or by string.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // load TOML data by filename
0000000000000000000000000000000000000000;;	//   tree, err := toml.LoadFile("filename.toml")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // load TOML data stored in a string
0000000000000000000000000000000000000000;;	//   tree, err := toml.Load(stringContainingTomlData)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Either way, the result is a TomlTree object that can be used to navigate the
0000000000000000000000000000000000000000;;	// structure and data within the original document.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Getting data from the TomlTree
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// After parsing TOML data with Load() or LoadFile(), use the Has() and Get()
0000000000000000000000000000000000000000;;	// methods on the returned TomlTree, to find your way through the document data.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   if tree.Has('foo') {
0000000000000000000000000000000000000000;;	//     fmt.Prinln("foo is: %v", tree.Get('foo'))
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Working with Paths
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Go-toml has support for basic dot-separated key paths on the Has(), Get(), Set()
0000000000000000000000000000000000000000;;	// and GetDefault() methods.  These are the same kind of key paths used within the
0000000000000000000000000000000000000000;;	// TOML specification for struct tames.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // looks for a key named 'baz', within struct 'bar', within struct 'foo'
0000000000000000000000000000000000000000;;	//   tree.Has("foo.bar.baz")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // returns the key at this path, if it is there
0000000000000000000000000000000000000000;;	//   tree.Get("foo.bar.baz")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// TOML allows keys to contain '.', which can cause this syntax to be problematic
0000000000000000000000000000000000000000;;	// for some documents.  In such cases, use the GetPath(), HasPath(), and SetPath(),
0000000000000000000000000000000000000000;;	// methods to explicitly define the path.  This form is also faster, since
0000000000000000000000000000000000000000;;	// it avoids having to parse the passed key for '.' delimiters.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // looks for a key named 'baz', within struct 'bar', within struct 'foo'
0000000000000000000000000000000000000000;;	//   tree.HasPath(string{}{"foo","bar","baz"})
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // returns the key at this path, if it is there
0000000000000000000000000000000000000000;;	//   tree.GetPath(string{}{"foo","bar","baz"})
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that this is distinct from the heavyweight query syntax supported by
0000000000000000000000000000000000000000;;	// TomlTree.Query() and the Query() struct (see below).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Position Support
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each element within the TomlTree is stored with position metadata, which is
0000000000000000000000000000000000000000;;	// invaluable for providing semantic feedback to a user.  This helps in
0000000000000000000000000000000000000000;;	// situations where the TOML file parses correctly, but contains data that is
0000000000000000000000000000000000000000;;	// not correct for the application.  In such cases, an error message can be
0000000000000000000000000000000000000000;;	// generated that indicates the problem line and column number in the source
0000000000000000000000000000000000000000;;	// TOML document.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // load TOML data
0000000000000000000000000000000000000000;;	//   tree, _ := toml.Load("filename.toml")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // get an entry and report an error if it's the wrong type
0000000000000000000000000000000000000000;;	//   element := tree.Get("foo")
0000000000000000000000000000000000000000;;	//   if value, ok := element.(int64); !ok {
0000000000000000000000000000000000000000;;	//       return fmt.Errorf("%v: Element 'foo' must be an integer", tree.GetPosition("foo"))
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // report an error if an expected element is missing
0000000000000000000000000000000000000000;;	//   if !tree.Has("bar") {
0000000000000000000000000000000000000000;;	//      return fmt.Errorf("%v: Expected 'bar' element", tree.GetPosition(""))
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Query Support
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The TOML query path implementation is based loosely on the JSONPath specification:
0000000000000000000000000000000000000000;;	// http://goessner.net/articles/JsonPath/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The idea behind a query path is to allow quick access to any element, or set
0000000000000000000000000000000000000000;;	// of elements within TOML document, with a single expression.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   result, err := tree.Query("$.foo.bar.baz")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is roughly equivalent to:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   next := tree.Get("foo")
0000000000000000000000000000000000000000;;	//   if next != nil {
0000000000000000000000000000000000000000;;	//     next = next.Get("bar")
0000000000000000000000000000000000000000;;	//     if next != nil {
0000000000000000000000000000000000000000;;	//       next = next.Get("baz")
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//   result := next
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// err is nil if any parsing exception occurs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If no node in the tree matches the query, result will simply contain an empty list of
0000000000000000000000000000000000000000;;	// items.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// As illustrated above, the query path is much more efficient, especially since
0000000000000000000000000000000000000000;;	// the structure of the TOML file can vary.  Rather than making assumptions about
0000000000000000000000000000000000000000;;	// a document's structure, a query allows the programmer to make structured
0000000000000000000000000000000000000000;;	// requests into the document, and get zero or more values as a result.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The syntax of a query begins with a root token, followed by any number
0000000000000000000000000000000000000000;;	// sub-expressions:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   $
0000000000000000000000000000000000000000;;	//                    Root of the TOML tree.  This must always come first.
0000000000000000000000000000000000000000;;	//   .name
0000000000000000000000000000000000000000;;	//                    Selects child of this node, where 'name' is a TOML key
0000000000000000000000000000000000000000;;	//                    name.
0000000000000000000000000000000000000000;;	//   ['name']
0000000000000000000000000000000000000000;;	//                    Selects child of this node, where 'name' is a string
0000000000000000000000000000000000000000;;	//                    containing a TOML key name.
0000000000000000000000000000000000000000;;	//   [index]
0000000000000000000000000000000000000000;;	//                    Selcts child array element at 'index'.
0000000000000000000000000000000000000000;;	//   ..expr
0000000000000000000000000000000000000000;;	//                    Recursively selects all children, filtered by an a union,
0000000000000000000000000000000000000000;;	//                    index, or slice expression.
0000000000000000000000000000000000000000;;	//   ..*
0000000000000000000000000000000000000000;;	//                    Recursive selection of all nodes at this point in the
0000000000000000000000000000000000000000;;	//                    tree.
0000000000000000000000000000000000000000;;	//   .*
0000000000000000000000000000000000000000;;	//                    Selects all children of the current node.
0000000000000000000000000000000000000000;;	//   [expr,expr]
0000000000000000000000000000000000000000;;	//                    Union operator - a logical 'or' grouping of two or more
0000000000000000000000000000000000000000;;	//                    sub-expressions: index, key name, or filter.
0000000000000000000000000000000000000000;;	//   [start:end:step]
0000000000000000000000000000000000000000;;	//                    Slice operator - selects array elements from start to
0000000000000000000000000000000000000000;;	//                    end-1, at the given step.  All three arguments are
0000000000000000000000000000000000000000;;	//                    optional.
0000000000000000000000000000000000000000;;	//   [?(filter)]
0000000000000000000000000000000000000000;;	//                    Named filter expression - the function 'filter' is
0000000000000000000000000000000000000000;;	//                    used to filter children at this node.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Query Indexes And Slices
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Index expressions perform no bounds checking, and will contribute no
0000000000000000000000000000000000000000;;	// values to the result set if the provided index or index range is invalid.
0000000000000000000000000000000000000000;;	// Negative indexes represent values from the end of the array, counting backwards.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // select the last index of the array named 'foo'
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[-1]")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Slice expressions are supported, by using ':' to separate a start/end index pair.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // select up to the first five elements in the array
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[0:5]")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Slice expressions also allow negative indexes for the start and stop
0000000000000000000000000000000000000000;;	// arguments.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // select all array elements.
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[0:-1]")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Slice expressions may have an optional stride/step parameter:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // select every other element
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[0:-1:2]")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Slice start and end parameters are also optional:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // these are all equivalent and select all the values in the array
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[:]")
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[0:]")
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[:-1]")
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[0:-1:]")
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[::1]")
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[0::1]")
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[:-1:1]")
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[0:-1:1]")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Query Filters
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Query filters are used within a Union [,] or single Filter [] expression.
0000000000000000000000000000000000000000;;	// A filter only allows nodes that qualify through to the next expression,
0000000000000000000000000000000000000000;;	// and/or into the result set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // returns children of foo that are permitted by the 'bar' filter.
0000000000000000000000000000000000000000;;	//   tree.Query("$.foo[?(bar)]")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There are several filters provided with the library:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   tree
0000000000000000000000000000000000000000;;	//          Allows nodes of type TomlTree.
0000000000000000000000000000000000000000;;	//   int
0000000000000000000000000000000000000000;;	//          Allows nodes of type int64.
0000000000000000000000000000000000000000;;	//   float
0000000000000000000000000000000000000000;;	//          Allows nodes of type float64.
0000000000000000000000000000000000000000;;	//   string
0000000000000000000000000000000000000000;;	//          Allows nodes of type string.
0000000000000000000000000000000000000000;;	//   time
0000000000000000000000000000000000000000;;	//          Allows nodes of type time.Time.
0000000000000000000000000000000000000000;;	//   bool
0000000000000000000000000000000000000000;;	//          Allows nodes of type bool.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Query Results
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// An executed query returns a QueryResult object.  This contains the nodes
0000000000000000000000000000000000000000;;	// in the TOML tree that qualify the query expression.  Position information
0000000000000000000000000000000000000000;;	// is also available for each value in the set.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // display the results of a query
0000000000000000000000000000000000000000;;	//   results := tree.Query("$.foo.bar.baz")
0000000000000000000000000000000000000000;;	//   for idx, value := results.Values() {
0000000000000000000000000000000000000000;;	//       fmt.Println("%v: %v", results.Positions()[idx], value)
0000000000000000000000000000000000000000;;	//   }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Compiled Queries
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Queries may be executed directly on a TomlTree object, or compiled ahead
0000000000000000000000000000000000000000;;	// of time and executed discretely.  The former is more convienent, but has the
0000000000000000000000000000000000000000;;	// penalty of having to recompile the query expression each time.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // basic query
0000000000000000000000000000000000000000;;	//   results := tree.Query("$.foo.bar.baz")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // compiled query
0000000000000000000000000000000000000000;;	//   query := toml.CompileQuery("$.foo.bar.baz")
0000000000000000000000000000000000000000;;	//   results := query.Execute(tree)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // run the compiled query again on a different tree
0000000000000000000000000000000000000000;;	//   moreResults := query.Execute(anotherTree)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// User Defined Query Filters
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Filter expressions may also be user defined by using the SetFilter()
0000000000000000000000000000000000000000;;	// function on the Query object.  The function must return true/false, which
0000000000000000000000000000000000000000;;	// signifies if the passed node is kept or discarded, respectively.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // create a query that references a user-defined filter
0000000000000000000000000000000000000000;;	//   query, _ := CompileQuery("$[?(bazOnly)]")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // define the filter, and assign it to the query
0000000000000000000000000000000000000000;;	//   query.SetFilter("bazOnly", func(node interface{}) bool{
0000000000000000000000000000000000000000;;	//       if tree, ok := node.(*TomlTree); ok {
0000000000000000000000000000000000000000;;	//           return tree.Has("baz")
0000000000000000000000000000000000000000;;	//       }
0000000000000000000000000000000000000000;;	//       return false  // reject all other node types
0000000000000000000000000000000000000000;;	//   })
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   // run the query
0000000000000000000000000000000000000000;;	//   query.Execute(tree)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	package toml
