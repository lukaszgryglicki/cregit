0000000000000000000000000000000000000000;;	package token
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hcltoken "github.com/hashicorp/hcl/hcl/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token defines a single HCL token which can be obtained via the Scanner
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		Type Type
0000000000000000000000000000000000000000;;		Pos  Pos
0000000000000000000000000000000000000000;;		Text string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type is the set of lexical tokens of the HCL (HashiCorp Configuration Language)
0000000000000000000000000000000000000000;;	type Type int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Special tokens
0000000000000000000000000000000000000000;;		ILLEGAL Type = iota
0000000000000000000000000000000000000000;;		EOF
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		identifier_beg
0000000000000000000000000000000000000000;;		literal_beg
0000000000000000000000000000000000000000;;		NUMBER // 12345
0000000000000000000000000000000000000000;;		FLOAT  // 123.45
0000000000000000000000000000000000000000;;		BOOL   // true,false
0000000000000000000000000000000000000000;;		STRING // "abc"
0000000000000000000000000000000000000000;;		NULL   // null
0000000000000000000000000000000000000000;;		literal_end
0000000000000000000000000000000000000000;;		identifier_end
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operator_beg
0000000000000000000000000000000000000000;;		LBRACK // [
0000000000000000000000000000000000000000;;		LBRACE // {
0000000000000000000000000000000000000000;;		COMMA  // ,
0000000000000000000000000000000000000000;;		PERIOD // .
0000000000000000000000000000000000000000;;		COLON  // :
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RBRACK // ]
0000000000000000000000000000000000000000;;		RBRACE // }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operator_end
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var tokens = [...]string{
0000000000000000000000000000000000000000;;		ILLEGAL: "ILLEGAL",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EOF: "EOF",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		NUMBER: "NUMBER",
0000000000000000000000000000000000000000;;		FLOAT:  "FLOAT",
0000000000000000000000000000000000000000;;		BOOL:   "BOOL",
0000000000000000000000000000000000000000;;		STRING: "STRING",
0000000000000000000000000000000000000000;;		NULL:   "NULL",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LBRACK: "LBRACK",
0000000000000000000000000000000000000000;;		LBRACE: "LBRACE",
0000000000000000000000000000000000000000;;		COMMA:  "COMMA",
0000000000000000000000000000000000000000;;		PERIOD: "PERIOD",
0000000000000000000000000000000000000000;;		COLON:  "COLON",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RBRACK: "RBRACK",
0000000000000000000000000000000000000000;;		RBRACE: "RBRACE",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string corresponding to the token tok.
0000000000000000000000000000000000000000;;	func (t Type) String() string {
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		if 0 <= t && t < Type(len(tokens)) {
0000000000000000000000000000000000000000;;			s = tokens[t]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = "token(" + strconv.Itoa(int(t)) + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsIdentifier returns true for tokens corresponding to identifiers and basic
0000000000000000000000000000000000000000;;	// type literals; it returns false otherwise.
0000000000000000000000000000000000000000;;	func (t Type) IsIdentifier() bool { return identifier_beg < t && t < identifier_end }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLiteral returns true for tokens corresponding to basic type literals; it
0000000000000000000000000000000000000000;;	// returns false otherwise.
0000000000000000000000000000000000000000;;	func (t Type) IsLiteral() bool { return literal_beg < t && t < literal_end }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsOperator returns true for tokens corresponding to operators and
0000000000000000000000000000000000000000;;	// delimiters; it returns false otherwise.
0000000000000000000000000000000000000000;;	func (t Type) IsOperator() bool { return operator_beg < t && t < operator_end }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the token's literal text. Note that this is only
0000000000000000000000000000000000000000;;	// applicable for certain token types, such as token.IDENT,
0000000000000000000000000000000000000000;;	// token.STRING, etc..
0000000000000000000000000000000000000000;;	func (t Token) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s %s %s", t.Pos.String(), t.Type.String(), t.Text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HCLToken converts this token to an HCL token.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The token type must be a literal type or this will panic.
0000000000000000000000000000000000000000;;	func (t Token) HCLToken() hcltoken.Token {
0000000000000000000000000000000000000000;;		switch t.Type {
0000000000000000000000000000000000000000;;		case BOOL:
0000000000000000000000000000000000000000;;			return hcltoken.Token{Type: hcltoken.BOOL, Text: t.Text}
0000000000000000000000000000000000000000;;		case FLOAT:
0000000000000000000000000000000000000000;;			return hcltoken.Token{Type: hcltoken.FLOAT, Text: t.Text}
0000000000000000000000000000000000000000;;		case NULL:
0000000000000000000000000000000000000000;;			return hcltoken.Token{Type: hcltoken.STRING, Text: ""}
0000000000000000000000000000000000000000;;		case NUMBER:
0000000000000000000000000000000000000000;;			return hcltoken.Token{Type: hcltoken.NUMBER, Text: t.Text}
0000000000000000000000000000000000000000;;		case STRING:
0000000000000000000000000000000000000000;;			return hcltoken.Token{Type: hcltoken.STRING, Text: t.Text, JSON: true}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unimplemented HCLToken for type: %s", t.Type))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
