0000000000000000000000000000000000000000;;	package parser
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/ast"
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/json/scanner"
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/json/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parser struct {
0000000000000000000000000000000000000000;;		sc *scanner.Scanner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Last read token
0000000000000000000000000000000000000000;;		tok       token.Token
0000000000000000000000000000000000000000;;		commaPrev token.Token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enableTrace bool
0000000000000000000000000000000000000000;;		indent      int
0000000000000000000000000000000000000000;;		n           int // buffer size (max = 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newParser(src []byte) *Parser {
0000000000000000000000000000000000000000;;		return &Parser{
0000000000000000000000000000000000000000;;			sc: scanner.New(src),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse returns the fully parsed source and returns the abstract syntax tree.
0000000000000000000000000000000000000000;;	func Parse(src []byte) (*ast.File, error) {
0000000000000000000000000000000000000000;;		p := newParser(src)
0000000000000000000000000000000000000000;;		return p.Parse()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errEofToken = errors.New("EOF token found")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse returns the fully parsed source and returns the abstract syntax tree.
0000000000000000000000000000000000000000;;	func (p *Parser) Parse() (*ast.File, error) {
0000000000000000000000000000000000000000;;		f := &ast.File{}
0000000000000000000000000000000000000000;;		var err, scerr error
0000000000000000000000000000000000000000;;		p.sc.Error = func(pos token.Pos, msg string) {
0000000000000000000000000000000000000000;;			scerr = fmt.Errorf("%s: %s", pos, msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The root must be an object in JSON
0000000000000000000000000000000000000000;;		object, err := p.object()
0000000000000000000000000000000000000000;;		if scerr != nil {
0000000000000000000000000000000000000000;;			return nil, scerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We make our final node an object list so it is more HCL compatible
0000000000000000000000000000000000000000;;		f.Node = object.List
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flatten it, which finds patterns and turns them into more HCL-like
0000000000000000000000000000000000000000;;		// AST trees.
0000000000000000000000000000000000000000;;		flattenObjects(f.Node)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) objectList() (*ast.ObjectList, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseObjectList"))
0000000000000000000000000000000000000000;;		node := &ast.ObjectList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, err := p.objectItem()
0000000000000000000000000000000000000000;;			if err == errEofToken {
0000000000000000000000000000000000000000;;				break // we are finished
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we don't return a nil node, because might want to use already
0000000000000000000000000000000000000000;;			// collected items.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return node, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			node.Add(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Check for a followup comma. If it isn't a comma, then we're done
0000000000000000000000000000000000000000;;			if tok := p.scan(); tok.Type != token.COMMA {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return node, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectItem parses a single object item
0000000000000000000000000000000000000000;;	func (p *Parser) objectItem() (*ast.ObjectItem, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseObjectItem"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys, err := p.objectKey()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o := &ast.ObjectItem{
0000000000000000000000000000000000000000;;			Keys: keys,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case token.COLON:
0000000000000000000000000000000000000000;;			o.Val, err = p.objectValue()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectKey parses an object key and returns a ObjectKey AST
0000000000000000000000000000000000000000;;	func (p *Parser) objectKey() ([]*ast.ObjectKey, error) {
0000000000000000000000000000000000000000;;		keyCount := 0
0000000000000000000000000000000000000000;;		keys := make([]*ast.ObjectKey, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok := p.scan()
0000000000000000000000000000000000000000;;			switch tok.Type {
0000000000000000000000000000000000000000;;			case token.EOF:
0000000000000000000000000000000000000000;;				return nil, errEofToken
0000000000000000000000000000000000000000;;			case token.STRING:
0000000000000000000000000000000000000000;;				keyCount++
0000000000000000000000000000000000000000;;				keys = append(keys, &ast.ObjectKey{
0000000000000000000000000000000000000000;;					Token: p.tok.HCLToken(),
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;			case token.COLON:
0000000000000000000000000000000000000000;;				// If we have a zero keycount it means that we never got
0000000000000000000000000000000000000000;;				// an object key, i.e. `{ :`. This is a syntax error.
0000000000000000000000000000000000000000;;				if keyCount == 0 {
0000000000000000000000000000000000000000;;					return nil, fmt.Errorf("expected: STRING got: %s", p.tok.Type)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Done
0000000000000000000000000000000000000000;;				return keys, nil
0000000000000000000000000000000000000000;;			case token.ILLEGAL:
0000000000000000000000000000000000000000;;				fmt.Println("illegal")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("expected: STRING got: %s", p.tok.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// object parses any type of object, such as number, bool, string, object or
0000000000000000000000000000000000000000;;	// list.
0000000000000000000000000000000000000000;;	func (p *Parser) objectValue() (ast.Node, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseObjectValue"))
0000000000000000000000000000000000000000;;		tok := p.scan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tok.Type {
0000000000000000000000000000000000000000;;		case token.NUMBER, token.FLOAT, token.BOOL, token.NULL, token.STRING:
0000000000000000000000000000000000000000;;			return p.literalType()
0000000000000000000000000000000000000000;;		case token.LBRACE:
0000000000000000000000000000000000000000;;			return p.objectType()
0000000000000000000000000000000000000000;;		case token.LBRACK:
0000000000000000000000000000000000000000;;			return p.listType()
0000000000000000000000000000000000000000;;		case token.EOF:
0000000000000000000000000000000000000000;;			return nil, errEofToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Expected object value, got unknown token: %+v", tok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// object parses any type of object, such as number, bool, string, object or
0000000000000000000000000000000000000000;;	// list.
0000000000000000000000000000000000000000;;	func (p *Parser) object() (*ast.ObjectType, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseType"))
0000000000000000000000000000000000000000;;		tok := p.scan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tok.Type {
0000000000000000000000000000000000000000;;		case token.LBRACE:
0000000000000000000000000000000000000000;;			return p.objectType()
0000000000000000000000000000000000000000;;		case token.EOF:
0000000000000000000000000000000000000000;;			return nil, errEofToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Expected object, got unknown token: %+v", tok)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectType parses an object type and returns a ObjectType AST
0000000000000000000000000000000000000000;;	func (p *Parser) objectType() (*ast.ObjectType, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseObjectType"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we assume that the currently scanned token is a LBRACE
0000000000000000000000000000000000000000;;		o := &ast.ObjectType{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, err := p.objectList()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we hit RBRACE, we are good to go (means we parsed all Items), if it's
0000000000000000000000000000000000000000;;		// not a RBRACE, it's an syntax error and we just return it.
0000000000000000000000000000000000000000;;		if err != nil && p.tok.Type != token.RBRACE {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.List = l
0000000000000000000000000000000000000000;;		return o, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listType parses a list type and returns a ListType AST
0000000000000000000000000000000000000000;;	func (p *Parser) listType() (*ast.ListType, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseListType"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we assume that the currently scanned token is a LBRACK
0000000000000000000000000000000000000000;;		l := &ast.ListType{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok := p.scan()
0000000000000000000000000000000000000000;;			switch tok.Type {
0000000000000000000000000000000000000000;;			case token.NUMBER, token.FLOAT, token.STRING:
0000000000000000000000000000000000000000;;				node, err := p.literalType()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				l.Add(node)
0000000000000000000000000000000000000000;;			case token.COMMA:
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case token.LBRACE:
0000000000000000000000000000000000000000;;				node, err := p.objectType()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				l.Add(node)
0000000000000000000000000000000000000000;;			case token.BOOL:
0000000000000000000000000000000000000000;;				// TODO(arslan) should we support? not supported by HCL yet
0000000000000000000000000000000000000000;;			case token.LBRACK:
0000000000000000000000000000000000000000;;				// TODO(arslan) should we support nested lists? Even though it's
0000000000000000000000000000000000000000;;				// written in README of HCL, it's not a part of the grammar
0000000000000000000000000000000000000000;;				// (not defined in parse.y)
0000000000000000000000000000000000000000;;			case token.RBRACK:
0000000000000000000000000000000000000000;;				// finished
0000000000000000000000000000000000000000;;				return l, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("unexpected token while parsing list: %s", tok.Type)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// literalType parses a literal type and returns a LiteralType AST
0000000000000000000000000000000000000000;;	func (p *Parser) literalType() (*ast.LiteralType, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseLiteral"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ast.LiteralType{
0000000000000000000000000000000000000000;;			Token: p.tok.HCLToken(),
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scan returns the next token from the underlying scanner. If a token has
0000000000000000000000000000000000000000;;	// been unscanned then read that instead.
0000000000000000000000000000000000000000;;	func (p *Parser) scan() token.Token {
0000000000000000000000000000000000000000;;		// If we have a token on the buffer, then return it.
0000000000000000000000000000000000000000;;		if p.n != 0 {
0000000000000000000000000000000000000000;;			p.n = 0
0000000000000000000000000000000000000000;;			return p.tok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.tok = p.sc.Scan()
0000000000000000000000000000000000000000;;		return p.tok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unscan pushes the previously read token back onto the buffer.
0000000000000000000000000000000000000000;;	func (p *Parser) unscan() {
0000000000000000000000000000000000000000;;		p.n = 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Parsing support
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) printTrace(a ...interface{}) {
0000000000000000000000000000000000000000;;		if !p.enableTrace {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const dots = ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
0000000000000000000000000000000000000000;;		const n = len(dots)
0000000000000000000000000000000000000000;;		fmt.Printf("%5d:%3d: ", p.tok.Pos.Line, p.tok.Pos.Column)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 2 * p.indent
0000000000000000000000000000000000000000;;		for i > n {
0000000000000000000000000000000000000000;;			fmt.Print(dots)
0000000000000000000000000000000000000000;;			i -= n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// i <= n
0000000000000000000000000000000000000000;;		fmt.Print(dots[0:i])
0000000000000000000000000000000000000000;;		fmt.Println(a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trace(p *Parser, msg string) *Parser {
0000000000000000000000000000000000000000;;		p.printTrace(msg, "(")
0000000000000000000000000000000000000000;;		p.indent++
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usage pattern: defer un(trace(p, "..."))
0000000000000000000000000000000000000000;;	func un(p *Parser) {
0000000000000000000000000000000000000000;;		p.indent--
0000000000000000000000000000000000000000;;		p.printTrace(")")
0000000000000000000000000000000000000000;;	}
