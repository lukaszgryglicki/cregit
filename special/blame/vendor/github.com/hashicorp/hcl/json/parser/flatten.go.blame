0000000000000000000000000000000000000000;;	package parser
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import "github.com/hashicorp/hcl/hcl/ast"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flattenObjects takes an AST node, walks it, and flattens
0000000000000000000000000000000000000000;;	func flattenObjects(node ast.Node) {
0000000000000000000000000000000000000000;;		ast.Walk(node, func(n ast.Node) (ast.Node, bool) {
0000000000000000000000000000000000000000;;			// We only care about lists, because this is what we modify
0000000000000000000000000000000000000000;;			list, ok := n.(*ast.ObjectList)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return n, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Rebuild the item list
0000000000000000000000000000000000000000;;			items := make([]*ast.ObjectItem, 0, len(list.Items))
0000000000000000000000000000000000000000;;			frontier := make([]*ast.ObjectItem, len(list.Items))
0000000000000000000000000000000000000000;;			copy(frontier, list.Items)
0000000000000000000000000000000000000000;;			for len(frontier) > 0 {
0000000000000000000000000000000000000000;;				// Pop the current item
0000000000000000000000000000000000000000;;				n := len(frontier)
0000000000000000000000000000000000000000;;				item := frontier[n-1]
0000000000000000000000000000000000000000;;				frontier = frontier[:n-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				switch v := item.Val.(type) {
0000000000000000000000000000000000000000;;				case *ast.ObjectType:
0000000000000000000000000000000000000000;;					items, frontier = flattenObjectType(v, item, items, frontier)
0000000000000000000000000000000000000000;;				case *ast.ListType:
0000000000000000000000000000000000000000;;					items, frontier = flattenListType(v, item, items, frontier)
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					items = append(items, item)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Reverse the list since the frontier model runs things backwards
0000000000000000000000000000000000000000;;			for i := len(items)/2 - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;				opp := len(items) - 1 - i
0000000000000000000000000000000000000000;;				items[i], items[opp] = items[opp], items[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Done! Set the original items
0000000000000000000000000000000000000000;;			list.Items = items
0000000000000000000000000000000000000000;;			return n, true
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flattenListType(
0000000000000000000000000000000000000000;;		ot *ast.ListType,
0000000000000000000000000000000000000000;;		item *ast.ObjectItem,
0000000000000000000000000000000000000000;;		items []*ast.ObjectItem,
0000000000000000000000000000000000000000;;		frontier []*ast.ObjectItem) ([]*ast.ObjectItem, []*ast.ObjectItem) {
0000000000000000000000000000000000000000;;		// All the elements of this object must also be objects!
0000000000000000000000000000000000000000;;		for _, subitem := range ot.List {
0000000000000000000000000000000000000000;;			if _, ok := subitem.(*ast.ObjectType); !ok {
0000000000000000000000000000000000000000;;				items = append(items, item)
0000000000000000000000000000000000000000;;				return items, frontier
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Great! We have a match go through all the items and flatten
0000000000000000000000000000000000000000;;		for _, elem := range ot.List {
0000000000000000000000000000000000000000;;			// Add it to the frontier so that we can recurse
0000000000000000000000000000000000000000;;			frontier = append(frontier, &ast.ObjectItem{
0000000000000000000000000000000000000000;;				Keys:        item.Keys,
0000000000000000000000000000000000000000;;				Assign:      item.Assign,
0000000000000000000000000000000000000000;;				Val:         elem,
0000000000000000000000000000000000000000;;				LeadComment: item.LeadComment,
0000000000000000000000000000000000000000;;				LineComment: item.LineComment,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return items, frontier
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flattenObjectType(
0000000000000000000000000000000000000000;;		ot *ast.ObjectType,
0000000000000000000000000000000000000000;;		item *ast.ObjectItem,
0000000000000000000000000000000000000000;;		items []*ast.ObjectItem,
0000000000000000000000000000000000000000;;		frontier []*ast.ObjectItem) ([]*ast.ObjectItem, []*ast.ObjectItem) {
0000000000000000000000000000000000000000;;		// If the list has no items we do not have to flatten anything
0000000000000000000000000000000000000000;;		if ot.List.Items == nil {
0000000000000000000000000000000000000000;;			items = append(items, item)
0000000000000000000000000000000000000000;;			return items, frontier
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// All the elements of this object must also be objects!
0000000000000000000000000000000000000000;;		for _, subitem := range ot.List.Items {
0000000000000000000000000000000000000000;;			if _, ok := subitem.Val.(*ast.ObjectType); !ok {
0000000000000000000000000000000000000000;;				items = append(items, item)
0000000000000000000000000000000000000000;;				return items, frontier
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Great! We have a match go through all the items and flatten
0000000000000000000000000000000000000000;;		for _, subitem := range ot.List.Items {
0000000000000000000000000000000000000000;;			// Copy the new key
0000000000000000000000000000000000000000;;			keys := make([]*ast.ObjectKey, len(item.Keys)+len(subitem.Keys))
0000000000000000000000000000000000000000;;			copy(keys, item.Keys)
0000000000000000000000000000000000000000;;			copy(keys[len(item.Keys):], subitem.Keys)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add it to the frontier so that we can recurse
0000000000000000000000000000000000000000;;			frontier = append(frontier, &ast.ObjectItem{
0000000000000000000000000000000000000000;;				Keys:        keys,
0000000000000000000000000000000000000000;;				Assign:      item.Assign,
0000000000000000000000000000000000000000;;				Val:         subitem.Val,
0000000000000000000000000000000000000000;;				LeadComment: item.LeadComment,
0000000000000000000000000000000000000000;;				LineComment: item.LineComment,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return items, frontier
0000000000000000000000000000000000000000;;	}
