0000000000000000000000000000000000000000;;	// Package scanner implements a scanner for HCL (HashiCorp Configuration
0000000000000000000000000000000000000000;;	// Language) source text.
0000000000000000000000000000000000000000;;	package scanner
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// eof represents a marker rune for the end of the reader.
0000000000000000000000000000000000000000;;	const eof = rune(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scanner defines a lexical scanner
0000000000000000000000000000000000000000;;	type Scanner struct {
0000000000000000000000000000000000000000;;		buf *bytes.Buffer // Source buffer for advancing and scanning
0000000000000000000000000000000000000000;;		src []byte        // Source buffer for immutable access
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Source Position
0000000000000000000000000000000000000000;;		srcPos  token.Pos // current position
0000000000000000000000000000000000000000;;		prevPos token.Pos // previous position, used for peek() method
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lastCharLen int // length of last character in bytes
0000000000000000000000000000000000000000;;		lastLineLen int // length of last line in characters (for correct column reporting)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tokStart int // token text start position
0000000000000000000000000000000000000000;;		tokEnd   int // token text end  position
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Error is called for each error encountered. If no Error
0000000000000000000000000000000000000000;;		// function is set, the error is reported to os.Stderr.
0000000000000000000000000000000000000000;;		Error func(pos token.Pos, msg string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ErrorCount is incremented by one for each error encountered.
0000000000000000000000000000000000000000;;		ErrorCount int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// tokPos is the start position of most recently scanned token; set by
0000000000000000000000000000000000000000;;		// Scan. The Filename field is always left untouched by the Scanner.  If
0000000000000000000000000000000000000000;;		// an error is reported (via Error) and Position is invalid, the scanner is
0000000000000000000000000000000000000000;;		// not inside a token.
0000000000000000000000000000000000000000;;		tokPos token.Pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates and initializes a new instance of Scanner using src as
0000000000000000000000000000000000000000;;	// its source content.
0000000000000000000000000000000000000000;;	func New(src []byte) *Scanner {
0000000000000000000000000000000000000000;;		// even though we accept a src, we read from a io.Reader compatible type
0000000000000000000000000000000000000000;;		// (*bytes.Buffer). So in the future we might easily change it to streaming
0000000000000000000000000000000000000000;;		// read.
0000000000000000000000000000000000000000;;		b := bytes.NewBuffer(src)
0000000000000000000000000000000000000000;;		s := &Scanner{
0000000000000000000000000000000000000000;;			buf: b,
0000000000000000000000000000000000000000;;			src: src,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// srcPosition always starts with 1
0000000000000000000000000000000000000000;;		s.srcPos.Line = 1
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// next reads the next rune from the bufferred reader. Returns the rune(0) if
0000000000000000000000000000000000000000;;	// an error occurs (or io.EOF is returned).
0000000000000000000000000000000000000000;;	func (s *Scanner) next() rune {
0000000000000000000000000000000000000000;;		ch, size, err := s.buf.ReadRune()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// advance for error reporting
0000000000000000000000000000000000000000;;			s.srcPos.Column++
0000000000000000000000000000000000000000;;			s.srcPos.Offset += size
0000000000000000000000000000000000000000;;			s.lastCharLen = size
0000000000000000000000000000000000000000;;			return eof
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ch == utf8.RuneError && size == 1 {
0000000000000000000000000000000000000000;;			s.srcPos.Column++
0000000000000000000000000000000000000000;;			s.srcPos.Offset += size
0000000000000000000000000000000000000000;;			s.lastCharLen = size
0000000000000000000000000000000000000000;;			s.err("illegal UTF-8 encoding")
0000000000000000000000000000000000000000;;			return ch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remember last position
0000000000000000000000000000000000000000;;		s.prevPos = s.srcPos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.srcPos.Column++
0000000000000000000000000000000000000000;;		s.lastCharLen = size
0000000000000000000000000000000000000000;;		s.srcPos.Offset += size
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ch == '\n' {
0000000000000000000000000000000000000000;;			s.srcPos.Line++
0000000000000000000000000000000000000000;;			s.lastLineLen = s.srcPos.Column
0000000000000000000000000000000000000000;;			s.srcPos.Column = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// debug
0000000000000000000000000000000000000000;;		// fmt.Printf("ch: %q, offset:column: %d:%d\n", ch, s.srcPos.Offset, s.srcPos.Column)
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unread unreads the previous read Rune and updates the source position
0000000000000000000000000000000000000000;;	func (s *Scanner) unread() {
0000000000000000000000000000000000000000;;		if err := s.buf.UnreadRune(); err != nil {
0000000000000000000000000000000000000000;;			panic(err) // this is user fault, we should catch it
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.srcPos = s.prevPos // put back last position
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// peek returns the next rune without advancing the reader.
0000000000000000000000000000000000000000;;	func (s *Scanner) peek() rune {
0000000000000000000000000000000000000000;;		peek, _, err := s.buf.ReadRune()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return eof
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.buf.UnreadRune()
0000000000000000000000000000000000000000;;		return peek
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan scans the next token and returns the token.
0000000000000000000000000000000000000000;;	func (s *Scanner) Scan() token.Token {
0000000000000000000000000000000000000000;;		ch := s.next()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip white space
0000000000000000000000000000000000000000;;		for isWhitespace(ch) {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var tok token.Type
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// token text markings
0000000000000000000000000000000000000000;;		s.tokStart = s.srcPos.Offset - s.lastCharLen
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// token position, initial next() is moving the offset by one(size of rune
0000000000000000000000000000000000000000;;		// actually), though we are interested with the starting point
0000000000000000000000000000000000000000;;		s.tokPos.Offset = s.srcPos.Offset - s.lastCharLen
0000000000000000000000000000000000000000;;		if s.srcPos.Column > 0 {
0000000000000000000000000000000000000000;;			// common case: last character was not a '\n'
0000000000000000000000000000000000000000;;			s.tokPos.Line = s.srcPos.Line
0000000000000000000000000000000000000000;;			s.tokPos.Column = s.srcPos.Column
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// last character was a '\n'
0000000000000000000000000000000000000000;;			// (we cannot be at the beginning of the source
0000000000000000000000000000000000000000;;			// since we have called next() at least once)
0000000000000000000000000000000000000000;;			s.tokPos.Line = s.srcPos.Line - 1
0000000000000000000000000000000000000000;;			s.tokPos.Column = s.lastLineLen
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case isLetter(ch):
0000000000000000000000000000000000000000;;			tok = token.IDENT
0000000000000000000000000000000000000000;;			lit := s.scanIdentifier()
0000000000000000000000000000000000000000;;			if lit == "true" || lit == "false" {
0000000000000000000000000000000000000000;;				tok = token.BOOL
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case isDecimal(ch):
0000000000000000000000000000000000000000;;			tok = s.scanNumber(ch)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			switch ch {
0000000000000000000000000000000000000000;;			case eof:
0000000000000000000000000000000000000000;;				tok = token.EOF
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				tok = token.STRING
0000000000000000000000000000000000000000;;				s.scanString()
0000000000000000000000000000000000000000;;			case '#', '/':
0000000000000000000000000000000000000000;;				tok = token.COMMENT
0000000000000000000000000000000000000000;;				s.scanComment(ch)
0000000000000000000000000000000000000000;;			case '.':
0000000000000000000000000000000000000000;;				tok = token.PERIOD
0000000000000000000000000000000000000000;;				ch = s.peek()
0000000000000000000000000000000000000000;;				if isDecimal(ch) {
0000000000000000000000000000000000000000;;					tok = token.FLOAT
0000000000000000000000000000000000000000;;					ch = s.scanMantissa(ch)
0000000000000000000000000000000000000000;;					ch = s.scanExponent(ch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '<':
0000000000000000000000000000000000000000;;				tok = token.HEREDOC
0000000000000000000000000000000000000000;;				s.scanHeredoc()
0000000000000000000000000000000000000000;;			case '[':
0000000000000000000000000000000000000000;;				tok = token.LBRACK
0000000000000000000000000000000000000000;;			case ']':
0000000000000000000000000000000000000000;;				tok = token.RBRACK
0000000000000000000000000000000000000000;;			case '{':
0000000000000000000000000000000000000000;;				tok = token.LBRACE
0000000000000000000000000000000000000000;;			case '}':
0000000000000000000000000000000000000000;;				tok = token.RBRACE
0000000000000000000000000000000000000000;;			case ',':
0000000000000000000000000000000000000000;;				tok = token.COMMA
0000000000000000000000000000000000000000;;			case '=':
0000000000000000000000000000000000000000;;				tok = token.ASSIGN
0000000000000000000000000000000000000000;;			case '+':
0000000000000000000000000000000000000000;;				tok = token.ADD
0000000000000000000000000000000000000000;;			case '-':
0000000000000000000000000000000000000000;;				if isDecimal(s.peek()) {
0000000000000000000000000000000000000000;;					ch := s.next()
0000000000000000000000000000000000000000;;					tok = s.scanNumber(ch)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					tok = token.SUB
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				s.err("illegal char")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// finish token ending
0000000000000000000000000000000000000000;;		s.tokEnd = s.srcPos.Offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// create token literal
0000000000000000000000000000000000000000;;		var tokenText string
0000000000000000000000000000000000000000;;		if s.tokStart >= 0 {
0000000000000000000000000000000000000000;;			tokenText = string(s.src[s.tokStart:s.tokEnd])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.tokStart = s.tokEnd // ensure idempotency of tokenText() call
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return token.Token{
0000000000000000000000000000000000000000;;			Type: tok,
0000000000000000000000000000000000000000;;			Pos:  s.tokPos,
0000000000000000000000000000000000000000;;			Text: tokenText,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Scanner) scanComment(ch rune) {
0000000000000000000000000000000000000000;;		// single line comments
0000000000000000000000000000000000000000;;		if ch == '#' || (ch == '/' && s.peek() != '*') {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;			for ch != '\n' && ch >= 0 && ch != eof {
0000000000000000000000000000000000000000;;				ch = s.next()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ch != eof && ch >= 0 {
0000000000000000000000000000000000000000;;				s.unread()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// be sure we get the character after /* This allows us to find comment's
0000000000000000000000000000000000000000;;		// that are not erminated
0000000000000000000000000000000000000000;;		if ch == '/' {
0000000000000000000000000000000000000000;;			s.next()
0000000000000000000000000000000000000000;;			ch = s.next() // read character after "/*"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// look for /* - style comments
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if ch < 0 || ch == eof {
0000000000000000000000000000000000000000;;				s.err("comment not terminated")
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ch0 := ch
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;			if ch0 == '*' && ch == '/' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanNumber scans a HCL number definition starting with the given rune
0000000000000000000000000000000000000000;;	func (s *Scanner) scanNumber(ch rune) token.Type {
0000000000000000000000000000000000000000;;		if ch == '0' {
0000000000000000000000000000000000000000;;			// check for hexadecimal, octal or float
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;			if ch == 'x' || ch == 'X' {
0000000000000000000000000000000000000000;;				// hexadecimal
0000000000000000000000000000000000000000;;				ch = s.next()
0000000000000000000000000000000000000000;;				found := false
0000000000000000000000000000000000000000;;				for isHexadecimal(ch) {
0000000000000000000000000000000000000000;;					ch = s.next()
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !found {
0000000000000000000000000000000000000000;;					s.err("illegal hexadecimal number")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ch != eof {
0000000000000000000000000000000000000000;;					s.unread()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return token.NUMBER
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// now it's either something like: 0421(octal) or 0.1231(float)
0000000000000000000000000000000000000000;;			illegalOctal := false
0000000000000000000000000000000000000000;;			for isDecimal(ch) {
0000000000000000000000000000000000000000;;				ch = s.next()
0000000000000000000000000000000000000000;;				if ch == '8' || ch == '9' {
0000000000000000000000000000000000000000;;					// this is just a possibility. For example 0159 is illegal, but
0000000000000000000000000000000000000000;;					// 0159.23 is valid. So we mark a possible illegal octal. If
0000000000000000000000000000000000000000;;					// the next character is not a period, we'll print the error.
0000000000000000000000000000000000000000;;					illegalOctal = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ch == 'e' || ch == 'E' {
0000000000000000000000000000000000000000;;				ch = s.scanExponent(ch)
0000000000000000000000000000000000000000;;				return token.FLOAT
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ch == '.' {
0000000000000000000000000000000000000000;;				ch = s.scanFraction(ch)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ch == 'e' || ch == 'E' {
0000000000000000000000000000000000000000;;					ch = s.next()
0000000000000000000000000000000000000000;;					ch = s.scanExponent(ch)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return token.FLOAT
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if illegalOctal {
0000000000000000000000000000000000000000;;				s.err("illegal octal number")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ch != eof {
0000000000000000000000000000000000000000;;				s.unread()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return token.NUMBER
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s.scanMantissa(ch)
0000000000000000000000000000000000000000;;		ch = s.next() // seek forward
0000000000000000000000000000000000000000;;		if ch == 'e' || ch == 'E' {
0000000000000000000000000000000000000000;;			ch = s.scanExponent(ch)
0000000000000000000000000000000000000000;;			return token.FLOAT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ch == '.' {
0000000000000000000000000000000000000000;;			ch = s.scanFraction(ch)
0000000000000000000000000000000000000000;;			if ch == 'e' || ch == 'E' {
0000000000000000000000000000000000000000;;				ch = s.next()
0000000000000000000000000000000000000000;;				ch = s.scanExponent(ch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return token.FLOAT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ch != eof {
0000000000000000000000000000000000000000;;			s.unread()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return token.NUMBER
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanMantissa scans the mantissa begining from the rune. It returns the next
0000000000000000000000000000000000000000;;	// non decimal rune. It's used to determine wheter it's a fraction or exponent.
0000000000000000000000000000000000000000;;	func (s *Scanner) scanMantissa(ch rune) rune {
0000000000000000000000000000000000000000;;		scanned := false
0000000000000000000000000000000000000000;;		for isDecimal(ch) {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;			scanned = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if scanned && ch != eof {
0000000000000000000000000000000000000000;;			s.unread()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanFraction scans the fraction after the '.' rune
0000000000000000000000000000000000000000;;	func (s *Scanner) scanFraction(ch rune) rune {
0000000000000000000000000000000000000000;;		if ch == '.' {
0000000000000000000000000000000000000000;;			ch = s.peek() // we peek just to see if we can move forward
0000000000000000000000000000000000000000;;			ch = s.scanMantissa(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanExponent scans the remaining parts of an exponent after the 'e' or 'E'
0000000000000000000000000000000000000000;;	// rune.
0000000000000000000000000000000000000000;;	func (s *Scanner) scanExponent(ch rune) rune {
0000000000000000000000000000000000000000;;		if ch == 'e' || ch == 'E' {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;			if ch == '-' || ch == '+' {
0000000000000000000000000000000000000000;;				ch = s.next()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ch = s.scanMantissa(ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanHeredoc scans a heredoc string
0000000000000000000000000000000000000000;;	func (s *Scanner) scanHeredoc() {
0000000000000000000000000000000000000000;;		// Scan the second '<' in example: '<<EOF'
0000000000000000000000000000000000000000;;		if s.next() != '<' {
0000000000000000000000000000000000000000;;			s.err("heredoc expected second '<', didn't see it")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Get the original offset so we can read just the heredoc ident
0000000000000000000000000000000000000000;;		offs := s.srcPos.Offset
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Scan the identifier
0000000000000000000000000000000000000000;;		ch := s.next()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Indented heredoc syntax
0000000000000000000000000000000000000000;;		if ch == '-' {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for isLetter(ch) || isDigit(ch) {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we reached an EOF then that is not good
0000000000000000000000000000000000000000;;		if ch == eof {
0000000000000000000000000000000000000000;;			s.err("heredoc not terminated")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ignore the '\r' in Windows line endings
0000000000000000000000000000000000000000;;		if ch == '\r' {
0000000000000000000000000000000000000000;;			if s.peek() == '\n' {
0000000000000000000000000000000000000000;;				ch = s.next()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we didn't reach a newline then that is also not good
0000000000000000000000000000000000000000;;		if ch != '\n' {
0000000000000000000000000000000000000000;;			s.err("invalid characters in heredoc anchor")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read the identifier
0000000000000000000000000000000000000000;;		identBytes := s.src[offs : s.srcPos.Offset-s.lastCharLen]
0000000000000000000000000000000000000000;;		if len(identBytes) == 0 {
0000000000000000000000000000000000000000;;			s.err("zero-length heredoc anchor")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var identRegexp *regexp.Regexp
0000000000000000000000000000000000000000;;		if identBytes[0] == '-' {
0000000000000000000000000000000000000000;;			identRegexp = regexp.MustCompile(fmt.Sprintf(`[[:space:]]*%s\z`, identBytes[1:]))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			identRegexp = regexp.MustCompile(fmt.Sprintf(`[[:space:]]*%s\z`, identBytes))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Read the actual string value
0000000000000000000000000000000000000000;;		lineStart := s.srcPos.Offset
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			ch := s.next()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Special newline handling.
0000000000000000000000000000000000000000;;			if ch == '\n' {
0000000000000000000000000000000000000000;;				// Math is fast, so we first compare the byte counts to see if we have a chance
0000000000000000000000000000000000000000;;				// of seeing the same identifier - if the length is less than the number of bytes
0000000000000000000000000000000000000000;;				// in the identifier, this cannot be a valid terminator.
0000000000000000000000000000000000000000;;				lineBytesLen := s.srcPos.Offset - s.lastCharLen - lineStart
0000000000000000000000000000000000000000;;				if lineBytesLen >= len(identBytes) && identRegexp.Match(s.src[lineStart:s.srcPos.Offset-s.lastCharLen]) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Not an anchor match, record the start of a new line
0000000000000000000000000000000000000000;;				lineStart = s.srcPos.Offset
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ch == eof {
0000000000000000000000000000000000000000;;				s.err("heredoc not terminated")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanString scans a quoted string
0000000000000000000000000000000000000000;;	func (s *Scanner) scanString() {
0000000000000000000000000000000000000000;;		braces := 0
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// '"' opening already consumed
0000000000000000000000000000000000000000;;			// read character after quote
0000000000000000000000000000000000000000;;			ch := s.next()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ch < 0 || ch == eof {
0000000000000000000000000000000000000000;;				s.err("literal not terminated")
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ch == '"' && braces == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we're going into a ${} then we can ignore quotes for awhile
0000000000000000000000000000000000000000;;			if braces == 0 && ch == '$' && s.peek() == '{' {
0000000000000000000000000000000000000000;;				braces++
0000000000000000000000000000000000000000;;				s.next()
0000000000000000000000000000000000000000;;			} else if braces > 0 && ch == '{' {
0000000000000000000000000000000000000000;;				braces++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if braces > 0 && ch == '}' {
0000000000000000000000000000000000000000;;				braces--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ch == '\\' {
0000000000000000000000000000000000000000;;				s.scanEscape()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanEscape scans an escape sequence
0000000000000000000000000000000000000000;;	func (s *Scanner) scanEscape() rune {
0000000000000000000000000000000000000000;;		// http://en.cppreference.com/w/cpp/language/escape
0000000000000000000000000000000000000000;;		ch := s.next() // read character after '/'
0000000000000000000000000000000000000000;;		switch ch {
0000000000000000000000000000000000000000;;		case 'a', 'b', 'f', 'n', 'r', 't', 'v', '\\', '"':
0000000000000000000000000000000000000000;;			// nothing to do
0000000000000000000000000000000000000000;;		case '0', '1', '2', '3', '4', '5', '6', '7':
0000000000000000000000000000000000000000;;			// octal notation
0000000000000000000000000000000000000000;;			ch = s.scanDigits(ch, 8, 3)
0000000000000000000000000000000000000000;;		case 'x':
0000000000000000000000000000000000000000;;			// hexademical notation
0000000000000000000000000000000000000000;;			ch = s.scanDigits(s.next(), 16, 2)
0000000000000000000000000000000000000000;;		case 'u':
0000000000000000000000000000000000000000;;			// universal character name
0000000000000000000000000000000000000000;;			ch = s.scanDigits(s.next(), 16, 4)
0000000000000000000000000000000000000000;;		case 'U':
0000000000000000000000000000000000000000;;			// universal character name
0000000000000000000000000000000000000000;;			ch = s.scanDigits(s.next(), 16, 8)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			s.err("illegal char escape")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanDigits scans a rune with the given base for n times. For example an
0000000000000000000000000000000000000000;;	// octal notation \184 would yield in scanDigits(ch, 8, 3)
0000000000000000000000000000000000000000;;	func (s *Scanner) scanDigits(ch rune, base, n int) rune {
0000000000000000000000000000000000000000;;		start := n
0000000000000000000000000000000000000000;;		for n > 0 && digitVal(ch) < base {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;			if ch == eof {
0000000000000000000000000000000000000000;;				// If we see an EOF, we halt any more scanning of digits
0000000000000000000000000000000000000000;;				// immediately.
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n > 0 {
0000000000000000000000000000000000000000;;			s.err("illegal char escape")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n != start {
0000000000000000000000000000000000000000;;			// we scanned all digits, put the last non digit char back,
0000000000000000000000000000000000000000;;			// only if we read anything at all
0000000000000000000000000000000000000000;;			s.unread()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ch
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scanIdentifier scans an identifier and returns the literal string
0000000000000000000000000000000000000000;;	func (s *Scanner) scanIdentifier() string {
0000000000000000000000000000000000000000;;		offs := s.srcPos.Offset - s.lastCharLen
0000000000000000000000000000000000000000;;		ch := s.next()
0000000000000000000000000000000000000000;;		for isLetter(ch) || isDigit(ch) || ch == '-' || ch == '.' {
0000000000000000000000000000000000000000;;			ch = s.next()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ch != eof {
0000000000000000000000000000000000000000;;			s.unread() // we got identifier, put back latest char
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(s.src[offs:s.srcPos.Offset])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recentPosition returns the position of the character immediately after the
0000000000000000000000000000000000000000;;	// character or token returned by the last call to Scan.
0000000000000000000000000000000000000000;;	func (s *Scanner) recentPosition() (pos token.Pos) {
0000000000000000000000000000000000000000;;		pos.Offset = s.srcPos.Offset - s.lastCharLen
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case s.srcPos.Column > 0:
0000000000000000000000000000000000000000;;			// common case: last character was not a '\n'
0000000000000000000000000000000000000000;;			pos.Line = s.srcPos.Line
0000000000000000000000000000000000000000;;			pos.Column = s.srcPos.Column
0000000000000000000000000000000000000000;;		case s.lastLineLen > 0:
0000000000000000000000000000000000000000;;			// last character was a '\n'
0000000000000000000000000000000000000000;;			// (we cannot be at the beginning of the source
0000000000000000000000000000000000000000;;			// since we have called next() at least once)
0000000000000000000000000000000000000000;;			pos.Line = s.srcPos.Line - 1
0000000000000000000000000000000000000000;;			pos.Column = s.lastLineLen
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// at the beginning of the source
0000000000000000000000000000000000000000;;			pos.Line = 1
0000000000000000000000000000000000000000;;			pos.Column = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// err prints the error of any scanning to s.Error function. If the function is
0000000000000000000000000000000000000000;;	// not defined, by default it prints them to os.Stderr
0000000000000000000000000000000000000000;;	func (s *Scanner) err(msg string) {
0000000000000000000000000000000000000000;;		s.ErrorCount++
0000000000000000000000000000000000000000;;		pos := s.recentPosition()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Error != nil {
0000000000000000000000000000000000000000;;			s.Error(pos, msg)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fmt.Fprintf(os.Stderr, "%s: %s\n", pos, msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isHexadecimal returns true if the given rune is a letter
0000000000000000000000000000000000000000;;	func isLetter(ch rune) bool {
0000000000000000000000000000000000000000;;		return 'a' <= ch && ch <= 'z' || 'A' <= ch && ch <= 'Z' || ch == '_' || ch >= 0x80 && unicode.IsLetter(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isDigit returns true if the given rune is a decimal digit
0000000000000000000000000000000000000000;;	func isDigit(ch rune) bool {
0000000000000000000000000000000000000000;;		return '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isDecimal returns true if the given rune is a decimal number
0000000000000000000000000000000000000000;;	func isDecimal(ch rune) bool {
0000000000000000000000000000000000000000;;		return '0' <= ch && ch <= '9'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isHexadecimal returns true if the given rune is an hexadecimal number
0000000000000000000000000000000000000000;;	func isHexadecimal(ch rune) bool {
0000000000000000000000000000000000000000;;		return '0' <= ch && ch <= '9' || 'a' <= ch && ch <= 'f' || 'A' <= ch && ch <= 'F'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isWhitespace returns true if the rune is a space, tab, newline or carriage return
0000000000000000000000000000000000000000;;	func isWhitespace(ch rune) bool {
0000000000000000000000000000000000000000;;		return ch == ' ' || ch == '\t' || ch == '\n' || ch == '\r'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// digitVal returns the integer value of a given octal,decimal or hexadecimal rune
0000000000000000000000000000000000000000;;	func digitVal(ch rune) int {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case '0' <= ch && ch <= '9':
0000000000000000000000000000000000000000;;			return int(ch - '0')
0000000000000000000000000000000000000000;;		case 'a' <= ch && ch <= 'f':
0000000000000000000000000000000000000000;;			return int(ch - 'a' + 10)
0000000000000000000000000000000000000000;;		case 'A' <= ch && ch <= 'F':
0000000000000000000000000000000000000000;;			return int(ch - 'A' + 10)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 16 // larger than any legal digit val
0000000000000000000000000000000000000000;;	}
