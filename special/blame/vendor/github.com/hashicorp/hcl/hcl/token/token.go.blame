0000000000000000000000000000000000000000;;	// Package token defines constants representing the lexical tokens for HCL
0000000000000000000000000000000000000000;;	// (HashiCorp Configuration Language)
0000000000000000000000000000000000000000;;	package token
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hclstrconv "github.com/hashicorp/hcl/hcl/strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token defines a single HCL token which can be obtained via the Scanner
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		Type Type
0000000000000000000000000000000000000000;;		Pos  Pos
0000000000000000000000000000000000000000;;		Text string
0000000000000000000000000000000000000000;;		JSON bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Type is the set of lexical tokens of the HCL (HashiCorp Configuration Language)
0000000000000000000000000000000000000000;;	type Type int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Special tokens
0000000000000000000000000000000000000000;;		ILLEGAL Type = iota
0000000000000000000000000000000000000000;;		EOF
0000000000000000000000000000000000000000;;		COMMENT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		identifier_beg
0000000000000000000000000000000000000000;;		IDENT // literals
0000000000000000000000000000000000000000;;		literal_beg
0000000000000000000000000000000000000000;;		NUMBER  // 12345
0000000000000000000000000000000000000000;;		FLOAT   // 123.45
0000000000000000000000000000000000000000;;		BOOL    // true,false
0000000000000000000000000000000000000000;;		STRING  // "abc"
0000000000000000000000000000000000000000;;		HEREDOC // <<FOO\nbar\nFOO
0000000000000000000000000000000000000000;;		literal_end
0000000000000000000000000000000000000000;;		identifier_end
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		operator_beg
0000000000000000000000000000000000000000;;		LBRACK // [
0000000000000000000000000000000000000000;;		LBRACE // {
0000000000000000000000000000000000000000;;		COMMA  // ,
0000000000000000000000000000000000000000;;		PERIOD // .
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RBRACK // ]
0000000000000000000000000000000000000000;;		RBRACE // }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ASSIGN // =
0000000000000000000000000000000000000000;;		ADD    // +
0000000000000000000000000000000000000000;;		SUB    // -
0000000000000000000000000000000000000000;;		operator_end
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var tokens = [...]string{
0000000000000000000000000000000000000000;;		ILLEGAL: "ILLEGAL",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		EOF:     "EOF",
0000000000000000000000000000000000000000;;		COMMENT: "COMMENT",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		IDENT:  "IDENT",
0000000000000000000000000000000000000000;;		NUMBER: "NUMBER",
0000000000000000000000000000000000000000;;		FLOAT:  "FLOAT",
0000000000000000000000000000000000000000;;		BOOL:   "BOOL",
0000000000000000000000000000000000000000;;		STRING: "STRING",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LBRACK:  "LBRACK",
0000000000000000000000000000000000000000;;		LBRACE:  "LBRACE",
0000000000000000000000000000000000000000;;		COMMA:   "COMMA",
0000000000000000000000000000000000000000;;		PERIOD:  "PERIOD",
0000000000000000000000000000000000000000;;		HEREDOC: "HEREDOC",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RBRACK: "RBRACK",
0000000000000000000000000000000000000000;;		RBRACE: "RBRACE",
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ASSIGN: "ASSIGN",
0000000000000000000000000000000000000000;;		ADD:    "ADD",
0000000000000000000000000000000000000000;;		SUB:    "SUB",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string corresponding to the token tok.
0000000000000000000000000000000000000000;;	func (t Type) String() string {
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		if 0 <= t && t < Type(len(tokens)) {
0000000000000000000000000000000000000000;;			s = tokens[t]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			s = "token(" + strconv.Itoa(int(t)) + ")"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsIdentifier returns true for tokens corresponding to identifiers and basic
0000000000000000000000000000000000000000;;	// type literals; it returns false otherwise.
0000000000000000000000000000000000000000;;	func (t Type) IsIdentifier() bool { return identifier_beg < t && t < identifier_end }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsLiteral returns true for tokens corresponding to basic type literals; it
0000000000000000000000000000000000000000;;	// returns false otherwise.
0000000000000000000000000000000000000000;;	func (t Type) IsLiteral() bool { return literal_beg < t && t < literal_end }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsOperator returns true for tokens corresponding to operators and
0000000000000000000000000000000000000000;;	// delimiters; it returns false otherwise.
0000000000000000000000000000000000000000;;	func (t Type) IsOperator() bool { return operator_beg < t && t < operator_end }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the token's literal text. Note that this is only
0000000000000000000000000000000000000000;;	// applicable for certain token types, such as token.IDENT,
0000000000000000000000000000000000000000;;	// token.STRING, etc..
0000000000000000000000000000000000000000;;	func (t Token) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s %s %s", t.Pos.String(), t.Type.String(), t.Text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value returns the properly typed value for this token. The type of
0000000000000000000000000000000000000000;;	// the returned interface{} is guaranteed based on the Type field.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This can only be called for literal types. If it is called for any other
0000000000000000000000000000000000000000;;	// type, this will panic.
0000000000000000000000000000000000000000;;	func (t Token) Value() interface{} {
0000000000000000000000000000000000000000;;		switch t.Type {
0000000000000000000000000000000000000000;;		case BOOL:
0000000000000000000000000000000000000000;;			if t.Text == "true" {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			} else if t.Text == "false" {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			panic("unknown bool value: " + t.Text)
0000000000000000000000000000000000000000;;		case FLOAT:
0000000000000000000000000000000000000000;;			v, err := strconv.ParseFloat(t.Text, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return float64(v)
0000000000000000000000000000000000000000;;		case NUMBER:
0000000000000000000000000000000000000000;;			v, err := strconv.ParseInt(t.Text, 0, 64)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return int64(v)
0000000000000000000000000000000000000000;;		case IDENT:
0000000000000000000000000000000000000000;;			return t.Text
0000000000000000000000000000000000000000;;		case HEREDOC:
0000000000000000000000000000000000000000;;			return unindentHeredoc(t.Text)
0000000000000000000000000000000000000000;;		case STRING:
0000000000000000000000000000000000000000;;			// Determine the Unquote method to use. If it came from JSON,
0000000000000000000000000000000000000000;;			// then we need to use the built-in unquote since we have to
0000000000000000000000000000000000000000;;			// escape interpolations there.
0000000000000000000000000000000000000000;;			f := hclstrconv.Unquote
0000000000000000000000000000000000000000;;			if t.JSON {
0000000000000000000000000000000000000000;;				f = strconv.Unquote
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// This case occurs if json null is used
0000000000000000000000000000000000000000;;			if t.Text == "" {
0000000000000000000000000000000000000000;;				return ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			v, err := f(t.Text)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(fmt.Sprintf("unquote %s err: %s", t.Text, err))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("unimplemented Value for type: %s", t.Type))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unindentHeredoc returns the string content of a HEREDOC if it is started with <<
0000000000000000000000000000000000000000;;	// and the content of a HEREDOC with the hanging indent removed if it is started with
0000000000000000000000000000000000000000;;	// a <<-, and the terminating line is at least as indented as the least indented line.
0000000000000000000000000000000000000000;;	func unindentHeredoc(heredoc string) string {
0000000000000000000000000000000000000000;;		// We need to find the end of the marker
0000000000000000000000000000000000000000;;		idx := strings.IndexByte(heredoc, '\n')
0000000000000000000000000000000000000000;;		if idx == -1 {
0000000000000000000000000000000000000000;;			panic("heredoc doesn't contain newline")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unindent := heredoc[2] == '-'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We can optimize if the heredoc isn't marked for indentation
0000000000000000000000000000000000000000;;		if !unindent {
0000000000000000000000000000000000000000;;			return string(heredoc[idx+1 : len(heredoc)-idx+1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need to unindent each line based on the indentation level of the marker
0000000000000000000000000000000000000000;;		lines := strings.Split(string(heredoc[idx+1:len(heredoc)-idx+2]), "\n")
0000000000000000000000000000000000000000;;		whitespacePrefix := lines[len(lines)-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		isIndented := true
0000000000000000000000000000000000000000;;		for _, v := range lines {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(v, whitespacePrefix) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			isIndented = false
0000000000000000000000000000000000000000;;			break
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If all lines are not at least as indented as the terminating mark, return the
0000000000000000000000000000000000000000;;		// heredoc as is, but trim the leading space from the marker on the final line.
0000000000000000000000000000000000000000;;		if !isIndented {
0000000000000000000000000000000000000000;;			return strings.TrimRight(string(heredoc[idx+1:len(heredoc)-idx+1]), " \t")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unindentedLines := make([]string, len(lines))
0000000000000000000000000000000000000000;;		for k, v := range lines {
0000000000000000000000000000000000000000;;			if k == len(lines)-1 {
0000000000000000000000000000000000000000;;				unindentedLines[k] = ""
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			unindentedLines[k] = strings.TrimPrefix(v, whitespacePrefix)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return strings.Join(unindentedLines, "\n")
0000000000000000000000000000000000000000;;	}
