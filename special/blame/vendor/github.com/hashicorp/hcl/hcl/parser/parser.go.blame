0000000000000000000000000000000000000000;;	// Package parser implements a parser for HCL (HashiCorp Configuration
0000000000000000000000000000000000000000;;	// Language)
0000000000000000000000000000000000000000;;	package parser
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/ast"
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/scanner"
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Parser struct {
0000000000000000000000000000000000000000;;		sc *scanner.Scanner
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Last read token
0000000000000000000000000000000000000000;;		tok       token.Token
0000000000000000000000000000000000000000;;		commaPrev token.Token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		comments    []*ast.CommentGroup
0000000000000000000000000000000000000000;;		leadComment *ast.CommentGroup // last lead comment
0000000000000000000000000000000000000000;;		lineComment *ast.CommentGroup // last line comment
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		enableTrace bool
0000000000000000000000000000000000000000;;		indent      int
0000000000000000000000000000000000000000;;		n           int // buffer size (max = 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newParser(src []byte) *Parser {
0000000000000000000000000000000000000000;;		return &Parser{
0000000000000000000000000000000000000000;;			sc: scanner.New(src),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse returns the fully parsed source and returns the abstract syntax tree.
0000000000000000000000000000000000000000;;	func Parse(src []byte) (*ast.File, error) {
0000000000000000000000000000000000000000;;		p := newParser(src)
0000000000000000000000000000000000000000;;		return p.Parse()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var errEofToken = errors.New("EOF token found")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse returns the fully parsed source and returns the abstract syntax tree.
0000000000000000000000000000000000000000;;	func (p *Parser) Parse() (*ast.File, error) {
0000000000000000000000000000000000000000;;		f := &ast.File{}
0000000000000000000000000000000000000000;;		var err, scerr error
0000000000000000000000000000000000000000;;		p.sc.Error = func(pos token.Pos, msg string) {
0000000000000000000000000000000000000000;;			scerr = &PosError{Pos: pos, Err: errors.New(msg)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Node, err = p.objectList()
0000000000000000000000000000000000000000;;		if scerr != nil {
0000000000000000000000000000000000000000;;			return nil, scerr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f.Comments = p.comments
0000000000000000000000000000000000000000;;		return f, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) objectList() (*ast.ObjectList, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseObjectList"))
0000000000000000000000000000000000000000;;		node := &ast.ObjectList{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			n, err := p.objectItem()
0000000000000000000000000000000000000000;;			if err == errEofToken {
0000000000000000000000000000000000000000;;				break // we are finished
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// we don't return a nil node, because might want to use already
0000000000000000000000000000000000000000;;			// collected items.
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return node, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			node.Add(n)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// object lists can be optionally comma-delimited e.g. when a list of maps
0000000000000000000000000000000000000000;;			// is being expressed, so a comma is allowed here - it's simply consumed
0000000000000000000000000000000000000000;;			tok := p.scan()
0000000000000000000000000000000000000000;;			if tok.Type != token.COMMA {
0000000000000000000000000000000000000000;;				p.unscan()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return node, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) consumeComment() (comment *ast.Comment, endline int) {
0000000000000000000000000000000000000000;;		endline = p.tok.Pos.Line
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// count the endline if it's multiline comment, ie starting with /*
0000000000000000000000000000000000000000;;		if len(p.tok.Text) > 1 && p.tok.Text[1] == '*' {
0000000000000000000000000000000000000000;;			// don't use range here - no need to decode Unicode code points
0000000000000000000000000000000000000000;;			for i := 0; i < len(p.tok.Text); i++ {
0000000000000000000000000000000000000000;;				if p.tok.Text[i] == '\n' {
0000000000000000000000000000000000000000;;					endline++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		comment = &ast.Comment{Start: p.tok.Pos, Text: p.tok.Text}
0000000000000000000000000000000000000000;;		p.tok = p.sc.Scan()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) consumeCommentGroup(n int) (comments *ast.CommentGroup, endline int) {
0000000000000000000000000000000000000000;;		var list []*ast.Comment
0000000000000000000000000000000000000000;;		endline = p.tok.Pos.Line
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for p.tok.Type == token.COMMENT && p.tok.Pos.Line <= endline+n {
0000000000000000000000000000000000000000;;			var comment *ast.Comment
0000000000000000000000000000000000000000;;			comment, endline = p.consumeComment()
0000000000000000000000000000000000000000;;			list = append(list, comment)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// add comment group to the comments list
0000000000000000000000000000000000000000;;		comments = &ast.CommentGroup{List: list}
0000000000000000000000000000000000000000;;		p.comments = append(p.comments, comments)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectItem parses a single object item
0000000000000000000000000000000000000000;;	func (p *Parser) objectItem() (*ast.ObjectItem, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseObjectItem"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keys, err := p.objectKey()
0000000000000000000000000000000000000000;;		if len(keys) > 0 && err == errEofToken {
0000000000000000000000000000000000000000;;			// We ignore eof token here since it is an error if we didn't
0000000000000000000000000000000000000000;;			// receive a value (but we did receive a key) for the item.
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(keys) > 0 && err != nil && p.tok.Type == token.RBRACE {
0000000000000000000000000000000000000000;;			// This is a strange boolean statement, but what it means is:
0000000000000000000000000000000000000000;;			// We have keys with no value, and we're likely in an object
0000000000000000000000000000000000000000;;			// (since RBrace ends an object). For this, we set err to nil so
0000000000000000000000000000000000000000;;			// we continue and get the error below of having the wrong value
0000000000000000000000000000000000000000;;			// type.
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Reset the token type so we don't think it completed fine. See
0000000000000000000000000000000000000000;;			// objectType which uses p.tok.Type to check if we're done with
0000000000000000000000000000000000000000;;			// the object.
0000000000000000000000000000000000000000;;			p.tok.Type = token.EOF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o := &ast.ObjectItem{
0000000000000000000000000000000000000000;;			Keys: keys,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.leadComment != nil {
0000000000000000000000000000000000000000;;			o.LeadComment = p.leadComment
0000000000000000000000000000000000000000;;			p.leadComment = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch p.tok.Type {
0000000000000000000000000000000000000000;;		case token.ASSIGN:
0000000000000000000000000000000000000000;;			o.Assign = p.tok.Pos
0000000000000000000000000000000000000000;;			o.Val, err = p.object()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case token.LBRACE:
0000000000000000000000000000000000000000;;			o.Val, err = p.objectType()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			keyStr := make([]string, 0, len(keys))
0000000000000000000000000000000000000000;;			for _, k := range keys {
0000000000000000000000000000000000000000;;				keyStr = append(keyStr, k.Token.Text)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf(
0000000000000000000000000000000000000000;;				"key '%s' expected start of object ('{') or assignment ('=')",
0000000000000000000000000000000000000000;;				strings.Join(keyStr, " "))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// do a look-ahead for line comment
0000000000000000000000000000000000000000;;		p.scan()
0000000000000000000000000000000000000000;;		if len(keys) > 0 && o.Val.Pos().Line == keys[0].Pos().Line && p.lineComment != nil {
0000000000000000000000000000000000000000;;			o.LineComment = p.lineComment
0000000000000000000000000000000000000000;;			p.lineComment = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.unscan()
0000000000000000000000000000000000000000;;		return o, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectKey parses an object key and returns a ObjectKey AST
0000000000000000000000000000000000000000;;	func (p *Parser) objectKey() ([]*ast.ObjectKey, error) {
0000000000000000000000000000000000000000;;		keyCount := 0
0000000000000000000000000000000000000000;;		keys := make([]*ast.ObjectKey, 0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok := p.scan()
0000000000000000000000000000000000000000;;			switch tok.Type {
0000000000000000000000000000000000000000;;			case token.EOF:
0000000000000000000000000000000000000000;;				// It is very important to also return the keys here as well as
0000000000000000000000000000000000000000;;				// the error. This is because we need to be able to tell if we
0000000000000000000000000000000000000000;;				// did parse keys prior to finding the EOF, or if we just found
0000000000000000000000000000000000000000;;				// a bare EOF.
0000000000000000000000000000000000000000;;				return keys, errEofToken
0000000000000000000000000000000000000000;;			case token.ASSIGN:
0000000000000000000000000000000000000000;;				// assignment or object only, but not nested objects. this is not
0000000000000000000000000000000000000000;;				// allowed: `foo bar = {}`
0000000000000000000000000000000000000000;;				if keyCount > 1 {
0000000000000000000000000000000000000000;;					return nil, &PosError{
0000000000000000000000000000000000000000;;						Pos: p.tok.Pos,
0000000000000000000000000000000000000000;;						Err: fmt.Errorf("nested object expected: LBRACE got: %s", p.tok.Type),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if keyCount == 0 {
0000000000000000000000000000000000000000;;					return nil, &PosError{
0000000000000000000000000000000000000000;;						Pos: p.tok.Pos,
0000000000000000000000000000000000000000;;						Err: errors.New("no object keys found!"),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return keys, nil
0000000000000000000000000000000000000000;;			case token.LBRACE:
0000000000000000000000000000000000000000;;				var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// If we have no keys, then it is a syntax error. i.e. {{}} is not
0000000000000000000000000000000000000000;;				// allowed.
0000000000000000000000000000000000000000;;				if len(keys) == 0 {
0000000000000000000000000000000000000000;;					err = &PosError{
0000000000000000000000000000000000000000;;						Pos: p.tok.Pos,
0000000000000000000000000000000000000000;;						Err: fmt.Errorf("expected: IDENT | STRING got: %s", p.tok.Type),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// object
0000000000000000000000000000000000000000;;				return keys, err
0000000000000000000000000000000000000000;;			case token.IDENT, token.STRING:
0000000000000000000000000000000000000000;;				keyCount++
0000000000000000000000000000000000000000;;				keys = append(keys, &ast.ObjectKey{Token: p.tok})
0000000000000000000000000000000000000000;;			case token.ILLEGAL:
0000000000000000000000000000000000000000;;				fmt.Println("illegal")
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return keys, &PosError{
0000000000000000000000000000000000000000;;					Pos: p.tok.Pos,
0000000000000000000000000000000000000000;;					Err: fmt.Errorf("expected: IDENT | STRING | ASSIGN | LBRACE got: %s", p.tok.Type),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// object parses any type of object, such as number, bool, string, object or
0000000000000000000000000000000000000000;;	// list.
0000000000000000000000000000000000000000;;	func (p *Parser) object() (ast.Node, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseType"))
0000000000000000000000000000000000000000;;		tok := p.scan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch tok.Type {
0000000000000000000000000000000000000000;;		case token.NUMBER, token.FLOAT, token.BOOL, token.STRING, token.HEREDOC:
0000000000000000000000000000000000000000;;			return p.literalType()
0000000000000000000000000000000000000000;;		case token.LBRACE:
0000000000000000000000000000000000000000;;			return p.objectType()
0000000000000000000000000000000000000000;;		case token.LBRACK:
0000000000000000000000000000000000000000;;			return p.listType()
0000000000000000000000000000000000000000;;		case token.COMMENT:
0000000000000000000000000000000000000000;;			// implement comment
0000000000000000000000000000000000000000;;		case token.EOF:
0000000000000000000000000000000000000000;;			return nil, errEofToken
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, &PosError{
0000000000000000000000000000000000000000;;			Pos: tok.Pos,
0000000000000000000000000000000000000000;;			Err: fmt.Errorf("Unknown token: %+v", tok),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// objectType parses an object type and returns a ObjectType AST
0000000000000000000000000000000000000000;;	func (p *Parser) objectType() (*ast.ObjectType, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseObjectType"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we assume that the currently scanned token is a LBRACE
0000000000000000000000000000000000000000;;		o := &ast.ObjectType{
0000000000000000000000000000000000000000;;			Lbrace: p.tok.Pos,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l, err := p.objectList()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if we hit RBRACE, we are good to go (means we parsed all Items), if it's
0000000000000000000000000000000000000000;;		// not a RBRACE, it's an syntax error and we just return it.
0000000000000000000000000000000000000000;;		if err != nil && p.tok.Type != token.RBRACE {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If there is no error, we should be at a RBRACE to end the object
0000000000000000000000000000000000000000;;		if p.tok.Type != token.RBRACE {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("object expected closing RBRACE got: %s", p.tok.Type)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o.List = l
0000000000000000000000000000000000000000;;		o.Rbrace = p.tok.Pos // advanced via parseObjectList
0000000000000000000000000000000000000000;;		return o, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// listType parses a list type and returns a ListType AST
0000000000000000000000000000000000000000;;	func (p *Parser) listType() (*ast.ListType, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseListType"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we assume that the currently scanned token is a LBRACK
0000000000000000000000000000000000000000;;		l := &ast.ListType{
0000000000000000000000000000000000000000;;			Lbrack: p.tok.Pos,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		needComma := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			tok := p.scan()
0000000000000000000000000000000000000000;;			if needComma {
0000000000000000000000000000000000000000;;				switch tok.Type {
0000000000000000000000000000000000000000;;				case token.COMMA, token.RBRACK:
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, &PosError{
0000000000000000000000000000000000000000;;						Pos: tok.Pos,
0000000000000000000000000000000000000000;;						Err: fmt.Errorf(
0000000000000000000000000000000000000000;;							"error parsing list, expected comma or list end, got: %s",
0000000000000000000000000000000000000000;;							tok.Type),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch tok.Type {
0000000000000000000000000000000000000000;;			case token.NUMBER, token.FLOAT, token.STRING, token.HEREDOC:
0000000000000000000000000000000000000000;;				node, err := p.literalType()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				l.Add(node)
0000000000000000000000000000000000000000;;				needComma = true
0000000000000000000000000000000000000000;;			case token.COMMA:
0000000000000000000000000000000000000000;;				// get next list item or we are at the end
0000000000000000000000000000000000000000;;				// do a look-ahead for line comment
0000000000000000000000000000000000000000;;				p.scan()
0000000000000000000000000000000000000000;;				if p.lineComment != nil && len(l.List) > 0 {
0000000000000000000000000000000000000000;;					lit, ok := l.List[len(l.List)-1].(*ast.LiteralType)
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						lit.LineComment = p.lineComment
0000000000000000000000000000000000000000;;						l.List[len(l.List)-1] = lit
0000000000000000000000000000000000000000;;						p.lineComment = nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.unscan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				needComma = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			case token.LBRACE:
0000000000000000000000000000000000000000;;				// Looks like a nested object, so parse it out
0000000000000000000000000000000000000000;;				node, err := p.objectType()
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, &PosError{
0000000000000000000000000000000000000000;;						Pos: tok.Pos,
0000000000000000000000000000000000000000;;						Err: fmt.Errorf(
0000000000000000000000000000000000000000;;							"error while trying to parse object within list: %s", err),
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.Add(node)
0000000000000000000000000000000000000000;;				needComma = true
0000000000000000000000000000000000000000;;			case token.BOOL:
0000000000000000000000000000000000000000;;				// TODO(arslan) should we support? not supported by HCL yet
0000000000000000000000000000000000000000;;			case token.LBRACK:
0000000000000000000000000000000000000000;;				// TODO(arslan) should we support nested lists? Even though it's
0000000000000000000000000000000000000000;;				// written in README of HCL, it's not a part of the grammar
0000000000000000000000000000000000000000;;				// (not defined in parse.y)
0000000000000000000000000000000000000000;;			case token.RBRACK:
0000000000000000000000000000000000000000;;				// finished
0000000000000000000000000000000000000000;;				l.Rbrack = p.tok.Pos
0000000000000000000000000000000000000000;;				return l, nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, &PosError{
0000000000000000000000000000000000000000;;					Pos: tok.Pos,
0000000000000000000000000000000000000000;;					Err: fmt.Errorf("unexpected token while parsing list: %s", tok.Type),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// literalType parses a literal type and returns a LiteralType AST
0000000000000000000000000000000000000000;;	func (p *Parser) literalType() (*ast.LiteralType, error) {
0000000000000000000000000000000000000000;;		defer un(trace(p, "ParseLiteral"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ast.LiteralType{
0000000000000000000000000000000000000000;;			Token: p.tok,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// scan returns the next token from the underlying scanner. If a token has
0000000000000000000000000000000000000000;;	// been unscanned then read that instead. In the process, it collects any
0000000000000000000000000000000000000000;;	// comment groups encountered, and remembers the last lead and line comments.
0000000000000000000000000000000000000000;;	func (p *Parser) scan() token.Token {
0000000000000000000000000000000000000000;;		// If we have a token on the buffer, then return it.
0000000000000000000000000000000000000000;;		if p.n != 0 {
0000000000000000000000000000000000000000;;			p.n = 0
0000000000000000000000000000000000000000;;			return p.tok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Otherwise read the next token from the scanner and Save it to the buffer
0000000000000000000000000000000000000000;;		// in case we unscan later.
0000000000000000000000000000000000000000;;		prev := p.tok
0000000000000000000000000000000000000000;;		p.tok = p.sc.Scan()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.tok.Type == token.COMMENT {
0000000000000000000000000000000000000000;;			var comment *ast.CommentGroup
0000000000000000000000000000000000000000;;			var endline int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// fmt.Printf("p.tok.Pos.Line = %+v prev: %d endline %d \n",
0000000000000000000000000000000000000000;;			// p.tok.Pos.Line, prev.Pos.Line, endline)
0000000000000000000000000000000000000000;;			if p.tok.Pos.Line == prev.Pos.Line {
0000000000000000000000000000000000000000;;				// The comment is on same line as the previous token; it
0000000000000000000000000000000000000000;;				// cannot be a lead comment but may be a line comment.
0000000000000000000000000000000000000000;;				comment, endline = p.consumeCommentGroup(0)
0000000000000000000000000000000000000000;;				if p.tok.Pos.Line != endline {
0000000000000000000000000000000000000000;;					// The next token is on a different line, thus
0000000000000000000000000000000000000000;;					// the last comment group is a line comment.
0000000000000000000000000000000000000000;;					p.lineComment = comment
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// consume successor comments, if any
0000000000000000000000000000000000000000;;			endline = -1
0000000000000000000000000000000000000000;;			for p.tok.Type == token.COMMENT {
0000000000000000000000000000000000000000;;				comment, endline = p.consumeCommentGroup(1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if endline+1 == p.tok.Pos.Line && p.tok.Type != token.RBRACE {
0000000000000000000000000000000000000000;;				switch p.tok.Type {
0000000000000000000000000000000000000000;;				case token.RBRACE, token.RBRACK:
0000000000000000000000000000000000000000;;					// Do not count for these cases
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					// The next token is following on the line immediately after the
0000000000000000000000000000000000000000;;					// comment group, thus the last comment group is a lead comment.
0000000000000000000000000000000000000000;;					p.leadComment = comment
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return p.tok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unscan pushes the previously read token back onto the buffer.
0000000000000000000000000000000000000000;;	func (p *Parser) unscan() {
0000000000000000000000000000000000000000;;		p.n = 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ----------------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// Parsing support
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Parser) printTrace(a ...interface{}) {
0000000000000000000000000000000000000000;;		if !p.enableTrace {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		const dots = ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "
0000000000000000000000000000000000000000;;		const n = len(dots)
0000000000000000000000000000000000000000;;		fmt.Printf("%5d:%3d: ", p.tok.Pos.Line, p.tok.Pos.Column)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 2 * p.indent
0000000000000000000000000000000000000000;;		for i > n {
0000000000000000000000000000000000000000;;			fmt.Print(dots)
0000000000000000000000000000000000000000;;			i -= n
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// i <= n
0000000000000000000000000000000000000000;;		fmt.Print(dots[0:i])
0000000000000000000000000000000000000000;;		fmt.Println(a...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trace(p *Parser, msg string) *Parser {
0000000000000000000000000000000000000000;;		p.printTrace(msg, "(")
0000000000000000000000000000000000000000;;		p.indent++
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Usage pattern: defer un(trace(p, "..."))
0000000000000000000000000000000000000000;;	func un(p *Parser) {
0000000000000000000000000000000000000000;;		p.indent--
0000000000000000000000000000000000000000;;		p.printTrace(")")
0000000000000000000000000000000000000000;;	}
