0000000000000000000000000000000000000000;;	// Package ast declares the types used to represent syntax trees for HCL
0000000000000000000000000000000000000000;;	// (HashiCorp Configuration Language)
0000000000000000000000000000000000000000;;	package ast
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Node is an element in the abstract syntax tree.
0000000000000000000000000000000000000000;;	type Node interface {
0000000000000000000000000000000000000000;;		node()
0000000000000000000000000000000000000000;;		Pos() token.Pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (File) node()         {}
0000000000000000000000000000000000000000;;	func (ObjectList) node()   {}
0000000000000000000000000000000000000000;;	func (ObjectKey) node()    {}
0000000000000000000000000000000000000000;;	func (ObjectItem) node()   {}
0000000000000000000000000000000000000000;;	func (Comment) node()      {}
0000000000000000000000000000000000000000;;	func (CommentGroup) node() {}
0000000000000000000000000000000000000000;;	func (ObjectType) node()   {}
0000000000000000000000000000000000000000;;	func (LiteralType) node()  {}
0000000000000000000000000000000000000000;;	func (ListType) node()     {}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File represents a single HCL file
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		Node     Node            // usually a *ObjectList
0000000000000000000000000000000000000000;;		Comments []*CommentGroup // list of all comments in the source
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *File) Pos() token.Pos {
0000000000000000000000000000000000000000;;		return f.Node.Pos()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectList represents a list of ObjectItems. An HCL file itself is an
0000000000000000000000000000000000000000;;	// ObjectList.
0000000000000000000000000000000000000000;;	type ObjectList struct {
0000000000000000000000000000000000000000;;		Items []*ObjectItem
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ObjectList) Add(item *ObjectItem) {
0000000000000000000000000000000000000000;;		o.Items = append(o.Items, item)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Filter filters out the objects with the given key list as a prefix.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The returned list of objects contain ObjectItems where the keys have
0000000000000000000000000000000000000000;;	// this prefix already stripped off. This might result in objects with
0000000000000000000000000000000000000000;;	// zero-length key lists if they have no children.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If no matches are found, an empty ObjectList (non-nil) is returned.
0000000000000000000000000000000000000000;;	func (o *ObjectList) Filter(keys ...string) *ObjectList {
0000000000000000000000000000000000000000;;		var result ObjectList
0000000000000000000000000000000000000000;;		for _, item := range o.Items {
0000000000000000000000000000000000000000;;			// If there aren't enough keys, then ignore this
0000000000000000000000000000000000000000;;			if len(item.Keys) < len(keys) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			match := true
0000000000000000000000000000000000000000;;			for i, key := range item.Keys[:len(keys)] {
0000000000000000000000000000000000000000;;				key := key.Token.Value().(string)
0000000000000000000000000000000000000000;;				if key != keys[i] && !strings.EqualFold(key, keys[i]) {
0000000000000000000000000000000000000000;;					match = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !match {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Strip off the prefix from the children
0000000000000000000000000000000000000000;;			newItem := *item
0000000000000000000000000000000000000000;;			newItem.Keys = newItem.Keys[len(keys):]
0000000000000000000000000000000000000000;;			result.Add(&newItem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Children returns further nested objects (key length > 0) within this
0000000000000000000000000000000000000000;;	// ObjectList. This should be used with Filter to get at child items.
0000000000000000000000000000000000000000;;	func (o *ObjectList) Children() *ObjectList {
0000000000000000000000000000000000000000;;		var result ObjectList
0000000000000000000000000000000000000000;;		for _, item := range o.Items {
0000000000000000000000000000000000000000;;			if len(item.Keys) > 0 {
0000000000000000000000000000000000000000;;				result.Add(item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Elem returns items in the list that are direct element assignments
0000000000000000000000000000000000000000;;	// (key length == 0). This should be used with Filter to get at elements.
0000000000000000000000000000000000000000;;	func (o *ObjectList) Elem() *ObjectList {
0000000000000000000000000000000000000000;;		var result ObjectList
0000000000000000000000000000000000000000;;		for _, item := range o.Items {
0000000000000000000000000000000000000000;;			if len(item.Keys) == 0 {
0000000000000000000000000000000000000000;;				result.Add(item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ObjectList) Pos() token.Pos {
0000000000000000000000000000000000000000;;		// always returns the uninitiliazed position
0000000000000000000000000000000000000000;;		return o.Items[0].Pos()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectItem represents a HCL Object Item. An item is represented with a key
0000000000000000000000000000000000000000;;	// (or keys). It can be an assignment or an object (both normal and nested)
0000000000000000000000000000000000000000;;	type ObjectItem struct {
0000000000000000000000000000000000000000;;		// keys is only one length long if it's of type assignment. If it's a
0000000000000000000000000000000000000000;;		// nested object it can be larger than one. In that case "assign" is
0000000000000000000000000000000000000000;;		// invalid as there is no assignments for a nested object.
0000000000000000000000000000000000000000;;		Keys []*ObjectKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// assign contains the position of "=", if any
0000000000000000000000000000000000000000;;		Assign token.Pos
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// val is the item itself. It can be an object,list, number, bool or a
0000000000000000000000000000000000000000;;		// string. If key length is larger than one, val can be only of type
0000000000000000000000000000000000000000;;		// Object.
0000000000000000000000000000000000000000;;		Val Node
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LeadComment *CommentGroup // associated lead comment
0000000000000000000000000000000000000000;;		LineComment *CommentGroup // associated line comment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ObjectItem) Pos() token.Pos {
0000000000000000000000000000000000000000;;		// I'm not entirely sure what causes this, but removing this causes
0000000000000000000000000000000000000000;;		// a test failure. We should investigate at some point.
0000000000000000000000000000000000000000;;		if len(o.Keys) == 0 {
0000000000000000000000000000000000000000;;			return token.Pos{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return o.Keys[0].Pos()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectKeys are either an identifier or of type string.
0000000000000000000000000000000000000000;;	type ObjectKey struct {
0000000000000000000000000000000000000000;;		Token token.Token
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ObjectKey) Pos() token.Pos {
0000000000000000000000000000000000000000;;		return o.Token.Pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LiteralType represents a literal of basic type. Valid types are:
0000000000000000000000000000000000000000;;	// token.NUMBER, token.FLOAT, token.BOOL and token.STRING
0000000000000000000000000000000000000000;;	type LiteralType struct {
0000000000000000000000000000000000000000;;		Token token.Token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// associated line comment, only when used in a list
0000000000000000000000000000000000000000;;		LineComment *CommentGroup
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *LiteralType) Pos() token.Pos {
0000000000000000000000000000000000000000;;		return l.Token.Pos
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListStatement represents a HCL List type
0000000000000000000000000000000000000000;;	type ListType struct {
0000000000000000000000000000000000000000;;		Lbrack token.Pos // position of "["
0000000000000000000000000000000000000000;;		Rbrack token.Pos // position of "]"
0000000000000000000000000000000000000000;;		List   []Node    // the elements in lexical order
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *ListType) Pos() token.Pos {
0000000000000000000000000000000000000000;;		return l.Lbrack
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (l *ListType) Add(node Node) {
0000000000000000000000000000000000000000;;		l.List = append(l.List, node)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ObjectType represents a HCL Object Type
0000000000000000000000000000000000000000;;	type ObjectType struct {
0000000000000000000000000000000000000000;;		Lbrace token.Pos   // position of "{"
0000000000000000000000000000000000000000;;		Rbrace token.Pos   // position of "}"
0000000000000000000000000000000000000000;;		List   *ObjectList // the nodes in lexical order
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ObjectType) Pos() token.Pos {
0000000000000000000000000000000000000000;;		return o.Lbrace
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Comment node represents a single //, # style or /*- style commment
0000000000000000000000000000000000000000;;	type Comment struct {
0000000000000000000000000000000000000000;;		Start token.Pos // position of / or #
0000000000000000000000000000000000000000;;		Text  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Comment) Pos() token.Pos {
0000000000000000000000000000000000000000;;		return c.Start
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CommentGroup node represents a sequence of comments with no other tokens and
0000000000000000000000000000000000000000;;	// no empty lines between.
0000000000000000000000000000000000000000;;	type CommentGroup struct {
0000000000000000000000000000000000000000;;		List []*Comment // len(List) > 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CommentGroup) Pos() token.Pos {
0000000000000000000000000000000000000000;;		return c.List[0].Pos()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//-------------------------------------------------------------------
0000000000000000000000000000000000000000;;	// GoStringer
0000000000000000000000000000000000000000;;	//-------------------------------------------------------------------
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *ObjectKey) GoString() string { return fmt.Sprintf("*%#v", *o) }
