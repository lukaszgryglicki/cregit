0000000000000000000000000000000000000000;;	package strconv
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrSyntax indicates that a value does not have the right syntax for the target type.
0000000000000000000000000000000000000000;;	var ErrSyntax = errors.New("invalid syntax")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unquote interprets s as a single-quoted, double-quoted,
0000000000000000000000000000000000000000;;	// or backquoted Go string literal, returning the string value
0000000000000000000000000000000000000000;;	// that s quotes.  (If s is single-quoted, it would be a Go
0000000000000000000000000000000000000000;;	// character literal; Unquote returns the corresponding
0000000000000000000000000000000000000000;;	// one-character string.)
0000000000000000000000000000000000000000;;	func Unquote(s string) (t string, err error) {
0000000000000000000000000000000000000000;;		n := len(s)
0000000000000000000000000000000000000000;;		if n < 2 {
0000000000000000000000000000000000000000;;			return "", ErrSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		quote := s[0]
0000000000000000000000000000000000000000;;		if quote != s[n-1] {
0000000000000000000000000000000000000000;;			return "", ErrSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s = s[1 : n-1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if quote != '"' {
0000000000000000000000000000000000000000;;			return "", ErrSyntax
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Is it trivial?  Avoid allocation.
0000000000000000000000000000000000000000;;		if !contains(s, '\\') && !contains(s, quote) && !contains(s, '$') {
0000000000000000000000000000000000000000;;			switch quote {
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				return s, nil
0000000000000000000000000000000000000000;;			case '\'':
0000000000000000000000000000000000000000;;				r, size := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;				if size == len(s) && (r != utf8.RuneError || size != 1) {
0000000000000000000000000000000000000000;;					return s, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var runeTmp [utf8.UTFMax]byte
0000000000000000000000000000000000000000;;		buf := make([]byte, 0, 3*len(s)/2) // Try to avoid more allocations.
0000000000000000000000000000000000000000;;		for len(s) > 0 {
0000000000000000000000000000000000000000;;			// If we're starting a '${}' then let it through un-unquoted.
0000000000000000000000000000000000000000;;			// Specifically: we don't unquote any characters within the `${}`
0000000000000000000000000000000000000000;;			// section, except for escaped backslashes, which we handle specifically.
0000000000000000000000000000000000000000;;			if s[0] == '$' && len(s) > 1 && s[1] == '{' {
0000000000000000000000000000000000000000;;				buf = append(buf, '$', '{')
0000000000000000000000000000000000000000;;				s = s[2:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Continue reading until we find the closing brace, copying as-is
0000000000000000000000000000000000000000;;				braces := 1
0000000000000000000000000000000000000000;;				for len(s) > 0 && braces > 0 {
0000000000000000000000000000000000000000;;					r, size := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;					if r == utf8.RuneError {
0000000000000000000000000000000000000000;;						return "", ErrSyntax
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					s = s[size:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// We special case escaped backslashes in interpolations, converting
0000000000000000000000000000000000000000;;					// them to their unescaped equivalents.
0000000000000000000000000000000000000000;;					if r == '\\' {
0000000000000000000000000000000000000000;;						q, _ := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;						switch q {
0000000000000000000000000000000000000000;;						case '\\':
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					n := utf8.EncodeRune(runeTmp[:], r)
0000000000000000000000000000000000000000;;					buf = append(buf, runeTmp[:n]...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					switch r {
0000000000000000000000000000000000000000;;					case '{':
0000000000000000000000000000000000000000;;						braces++
0000000000000000000000000000000000000000;;					case '}':
0000000000000000000000000000000000000000;;						braces--
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if braces != 0 {
0000000000000000000000000000000000000000;;					return "", ErrSyntax
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if len(s) == 0 {
0000000000000000000000000000000000000000;;					// If there's no string left, we're done!
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// If there's more left, we need to pop back up to the top of the loop
0000000000000000000000000000000000000000;;					// in case there's another interpolation in this string.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			c, multibyte, ss, err := unquoteChar(s, quote)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return "", err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = ss
0000000000000000000000000000000000000000;;			if c < utf8.RuneSelf || !multibyte {
0000000000000000000000000000000000000000;;				buf = append(buf, byte(c))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				n := utf8.EncodeRune(runeTmp[:], c)
0000000000000000000000000000000000000000;;				buf = append(buf, runeTmp[:n]...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if quote == '\'' && len(s) != 0 {
0000000000000000000000000000000000000000;;				// single-quoted must be single character
0000000000000000000000000000000000000000;;				return "", ErrSyntax
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// contains reports whether the string contains the byte c.
0000000000000000000000000000000000000000;;	func contains(s string, c byte) bool {
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			if s[i] == c {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unhex(b byte) (v rune, ok bool) {
0000000000000000000000000000000000000000;;		c := rune(b)
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case '0' <= c && c <= '9':
0000000000000000000000000000000000000000;;			return c - '0', true
0000000000000000000000000000000000000000;;		case 'a' <= c && c <= 'f':
0000000000000000000000000000000000000000;;			return c - 'a' + 10, true
0000000000000000000000000000000000000000;;		case 'A' <= c && c <= 'F':
0000000000000000000000000000000000000000;;			return c - 'A' + 10, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unquoteChar(s string, quote byte) (value rune, multibyte bool, tail string, err error) {
0000000000000000000000000000000000000000;;		// easy cases
0000000000000000000000000000000000000000;;		switch c := s[0]; {
0000000000000000000000000000000000000000;;		case c == quote && (quote == '\'' || quote == '"'):
0000000000000000000000000000000000000000;;			err = ErrSyntax
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case c >= utf8.RuneSelf:
0000000000000000000000000000000000000000;;			r, size := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;			return r, true, s[size:], nil
0000000000000000000000000000000000000000;;		case c != '\\':
0000000000000000000000000000000000000000;;			return rune(s[0]), false, s[1:], nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// hard case: c is backslash
0000000000000000000000000000000000000000;;		if len(s) <= 1 {
0000000000000000000000000000000000000000;;			err = ErrSyntax
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := s[1]
0000000000000000000000000000000000000000;;		s = s[2:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case 'a':
0000000000000000000000000000000000000000;;			value = '\a'
0000000000000000000000000000000000000000;;		case 'b':
0000000000000000000000000000000000000000;;			value = '\b'
0000000000000000000000000000000000000000;;		case 'f':
0000000000000000000000000000000000000000;;			value = '\f'
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			value = '\n'
0000000000000000000000000000000000000000;;		case 'r':
0000000000000000000000000000000000000000;;			value = '\r'
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			value = '\t'
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			value = '\v'
0000000000000000000000000000000000000000;;		case 'x', 'u', 'U':
0000000000000000000000000000000000000000;;			n := 0
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case 'x':
0000000000000000000000000000000000000000;;				n = 2
0000000000000000000000000000000000000000;;			case 'u':
0000000000000000000000000000000000000000;;				n = 4
0000000000000000000000000000000000000000;;			case 'U':
0000000000000000000000000000000000000000;;				n = 8
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var v rune
0000000000000000000000000000000000000000;;			if len(s) < n {
0000000000000000000000000000000000000000;;				err = ErrSyntax
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j := 0; j < n; j++ {
0000000000000000000000000000000000000000;;				x, ok := unhex(s[j])
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					err = ErrSyntax
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = v<<4 | x
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = s[n:]
0000000000000000000000000000000000000000;;			if c == 'x' {
0000000000000000000000000000000000000000;;				// single-byte string, possibly not UTF-8
0000000000000000000000000000000000000000;;				value = v
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if v > utf8.MaxRune {
0000000000000000000000000000000000000000;;				err = ErrSyntax
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value = v
0000000000000000000000000000000000000000;;			multibyte = true
0000000000000000000000000000000000000000;;		case '0', '1', '2', '3', '4', '5', '6', '7':
0000000000000000000000000000000000000000;;			v := rune(c) - '0'
0000000000000000000000000000000000000000;;			if len(s) < 2 {
0000000000000000000000000000000000000000;;				err = ErrSyntax
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for j := 0; j < 2; j++ { // one digit already; two more
0000000000000000000000000000000000000000;;				x := rune(s[j]) - '0'
0000000000000000000000000000000000000000;;				if x < 0 || x > 7 {
0000000000000000000000000000000000000000;;					err = ErrSyntax
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v = (v << 3) | x
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s = s[2:]
0000000000000000000000000000000000000000;;			if v > 255 {
0000000000000000000000000000000000000000;;				err = ErrSyntax
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value = v
0000000000000000000000000000000000000000;;		case '\\':
0000000000000000000000000000000000000000;;			value = '\\'
0000000000000000000000000000000000000000;;		case '\'', '"':
0000000000000000000000000000000000000000;;			if c != quote {
0000000000000000000000000000000000000000;;				err = ErrSyntax
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			value = rune(c)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			err = ErrSyntax
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tail = s
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
