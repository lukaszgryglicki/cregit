0000000000000000000000000000000000000000;;	# HCL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	[![GoDoc](https://godoc.org/github.com/hashicorp/hcl?status.png)](https://godoc.org/github.com/hashicorp/hcl) [![Build Status](https://travis-ci.org/hashicorp/hcl.svg?branch=master)](https://travis-ci.org/hashicorp/hcl)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	HCL (HashiCorp Configuration Language) is a configuration language built
0000000000000000000000000000000000000000;;	by HashiCorp. The goal of HCL is to build a structured configuration language
0000000000000000000000000000000000000000;;	that is both human and machine friendly for use with command-line tools, but
0000000000000000000000000000000000000000;;	specifically targeted towards DevOps tools, servers, etc.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	HCL is also fully JSON compatible. That is, JSON can be used as completely
0000000000000000000000000000000000000000;;	valid input to a system expecting HCL. This helps makes systems
0000000000000000000000000000000000000000;;	interoperable with other systems.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	HCL is heavily inspired by
0000000000000000000000000000000000000000;;	[libucl](https://github.com/vstakhov/libucl),
0000000000000000000000000000000000000000;;	nginx configuration, and others similar.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Why?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	A common question when viewing HCL is to ask the question: why not
0000000000000000000000000000000000000000;;	JSON, YAML, etc.?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Prior to HCL, the tools we built at [HashiCorp](http://www.hashicorp.com)
0000000000000000000000000000000000000000;;	used a variety of configuration languages from full programming languages
0000000000000000000000000000000000000000;;	such as Ruby to complete data structure languages such as JSON. What we
0000000000000000000000000000000000000000;;	learned is that some people wanted human-friendly configuration languages
0000000000000000000000000000000000000000;;	and some people wanted machine-friendly languages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	JSON fits a nice balance in this, but is fairly verbose and most
0000000000000000000000000000000000000000;;	importantly doesn't support comments. With YAML, we found that beginners
0000000000000000000000000000000000000000;;	had a really hard time determining what the actual structure was, and
0000000000000000000000000000000000000000;;	ended up guessing more often than not whether to use a hyphen, colon, etc.
0000000000000000000000000000000000000000;;	in order to represent some configuration key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Full programming languages such as Ruby enable complex behavior
0000000000000000000000000000000000000000;;	a configuration language shouldn't usually allow, and also forces
0000000000000000000000000000000000000000;;	people to learn some set of Ruby.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Because of this, we decided to create our own configuration language
0000000000000000000000000000000000000000;;	that is JSON-compatible. Our configuration language (HCL) is designed
0000000000000000000000000000000000000000;;	to be written and modified by humans. The API for HCL allows JSON
0000000000000000000000000000000000000000;;	as an input so that it is also machine-friendly (machines can generate
0000000000000000000000000000000000000000;;	JSON instead of trying to generate HCL).
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Our goal with HCL is not to alienate other configuration languages.
0000000000000000000000000000000000000000;;	It is instead to provide HCL as a specialized language for our tools,
0000000000000000000000000000000000000000;;	and JSON as the interoperability layer.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Syntax
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For a complete grammar, please see the parser itself. A high-level overview
0000000000000000000000000000000000000000;;	of the syntax and grammar is listed here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Single line comments start with `#` or `//`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Multi-line comments are wrapped in `/*` and `*/`. Nested block comments
0000000000000000000000000000000000000000;;	    are not allowed. A multi-line comment (also known as a block comment)
0000000000000000000000000000000000000000;;	    terminates at the first `*/` found.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Values are assigned with the syntax `key = value` (whitespace doesn't
0000000000000000000000000000000000000000;;	    matter). The value can be any primitive: a string, number, boolean,
0000000000000000000000000000000000000000;;	    object, or list.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Strings are double-quoted and can contain any UTF-8 characters.
0000000000000000000000000000000000000000;;	    Example: `"Hello, World"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Multi-line strings start with `<<EOF` at the end of a line, and end
0000000000000000000000000000000000000000;;	    with `EOF` on its own line ([here documents](https://en.wikipedia.org/wiki/Here_document)).
0000000000000000000000000000000000000000;;	    Any text may be used in place of `EOF`. Example:
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	<<FOO
0000000000000000000000000000000000000000;;	hello
0000000000000000000000000000000000000000;;	world
0000000000000000000000000000000000000000;;	FOO
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Numbers are assumed to be base 10. If you prefix a number with 0x,
0000000000000000000000000000000000000000;;	    it is treated as a hexadecimal. If it is prefixed with 0, it is
0000000000000000000000000000000000000000;;	    treated as an octal. Numbers can be in scientific notation: "1e10".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Boolean values: `true`, `false`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * Arrays can be made by wrapping it in `[]`. Example:
0000000000000000000000000000000000000000;;	    `["foo", "bar", 42]`. Arrays can contain primitives,
0000000000000000000000000000000000000000;;	    other arrays, and objects. As an alternative, lists
0000000000000000000000000000000000000000;;	    of objects can be created with repeated blocks, using
0000000000000000000000000000000000000000;;	    this structure:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    ```hcl
0000000000000000000000000000000000000000;;	    service {
0000000000000000000000000000000000000000;;	        key = "value"
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    service {
0000000000000000000000000000000000000000;;	        key = "value"
0000000000000000000000000000000000000000;;	    }
0000000000000000000000000000000000000000;;	    ```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Objects and nested objects are created using the structure shown below:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	variable "ami" {
0000000000000000000000000000000000000000;;	    description = "the AMI to use"
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	```
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	## Thanks
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Thanks to:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * [@vstakhov](https://github.com/vstakhov) - The original libucl parser
0000000000000000000000000000000000000000;;	    and syntax that HCL was based off of.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  * [@fatih](https://github.com/fatih) - The rewritten HCL parser
0000000000000000000000000000000000000000;;	    in pure Go (no goyacc) and support for a printer.
