0000000000000000000000000000000000000000;;	package hcl
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/ast"
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/parser"
0000000000000000000000000000000000000000;;		"github.com/hashicorp/hcl/hcl/token"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// This is the tag to use with structures to have settings for HCL
0000000000000000000000000000000000000000;;	const tagName = "hcl"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// nodeType holds a reference to the type of ast.Node
0000000000000000000000000000000000000000;;		nodeType reflect.Type = findNodeType()
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unmarshal accepts a byte slice as input and writes the
0000000000000000000000000000000000000000;;	// data to the value pointed to by v.
0000000000000000000000000000000000000000;;	func Unmarshal(bs []byte, v interface{}) error {
0000000000000000000000000000000000000000;;		root, err := parse(bs)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return DecodeObject(v, root)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Decode reads the given input and decodes it into the structure
0000000000000000000000000000000000000000;;	// given by `out`.
0000000000000000000000000000000000000000;;	func Decode(out interface{}, in string) error {
0000000000000000000000000000000000000000;;		obj, err := Parse(in)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return DecodeObject(out, obj)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodeObject is a lower-level version of Decode. It decodes a
0000000000000000000000000000000000000000;;	// raw Object into the given output.
0000000000000000000000000000000000000000;;	func DecodeObject(out interface{}, n ast.Node) error {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(out)
0000000000000000000000000000000000000000;;		if val.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return errors.New("result must be a pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have the file, we really decode the root node
0000000000000000000000000000000000000000;;		if f, ok := n.(*ast.File); ok {
0000000000000000000000000000000000000000;;			n = f.Node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var d decoder
0000000000000000000000000000000000000000;;		return d.decode("root", n, val.Elem())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type decoder struct {
0000000000000000000000000000000000000000;;		stack []reflect.Kind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decode(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		k := result
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have an interface with a valid value, we use that
0000000000000000000000000000000000000000;;		// for the check.
0000000000000000000000000000000000000000;;		if result.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;			elem := result.Elem()
0000000000000000000000000000000000000000;;			if elem.IsValid() {
0000000000000000000000000000000000000000;;				k = elem
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Push current onto stack unless it is an interface.
0000000000000000000000000000000000000000;;		if k.Kind() != reflect.Interface {
0000000000000000000000000000000000000000;;			d.stack = append(d.stack, k.Kind())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Schedule a pop
0000000000000000000000000000000000000000;;			defer func() {
0000000000000000000000000000000000000000;;				d.stack = d.stack[:len(d.stack)-1]
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch k.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return d.decodeBool(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.Float64:
0000000000000000000000000000000000000000;;			return d.decodeFloat(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.Int:
0000000000000000000000000000000000000000;;			return d.decodeInt(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			// When we see an interface, we make our own thing
0000000000000000000000000000000000000000;;			return d.decodeInterface(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			return d.decodeMap(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			return d.decodePtr(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			return d.decodeSlice(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return d.decodeString(name, node, result)
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			return d.decodeStruct(name, node, result)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return &parser.PosError{
0000000000000000000000000000000000000000;;				Pos: node.Pos(),
0000000000000000000000000000000000000000;;				Err: fmt.Errorf("%s: unknown kind to decode into: %s", name, k.Kind()),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeBool(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		switch n := node.(type) {
0000000000000000000000000000000000000000;;		case *ast.LiteralType:
0000000000000000000000000000000000000000;;			if n.Token.Type == token.BOOL {
0000000000000000000000000000000000000000;;				v, err := strconv.ParseBool(n.Token.Text)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				result.Set(reflect.ValueOf(v))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &parser.PosError{
0000000000000000000000000000000000000000;;			Pos: node.Pos(),
0000000000000000000000000000000000000000;;			Err: fmt.Errorf("%s: unknown type %T", name, node),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeFloat(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		switch n := node.(type) {
0000000000000000000000000000000000000000;;		case *ast.LiteralType:
0000000000000000000000000000000000000000;;			if n.Token.Type == token.FLOAT {
0000000000000000000000000000000000000000;;				v, err := strconv.ParseFloat(n.Token.Text, 64)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				result.Set(reflect.ValueOf(v))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &parser.PosError{
0000000000000000000000000000000000000000;;			Pos: node.Pos(),
0000000000000000000000000000000000000000;;			Err: fmt.Errorf("%s: unknown type %T", name, node),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeInt(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		switch n := node.(type) {
0000000000000000000000000000000000000000;;		case *ast.LiteralType:
0000000000000000000000000000000000000000;;			switch n.Token.Type {
0000000000000000000000000000000000000000;;			case token.NUMBER:
0000000000000000000000000000000000000000;;				v, err := strconv.ParseInt(n.Token.Text, 0, 0)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				result.Set(reflect.ValueOf(int(v)))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case token.STRING:
0000000000000000000000000000000000000000;;				v, err := strconv.ParseInt(n.Token.Value().(string), 0, 0)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				result.Set(reflect.ValueOf(int(v)))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &parser.PosError{
0000000000000000000000000000000000000000;;			Pos: node.Pos(),
0000000000000000000000000000000000000000;;			Err: fmt.Errorf("%s: unknown type %T", name, node),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeInterface(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		// When we see an ast.Node, we retain the value to enable deferred decoding.
0000000000000000000000000000000000000000;;		// Very useful in situations where we want to preserve ast.Node information
0000000000000000000000000000000000000000;;		// like Pos
0000000000000000000000000000000000000000;;		if result.Type() == nodeType && result.CanSet() {
0000000000000000000000000000000000000000;;			result.Set(reflect.ValueOf(node))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var set reflect.Value
0000000000000000000000000000000000000000;;		redecode := true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For testing types, ObjectType should just be treated as a list. We
0000000000000000000000000000000000000000;;		// set this to a temporary var because we want to pass in the real node.
0000000000000000000000000000000000000000;;		testNode := node
0000000000000000000000000000000000000000;;		if ot, ok := node.(*ast.ObjectType); ok {
0000000000000000000000000000000000000000;;			testNode = ot.List
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch n := testNode.(type) {
0000000000000000000000000000000000000000;;		case *ast.ObjectList:
0000000000000000000000000000000000000000;;			// If we're at the root or we're directly within a slice, then we
0000000000000000000000000000000000000000;;			// decode objects into map[string]interface{}, otherwise we decode
0000000000000000000000000000000000000000;;			// them into lists.
0000000000000000000000000000000000000000;;			if len(d.stack) == 0 || d.stack[len(d.stack)-1] == reflect.Slice {
0000000000000000000000000000000000000000;;				var temp map[string]interface{}
0000000000000000000000000000000000000000;;				tempVal := reflect.ValueOf(temp)
0000000000000000000000000000000000000000;;				result := reflect.MakeMap(
0000000000000000000000000000000000000000;;					reflect.MapOf(
0000000000000000000000000000000000000000;;						reflect.TypeOf(""),
0000000000000000000000000000000000000000;;						tempVal.Type().Elem()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				set = result
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var temp []map[string]interface{}
0000000000000000000000000000000000000000;;				tempVal := reflect.ValueOf(temp)
0000000000000000000000000000000000000000;;				result := reflect.MakeSlice(
0000000000000000000000000000000000000000;;					reflect.SliceOf(tempVal.Type().Elem()), 0, len(n.Items))
0000000000000000000000000000000000000000;;				set = result
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.ObjectType:
0000000000000000000000000000000000000000;;			// If we're at the root or we're directly within a slice, then we
0000000000000000000000000000000000000000;;			// decode objects into map[string]interface{}, otherwise we decode
0000000000000000000000000000000000000000;;			// them into lists.
0000000000000000000000000000000000000000;;			if len(d.stack) == 0 || d.stack[len(d.stack)-1] == reflect.Slice {
0000000000000000000000000000000000000000;;				var temp map[string]interface{}
0000000000000000000000000000000000000000;;				tempVal := reflect.ValueOf(temp)
0000000000000000000000000000000000000000;;				result := reflect.MakeMap(
0000000000000000000000000000000000000000;;					reflect.MapOf(
0000000000000000000000000000000000000000;;						reflect.TypeOf(""),
0000000000000000000000000000000000000000;;						tempVal.Type().Elem()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				set = result
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				var temp []map[string]interface{}
0000000000000000000000000000000000000000;;				tempVal := reflect.ValueOf(temp)
0000000000000000000000000000000000000000;;				result := reflect.MakeSlice(
0000000000000000000000000000000000000000;;					reflect.SliceOf(tempVal.Type().Elem()), 0, 1)
0000000000000000000000000000000000000000;;				set = result
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.ListType:
0000000000000000000000000000000000000000;;			var temp []interface{}
0000000000000000000000000000000000000000;;			tempVal := reflect.ValueOf(temp)
0000000000000000000000000000000000000000;;			result := reflect.MakeSlice(
0000000000000000000000000000000000000000;;				reflect.SliceOf(tempVal.Type().Elem()), 0, 0)
0000000000000000000000000000000000000000;;			set = result
0000000000000000000000000000000000000000;;		case *ast.LiteralType:
0000000000000000000000000000000000000000;;			switch n.Token.Type {
0000000000000000000000000000000000000000;;			case token.BOOL:
0000000000000000000000000000000000000000;;				var result bool
0000000000000000000000000000000000000000;;				set = reflect.Indirect(reflect.New(reflect.TypeOf(result)))
0000000000000000000000000000000000000000;;			case token.FLOAT:
0000000000000000000000000000000000000000;;				var result float64
0000000000000000000000000000000000000000;;				set = reflect.Indirect(reflect.New(reflect.TypeOf(result)))
0000000000000000000000000000000000000000;;			case token.NUMBER:
0000000000000000000000000000000000000000;;				var result int
0000000000000000000000000000000000000000;;				set = reflect.Indirect(reflect.New(reflect.TypeOf(result)))
0000000000000000000000000000000000000000;;			case token.STRING, token.HEREDOC:
0000000000000000000000000000000000000000;;				set = reflect.Indirect(reflect.New(reflect.TypeOf("")))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return &parser.PosError{
0000000000000000000000000000000000000000;;					Pos: node.Pos(),
0000000000000000000000000000000000000000;;					Err: fmt.Errorf("%s: cannot decode into interface: %T", name, node),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf(
0000000000000000000000000000000000000000;;				"%s: cannot decode into interface: %T",
0000000000000000000000000000000000000000;;				name, node)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the result to what its supposed to be, then reset
0000000000000000000000000000000000000000;;		// result so we don't reflect into this method anymore.
0000000000000000000000000000000000000000;;		result.Set(set)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if redecode {
0000000000000000000000000000000000000000;;			// Revisit the node so that we can use the newly instantiated
0000000000000000000000000000000000000000;;			// thing and populate it.
0000000000000000000000000000000000000000;;			if err := d.decode(name, node, result); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeMap(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		if item, ok := node.(*ast.ObjectItem); ok {
0000000000000000000000000000000000000000;;			node = &ast.ObjectList{Items: []*ast.ObjectItem{item}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ot, ok := node.(*ast.ObjectType); ok {
0000000000000000000000000000000000000000;;			node = ot.List
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, ok := node.(*ast.ObjectList)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return &parser.PosError{
0000000000000000000000000000000000000000;;				Pos: node.Pos(),
0000000000000000000000000000000000000000;;				Err: fmt.Errorf("%s: not an object type for map (%T)", name, node),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we have an interface, then we can address the interface,
0000000000000000000000000000000000000000;;		// but not the slice itself, so get the element but set the interface
0000000000000000000000000000000000000000;;		set := result
0000000000000000000000000000000000000000;;		if result.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;			result = result.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resultType := result.Type()
0000000000000000000000000000000000000000;;		resultElemType := resultType.Elem()
0000000000000000000000000000000000000000;;		resultKeyType := resultType.Key()
0000000000000000000000000000000000000000;;		if resultKeyType.Kind() != reflect.String {
0000000000000000000000000000000000000000;;			return &parser.PosError{
0000000000000000000000000000000000000000;;				Pos: node.Pos(),
0000000000000000000000000000000000000000;;				Err: fmt.Errorf("%s: map must have string keys", name),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Make a map if it is nil
0000000000000000000000000000000000000000;;		resultMap := result
0000000000000000000000000000000000000000;;		if result.IsNil() {
0000000000000000000000000000000000000000;;			resultMap = reflect.MakeMap(
0000000000000000000000000000000000000000;;				reflect.MapOf(resultKeyType, resultElemType))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Go through each element and decode it.
0000000000000000000000000000000000000000;;		done := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, item := range n.Items {
0000000000000000000000000000000000000000;;			if item.Val == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// github.com/hashicorp/terraform/issue/5740
0000000000000000000000000000000000000000;;			if len(item.Keys) == 0 {
0000000000000000000000000000000000000000;;				return &parser.PosError{
0000000000000000000000000000000000000000;;					Pos: node.Pos(),
0000000000000000000000000000000000000000;;					Err: fmt.Errorf("%s: map must have string keys", name),
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the key we're dealing with, which is the first item
0000000000000000000000000000000000000000;;			keyStr := item.Keys[0].Token.Value().(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we've already processed this key, then ignore it
0000000000000000000000000000000000000000;;			if _, ok := done[keyStr]; ok {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Determine the value. If we have more than one key, then we
0000000000000000000000000000000000000000;;			// get the objectlist of only these keys.
0000000000000000000000000000000000000000;;			itemVal := item.Val
0000000000000000000000000000000000000000;;			if len(item.Keys) > 1 {
0000000000000000000000000000000000000000;;				itemVal = n.Filter(keyStr)
0000000000000000000000000000000000000000;;				done[keyStr] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Make the field name
0000000000000000000000000000000000000000;;			fieldName := fmt.Sprintf("%s.%s", name, keyStr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Get the key/value as reflection values
0000000000000000000000000000000000000000;;			key := reflect.ValueOf(keyStr)
0000000000000000000000000000000000000000;;			val := reflect.Indirect(reflect.New(resultElemType))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we have a pre-existing value in the map, use that
0000000000000000000000000000000000000000;;			oldVal := resultMap.MapIndex(key)
0000000000000000000000000000000000000000;;			if oldVal.IsValid() {
0000000000000000000000000000000000000000;;				val.Set(oldVal)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Decode!
0000000000000000000000000000000000000000;;			if err := d.decode(fieldName, itemVal, val); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Set the value on the map
0000000000000000000000000000000000000000;;			resultMap.SetMapIndex(key, val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Set the final map if we can
0000000000000000000000000000000000000000;;		set.Set(resultMap)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodePtr(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		// Create an element of the concrete (non pointer) type and decode
0000000000000000000000000000000000000000;;		// into that. Then set the value of the pointer to this type.
0000000000000000000000000000000000000000;;		resultType := result.Type()
0000000000000000000000000000000000000000;;		resultElemType := resultType.Elem()
0000000000000000000000000000000000000000;;		val := reflect.New(resultElemType)
0000000000000000000000000000000000000000;;		if err := d.decode(name, node, reflect.Indirect(val)); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result.Set(val)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeSlice(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		// If we have an interface, then we can address the interface,
0000000000000000000000000000000000000000;;		// but not the slice itself, so get the element but set the interface
0000000000000000000000000000000000000000;;		set := result
0000000000000000000000000000000000000000;;		if result.Kind() == reflect.Interface {
0000000000000000000000000000000000000000;;			result = result.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the slice if it isn't nil
0000000000000000000000000000000000000000;;		resultType := result.Type()
0000000000000000000000000000000000000000;;		resultElemType := resultType.Elem()
0000000000000000000000000000000000000000;;		if result.IsNil() {
0000000000000000000000000000000000000000;;			resultSliceType := reflect.SliceOf(resultElemType)
0000000000000000000000000000000000000000;;			result = reflect.MakeSlice(
0000000000000000000000000000000000000000;;				resultSliceType, 0, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Figure out the items we'll be copying into the slice
0000000000000000000000000000000000000000;;		var items []ast.Node
0000000000000000000000000000000000000000;;		switch n := node.(type) {
0000000000000000000000000000000000000000;;		case *ast.ObjectList:
0000000000000000000000000000000000000000;;			items = make([]ast.Node, len(n.Items))
0000000000000000000000000000000000000000;;			for i, item := range n.Items {
0000000000000000000000000000000000000000;;				items[i] = item
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case *ast.ObjectType:
0000000000000000000000000000000000000000;;			items = []ast.Node{n}
0000000000000000000000000000000000000000;;		case *ast.ListType:
0000000000000000000000000000000000000000;;			items = n.List
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return &parser.PosError{
0000000000000000000000000000000000000000;;				Pos: node.Pos(),
0000000000000000000000000000000000000000;;				Err: fmt.Errorf("unknown slice type: %T", node),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, item := range items {
0000000000000000000000000000000000000000;;			fieldName := fmt.Sprintf("%s[%d]", name, i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Decode
0000000000000000000000000000000000000000;;			val := reflect.Indirect(reflect.New(resultElemType))
0000000000000000000000000000000000000000;;			if err := d.decode(fieldName, item, val); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Append it onto the slice
0000000000000000000000000000000000000000;;			result = reflect.Append(result, val)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		set.Set(result)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeString(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		switch n := node.(type) {
0000000000000000000000000000000000000000;;		case *ast.LiteralType:
0000000000000000000000000000000000000000;;			switch n.Token.Type {
0000000000000000000000000000000000000000;;			case token.NUMBER:
0000000000000000000000000000000000000000;;				result.Set(reflect.ValueOf(n.Token.Text).Convert(result.Type()))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			case token.STRING, token.HEREDOC:
0000000000000000000000000000000000000000;;				result.Set(reflect.ValueOf(n.Token.Value()).Convert(result.Type()))
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &parser.PosError{
0000000000000000000000000000000000000000;;			Pos: node.Pos(),
0000000000000000000000000000000000000000;;			Err: fmt.Errorf("%s: unknown type for string %T", name, node),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *decoder) decodeStruct(name string, node ast.Node, result reflect.Value) error {
0000000000000000000000000000000000000000;;		var item *ast.ObjectItem
0000000000000000000000000000000000000000;;		if it, ok := node.(*ast.ObjectItem); ok {
0000000000000000000000000000000000000000;;			item = it
0000000000000000000000000000000000000000;;			node = it.Val
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ot, ok := node.(*ast.ObjectType); ok {
0000000000000000000000000000000000000000;;			node = ot.List
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Handle the special case where the object itself is a literal. Previously
0000000000000000000000000000000000000000;;		// the yacc parser would always ensure top-level elements were arrays. The new
0000000000000000000000000000000000000000;;		// parser does not make the same guarantees, thus we need to convert any
0000000000000000000000000000000000000000;;		// top-level literal elements into a list.
0000000000000000000000000000000000000000;;		if _, ok := node.(*ast.LiteralType); ok {
0000000000000000000000000000000000000000;;			node = &ast.ObjectList{Items: []*ast.ObjectItem{item}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		list, ok := node.(*ast.ObjectList)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return &parser.PosError{
0000000000000000000000000000000000000000;;				Pos: node.Pos(),
0000000000000000000000000000000000000000;;				Err: fmt.Errorf("%s: not an object type for struct (%T)", name, node),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// This slice will keep track of all the structs we'll be decoding.
0000000000000000000000000000000000000000;;		// There can be more than one struct if there are embedded structs
0000000000000000000000000000000000000000;;		// that are squashed.
0000000000000000000000000000000000000000;;		structs := make([]reflect.Value, 1, 5)
0000000000000000000000000000000000000000;;		structs[0] = result
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compile the list of all the fields that we're going to be decoding
0000000000000000000000000000000000000000;;		// from all the structs.
0000000000000000000000000000000000000000;;		fields := make(map[*reflect.StructField]reflect.Value)
0000000000000000000000000000000000000000;;		for len(structs) > 0 {
0000000000000000000000000000000000000000;;			structVal := structs[0]
0000000000000000000000000000000000000000;;			structs = structs[1:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			structType := structVal.Type()
0000000000000000000000000000000000000000;;			for i := 0; i < structType.NumField(); i++ {
0000000000000000000000000000000000000000;;				fieldType := structType.Field(i)
0000000000000000000000000000000000000000;;				tagParts := strings.Split(fieldType.Tag.Get(tagName), ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Ignore fields with tag name "-"
0000000000000000000000000000000000000000;;				if tagParts[0] == "-" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if fieldType.Anonymous {
0000000000000000000000000000000000000000;;					fieldKind := fieldType.Type.Kind()
0000000000000000000000000000000000000000;;					if fieldKind != reflect.Struct {
0000000000000000000000000000000000000000;;						return &parser.PosError{
0000000000000000000000000000000000000000;;							Pos: node.Pos(),
0000000000000000000000000000000000000000;;							Err: fmt.Errorf("%s: unsupported type to struct: %s",
0000000000000000000000000000000000000000;;								fieldType.Name, fieldKind),
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// We have an embedded field. We "squash" the fields down
0000000000000000000000000000000000000000;;					// if specified in the tag.
0000000000000000000000000000000000000000;;					squash := false
0000000000000000000000000000000000000000;;					for _, tag := range tagParts[1:] {
0000000000000000000000000000000000000000;;						if tag == "squash" {
0000000000000000000000000000000000000000;;							squash = true
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if squash {
0000000000000000000000000000000000000000;;						structs = append(
0000000000000000000000000000000000000000;;							structs, result.FieldByName(fieldType.Name))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Normal struct field, store it away
0000000000000000000000000000000000000000;;				fields[&fieldType] = structVal.Field(i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		usedKeys := make(map[string]struct{})
0000000000000000000000000000000000000000;;		decodedFields := make([]string, 0, len(fields))
0000000000000000000000000000000000000000;;		decodedFieldsVal := make([]reflect.Value, 0)
0000000000000000000000000000000000000000;;		unusedKeysVal := make([]reflect.Value, 0)
0000000000000000000000000000000000000000;;		for fieldType, field := range fields {
0000000000000000000000000000000000000000;;			if !field.IsValid() {
0000000000000000000000000000000000000000;;				// This should never happen
0000000000000000000000000000000000000000;;				panic("field is not valid")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If we can't set the field, then it is unexported or something,
0000000000000000000000000000000000000000;;			// and we just continue onwards.
0000000000000000000000000000000000000000;;			if !field.CanSet() {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			fieldName := fieldType.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			tagValue := fieldType.Tag.Get(tagName)
0000000000000000000000000000000000000000;;			tagParts := strings.SplitN(tagValue, ",", 2)
0000000000000000000000000000000000000000;;			if len(tagParts) >= 2 {
0000000000000000000000000000000000000000;;				switch tagParts[1] {
0000000000000000000000000000000000000000;;				case "decodedFields":
0000000000000000000000000000000000000000;;					decodedFieldsVal = append(decodedFieldsVal, field)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case "key":
0000000000000000000000000000000000000000;;					if item == nil {
0000000000000000000000000000000000000000;;						return &parser.PosError{
0000000000000000000000000000000000000000;;							Pos: node.Pos(),
0000000000000000000000000000000000000000;;							Err: fmt.Errorf("%s: %s asked for 'key', impossible",
0000000000000000000000000000000000000000;;								name, fieldName),
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					field.SetString(item.Keys[0].Token.Value().(string))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				case "unusedKeys":
0000000000000000000000000000000000000000;;					unusedKeysVal = append(unusedKeysVal, field)
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tagParts[0] != "" {
0000000000000000000000000000000000000000;;				fieldName = tagParts[0]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Determine the element we'll use to decode. If it is a single
0000000000000000000000000000000000000000;;			// match (only object with the field), then we decode it exactly.
0000000000000000000000000000000000000000;;			// If it is a prefix match, then we decode the matches.
0000000000000000000000000000000000000000;;			filter := list.Filter(fieldName)
0000000000000000000000000000000000000000;;			prefixMatches := filter.Children()
0000000000000000000000000000000000000000;;			matches := filter.Elem()
0000000000000000000000000000000000000000;;			if len(matches.Items) == 0 && len(prefixMatches.Items) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Track the used key
0000000000000000000000000000000000000000;;			usedKeys[fieldName] = struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Create the field name and decode. We range over the elements
0000000000000000000000000000000000000000;;			// because we actually want the value.
0000000000000000000000000000000000000000;;			fieldName = fmt.Sprintf("%s.%s", name, fieldName)
0000000000000000000000000000000000000000;;			if len(prefixMatches.Items) > 0 {
0000000000000000000000000000000000000000;;				if err := d.decode(fieldName, prefixMatches, field); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, match := range matches.Items {
0000000000000000000000000000000000000000;;				var decodeNode ast.Node = match.Val
0000000000000000000000000000000000000000;;				if ot, ok := decodeNode.(*ast.ObjectType); ok {
0000000000000000000000000000000000000000;;					decodeNode = &ast.ObjectList{Items: ot.List.Items}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if err := d.decode(fieldName, decodeNode, field); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			decodedFields = append(decodedFields, fieldType.Name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(decodedFieldsVal) > 0 {
0000000000000000000000000000000000000000;;			// Sort it so that it is deterministic
0000000000000000000000000000000000000000;;			sort.Strings(decodedFields)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, v := range decodedFieldsVal {
0000000000000000000000000000000000000000;;				v.Set(reflect.ValueOf(decodedFields))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findNodeType returns the type of ast.Node
0000000000000000000000000000000000000000;;	func findNodeType() reflect.Type {
0000000000000000000000000000000000000000;;		var nodeContainer struct {
0000000000000000000000000000000000000000;;			Node ast.Node
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value := reflect.ValueOf(nodeContainer).FieldByName("Node")
0000000000000000000000000000000000000000;;		return value.Type()
0000000000000000000000000000000000000000;;	}
