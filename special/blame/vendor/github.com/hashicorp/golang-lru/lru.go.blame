0000000000000000000000000000000000000000;;	// This package provides a simple LRU cache. It is based on the
0000000000000000000000000000000000000000;;	// LRU implementation in groupcache:
0000000000000000000000000000000000000000;;	// https://github.com/golang/groupcache/tree/master/lru
0000000000000000000000000000000000000000;;	package lru
dc1f984f866a97e31080b22810a1488427a44cbb;Godeps/_workspace/src/github.com/hashicorp/golang-lru/lru.go[Godeps/_workspace/src/github.com/hashicorp/golang-lru/lru.go][vendor/github.com/hashicorp/golang-lru/lru.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/golang-lru/simplelru"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cache is a thread-safe fixed size LRU cache.
0000000000000000000000000000000000000000;;	type Cache struct {
0000000000000000000000000000000000000000;;		lru  *simplelru.LRU
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates an LRU of the given size
0000000000000000000000000000000000000000;;	func New(size int) (*Cache, error) {
0000000000000000000000000000000000000000;;		return NewWithEvict(size, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewWithEvict constructs a fixed size cache with the given eviction
0000000000000000000000000000000000000000;;	// callback.
0000000000000000000000000000000000000000;;	func NewWithEvict(size int, onEvicted func(key interface{}, value interface{})) (*Cache, error) {
0000000000000000000000000000000000000000;;		lru, err := simplelru.NewLRU(size, simplelru.EvictCallback(onEvicted))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &Cache{
0000000000000000000000000000000000000000;;			lru: lru,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Purge is used to completely clear the cache
0000000000000000000000000000000000000000;;	func (c *Cache) Purge() {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		c.lru.Purge()
0000000000000000000000000000000000000000;;		c.lock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a value to the cache.  Returns true if an eviction occurred.
0000000000000000000000000000000000000000;;	func (c *Cache) Add(key, value interface{}) bool {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		return c.lru.Add(key, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get looks up a key's value from the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) Get(key interface{}) (interface{}, bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		return c.lru.Get(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a key is in the cache, without updating the recent-ness
0000000000000000000000000000000000000000;;	// or deleting it for being stale.
0000000000000000000000000000000000000000;;	func (c *Cache) Contains(key interface{}) bool {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.lru.Contains(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the key value (or undefined if not found) without updating
0000000000000000000000000000000000000000;;	// the "recently used"-ness of the key.
0000000000000000000000000000000000000000;;	func (c *Cache) Peek(key interface{}) (interface{}, bool) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.lru.Peek(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainsOrAdd checks if a key is in the cache  without updating the
0000000000000000000000000000000000000000;;	// recent-ness or deleting it for being stale,  and if not, adds the value.
0000000000000000000000000000000000000000;;	// Returns whether found and whether an eviction occurred.
0000000000000000000000000000000000000000;;	func (c *Cache) ContainsOrAdd(key, value interface{}) (ok, evict bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if c.lru.Contains(key) {
0000000000000000000000000000000000000000;;			return true, false
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			evict := c.lru.Add(key, value)
0000000000000000000000000000000000000000;;			return false, evict
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the provided key from the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) Remove(key interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		c.lru.Remove(key)
0000000000000000000000000000000000000000;;		c.lock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveOldest removes the oldest item from the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) RemoveOldest() {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		c.lru.RemoveOldest()
0000000000000000000000000000000000000000;;		c.lock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns a slice of the keys in the cache, from oldest to newest.
0000000000000000000000000000000000000000;;	func (c *Cache) Keys() []interface{} {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.lru.Keys()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of items in the cache.
0000000000000000000000000000000000000000;;	func (c *Cache) Len() int {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.lru.Len()
0000000000000000000000000000000000000000;;	}
