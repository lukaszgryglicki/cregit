0000000000000000000000000000000000000000;;	package lru
dc1f984f866a97e31080b22810a1488427a44cbb;Godeps/_workspace/src/github.com/hashicorp/golang-lru/2q.go[Godeps/_workspace/src/github.com/hashicorp/golang-lru/2q.go][vendor/github.com/hashicorp/golang-lru/2q.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/golang-lru/simplelru"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Default2QRecentRatio is the ratio of the 2Q cache dedicated
0000000000000000000000000000000000000000;;		// to recently added entries that have only been accessed once.
0000000000000000000000000000000000000000;;		Default2QRecentRatio = 0.25
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Default2QGhostEntries is the default ratio of ghost
0000000000000000000000000000000000000000;;		// entries kept to track entries recently evicted
0000000000000000000000000000000000000000;;		Default2QGhostEntries = 0.50
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TwoQueueCache is a thread-safe fixed size 2Q cache.
0000000000000000000000000000000000000000;;	// 2Q is an enhancement over the standard LRU cache
0000000000000000000000000000000000000000;;	// in that it tracks both frequently and recently used
0000000000000000000000000000000000000000;;	// entries separately. This avoids a burst in access to new
0000000000000000000000000000000000000000;;	// entries from evicting frequently used entries. It adds some
0000000000000000000000000000000000000000;;	// additional tracking overhead to the standard LRU cache, and is
0000000000000000000000000000000000000000;;	// computationally about 2x the cost, and adds some metadata over
0000000000000000000000000000000000000000;;	// head. The ARCCache is similar, but does not require setting any
0000000000000000000000000000000000000000;;	// parameters.
0000000000000000000000000000000000000000;;	type TwoQueueCache struct {
0000000000000000000000000000000000000000;;		size       int
0000000000000000000000000000000000000000;;		recentSize int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		recent      *simplelru.LRU
0000000000000000000000000000000000000000;;		frequent    *simplelru.LRU
0000000000000000000000000000000000000000;;		recentEvict *simplelru.LRU
0000000000000000000000000000000000000000;;		lock        sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New2Q creates a new TwoQueueCache using the default
0000000000000000000000000000000000000000;;	// values for the parameters.
0000000000000000000000000000000000000000;;	func New2Q(size int) (*TwoQueueCache, error) {
0000000000000000000000000000000000000000;;		return New2QParams(size, Default2QRecentRatio, Default2QGhostEntries)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New2QParams creates a new TwoQueueCache using the provided
0000000000000000000000000000000000000000;;	// parameter values.
0000000000000000000000000000000000000000;;	func New2QParams(size int, recentRatio float64, ghostRatio float64) (*TwoQueueCache, error) {
0000000000000000000000000000000000000000;;		if size <= 0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if recentRatio < 0.0 || recentRatio > 1.0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid recent ratio")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ghostRatio < 0.0 || ghostRatio > 1.0 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("invalid ghost ratio")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Determine the sub-sizes
0000000000000000000000000000000000000000;;		recentSize := int(float64(size) * recentRatio)
0000000000000000000000000000000000000000;;		evictSize := int(float64(size) * ghostRatio)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Allocate the LRUs
0000000000000000000000000000000000000000;;		recent, err := simplelru.NewLRU(size, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		frequent, err := simplelru.NewLRU(size, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		recentEvict, err := simplelru.NewLRU(evictSize, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize the cache
0000000000000000000000000000000000000000;;		c := &TwoQueueCache{
0000000000000000000000000000000000000000;;			size:        size,
0000000000000000000000000000000000000000;;			recentSize:  recentSize,
0000000000000000000000000000000000000000;;			recent:      recent,
0000000000000000000000000000000000000000;;			frequent:    frequent,
0000000000000000000000000000000000000000;;			recentEvict: recentEvict,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Get(key interface{}) (interface{}, bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if this is a frequent value
0000000000000000000000000000000000000000;;		if val, ok := c.frequent.Get(key); ok {
0000000000000000000000000000000000000000;;			return val, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the value is contained in recent, then we
0000000000000000000000000000000000000000;;		// promote it to frequent
0000000000000000000000000000000000000000;;		if val, ok := c.recent.Peek(key); ok {
0000000000000000000000000000000000000000;;			c.recent.Remove(key)
0000000000000000000000000000000000000000;;			c.frequent.Add(key, val)
0000000000000000000000000000000000000000;;			return val, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No hit
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Add(key, value interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the value is frequently used already,
0000000000000000000000000000000000000000;;		// and just update the value
0000000000000000000000000000000000000000;;		if c.frequent.Contains(key) {
0000000000000000000000000000000000000000;;			c.frequent.Add(key, value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the value is recently used, and promote
0000000000000000000000000000000000000000;;		// the value into the frequent list
0000000000000000000000000000000000000000;;		if c.recent.Contains(key) {
0000000000000000000000000000000000000000;;			c.recent.Remove(key)
0000000000000000000000000000000000000000;;			c.frequent.Add(key, value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the value was recently evicted, add it to the
0000000000000000000000000000000000000000;;		// frequently used list
0000000000000000000000000000000000000000;;		if c.recentEvict.Contains(key) {
0000000000000000000000000000000000000000;;			c.ensureSpace(true)
0000000000000000000000000000000000000000;;			c.recentEvict.Remove(key)
0000000000000000000000000000000000000000;;			c.frequent.Add(key, value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add to the recently seen list
0000000000000000000000000000000000000000;;		c.ensureSpace(false)
0000000000000000000000000000000000000000;;		c.recent.Add(key, value)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ensureSpace is used to ensure we have space in the cache
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) ensureSpace(recentEvict bool) {
0000000000000000000000000000000000000000;;		// If we have space, nothing to do
0000000000000000000000000000000000000000;;		recentLen := c.recent.Len()
0000000000000000000000000000000000000000;;		freqLen := c.frequent.Len()
0000000000000000000000000000000000000000;;		if recentLen+freqLen < c.size {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If the recent buffer is larger than
0000000000000000000000000000000000000000;;		// the target, evict from there
0000000000000000000000000000000000000000;;		if recentLen > 0 && (recentLen > c.recentSize || (recentLen == c.recentSize && !recentEvict)) {
0000000000000000000000000000000000000000;;			k, _, _ := c.recent.RemoveOldest()
0000000000000000000000000000000000000000;;			c.recentEvict.Add(k, nil)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Remove from the frequent list otherwise
0000000000000000000000000000000000000000;;		c.frequent.RemoveOldest()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Len() int {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.recent.Len() + c.frequent.Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Keys() []interface{} {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		k1 := c.frequent.Keys()
0000000000000000000000000000000000000000;;		k2 := c.recent.Keys()
0000000000000000000000000000000000000000;;		return append(k1, k2...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Remove(key interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		if c.frequent.Remove(key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.recent.Remove(key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.recentEvict.Remove(key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Purge() {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.recent.Purge()
0000000000000000000000000000000000000000;;		c.frequent.Purge()
0000000000000000000000000000000000000000;;		c.recentEvict.Purge()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Contains(key interface{}) bool {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.frequent.Contains(key) || c.recent.Contains(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *TwoQueueCache) Peek(key interface{}) (interface{}, bool) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		if val, ok := c.frequent.Peek(key); ok {
0000000000000000000000000000000000000000;;			return val, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.recent.Peek(key)
0000000000000000000000000000000000000000;;	}
