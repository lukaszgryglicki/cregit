0000000000000000000000000000000000000000;;	package simplelru
dc1f984f866a97e31080b22810a1488427a44cbb;Godeps/_workspace/src/github.com/hashicorp/golang-lru/simplelru/lru.go[Godeps/_workspace/src/github.com/hashicorp/golang-lru/simplelru/lru.go][vendor/github.com/hashicorp/golang-lru/simplelru/lru.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EvictCallback is used to get a callback when a cache entry is evicted
0000000000000000000000000000000000000000;;	type EvictCallback func(key interface{}, value interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LRU implements a non-thread safe fixed size LRU cache
0000000000000000000000000000000000000000;;	type LRU struct {
0000000000000000000000000000000000000000;;		size      int
0000000000000000000000000000000000000000;;		evictList *list.List
0000000000000000000000000000000000000000;;		items     map[interface{}]*list.Element
0000000000000000000000000000000000000000;;		onEvict   EvictCallback
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// entry is used to hold a value in the evictList
0000000000000000000000000000000000000000;;	type entry struct {
0000000000000000000000000000000000000000;;		key   interface{}
0000000000000000000000000000000000000000;;		value interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewLRU constructs an LRU of the given size
0000000000000000000000000000000000000000;;	func NewLRU(size int, onEvict EvictCallback) (*LRU, error) {
0000000000000000000000000000000000000000;;		if size <= 0 {
0000000000000000000000000000000000000000;;			return nil, errors.New("Must provide a positive size")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := &LRU{
0000000000000000000000000000000000000000;;			size:      size,
0000000000000000000000000000000000000000;;			evictList: list.New(),
0000000000000000000000000000000000000000;;			items:     make(map[interface{}]*list.Element),
0000000000000000000000000000000000000000;;			onEvict:   onEvict,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Purge is used to completely clear the cache
0000000000000000000000000000000000000000;;	func (c *LRU) Purge() {
0000000000000000000000000000000000000000;;		for k, v := range c.items {
0000000000000000000000000000000000000000;;			if c.onEvict != nil {
0000000000000000000000000000000000000000;;				c.onEvict(k, v.Value.(*entry).value)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			delete(c.items, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.evictList.Init()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a value to the cache.  Returns true if an eviction occured.
0000000000000000000000000000000000000000;;	func (c *LRU) Add(key, value interface{}) bool {
0000000000000000000000000000000000000000;;		// Check for existing item
0000000000000000000000000000000000000000;;		if ent, ok := c.items[key]; ok {
0000000000000000000000000000000000000000;;			c.evictList.MoveToFront(ent)
0000000000000000000000000000000000000000;;			ent.Value.(*entry).value = value
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add new item
0000000000000000000000000000000000000000;;		ent := &entry{key, value}
0000000000000000000000000000000000000000;;		entry := c.evictList.PushFront(ent)
0000000000000000000000000000000000000000;;		c.items[key] = entry
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		evict := c.evictList.Len() > c.size
0000000000000000000000000000000000000000;;		// Verify size not exceeded
0000000000000000000000000000000000000000;;		if evict {
0000000000000000000000000000000000000000;;			c.removeOldest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return evict
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get looks up a key's value from the cache.
0000000000000000000000000000000000000000;;	func (c *LRU) Get(key interface{}) (value interface{}, ok bool) {
0000000000000000000000000000000000000000;;		if ent, ok := c.items[key]; ok {
0000000000000000000000000000000000000000;;			c.evictList.MoveToFront(ent)
0000000000000000000000000000000000000000;;			return ent.Value.(*entry).value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check if a key is in the cache, without updating the recent-ness
0000000000000000000000000000000000000000;;	// or deleting it for being stale.
0000000000000000000000000000000000000000;;	func (c *LRU) Contains(key interface{}) (ok bool) {
0000000000000000000000000000000000000000;;		_, ok = c.items[key]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Returns the key value (or undefined if not found) without updating
0000000000000000000000000000000000000000;;	// the "recently used"-ness of the key.
0000000000000000000000000000000000000000;;	func (c *LRU) Peek(key interface{}) (value interface{}, ok bool) {
0000000000000000000000000000000000000000;;		if ent, ok := c.items[key]; ok {
0000000000000000000000000000000000000000;;			return ent.Value.(*entry).value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the provided key from the cache, returning if the
0000000000000000000000000000000000000000;;	// key was contained.
0000000000000000000000000000000000000000;;	func (c *LRU) Remove(key interface{}) bool {
0000000000000000000000000000000000000000;;		if ent, ok := c.items[key]; ok {
0000000000000000000000000000000000000000;;			c.removeElement(ent)
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoveOldest removes the oldest item from the cache.
0000000000000000000000000000000000000000;;	func (c *LRU) RemoveOldest() (interface{}, interface{}, bool) {
0000000000000000000000000000000000000000;;		ent := c.evictList.Back()
0000000000000000000000000000000000000000;;		if ent != nil {
0000000000000000000000000000000000000000;;			c.removeElement(ent)
0000000000000000000000000000000000000000;;			kv := ent.Value.(*entry)
0000000000000000000000000000000000000000;;			return kv.key, kv.value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetOldest returns the oldest entry
0000000000000000000000000000000000000000;;	func (c *LRU) GetOldest() (interface{}, interface{}, bool) {
0000000000000000000000000000000000000000;;		ent := c.evictList.Back()
0000000000000000000000000000000000000000;;		if ent != nil {
0000000000000000000000000000000000000000;;			kv := ent.Value.(*entry)
0000000000000000000000000000000000000000;;			return kv.key, kv.value, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns a slice of the keys in the cache, from oldest to newest.
0000000000000000000000000000000000000000;;	func (c *LRU) Keys() []interface{} {
0000000000000000000000000000000000000000;;		keys := make([]interface{}, len(c.items))
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for ent := c.evictList.Back(); ent != nil; ent = ent.Prev() {
0000000000000000000000000000000000000000;;			keys[i] = ent.Value.(*entry).key
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return keys
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of items in the cache.
0000000000000000000000000000000000000000;;	func (c *LRU) Len() int {
0000000000000000000000000000000000000000;;		return c.evictList.Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeOldest removes the oldest item from the cache.
0000000000000000000000000000000000000000;;	func (c *LRU) removeOldest() {
0000000000000000000000000000000000000000;;		ent := c.evictList.Back()
0000000000000000000000000000000000000000;;		if ent != nil {
0000000000000000000000000000000000000000;;			c.removeElement(ent)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// removeElement is used to remove a given list element from the cache
0000000000000000000000000000000000000000;;	func (c *LRU) removeElement(e *list.Element) {
0000000000000000000000000000000000000000;;		c.evictList.Remove(e)
0000000000000000000000000000000000000000;;		kv := e.Value.(*entry)
0000000000000000000000000000000000000000;;		delete(c.items, kv.key)
0000000000000000000000000000000000000000;;		if c.onEvict != nil {
0000000000000000000000000000000000000000;;			c.onEvict(kv.key, kv.value)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
