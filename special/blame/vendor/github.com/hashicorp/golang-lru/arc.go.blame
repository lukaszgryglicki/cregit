0000000000000000000000000000000000000000;;	package lru
dc1f984f866a97e31080b22810a1488427a44cbb;Godeps/_workspace/src/github.com/hashicorp/golang-lru/arc.go[Godeps/_workspace/src/github.com/hashicorp/golang-lru/arc.go][vendor/github.com/hashicorp/golang-lru/arc.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/hashicorp/golang-lru/simplelru"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ARCCache is a thread-safe fixed size Adaptive Replacement Cache (ARC).
0000000000000000000000000000000000000000;;	// ARC is an enhancement over the standard LRU cache in that tracks both
0000000000000000000000000000000000000000;;	// frequency and recency of use. This avoids a burst in access to new
0000000000000000000000000000000000000000;;	// entries from evicting the frequently used older entries. It adds some
0000000000000000000000000000000000000000;;	// additional tracking overhead to a standard LRU cache, computationally
0000000000000000000000000000000000000000;;	// it is roughly 2x the cost, and the extra memory overhead is linear
0000000000000000000000000000000000000000;;	// with the size of the cache. ARC has been patented by IBM, but is
0000000000000000000000000000000000000000;;	// similar to the TwoQueueCache (2Q) which requires setting parameters.
0000000000000000000000000000000000000000;;	type ARCCache struct {
0000000000000000000000000000000000000000;;		size int // Size is the total capacity of the cache
0000000000000000000000000000000000000000;;		p    int // P is the dynamic preference towards T1 or T2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t1 *simplelru.LRU // T1 is the LRU for recently accessed items
0000000000000000000000000000000000000000;;		b1 *simplelru.LRU // B1 is the LRU for evictions from t1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t2 *simplelru.LRU // T2 is the LRU for frequently accessed items
0000000000000000000000000000000000000000;;		b2 *simplelru.LRU // B2 is the LRU for evictions from t2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewARC creates an ARC of the given size
0000000000000000000000000000000000000000;;	func NewARC(size int) (*ARCCache, error) {
0000000000000000000000000000000000000000;;		// Create the sub LRUs
0000000000000000000000000000000000000000;;		b1, err := simplelru.NewLRU(size, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b2, err := simplelru.NewLRU(size, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t1, err := simplelru.NewLRU(size, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t2, err := simplelru.NewLRU(size, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Initialize the ARC
0000000000000000000000000000000000000000;;		c := &ARCCache{
0000000000000000000000000000000000000000;;			size: size,
0000000000000000000000000000000000000000;;			p:    0,
0000000000000000000000000000000000000000;;			t1:   t1,
0000000000000000000000000000000000000000;;			b1:   b1,
0000000000000000000000000000000000000000;;			t2:   t2,
0000000000000000000000000000000000000000;;			b2:   b2,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get looks up a key's value from the cache.
0000000000000000000000000000000000000000;;	func (c *ARCCache) Get(key interface{}) (interface{}, bool) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Ff the value is contained in T1 (recent), then
0000000000000000000000000000000000000000;;		// promote it to T2 (frequent)
0000000000000000000000000000000000000000;;		if val, ok := c.t1.Peek(key); ok {
0000000000000000000000000000000000000000;;			c.t1.Remove(key)
0000000000000000000000000000000000000000;;			c.t2.Add(key, val)
0000000000000000000000000000000000000000;;			return val, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the value is contained in T2 (frequent)
0000000000000000000000000000000000000000;;		if val, ok := c.t2.Get(key); ok {
0000000000000000000000000000000000000000;;			return val, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// No hit
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a value to the cache.
0000000000000000000000000000000000000000;;	func (c *ARCCache) Add(key, value interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the value is contained in T1 (recent), and potentially
0000000000000000000000000000000000000000;;		// promote it to frequent T2
0000000000000000000000000000000000000000;;		if c.t1.Contains(key) {
0000000000000000000000000000000000000000;;			c.t1.Remove(key)
0000000000000000000000000000000000000000;;			c.t2.Add(key, value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if the value is already in T2 (frequent) and update it
0000000000000000000000000000000000000000;;		if c.t2.Contains(key) {
0000000000000000000000000000000000000000;;			c.t2.Add(key, value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if this value was recently evicted as part of the
0000000000000000000000000000000000000000;;		// recently used list
0000000000000000000000000000000000000000;;		if c.b1.Contains(key) {
0000000000000000000000000000000000000000;;			// T1 set is too small, increase P appropriately
0000000000000000000000000000000000000000;;			delta := 1
0000000000000000000000000000000000000000;;			b1Len := c.b1.Len()
0000000000000000000000000000000000000000;;			b2Len := c.b2.Len()
0000000000000000000000000000000000000000;;			if b2Len > b1Len {
0000000000000000000000000000000000000000;;				delta = b2Len / b1Len
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.p+delta >= c.size {
0000000000000000000000000000000000000000;;				c.p = c.size
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c.p += delta
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Potentially need to make room in the cache
0000000000000000000000000000000000000000;;			if c.t1.Len()+c.t2.Len() >= c.size {
0000000000000000000000000000000000000000;;				c.replace(false)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove from B1
0000000000000000000000000000000000000000;;			c.b1.Remove(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add the key to the frequently used list
0000000000000000000000000000000000000000;;			c.t2.Add(key, value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Check if this value was recently evicted as part of the
0000000000000000000000000000000000000000;;		// frequently used list
0000000000000000000000000000000000000000;;		if c.b2.Contains(key) {
0000000000000000000000000000000000000000;;			// T2 set is too small, decrease P appropriately
0000000000000000000000000000000000000000;;			delta := 1
0000000000000000000000000000000000000000;;			b1Len := c.b1.Len()
0000000000000000000000000000000000000000;;			b2Len := c.b2.Len()
0000000000000000000000000000000000000000;;			if b1Len > b2Len {
0000000000000000000000000000000000000000;;				delta = b1Len / b2Len
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if delta >= c.p {
0000000000000000000000000000000000000000;;				c.p = 0
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				c.p -= delta
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Potentially need to make room in the cache
0000000000000000000000000000000000000000;;			if c.t1.Len()+c.t2.Len() >= c.size {
0000000000000000000000000000000000000000;;				c.replace(true)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remove from B2
0000000000000000000000000000000000000000;;			c.b2.Remove(key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Add the key to the frequntly used list
0000000000000000000000000000000000000000;;			c.t2.Add(key, value)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Potentially need to make room in the cache
0000000000000000000000000000000000000000;;		if c.t1.Len()+c.t2.Len() >= c.size {
0000000000000000000000000000000000000000;;			c.replace(false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Keep the size of the ghost buffers trim
0000000000000000000000000000000000000000;;		if c.b1.Len() > c.size-c.p {
0000000000000000000000000000000000000000;;			c.b1.RemoveOldest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.b2.Len() > c.p {
0000000000000000000000000000000000000000;;			c.b2.RemoveOldest()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add to the recently seen list
0000000000000000000000000000000000000000;;		c.t1.Add(key, value)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// replace is used to adaptively evict from either T1 or T2
0000000000000000000000000000000000000000;;	// based on the current learned value of P
0000000000000000000000000000000000000000;;	func (c *ARCCache) replace(b2ContainsKey bool) {
0000000000000000000000000000000000000000;;		t1Len := c.t1.Len()
0000000000000000000000000000000000000000;;		if t1Len > 0 && (t1Len > c.p || (t1Len == c.p && b2ContainsKey)) {
0000000000000000000000000000000000000000;;			k, _, ok := c.t1.RemoveOldest()
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				c.b1.Add(k, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			k, _, ok := c.t2.RemoveOldest()
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				c.b2.Add(k, nil)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of cached entries
0000000000000000000000000000000000000000;;	func (c *ARCCache) Len() int {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.t1.Len() + c.t2.Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Keys returns all the cached keys
0000000000000000000000000000000000000000;;	func (c *ARCCache) Keys() []interface{} {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		k1 := c.t1.Keys()
0000000000000000000000000000000000000000;;		k2 := c.t2.Keys()
0000000000000000000000000000000000000000;;		return append(k1, k2...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove is used to purge a key from the cache
0000000000000000000000000000000000000000;;	func (c *ARCCache) Remove(key interface{}) {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		if c.t1.Remove(key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.t2.Remove(key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.b1.Remove(key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.b2.Remove(key) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Purge is used to clear the cache
0000000000000000000000000000000000000000;;	func (c *ARCCache) Purge() {
0000000000000000000000000000000000000000;;		c.lock.Lock()
0000000000000000000000000000000000000000;;		defer c.lock.Unlock()
0000000000000000000000000000000000000000;;		c.t1.Purge()
0000000000000000000000000000000000000000;;		c.t2.Purge()
0000000000000000000000000000000000000000;;		c.b1.Purge()
0000000000000000000000000000000000000000;;		c.b2.Purge()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains is used to check if the cache contains a key
0000000000000000000000000000000000000000;;	// without updating recency or frequency.
0000000000000000000000000000000000000000;;	func (c *ARCCache) Contains(key interface{}) bool {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		return c.t1.Contains(key) || c.t2.Contains(key)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Peek is used to inspect the cache value of a key
0000000000000000000000000000000000000000;;	// without updating recency or frequency.
0000000000000000000000000000000000000000;;	func (c *ARCCache) Peek(key interface{}) (interface{}, bool) {
0000000000000000000000000000000000000000;;		c.lock.RLock()
0000000000000000000000000000000000000000;;		defer c.lock.RUnlock()
0000000000000000000000000000000000000000;;		if val, ok := c.t1.Peek(key); ok {
0000000000000000000000000000000000000000;;			return val, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.t2.Peek(key)
0000000000000000000000000000000000000000;;	}
