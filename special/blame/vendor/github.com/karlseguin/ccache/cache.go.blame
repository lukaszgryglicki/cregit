0000000000000000000000000000000000000000;;	// An LRU cached aimed at high concurrency
0000000000000000000000000000000000000000;;	package ccache
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Cache struct {
0000000000000000000000000000000000000000;;		*Configuration
0000000000000000000000000000000000000000;;		list        *list.List
0000000000000000000000000000000000000000;;		size        int64
0000000000000000000000000000000000000000;;		buckets     []*bucket
0000000000000000000000000000000000000000;;		bucketMask  uint32
0000000000000000000000000000000000000000;;		deletables  chan *Item
0000000000000000000000000000000000000000;;		promotables chan *Item
0000000000000000000000000000000000000000;;		donec       chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new cache with the specified configuration
0000000000000000000000000000000000000000;;	// See ccache.Configure() for creating a configuration
0000000000000000000000000000000000000000;;	func New(config *Configuration) *Cache {
0000000000000000000000000000000000000000;;		c := &Cache{
0000000000000000000000000000000000000000;;			list:          list.New(),
0000000000000000000000000000000000000000;;			Configuration: config,
0000000000000000000000000000000000000000;;			bucketMask:    uint32(config.buckets) - 1,
0000000000000000000000000000000000000000;;			buckets:       make([]*bucket, config.buckets),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < int(config.buckets); i++ {
0000000000000000000000000000000000000000;;			c.buckets[i] = &bucket{
0000000000000000000000000000000000000000;;				lookup: make(map[string]*Item),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.restart()
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get an item from the cache. Returns nil if the item wasn't found.
0000000000000000000000000000000000000000;;	// This can return an expired item. Use item.Expired() to see if the item
0000000000000000000000000000000000000000;;	// is expired and item.TTL() to see how long until the item expires (which
0000000000000000000000000000000000000000;;	// will be negative for an already expired item).
0000000000000000000000000000000000000000;;	func (c *Cache) Get(key string) *Item {
0000000000000000000000000000000000000000;;		item := c.bucket(key).get(key)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if item.expires > time.Now().UnixNano() {
0000000000000000000000000000000000000000;;			c.promote(item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used when the cache was created with the Track() configuration option.
0000000000000000000000000000000000000000;;	// Avoid otherwise
0000000000000000000000000000000000000000;;	func (c *Cache) TrackingGet(key string) TrackedItem {
0000000000000000000000000000000000000000;;		item := c.Get(key)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return NilTracked
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		item.track()
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the value in the cache for the specified duration
0000000000000000000000000000000000000000;;	func (c *Cache) Set(key string, value interface{}, duration time.Duration) {
0000000000000000000000000000000000000000;;		c.set(key, value, duration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace the value if it exists, does not set if it doesn't.
0000000000000000000000000000000000000000;;	// Returns true if the item existed an was replaced, false otherwise.
0000000000000000000000000000000000000000;;	// Replace does not reset item's TTL
0000000000000000000000000000000000000000;;	func (c *Cache) Replace(key string, value interface{}) bool {
0000000000000000000000000000000000000000;;		item := c.bucket(key).get(key)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Set(key, value, item.TTL())
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attempts to get the value from the cache and calles fetch on a miss (missing
0000000000000000000000000000000000000000;;	// or stale item). If fetch returns an error, no value is cached and the error
0000000000000000000000000000000000000000;;	// is returned back to the caller.
0000000000000000000000000000000000000000;;	func (c *Cache) Fetch(key string, duration time.Duration, fetch func() (interface{}, error)) (*Item, error) {
0000000000000000000000000000000000000000;;		item := c.Get(key)
0000000000000000000000000000000000000000;;		if item != nil && !item.Expired() {
0000000000000000000000000000000000000000;;			return item, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value, err := fetch()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.set(key, value, duration), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove the item from the cache, return true if the item was present, false otherwise.
0000000000000000000000000000000000000000;;	func (c *Cache) Delete(key string) bool {
0000000000000000000000000000000000000000;;		item := c.bucket(key).delete(key)
0000000000000000000000000000000000000000;;		if item != nil {
0000000000000000000000000000000000000000;;			c.deletables <- item
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//this isn't thread safe. It's meant to be called from non-concurrent tests
0000000000000000000000000000000000000000;;	func (c *Cache) Clear() {
0000000000000000000000000000000000000000;;		for _, bucket := range c.buckets {
0000000000000000000000000000000000000000;;			bucket.clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.size = 0
0000000000000000000000000000000000000000;;		c.list = list.New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stops the background worker. Operations performed on the cache after Stop
0000000000000000000000000000000000000000;;	// is called are likely to panic
0000000000000000000000000000000000000000;;	func (c *Cache) Stop() {
0000000000000000000000000000000000000000;;		close(c.promotables)
0000000000000000000000000000000000000000;;		<-c.donec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) restart() {
0000000000000000000000000000000000000000;;		c.deletables = make(chan *Item, c.deleteBuffer)
0000000000000000000000000000000000000000;;		c.promotables = make(chan *Item, c.promoteBuffer)
0000000000000000000000000000000000000000;;		c.donec = make(chan struct{})
0000000000000000000000000000000000000000;;		go c.worker()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) deleteItem(bucket *bucket, item *Item) {
0000000000000000000000000000000000000000;;		bucket.delete(item.key) //stop other GETs from getting it
0000000000000000000000000000000000000000;;		c.deletables <- item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) set(key string, value interface{}, duration time.Duration) *Item {
0000000000000000000000000000000000000000;;		item, existing := c.bucket(key).set(key, value, duration)
0000000000000000000000000000000000000000;;		if existing != nil {
0000000000000000000000000000000000000000;;			c.deletables <- existing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.promote(item)
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) bucket(key string) *bucket {
0000000000000000000000000000000000000000;;		h := fnv.New32a()
0000000000000000000000000000000000000000;;		h.Write([]byte(key))
0000000000000000000000000000000000000000;;		return c.buckets[h.Sum32()&c.bucketMask]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) promote(item *Item) {
0000000000000000000000000000000000000000;;		c.promotables <- item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) worker() {
0000000000000000000000000000000000000000;;		defer close(c.donec)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case item, ok := <-c.promotables:
0000000000000000000000000000000000000000;;				if ok == false {
0000000000000000000000000000000000000000;;					goto drain
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.doPromote(item) && c.size > c.maxSize {
0000000000000000000000000000000000000000;;					c.gc()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case item := <-c.deletables:
0000000000000000000000000000000000000000;;				c.doDelete(item)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	drain:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case item := <-c.deletables:
0000000000000000000000000000000000000000;;				c.doDelete(item)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				close(c.deletables)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) doDelete(item *Item) {
0000000000000000000000000000000000000000;;		if item.element == nil {
0000000000000000000000000000000000000000;;			item.promotions = -2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			c.size -= item.size
0000000000000000000000000000000000000000;;			c.list.Remove(item.element)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) doPromote(item *Item) bool {
0000000000000000000000000000000000000000;;		//already deleted
0000000000000000000000000000000000000000;;		if item.promotions == -2 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if item.element != nil { //not a new item
0000000000000000000000000000000000000000;;			if item.shouldPromote(c.getsPerPromote) {
0000000000000000000000000000000000000000;;				c.list.MoveToFront(item.element)
0000000000000000000000000000000000000000;;				item.promotions = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.size += item.size
0000000000000000000000000000000000000000;;		item.element = c.list.PushFront(item)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Cache) gc() {
0000000000000000000000000000000000000000;;		element := c.list.Back()
0000000000000000000000000000000000000000;;		for i := 0; i < c.itemsToPrune; i++ {
0000000000000000000000000000000000000000;;			if element == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prev := element.Prev()
0000000000000000000000000000000000000000;;			item := element.Value.(*Item)
0000000000000000000000000000000000000000;;			if c.tracking == false || atomic.LoadInt32(&item.refCount) == 0 {
0000000000000000000000000000000000000000;;				c.bucket(item.key).delete(item.key)
0000000000000000000000000000000000000000;;				c.size -= item.size
0000000000000000000000000000000000000000;;				c.list.Remove(element)
0000000000000000000000000000000000000000;;				item.promotions = -2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			element = prev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
