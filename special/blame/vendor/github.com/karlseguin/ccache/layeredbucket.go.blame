0000000000000000000000000000000000000000;;	package ccache
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type layeredBucket struct {
0000000000000000000000000000000000000000;;		sync.RWMutex
0000000000000000000000000000000000000000;;		buckets map[string]*bucket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *layeredBucket) get(primary, secondary string) *Item {
0000000000000000000000000000000000000000;;		bucket := b.getSecondaryBucket(primary)
0000000000000000000000000000000000000000;;		if bucket == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bucket.get(secondary)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *layeredBucket) getSecondaryBucket(primary string) *bucket {
0000000000000000000000000000000000000000;;		b.RLock()
0000000000000000000000000000000000000000;;		bucket, exists := b.buckets[primary]
0000000000000000000000000000000000000000;;		b.RUnlock()
0000000000000000000000000000000000000000;;		if exists == false {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bucket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *layeredBucket) set(primary, secondary string, value interface{}, duration time.Duration) (*Item, *Item) {
0000000000000000000000000000000000000000;;		b.Lock()
0000000000000000000000000000000000000000;;		bkt, exists := b.buckets[primary]
0000000000000000000000000000000000000000;;		if exists == false {
0000000000000000000000000000000000000000;;			bkt = &bucket{lookup: make(map[string]*Item)}
0000000000000000000000000000000000000000;;			b.buckets[primary] = bkt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.Unlock()
0000000000000000000000000000000000000000;;		item, existing := bkt.set(secondary, value, duration)
0000000000000000000000000000000000000000;;		item.group = primary
0000000000000000000000000000000000000000;;		return item, existing
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *layeredBucket) delete(primary, secondary string) *Item {
0000000000000000000000000000000000000000;;		b.RLock()
0000000000000000000000000000000000000000;;		bucket, exists := b.buckets[primary]
0000000000000000000000000000000000000000;;		b.RUnlock()
0000000000000000000000000000000000000000;;		if exists == false {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return bucket.delete(secondary)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *layeredBucket) deleteAll(primary string, deletables chan *Item) bool {
0000000000000000000000000000000000000000;;		b.RLock()
0000000000000000000000000000000000000000;;		bucket, exists := b.buckets[primary]
0000000000000000000000000000000000000000;;		b.RUnlock()
0000000000000000000000000000000000000000;;		if exists == false {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		bucket.Lock()
0000000000000000000000000000000000000000;;		defer bucket.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if l := len(bucket.lookup); l == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for key, item := range bucket.lookup {
0000000000000000000000000000000000000000;;			delete(bucket.lookup, key)
0000000000000000000000000000000000000000;;			deletables <- item
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *layeredBucket) clear() {
0000000000000000000000000000000000000000;;		b.Lock()
0000000000000000000000000000000000000000;;		defer b.Unlock()
0000000000000000000000000000000000000000;;		for _, bucket := range b.buckets {
0000000000000000000000000000000000000000;;			bucket.clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b.buckets = make(map[string]*bucket)
0000000000000000000000000000000000000000;;	}
