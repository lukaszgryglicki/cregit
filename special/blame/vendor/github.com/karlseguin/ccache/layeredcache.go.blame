0000000000000000000000000000000000000000;;	// An LRU cached aimed at high concurrency
0000000000000000000000000000000000000000;;	package ccache
550be6508d59ea184bfb64f8ae23c177b9e6d1c9;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"container/list"
0000000000000000000000000000000000000000;;		"hash/fnv"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LayeredCache struct {
0000000000000000000000000000000000000000;;		*Configuration
0000000000000000000000000000000000000000;;		list        *list.List
0000000000000000000000000000000000000000;;		buckets     []*layeredBucket
0000000000000000000000000000000000000000;;		bucketMask  uint32
0000000000000000000000000000000000000000;;		size        int64
0000000000000000000000000000000000000000;;		deletables  chan *Item
0000000000000000000000000000000000000000;;		promotables chan *Item
0000000000000000000000000000000000000000;;		donec       chan struct{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a new layered cache with the specified configuration.
0000000000000000000000000000000000000000;;	// A layered cache used a two keys to identify a value: a primary key
0000000000000000000000000000000000000000;;	// and a secondary key. Get, Set and Delete require both a primary and
0000000000000000000000000000000000000000;;	// secondary key. However, DeleteAll requires only a primary key, deleting
0000000000000000000000000000000000000000;;	// all values that share the same primary key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Layered Cache is useful as an HTTP cache, where an HTTP purge might
0000000000000000000000000000000000000000;;	// delete multiple variants of the same resource:
0000000000000000000000000000000000000000;;	// primary key = "user/44"
0000000000000000000000000000000000000000;;	// secondary key 1 = ".json"
0000000000000000000000000000000000000000;;	// secondary key 2 = ".xml"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See ccache.Configure() for creating a configuration
0000000000000000000000000000000000000000;;	func Layered(config *Configuration) *LayeredCache {
0000000000000000000000000000000000000000;;		c := &LayeredCache{
0000000000000000000000000000000000000000;;			list:          list.New(),
0000000000000000000000000000000000000000;;			Configuration: config,
0000000000000000000000000000000000000000;;			bucketMask:    uint32(config.buckets) - 1,
0000000000000000000000000000000000000000;;			buckets:       make([]*layeredBucket, config.buckets),
0000000000000000000000000000000000000000;;			deletables:    make(chan *Item, config.deleteBuffer),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < int(config.buckets); i++ {
0000000000000000000000000000000000000000;;			c.buckets[i] = &layeredBucket{
0000000000000000000000000000000000000000;;				buckets: make(map[string]*bucket),
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.restart()
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get an item from the cache. Returns nil if the item wasn't found.
0000000000000000000000000000000000000000;;	// This can return an expired item. Use item.Expired() to see if the item
0000000000000000000000000000000000000000;;	// is expired and item.TTL() to see how long until the item expires (which
0000000000000000000000000000000000000000;;	// will be negative for an already expired item).
0000000000000000000000000000000000000000;;	func (c *LayeredCache) Get(primary, secondary string) *Item {
0000000000000000000000000000000000000000;;		item := c.bucket(primary).get(primary, secondary)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if item.expires > time.Now().UnixNano() {
0000000000000000000000000000000000000000;;			c.promote(item)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get the secondary cache for a given primary key. This operation will
0000000000000000000000000000000000000000;;	// never return nil. In the case where the primary key does not exist, a
0000000000000000000000000000000000000000;;	// new, underlying, empty bucket will be created and returned.
0000000000000000000000000000000000000000;;	func (c *LayeredCache) GetOrCreateSecondaryCache(primary string) *SecondaryCache {
0000000000000000000000000000000000000000;;		primaryBkt := c.bucket(primary)
0000000000000000000000000000000000000000;;		bkt := primaryBkt.getSecondaryBucket(primary)
0000000000000000000000000000000000000000;;		primaryBkt.Lock()
0000000000000000000000000000000000000000;;		if bkt == nil {
0000000000000000000000000000000000000000;;			bkt = &bucket{lookup: make(map[string]*Item)}
0000000000000000000000000000000000000000;;			primaryBkt.buckets[primary] = bkt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		primaryBkt.Unlock()
0000000000000000000000000000000000000000;;		return &SecondaryCache{
0000000000000000000000000000000000000000;;			bucket: bkt,
0000000000000000000000000000000000000000;;			pCache: c,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used when the cache was created with the Track() configuration option.
0000000000000000000000000000000000000000;;	// Avoid otherwise
0000000000000000000000000000000000000000;;	func (c *LayeredCache) TrackingGet(primary, secondary string) TrackedItem {
0000000000000000000000000000000000000000;;		item := c.Get(primary, secondary)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return NilTracked
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		item.track()
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the value in the cache for the specified duration
0000000000000000000000000000000000000000;;	func (c *LayeredCache) Set(primary, secondary string, value interface{}, duration time.Duration) {
0000000000000000000000000000000000000000;;		c.set(primary, secondary, value, duration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace the value if it exists, does not set if it doesn't.
0000000000000000000000000000000000000000;;	// Returns true if the item existed an was replaced, false otherwise.
0000000000000000000000000000000000000000;;	// Replace does not reset item's TTL nor does it alter its position in the LRU
0000000000000000000000000000000000000000;;	func (c *LayeredCache) Replace(primary, secondary string, value interface{}) bool {
0000000000000000000000000000000000000000;;		item := c.bucket(primary).get(primary, secondary)
0000000000000000000000000000000000000000;;		if item == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Set(primary, secondary, value, item.TTL())
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Attempts to get the value from the cache and calles fetch on a miss.
0000000000000000000000000000000000000000;;	// If fetch returns an error, no value is cached and the error is returned back
0000000000000000000000000000000000000000;;	// to the caller.
0000000000000000000000000000000000000000;;	func (c *LayeredCache) Fetch(primary, secondary string, duration time.Duration, fetch func() (interface{}, error)) (*Item, error) {
0000000000000000000000000000000000000000;;		item := c.Get(primary, secondary)
0000000000000000000000000000000000000000;;		if item != nil {
0000000000000000000000000000000000000000;;			return item, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		value, err := fetch()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.set(primary, secondary, value, duration), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove the item from the cache, return true if the item was present, false otherwise.
0000000000000000000000000000000000000000;;	func (c *LayeredCache) Delete(primary, secondary string) bool {
0000000000000000000000000000000000000000;;		item := c.bucket(primary).delete(primary, secondary)
0000000000000000000000000000000000000000;;		if item != nil {
0000000000000000000000000000000000000000;;			c.deletables <- item
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Deletes all items that share the same primary key
0000000000000000000000000000000000000000;;	func (c *LayeredCache) DeleteAll(primary string) bool {
0000000000000000000000000000000000000000;;		return c.bucket(primary).deleteAll(primary, c.deletables)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//this isn't thread safe. It's meant to be called from non-concurrent tests
0000000000000000000000000000000000000000;;	func (c *LayeredCache) Clear() {
0000000000000000000000000000000000000000;;		for _, bucket := range c.buckets {
0000000000000000000000000000000000000000;;			bucket.clear()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.size = 0
0000000000000000000000000000000000000000;;		c.list = list.New()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) Stop() {
0000000000000000000000000000000000000000;;		close(c.promotables)
0000000000000000000000000000000000000000;;		<-c.donec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) restart() {
0000000000000000000000000000000000000000;;		c.promotables = make(chan *Item, c.promoteBuffer)
0000000000000000000000000000000000000000;;		c.donec = make(chan struct{})
0000000000000000000000000000000000000000;;		go c.worker()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) set(primary, secondary string, value interface{}, duration time.Duration) *Item {
0000000000000000000000000000000000000000;;		item, existing := c.bucket(primary).set(primary, secondary, value, duration)
0000000000000000000000000000000000000000;;		if existing != nil {
0000000000000000000000000000000000000000;;			c.deletables <- existing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.promote(item)
0000000000000000000000000000000000000000;;		return item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) bucket(key string) *layeredBucket {
0000000000000000000000000000000000000000;;		h := fnv.New32a()
0000000000000000000000000000000000000000;;		h.Write([]byte(key))
0000000000000000000000000000000000000000;;		return c.buckets[h.Sum32()&c.bucketMask]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) promote(item *Item) {
0000000000000000000000000000000000000000;;		c.promotables <- item
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) worker() {
0000000000000000000000000000000000000000;;		defer close(c.donec)
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case item, ok := <-c.promotables:
0000000000000000000000000000000000000000;;				if ok == false {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.doPromote(item) && c.size > c.maxSize {
0000000000000000000000000000000000000000;;					c.gc()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case item := <-c.deletables:
0000000000000000000000000000000000000000;;				if item.element == nil {
0000000000000000000000000000000000000000;;					item.promotions = -2
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					c.size -= item.size
0000000000000000000000000000000000000000;;					c.list.Remove(item.element)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) doPromote(item *Item) bool {
0000000000000000000000000000000000000000;;		// deleted before it ever got promoted
0000000000000000000000000000000000000000;;		if item.promotions == -2 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if item.element != nil { //not a new item
0000000000000000000000000000000000000000;;			if item.shouldPromote(c.getsPerPromote) {
0000000000000000000000000000000000000000;;				c.list.MoveToFront(item.element)
0000000000000000000000000000000000000000;;				item.promotions = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.size += item.size
0000000000000000000000000000000000000000;;		item.element = c.list.PushFront(item)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *LayeredCache) gc() {
0000000000000000000000000000000000000000;;		element := c.list.Back()
0000000000000000000000000000000000000000;;		for i := 0; i < c.itemsToPrune; i++ {
0000000000000000000000000000000000000000;;			if element == nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			prev := element.Prev()
0000000000000000000000000000000000000000;;			item := element.Value.(*Item)
0000000000000000000000000000000000000000;;			if c.tracking == false || atomic.LoadInt32(&item.refCount) == 0 {
0000000000000000000000000000000000000000;;				c.bucket(item.group).delete(item.group, item.key)
0000000000000000000000000000000000000000;;				c.size -= item.size
0000000000000000000000000000000000000000;;				c.list.Remove(element)
0000000000000000000000000000000000000000;;				item.promotions = -2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			element = prev
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
