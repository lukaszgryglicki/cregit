0000000000000000000000000000000000000000;;	// Copyright 2014 Canonical Ltd.
0000000000000000000000000000000000000000;;	// Licensed under the LGPLv3 with static-linking exception.
0000000000000000000000000000000000000000;;	// See LICENCE file for details.
935e0b671fa8798cf3bf94c7249393468c9316bd;;	
0000000000000000000000000000000000000000;;	// Package ratelimit provides an efficient token bucket implementation
0000000000000000000000000000000000000000;;	// that can be used to limit the rate of arbitrary things.
0000000000000000000000000000000000000000;;	// See http://en.wikipedia.org/wiki/Token_bucket.
0000000000000000000000000000000000000000;;	package ratelimit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Bucket represents a token bucket that fills at a predetermined rate.
0000000000000000000000000000000000000000;;	// Methods on Bucket may be called concurrently.
0000000000000000000000000000000000000000;;	type Bucket struct {
0000000000000000000000000000000000000000;;		startTime    time.Time
0000000000000000000000000000000000000000;;		capacity     int64
0000000000000000000000000000000000000000;;		quantum      int64
0000000000000000000000000000000000000000;;		fillInterval time.Duration
0000000000000000000000000000000000000000;;		clock        Clock
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The mutex guards the fields following it.
0000000000000000000000000000000000000000;;		mu sync.Mutex
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// avail holds the number of available tokens
0000000000000000000000000000000000000000;;		// in the bucket, as of availTick ticks from startTime.
0000000000000000000000000000000000000000;;		// It will be negative when there are consumers
0000000000000000000000000000000000000000;;		// waiting for tokens.
0000000000000000000000000000000000000000;;		avail     int64
0000000000000000000000000000000000000000;;		availTick int64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clock is used to inject testable fakes.
0000000000000000000000000000000000000000;;	type Clock interface {
0000000000000000000000000000000000000000;;		Now() time.Time
0000000000000000000000000000000000000000;;		Sleep(d time.Duration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// realClock implements Clock in terms of standard time functions.
0000000000000000000000000000000000000000;;	type realClock struct{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Now is identical to time.Now.
0000000000000000000000000000000000000000;;	func (realClock) Now() time.Time {
0000000000000000000000000000000000000000;;		return time.Now()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sleep is identical to time.Sleep.
0000000000000000000000000000000000000000;;	func (realClock) Sleep(d time.Duration) {
0000000000000000000000000000000000000000;;		time.Sleep(d)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBucket returns a new token bucket that fills at the
0000000000000000000000000000000000000000;;	// rate of one token every fillInterval, up to the given
0000000000000000000000000000000000000000;;	// maximum capacity. Both arguments must be
0000000000000000000000000000000000000000;;	// positive. The bucket is initially full.
0000000000000000000000000000000000000000;;	func NewBucket(fillInterval time.Duration, capacity int64) *Bucket {
0000000000000000000000000000000000000000;;		return NewBucketWithClock(fillInterval, capacity, realClock{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBucketWithClock is identical to NewBucket but injects a testable clock
0000000000000000000000000000000000000000;;	// interface.
0000000000000000000000000000000000000000;;	func NewBucketWithClock(fillInterval time.Duration, capacity int64, clock Clock) *Bucket {
0000000000000000000000000000000000000000;;		return NewBucketWithQuantumAndClock(fillInterval, capacity, 1, clock)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// rateMargin specifes the allowed variance of actual
0000000000000000000000000000000000000000;;	// rate from specified rate. 1% seems reasonable.
0000000000000000000000000000000000000000;;	const rateMargin = 0.01
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBucketWithRate returns a token bucket that fills the bucket
0000000000000000000000000000000000000000;;	// at the rate of rate tokens per second up to the given
0000000000000000000000000000000000000000;;	// maximum capacity. Because of limited clock resolution,
0000000000000000000000000000000000000000;;	// at high rates, the actual rate may be up to 1% different from the
0000000000000000000000000000000000000000;;	// specified rate.
0000000000000000000000000000000000000000;;	func NewBucketWithRate(rate float64, capacity int64) *Bucket {
0000000000000000000000000000000000000000;;		return NewBucketWithRateAndClock(rate, capacity, realClock{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBucketWithRateAndClock is identical to NewBucketWithRate but injects a
0000000000000000000000000000000000000000;;	// testable clock interface.
0000000000000000000000000000000000000000;;	func NewBucketWithRateAndClock(rate float64, capacity int64, clock Clock) *Bucket {
0000000000000000000000000000000000000000;;		for quantum := int64(1); quantum < 1<<50; quantum = nextQuantum(quantum) {
0000000000000000000000000000000000000000;;			fillInterval := time.Duration(1e9 * float64(quantum) / rate)
0000000000000000000000000000000000000000;;			if fillInterval <= 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			tb := NewBucketWithQuantumAndClock(fillInterval, capacity, quantum, clock)
0000000000000000000000000000000000000000;;			if diff := math.Abs(tb.Rate() - rate); diff/rate <= rateMargin {
0000000000000000000000000000000000000000;;				return tb
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("cannot find suitable quantum for " + strconv.FormatFloat(rate, 'g', -1, 64))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// nextQuantum returns the next quantum to try after q.
0000000000000000000000000000000000000000;;	// We grow the quantum exponentially, but slowly, so we
0000000000000000000000000000000000000000;;	// get a good fit in the lower numbers.
0000000000000000000000000000000000000000;;	func nextQuantum(q int64) int64 {
0000000000000000000000000000000000000000;;		q1 := q * 11 / 10
0000000000000000000000000000000000000000;;		if q1 == q {
0000000000000000000000000000000000000000;;			q1++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBucketWithQuantum is similar to NewBucket, but allows
0000000000000000000000000000000000000000;;	// the specification of the quantum size - quantum tokens
0000000000000000000000000000000000000000;;	// are added every fillInterval.
0000000000000000000000000000000000000000;;	func NewBucketWithQuantum(fillInterval time.Duration, capacity, quantum int64) *Bucket {
0000000000000000000000000000000000000000;;		return NewBucketWithQuantumAndClock(fillInterval, capacity, quantum, realClock{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewBucketWithQuantumAndClock is identical to NewBucketWithQuantum but injects
0000000000000000000000000000000000000000;;	// a testable clock interface.
0000000000000000000000000000000000000000;;	func NewBucketWithQuantumAndClock(fillInterval time.Duration, capacity, quantum int64, clock Clock) *Bucket {
0000000000000000000000000000000000000000;;		if fillInterval <= 0 {
0000000000000000000000000000000000000000;;			panic("token bucket fill interval is not > 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if capacity <= 0 {
0000000000000000000000000000000000000000;;			panic("token bucket capacity is not > 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if quantum <= 0 {
0000000000000000000000000000000000000000;;			panic("token bucket quantum is not > 0")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Bucket{
0000000000000000000000000000000000000000;;			clock:        clock,
0000000000000000000000000000000000000000;;			startTime:    clock.Now(),
0000000000000000000000000000000000000000;;			capacity:     capacity,
0000000000000000000000000000000000000000;;			quantum:      quantum,
0000000000000000000000000000000000000000;;			avail:        capacity,
0000000000000000000000000000000000000000;;			fillInterval: fillInterval,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wait takes count tokens from the bucket, waiting until they are
0000000000000000000000000000000000000000;;	// available.
0000000000000000000000000000000000000000;;	func (tb *Bucket) Wait(count int64) {
0000000000000000000000000000000000000000;;		if d := tb.Take(count); d > 0 {
0000000000000000000000000000000000000000;;			tb.clock.Sleep(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitMaxDuration is like Wait except that it will
0000000000000000000000000000000000000000;;	// only take tokens from the bucket if it needs to wait
0000000000000000000000000000000000000000;;	// for no greater than maxWait. It reports whether
0000000000000000000000000000000000000000;;	// any tokens have been removed from the bucket
0000000000000000000000000000000000000000;;	// If no tokens have been removed, it returns immediately.
0000000000000000000000000000000000000000;;	func (tb *Bucket) WaitMaxDuration(count int64, maxWait time.Duration) bool {
0000000000000000000000000000000000000000;;		d, ok := tb.TakeMaxDuration(count, maxWait)
0000000000000000000000000000000000000000;;		if d > 0 {
0000000000000000000000000000000000000000;;			tb.clock.Sleep(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const infinityDuration time.Duration = 0x7fffffffffffffff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Take takes count tokens from the bucket without blocking. It returns
0000000000000000000000000000000000000000;;	// the time that the caller should wait until the tokens are actually
0000000000000000000000000000000000000000;;	// available.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note that if the request is irrevocable - there is no way to return
0000000000000000000000000000000000000000;;	// tokens to the bucket once this method commits us to taking them.
0000000000000000000000000000000000000000;;	func (tb *Bucket) Take(count int64) time.Duration {
0000000000000000000000000000000000000000;;		d, _ := tb.take(tb.clock.Now(), count, infinityDuration)
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TakeMaxDuration is like Take, except that
0000000000000000000000000000000000000000;;	// it will only take tokens from the bucket if the wait
0000000000000000000000000000000000000000;;	// time for the tokens is no greater than maxWait.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If it would take longer than maxWait for the tokens
0000000000000000000000000000000000000000;;	// to become available, it does nothing and reports false,
0000000000000000000000000000000000000000;;	// otherwise it returns the time that the caller should
0000000000000000000000000000000000000000;;	// wait until the tokens are actually available, and reports
0000000000000000000000000000000000000000;;	// true.
0000000000000000000000000000000000000000;;	func (tb *Bucket) TakeMaxDuration(count int64, maxWait time.Duration) (time.Duration, bool) {
0000000000000000000000000000000000000000;;		return tb.take(tb.clock.Now(), count, maxWait)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TakeAvailable takes up to count immediately available tokens from the
0000000000000000000000000000000000000000;;	// bucket. It returns the number of tokens removed, or zero if there are
0000000000000000000000000000000000000000;;	// no available tokens. It does not block.
0000000000000000000000000000000000000000;;	func (tb *Bucket) TakeAvailable(count int64) int64 {
0000000000000000000000000000000000000000;;		return tb.takeAvailable(tb.clock.Now(), count)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// takeAvailable is the internal version of TakeAvailable - it takes the
0000000000000000000000000000000000000000;;	// current time as an argument to enable easy testing.
0000000000000000000000000000000000000000;;	func (tb *Bucket) takeAvailable(now time.Time, count int64) int64 {
0000000000000000000000000000000000000000;;		if count <= 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tb.mu.Lock()
0000000000000000000000000000000000000000;;		defer tb.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tb.adjust(now)
0000000000000000000000000000000000000000;;		if tb.avail <= 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if count > tb.avail {
0000000000000000000000000000000000000000;;			count = tb.avail
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tb.avail -= count
0000000000000000000000000000000000000000;;		return count
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Available returns the number of available tokens. It will be negative
0000000000000000000000000000000000000000;;	// when there are consumers waiting for tokens. Note that if this
0000000000000000000000000000000000000000;;	// returns greater than zero, it does not guarantee that calls that take
0000000000000000000000000000000000000000;;	// tokens from the buffer will succeed, as the number of available
0000000000000000000000000000000000000000;;	// tokens could have changed in the meantime. This method is intended
0000000000000000000000000000000000000000;;	// primarily for metrics reporting and debugging.
0000000000000000000000000000000000000000;;	func (tb *Bucket) Available() int64 {
0000000000000000000000000000000000000000;;		return tb.available(tb.clock.Now())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// available is the internal version of available - it takes the current time as
0000000000000000000000000000000000000000;;	// an argument to enable easy testing.
0000000000000000000000000000000000000000;;	func (tb *Bucket) available(now time.Time) int64 {
0000000000000000000000000000000000000000;;		tb.mu.Lock()
0000000000000000000000000000000000000000;;		defer tb.mu.Unlock()
0000000000000000000000000000000000000000;;		tb.adjust(now)
0000000000000000000000000000000000000000;;		return tb.avail
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Capacity returns the capacity that the bucket was created with.
0000000000000000000000000000000000000000;;	func (tb *Bucket) Capacity() int64 {
0000000000000000000000000000000000000000;;		return tb.capacity
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rate returns the fill rate of the bucket, in tokens per second.
0000000000000000000000000000000000000000;;	func (tb *Bucket) Rate() float64 {
0000000000000000000000000000000000000000;;		return 1e9 * float64(tb.quantum) / float64(tb.fillInterval)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// take is the internal version of Take - it takes the current time as
0000000000000000000000000000000000000000;;	// an argument to enable easy testing.
0000000000000000000000000000000000000000;;	func (tb *Bucket) take(now time.Time, count int64, maxWait time.Duration) (time.Duration, bool) {
0000000000000000000000000000000000000000;;		if count <= 0 {
0000000000000000000000000000000000000000;;			return 0, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tb.mu.Lock()
0000000000000000000000000000000000000000;;		defer tb.mu.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentTick := tb.adjust(now)
0000000000000000000000000000000000000000;;		avail := tb.avail - count
0000000000000000000000000000000000000000;;		if avail >= 0 {
0000000000000000000000000000000000000000;;			tb.avail = avail
0000000000000000000000000000000000000000;;			return 0, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Round up the missing tokens to the nearest multiple
0000000000000000000000000000000000000000;;		// of quantum - the tokens won't be available until
0000000000000000000000000000000000000000;;		// that tick.
0000000000000000000000000000000000000000;;		endTick := currentTick + (-avail+tb.quantum-1)/tb.quantum
0000000000000000000000000000000000000000;;		endTime := tb.startTime.Add(time.Duration(endTick) * tb.fillInterval)
0000000000000000000000000000000000000000;;		waitTime := endTime.Sub(now)
0000000000000000000000000000000000000000;;		if waitTime > maxWait {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tb.avail = avail
0000000000000000000000000000000000000000;;		return waitTime, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// adjust adjusts the current bucket capacity based on the current time.
0000000000000000000000000000000000000000;;	// It returns the current tick.
0000000000000000000000000000000000000000;;	func (tb *Bucket) adjust(now time.Time) (currentTick int64) {
0000000000000000000000000000000000000000;;		currentTick = int64(now.Sub(tb.startTime) / tb.fillInterval)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tb.avail >= tb.capacity {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tb.avail += (currentTick - tb.availTick) * tb.quantum
0000000000000000000000000000000000000000;;		if tb.avail > tb.capacity {
0000000000000000000000000000000000000000;;			tb.avail = tb.capacity
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		tb.availTick = currentTick
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
