0000000000000000000000000000000000000000;;	// Copyright 2014 Dario Castañé. All rights reserved.
0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
383101117971b41477d8721be12d3ae8a8a46839;Godeps/_workspace/src/github.com/imdario/mergo/map.go[Godeps/_workspace/src/github.com/imdario/mergo/map.go][vendor/github.com/imdario/mergo/map.go];	
0000000000000000000000000000000000000000;;	// Based on src/pkg/reflect/deepequal.go from official
0000000000000000000000000000000000000000;;	// golang's stdlib.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mergo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"unicode"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func changeInitialCase(s string, mapper func(rune) rune) string {
0000000000000000000000000000000000000000;;		if s == "" {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, n := utf8.DecodeRuneInString(s)
0000000000000000000000000000000000000000;;		return string(mapper(r)) + s[n:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isExported(field reflect.StructField) bool {
0000000000000000000000000000000000000000;;		r, _ := utf8.DecodeRuneInString(field.Name)
0000000000000000000000000000000000000000;;		return r >= 'A' && r <= 'Z'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Traverses recursively both values, assigning src's fields values to dst.
0000000000000000000000000000000000000000;;	// The map argument tracks comparisons that have already been seen, which allows
0000000000000000000000000000000000000000;;	// short circuiting on recursive types.
0000000000000000000000000000000000000000;;	func deepMap(dst, src reflect.Value, visited map[uintptr]*visit, depth int) (err error) {
0000000000000000000000000000000000000000;;		if dst.CanAddr() {
0000000000000000000000000000000000000000;;			addr := dst.UnsafeAddr()
0000000000000000000000000000000000000000;;			h := 17 * addr
0000000000000000000000000000000000000000;;			seen := visited[h]
0000000000000000000000000000000000000000;;			typ := dst.Type()
0000000000000000000000000000000000000000;;			for p := seen; p != nil; p = p.next {
0000000000000000000000000000000000000000;;				if p.ptr == addr && p.typ == typ {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Remember, remember...
0000000000000000000000000000000000000000;;			visited[h] = &visit{addr, typ, seen}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		zeroValue := reflect.Value{}
0000000000000000000000000000000000000000;;		switch dst.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			dstMap := dst.Interface().(map[string]interface{})
0000000000000000000000000000000000000000;;			for i, n := 0, src.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;				srcType := src.Type()
0000000000000000000000000000000000000000;;				field := srcType.Field(i)
0000000000000000000000000000000000000000;;				if !isExported(field) {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				fieldName := field.Name
0000000000000000000000000000000000000000;;				fieldName = changeInitialCase(fieldName, unicode.ToLower)
0000000000000000000000000000000000000000;;				if v, ok := dstMap[fieldName]; !ok || isEmptyValue(reflect.ValueOf(v)) {
0000000000000000000000000000000000000000;;					dstMap[fieldName] = src.Field(i).Interface()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			srcMap := src.Interface().(map[string]interface{})
0000000000000000000000000000000000000000;;			for key := range srcMap {
0000000000000000000000000000000000000000;;				srcValue := srcMap[key]
0000000000000000000000000000000000000000;;				fieldName := changeInitialCase(key, unicode.ToUpper)
0000000000000000000000000000000000000000;;				dstElement := dst.FieldByName(fieldName)
0000000000000000000000000000000000000000;;				if dstElement == zeroValue {
0000000000000000000000000000000000000000;;					// We discard it because the field doesn't exist.
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				srcElement := reflect.ValueOf(srcValue)
0000000000000000000000000000000000000000;;				dstKind := dstElement.Kind()
0000000000000000000000000000000000000000;;				srcKind := srcElement.Kind()
0000000000000000000000000000000000000000;;				if srcKind == reflect.Ptr && dstKind != reflect.Ptr {
0000000000000000000000000000000000000000;;					srcElement = srcElement.Elem()
0000000000000000000000000000000000000000;;					srcKind = reflect.TypeOf(srcElement.Interface()).Kind()
0000000000000000000000000000000000000000;;				} else if dstKind == reflect.Ptr {
0000000000000000000000000000000000000000;;					// Can this work? I guess it can't.
0000000000000000000000000000000000000000;;					if srcKind != reflect.Ptr && srcElement.CanAddr() {
0000000000000000000000000000000000000000;;						srcPtr := srcElement.Addr()
0000000000000000000000000000000000000000;;						srcElement = reflect.ValueOf(srcPtr)
0000000000000000000000000000000000000000;;						srcKind = reflect.Ptr
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !srcElement.IsValid() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if srcKind == dstKind {
0000000000000000000000000000000000000000;;					if err = deepMerge(dstElement, srcElement, visited, depth+1); err != nil {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if srcKind == reflect.Map {
0000000000000000000000000000000000000000;;						if err = deepMap(dstElement, srcElement, visited, depth+1); err != nil {
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						return fmt.Errorf("type mismatch on %s field: found %v, expected %v", fieldName, srcKind, dstKind)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map sets fields' values in dst from src.
0000000000000000000000000000000000000000;;	// src can be a map with string keys or a struct. dst must be the opposite:
0000000000000000000000000000000000000000;;	// if src is a map, dst must be a valid pointer to struct. If src is a struct,
0000000000000000000000000000000000000000;;	// dst must be map[string]interface{}.
0000000000000000000000000000000000000000;;	// It won't merge unexported (private) fields and will do recursively
0000000000000000000000000000000000000000;;	// any exported field.
0000000000000000000000000000000000000000;;	// If dst is a map, keys will be src fields' names in lower camel case.
0000000000000000000000000000000000000000;;	// Missing key in src that doesn't match a field in dst will be skipped. This
0000000000000000000000000000000000000000;;	// doesn't apply if dst is a map.
0000000000000000000000000000000000000000;;	// This is separated method from Merge because it is cleaner and it keeps sane
0000000000000000000000000000000000000000;;	// semantics: merging equal types, mapping different (restricted) types.
0000000000000000000000000000000000000000;;	func Map(dst, src interface{}) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			vDst, vSrc reflect.Value
0000000000000000000000000000000000000000;;			err        error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if vDst, vSrc, err = resolveValues(dst, src); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// To be friction-less, we redirect equal-type arguments
0000000000000000000000000000000000000000;;		// to deepMerge. Only because arguments can be anything.
0000000000000000000000000000000000000000;;		if vSrc.Kind() == vDst.Kind() {
0000000000000000000000000000000000000000;;			return deepMerge(vDst, vSrc, make(map[uintptr]*visit), 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch vSrc.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if vDst.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;				return ErrExpectedMapAsDestination
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if vDst.Kind() != reflect.Struct {
0000000000000000000000000000000000000000;;				return ErrExpectedStructAsDestination
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrNotSupported
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return deepMap(vDst, vSrc, make(map[uintptr]*visit), 0)
0000000000000000000000000000000000000000;;	}
