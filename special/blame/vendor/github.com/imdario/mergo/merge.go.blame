0000000000000000000000000000000000000000;;	// Copyright 2013 Dario Castañé. All rights reserved.
0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
383101117971b41477d8721be12d3ae8a8a46839;Godeps/_workspace/src/github.com/imdario/mergo/merge.go[Godeps/_workspace/src/github.com/imdario/mergo/merge.go][vendor/github.com/imdario/mergo/merge.go];	
0000000000000000000000000000000000000000;;	// Based on src/pkg/reflect/deepequal.go from official
0000000000000000000000000000000000000000;;	// golang's stdlib.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mergo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Traverses recursively both values, assigning src's fields values to dst.
0000000000000000000000000000000000000000;;	// The map argument tracks comparisons that have already been seen, which allows
0000000000000000000000000000000000000000;;	// short circuiting on recursive types.
0000000000000000000000000000000000000000;;	func deepMerge(dst, src reflect.Value, visited map[uintptr]*visit, depth int) (err error) {
0000000000000000000000000000000000000000;;		if !src.IsValid() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dst.CanAddr() {
0000000000000000000000000000000000000000;;			addr := dst.UnsafeAddr()
0000000000000000000000000000000000000000;;			h := 17 * addr
0000000000000000000000000000000000000000;;			seen := visited[h]
0000000000000000000000000000000000000000;;			typ := dst.Type()
0000000000000000000000000000000000000000;;			for p := seen; p != nil; p = p.next {
0000000000000000000000000000000000000000;;				if p.ptr == addr && p.typ == typ {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Remember, remember...
0000000000000000000000000000000000000000;;			visited[h] = &visit{addr, typ, seen}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch dst.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i, n := 0, dst.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;				if err = deepMerge(dst.Field(i), src.Field(i), visited, depth+1); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			for _, key := range src.MapKeys() {
0000000000000000000000000000000000000000;;				srcElement := src.MapIndex(key)
0000000000000000000000000000000000000000;;				if !srcElement.IsValid() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				dstElement := dst.MapIndex(key)
0000000000000000000000000000000000000000;;				switch reflect.TypeOf(srcElement.Interface()).Kind() {
0000000000000000000000000000000000000000;;				case reflect.Struct:
0000000000000000000000000000000000000000;;					fallthrough
0000000000000000000000000000000000000000;;				case reflect.Map:
0000000000000000000000000000000000000000;;					if err = deepMerge(dstElement, srcElement, visited, depth+1); err != nil {
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !dstElement.IsValid() {
0000000000000000000000000000000000000000;;					dst.SetMapIndex(key, srcElement)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if src.IsNil() {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			} else if dst.IsNil() {
0000000000000000000000000000000000000000;;				if dst.CanSet() && isEmptyValue(dst) {
0000000000000000000000000000000000000000;;					dst.Set(src)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if err = deepMerge(dst.Elem(), src.Elem(), visited, depth+1); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if dst.CanSet() && !isEmptyValue(src) {
0000000000000000000000000000000000000000;;				dst.Set(src)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Merge sets fields' values in dst from src if they have a zero
0000000000000000000000000000000000000000;;	// value of their type.
0000000000000000000000000000000000000000;;	// dst and src must be valid same-type structs and dst must be
0000000000000000000000000000000000000000;;	// a pointer to struct.
0000000000000000000000000000000000000000;;	// It won't merge unexported (private) fields and will do recursively
0000000000000000000000000000000000000000;;	// any exported field.
0000000000000000000000000000000000000000;;	func Merge(dst, src interface{}) error {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			vDst, vSrc reflect.Value
0000000000000000000000000000000000000000;;			err        error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if vDst, vSrc, err = resolveValues(dst, src); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vDst.Type() != vSrc.Type() {
0000000000000000000000000000000000000000;;			return ErrDifferentArgumentsTypes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return deepMerge(vDst, vSrc, make(map[uintptr]*visit), 0)
0000000000000000000000000000000000000000;;	}
