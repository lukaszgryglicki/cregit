0000000000000000000000000000000000000000;;	// Copyright 2013 Dario Castañé. All rights reserved.
0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
383101117971b41477d8721be12d3ae8a8a46839;Godeps/_workspace/src/github.com/imdario/mergo/mergo.go[Godeps/_workspace/src/github.com/imdario/mergo/mergo.go][vendor/github.com/imdario/mergo/mergo.go];	
0000000000000000000000000000000000000000;;	// Based on src/pkg/reflect/deepequal.go from official
0000000000000000000000000000000000000000;;	// golang's stdlib.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package mergo
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errors reported by Mergo when it finds invalid arguments.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrNilArguments                = errors.New("src and dst must not be nil")
0000000000000000000000000000000000000000;;		ErrDifferentArgumentsTypes     = errors.New("src and dst must be of same type")
0000000000000000000000000000000000000000;;		ErrNotSupported                = errors.New("only structs and maps are supported")
0000000000000000000000000000000000000000;;		ErrExpectedMapAsDestination    = errors.New("dst was expected to be a map")
0000000000000000000000000000000000000000;;		ErrExpectedStructAsDestination = errors.New("dst was expected to be a struct")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// During deepMerge, must keep track of checks that are
0000000000000000000000000000000000000000;;	// in progress.  The comparison algorithm assumes that all
0000000000000000000000000000000000000000;;	// checks in progress are true when it reencounters them.
0000000000000000000000000000000000000000;;	// Visited are stored in a map indexed by 17 * a1 + a2;
0000000000000000000000000000000000000000;;	type visit struct {
0000000000000000000000000000000000000000;;		ptr  uintptr
0000000000000000000000000000000000000000;;		typ  reflect.Type
0000000000000000000000000000000000000000;;		next *visit
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From src/pkg/encoding/json.
0000000000000000000000000000000000000000;;	func isEmptyValue(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array, reflect.Map, reflect.Slice, reflect.String:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Ptr:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func resolveValues(dst, src interface{}) (vDst, vSrc reflect.Value, err error) {
0000000000000000000000000000000000000000;;		if dst == nil || src == nil {
0000000000000000000000000000000000000000;;			err = ErrNilArguments
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vDst = reflect.ValueOf(dst).Elem()
0000000000000000000000000000000000000000;;		if vDst.Kind() != reflect.Struct && vDst.Kind() != reflect.Map {
0000000000000000000000000000000000000000;;			err = ErrNotSupported
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		vSrc = reflect.ValueOf(src)
0000000000000000000000000000000000000000;;		// We check if vSrc is a pointer to dereference it.
0000000000000000000000000000000000000000;;		if vSrc.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			vSrc = vSrc.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Traverses recursively both values, assigning src's fields values to dst.
0000000000000000000000000000000000000000;;	// The map argument tracks comparisons that have already been seen, which allows
0000000000000000000000000000000000000000;;	// short circuiting on recursive types.
0000000000000000000000000000000000000000;;	func deeper(dst, src reflect.Value, visited map[uintptr]*visit, depth int) (err error) {
0000000000000000000000000000000000000000;;		if dst.CanAddr() {
0000000000000000000000000000000000000000;;			addr := dst.UnsafeAddr()
0000000000000000000000000000000000000000;;			h := 17 * addr
0000000000000000000000000000000000000000;;			seen := visited[h]
0000000000000000000000000000000000000000;;			typ := dst.Type()
0000000000000000000000000000000000000000;;			for p := seen; p != nil; p = p.next {
0000000000000000000000000000000000000000;;				if p.ptr == addr && p.typ == typ {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Remember, remember...
0000000000000000000000000000000000000000;;			visited[h] = &visit{addr, typ, seen}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return // TODO refactor
0000000000000000000000000000000000000000;;	}
