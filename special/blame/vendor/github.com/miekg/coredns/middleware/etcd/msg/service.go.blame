0000000000000000000000000000000000000000;;	// Package msg defines the Service structure which is used for service discovery.
0000000000000000000000000000000000000000;;	package msg
b79311728c00c3c2b5b40b134fcc82ec5fa0079a;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/miekg/dns"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Service defines a discoverable service in etcd. It is the rdata from a SRV
0000000000000000000000000000000000000000;;	// record, but with a twist.  Host (Target in SRV) must be a domain name, but
0000000000000000000000000000000000000000;;	// if it looks like an IP address (4/6), we will treat it like an IP address.
0000000000000000000000000000000000000000;;	type Service struct {
0000000000000000000000000000000000000000;;		Host     string `json:"host,omitempty"`
0000000000000000000000000000000000000000;;		Port     int    `json:"port,omitempty"`
0000000000000000000000000000000000000000;;		Priority int    `json:"priority,omitempty"`
0000000000000000000000000000000000000000;;		Weight   int    `json:"weight,omitempty"`
0000000000000000000000000000000000000000;;		Text     string `json:"text,omitempty"`
0000000000000000000000000000000000000000;;		Mail     bool   `json:"mail,omitempty"` // Be an MX record. Priority becomes Preference.
0000000000000000000000000000000000000000;;		TTL      uint32 `json:"ttl,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// When a SRV record with a "Host: IP-address" is added, we synthesize
0000000000000000000000000000000000000000;;		// a srv.Target domain name.  Normally we convert the full Key where
0000000000000000000000000000000000000000;;		// the record lives to a DNS name and use this as the srv.Target.  When
0000000000000000000000000000000000000000;;		// TargetStrip > 0 we strip the left most TargetStrip labels from the
0000000000000000000000000000000000000000;;		// DNS name.
0000000000000000000000000000000000000000;;		TargetStrip int `json:"targetstrip,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Group is used to group (or *not* to group) different services
0000000000000000000000000000000000000000;;		// together. Services with an identical Group are returned in the same
0000000000000000000000000000000000000000;;		// answer.
0000000000000000000000000000000000000000;;		Group string `json:"group,omitempty"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Etcd key where we found this service and ignored from json un-/marshalling
0000000000000000000000000000000000000000;;		Key string `json:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RR returns an RR representation of s. It is in a condensed form to minimize space
0000000000000000000000000000000000000000;;	// when this is returned in a DNS message.
0000000000000000000000000000000000000000;;	// The RR will look like:
0000000000000000000000000000000000000000;;	//	1.rails.production.east.skydns.local. 300 CH TXT "service1.example.com:8080(10,0,,false)[0,]"
0000000000000000000000000000000000000000;;	//                      etcd Key              Ttl               Host:Port          <   see below   >
0000000000000000000000000000000000000000;;	// between parens: (Priority, Weight, Text (only first 200 bytes!), Mail)
0000000000000000000000000000000000000000;;	// between blockquotes: [TargetStrip,Group]
0000000000000000000000000000000000000000;;	// If the record is synthesised by CoreDNS (i.e. no lookup in etcd happened):
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	TODO(miek): what to put here?
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (s *Service) RR() *dns.TXT {
0000000000000000000000000000000000000000;;		l := len(s.Text)
0000000000000000000000000000000000000000;;		if l > 200 {
0000000000000000000000000000000000000000;;			l = 200
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t := new(dns.TXT)
0000000000000000000000000000000000000000;;		t.Hdr.Class = dns.ClassCHAOS
0000000000000000000000000000000000000000;;		t.Hdr.Ttl = s.TTL
0000000000000000000000000000000000000000;;		t.Hdr.Rrtype = dns.TypeTXT
0000000000000000000000000000000000000000;;		t.Hdr.Name = Domain(s.Key)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Txt = make([]string, 1)
0000000000000000000000000000000000000000;;		t.Txt[0] = fmt.Sprintf("%s:%d(%d,%d,%s,%t)[%d,%s]",
0000000000000000000000000000000000000000;;			s.Host, s.Port,
0000000000000000000000000000000000000000;;			s.Priority, s.Weight, s.Text[:l], s.Mail,
0000000000000000000000000000000000000000;;			s.TargetStrip, s.Group)
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSRV returns a new SRV record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewSRV(name string, weight uint16) *dns.SRV {
0000000000000000000000000000000000000000;;		host := targetStrip(dns.Fqdn(s.Host), s.TargetStrip)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &dns.SRV{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypeSRV, Class: dns.ClassINET, Ttl: s.TTL},
0000000000000000000000000000000000000000;;			Priority: uint16(s.Priority), Weight: weight, Port: uint16(s.Port), Target: dns.Fqdn(host)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewMX returns a new MX record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewMX(name string) *dns.MX {
0000000000000000000000000000000000000000;;		host := targetStrip(dns.Fqdn(s.Host), s.TargetStrip)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &dns.MX{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypeMX, Class: dns.ClassINET, Ttl: s.TTL},
0000000000000000000000000000000000000000;;			Preference: uint16(s.Priority), Mx: host}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewA returns a new A record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewA(name string, ip net.IP) *dns.A {
0000000000000000000000000000000000000000;;		return &dns.A{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypeA, Class: dns.ClassINET, Ttl: s.TTL}, A: ip}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewAAAA returns a new AAAA record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewAAAA(name string, ip net.IP) *dns.AAAA {
0000000000000000000000000000000000000000;;		return &dns.AAAA{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypeAAAA, Class: dns.ClassINET, Ttl: s.TTL}, AAAA: ip}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewCNAME returns a new CNAME record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewCNAME(name string, target string) *dns.CNAME {
0000000000000000000000000000000000000000;;		return &dns.CNAME{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypeCNAME, Class: dns.ClassINET, Ttl: s.TTL}, Target: dns.Fqdn(target)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewTXT returns a new TXT record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewTXT(name string) *dns.TXT {
0000000000000000000000000000000000000000;;		return &dns.TXT{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypeTXT, Class: dns.ClassINET, Ttl: s.TTL}, Txt: split255(s.Text)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPTR returns a new PTR record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewPTR(name string, target string) *dns.PTR {
0000000000000000000000000000000000000000;;		return &dns.PTR{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypePTR, Class: dns.ClassINET, Ttl: s.TTL}, Ptr: dns.Fqdn(target)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNS returns a new NS record based on the Service.
0000000000000000000000000000000000000000;;	func (s *Service) NewNS(name string) *dns.NS {
0000000000000000000000000000000000000000;;		host := targetStrip(dns.Fqdn(s.Host), s.TargetStrip)
0000000000000000000000000000000000000000;;		return &dns.NS{Hdr: dns.RR_Header{Name: name, Rrtype: dns.TypeNS, Class: dns.ClassINET, Ttl: s.TTL}, Ns: host}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Group checks the services in sx, it looks for a Group attribute on the shortest
0000000000000000000000000000000000000000;;	// keys. If there are multiple shortest keys *and* the group attribute disagrees (and
0000000000000000000000000000000000000000;;	// is not empty), we don't consider it a group.
0000000000000000000000000000000000000000;;	// If a group is found, only services with *that* group (or no group) will be returned.
0000000000000000000000000000000000000000;;	func Group(sx []Service) []Service {
0000000000000000000000000000000000000000;;		if len(sx) == 0 {
0000000000000000000000000000000000000000;;			return sx
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Shortest key with group attribute sets the group for this set.
0000000000000000000000000000000000000000;;		group := sx[0].Group
0000000000000000000000000000000000000000;;		slashes := strings.Count(sx[0].Key, "/")
0000000000000000000000000000000000000000;;		length := make([]int, len(sx))
0000000000000000000000000000000000000000;;		for i, s := range sx {
0000000000000000000000000000000000000000;;			x := strings.Count(s.Key, "/")
0000000000000000000000000000000000000000;;			length[i] = x
0000000000000000000000000000000000000000;;			if x < slashes {
0000000000000000000000000000000000000000;;				if s.Group == "" {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				slashes = x
0000000000000000000000000000000000000000;;				group = s.Group
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if group == "" {
0000000000000000000000000000000000000000;;			return sx
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := []Service{} // with slice-tricks in sx we can prolly save this allocation (TODO)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, s := range sx {
0000000000000000000000000000000000000000;;			if s.Group == "" {
0000000000000000000000000000000000000000;;				ret = append(ret, s)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Disagreement on the same level
0000000000000000000000000000000000000000;;			if length[i] == slashes && s.Group != group {
0000000000000000000000000000000000000000;;				return sx
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if s.Group == group {
0000000000000000000000000000000000000000;;				ret = append(ret, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Split255 splits a string into 255 byte chunks.
0000000000000000000000000000000000000000;;	func split255(s string) []string {
0000000000000000000000000000000000000000;;		if len(s) < 255 {
0000000000000000000000000000000000000000;;			return []string{s}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sx := []string{}
0000000000000000000000000000000000000000;;		p, i := 0, 255
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i <= len(s) {
0000000000000000000000000000000000000000;;				sx = append(sx, s[p:i])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				sx = append(sx, s[p:])
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p, i = p+255, i+255
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return sx
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// targetStrip strips "targetstrip" labels from the left side of the fully qualified name.
0000000000000000000000000000000000000000;;	func targetStrip(name string, targetStrip int) string {
0000000000000000000000000000000000000000;;		if targetStrip == 0 {
0000000000000000000000000000000000000000;;			return name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		offset, end := 0, false
0000000000000000000000000000000000000000;;		for i := 0; i < targetStrip; i++ {
0000000000000000000000000000000000000000;;			offset, end = dns.NextLabel(name, offset)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end {
0000000000000000000000000000000000000000;;			// We overshot the name, use the orignal one.
0000000000000000000000000000000000000000;;			offset = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name = name[offset:]
0000000000000000000000000000000000000000;;		return name
0000000000000000000000000000000000000000;;	}
