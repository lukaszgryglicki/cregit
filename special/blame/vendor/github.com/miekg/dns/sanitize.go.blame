0000000000000000000000000000000000000000;;	package dns
b9f13aaa534682ec2030ddaa4366d37857ab7cbb;;	
0000000000000000000000000000000000000000;;	// Dedup removes identical RRs from rrs. It preserves the original ordering.
0000000000000000000000000000000000000000;;	// The lowest TTL of any duplicates is used in the remaining one. Dedup modifies
0000000000000000000000000000000000000000;;	// rrs.
0000000000000000000000000000000000000000;;	// m is used to store the RRs temporay. If it is nil a new map will be allocated.
0000000000000000000000000000000000000000;;	func Dedup(rrs []RR, m map[string]RR) []RR {
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			m = make(map[string]RR)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Save the keys, so we don't have to call normalizedString twice.
0000000000000000000000000000000000000000;;		keys := make([]*string, 0, len(rrs))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, r := range rrs {
0000000000000000000000000000000000000000;;			key := normalizedString(r)
0000000000000000000000000000000000000000;;			keys = append(keys, &key)
0000000000000000000000000000000000000000;;			if _, ok := m[key]; ok {
0000000000000000000000000000000000000000;;				// Shortest TTL wins.
0000000000000000000000000000000000000000;;				if m[key].Header().Ttl > r.Header().Ttl {
0000000000000000000000000000000000000000;;					m[key].Header().Ttl = r.Header().Ttl
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			m[key] = r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the length of the result map equals the amount of RRs we got,
0000000000000000000000000000000000000000;;		// it means they were all different. We can then just return the original rrset.
0000000000000000000000000000000000000000;;		if len(m) == len(rrs) {
0000000000000000000000000000000000000000;;			return rrs
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		for i, r := range rrs {
0000000000000000000000000000000000000000;;			// If keys[i] lives in the map, we should copy and remove it.
0000000000000000000000000000000000000000;;			if _, ok := m[*keys[i]]; ok {
0000000000000000000000000000000000000000;;				delete(m, *keys[i])
0000000000000000000000000000000000000000;;				rrs[j] = r
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(m) == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rrs[:j]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// normalizedString returns a normalized string from r. The TTL
0000000000000000000000000000000000000000;;	// is removed and the domain name is lowercased. We go from this:
0000000000000000000000000000000000000000;;	// DomainName<TAB>TTL<TAB>CLASS<TAB>TYPE<TAB>RDATA to:
0000000000000000000000000000000000000000;;	// lowercasename<TAB>CLASS<TAB>TYPE...
0000000000000000000000000000000000000000;;	func normalizedString(r RR) string {
0000000000000000000000000000000000000000;;		// A string Go DNS makes has: domainname<TAB>TTL<TAB>...
0000000000000000000000000000000000000000;;		b := []byte(r.String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the first non-escaped tab, then another, so we capture where the TTL lives.
0000000000000000000000000000000000000000;;		esc := false
0000000000000000000000000000000000000000;;		ttlStart, ttlEnd := 0, 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(b) && ttlEnd == 0; i++ {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case b[i] == '\\':
0000000000000000000000000000000000000000;;				esc = !esc
0000000000000000000000000000000000000000;;			case b[i] == '\t' && !esc:
0000000000000000000000000000000000000000;;				if ttlStart == 0 {
0000000000000000000000000000000000000000;;					ttlStart = i
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ttlEnd == 0 {
0000000000000000000000000000000000000000;;					ttlEnd = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case b[i] >= 'A' && b[i] <= 'Z' && !esc:
0000000000000000000000000000000000000000;;				b[i] += 32
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				esc = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// remove TTL.
0000000000000000000000000000000000000000;;		copy(b[ttlStart:], b[ttlEnd:])
0000000000000000000000000000000000000000;;		cut := ttlEnd - ttlStart
0000000000000000000000000000000000000000;;		return string(b[:len(b)-cut])
0000000000000000000000000000000000000000;;	}
