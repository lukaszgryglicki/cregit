0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/types.go[Godeps/_workspace/src/github.com/miekg/dns/types.go][vendor/github.com/miekg/dns/types.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type (
0000000000000000000000000000000000000000;;		// Type is a DNS type.
0000000000000000000000000000000000000000;;		Type uint16
0000000000000000000000000000000000000000;;		// Class is a DNS class.
0000000000000000000000000000000000000000;;		Class uint16
0000000000000000000000000000000000000000;;		// Name is a DNS domain name.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Packet formats
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wire constants and supported types.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// valid RR_Header.Rrtype and Question.qtype
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TypeNone       uint16 = 0
0000000000000000000000000000000000000000;;		TypeA          uint16 = 1
0000000000000000000000000000000000000000;;		TypeNS         uint16 = 2
0000000000000000000000000000000000000000;;		TypeMD         uint16 = 3
0000000000000000000000000000000000000000;;		TypeMF         uint16 = 4
0000000000000000000000000000000000000000;;		TypeCNAME      uint16 = 5
0000000000000000000000000000000000000000;;		TypeSOA        uint16 = 6
0000000000000000000000000000000000000000;;		TypeMB         uint16 = 7
0000000000000000000000000000000000000000;;		TypeMG         uint16 = 8
0000000000000000000000000000000000000000;;		TypeMR         uint16 = 9
0000000000000000000000000000000000000000;;		TypeNULL       uint16 = 10
0000000000000000000000000000000000000000;;		TypePTR        uint16 = 12
0000000000000000000000000000000000000000;;		TypeHINFO      uint16 = 13
0000000000000000000000000000000000000000;;		TypeMINFO      uint16 = 14
0000000000000000000000000000000000000000;;		TypeMX         uint16 = 15
0000000000000000000000000000000000000000;;		TypeTXT        uint16 = 16
0000000000000000000000000000000000000000;;		TypeRP         uint16 = 17
0000000000000000000000000000000000000000;;		TypeAFSDB      uint16 = 18
0000000000000000000000000000000000000000;;		TypeX25        uint16 = 19
0000000000000000000000000000000000000000;;		TypeISDN       uint16 = 20
0000000000000000000000000000000000000000;;		TypeRT         uint16 = 21
0000000000000000000000000000000000000000;;		TypeNSAPPTR    uint16 = 23
0000000000000000000000000000000000000000;;		TypeSIG        uint16 = 24
0000000000000000000000000000000000000000;;		TypeKEY        uint16 = 25
0000000000000000000000000000000000000000;;		TypePX         uint16 = 26
0000000000000000000000000000000000000000;;		TypeGPOS       uint16 = 27
0000000000000000000000000000000000000000;;		TypeAAAA       uint16 = 28
0000000000000000000000000000000000000000;;		TypeLOC        uint16 = 29
0000000000000000000000000000000000000000;;		TypeNXT        uint16 = 30
0000000000000000000000000000000000000000;;		TypeEID        uint16 = 31
0000000000000000000000000000000000000000;;		TypeNIMLOC     uint16 = 32
0000000000000000000000000000000000000000;;		TypeSRV        uint16 = 33
0000000000000000000000000000000000000000;;		TypeATMA       uint16 = 34
0000000000000000000000000000000000000000;;		TypeNAPTR      uint16 = 35
0000000000000000000000000000000000000000;;		TypeKX         uint16 = 36
0000000000000000000000000000000000000000;;		TypeCERT       uint16 = 37
0000000000000000000000000000000000000000;;		TypeDNAME      uint16 = 39
0000000000000000000000000000000000000000;;		TypeOPT        uint16 = 41 // EDNS
0000000000000000000000000000000000000000;;		TypeDS         uint16 = 43
0000000000000000000000000000000000000000;;		TypeSSHFP      uint16 = 44
0000000000000000000000000000000000000000;;		TypeRRSIG      uint16 = 46
0000000000000000000000000000000000000000;;		TypeNSEC       uint16 = 47
0000000000000000000000000000000000000000;;		TypeDNSKEY     uint16 = 48
0000000000000000000000000000000000000000;;		TypeDHCID      uint16 = 49
0000000000000000000000000000000000000000;;		TypeNSEC3      uint16 = 50
0000000000000000000000000000000000000000;;		TypeNSEC3PARAM uint16 = 51
0000000000000000000000000000000000000000;;		TypeTLSA       uint16 = 52
0000000000000000000000000000000000000000;;		TypeHIP        uint16 = 55
0000000000000000000000000000000000000000;;		TypeNINFO      uint16 = 56
0000000000000000000000000000000000000000;;		TypeRKEY       uint16 = 57
0000000000000000000000000000000000000000;;		TypeTALINK     uint16 = 58
0000000000000000000000000000000000000000;;		TypeCDS        uint16 = 59
0000000000000000000000000000000000000000;;		TypeCDNSKEY    uint16 = 60
0000000000000000000000000000000000000000;;		TypeOPENPGPKEY uint16 = 61
0000000000000000000000000000000000000000;;		TypeSPF        uint16 = 99
0000000000000000000000000000000000000000;;		TypeUINFO      uint16 = 100
0000000000000000000000000000000000000000;;		TypeUID        uint16 = 101
0000000000000000000000000000000000000000;;		TypeGID        uint16 = 102
0000000000000000000000000000000000000000;;		TypeUNSPEC     uint16 = 103
0000000000000000000000000000000000000000;;		TypeNID        uint16 = 104
0000000000000000000000000000000000000000;;		TypeL32        uint16 = 105
0000000000000000000000000000000000000000;;		TypeL64        uint16 = 106
0000000000000000000000000000000000000000;;		TypeLP         uint16 = 107
0000000000000000000000000000000000000000;;		TypeEUI48      uint16 = 108
0000000000000000000000000000000000000000;;		TypeEUI64      uint16 = 109
0000000000000000000000000000000000000000;;		TypeURI        uint16 = 256
0000000000000000000000000000000000000000;;		TypeCAA        uint16 = 257
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TypeTKEY uint16 = 249
0000000000000000000000000000000000000000;;		TypeTSIG uint16 = 250
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// valid Question.Qtype only
0000000000000000000000000000000000000000;;		TypeIXFR  uint16 = 251
0000000000000000000000000000000000000000;;		TypeAXFR  uint16 = 252
0000000000000000000000000000000000000000;;		TypeMAILB uint16 = 253
0000000000000000000000000000000000000000;;		TypeMAILA uint16 = 254
0000000000000000000000000000000000000000;;		TypeANY   uint16 = 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TypeTA       uint16 = 32768
0000000000000000000000000000000000000000;;		TypeDLV      uint16 = 32769
0000000000000000000000000000000000000000;;		TypeReserved uint16 = 65535
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// valid Question.Qclass
0000000000000000000000000000000000000000;;		ClassINET   = 1
0000000000000000000000000000000000000000;;		ClassCSNET  = 2
0000000000000000000000000000000000000000;;		ClassCHAOS  = 3
0000000000000000000000000000000000000000;;		ClassHESIOD = 4
0000000000000000000000000000000000000000;;		ClassNONE   = 254
0000000000000000000000000000000000000000;;		ClassANY    = 255
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Message Response Codes.
0000000000000000000000000000000000000000;;		RcodeSuccess        = 0
0000000000000000000000000000000000000000;;		RcodeFormatError    = 1
0000000000000000000000000000000000000000;;		RcodeServerFailure  = 2
0000000000000000000000000000000000000000;;		RcodeNameError      = 3
0000000000000000000000000000000000000000;;		RcodeNotImplemented = 4
0000000000000000000000000000000000000000;;		RcodeRefused        = 5
0000000000000000000000000000000000000000;;		RcodeYXDomain       = 6
0000000000000000000000000000000000000000;;		RcodeYXRrset        = 7
0000000000000000000000000000000000000000;;		RcodeNXRrset        = 8
0000000000000000000000000000000000000000;;		RcodeNotAuth        = 9
0000000000000000000000000000000000000000;;		RcodeNotZone        = 10
0000000000000000000000000000000000000000;;		RcodeBadSig         = 16 // TSIG
0000000000000000000000000000000000000000;;		RcodeBadVers        = 16 // EDNS0
0000000000000000000000000000000000000000;;		RcodeBadKey         = 17
0000000000000000000000000000000000000000;;		RcodeBadTime        = 18
0000000000000000000000000000000000000000;;		RcodeBadMode        = 19 // TKEY
0000000000000000000000000000000000000000;;		RcodeBadName        = 20
0000000000000000000000000000000000000000;;		RcodeBadAlg         = 21
0000000000000000000000000000000000000000;;		RcodeBadTrunc       = 22 // TSIG
0000000000000000000000000000000000000000;;		RcodeBadCookie      = 23 // DNS Cookies
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Message Opcodes. There is no 3.
0000000000000000000000000000000000000000;;		OpcodeQuery  = 0
0000000000000000000000000000000000000000;;		OpcodeIQuery = 1
0000000000000000000000000000000000000000;;		OpcodeStatus = 2
0000000000000000000000000000000000000000;;		OpcodeNotify = 4
0000000000000000000000000000000000000000;;		OpcodeUpdate = 5
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Headers is the wire format for the DNS packet header.
0000000000000000000000000000000000000000;;	type Header struct {
0000000000000000000000000000000000000000;;		Id                                 uint16
0000000000000000000000000000000000000000;;		Bits                               uint16
0000000000000000000000000000000000000000;;		Qdcount, Ancount, Nscount, Arcount uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		headerSize = 12
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Header.Bits
0000000000000000000000000000000000000000;;		_QR = 1 << 15 // query/response (response=1)
0000000000000000000000000000000000000000;;		_AA = 1 << 10 // authoritative
0000000000000000000000000000000000000000;;		_TC = 1 << 9  // truncated
0000000000000000000000000000000000000000;;		_RD = 1 << 8  // recursion desired
0000000000000000000000000000000000000000;;		_RA = 1 << 7  // recursion available
0000000000000000000000000000000000000000;;		_Z  = 1 << 6  // Z
0000000000000000000000000000000000000000;;		_AD = 1 << 5  // authticated data
0000000000000000000000000000000000000000;;		_CD = 1 << 4  // checking disabled
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LOC_EQUATOR       = 1 << 31 // RFC 1876, Section 2.
0000000000000000000000000000000000000000;;		LOC_PRIMEMERIDIAN = 1 << 31 // RFC 1876, Section 2.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LOC_HOURS   = 60 * 1000
0000000000000000000000000000000000000000;;		LOC_DEGREES = 60 * LOC_HOURS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		LOC_ALTITUDEBASE = 100000
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Different Certificate Types, see RFC 4398, Section 2.1
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		CertPKIX = 1 + iota
0000000000000000000000000000000000000000;;		CertSPKI
0000000000000000000000000000000000000000;;		CertPGP
0000000000000000000000000000000000000000;;		CertIPIX
0000000000000000000000000000000000000000;;		CertISPKI
0000000000000000000000000000000000000000;;		CertIPGP
0000000000000000000000000000000000000000;;		CertACPKIX
0000000000000000000000000000000000000000;;		CertIACPKIX
0000000000000000000000000000000000000000;;		CertURI = 253
0000000000000000000000000000000000000000;;		CertOID = 254
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertTypeToString converts the Cert Type to its string representation.
0000000000000000000000000000000000000000;;	// See RFC 4398 and RFC 6944.
0000000000000000000000000000000000000000;;	var CertTypeToString = map[uint16]string{
0000000000000000000000000000000000000000;;		CertPKIX:    "PKIX",
0000000000000000000000000000000000000000;;		CertSPKI:    "SPKI",
0000000000000000000000000000000000000000;;		CertPGP:     "PGP",
0000000000000000000000000000000000000000;;		CertIPIX:    "IPIX",
0000000000000000000000000000000000000000;;		CertISPKI:   "ISPKI",
0000000000000000000000000000000000000000;;		CertIPGP:    "IPGP",
0000000000000000000000000000000000000000;;		CertACPKIX:  "ACPKIX",
0000000000000000000000000000000000000000;;		CertIACPKIX: "IACPKIX",
0000000000000000000000000000000000000000;;		CertURI:     "URI",
0000000000000000000000000000000000000000;;		CertOID:     "OID",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToCertType is the reverseof CertTypeToString.
0000000000000000000000000000000000000000;;	var StringToCertType = reverseInt16(CertTypeToString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:generate go run types_generate.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Question holds a DNS question. There can be multiple questions in the
0000000000000000000000000000000000000000;;	// question section of a message. Usually there is just one.
0000000000000000000000000000000000000000;;	type Question struct {
0000000000000000000000000000000000000000;;		Name   string `dns:"cdomain-name"` // "cdomain-name" specifies encoding (and may be compressed)
0000000000000000000000000000000000000000;;		Qtype  uint16
0000000000000000000000000000000000000000;;		Qclass uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *Question) len() int {
0000000000000000000000000000000000000000;;		return len(q.Name) + 1 + 2 + 2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *Question) String() (s string) {
0000000000000000000000000000000000000000;;		// prefix with ; (as in dig)
0000000000000000000000000000000000000000;;		s = ";" + sprintName(q.Name) + "\t"
0000000000000000000000000000000000000000;;		s += Class(q.Qclass).String() + "\t"
0000000000000000000000000000000000000000;;		s += " " + Type(q.Qtype).String()
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ANY is a wildcard record. See RFC 1035, Section 3.2.3. ANY
0000000000000000000000000000000000000000;;	// is named "*" there.
0000000000000000000000000000000000000000;;	type ANY struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		// Does not have any rdata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *ANY) String() string { return rr.Hdr.String() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CNAME struct {
0000000000000000000000000000000000000000;;		Hdr    RR_Header
0000000000000000000000000000000000000000;;		Target string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CNAME) String() string { return rr.Hdr.String() + sprintName(rr.Target) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HINFO struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Cpu string
0000000000000000000000000000000000000000;;		Os  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *HINFO) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintTxt([]string{rr.Cpu, rr.Os})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MB struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Mb  string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MB) String() string { return rr.Hdr.String() + sprintName(rr.Mb) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MG struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Mg  string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MG) String() string { return rr.Hdr.String() + sprintName(rr.Mg) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MINFO struct {
0000000000000000000000000000000000000000;;		Hdr   RR_Header
0000000000000000000000000000000000000000;;		Rmail string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;		Email string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MINFO) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Rmail) + " " + sprintName(rr.Email)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MR struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Mr  string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MR) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Mr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MF struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Mf  string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MF) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Mf)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MD struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Md  string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MD) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Md)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type MX struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		Mx         string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MX) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Preference)) + " " + sprintName(rr.Mx)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AFSDB struct {
0000000000000000000000000000000000000000;;		Hdr      RR_Header
0000000000000000000000000000000000000000;;		Subtype  uint16
0000000000000000000000000000000000000000;;		Hostname string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *AFSDB) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Subtype)) + " " + sprintName(rr.Hostname)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type X25 struct {
0000000000000000000000000000000000000000;;		Hdr         RR_Header
0000000000000000000000000000000000000000;;		PSDNAddress string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *X25) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + rr.PSDNAddress
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RT struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		Host       string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RT) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Preference)) + " " + sprintName(rr.Host)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NS struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Ns  string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NS) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Ns)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PTR struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Ptr string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *PTR) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Ptr)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RP struct {
0000000000000000000000000000000000000000;;		Hdr  RR_Header
0000000000000000000000000000000000000000;;		Mbox string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		Txt  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RP) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + rr.Mbox + " " + sprintTxt([]string{rr.Txt})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SOA struct {
0000000000000000000000000000000000000000;;		Hdr     RR_Header
0000000000000000000000000000000000000000;;		Ns      string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;		Mbox    string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;		Serial  uint32
0000000000000000000000000000000000000000;;		Refresh uint32
0000000000000000000000000000000000000000;;		Retry   uint32
0000000000000000000000000000000000000000;;		Expire  uint32
0000000000000000000000000000000000000000;;		Minttl  uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SOA) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Ns) + " " + sprintName(rr.Mbox) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatInt(int64(rr.Serial), 10) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatInt(int64(rr.Refresh), 10) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatInt(int64(rr.Retry), 10) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatInt(int64(rr.Expire), 10) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatInt(int64(rr.Minttl), 10)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TXT struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Txt []string `dns:"txt"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TXT) String() string { return rr.Hdr.String() + sprintTxt(rr.Txt) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sprintName(s string) string {
0000000000000000000000000000000000000000;;		src := []byte(s)
0000000000000000000000000000000000000000;;		dst := make([]byte, 0, len(src))
0000000000000000000000000000000000000000;;		for i := 0; i < len(src); {
0000000000000000000000000000000000000000;;			if i+1 < len(src) && src[i] == '\\' && src[i+1] == '.' {
0000000000000000000000000000000000000000;;				dst = append(dst, src[i:i+2]...)
0000000000000000000000000000000000000000;;				i += 2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				b, n := nextByte(src, i)
0000000000000000000000000000000000000000;;				if n == 0 {
0000000000000000000000000000000000000000;;					i++ // dangling back slash
0000000000000000000000000000000000000000;;				} else if b == '.' {
0000000000000000000000000000000000000000;;					dst = append(dst, b)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					dst = appendDomainNameByte(dst, b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i += n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(dst)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sprintTxtOctet(s string) string {
0000000000000000000000000000000000000000;;		src := []byte(s)
0000000000000000000000000000000000000000;;		dst := make([]byte, 0, len(src))
0000000000000000000000000000000000000000;;		dst = append(dst, '"')
0000000000000000000000000000000000000000;;		for i := 0; i < len(src); {
0000000000000000000000000000000000000000;;			if i+1 < len(src) && src[i] == '\\' && src[i+1] == '.' {
0000000000000000000000000000000000000000;;				dst = append(dst, src[i:i+2]...)
0000000000000000000000000000000000000000;;				i += 2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				b, n := nextByte(src, i)
0000000000000000000000000000000000000000;;				if n == 0 {
0000000000000000000000000000000000000000;;					i++ // dangling back slash
0000000000000000000000000000000000000000;;				} else if b == '.' {
0000000000000000000000000000000000000000;;					dst = append(dst, b)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					if b < ' ' || b > '~' {
0000000000000000000000000000000000000000;;						dst = appendByte(dst, b)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						dst = append(dst, b)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i += n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dst = append(dst, '"')
0000000000000000000000000000000000000000;;		return string(dst)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sprintTxt(txt []string) string {
0000000000000000000000000000000000000000;;		var out []byte
0000000000000000000000000000000000000000;;		for i, s := range txt {
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				out = append(out, ` "`...)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out = append(out, '"')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			bs := []byte(s)
0000000000000000000000000000000000000000;;			for j := 0; j < len(bs); {
0000000000000000000000000000000000000000;;				b, n := nextByte(bs, j)
0000000000000000000000000000000000000000;;				if n == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out = appendTXTStringByte(out, b)
0000000000000000000000000000000000000000;;				j += n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, '"')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(out)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendDomainNameByte(s []byte, b byte) []byte {
0000000000000000000000000000000000000000;;		switch b {
0000000000000000000000000000000000000000;;		case '.', ' ', '\'', '@', ';', '(', ')': // additional chars to escape
0000000000000000000000000000000000000000;;			return append(s, '\\', b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return appendTXTStringByte(s, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendTXTStringByte(s []byte, b byte) []byte {
0000000000000000000000000000000000000000;;		switch b {
0000000000000000000000000000000000000000;;		case '\t':
0000000000000000000000000000000000000000;;			return append(s, '\\', 't')
0000000000000000000000000000000000000000;;		case '\r':
0000000000000000000000000000000000000000;;			return append(s, '\\', 'r')
0000000000000000000000000000000000000000;;		case '\n':
0000000000000000000000000000000000000000;;			return append(s, '\\', 'n')
0000000000000000000000000000000000000000;;		case '"', '\\':
0000000000000000000000000000000000000000;;			return append(s, '\\', b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b < ' ' || b > '~' {
0000000000000000000000000000000000000000;;			return appendByte(s, b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return append(s, b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendByte(s []byte, b byte) []byte {
0000000000000000000000000000000000000000;;		var buf [3]byte
0000000000000000000000000000000000000000;;		bufs := strconv.AppendInt(buf[:0], int64(b), 10)
0000000000000000000000000000000000000000;;		s = append(s, '\\')
0000000000000000000000000000000000000000;;		for i := 0; i < 3-len(bufs); i++ {
0000000000000000000000000000000000000000;;			s = append(s, '0')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, r := range bufs {
0000000000000000000000000000000000000000;;			s = append(s, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextByte(b []byte, offset int) (byte, int) {
0000000000000000000000000000000000000000;;		if offset >= len(b) {
0000000000000000000000000000000000000000;;			return 0, 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if b[offset] != '\\' {
0000000000000000000000000000000000000000;;			// not an escape sequence
0000000000000000000000000000000000000000;;			return b[offset], 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch len(b) - offset {
0000000000000000000000000000000000000000;;		case 1: // dangling escape
0000000000000000000000000000000000000000;;			return 0, 0
0000000000000000000000000000000000000000;;		case 2, 3: // too short to be \ddd
0000000000000000000000000000000000000000;;		default: // maybe \ddd
0000000000000000000000000000000000000000;;			if isDigit(b[offset+1]) && isDigit(b[offset+2]) && isDigit(b[offset+3]) {
0000000000000000000000000000000000000000;;				return dddToByte(b[offset+1:]), 4
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// not \ddd, maybe a control char
0000000000000000000000000000000000000000;;		switch b[offset+1] {
0000000000000000000000000000000000000000;;		case 't':
0000000000000000000000000000000000000000;;			return '\t', 2
0000000000000000000000000000000000000000;;		case 'r':
0000000000000000000000000000000000000000;;			return '\r', 2
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			return '\n', 2
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return b[offset+1], 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SPF struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Txt []string `dns:"txt"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SPF) String() string { return rr.Hdr.String() + sprintTxt(rr.Txt) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SRV struct {
0000000000000000000000000000000000000000;;		Hdr      RR_Header
0000000000000000000000000000000000000000;;		Priority uint16
0000000000000000000000000000000000000000;;		Weight   uint16
0000000000000000000000000000000000000000;;		Port     uint16
0000000000000000000000000000000000000000;;		Target   string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SRV) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() +
0000000000000000000000000000000000000000;;			strconv.Itoa(int(rr.Priority)) + " " +
0000000000000000000000000000000000000000;;			strconv.Itoa(int(rr.Weight)) + " " +
0000000000000000000000000000000000000000;;			strconv.Itoa(int(rr.Port)) + " " + sprintName(rr.Target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NAPTR struct {
0000000000000000000000000000000000000000;;		Hdr         RR_Header
0000000000000000000000000000000000000000;;		Order       uint16
0000000000000000000000000000000000000000;;		Preference  uint16
0000000000000000000000000000000000000000;;		Flags       string
0000000000000000000000000000000000000000;;		Service     string
0000000000000000000000000000000000000000;;		Regexp      string
0000000000000000000000000000000000000000;;		Replacement string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NAPTR) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() +
0000000000000000000000000000000000000000;;			strconv.Itoa(int(rr.Order)) + " " +
0000000000000000000000000000000000000000;;			strconv.Itoa(int(rr.Preference)) + " " +
0000000000000000000000000000000000000000;;			"\"" + rr.Flags + "\" " +
0000000000000000000000000000000000000000;;			"\"" + rr.Service + "\" " +
0000000000000000000000000000000000000000;;			"\"" + rr.Regexp + "\" " +
0000000000000000000000000000000000000000;;			rr.Replacement
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The CERT resource record, see RFC 4398.
0000000000000000000000000000000000000000;;	type CERT struct {
0000000000000000000000000000000000000000;;		Hdr         RR_Header
0000000000000000000000000000000000000000;;		Type        uint16
0000000000000000000000000000000000000000;;		KeyTag      uint16
0000000000000000000000000000000000000000;;		Algorithm   uint8
0000000000000000000000000000000000000000;;		Certificate string `dns:"base64"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CERT) String() string {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			ok                  bool
0000000000000000000000000000000000000000;;			certtype, algorithm string
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if certtype, ok = CertTypeToString[rr.Type]; !ok {
0000000000000000000000000000000000000000;;			certtype = strconv.Itoa(int(rr.Type))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if algorithm, ok = AlgorithmToString[rr.Algorithm]; !ok {
0000000000000000000000000000000000000000;;			algorithm = strconv.Itoa(int(rr.Algorithm))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + certtype +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.KeyTag)) +
0000000000000000000000000000000000000000;;			" " + algorithm +
0000000000000000000000000000000000000000;;			" " + rr.Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The DNAME resource record, see RFC 2672.
0000000000000000000000000000000000000000;;	type DNAME struct {
0000000000000000000000000000000000000000;;		Hdr    RR_Header
0000000000000000000000000000000000000000;;		Target string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DNAME) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + sprintName(rr.Target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type A struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		A   net.IP `dns:"a"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *A) String() string {
0000000000000000000000000000000000000000;;		if rr.A == nil {
0000000000000000000000000000000000000000;;			return rr.Hdr.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + rr.A.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type AAAA struct {
0000000000000000000000000000000000000000;;		Hdr  RR_Header
0000000000000000000000000000000000000000;;		AAAA net.IP `dns:"aaaa"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *AAAA) String() string {
0000000000000000000000000000000000000000;;		if rr.AAAA == nil {
0000000000000000000000000000000000000000;;			return rr.Hdr.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + rr.AAAA.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type PX struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		Map822     string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		Mapx400    string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *PX) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Preference)) + " " + sprintName(rr.Map822) + " " + sprintName(rr.Mapx400)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GPOS struct {
0000000000000000000000000000000000000000;;		Hdr       RR_Header
0000000000000000000000000000000000000000;;		Longitude string
0000000000000000000000000000000000000000;;		Latitude  string
0000000000000000000000000000000000000000;;		Altitude  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *GPOS) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + rr.Longitude + " " + rr.Latitude + " " + rr.Altitude
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LOC struct {
0000000000000000000000000000000000000000;;		Hdr       RR_Header
0000000000000000000000000000000000000000;;		Version   uint8
0000000000000000000000000000000000000000;;		Size      uint8
0000000000000000000000000000000000000000;;		HorizPre  uint8
0000000000000000000000000000000000000000;;		VertPre   uint8
0000000000000000000000000000000000000000;;		Latitude  uint32
0000000000000000000000000000000000000000;;		Longitude uint32
0000000000000000000000000000000000000000;;		Altitude  uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// cmToM takes a cm value expressed in RFC1876 SIZE mantissa/exponent
0000000000000000000000000000000000000000;;	// format and returns a string in m (two decimals for the cm)
0000000000000000000000000000000000000000;;	func cmToM(m, e uint8) string {
0000000000000000000000000000000000000000;;		if e < 2 {
0000000000000000000000000000000000000000;;			if e == 1 {
0000000000000000000000000000000000000000;;				m *= 10
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return fmt.Sprintf("0.%02d", m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := fmt.Sprintf("%d", m)
0000000000000000000000000000000000000000;;		for e > 2 {
0000000000000000000000000000000000000000;;			s += "0"
0000000000000000000000000000000000000000;;			e--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *LOC) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lat := rr.Latitude
0000000000000000000000000000000000000000;;		ns := "N"
0000000000000000000000000000000000000000;;		if lat > LOC_EQUATOR {
0000000000000000000000000000000000000000;;			lat = lat - LOC_EQUATOR
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ns = "S"
0000000000000000000000000000000000000000;;			lat = LOC_EQUATOR - lat
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h := lat / LOC_DEGREES
0000000000000000000000000000000000000000;;		lat = lat % LOC_DEGREES
0000000000000000000000000000000000000000;;		m := lat / LOC_HOURS
0000000000000000000000000000000000000000;;		lat = lat % LOC_HOURS
0000000000000000000000000000000000000000;;		s += fmt.Sprintf("%02d %02d %0.3f %s ", h, m, (float64(lat) / 1000), ns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lon := rr.Longitude
0000000000000000000000000000000000000000;;		ew := "E"
0000000000000000000000000000000000000000;;		if lon > LOC_PRIMEMERIDIAN {
0000000000000000000000000000000000000000;;			lon = lon - LOC_PRIMEMERIDIAN
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ew = "W"
0000000000000000000000000000000000000000;;			lon = LOC_PRIMEMERIDIAN - lon
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h = lon / LOC_DEGREES
0000000000000000000000000000000000000000;;		lon = lon % LOC_DEGREES
0000000000000000000000000000000000000000;;		m = lon / LOC_HOURS
0000000000000000000000000000000000000000;;		lon = lon % LOC_HOURS
0000000000000000000000000000000000000000;;		s += fmt.Sprintf("%02d %02d %0.3f %s ", h, m, (float64(lon) / 1000), ew)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var alt = float64(rr.Altitude) / 100
0000000000000000000000000000000000000000;;		alt -= LOC_ALTITUDEBASE
0000000000000000000000000000000000000000;;		if rr.Altitude%100 != 0 {
0000000000000000000000000000000000000000;;			s += fmt.Sprintf("%.2fm ", alt)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s += fmt.Sprintf("%.0fm ", alt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s += cmToM((rr.Size&0xf0)>>4, rr.Size&0x0f) + "m "
0000000000000000000000000000000000000000;;		s += cmToM((rr.HorizPre&0xf0)>>4, rr.HorizPre&0x0f) + "m "
0000000000000000000000000000000000000000;;		s += cmToM((rr.VertPre&0xf0)>>4, rr.VertPre&0x0f) + "m"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SIG is identical to RRSIG and nowadays only used for SIG(0), RFC2931.
0000000000000000000000000000000000000000;;	type SIG struct {
0000000000000000000000000000000000000000;;		RRSIG
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RRSIG struct {
0000000000000000000000000000000000000000;;		Hdr         RR_Header
0000000000000000000000000000000000000000;;		TypeCovered uint16
0000000000000000000000000000000000000000;;		Algorithm   uint8
0000000000000000000000000000000000000000;;		Labels      uint8
0000000000000000000000000000000000000000;;		OrigTtl     uint32
0000000000000000000000000000000000000000;;		Expiration  uint32
0000000000000000000000000000000000000000;;		Inception   uint32
0000000000000000000000000000000000000000;;		KeyTag      uint16
0000000000000000000000000000000000000000;;		SignerName  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		Signature   string `dns:"base64"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RRSIG) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String()
0000000000000000000000000000000000000000;;		s += Type(rr.TypeCovered).String()
0000000000000000000000000000000000000000;;		s += " " + strconv.Itoa(int(rr.Algorithm)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Labels)) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatInt(int64(rr.OrigTtl), 10) +
0000000000000000000000000000000000000000;;			" " + TimeToString(rr.Expiration) +
0000000000000000000000000000000000000000;;			" " + TimeToString(rr.Inception) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.KeyTag)) +
0000000000000000000000000000000000000000;;			" " + sprintName(rr.SignerName) +
0000000000000000000000000000000000000000;;			" " + rr.Signature
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NSEC struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		NextDomain string   `dns:"domain-name"`
0000000000000000000000000000000000000000;;		TypeBitMap []uint16 `dns:"nsec"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String() + sprintName(rr.NextDomain)
0000000000000000000000000000000000000000;;		for i := 0; i < len(rr.TypeBitMap); i++ {
0000000000000000000000000000000000000000;;			s += " " + Type(rr.TypeBitMap[i]).String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC) len() int {
0000000000000000000000000000000000000000;;		l := rr.Hdr.len() + len(rr.NextDomain) + 1
0000000000000000000000000000000000000000;;		lastwindow := uint32(2 ^ 32 + 1)
0000000000000000000000000000000000000000;;		for _, t := range rr.TypeBitMap {
0000000000000000000000000000000000000000;;			window := t / 256
0000000000000000000000000000000000000000;;			if uint32(window) != lastwindow {
0000000000000000000000000000000000000000;;				l += 1 + 32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastwindow = uint32(window)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DLV struct {
0000000000000000000000000000000000000000;;		DS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CDS struct {
0000000000000000000000000000000000000000;;		DS
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DS struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		KeyTag     uint16
0000000000000000000000000000000000000000;;		Algorithm  uint8
0000000000000000000000000000000000000000;;		DigestType uint8
0000000000000000000000000000000000000000;;		Digest     string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DS) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.KeyTag)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Algorithm)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.DigestType)) +
0000000000000000000000000000000000000000;;			" " + strings.ToUpper(rr.Digest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KX struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		Exchanger  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *KX) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Preference)) +
0000000000000000000000000000000000000000;;			" " + sprintName(rr.Exchanger)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TA struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		KeyTag     uint16
0000000000000000000000000000000000000000;;		Algorithm  uint8
0000000000000000000000000000000000000000;;		DigestType uint8
0000000000000000000000000000000000000000;;		Digest     string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TA) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.KeyTag)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Algorithm)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.DigestType)) +
0000000000000000000000000000000000000000;;			" " + strings.ToUpper(rr.Digest)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TALINK struct {
0000000000000000000000000000000000000000;;		Hdr          RR_Header
0000000000000000000000000000000000000000;;		PreviousName string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		NextName     string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TALINK) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() +
0000000000000000000000000000000000000000;;			sprintName(rr.PreviousName) + " " + sprintName(rr.NextName)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SSHFP struct {
0000000000000000000000000000000000000000;;		Hdr         RR_Header
0000000000000000000000000000000000000000;;		Algorithm   uint8
0000000000000000000000000000000000000000;;		Type        uint8
0000000000000000000000000000000000000000;;		FingerPrint string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SSHFP) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Algorithm)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Type)) +
0000000000000000000000000000000000000000;;			" " + strings.ToUpper(rr.FingerPrint)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type KEY struct {
0000000000000000000000000000000000000000;;		DNSKEY
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CDNSKEY struct {
0000000000000000000000000000000000000000;;		DNSKEY
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DNSKEY struct {
0000000000000000000000000000000000000000;;		Hdr       RR_Header
0000000000000000000000000000000000000000;;		Flags     uint16
0000000000000000000000000000000000000000;;		Protocol  uint8
0000000000000000000000000000000000000000;;		Algorithm uint8
0000000000000000000000000000000000000000;;		PublicKey string `dns:"base64"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DNSKEY) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Flags)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Protocol)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Algorithm)) +
0000000000000000000000000000000000000000;;			" " + rr.PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type RKEY struct {
0000000000000000000000000000000000000000;;		Hdr       RR_Header
0000000000000000000000000000000000000000;;		Flags     uint16
0000000000000000000000000000000000000000;;		Protocol  uint8
0000000000000000000000000000000000000000;;		Algorithm uint8
0000000000000000000000000000000000000000;;		PublicKey string `dns:"base64"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RKEY) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Flags)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Protocol)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Algorithm)) +
0000000000000000000000000000000000000000;;			" " + rr.PublicKey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NSAPPTR struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Ptr string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSAPPTR) String() string { return rr.Hdr.String() + sprintName(rr.Ptr) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NSEC3 struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Hash       uint8
0000000000000000000000000000000000000000;;		Flags      uint8
0000000000000000000000000000000000000000;;		Iterations uint16
0000000000000000000000000000000000000000;;		SaltLength uint8
0000000000000000000000000000000000000000;;		Salt       string `dns:"size-hex:SaltLength"`
0000000000000000000000000000000000000000;;		HashLength uint8
0000000000000000000000000000000000000000;;		NextDomain string   `dns:"size-base32:HashLength"`
0000000000000000000000000000000000000000;;		TypeBitMap []uint16 `dns:"nsec"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC3) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String()
0000000000000000000000000000000000000000;;		s += strconv.Itoa(int(rr.Hash)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Flags)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Iterations)) +
0000000000000000000000000000000000000000;;			" " + saltToString(rr.Salt) +
0000000000000000000000000000000000000000;;			" " + rr.NextDomain
0000000000000000000000000000000000000000;;		for i := 0; i < len(rr.TypeBitMap); i++ {
0000000000000000000000000000000000000000;;			s += " " + Type(rr.TypeBitMap[i]).String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC3) len() int {
0000000000000000000000000000000000000000;;		l := rr.Hdr.len() + 6 + len(rr.Salt)/2 + 1 + len(rr.NextDomain) + 1
0000000000000000000000000000000000000000;;		lastwindow := uint32(2 ^ 32 + 1)
0000000000000000000000000000000000000000;;		for _, t := range rr.TypeBitMap {
0000000000000000000000000000000000000000;;			window := t / 256
0000000000000000000000000000000000000000;;			if uint32(window) != lastwindow {
0000000000000000000000000000000000000000;;				l += 1 + 32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			lastwindow = uint32(window)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NSEC3PARAM struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Hash       uint8
0000000000000000000000000000000000000000;;		Flags      uint8
0000000000000000000000000000000000000000;;		Iterations uint16
0000000000000000000000000000000000000000;;		SaltLength uint8
0000000000000000000000000000000000000000;;		Salt       string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC3PARAM) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String()
0000000000000000000000000000000000000000;;		s += strconv.Itoa(int(rr.Hash)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Flags)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Iterations)) +
0000000000000000000000000000000000000000;;			" " + saltToString(rr.Salt)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TKEY struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Algorithm  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		Inception  uint32
0000000000000000000000000000000000000000;;		Expiration uint32
0000000000000000000000000000000000000000;;		Mode       uint16
0000000000000000000000000000000000000000;;		Error      uint16
0000000000000000000000000000000000000000;;		KeySize    uint16
0000000000000000000000000000000000000000;;		Key        string
0000000000000000000000000000000000000000;;		OtherLen   uint16
0000000000000000000000000000000000000000;;		OtherData  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TKEY) String() string {
0000000000000000000000000000000000000000;;		// It has no presentation format
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RFC3597 represents an unknown/generic RR.
0000000000000000000000000000000000000000;;	type RFC3597 struct {
0000000000000000000000000000000000000000;;		Hdr   RR_Header
0000000000000000000000000000000000000000;;		Rdata string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RFC3597) String() string {
0000000000000000000000000000000000000000;;		// Let's call it a hack
0000000000000000000000000000000000000000;;		s := rfc3597Header(rr.Hdr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s += "\\# " + strconv.Itoa(len(rr.Rdata)/2) + " " + rr.Rdata
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func rfc3597Header(h RR_Header) string {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s += sprintName(h.Name) + "\t"
0000000000000000000000000000000000000000;;		s += strconv.FormatInt(int64(h.Ttl), 10) + "\t"
0000000000000000000000000000000000000000;;		s += "CLASS" + strconv.Itoa(int(h.Class)) + "\t"
0000000000000000000000000000000000000000;;		s += "TYPE" + strconv.Itoa(int(h.Rrtype)) + "\t"
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type URI struct {
0000000000000000000000000000000000000000;;		Hdr      RR_Header
0000000000000000000000000000000000000000;;		Priority uint16
0000000000000000000000000000000000000000;;		Weight   uint16
0000000000000000000000000000000000000000;;		Target   string `dns:"octet"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *URI) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Priority)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Weight)) + " " + sprintTxtOctet(rr.Target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DHCID struct {
0000000000000000000000000000000000000000;;		Hdr    RR_Header
0000000000000000000000000000000000000000;;		Digest string `dns:"base64"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DHCID) String() string { return rr.Hdr.String() + rr.Digest }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type TLSA struct {
0000000000000000000000000000000000000000;;		Hdr          RR_Header
0000000000000000000000000000000000000000;;		Usage        uint8
0000000000000000000000000000000000000000;;		Selector     uint8
0000000000000000000000000000000000000000;;		MatchingType uint8
0000000000000000000000000000000000000000;;		Certificate  string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TLSA) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() +
0000000000000000000000000000000000000000;;			strconv.Itoa(int(rr.Usage)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Selector)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.MatchingType)) +
0000000000000000000000000000000000000000;;			" " + rr.Certificate
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HIP struct {
0000000000000000000000000000000000000000;;		Hdr                RR_Header
0000000000000000000000000000000000000000;;		HitLength          uint8
0000000000000000000000000000000000000000;;		PublicKeyAlgorithm uint8
0000000000000000000000000000000000000000;;		PublicKeyLength    uint16
0000000000000000000000000000000000000000;;		Hit                string   `dns:"size-hex:HitLength"`
0000000000000000000000000000000000000000;;		PublicKey          string   `dns:"size-base64:PublicKeyLength"`
0000000000000000000000000000000000000000;;		RendezvousServers  []string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *HIP) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String() +
0000000000000000000000000000000000000000;;			strconv.Itoa(int(rr.PublicKeyAlgorithm)) +
0000000000000000000000000000000000000000;;			" " + rr.Hit +
0000000000000000000000000000000000000000;;			" " + rr.PublicKey
0000000000000000000000000000000000000000;;		for _, d := range rr.RendezvousServers {
0000000000000000000000000000000000000000;;			s += " " + sprintName(d)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NINFO struct {
0000000000000000000000000000000000000000;;		Hdr    RR_Header
0000000000000000000000000000000000000000;;		ZSData []string `dns:"txt"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NINFO) String() string { return rr.Hdr.String() + sprintTxt(rr.ZSData) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NID struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		NodeID     uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NID) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String() + strconv.Itoa(int(rr.Preference))
0000000000000000000000000000000000000000;;		node := fmt.Sprintf("%0.16x", rr.NodeID)
0000000000000000000000000000000000000000;;		s += " " + node[0:4] + ":" + node[4:8] + ":" + node[8:12] + ":" + node[12:16]
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type L32 struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		Locator32  net.IP `dns:"a"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *L32) String() string {
0000000000000000000000000000000000000000;;		if rr.Locator32 == nil {
0000000000000000000000000000000000000000;;			return rr.Hdr.String() + strconv.Itoa(int(rr.Preference))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Preference)) +
0000000000000000000000000000000000000000;;			" " + rr.Locator32.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type L64 struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		Locator64  uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *L64) String() string {
0000000000000000000000000000000000000000;;		s := rr.Hdr.String() + strconv.Itoa(int(rr.Preference))
0000000000000000000000000000000000000000;;		node := fmt.Sprintf("%0.16X", rr.Locator64)
0000000000000000000000000000000000000000;;		s += " " + node[0:4] + ":" + node[4:8] + ":" + node[8:12] + ":" + node[12:16]
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type LP struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Preference uint16
0000000000000000000000000000000000000000;;		Fqdn       string `dns:"domain-name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *LP) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Preference)) + " " + sprintName(rr.Fqdn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EUI48 struct {
0000000000000000000000000000000000000000;;		Hdr     RR_Header
0000000000000000000000000000000000000000;;		Address uint64 `dns:"uint48"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *EUI48) String() string { return rr.Hdr.String() + euiToString(rr.Address, 48) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EUI64 struct {
0000000000000000000000000000000000000000;;		Hdr     RR_Header
0000000000000000000000000000000000000000;;		Address uint64
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *EUI64) String() string { return rr.Hdr.String() + euiToString(rr.Address, 64) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CAA struct {
0000000000000000000000000000000000000000;;		Hdr   RR_Header
0000000000000000000000000000000000000000;;		Flag  uint8
0000000000000000000000000000000000000000;;		Tag   string
0000000000000000000000000000000000000000;;		Value string `dns:"octet"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CAA) String() string {
0000000000000000000000000000000000000000;;		return rr.Hdr.String() + strconv.Itoa(int(rr.Flag)) + " " + rr.Tag + " " + sprintTxtOctet(rr.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UID struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Uid uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *UID) String() string { return rr.Hdr.String() + strconv.FormatInt(int64(rr.Uid), 10) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type GID struct {
0000000000000000000000000000000000000000;;		Hdr RR_Header
0000000000000000000000000000000000000000;;		Gid uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *GID) String() string { return rr.Hdr.String() + strconv.FormatInt(int64(rr.Gid), 10) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type UINFO struct {
0000000000000000000000000000000000000000;;		Hdr   RR_Header
0000000000000000000000000000000000000000;;		Uinfo string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *UINFO) String() string { return rr.Hdr.String() + sprintTxt([]string{rr.Uinfo}) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EID struct {
0000000000000000000000000000000000000000;;		Hdr      RR_Header
0000000000000000000000000000000000000000;;		Endpoint string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *EID) String() string { return rr.Hdr.String() + strings.ToUpper(rr.Endpoint) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NIMLOC struct {
0000000000000000000000000000000000000000;;		Hdr     RR_Header
0000000000000000000000000000000000000000;;		Locator string `dns:"hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NIMLOC) String() string { return rr.Hdr.String() + strings.ToUpper(rr.Locator) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OPENPGPKEY struct {
0000000000000000000000000000000000000000;;		Hdr       RR_Header
0000000000000000000000000000000000000000;;		PublicKey string `dns:"base64"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *OPENPGPKEY) String() string { return rr.Hdr.String() + rr.PublicKey }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TimeToString translates the RRSIG's incep. and expir. times to the
0000000000000000000000000000000000000000;;	// string representation used when printing the record.
0000000000000000000000000000000000000000;;	// It takes serial arithmetic (RFC 1982) into account.
0000000000000000000000000000000000000000;;	func TimeToString(t uint32) string {
0000000000000000000000000000000000000000;;		mod := ((int64(t) - time.Now().Unix()) / year68) - 1
0000000000000000000000000000000000000000;;		if mod < 0 {
0000000000000000000000000000000000000000;;			mod = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ti := time.Unix(int64(t)-(mod*year68), 0).UTC()
0000000000000000000000000000000000000000;;		return ti.Format("20060102150405")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringToTime translates the RRSIG's incep. and expir. times from
0000000000000000000000000000000000000000;;	// string values like "20110403154150" to an 32 bit integer.
0000000000000000000000000000000000000000;;	// It takes serial arithmetic (RFC 1982) into account.
0000000000000000000000000000000000000000;;	func StringToTime(s string) (uint32, error) {
0000000000000000000000000000000000000000;;		t, err := time.Parse("20060102150405", s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mod := (t.Unix() / year68) - 1
0000000000000000000000000000000000000000;;		if mod < 0 {
0000000000000000000000000000000000000000;;			mod = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint32(t.Unix() - (mod * year68)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// saltToString converts a NSECX salt to uppercase and
0000000000000000000000000000000000000000;;	// returns "-" when it is empty
0000000000000000000000000000000000000000;;	func saltToString(s string) string {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return "-"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.ToUpper(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func euiToString(eui uint64, bits int) (hex string) {
0000000000000000000000000000000000000000;;		switch bits {
0000000000000000000000000000000000000000;;		case 64:
0000000000000000000000000000000000000000;;			hex = fmt.Sprintf("%16.16x", eui)
0000000000000000000000000000000000000000;;			hex = hex[0:2] + "-" + hex[2:4] + "-" + hex[4:6] + "-" + hex[6:8] +
0000000000000000000000000000000000000000;;				"-" + hex[8:10] + "-" + hex[10:12] + "-" + hex[12:14] + "-" + hex[14:16]
0000000000000000000000000000000000000000;;		case 48:
0000000000000000000000000000000000000000;;			hex = fmt.Sprintf("%12.12x", eui)
0000000000000000000000000000000000000000;;			hex = hex[0:2] + "-" + hex[2:4] + "-" + hex[4:6] + "-" + hex[6:8] +
0000000000000000000000000000000000000000;;				"-" + hex[8:10] + "-" + hex[10:12]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// copyIP returns a copy of ip.
0000000000000000000000000000000000000000;;	func copyIP(ip net.IP) net.IP {
0000000000000000000000000000000000000000;;		p := make(net.IP, len(ip))
0000000000000000000000000000000000000000;;		copy(p, ip)
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
