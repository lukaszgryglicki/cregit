0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/zscan.go[Godeps/_workspace/src/github.com/miekg/dns/zscan.go][vendor/github.com/miekg/dns/scan.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type debugging bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const debug debugging = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d debugging) Printf(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;		if d {
0000000000000000000000000000000000000000;;			log.Printf(format, args...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxTok = 2048 // Largest token we can return.
0000000000000000000000000000000000000000;;	const maxUint16 = 1<<16 - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Tokinize a RFC 1035 zone file. The tokenizer will normalize it:
0000000000000000000000000000000000000000;;	// * Add ownernames if they are left blank;
0000000000000000000000000000000000000000;;	// * Suppress sequences of spaces;
0000000000000000000000000000000000000000;;	// * Make each RR fit on one line (_NEWLINE is send as last)
0000000000000000000000000000000000000000;;	// * Handle comments: ;
0000000000000000000000000000000000000000;;	// * Handle braces - anywhere.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Zonefile
0000000000000000000000000000000000000000;;		zEOF = iota
0000000000000000000000000000000000000000;;		zString
0000000000000000000000000000000000000000;;		zBlank
0000000000000000000000000000000000000000;;		zQuote
0000000000000000000000000000000000000000;;		zNewline
0000000000000000000000000000000000000000;;		zRrtpe
0000000000000000000000000000000000000000;;		zOwner
0000000000000000000000000000000000000000;;		zClass
0000000000000000000000000000000000000000;;		zDirOrigin   // $ORIGIN
0000000000000000000000000000000000000000;;		zDirTtl      // $TTL
0000000000000000000000000000000000000000;;		zDirInclude  // $INCLUDE
0000000000000000000000000000000000000000;;		zDirGenerate // $GENERATE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Privatekey file
0000000000000000000000000000000000000000;;		zValue
0000000000000000000000000000000000000000;;		zKey
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		zExpectOwnerDir      // Ownername
0000000000000000000000000000000000000000;;		zExpectOwnerBl       // Whitespace after the ownername
0000000000000000000000000000000000000000;;		zExpectAny           // Expect rrtype, ttl or class
0000000000000000000000000000000000000000;;		zExpectAnyNoClass    // Expect rrtype or ttl
0000000000000000000000000000000000000000;;		zExpectAnyNoClassBl  // The whitespace after _EXPECT_ANY_NOCLASS
0000000000000000000000000000000000000000;;		zExpectAnyNoTtl      // Expect rrtype or class
0000000000000000000000000000000000000000;;		zExpectAnyNoTtlBl    // Whitespace after _EXPECT_ANY_NOTTL
0000000000000000000000000000000000000000;;		zExpectRrtype        // Expect rrtype
0000000000000000000000000000000000000000;;		zExpectRrtypeBl      // Whitespace BEFORE rrtype
0000000000000000000000000000000000000000;;		zExpectRdata         // The first element of the rdata
0000000000000000000000000000000000000000;;		zExpectDirTtlBl      // Space after directive $TTL
0000000000000000000000000000000000000000;;		zExpectDirTtl        // Directive $TTL
0000000000000000000000000000000000000000;;		zExpectDirOriginBl   // Space after directive $ORIGIN
0000000000000000000000000000000000000000;;		zExpectDirOrigin     // Directive $ORIGIN
0000000000000000000000000000000000000000;;		zExpectDirIncludeBl  // Space after directive $INCLUDE
0000000000000000000000000000000000000000;;		zExpectDirInclude    // Directive $INCLUDE
0000000000000000000000000000000000000000;;		zExpectDirGenerate   // Directive $GENERATE
0000000000000000000000000000000000000000;;		zExpectDirGenerateBl // Space after directive $GENERATE
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseError is a parsing error. It contains the parse error and the location in the io.Reader
0000000000000000000000000000000000000000;;	// where the error occurred.
0000000000000000000000000000000000000000;;	type ParseError struct {
0000000000000000000000000000000000000000;;		file string
0000000000000000000000000000000000000000;;		err  string
0000000000000000000000000000000000000000;;		lex  lex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ParseError) Error() (s string) {
0000000000000000000000000000000000000000;;		if e.file != "" {
0000000000000000000000000000000000000000;;			s = e.file + ": "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s += "dns: " + e.err + ": " + strconv.QuoteToASCII(e.lex.token) + " at line: " +
0000000000000000000000000000000000000000;;			strconv.Itoa(e.lex.line) + ":" + strconv.Itoa(e.lex.column)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type lex struct {
0000000000000000000000000000000000000000;;		token      string // text of the token
0000000000000000000000000000000000000000;;		tokenUpper string // uppercase text of the token
0000000000000000000000000000000000000000;;		length     int    // length of the token
0000000000000000000000000000000000000000;;		err        bool   // when true, token text has lexer error
0000000000000000000000000000000000000000;;		value      uint8  // value: zString, _BLANK, etc.
0000000000000000000000000000000000000000;;		line       int    // line in the file
0000000000000000000000000000000000000000;;		column     int    // column in the file
0000000000000000000000000000000000000000;;		torc       uint16 // type or class as parsed in the lexer, we only need to look this up in the grammar
0000000000000000000000000000000000000000;;		comment    string // any comment text seen
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token holds the token that are returned when a zone file is parsed.
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		// The scanned resource record when error is not nil.
0000000000000000000000000000000000000000;;		RR
0000000000000000000000000000000000000000;;		// When an error occurred, this has the error specifics.
0000000000000000000000000000000000000000;;		Error *ParseError
0000000000000000000000000000000000000000;;		// A potential comment positioned after the RR and on the same line.
0000000000000000000000000000000000000000;;		Comment string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRR reads the RR contained in the string s. Only the first RR is
0000000000000000000000000000000000000000;;	// returned. If s contains no RR, return nil with no error. The class
0000000000000000000000000000000000000000;;	// defaults to IN and TTL defaults to 3600. The full zone file syntax
0000000000000000000000000000000000000000;;	// like $TTL, $ORIGIN, etc. is supported. All fields of the returned
0000000000000000000000000000000000000000;;	// RR are set, except RR.Header().Rdlength which is set to 0.
0000000000000000000000000000000000000000;;	func NewRR(s string) (RR, error) {
0000000000000000000000000000000000000000;;		if len(s) > 0 && s[len(s)-1] != '\n' { // We need a closing newline
0000000000000000000000000000000000000000;;			return ReadRR(strings.NewReader(s+"\n"), "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ReadRR(strings.NewReader(s), "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadRR reads the RR contained in q.
0000000000000000000000000000000000000000;;	// See NewRR for more documentation.
0000000000000000000000000000000000000000;;	func ReadRR(q io.Reader, filename string) (RR, error) {
0000000000000000000000000000000000000000;;		r := <-parseZoneHelper(q, ".", filename, 1)
0000000000000000000000000000000000000000;;		if r == nil {
0000000000000000000000000000000000000000;;			return nil, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Error != nil {
0000000000000000000000000000000000000000;;			return nil, r.Error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r.RR, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseZone reads a RFC 1035 style zonefile from r. It returns *Tokens on the
0000000000000000000000000000000000000000;;	// returned channel, which consist out the parsed RR, a potential comment or an error.
0000000000000000000000000000000000000000;;	// If there is an error the RR is nil. The string file is only used
0000000000000000000000000000000000000000;;	// in error reporting. The string origin is used as the initial origin, as
0000000000000000000000000000000000000000;;	// if the file would start with: $ORIGIN origin .
0000000000000000000000000000000000000000;;	// The directives $INCLUDE, $ORIGIN, $TTL and $GENERATE are supported.
0000000000000000000000000000000000000000;;	// The channel t is closed by ParseZone when the end of r is reached.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Basic usage pattern when reading from a string (z) containing the
0000000000000000000000000000000000000000;;	// zone data:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	for x := range dns.ParseZone(strings.NewReader(z), "", "") {
0000000000000000000000000000000000000000;;	//		if x.Error != nil {
0000000000000000000000000000000000000000;;	//                  // log.Println(x.Error)
0000000000000000000000000000000000000000;;	//              } else {
0000000000000000000000000000000000000000;;	//                  // Do something with x.RR
0000000000000000000000000000000000000000;;	//              }
0000000000000000000000000000000000000000;;	//	}
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Comments specified after an RR (and on the same line!) are returned too:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	foo. IN A 10.0.0.1 ; this is a comment
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The text "; this is comment" is returned in Token.Comment. Comments inside the
0000000000000000000000000000000000000000;;	// RR are discarded. Comments on a line by themselves are discarded too.
0000000000000000000000000000000000000000;;	func ParseZone(r io.Reader, origin, file string) chan *Token {
0000000000000000000000000000000000000000;;		return parseZoneHelper(r, origin, file, 10000)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseZoneHelper(r io.Reader, origin, file string, chansize int) chan *Token {
0000000000000000000000000000000000000000;;		t := make(chan *Token, chansize)
0000000000000000000000000000000000000000;;		go parseZone(r, origin, file, t, 0)
0000000000000000000000000000000000000000;;		return t
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parseZone(r io.Reader, origin, f string, t chan *Token, include int) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			if include == 0 {
0000000000000000000000000000000000000000;;				close(t)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		s := scanInit(r)
0000000000000000000000000000000000000000;;		c := make(chan lex)
0000000000000000000000000000000000000000;;		// Start the lexer
0000000000000000000000000000000000000000;;		go zlexer(s, c)
0000000000000000000000000000000000000000;;		// 6 possible beginnings of a line, _ is a space
0000000000000000000000000000000000000000;;		// 0. zRRTYPE                              -> all omitted until the rrtype
0000000000000000000000000000000000000000;;		// 1. zOwner _ zRrtype                     -> class/ttl omitted
0000000000000000000000000000000000000000;;		// 2. zOwner _ zString _ zRrtype           -> class omitted
0000000000000000000000000000000000000000;;		// 3. zOwner _ zString _ zClass  _ zRrtype -> ttl/class
0000000000000000000000000000000000000000;;		// 4. zOwner _ zClass  _ zRrtype           -> ttl omitted
0000000000000000000000000000000000000000;;		// 5. zOwner _ zClass  _ zString _ zRrtype -> class/ttl (reversed)
0000000000000000000000000000000000000000;;		// After detecting these, we know the zRrtype so we can jump to functions
0000000000000000000000000000000000000000;;		// handling the rdata for each of these types.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if origin == "" {
0000000000000000000000000000000000000000;;			origin = "."
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		origin = Fqdn(origin)
0000000000000000000000000000000000000000;;		if _, ok := IsDomainName(origin); !ok {
0000000000000000000000000000000000000000;;			t <- &Token{Error: &ParseError{f, "bad initial origin name", lex{}}}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		st := zExpectOwnerDir // initial state
0000000000000000000000000000000000000000;;		var h RR_Header
0000000000000000000000000000000000000000;;		var defttl uint32 = defaultTtl
0000000000000000000000000000000000000000;;		var prevName string
0000000000000000000000000000000000000000;;		for l := range c {
0000000000000000000000000000000000000000;;			// Lexer spotted an error already
0000000000000000000000000000000000000000;;			if l.err == true {
0000000000000000000000000000000000000000;;				t <- &Token{Error: &ParseError{f, l.token, l}}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch st {
0000000000000000000000000000000000000000;;			case zExpectOwnerDir:
0000000000000000000000000000000000000000;;				// We can also expect a directive, like $TTL or $ORIGIN
0000000000000000000000000000000000000000;;				h.Ttl = defttl
0000000000000000000000000000000000000000;;				h.Class = ClassINET
0000000000000000000000000000000000000000;;				switch l.value {
0000000000000000000000000000000000000000;;				case zNewline:
0000000000000000000000000000000000000000;;					st = zExpectOwnerDir
0000000000000000000000000000000000000000;;				case zOwner:
0000000000000000000000000000000000000000;;					h.Name = l.token
0000000000000000000000000000000000000000;;					if l.token[0] == '@' {
0000000000000000000000000000000000000000;;						h.Name = origin
0000000000000000000000000000000000000000;;						prevName = h.Name
0000000000000000000000000000000000000000;;						st = zExpectOwnerBl
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if h.Name[l.length-1] != '.' {
0000000000000000000000000000000000000000;;						h.Name = appendOrigin(h.Name, origin)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t <- &Token{Error: &ParseError{f, "bad owner name", l}}
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					prevName = h.Name
0000000000000000000000000000000000000000;;					st = zExpectOwnerBl
0000000000000000000000000000000000000000;;				case zDirTtl:
0000000000000000000000000000000000000000;;					st = zExpectDirTtlBl
0000000000000000000000000000000000000000;;				case zDirOrigin:
0000000000000000000000000000000000000000;;					st = zExpectDirOriginBl
0000000000000000000000000000000000000000;;				case zDirInclude:
0000000000000000000000000000000000000000;;					st = zExpectDirIncludeBl
0000000000000000000000000000000000000000;;				case zDirGenerate:
0000000000000000000000000000000000000000;;					st = zExpectDirGenerateBl
0000000000000000000000000000000000000000;;				case zRrtpe:
0000000000000000000000000000000000000000;;					h.Name = prevName
0000000000000000000000000000000000000000;;					h.Rrtype = l.torc
0000000000000000000000000000000000000000;;					st = zExpectRdata
0000000000000000000000000000000000000000;;				case zClass:
0000000000000000000000000000000000000000;;					h.Name = prevName
0000000000000000000000000000000000000000;;					h.Class = l.torc
0000000000000000000000000000000000000000;;					st = zExpectAnyNoClassBl
0000000000000000000000000000000000000000;;				case zBlank:
0000000000000000000000000000000000000000;;					// Discard, can happen when there is nothing on the
0000000000000000000000000000000000000000;;					// line except the RR type
0000000000000000000000000000000000000000;;				case zString:
0000000000000000000000000000000000000000;;					ttl, ok := stringToTtl(l.token)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t <- &Token{Error: &ParseError{f, "not a TTL", l}}
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					h.Ttl = ttl
0000000000000000000000000000000000000000;;					// Don't about the defttl, we should take the $TTL value
0000000000000000000000000000000000000000;;					// defttl = ttl
0000000000000000000000000000000000000000;;					st = zExpectAnyNoTtlBl
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "syntax error at beginning", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case zExpectDirIncludeBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank after $INCLUDE-directive", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectDirInclude
0000000000000000000000000000000000000000;;			case zExpectDirInclude:
0000000000000000000000000000000000000000;;				if l.value != zString {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting $INCLUDE value, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				neworigin := origin // There may be optionally a new origin set after the filename, if not use current one
0000000000000000000000000000000000000000;;				l := <-c
0000000000000000000000000000000000000000;;				switch l.value {
0000000000000000000000000000000000000000;;				case zBlank:
0000000000000000000000000000000000000000;;					l := <-c
0000000000000000000000000000000000000000;;					if l.value == zString {
0000000000000000000000000000000000000000;;						if _, ok := IsDomainName(l.token); !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;							t <- &Token{Error: &ParseError{f, "bad origin name", l}}
0000000000000000000000000000000000000000;;							return
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						// a new origin is specified.
0000000000000000000000000000000000000000;;						if l.token[l.length-1] != '.' {
0000000000000000000000000000000000000000;;							if origin != "." { // Prevent .. endings
0000000000000000000000000000000000000000;;								neworigin = l.token + "." + origin
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								neworigin = l.token + origin
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							neworigin = l.token
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case zNewline, zEOF:
0000000000000000000000000000000000000000;;					// Ok
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "garbage after $INCLUDE", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Start with the new file
0000000000000000000000000000000000000000;;				r1, e1 := os.Open(l.token)
0000000000000000000000000000000000000000;;				if e1 != nil {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "failed to open `" + l.token + "'", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if include+1 > 7 {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "too deeply nested $INCLUDE", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				parseZone(r1, l.token, neworigin, t, include+1)
0000000000000000000000000000000000000000;;				st = zExpectOwnerDir
0000000000000000000000000000000000000000;;			case zExpectDirTtlBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank after $TTL-directive", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectDirTtl
0000000000000000000000000000000000000000;;			case zExpectDirTtl:
0000000000000000000000000000000000000000;;				if l.value != zString {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting $TTL value, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, _ := slurpRemainder(c, f); e != nil {
0000000000000000000000000000000000000000;;					t <- &Token{Error: e}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ttl, ok := stringToTtl(l.token)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting $TTL value, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				defttl = ttl
0000000000000000000000000000000000000000;;				st = zExpectOwnerDir
0000000000000000000000000000000000000000;;			case zExpectDirOriginBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank after $ORIGIN-directive", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectDirOrigin
0000000000000000000000000000000000000000;;			case zExpectDirOrigin:
0000000000000000000000000000000000000000;;				if l.value != zString {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting $ORIGIN value, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if e, _ := slurpRemainder(c, f); e != nil {
0000000000000000000000000000000000000000;;					t <- &Token{Error: e}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if _, ok := IsDomainName(l.token); !ok {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "bad origin name", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if l.token[l.length-1] != '.' {
0000000000000000000000000000000000000000;;					if origin != "." { // Prevent .. endings
0000000000000000000000000000000000000000;;						origin = l.token + "." + origin
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						origin = l.token + origin
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					origin = l.token
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectOwnerDir
0000000000000000000000000000000000000000;;			case zExpectDirGenerateBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank after $GENERATE-directive", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectDirGenerate
0000000000000000000000000000000000000000;;			case zExpectDirGenerate:
0000000000000000000000000000000000000000;;				if l.value != zString {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting $GENERATE value, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if errMsg := generate(l, c, t, origin); errMsg != "" {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, errMsg, l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectOwnerDir
0000000000000000000000000000000000000000;;			case zExpectOwnerBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank after owner", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectAny
0000000000000000000000000000000000000000;;			case zExpectAny:
0000000000000000000000000000000000000000;;				switch l.value {
0000000000000000000000000000000000000000;;				case zRrtpe:
0000000000000000000000000000000000000000;;					h.Rrtype = l.torc
0000000000000000000000000000000000000000;;					st = zExpectRdata
0000000000000000000000000000000000000000;;				case zClass:
0000000000000000000000000000000000000000;;					h.Class = l.torc
0000000000000000000000000000000000000000;;					st = zExpectAnyNoClassBl
0000000000000000000000000000000000000000;;				case zString:
0000000000000000000000000000000000000000;;					ttl, ok := stringToTtl(l.token)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t <- &Token{Error: &ParseError{f, "not a TTL", l}}
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					h.Ttl = ttl
0000000000000000000000000000000000000000;;					// defttl = ttl // don't set the defttl here
0000000000000000000000000000000000000000;;					st = zExpectAnyNoTtlBl
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting RR type, TTL or class, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case zExpectAnyNoClassBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank before class", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectAnyNoClass
0000000000000000000000000000000000000000;;			case zExpectAnyNoTtlBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank before TTL", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectAnyNoTtl
0000000000000000000000000000000000000000;;			case zExpectAnyNoTtl:
0000000000000000000000000000000000000000;;				switch l.value {
0000000000000000000000000000000000000000;;				case zClass:
0000000000000000000000000000000000000000;;					h.Class = l.torc
0000000000000000000000000000000000000000;;					st = zExpectRrtypeBl
0000000000000000000000000000000000000000;;				case zRrtpe:
0000000000000000000000000000000000000000;;					h.Rrtype = l.torc
0000000000000000000000000000000000000000;;					st = zExpectRdata
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting RR type or class, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case zExpectAnyNoClass:
0000000000000000000000000000000000000000;;				switch l.value {
0000000000000000000000000000000000000000;;				case zString:
0000000000000000000000000000000000000000;;					ttl, ok := stringToTtl(l.token)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						t <- &Token{Error: &ParseError{f, "not a TTL", l}}
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					h.Ttl = ttl
0000000000000000000000000000000000000000;;					// defttl = ttl // don't set the def ttl anymore
0000000000000000000000000000000000000000;;					st = zExpectRrtypeBl
0000000000000000000000000000000000000000;;				case zRrtpe:
0000000000000000000000000000000000000000;;					h.Rrtype = l.torc
0000000000000000000000000000000000000000;;					st = zExpectRdata
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "expecting RR type or TTL, not this...", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case zExpectRrtypeBl:
0000000000000000000000000000000000000000;;				if l.value != zBlank {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "no blank before RR type", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				st = zExpectRrtype
0000000000000000000000000000000000000000;;			case zExpectRrtype:
0000000000000000000000000000000000000000;;				if l.value != zRrtpe {
0000000000000000000000000000000000000000;;					t <- &Token{Error: &ParseError{f, "unknown RR type", l}}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				h.Rrtype = l.torc
0000000000000000000000000000000000000000;;				st = zExpectRdata
0000000000000000000000000000000000000000;;			case zExpectRdata:
0000000000000000000000000000000000000000;;				r, e, c1 := setRR(h, c, origin, f)
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					// If e.lex is nil than we have encounter a unknown RR type
0000000000000000000000000000000000000000;;					// in that case we substitute our current lex token
0000000000000000000000000000000000000000;;					if e.lex.token == "" && e.lex.value == 0 {
0000000000000000000000000000000000000000;;						e.lex = l // Uh, dirty
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					t <- &Token{Error: e}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				t <- &Token{RR: r, Comment: c1}
0000000000000000000000000000000000000000;;				st = zExpectOwnerDir
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we get here, we and the h.Rrtype is still zero, we haven't parsed anything, this
0000000000000000000000000000000000000000;;		// is not an error, because an empty zone file is still a zone file.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// zlexer scans the sourcefile and returns tokens on the channel c.
0000000000000000000000000000000000000000;;	func zlexer(s *scan, c chan lex) {
0000000000000000000000000000000000000000;;		var l lex
0000000000000000000000000000000000000000;;		str := make([]byte, maxTok) // Should be enough for any token
0000000000000000000000000000000000000000;;		stri := 0                   // Offset in str (0 means empty)
0000000000000000000000000000000000000000;;		com := make([]byte, maxTok) // Hold comment text
0000000000000000000000000000000000000000;;		comi := 0
0000000000000000000000000000000000000000;;		quote := false
0000000000000000000000000000000000000000;;		escape := false
0000000000000000000000000000000000000000;;		space := false
0000000000000000000000000000000000000000;;		commt := false
0000000000000000000000000000000000000000;;		rrtype := false
0000000000000000000000000000000000000000;;		owner := true
0000000000000000000000000000000000000000;;		brace := 0
0000000000000000000000000000000000000000;;		x, err := s.tokenText()
0000000000000000000000000000000000000000;;		defer close(c)
0000000000000000000000000000000000000000;;		for err == nil {
0000000000000000000000000000000000000000;;			l.column = s.position.Column
0000000000000000000000000000000000000000;;			l.line = s.position.Line
0000000000000000000000000000000000000000;;			if stri >= maxTok {
0000000000000000000000000000000000000000;;				l.token = "token length insufficient for parsing"
0000000000000000000000000000000000000000;;				l.err = true
0000000000000000000000000000000000000000;;				debug.Printf("[%+v]", l.token)
0000000000000000000000000000000000000000;;				c <- l
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if comi >= maxTok {
0000000000000000000000000000000000000000;;				l.token = "comment length insufficient for parsing"
0000000000000000000000000000000000000000;;				l.err = true
0000000000000000000000000000000000000000;;				debug.Printf("[%+v]", l.token)
0000000000000000000000000000000000000000;;				c <- l
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch x {
0000000000000000000000000000000000000000;;			case ' ', '\t':
0000000000000000000000000000000000000000;;				if escape {
0000000000000000000000000000000000000000;;					escape = false
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quote {
0000000000000000000000000000000000000000;;					// Inside quotes this is legal
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					com[comi] = x
0000000000000000000000000000000000000000;;					comi++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if stri == 0 {
0000000000000000000000000000000000000000;;					// Space directly in the beginning, handled in the grammar
0000000000000000000000000000000000000000;;				} else if owner {
0000000000000000000000000000000000000000;;					// If we have a string and its the first, make it an owner
0000000000000000000000000000000000000000;;					l.value = zOwner
0000000000000000000000000000000000000000;;					l.token = string(str[:stri])
0000000000000000000000000000000000000000;;					l.tokenUpper = strings.ToUpper(l.token)
0000000000000000000000000000000000000000;;					l.length = stri
0000000000000000000000000000000000000000;;					// escape $... start with a \ not a $, so this will work
0000000000000000000000000000000000000000;;					switch l.tokenUpper {
0000000000000000000000000000000000000000;;					case "$TTL":
0000000000000000000000000000000000000000;;						l.value = zDirTtl
0000000000000000000000000000000000000000;;					case "$ORIGIN":
0000000000000000000000000000000000000000;;						l.value = zDirOrigin
0000000000000000000000000000000000000000;;					case "$INCLUDE":
0000000000000000000000000000000000000000;;						l.value = zDirInclude
0000000000000000000000000000000000000000;;					case "$GENERATE":
0000000000000000000000000000000000000000;;						l.value = zDirGenerate
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					debug.Printf("[7 %+v]", l.token)
0000000000000000000000000000000000000000;;					c <- l
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					l.value = zString
0000000000000000000000000000000000000000;;					l.token = string(str[:stri])
0000000000000000000000000000000000000000;;					l.tokenUpper = strings.ToUpper(l.token)
0000000000000000000000000000000000000000;;					l.length = stri
0000000000000000000000000000000000000000;;					if !rrtype {
0000000000000000000000000000000000000000;;						if t, ok := StringToType[l.tokenUpper]; ok {
0000000000000000000000000000000000000000;;							l.value = zRrtpe
0000000000000000000000000000000000000000;;							l.torc = t
0000000000000000000000000000000000000000;;							rrtype = true
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							if strings.HasPrefix(l.tokenUpper, "TYPE") {
0000000000000000000000000000000000000000;;								t, ok := typeToInt(l.token)
0000000000000000000000000000000000000000;;								if !ok {
0000000000000000000000000000000000000000;;									l.token = "unknown RR type"
0000000000000000000000000000000000000000;;									l.err = true
0000000000000000000000000000000000000000;;									c <- l
0000000000000000000000000000000000000000;;									return
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								l.value = zRrtpe
0000000000000000000000000000000000000000;;								l.torc = t
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if t, ok := StringToClass[l.tokenUpper]; ok {
0000000000000000000000000000000000000000;;							l.value = zClass
0000000000000000000000000000000000000000;;							l.torc = t
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							if strings.HasPrefix(l.tokenUpper, "CLASS") {
0000000000000000000000000000000000000000;;								t, ok := classToInt(l.token)
0000000000000000000000000000000000000000;;								if !ok {
0000000000000000000000000000000000000000;;									l.token = "unknown class"
0000000000000000000000000000000000000000;;									l.err = true
0000000000000000000000000000000000000000;;									c <- l
0000000000000000000000000000000000000000;;									return
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								l.value = zClass
0000000000000000000000000000000000000000;;								l.torc = t
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					debug.Printf("[6 %+v]", l.token)
0000000000000000000000000000000000000000;;					c <- l
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				stri = 0
0000000000000000000000000000000000000000;;				// I reverse space stuff here
0000000000000000000000000000000000000000;;				if !space && !commt {
0000000000000000000000000000000000000000;;					l.value = zBlank
0000000000000000000000000000000000000000;;					l.token = " "
0000000000000000000000000000000000000000;;					l.length = 1
0000000000000000000000000000000000000000;;					debug.Printf("[5 %+v]", l.token)
0000000000000000000000000000000000000000;;					c <- l
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				owner = false
0000000000000000000000000000000000000000;;				space = true
0000000000000000000000000000000000000000;;			case ';':
0000000000000000000000000000000000000000;;				if escape {
0000000000000000000000000000000000000000;;					escape = false
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quote {
0000000000000000000000000000000000000000;;					// Inside quotes this is legal
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if stri > 0 {
0000000000000000000000000000000000000000;;					l.value = zString
0000000000000000000000000000000000000000;;					l.token = string(str[:stri])
0000000000000000000000000000000000000000;;					l.length = stri
0000000000000000000000000000000000000000;;					debug.Printf("[4 %+v]", l.token)
0000000000000000000000000000000000000000;;					c <- l
0000000000000000000000000000000000000000;;					stri = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				commt = true
0000000000000000000000000000000000000000;;				com[comi] = ';'
0000000000000000000000000000000000000000;;				comi++
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				escape = false
0000000000000000000000000000000000000000;;				if quote {
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// discard if outside of quotes
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				escape = false
0000000000000000000000000000000000000000;;				// Escaped newline
0000000000000000000000000000000000000000;;				if quote {
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// inside quotes this is legal
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					// Reset a comment
0000000000000000000000000000000000000000;;					commt = false
0000000000000000000000000000000000000000;;					rrtype = false
0000000000000000000000000000000000000000;;					stri = 0
0000000000000000000000000000000000000000;;					// If not in a brace this ends the comment AND the RR
0000000000000000000000000000000000000000;;					if brace == 0 {
0000000000000000000000000000000000000000;;						owner = true
0000000000000000000000000000000000000000;;						owner = true
0000000000000000000000000000000000000000;;						l.value = zNewline
0000000000000000000000000000000000000000;;						l.token = "\n"
0000000000000000000000000000000000000000;;						l.length = 1
0000000000000000000000000000000000000000;;						l.comment = string(com[:comi])
0000000000000000000000000000000000000000;;						debug.Printf("[3 %+v %+v]", l.token, l.comment)
0000000000000000000000000000000000000000;;						c <- l
0000000000000000000000000000000000000000;;						l.comment = ""
0000000000000000000000000000000000000000;;						comi = 0
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					com[comi] = ' ' // convert newline to space
0000000000000000000000000000000000000000;;					comi++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if brace == 0 {
0000000000000000000000000000000000000000;;					// If there is previous text, we should output it here
0000000000000000000000000000000000000000;;					if stri != 0 {
0000000000000000000000000000000000000000;;						l.value = zString
0000000000000000000000000000000000000000;;						l.token = string(str[:stri])
0000000000000000000000000000000000000000;;						l.tokenUpper = strings.ToUpper(l.token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						l.length = stri
0000000000000000000000000000000000000000;;						if !rrtype {
0000000000000000000000000000000000000000;;							if t, ok := StringToType[l.tokenUpper]; ok {
0000000000000000000000000000000000000000;;								l.value = zRrtpe
0000000000000000000000000000000000000000;;								l.torc = t
0000000000000000000000000000000000000000;;								rrtype = true
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						debug.Printf("[2 %+v]", l.token)
0000000000000000000000000000000000000000;;						c <- l
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					l.value = zNewline
0000000000000000000000000000000000000000;;					l.token = "\n"
0000000000000000000000000000000000000000;;					l.length = 1
0000000000000000000000000000000000000000;;					debug.Printf("[1 %+v]", l.token)
0000000000000000000000000000000000000000;;					c <- l
0000000000000000000000000000000000000000;;					stri = 0
0000000000000000000000000000000000000000;;					commt = false
0000000000000000000000000000000000000000;;					rrtype = false
0000000000000000000000000000000000000000;;					owner = true
0000000000000000000000000000000000000000;;					comi = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				// comments do not get escaped chars, everything is copied
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					com[comi] = x
0000000000000000000000000000000000000000;;					comi++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// something already escaped must be in string
0000000000000000000000000000000000000000;;				if escape {
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					escape = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// something escaped outside of string gets added to string
0000000000000000000000000000000000000000;;				str[stri] = x
0000000000000000000000000000000000000000;;				stri++
0000000000000000000000000000000000000000;;				escape = true
0000000000000000000000000000000000000000;;			case '"':
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					com[comi] = x
0000000000000000000000000000000000000000;;					comi++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if escape {
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					escape = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				space = false
0000000000000000000000000000000000000000;;				// send previous gathered text and the quote
0000000000000000000000000000000000000000;;				if stri != 0 {
0000000000000000000000000000000000000000;;					l.value = zString
0000000000000000000000000000000000000000;;					l.token = string(str[:stri])
0000000000000000000000000000000000000000;;					l.length = stri
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					debug.Printf("[%+v]", l.token)
0000000000000000000000000000000000000000;;					c <- l
0000000000000000000000000000000000000000;;					stri = 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// send quote itself as separate token
0000000000000000000000000000000000000000;;				l.value = zQuote
0000000000000000000000000000000000000000;;				l.token = "\""
0000000000000000000000000000000000000000;;				l.length = 1
0000000000000000000000000000000000000000;;				c <- l
0000000000000000000000000000000000000000;;				quote = !quote
0000000000000000000000000000000000000000;;			case '(', ')':
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					com[comi] = x
0000000000000000000000000000000000000000;;					comi++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if escape {
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					escape = false
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if quote {
0000000000000000000000000000000000000000;;					str[stri] = x
0000000000000000000000000000000000000000;;					stri++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch x {
0000000000000000000000000000000000000000;;				case ')':
0000000000000000000000000000000000000000;;					brace--
0000000000000000000000000000000000000000;;					if brace < 0 {
0000000000000000000000000000000000000000;;						l.token = "extra closing brace"
0000000000000000000000000000000000000000;;						l.err = true
0000000000000000000000000000000000000000;;						debug.Printf("[%+v]", l.token)
0000000000000000000000000000000000000000;;						c <- l
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case '(':
0000000000000000000000000000000000000000;;					brace++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				escape = false
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					com[comi] = x
0000000000000000000000000000000000000000;;					comi++
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				str[stri] = x
0000000000000000000000000000000000000000;;				stri++
0000000000000000000000000000000000000000;;				space = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x, err = s.tokenText()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if stri > 0 {
0000000000000000000000000000000000000000;;			// Send remainder
0000000000000000000000000000000000000000;;			l.token = string(str[:stri])
0000000000000000000000000000000000000000;;			l.length = stri
0000000000000000000000000000000000000000;;			l.value = zString
0000000000000000000000000000000000000000;;			debug.Printf("[%+v]", l.token)
0000000000000000000000000000000000000000;;			c <- l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract the class number from CLASSxx
0000000000000000000000000000000000000000;;	func classToInt(token string) (uint16, bool) {
0000000000000000000000000000000000000000;;		offset := 5
0000000000000000000000000000000000000000;;		if len(token) < offset+1 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		class, ok := strconv.Atoi(token[offset:])
0000000000000000000000000000000000000000;;		if ok != nil || class > maxUint16 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint16(class), true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract the rr number from TYPExxx
0000000000000000000000000000000000000000;;	func typeToInt(token string) (uint16, bool) {
0000000000000000000000000000000000000000;;		offset := 4
0000000000000000000000000000000000000000;;		if len(token) < offset+1 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		typ, ok := strconv.Atoi(token[offset:])
0000000000000000000000000000000000000000;;		if ok != nil || typ > maxUint16 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint16(typ), true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse things like 2w, 2m, etc, Return the time in seconds.
0000000000000000000000000000000000000000;;	func stringToTtl(token string) (uint32, bool) {
0000000000000000000000000000000000000000;;		s := uint32(0)
0000000000000000000000000000000000000000;;		i := uint32(0)
0000000000000000000000000000000000000000;;		for _, c := range token {
0000000000000000000000000000000000000000;;			switch c {
0000000000000000000000000000000000000000;;			case 's', 'S':
0000000000000000000000000000000000000000;;				s += i
0000000000000000000000000000000000000000;;				i = 0
0000000000000000000000000000000000000000;;			case 'm', 'M':
0000000000000000000000000000000000000000;;				s += i * 60
0000000000000000000000000000000000000000;;				i = 0
0000000000000000000000000000000000000000;;			case 'h', 'H':
0000000000000000000000000000000000000000;;				s += i * 60 * 60
0000000000000000000000000000000000000000;;				i = 0
0000000000000000000000000000000000000000;;			case 'd', 'D':
0000000000000000000000000000000000000000;;				s += i * 60 * 60 * 24
0000000000000000000000000000000000000000;;				i = 0
0000000000000000000000000000000000000000;;			case 'w', 'W':
0000000000000000000000000000000000000000;;				s += i * 60 * 60 * 24 * 7
0000000000000000000000000000000000000000;;				i = 0
0000000000000000000000000000000000000000;;			case '0', '1', '2', '3', '4', '5', '6', '7', '8', '9':
0000000000000000000000000000000000000000;;				i *= 10
0000000000000000000000000000000000000000;;				i += uint32(c) - '0'
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s + i, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse LOC records' <digits>[.<digits>][mM] into a
0000000000000000000000000000000000000000;;	// mantissa exponent format. Token should contain the entire
0000000000000000000000000000000000000000;;	// string (i.e. no spaces allowed)
0000000000000000000000000000000000000000;;	func stringToCm(token string) (e, m uint8, ok bool) {
0000000000000000000000000000000000000000;;		if token[len(token)-1] == 'M' || token[len(token)-1] == 'm' {
0000000000000000000000000000000000000000;;			token = token[0 : len(token)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := strings.SplitN(token, ".", 2)
0000000000000000000000000000000000000000;;		var meters, cmeters, val int
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		switch len(s) {
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			if cmeters, err = strconv.Atoi(s[1]); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			if meters, err = strconv.Atoi(s[0]); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			// huh?
0000000000000000000000000000000000000000;;			return 0, 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ok = true
0000000000000000000000000000000000000000;;		if meters > 0 {
0000000000000000000000000000000000000000;;			e = 2
0000000000000000000000000000000000000000;;			val = meters
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			e = 0
0000000000000000000000000000000000000000;;			val = cmeters
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for val > 10 {
0000000000000000000000000000000000000000;;			e++
0000000000000000000000000000000000000000;;			val /= 10
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if e > 9 {
0000000000000000000000000000000000000000;;			ok = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m = uint8(val)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func appendOrigin(name, origin string) string {
0000000000000000000000000000000000000000;;		if origin == "." {
0000000000000000000000000000000000000000;;			return name + origin
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return name + "." + origin
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LOC record helper function
0000000000000000000000000000000000000000;;	func locCheckNorth(token string, latitude uint32) (uint32, bool) {
0000000000000000000000000000000000000000;;		switch token {
0000000000000000000000000000000000000000;;		case "n", "N":
0000000000000000000000000000000000000000;;			return LOC_EQUATOR + latitude, true
0000000000000000000000000000000000000000;;		case "s", "S":
0000000000000000000000000000000000000000;;			return LOC_EQUATOR - latitude, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return latitude, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LOC record helper function
0000000000000000000000000000000000000000;;	func locCheckEast(token string, longitude uint32) (uint32, bool) {
0000000000000000000000000000000000000000;;		switch token {
0000000000000000000000000000000000000000;;		case "e", "E":
0000000000000000000000000000000000000000;;			return LOC_EQUATOR + longitude, true
0000000000000000000000000000000000000000;;		case "w", "W":
0000000000000000000000000000000000000000;;			return LOC_EQUATOR - longitude, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return longitude, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// "Eat" the rest of the "line". Return potential comments
0000000000000000000000000000000000000000;;	func slurpRemainder(c chan lex, f string) (*ParseError, string) {
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		com := ""
0000000000000000000000000000000000000000;;		switch l.value {
0000000000000000000000000000000000000000;;		case zBlank:
0000000000000000000000000000000000000000;;			l = <-c
0000000000000000000000000000000000000000;;			com = l.comment
0000000000000000000000000000000000000000;;			if l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;				return &ParseError{f, "garbage after rdata", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case zNewline:
0000000000000000000000000000000000000000;;			com = l.comment
0000000000000000000000000000000000000000;;		case zEOF:
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return &ParseError{f, "garbage after rdata", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, com
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse a 64 bit-like ipv6 address: "0014:4fff:ff20:ee64"
0000000000000000000000000000000000000000;;	// Used for NID and L64 record.
0000000000000000000000000000000000000000;;	func stringToNodeID(l lex) (uint64, *ParseError) {
0000000000000000000000000000000000000000;;		if len(l.token) < 19 {
0000000000000000000000000000000000000000;;			return 0, &ParseError{l.token, "bad NID/L64 NodeID/Locator64", l}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// There must be three colons at fixes postitions, if not its a parse error
0000000000000000000000000000000000000000;;		if l.token[4] != ':' && l.token[9] != ':' && l.token[14] != ':' {
0000000000000000000000000000000000000000;;			return 0, &ParseError{l.token, "bad NID/L64 NodeID/Locator64", l}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := l.token[0:4] + l.token[5:9] + l.token[10:14] + l.token[15:19]
0000000000000000000000000000000000000000;;		u, err := strconv.ParseUint(s, 16, 64)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, &ParseError{l.token, "bad NID/L64 NodeID/Locator64", l}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return u, nil
0000000000000000000000000000000000000000;;	}
