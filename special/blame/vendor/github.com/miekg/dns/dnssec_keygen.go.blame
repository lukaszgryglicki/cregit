0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/keygen.go[Godeps/_workspace/src/github.com/miekg/dns/keygen.go][vendor/github.com/miekg/dns/dnssec_keygen.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/dsa"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Generate generates a DNSKEY of the given bit size.
0000000000000000000000000000000000000000;;	// The public part is put inside the DNSKEY record.
0000000000000000000000000000000000000000;;	// The Algorithm in the key must be set as this will define
0000000000000000000000000000000000000000;;	// what kind of DNSKEY will be generated.
0000000000000000000000000000000000000000;;	// The ECDSA algorithms imply a fixed keysize, in that case
0000000000000000000000000000000000000000;;	// bits should be set to the size of the algorithm.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) Generate(bits int) (crypto.PrivateKey, error) {
0000000000000000000000000000000000000000;;		switch k.Algorithm {
0000000000000000000000000000000000000000;;		case DSA, DSANSEC3SHA1:
0000000000000000000000000000000000000000;;			if bits != 1024 {
0000000000000000000000000000000000000000;;				return nil, ErrKeySize
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case RSAMD5, RSASHA1, RSASHA256, RSASHA1NSEC3SHA1:
0000000000000000000000000000000000000000;;			if bits < 512 || bits > 4096 {
0000000000000000000000000000000000000000;;				return nil, ErrKeySize
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case RSASHA512:
0000000000000000000000000000000000000000;;			if bits < 1024 || bits > 4096 {
0000000000000000000000000000000000000000;;				return nil, ErrKeySize
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256:
0000000000000000000000000000000000000000;;			if bits != 256 {
0000000000000000000000000000000000000000;;				return nil, ErrKeySize
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			if bits != 384 {
0000000000000000000000000000000000000000;;				return nil, ErrKeySize
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch k.Algorithm {
0000000000000000000000000000000000000000;;		case DSA, DSANSEC3SHA1:
0000000000000000000000000000000000000000;;			params := new(dsa.Parameters)
0000000000000000000000000000000000000000;;			if err := dsa.GenerateParameters(params, rand.Reader, dsa.L1024N160); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			priv := new(dsa.PrivateKey)
0000000000000000000000000000000000000000;;			priv.PublicKey.Parameters = *params
0000000000000000000000000000000000000000;;			err := dsa.GenerateKey(priv, rand.Reader)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k.setPublicKeyDSA(params.Q, params.P, params.G, priv.PublicKey.Y)
0000000000000000000000000000000000000000;;			return priv, nil
0000000000000000000000000000000000000000;;		case RSAMD5, RSASHA1, RSASHA256, RSASHA512, RSASHA1NSEC3SHA1:
0000000000000000000000000000000000000000;;			priv, err := rsa.GenerateKey(rand.Reader, bits)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k.setPublicKeyRSA(priv.PublicKey.E, priv.PublicKey.N)
0000000000000000000000000000000000000000;;			return priv, nil
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256, ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			var c elliptic.Curve
0000000000000000000000000000000000000000;;			switch k.Algorithm {
0000000000000000000000000000000000000000;;			case ECDSAP256SHA256:
0000000000000000000000000000000000000000;;				c = elliptic.P256()
0000000000000000000000000000000000000000;;			case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;				c = elliptic.P384()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			priv, err := ecdsa.GenerateKey(c, rand.Reader)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			k.setPublicKeyECDSA(priv.PublicKey.X, priv.PublicKey.Y)
0000000000000000000000000000000000000000;;			return priv, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the public key (the value E and N)
0000000000000000000000000000000000000000;;	func (k *DNSKEY) setPublicKeyRSA(_E int, _N *big.Int) bool {
0000000000000000000000000000000000000000;;		if _E == 0 || _N == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := exponentToBuf(_E)
0000000000000000000000000000000000000000;;		buf = append(buf, _N.Bytes()...)
0000000000000000000000000000000000000000;;		k.PublicKey = toBase64(buf)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the public key for Elliptic Curves
0000000000000000000000000000000000000000;;	func (k *DNSKEY) setPublicKeyECDSA(_X, _Y *big.Int) bool {
0000000000000000000000000000000000000000;;		if _X == nil || _Y == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var intlen int
0000000000000000000000000000000000000000;;		switch k.Algorithm {
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256:
0000000000000000000000000000000000000000;;			intlen = 32
0000000000000000000000000000000000000000;;		case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			intlen = 48
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		k.PublicKey = toBase64(curveToBuf(_X, _Y, intlen))
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the public key for DSA
0000000000000000000000000000000000000000;;	func (k *DNSKEY) setPublicKeyDSA(_Q, _P, _G, _Y *big.Int) bool {
0000000000000000000000000000000000000000;;		if _Q == nil || _P == nil || _G == nil || _Y == nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := dsaToBuf(_Q, _P, _G, _Y)
0000000000000000000000000000000000000000;;		k.PublicKey = toBase64(buf)
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the public key (the values E and N) for RSA
0000000000000000000000000000000000000000;;	// RFC 3110: Section 2. RSA Public KEY Resource Records
0000000000000000000000000000000000000000;;	func exponentToBuf(_E int) []byte {
0000000000000000000000000000000000000000;;		var buf []byte
0000000000000000000000000000000000000000;;		i := big.NewInt(int64(_E))
0000000000000000000000000000000000000000;;		if len(i.Bytes()) < 256 {
0000000000000000000000000000000000000000;;			buf = make([]byte, 1)
0000000000000000000000000000000000000000;;			buf[0] = uint8(len(i.Bytes()))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			buf = make([]byte, 3)
0000000000000000000000000000000000000000;;			buf[0] = 0
0000000000000000000000000000000000000000;;			buf[1] = uint8(len(i.Bytes()) >> 8)
0000000000000000000000000000000000000000;;			buf[2] = uint8(len(i.Bytes()))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf = append(buf, i.Bytes()...)
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the public key for X and Y for Curve. The two
0000000000000000000000000000000000000000;;	// values are just concatenated.
0000000000000000000000000000000000000000;;	func curveToBuf(_X, _Y *big.Int, intlen int) []byte {
0000000000000000000000000000000000000000;;		buf := intToBytes(_X, intlen)
0000000000000000000000000000000000000000;;		buf = append(buf, intToBytes(_Y, intlen)...)
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the public key for X and Y for Curve. The two
0000000000000000000000000000000000000000;;	// values are just concatenated.
0000000000000000000000000000000000000000;;	func dsaToBuf(_Q, _P, _G, _Y *big.Int) []byte {
0000000000000000000000000000000000000000;;		t := divRoundUp(divRoundUp(_G.BitLen(), 8)-64, 8)
0000000000000000000000000000000000000000;;		buf := []byte{byte(t)}
0000000000000000000000000000000000000000;;		buf = append(buf, intToBytes(_Q, 20)...)
0000000000000000000000000000000000000000;;		buf = append(buf, intToBytes(_P, 64+t*8)...)
0000000000000000000000000000000000000000;;		buf = append(buf, intToBytes(_G, 64+t*8)...)
0000000000000000000000000000000000000000;;		buf = append(buf, intToBytes(_Y, 64+t*8)...)
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
