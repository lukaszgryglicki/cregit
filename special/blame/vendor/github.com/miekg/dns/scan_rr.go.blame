0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/zscan_rr.go[Godeps/_workspace/src/github.com/miekg/dns/zscan_rr.go][vendor/github.com/miekg/dns/scan_rr.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type parserFunc struct {
0000000000000000000000000000000000000000;;		// Func defines the function that parses the tokens and returns the RR
0000000000000000000000000000000000000000;;		// or an error. The last string contains any comments in the line as
0000000000000000000000000000000000000000;;		// they returned by the lexer as well.
0000000000000000000000000000000000000000;;		Func func(h RR_Header, c chan lex, origin string, file string) (RR, *ParseError, string)
0000000000000000000000000000000000000000;;		// Signals if the RR ending is of variable length, like TXT or records
0000000000000000000000000000000000000000;;		// that have Hexadecimal or Base64 as their last element in the Rdata. Records
0000000000000000000000000000000000000000;;		// that have a fixed ending or for instance A, AAAA, SOA and etc.
0000000000000000000000000000000000000000;;		Variable bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the rdata of each rrtype.
0000000000000000000000000000000000000000;;	// All data from the channel c is either zString or zBlank.
0000000000000000000000000000000000000000;;	// After the rdata there may come a zBlank and then a zNewline
0000000000000000000000000000000000000000;;	// or immediately a zNewline. If this is not the case we flag
0000000000000000000000000000000000000000;;	// an *ParseError: garbage after rdata.
0000000000000000000000000000000000000000;;	func setRR(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		parserfunc, ok := typeToparserFunc[h.Rrtype]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			r, e, cm := parserfunc.Func(h, c, o, f)
0000000000000000000000000000000000000000;;			if parserfunc.Variable {
0000000000000000000000000000000000000000;;				return r, e, cm
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				return nil, e, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e, cm = slurpRemainder(c, f)
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				return nil, e, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return r, nil, cm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// RFC3957 RR (Unknown RR handling)
0000000000000000000000000000000000000000;;		return setRFC3597(h, c, o, f)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A remainder of the rdata with embedded spaces, return the parsed string (sans the spaces)
0000000000000000000000000000000000000000;;	// or an error
0000000000000000000000000000000000000000;;	func endingToString(c chan lex, errstr, f string) (string, *ParseError, string) {
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		l := <-c // zString
0000000000000000000000000000000000000000;;		for l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;			if l.err {
0000000000000000000000000000000000000000;;				return s, &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch l.value {
0000000000000000000000000000000000000000;;			case zString:
0000000000000000000000000000000000000000;;				s += l.token
0000000000000000000000000000000000000000;;			case zBlank: // Ok
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return "", &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l = <-c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil, l.comment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A remainder of the rdata with embedded spaces, return the parsed string slice (sans the spaces)
0000000000000000000000000000000000000000;;	// or an error
0000000000000000000000000000000000000000;;	func endingToTxtSlice(c chan lex, errstr, f string) ([]string, *ParseError, string) {
0000000000000000000000000000000000000000;;		// Get the remaining data until we see a zNewline
0000000000000000000000000000000000000000;;		quote := false
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		var s []string
0000000000000000000000000000000000000000;;		if l.err {
0000000000000000000000000000000000000000;;			return s, &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch l.value == zQuote {
0000000000000000000000000000000000000000;;		case true: // A number of quoted string
0000000000000000000000000000000000000000;;			s = make([]string, 0)
0000000000000000000000000000000000000000;;			empty := true
0000000000000000000000000000000000000000;;			for l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;				if l.err {
0000000000000000000000000000000000000000;;					return nil, &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch l.value {
0000000000000000000000000000000000000000;;				case zString:
0000000000000000000000000000000000000000;;					empty = false
0000000000000000000000000000000000000000;;					if len(l.token) > 255 {
0000000000000000000000000000000000000000;;						// split up tokens that are larger than 255 into 255-chunks
0000000000000000000000000000000000000000;;						sx := []string{}
0000000000000000000000000000000000000000;;						p, i := 0, 255
0000000000000000000000000000000000000000;;						for {
0000000000000000000000000000000000000000;;							if i <= len(l.token) {
0000000000000000000000000000000000000000;;								sx = append(sx, l.token[p:i])
0000000000000000000000000000000000000000;;							} else {
0000000000000000000000000000000000000000;;								sx = append(sx, l.token[p:])
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							p, i = p+255, i+255
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						s = append(s, sx...)
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					s = append(s, l.token)
0000000000000000000000000000000000000000;;				case zBlank:
0000000000000000000000000000000000000000;;					if quote {
0000000000000000000000000000000000000000;;						// zBlank can only be seen in between txt parts.
0000000000000000000000000000000000000000;;						return nil, &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case zQuote:
0000000000000000000000000000000000000000;;					if empty && quote {
0000000000000000000000000000000000000000;;						s = append(s, "")
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					quote = !quote
0000000000000000000000000000000000000000;;					empty = true
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					return nil, &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l = <-c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if quote {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case false: // Unquoted text record
0000000000000000000000000000000000000000;;			s = make([]string, 1)
0000000000000000000000000000000000000000;;			for l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;				if l.err {
0000000000000000000000000000000000000000;;					return s, &ParseError{f, errstr, l}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s[0] += l.token
0000000000000000000000000000000000000000;;				l = <-c
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s, nil, l.comment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(A)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 { // Dynamic updates.
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.A = net.ParseIP(l.token)
0000000000000000000000000000000000000000;;		if rr.A == nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad A A", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setAAAA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(AAAA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.AAAA = net.ParseIP(l.token)
0000000000000000000000000000000000000000;;		if rr.AAAA == nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad AAAA AAAA", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNS(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NS)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Ns = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Ns = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NS Ns", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Ns[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Ns = appendOrigin(rr.Ns, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setPTR(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(PTR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Ptr = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 { // dynamic update rr.
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Ptr = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad PTR Ptr", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Ptr[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Ptr = appendOrigin(rr.Ptr, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNSAPPTR(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NSAPPTR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Ptr = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Ptr = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSAP-PTR Ptr", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Ptr[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Ptr = appendOrigin(rr.Ptr, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setRP(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(RP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Mbox = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mbox = o
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;			if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad RP Mbox", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rr.Mbox[l.length-1] != '.' {
0000000000000000000000000000000000000000;;				rr.Mbox = appendOrigin(rr.Mbox, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		rr.Txt = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Txt = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RP Txt", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Txt[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Txt = appendOrigin(rr.Txt, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMR(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(MR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Mr = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mr = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MR Mr", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Mr[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Mr = appendOrigin(rr.Mr, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMB(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(MB)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Mb = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mb = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MB Mb", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Mb[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Mb = appendOrigin(rr.Mb, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMG(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(MG)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Mg = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mg = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MG Mg", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Mg[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Mg = appendOrigin(rr.Mg, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setHINFO(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(HINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		chunks, e, c1 := endingToTxtSlice(c, "bad HINFO Fields", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ln := len(chunks); ln == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		} else if ln == 1 {
0000000000000000000000000000000000000000;;			// Can we split it?
0000000000000000000000000000000000000000;;			if out := strings.Fields(chunks[0]); len(out) > 1 {
0000000000000000000000000000000000000000;;				chunks = out
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				chunks = append(chunks, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Cpu = chunks[0]
0000000000000000000000000000000000000000;;		rr.Os = strings.Join(chunks[1:], " ")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMINFO(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(MINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Rmail = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Rmail = o
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;			if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad MINFO Rmail", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rr.Rmail[l.length-1] != '.' {
0000000000000000000000000000000000000000;;				rr.Rmail = appendOrigin(rr.Rmail, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		rr.Email = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Email = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MINFO Email", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Email[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Email = appendOrigin(rr.Email, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMF(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(MF)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Mf = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mf = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MF Mf", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Mf[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Mf = appendOrigin(rr.Mf, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMD(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(MD)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Md = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Md = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MD Md", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Md[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Md = appendOrigin(rr.Md, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setMX(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(MX)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MX Pref", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Mx = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mx = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad MX Mx", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Mx[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Mx = appendOrigin(rr.Mx, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setRT(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(RT)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RT Preference", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Host = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Host = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RT Host", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Host[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Host = appendOrigin(rr.Host, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setAFSDB(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(AFSDB)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad AFSDB Subtype", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Subtype = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Hostname = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Hostname = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad AFSDB Hostname", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Hostname[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Hostname = appendOrigin(rr.Hostname, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setX25(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(X25)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad X25 PSDNAddress", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PSDNAddress = l.token
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setKX(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(KX)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad KX Pref", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Exchanger = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Exchanger = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad KX Exchanger", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Exchanger[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Exchanger = appendOrigin(rr.Exchanger, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCNAME(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(CNAME)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Target = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Target = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CNAME Target", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Target[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Target = appendOrigin(rr.Target, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDNAME(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(DNAME)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Target = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Target = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CNAME Target", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Target[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Target = appendOrigin(rr.Target, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setSOA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(SOA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.Ns = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Ns = o
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;			if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad SOA Ns", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rr.Ns[l.length-1] != '.' {
0000000000000000000000000000000000000000;;				rr.Ns = appendOrigin(rr.Ns, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		rr.Mbox = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mbox = o
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;			if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad SOA Mbox", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rr.Mbox[l.length-1] != '.' {
0000000000000000000000000000000000000000;;				rr.Mbox = appendOrigin(rr.Mbox, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			v  uint32
0000000000000000000000000000000000000000;;			ok bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		for i := 0; i < 5; i++ {
0000000000000000000000000000000000000000;;			l = <-c
0000000000000000000000000000000000000000;;			if l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad SOA zone parameter", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if j, e := strconv.Atoi(l.token); e != nil {
0000000000000000000000000000000000000000;;				if i == 0 {
0000000000000000000000000000000000000000;;					// Serial should be a number
0000000000000000000000000000000000000000;;					return nil, &ParseError{f, "bad SOA zone parameter", l}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if v, ok = stringToTtl(l.token); !ok {
0000000000000000000000000000000000000000;;					return nil, &ParseError{f, "bad SOA zone parameter", l}, ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				v = uint32(j)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch i {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				rr.Serial = v
0000000000000000000000000000000000000000;;				<-c // zBlank
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				rr.Refresh = v
0000000000000000000000000000000000000000;;				<-c // zBlank
0000000000000000000000000000000000000000;;			case 2:
0000000000000000000000000000000000000000;;				rr.Retry = v
0000000000000000000000000000000000000000;;				<-c // zBlank
0000000000000000000000000000000000000000;;			case 3:
0000000000000000000000000000000000000000;;				rr.Expire = v
0000000000000000000000000000000000000000;;				<-c // zBlank
0000000000000000000000000000000000000000;;			case 4:
0000000000000000000000000000000000000000;;				rr.Minttl = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setSRV(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(SRV)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad SRV Priority", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Priority = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad SRV Weight", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Weight = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad SRV Port", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Port = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Target = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Target = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad SRV Target", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Target[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Target = appendOrigin(rr.Target, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNAPTR(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NAPTR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Order", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Order = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Preference", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		// Flags
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // _QUOTE
0000000000000000000000000000000000000000;;		if l.value != zQuote {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Flags", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l = <-c // Either String or Quote
0000000000000000000000000000000000000000;;		if l.value == zString {
0000000000000000000000000000000000000000;;			rr.Flags = l.token
0000000000000000000000000000000000000000;;			l = <-c // _QUOTE
0000000000000000000000000000000000000000;;			if l.value != zQuote {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad NAPTR Flags", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if l.value == zQuote {
0000000000000000000000000000000000000000;;			rr.Flags = ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Flags", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Service
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // _QUOTE
0000000000000000000000000000000000000000;;		if l.value != zQuote {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Service", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l = <-c // Either String or Quote
0000000000000000000000000000000000000000;;		if l.value == zString {
0000000000000000000000000000000000000000;;			rr.Service = l.token
0000000000000000000000000000000000000000;;			l = <-c // _QUOTE
0000000000000000000000000000000000000000;;			if l.value != zQuote {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad NAPTR Service", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if l.value == zQuote {
0000000000000000000000000000000000000000;;			rr.Service = ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Service", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Regexp
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // _QUOTE
0000000000000000000000000000000000000000;;		if l.value != zQuote {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Regexp", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l = <-c // Either String or Quote
0000000000000000000000000000000000000000;;		if l.value == zString {
0000000000000000000000000000000000000000;;			rr.Regexp = l.token
0000000000000000000000000000000000000000;;			l = <-c // _QUOTE
0000000000000000000000000000000000000000;;			if l.value != zQuote {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad NAPTR Regexp", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if l.value == zQuote {
0000000000000000000000000000000000000000;;			rr.Regexp = ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Regexp", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// After quote no space??
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Replacement = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Replacement = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NAPTR Replacement", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Replacement[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Replacement = appendOrigin(rr.Replacement, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setTALINK(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(TALINK)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.PreviousName = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.PreviousName = o
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;			if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad TALINK PreviousName", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rr.PreviousName[l.length-1] != '.' {
0000000000000000000000000000000000000000;;				rr.PreviousName = appendOrigin(rr.PreviousName, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		rr.NextName = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.NextName = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad TALINK NextName", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.NextName[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.NextName = appendOrigin(rr.NextName, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setLOC(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(LOC)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		// Non zero defaults for LOC record, see RFC 1876, Section 3.
0000000000000000000000000000000000000000;;		rr.HorizPre = 165 // 10000
0000000000000000000000000000000000000000;;		rr.VertPre = 162  // 10
0000000000000000000000000000000000000000;;		rr.Size = 18      // 1
0000000000000000000000000000000000000000;;		ok := false
0000000000000000000000000000000000000000;;		// North
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Latitude", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Latitude = 1000 * 60 * 60 * uint32(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		// Either number, 'N' or 'S'
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if rr.Latitude, ok = locCheckNorth(l.token, rr.Latitude); ok {
0000000000000000000000000000000000000000;;			goto East
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Latitude minutes", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Latitude += 1000 * 60 * uint32(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if i, e := strconv.ParseFloat(l.token, 32); e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Latitude seconds", l}, ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Latitude += uint32(1000 * i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		// Either number, 'N' or 'S'
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if rr.Latitude, ok = locCheckNorth(l.token, rr.Latitude); ok {
0000000000000000000000000000000000000000;;			goto East
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If still alive, flag an error
0000000000000000000000000000000000000000;;		return nil, &ParseError{f, "bad LOC Latitude North/South", l}, ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	East:
0000000000000000000000000000000000000000;;		// East
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if i, e := strconv.Atoi(l.token); e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Longitude", l}, ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Longitude = 1000 * 60 * 60 * uint32(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		// Either number, 'E' or 'W'
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if rr.Longitude, ok = locCheckEast(l.token, rr.Longitude); ok {
0000000000000000000000000000000000000000;;			goto Altitude
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i, e := strconv.Atoi(l.token); e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Longitude minutes", l}, ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Longitude += 1000 * 60 * uint32(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if i, e := strconv.ParseFloat(l.token, 32); e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Longitude seconds", l}, ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Longitude += uint32(1000 * i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		// Either number, 'E' or 'W'
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if rr.Longitude, ok = locCheckEast(l.token, rr.Longitude); ok {
0000000000000000000000000000000000000000;;			goto Altitude
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If still alive, flag an error
0000000000000000000000000000000000000000;;		return nil, &ParseError{f, "bad LOC Longitude East/West", l}, ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Altitude:
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Altitude", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token[len(l.token)-1] == 'M' || l.token[len(l.token)-1] == 'm' {
0000000000000000000000000000000000000000;;			l.token = l.token[0 : len(l.token)-1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i, e := strconv.ParseFloat(l.token, 32); e != nil {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LOC Altitude", l}, ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Altitude = uint32(i*100.0 + 10000000.0 + 0.5)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// And now optionally the other values
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;			switch l.value {
0000000000000000000000000000000000000000;;			case zString:
0000000000000000000000000000000000000000;;				switch count {
0000000000000000000000000000000000000000;;				case 0: // Size
0000000000000000000000000000000000000000;;					e, m, ok := stringToCm(l.token)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						return nil, &ParseError{f, "bad LOC Size", l}, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rr.Size = (e & 0x0f) | (m << 4 & 0xf0)
0000000000000000000000000000000000000000;;				case 1: // HorizPre
0000000000000000000000000000000000000000;;					e, m, ok := stringToCm(l.token)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						return nil, &ParseError{f, "bad LOC HorizPre", l}, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rr.HorizPre = (e & 0x0f) | (m << 4 & 0xf0)
0000000000000000000000000000000000000000;;				case 2: // VertPre
0000000000000000000000000000000000000000;;					e, m, ok := stringToCm(l.token)
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						return nil, &ParseError{f, "bad LOC VertPre", l}, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					rr.VertPre = (e & 0x0f) | (m << 4 & 0xf0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				count++
0000000000000000000000000000000000000000;;			case zBlank:
0000000000000000000000000000000000000000;;				// Ok
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad LOC Size, HorizPre or VertPre", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l = <-c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setHIP(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(HIP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HitLength is not represented
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad HIP PublicKeyAlgorithm", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKeyAlgorithm = uint8(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		if l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad HIP Hit", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Hit = l.token // This can not contain spaces, see RFC 5205 Section 6.
0000000000000000000000000000000000000000;;		rr.HitLength = uint8(len(rr.Hit)) / 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		if l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad HIP PublicKey", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey = l.token // This cannot contain spaces
0000000000000000000000000000000000000000;;		rr.PublicKeyLength = uint16(base64.StdEncoding.DecodedLen(len(rr.PublicKey)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RendezvousServers (if any)
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		var xs []string
0000000000000000000000000000000000000000;;		for l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;			switch l.value {
0000000000000000000000000000000000000000;;			case zString:
0000000000000000000000000000000000000000;;				if l.token == "@" {
0000000000000000000000000000000000000000;;					xs = append(xs, o)
0000000000000000000000000000000000000000;;					l = <-c
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;				if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;					return nil, &ParseError{f, "bad HIP RendezvousServers", l}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if l.token[l.length-1] != '.' {
0000000000000000000000000000000000000000;;					l.token = appendOrigin(l.token, o)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				xs = append(xs, l.token)
0000000000000000000000000000000000000000;;			case zBlank:
0000000000000000000000000000000000000000;;				// Ok
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad HIP RendezvousServers", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l = <-c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.RendezvousServers = xs
0000000000000000000000000000000000000000;;		return rr, nil, l.comment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCERT(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(CERT)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v, ok := StringToCertType[l.token]; ok {
0000000000000000000000000000000000000000;;			rr.Type = v
0000000000000000000000000000000000000000;;		} else if i, e := strconv.Atoi(l.token); e != nil {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CERT Type", l}, ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Type = uint16(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CERT KeyTag", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeyTag = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		if v, ok := StringToAlgorithm[l.token]; ok {
0000000000000000000000000000000000000000;;			rr.Algorithm = v
0000000000000000000000000000000000000000;;		} else if i, e := strconv.Atoi(l.token); e != nil {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CERT Algorithm", l}, ""
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Algorithm = uint8(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s, e1, c1 := endingToString(c, "bad CERT Certificate", f)
0000000000000000000000000000000000000000;;		if e1 != nil {
0000000000000000000000000000000000000000;;			return nil, e1, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Certificate = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setOPENPGPKEY(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(OPENPGPKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, e, c1 := endingToString(c, "bad OPENPGPKEY PublicKey", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setSIG(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		r, e, s := setRRSIG(h, c, o, f)
0000000000000000000000000000000000000000;;		if r != nil {
0000000000000000000000000000000000000000;;			return &SIG{*r.(*RRSIG)}, e, s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, e, s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setRRSIG(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(RRSIG)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t, ok := StringToType[l.tokenUpper]; !ok {
0000000000000000000000000000000000000000;;			if strings.HasPrefix(l.tokenUpper, "TYPE") {
0000000000000000000000000000000000000000;;				t, ok = typeToInt(l.tokenUpper)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, &ParseError{f, "bad RRSIG Typecovered", l}, ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rr.TypeCovered = t
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad RRSIG Typecovered", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.TypeCovered = t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, err := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if err != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RRSIG Algorithm", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, err = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if err != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RRSIG Labels", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Labels = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, err = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if err != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RRSIG OrigTtl", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OrigTtl = uint32(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if i, err := StringToTime(l.token); err != nil {
0000000000000000000000000000000000000000;;			// Try to see if all numeric and use it as epoch
0000000000000000000000000000000000000000;;			if i, err := strconv.ParseInt(l.token, 10, 64); err == nil {
0000000000000000000000000000000000000000;;				// TODO(miek): error out on > MAX_UINT32, same below
0000000000000000000000000000000000000000;;				rr.Expiration = uint32(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad RRSIG Expiration", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Expiration = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if i, err := StringToTime(l.token); err != nil {
0000000000000000000000000000000000000000;;			if i, err := strconv.ParseInt(l.token, 10, 64); err == nil {
0000000000000000000000000000000000000000;;				rr.Inception = uint32(i)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad RRSIG Inception", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Inception = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, err = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if err != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RRSIG KeyTag", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeyTag = uint16(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		rr.SignerName = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.SignerName = o
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;			if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad RRSIG SignerName", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rr.SignerName[l.length-1] != '.' {
0000000000000000000000000000000000000000;;				rr.SignerName = appendOrigin(rr.SignerName, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s, e, c1 := endingToString(c, "bad RRSIG Signature", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Signature = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNSEC(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NSEC)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		rr.NextDomain = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.NextDomain = o
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;			if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad NSEC NextDomain", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if rr.NextDomain[l.length-1] != '.' {
0000000000000000000000000000000000000000;;				rr.NextDomain = appendOrigin(rr.NextDomain, o)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.TypeBitMap = make([]uint16, 0)
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			k  uint16
0000000000000000000000000000000000000000;;			ok bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		for l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;			switch l.value {
0000000000000000000000000000000000000000;;			case zBlank:
0000000000000000000000000000000000000000;;				// Ok
0000000000000000000000000000000000000000;;			case zString:
0000000000000000000000000000000000000000;;				if k, ok = StringToType[l.tokenUpper]; !ok {
0000000000000000000000000000000000000000;;					if k, ok = typeToInt(l.tokenUpper); !ok {
0000000000000000000000000000000000000000;;						return nil, &ParseError{f, "bad NSEC TypeBitMap", l}, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rr.TypeBitMap = append(rr.TypeBitMap, k)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad NSEC TypeBitMap", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l = <-c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, l.comment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNSEC3(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NSEC3)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3 Hash", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Hash = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3 Flags", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flags = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3 Iterations", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Iterations = uint16(i)
0000000000000000000000000000000000000000;;		<-c
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if len(l.token) == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3 Salt", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.SaltLength = uint8(len(l.token)) / 2
0000000000000000000000000000000000000000;;		rr.Salt = l.token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if len(l.token) == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3 NextDomain", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.HashLength = 20 // Fix for NSEC3 (sha1 160 bits)
0000000000000000000000000000000000000000;;		rr.NextDomain = l.token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.TypeBitMap = make([]uint16, 0)
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			k  uint16
0000000000000000000000000000000000000000;;			ok bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		for l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;			switch l.value {
0000000000000000000000000000000000000000;;			case zBlank:
0000000000000000000000000000000000000000;;				// Ok
0000000000000000000000000000000000000000;;			case zString:
0000000000000000000000000000000000000000;;				if k, ok = StringToType[l.tokenUpper]; !ok {
0000000000000000000000000000000000000000;;					if k, ok = typeToInt(l.tokenUpper); !ok {
0000000000000000000000000000000000000000;;						return nil, &ParseError{f, "bad NSEC3 TypeBitMap", l}, ""
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				rr.TypeBitMap = append(rr.TypeBitMap, k)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad NSEC3 TypeBitMap", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l = <-c
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, l.comment
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNSEC3PARAM(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NSEC3PARAM)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3PARAM Hash", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Hash = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3PARAM Flags", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flags = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NSEC3PARAM Iterations", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Iterations = uint16(i)
0000000000000000000000000000000000000000;;		<-c
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		rr.SaltLength = uint8(len(l.token))
0000000000000000000000000000000000000000;;		rr.Salt = l.token
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setEUI48(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(EUI48)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.length != 17 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad EUI48 Address", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addr := make([]byte, 12)
0000000000000000000000000000000000000000;;		dash := 0
0000000000000000000000000000000000000000;;		for i := 0; i < 10; i += 2 {
0000000000000000000000000000000000000000;;			addr[i] = l.token[i+dash]
0000000000000000000000000000000000000000;;			addr[i+1] = l.token[i+1+dash]
0000000000000000000000000000000000000000;;			dash++
0000000000000000000000000000000000000000;;			if l.token[i+1+dash] != '-' {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad EUI48 Address", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addr[10] = l.token[15]
0000000000000000000000000000000000000000;;		addr[11] = l.token[16]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i, e := strconv.ParseUint(string(addr), 16, 48)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad EUI48 Address", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Address = i
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setEUI64(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(EUI64)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.length != 23 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad EUI64 Address", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addr := make([]byte, 16)
0000000000000000000000000000000000000000;;		dash := 0
0000000000000000000000000000000000000000;;		for i := 0; i < 14; i += 2 {
0000000000000000000000000000000000000000;;			addr[i] = l.token[i+dash]
0000000000000000000000000000000000000000;;			addr[i+1] = l.token[i+1+dash]
0000000000000000000000000000000000000000;;			dash++
0000000000000000000000000000000000000000;;			if l.token[i+1+dash] != '-' {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad EUI64 Address", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addr[14] = l.token[21]
0000000000000000000000000000000000000000;;		addr[15] = l.token[22]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i, e := strconv.ParseUint(string(addr), 16, 64)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad EUI68 Address", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Address = uint64(i)
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setSSHFP(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(SSHFP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad SSHFP Algorithm", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad SSHFP Type", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Type = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		s, e1, c1 := endingToString(c, "bad SSHFP Fingerprint", f)
0000000000000000000000000000000000000000;;		if e1 != nil {
0000000000000000000000000000000000000000;;			return nil, e1, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.FingerPrint = s
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDNSKEYs(h RR_Header, c chan lex, o, f, typ string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(DNSKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad " + typ + " Flags", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flags = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad " + typ + " Protocol", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Protocol = uint8(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad " + typ + " Algorithm", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm = uint8(i)
0000000000000000000000000000000000000000;;		s, e1, c1 := endingToString(c, "bad "+typ+" PublicKey", f)
0000000000000000000000000000000000000000;;		if e1 != nil {
0000000000000000000000000000000000000000;;			return nil, e1, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setKEY(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		r, e, s := setDNSKEYs(h, c, o, f, "KEY")
0000000000000000000000000000000000000000;;		if r != nil {
0000000000000000000000000000000000000000;;			return &KEY{*r.(*DNSKEY)}, e, s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, e, s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDNSKEY(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		r, e, s := setDNSKEYs(h, c, o, f, "DNSKEY")
0000000000000000000000000000000000000000;;		return r, e, s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCDNSKEY(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		r, e, s := setDNSKEYs(h, c, o, f, "CDNSKEY")
0000000000000000000000000000000000000000;;		if r != nil {
0000000000000000000000000000000000000000;;			return &CDNSKEY{*r.(*DNSKEY)}, e, s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, e, s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setRKEY(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(RKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RKEY Flags", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flags = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RKEY Protocol", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Protocol = uint8(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RKEY Algorithm", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm = uint8(i)
0000000000000000000000000000000000000000;;		s, e1, c1 := endingToString(c, "bad RKEY PublicKey", f)
0000000000000000000000000000000000000000;;		if e1 != nil {
0000000000000000000000000000000000000000;;			return nil, e1, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setEID(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(EID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		s, e, c1 := endingToString(c, "bad EID Endpoint", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Endpoint = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNIMLOC(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NIMLOC)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		s, e, c1 := endingToString(c, "bad NIMLOC Locator", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Locator = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setGPOS(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(GPOS)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, e := strconv.ParseFloat(l.token, 64)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad GPOS Longitude", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Longitude = l.token
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		_, e = strconv.ParseFloat(l.token, 64)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad GPOS Latitude", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Latitude = l.token
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		_, e = strconv.ParseFloat(l.token, 64)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad GPOS Altitude", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Altitude = l.token
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDSs(h RR_Header, c chan lex, o, f, typ string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(DS)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad " + typ + " KeyTag", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeyTag = uint16(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if i, e := strconv.Atoi(l.token); e != nil {
0000000000000000000000000000000000000000;;			i, ok := StringToAlgorithm[l.tokenUpper]
0000000000000000000000000000000000000000;;			if !ok || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad " + typ + " Algorithm", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rr.Algorithm = i
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Algorithm = uint8(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad " + typ + " DigestType", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.DigestType = uint8(i)
0000000000000000000000000000000000000000;;		s, e1, c1 := endingToString(c, "bad "+typ+" Digest", f)
0000000000000000000000000000000000000000;;		if e1 != nil {
0000000000000000000000000000000000000000;;			return nil, e1, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Digest = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDS(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		r, e, s := setDSs(h, c, o, f, "DS")
0000000000000000000000000000000000000000;;		return r, e, s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDLV(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		r, e, s := setDSs(h, c, o, f, "DLV")
0000000000000000000000000000000000000000;;		if r != nil {
0000000000000000000000000000000000000000;;			return &DLV{*r.(*DS)}, e, s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, e, s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCDS(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		r, e, s := setDSs(h, c, o, f, "CDS")
0000000000000000000000000000000000000000;;		if r != nil {
0000000000000000000000000000000000000000;;			return &CDS{*r.(*DS)}, e, s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, e, s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setTA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(TA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad TA KeyTag", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeyTag = uint16(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if i, e := strconv.Atoi(l.token); e != nil {
0000000000000000000000000000000000000000;;			i, ok := StringToAlgorithm[l.tokenUpper]
0000000000000000000000000000000000000000;;			if !ok || l.err {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, "bad TA Algorithm", l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rr.Algorithm = i
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr.Algorithm = uint8(i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad TA DigestType", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.DigestType = uint8(i)
0000000000000000000000000000000000000000;;		s, e, c1 := endingToString(c, "bad TA Digest", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e.(*ParseError), c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Digest = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setTLSA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(TLSA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad TLSA Usage", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Usage = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad TLSA Selector", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Selector = uint8(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad TLSA MatchingType", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.MatchingType = uint8(i)
0000000000000000000000000000000000000000;;		// So this needs be e2 (i.e. different than e), because...??t
0000000000000000000000000000000000000000;;		s, e2, c1 := endingToString(c, "bad TLSA Certificate", f)
0000000000000000000000000000000000000000;;		if e2 != nil {
0000000000000000000000000000000000000000;;			return nil, e2, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Certificate = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setRFC3597(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(RFC3597)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.token != "\\#" {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RFC3597 Rdata", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		rdlength, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RFC3597 Rdata ", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, e1, c1 := endingToString(c, "bad RFC3597 Rdata", f)
0000000000000000000000000000000000000000;;		if e1 != nil {
0000000000000000000000000000000000000000;;			return nil, e1, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rdlength*2 != len(s) {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad RFC3597 Rdata", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Rdata = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setSPF(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(SPF)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, e, c1 := endingToTxtSlice(c, "bad SPF Txt", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Txt = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setTXT(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(TXT)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no zBlank reading here, because all this rdata is TXT
0000000000000000000000000000000000000000;;		s, e, c1 := endingToTxtSlice(c, "bad TXT Txt", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Txt = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// identical to setTXT
0000000000000000000000000000000000000000;;	func setNINFO(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, e, c1 := endingToTxtSlice(c, "bad NINFO ZSData", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.ZSData = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setURI(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(URI)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 { // Dynamic updates.
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad URI Priority", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Priority = uint16(i)
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		i, e = strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad URI Weight", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Weight = uint16(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		s, err, c1 := endingToTxtSlice(c, "bad URI Target", f)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) > 1 {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad URI Target", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Target = s[0]
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setDHCID(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		// awesome record to parse!
0000000000000000000000000000000000000000;;		rr := new(DHCID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s, e, c1 := endingToString(c, "bad DHCID Digest", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Digest = s
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setNID(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(NID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad NID Preference", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		u, err := stringToNodeID(l)
0000000000000000000000000000000000000000;;		if err != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, err, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.NodeID = u
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setL32(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(L32)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad L32 Preference", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Locator32 = net.ParseIP(l.token)
0000000000000000000000000000000000000000;;		if rr.Locator32 == nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad L32 Locator", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setLP(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(LP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LP Preference", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Fqdn = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Fqdn = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad LP Fqdn", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Fqdn[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Fqdn = appendOrigin(rr.Fqdn, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setL64(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(L64)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad L64 Preference", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		u, err := stringToNodeID(l)
0000000000000000000000000000000000000000;;		if err != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, err, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Locator64 = u
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setUID(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(UID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad UID Uid", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Uid = uint32(i)
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setGID(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(GID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad GID Gid", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Gid = uint32(i)
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setUINFO(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(UINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		s, e, c1 := endingToTxtSlice(c, "bad UINFO Uinfo", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Uinfo = s[0] // silently discard anything above
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setPX(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(PX)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, e := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if e != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad PX Preference", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference = uint16(i)
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Map822 = l.token
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Map822 = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok := IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad PX Map822", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Map822[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Map822 = appendOrigin(rr.Map822, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		rr.Mapx400 = l.token
0000000000000000000000000000000000000000;;		if l.token == "@" {
0000000000000000000000000000000000000000;;			rr.Mapx400 = o
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, ok = IsDomainName(l.token)
0000000000000000000000000000000000000000;;		if !ok || l.length == 0 || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad PX Mapx400", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Mapx400[l.length-1] != '.' {
0000000000000000000000000000000000000000;;			rr.Mapx400 = appendOrigin(rr.Mapx400, o)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, nil, ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setCAA(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;		rr := new(CAA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		l := <-c
0000000000000000000000000000000000000000;;		if l.length == 0 {
0000000000000000000000000000000000000000;;			return rr, nil, l.comment
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, err := strconv.Atoi(l.token)
0000000000000000000000000000000000000000;;		if err != nil || l.err {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CAA Flag", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flag = uint8(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c     // zBlank
0000000000000000000000000000000000000000;;		l = <-c // zString
0000000000000000000000000000000000000000;;		if l.value != zString {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CAA Tag", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Tag = l.token
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c // zBlank
0000000000000000000000000000000000000000;;		s, e, c1 := endingToTxtSlice(c, "bad CAA Value", f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			return nil, e, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) > 1 {
0000000000000000000000000000000000000000;;			return nil, &ParseError{f, "bad CAA Value", l}, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Value = s[0]
0000000000000000000000000000000000000000;;		return rr, nil, c1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeToparserFunc = map[uint16]parserFunc{
0000000000000000000000000000000000000000;;		TypeAAAA:       {setAAAA, false},
0000000000000000000000000000000000000000;;		TypeAFSDB:      {setAFSDB, false},
0000000000000000000000000000000000000000;;		TypeA:          {setA, false},
0000000000000000000000000000000000000000;;		TypeCAA:        {setCAA, true},
0000000000000000000000000000000000000000;;		TypeCDS:        {setCDS, true},
0000000000000000000000000000000000000000;;		TypeCDNSKEY:    {setCDNSKEY, true},
0000000000000000000000000000000000000000;;		TypeCERT:       {setCERT, true},
0000000000000000000000000000000000000000;;		TypeCNAME:      {setCNAME, false},
0000000000000000000000000000000000000000;;		TypeDHCID:      {setDHCID, true},
0000000000000000000000000000000000000000;;		TypeDLV:        {setDLV, true},
0000000000000000000000000000000000000000;;		TypeDNAME:      {setDNAME, false},
0000000000000000000000000000000000000000;;		TypeKEY:        {setKEY, true},
0000000000000000000000000000000000000000;;		TypeDNSKEY:     {setDNSKEY, true},
0000000000000000000000000000000000000000;;		TypeDS:         {setDS, true},
0000000000000000000000000000000000000000;;		TypeEID:        {setEID, true},
0000000000000000000000000000000000000000;;		TypeEUI48:      {setEUI48, false},
0000000000000000000000000000000000000000;;		TypeEUI64:      {setEUI64, false},
0000000000000000000000000000000000000000;;		TypeGID:        {setGID, false},
0000000000000000000000000000000000000000;;		TypeGPOS:       {setGPOS, false},
0000000000000000000000000000000000000000;;		TypeHINFO:      {setHINFO, true},
0000000000000000000000000000000000000000;;		TypeHIP:        {setHIP, true},
0000000000000000000000000000000000000000;;		TypeKX:         {setKX, false},
0000000000000000000000000000000000000000;;		TypeL32:        {setL32, false},
0000000000000000000000000000000000000000;;		TypeL64:        {setL64, false},
0000000000000000000000000000000000000000;;		TypeLOC:        {setLOC, true},
0000000000000000000000000000000000000000;;		TypeLP:         {setLP, false},
0000000000000000000000000000000000000000;;		TypeMB:         {setMB, false},
0000000000000000000000000000000000000000;;		TypeMD:         {setMD, false},
0000000000000000000000000000000000000000;;		TypeMF:         {setMF, false},
0000000000000000000000000000000000000000;;		TypeMG:         {setMG, false},
0000000000000000000000000000000000000000;;		TypeMINFO:      {setMINFO, false},
0000000000000000000000000000000000000000;;		TypeMR:         {setMR, false},
0000000000000000000000000000000000000000;;		TypeMX:         {setMX, false},
0000000000000000000000000000000000000000;;		TypeNAPTR:      {setNAPTR, false},
0000000000000000000000000000000000000000;;		TypeNID:        {setNID, false},
0000000000000000000000000000000000000000;;		TypeNIMLOC:     {setNIMLOC, true},
0000000000000000000000000000000000000000;;		TypeNINFO:      {setNINFO, true},
0000000000000000000000000000000000000000;;		TypeNSAPPTR:    {setNSAPPTR, false},
0000000000000000000000000000000000000000;;		TypeNSEC3PARAM: {setNSEC3PARAM, false},
0000000000000000000000000000000000000000;;		TypeNSEC3:      {setNSEC3, true},
0000000000000000000000000000000000000000;;		TypeNSEC:       {setNSEC, true},
0000000000000000000000000000000000000000;;		TypeNS:         {setNS, false},
0000000000000000000000000000000000000000;;		TypeOPENPGPKEY: {setOPENPGPKEY, true},
0000000000000000000000000000000000000000;;		TypePTR:        {setPTR, false},
0000000000000000000000000000000000000000;;		TypePX:         {setPX, false},
0000000000000000000000000000000000000000;;		TypeSIG:        {setSIG, true},
0000000000000000000000000000000000000000;;		TypeRKEY:       {setRKEY, true},
0000000000000000000000000000000000000000;;		TypeRP:         {setRP, false},
0000000000000000000000000000000000000000;;		TypeRRSIG:      {setRRSIG, true},
0000000000000000000000000000000000000000;;		TypeRT:         {setRT, false},
0000000000000000000000000000000000000000;;		TypeSOA:        {setSOA, false},
0000000000000000000000000000000000000000;;		TypeSPF:        {setSPF, true},
0000000000000000000000000000000000000000;;		TypeSRV:        {setSRV, false},
0000000000000000000000000000000000000000;;		TypeSSHFP:      {setSSHFP, true},
0000000000000000000000000000000000000000;;		TypeTALINK:     {setTALINK, false},
0000000000000000000000000000000000000000;;		TypeTA:         {setTA, true},
0000000000000000000000000000000000000000;;		TypeTLSA:       {setTLSA, true},
0000000000000000000000000000000000000000;;		TypeTXT:        {setTXT, true},
0000000000000000000000000000000000000000;;		TypeUID:        {setUID, false},
0000000000000000000000000000000000000000;;		TypeUINFO:      {setUINFO, true},
0000000000000000000000000000000000000000;;		TypeURI:        {setURI, true},
0000000000000000000000000000000000000000;;		TypeX25:        {setX25, false},
0000000000000000000000000000000000000000;;	}
