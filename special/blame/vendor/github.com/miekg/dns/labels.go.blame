0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/labels.go[Godeps/_workspace/src/github.com/miekg/dns/labels.go][vendor/github.com/miekg/dns/labels.go];	
0000000000000000000000000000000000000000;;	// Holds a bunch of helper functions for dealing with labels.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitDomainName splits a name string into it's labels.
0000000000000000000000000000000000000000;;	// www.miek.nl. returns []string{"www", "miek", "nl"}
0000000000000000000000000000000000000000;;	// .www.miek.nl. returns []string{"", "www", "miek", "nl"},
0000000000000000000000000000000000000000;;	// The root label (.) returns nil. Note that using
0000000000000000000000000000000000000000;;	// strings.Split(s) will work in most cases, but does not handle
0000000000000000000000000000000000000000;;	// escaped dots (\.) for instance.
0000000000000000000000000000000000000000;;	// s must be a syntactically valid domain name, see IsDomainName.
0000000000000000000000000000000000000000;;	func SplitDomainName(s string) (labels []string) {
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		fqdnEnd := 0 // offset of the final '.' or the length of the name
0000000000000000000000000000000000000000;;		idx := Split(s)
0000000000000000000000000000000000000000;;		begin := 0
0000000000000000000000000000000000000000;;		if s[len(s)-1] == '.' {
0000000000000000000000000000000000000000;;			fqdnEnd = len(s) - 1
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			fqdnEnd = len(s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(idx) {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			// no-op
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			end := 0
0000000000000000000000000000000000000000;;			for i := 1; i < len(idx); i++ {
0000000000000000000000000000000000000000;;				end = idx[i]
0000000000000000000000000000000000000000;;				labels = append(labels, s[begin:end-1])
0000000000000000000000000000000000000000;;				begin = end
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		labels = append(labels, s[begin:fqdnEnd])
0000000000000000000000000000000000000000;;		return labels
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompareDomainName compares the names s1 and s2 and
0000000000000000000000000000000000000000;;	// returns how many labels they have in common starting from the *right*.
0000000000000000000000000000000000000000;;	// The comparison stops at the first inequality. The names are not downcased
0000000000000000000000000000000000000000;;	// before the comparison.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// www.miek.nl. and miek.nl. have two labels in common: miek and nl
0000000000000000000000000000000000000000;;	// www.miek.nl. and www.bla.nl. have one label in common: nl
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// s1 and s2 must be syntactically valid domain names.
0000000000000000000000000000000000000000;;	func CompareDomainName(s1, s2 string) (n int) {
0000000000000000000000000000000000000000;;		s1 = Fqdn(s1)
0000000000000000000000000000000000000000;;		s2 = Fqdn(s2)
0000000000000000000000000000000000000000;;		l1 := Split(s1)
0000000000000000000000000000000000000000;;		l2 := Split(s2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the first check: root label
0000000000000000000000000000000000000000;;		if l1 == nil || l2 == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		j1 := len(l1) - 1 // end
0000000000000000000000000000000000000000;;		i1 := len(l1) - 2 // start
0000000000000000000000000000000000000000;;		j2 := len(l2) - 1
0000000000000000000000000000000000000000;;		i2 := len(l2) - 2
0000000000000000000000000000000000000000;;		// the second check can be done here: last/only label
0000000000000000000000000000000000000000;;		// before we fall through into the for-loop below
0000000000000000000000000000000000000000;;		if s1[l1[j1]:] == s2[l2[j2]:] {
0000000000000000000000000000000000000000;;			n++
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if i1 < 0 || i2 < 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s1[l1[i1]:l1[j1]] == s2[l2[i2]:l2[j2]] {
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			j1--
0000000000000000000000000000000000000000;;			i1--
0000000000000000000000000000000000000000;;			j2--
0000000000000000000000000000000000000000;;			i2--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CountLabel counts the the number of labels in the string s.
0000000000000000000000000000000000000000;;	// s must be a syntactically valid domain name.
0000000000000000000000000000000000000000;;	func CountLabel(s string) (labels int) {
0000000000000000000000000000000000000000;;		if s == "." {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off := 0
0000000000000000000000000000000000000000;;		end := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			off, end = NextLabel(s, off)
0000000000000000000000000000000000000000;;			labels++
0000000000000000000000000000000000000000;;			if end {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Split splits a name s into its label indexes.
0000000000000000000000000000000000000000;;	// www.miek.nl. returns []int{0, 4, 9}, www.miek.nl also returns []int{0, 4, 9}.
0000000000000000000000000000000000000000;;	// The root name (.) returns nil. Also see SplitDomainName.
0000000000000000000000000000000000000000;;	// s must be a syntactically valid domain name.
0000000000000000000000000000000000000000;;	func Split(s string) []int {
0000000000000000000000000000000000000000;;		if s == "." {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idx := make([]int, 1, 3)
0000000000000000000000000000000000000000;;		off := 0
0000000000000000000000000000000000000000;;		end := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			off, end = NextLabel(s, off)
0000000000000000000000000000000000000000;;			if end {
0000000000000000000000000000000000000000;;				return idx
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			idx = append(idx, off)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextLabel returns the index of the start of the next label in the
0000000000000000000000000000000000000000;;	// string s starting at offset.
0000000000000000000000000000000000000000;;	// The bool end is true when the end of the string has been reached.
0000000000000000000000000000000000000000;;	// Also see PrevLabel.
0000000000000000000000000000000000000000;;	func NextLabel(s string, offset int) (i int, end bool) {
0000000000000000000000000000000000000000;;		quote := false
0000000000000000000000000000000000000000;;		for i = offset; i < len(s)-1; i++ {
0000000000000000000000000000000000000000;;			switch s[i] {
0000000000000000000000000000000000000000;;			case '\\':
0000000000000000000000000000000000000000;;				quote = !quote
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				quote = false
0000000000000000000000000000000000000000;;			case '.':
0000000000000000000000000000000000000000;;				if quote {
0000000000000000000000000000000000000000;;					quote = !quote
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return i + 1, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i + 1, true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrevLabel returns the index of the label when starting from the right and
0000000000000000000000000000000000000000;;	// jumping n labels to the left.
0000000000000000000000000000000000000000;;	// The bool start is true when the start of the string has been overshot.
0000000000000000000000000000000000000000;;	// Also see NextLabel.
0000000000000000000000000000000000000000;;	func PrevLabel(s string, n int) (i int, start bool) {
0000000000000000000000000000000000000000;;		if n == 0 {
0000000000000000000000000000000000000000;;			return len(s), false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lab := Split(s)
0000000000000000000000000000000000000000;;		if lab == nil {
0000000000000000000000000000000000000000;;			return 0, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n > len(lab) {
0000000000000000000000000000000000000000;;			return 0, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lab[len(lab)-n], false
0000000000000000000000000000000000000000;;	}
