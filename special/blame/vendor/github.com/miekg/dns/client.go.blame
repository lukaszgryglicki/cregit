0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/client.go[Godeps/_workspace/src/github.com/miekg/dns/client.go][vendor/github.com/miekg/dns/client.go];	
0000000000000000000000000000000000000000;;	// A client implementation.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const dnsTimeout time.Duration = 2 * time.Second
0000000000000000000000000000000000000000;;	const tcpIdleTimeout time.Duration = 8 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Conn represents a connection to a DNS server.
0000000000000000000000000000000000000000;;	type Conn struct {
0000000000000000000000000000000000000000;;		net.Conn                         // a net.Conn holding the connection
0000000000000000000000000000000000000000;;		UDPSize        uint16            // minimum receive buffer for UDP messages
0000000000000000000000000000000000000000;;		TsigSecret     map[string]string // secret(s) for Tsig map[<zonename>]<base64 secret>, zonename must be fully qualified
0000000000000000000000000000000000000000;;		rtt            time.Duration
0000000000000000000000000000000000000000;;		t              time.Time
0000000000000000000000000000000000000000;;		tsigRequestMAC string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Client defines parameters for a DNS client.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		Net            string            // if "tcp" or "tcp-tls" (DNS over TLS) a TCP query will be initiated, otherwise an UDP one (default is "" for UDP)
0000000000000000000000000000000000000000;;		UDPSize        uint16            // minimum receive buffer for UDP messages
0000000000000000000000000000000000000000;;		TLSConfig      *tls.Config       // TLS connection configuration
0000000000000000000000000000000000000000;;		Timeout        time.Duration     // a cumulative timeout for dial, write and read, defaults to 0 (disabled) - overrides DialTimeout, ReadTimeout and WriteTimeout when non-zero
0000000000000000000000000000000000000000;;		DialTimeout    time.Duration     // net.DialTimeout, defaults to 2 seconds - overridden by Timeout when that value is non-zero
0000000000000000000000000000000000000000;;		ReadTimeout    time.Duration     // net.Conn.SetReadTimeout value for connections, defaults to 2 seconds - overridden by Timeout when that value is non-zero
0000000000000000000000000000000000000000;;		WriteTimeout   time.Duration     // net.Conn.SetWriteTimeout value for connections, defaults to 2 seconds - overridden by Timeout when that value is non-zero
0000000000000000000000000000000000000000;;		TsigSecret     map[string]string // secret(s) for Tsig map[<zonename>]<base64 secret>, zonename must be fully qualified
0000000000000000000000000000000000000000;;		SingleInflight bool              // if true suppress multiple outstanding queries for the same Qname, Qtype and Qclass
0000000000000000000000000000000000000000;;		group          singleflight
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exchange performs a synchronous UDP query. It sends the message m to the address
0000000000000000000000000000000000000000;;	// contained in a and waits for an reply. Exchange does not retry a failed query, nor
0000000000000000000000000000000000000000;;	// will it fall back to TCP in case of truncation.
0000000000000000000000000000000000000000;;	// See client.Exchange for more information on setting larger buffer sizes.
0000000000000000000000000000000000000000;;	func Exchange(m *Msg, a string) (r *Msg, err error) {
0000000000000000000000000000000000000000;;		var co *Conn
0000000000000000000000000000000000000000;;		co, err = DialTimeout("udp", a, dnsTimeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		defer co.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opt := m.IsEdns0()
0000000000000000000000000000000000000000;;		// If EDNS0 is used use that for size.
0000000000000000000000000000000000000000;;		if opt != nil && opt.UDPSize() >= MinMsgSize {
0000000000000000000000000000000000000000;;			co.UDPSize = opt.UDPSize()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		co.SetWriteDeadline(time.Now().Add(dnsTimeout))
0000000000000000000000000000000000000000;;		if err = co.WriteMsg(m); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		co.SetReadDeadline(time.Now().Add(dnsTimeout))
0000000000000000000000000000000000000000;;		r, err = co.ReadMsg()
0000000000000000000000000000000000000000;;		if err == nil && r.Id != m.Id {
0000000000000000000000000000000000000000;;			err = ErrId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExchangeConn performs a synchronous query. It sends the message m via the connection
0000000000000000000000000000000000000000;;	// c and waits for a reply. The connection c is not closed by ExchangeConn.
0000000000000000000000000000000000000000;;	// This function is going away, but can easily be mimicked:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	co := &dns.Conn{Conn: c} // c is your net.Conn
0000000000000000000000000000000000000000;;	//	co.WriteMsg(m)
0000000000000000000000000000000000000000;;	//	in, _  := co.ReadMsg()
0000000000000000000000000000000000000000;;	//	co.Close()
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func ExchangeConn(c net.Conn, m *Msg) (r *Msg, err error) {
0000000000000000000000000000000000000000;;		println("dns: this function is deprecated")
0000000000000000000000000000000000000000;;		co := new(Conn)
0000000000000000000000000000000000000000;;		co.Conn = c
0000000000000000000000000000000000000000;;		if err = co.WriteMsg(m); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, err = co.ReadMsg()
0000000000000000000000000000000000000000;;		if err == nil && r.Id != m.Id {
0000000000000000000000000000000000000000;;			err = ErrId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Exchange performs an synchronous query. It sends the message m to the address
0000000000000000000000000000000000000000;;	// contained in a and waits for an reply. Basic use pattern with a *dns.Client:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	c := new(dns.Client)
0000000000000000000000000000000000000000;;	//	in, rtt, err := c.Exchange(message, "127.0.0.1:53")
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Exchange does not retry a failed query, nor will it fall back to TCP in
0000000000000000000000000000000000000000;;	// case of truncation.
0000000000000000000000000000000000000000;;	// It is up to the caller to create a message that allows for larger responses to be
0000000000000000000000000000000000000000;;	// returned. Specifically this means adding an EDNS0 OPT RR that will advertise a larger
0000000000000000000000000000000000000000;;	// buffer, see SetEdns0. Messsages without an OPT RR will fallback to the historic limit
0000000000000000000000000000000000000000;;	// of 512 bytes.
0000000000000000000000000000000000000000;;	func (c *Client) Exchange(m *Msg, a string) (r *Msg, rtt time.Duration, err error) {
0000000000000000000000000000000000000000;;		if !c.SingleInflight {
0000000000000000000000000000000000000000;;			return c.exchange(m, a)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// This adds a bunch of garbage, TODO(miek).
0000000000000000000000000000000000000000;;		t := "nop"
0000000000000000000000000000000000000000;;		if t1, ok := TypeToString[m.Question[0].Qtype]; ok {
0000000000000000000000000000000000000000;;			t = t1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		cl := "nop"
0000000000000000000000000000000000000000;;		if cl1, ok := ClassToString[m.Question[0].Qclass]; ok {
0000000000000000000000000000000000000000;;			cl = cl1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, rtt, err, shared := c.group.Do(m.Question[0].Name+t+cl, func() (*Msg, time.Duration, error) {
0000000000000000000000000000000000000000;;			return c.exchange(m, a)
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return r, rtt, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if shared {
0000000000000000000000000000000000000000;;			return r.Copy(), rtt, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, rtt, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) dialTimeout() time.Duration {
0000000000000000000000000000000000000000;;		if c.Timeout != 0 {
0000000000000000000000000000000000000000;;			return c.Timeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if c.DialTimeout != 0 {
0000000000000000000000000000000000000000;;			return c.DialTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dnsTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) readTimeout() time.Duration {
0000000000000000000000000000000000000000;;		if c.ReadTimeout != 0 {
0000000000000000000000000000000000000000;;			return c.ReadTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dnsTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) writeTimeout() time.Duration {
0000000000000000000000000000000000000000;;		if c.WriteTimeout != 0 {
0000000000000000000000000000000000000000;;			return c.WriteTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dnsTimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) exchange(m *Msg, a string) (r *Msg, rtt time.Duration, err error) {
0000000000000000000000000000000000000000;;		var co *Conn
0000000000000000000000000000000000000000;;		network := "udp"
0000000000000000000000000000000000000000;;		tls := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c.Net {
0000000000000000000000000000000000000000;;		case "tcp-tls":
0000000000000000000000000000000000000000;;			network = "tcp"
0000000000000000000000000000000000000000;;			tls = true
0000000000000000000000000000000000000000;;		case "tcp4-tls":
0000000000000000000000000000000000000000;;			network = "tcp4"
0000000000000000000000000000000000000000;;			tls = true
0000000000000000000000000000000000000000;;		case "tcp6-tls":
0000000000000000000000000000000000000000;;			network = "tcp6"
0000000000000000000000000000000000000000;;			tls = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if c.Net != "" {
0000000000000000000000000000000000000000;;				network = c.Net
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var deadline time.Time
0000000000000000000000000000000000000000;;		if c.Timeout != 0 {
0000000000000000000000000000000000000000;;			deadline = time.Now().Add(c.Timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if tls {
0000000000000000000000000000000000000000;;			co, err = DialTimeoutWithTLS(network, a, c.TLSConfig, c.dialTimeout())
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			co, err = DialTimeout(network, a, c.dialTimeout())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer co.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		opt := m.IsEdns0()
0000000000000000000000000000000000000000;;		// If EDNS0 is used use that for size.
0000000000000000000000000000000000000000;;		if opt != nil && opt.UDPSize() >= MinMsgSize {
0000000000000000000000000000000000000000;;			co.UDPSize = opt.UDPSize()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Otherwise use the client's configured UDP size.
0000000000000000000000000000000000000000;;		if opt == nil && c.UDPSize >= MinMsgSize {
0000000000000000000000000000000000000000;;			co.UDPSize = c.UDPSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		co.TsigSecret = c.TsigSecret
0000000000000000000000000000000000000000;;		co.SetWriteDeadline(deadlineOrTimeout(deadline, c.writeTimeout()))
0000000000000000000000000000000000000000;;		if err = co.WriteMsg(m); err != nil {
0000000000000000000000000000000000000000;;			return nil, 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		co.SetReadDeadline(deadlineOrTimeout(deadline, c.readTimeout()))
0000000000000000000000000000000000000000;;		r, err = co.ReadMsg()
0000000000000000000000000000000000000000;;		if err == nil && r.Id != m.Id {
0000000000000000000000000000000000000000;;			err = ErrId
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r, co.rtt, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadMsg reads a message from the connection co.
0000000000000000000000000000000000000000;;	// If the received message contains a TSIG record the transaction
0000000000000000000000000000000000000000;;	// signature is verified.
0000000000000000000000000000000000000000;;	func (co *Conn) ReadMsg() (*Msg, error) {
0000000000000000000000000000000000000000;;		p, err := co.ReadMsgHeader(nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := new(Msg)
0000000000000000000000000000000000000000;;		if err := m.Unpack(p); err != nil {
0000000000000000000000000000000000000000;;			// If ErrTruncated was returned, we still want to allow the user to use
0000000000000000000000000000000000000000;;			// the message, but naively they can just check err if they don't want
0000000000000000000000000000000000000000;;			// to use a truncated message
0000000000000000000000000000000000000000;;			if err == ErrTruncated {
0000000000000000000000000000000000000000;;				return m, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t := m.IsTsig(); t != nil {
0000000000000000000000000000000000000000;;			if _, ok := co.TsigSecret[t.Hdr.Name]; !ok {
0000000000000000000000000000000000000000;;				return m, ErrSecret
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Need to work on the original message p, as that was used to calculate the tsig.
0000000000000000000000000000000000000000;;			err = TsigVerify(p, co.TsigSecret[t.Hdr.Name], co.tsigRequestMAC, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadMsgHeader reads a DNS message, parses and populates hdr (when hdr is not nil).
0000000000000000000000000000000000000000;;	// Returns message as a byte slice to be parsed with Msg.Unpack later on.
0000000000000000000000000000000000000000;;	// Note that error handling on the message body is not possible as only the header is parsed.
0000000000000000000000000000000000000000;;	func (co *Conn) ReadMsgHeader(hdr *Header) ([]byte, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			p   []byte
0000000000000000000000000000000000000000;;			n   int
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch t := co.Conn.(type) {
0000000000000000000000000000000000000000;;		case *net.TCPConn, *tls.Conn:
0000000000000000000000000000000000000000;;			r := t.(io.Reader)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// First two bytes specify the length of the entire message.
0000000000000000000000000000000000000000;;			l, err := tcpMsgLen(r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p = make([]byte, l)
0000000000000000000000000000000000000000;;			n, err = tcpRead(r, p)
0000000000000000000000000000000000000000;;			co.rtt = time.Since(co.t)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if co.UDPSize > MinMsgSize {
0000000000000000000000000000000000000000;;				p = make([]byte, co.UDPSize)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p = make([]byte, MinMsgSize)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n, err = co.Read(p)
0000000000000000000000000000000000000000;;			co.rtt = time.Since(co.t)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		} else if n < headerSize {
0000000000000000000000000000000000000000;;			return nil, ErrShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p = p[:n]
0000000000000000000000000000000000000000;;		if hdr != nil {
0000000000000000000000000000000000000000;;			dh, _, err := unpackMsgHdr(p, 0)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*hdr = dh
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tcpMsgLen is a helper func to read first two bytes of stream as uint16 packet length.
0000000000000000000000000000000000000000;;	func tcpMsgLen(t io.Reader) (int, error) {
0000000000000000000000000000000000000000;;		p := []byte{0, 0}
0000000000000000000000000000000000000000;;		n, err := t.Read(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n != 2 {
0000000000000000000000000000000000000000;;			return 0, ErrShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := binary.BigEndian.Uint16(p)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return 0, ErrShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(l), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// tcpRead calls TCPConn.Read enough times to fill allocated buffer.
0000000000000000000000000000000000000000;;	func tcpRead(t io.Reader, p []byte) (int, error) {
0000000000000000000000000000000000000000;;		n, err := t.Read(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for n < len(p) {
0000000000000000000000000000000000000000;;			j, err := t.Read(p[n:])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return n, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			n += j
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read implements the net.Conn read method.
0000000000000000000000000000000000000000;;	func (co *Conn) Read(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		if co.Conn == nil {
0000000000000000000000000000000000000000;;			return 0, ErrConnEmpty
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(p) < 2 {
0000000000000000000000000000000000000000;;			return 0, io.ErrShortBuffer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch t := co.Conn.(type) {
0000000000000000000000000000000000000000;;		case *net.TCPConn, *tls.Conn:
0000000000000000000000000000000000000000;;			r := t.(io.Reader)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			l, err := tcpMsgLen(r)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if l > len(p) {
0000000000000000000000000000000000000000;;				return int(l), io.ErrShortBuffer
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return tcpRead(r, p[:l])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// UDP connection
0000000000000000000000000000000000000000;;		n, err = co.Conn.Read(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteMsg sends a message through the connection co.
0000000000000000000000000000000000000000;;	// If the message m contains a TSIG record the transaction
0000000000000000000000000000000000000000;;	// signature is calculated.
0000000000000000000000000000000000000000;;	func (co *Conn) WriteMsg(m *Msg) (err error) {
0000000000000000000000000000000000000000;;		var out []byte
0000000000000000000000000000000000000000;;		if t := m.IsTsig(); t != nil {
0000000000000000000000000000000000000000;;			mac := ""
0000000000000000000000000000000000000000;;			if _, ok := co.TsigSecret[t.Hdr.Name]; !ok {
0000000000000000000000000000000000000000;;				return ErrSecret
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out, mac, err = TsigGenerate(m, co.TsigSecret[t.Hdr.Name], co.tsigRequestMAC, false)
0000000000000000000000000000000000000000;;			// Set for the next read, although only used in zone transfers
0000000000000000000000000000000000000000;;			co.tsigRequestMAC = mac
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out, err = m.Pack()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		co.t = time.Now()
0000000000000000000000000000000000000000;;		if _, err = co.Write(out); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write implements the net.Conn Write method.
0000000000000000000000000000000000000000;;	func (co *Conn) Write(p []byte) (n int, err error) {
0000000000000000000000000000000000000000;;		switch t := co.Conn.(type) {
0000000000000000000000000000000000000000;;		case *net.TCPConn, *tls.Conn:
0000000000000000000000000000000000000000;;			w := t.(io.Writer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			lp := len(p)
0000000000000000000000000000000000000000;;			if lp < 2 {
0000000000000000000000000000000000000000;;				return 0, io.ErrShortBuffer
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lp > MaxMsgSize {
0000000000000000000000000000000000000000;;				return 0, &Error{err: "message too large"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l := make([]byte, 2, lp+2)
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint16(l, uint16(lp))
0000000000000000000000000000000000000000;;			p = append(l, p...)
0000000000000000000000000000000000000000;;			n, err := io.Copy(w, bytes.NewReader(p))
0000000000000000000000000000000000000000;;			return int(n), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n, err = co.Conn.(*net.UDPConn).Write(p)
0000000000000000000000000000000000000000;;		return n, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dial connects to the address on the named network.
0000000000000000000000000000000000000000;;	func Dial(network, address string) (conn *Conn, err error) {
0000000000000000000000000000000000000000;;		conn = new(Conn)
0000000000000000000000000000000000000000;;		conn.Conn, err = net.Dial(network, address)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialTimeout acts like Dial but takes a timeout.
0000000000000000000000000000000000000000;;	func DialTimeout(network, address string, timeout time.Duration) (conn *Conn, err error) {
0000000000000000000000000000000000000000;;		conn = new(Conn)
0000000000000000000000000000000000000000;;		conn.Conn, err = net.DialTimeout(network, address, timeout)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialWithTLS connects to the address on the named network with TLS.
0000000000000000000000000000000000000000;;	func DialWithTLS(network, address string, tlsConfig *tls.Config) (conn *Conn, err error) {
0000000000000000000000000000000000000000;;		conn = new(Conn)
0000000000000000000000000000000000000000;;		conn.Conn, err = tls.Dial(network, address, tlsConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DialTimeoutWithTLS acts like DialWithTLS but takes a timeout.
0000000000000000000000000000000000000000;;	func DialTimeoutWithTLS(network, address string, tlsConfig *tls.Config, timeout time.Duration) (conn *Conn, err error) {
0000000000000000000000000000000000000000;;		var dialer net.Dialer
0000000000000000000000000000000000000000;;		dialer.Timeout = timeout
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		conn = new(Conn)
0000000000000000000000000000000000000000;;		conn.Conn, err = tls.DialWithDialer(&dialer, network, address, tlsConfig)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return conn, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deadlineOrTimeout(deadline time.Time, timeout time.Duration) time.Time {
0000000000000000000000000000000000000000;;		if deadline.IsZero() {
0000000000000000000000000000000000000000;;			return time.Now().Add(timeout)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return deadline
0000000000000000000000000000000000000000;;	}
