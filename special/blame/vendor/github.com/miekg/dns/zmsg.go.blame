0000000000000000000000000000000000000000;;	// *** DO NOT MODIFY ***
0000000000000000000000000000000000000000;;	// AUTOGENERATED BY go generate from msg_generate.go
f5d7b27a32c788d876881f6f8798fa310653e8fb;;	
0000000000000000000000000000000000000000;;	package dns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pack*() functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *A) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packDataA(rr.A, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *AAAA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packDataAAAA(rr.AAAA, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *AFSDB) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Subtype, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Hostname, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *ANY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CAA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Flag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Tag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringOctet(rr.Value, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CDNSKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Flags, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Protocol, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.PublicKey, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CDS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.DigestType, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Digest, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CERT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Type, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.Certificate, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *CNAME) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Target, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DHCID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.Digest, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DLV) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.DigestType, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Digest, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DNAME) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Target, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DNSKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Flags, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Protocol, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.PublicKey, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *DS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.DigestType, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Digest, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *EID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Endpoint, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *EUI48) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint48(rr.Address, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *EUI64) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint64(rr.Address, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *GID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Gid, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *GPOS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packString(rr.Longitude, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Latitude, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Altitude, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *HINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packString(rr.Cpu, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Os, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *HIP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.HitLength, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.PublicKeyAlgorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.PublicKeyLength, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Hit, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.PublicKey, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packDataDomainNames(rr.RendezvousServers, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *KEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Flags, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Protocol, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.PublicKey, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *KX) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Exchanger, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *L32) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packDataA(rr.Locator32, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *L64) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint64(rr.Locator64, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *LOC) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Version, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Size, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.HorizPre, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.VertPre, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Latitude, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Longitude, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Altitude, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *LP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Fqdn, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MB) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mb, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MD) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Md, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MF) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mf, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MG) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mg, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Rmail, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Email, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mr, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *MX) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mx, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NAPTR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Order, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Flags, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Service, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Regexp, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Replacement, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint64(rr.NodeID, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NIMLOC) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Locator, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringTxt(rr.ZSData, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NS) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Ns, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSAPPTR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Ptr, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.NextDomain, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packDataNsec(rr.TypeBitMap, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC3) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Hash, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Flags, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Iterations, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.SaltLength, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Salt, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.HashLength, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase32(rr.NextDomain, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packDataNsec(rr.TypeBitMap, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *NSEC3PARAM) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Hash, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Flags, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Iterations, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.SaltLength, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Salt, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *OPENPGPKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.PublicKey, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *OPT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packDataOpt(rr.Option, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *PTR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Ptr, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *PX) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Map822, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mapx400, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RFC3597) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Rdata, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Flags, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Protocol, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.PublicKey, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mbox, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Txt, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RRSIG) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.TypeCovered, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Labels, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.OrigTtl, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Expiration, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Inception, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.SignerName, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.Signature, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *RT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Preference, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Host, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SIG) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.TypeCovered, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Labels, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.OrigTtl, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Expiration, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Inception, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.SignerName, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(rr.Signature, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SOA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Ns, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Mbox, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Serial, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Refresh, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Retry, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Expire, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Minttl, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SPF) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringTxt(rr.Txt, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SRV) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Priority, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Weight, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Port, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Target, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *SSHFP) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Type, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.FingerPrint, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.DigestType, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Digest, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TALINK) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.PreviousName, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.NextName, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TKEY) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Algorithm, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Inception, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Expiration, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Mode, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Error, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.KeySize, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.Key, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.OtherLen, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packString(rr.OtherData, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TLSA) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Usage, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.Selector, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(rr.MatchingType, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.Certificate, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TSIG) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = PackDomainName(rr.Algorithm, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint48(rr.TimeSigned, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Fudge, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.MACSize, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.MAC, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.OrigId, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Error, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.OtherLen, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(rr.OtherData, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TXT) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packStringTxt(rr.Txt, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *UID) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint32(rr.Uid, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *UINFO) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packString(rr.Uinfo, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *URI) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Priority, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(rr.Weight, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringOctet(rr.Target, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *X25) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := rr.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		off, err = packString(rr.PSDNAddress, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unpack*() functions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackA(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(A)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.A, off, err = unpackDataA(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackAAAA(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(AAAA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.AAAA, off, err = unpackDataAAAA(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackAFSDB(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(AFSDB)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Subtype, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Hostname, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackANY(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(ANY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackCAA(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(CAA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Flag, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Tag, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Value, off, err = unpackStringOctet(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackCDNSKEY(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(CDNSKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Flags, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Protocol, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackCDS(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(CDS)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.KeyTag, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.DigestType, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Digest, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackCERT(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(CERT)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Type, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeyTag, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Certificate, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackCNAME(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(CNAME)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Target, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDHCID(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(DHCID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Digest, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDLV(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(DLV)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.KeyTag, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.DigestType, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Digest, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDNAME(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(DNAME)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Target, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDNSKEY(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(DNSKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Flags, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Protocol, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDS(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(DS)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.KeyTag, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.DigestType, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Digest, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackEID(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(EID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Endpoint, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackEUI48(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(EUI48)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Address, off, err = unpackUint48(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackEUI64(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(EUI64)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Address, off, err = unpackUint64(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackGID(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(GID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Gid, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackGPOS(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(GPOS)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Longitude, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Latitude, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Altitude, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackHINFO(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(HINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Cpu, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Os, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackHIP(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(HIP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.HitLength, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKeyAlgorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKeyLength, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Hit, off, err = unpackStringHex(msg, off, off+int(rr.HitLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey, off, err = unpackStringBase64(msg, off, off+int(rr.PublicKeyLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.RendezvousServers, off, err = unpackDataDomainNames(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackKEY(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(KEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Flags, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Protocol, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackKX(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(KX)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Exchanger, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackL32(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(L32)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Locator32, off, err = unpackDataA(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackL64(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(L64)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Locator64, off, err = unpackUint64(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackLOC(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(LOC)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Version, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Size, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.HorizPre, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.VertPre, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Latitude, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Longitude, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Altitude, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackLP(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(LP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Fqdn, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMB(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(MB)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Mb, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMD(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(MD)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Md, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMF(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(MF)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Mf, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMG(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(MG)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Mg, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMINFO(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(MINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Rmail, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Email, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMR(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(MR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Mr, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMX(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(MX)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Mx, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNAPTR(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NAPTR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Order, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flags, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Service, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Regexp, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Replacement, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNID(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.NodeID, off, err = unpackUint64(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNIMLOC(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NIMLOC)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Locator, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNINFO(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.ZSData, off, err = unpackStringTxt(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNS(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NS)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Ns, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNSAPPTR(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NSAPPTR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Ptr, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNSEC(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NSEC)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.NextDomain, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.TypeBitMap, off, err = unpackDataNsec(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNSEC3(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NSEC3)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Hash, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flags, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Iterations, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.SaltLength, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Salt, off, err = unpackStringHex(msg, off, off+int(rr.SaltLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.HashLength, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.NextDomain, off, err = unpackStringBase32(msg, off, off+int(rr.HashLength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.TypeBitMap, off, err = unpackDataNsec(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackNSEC3PARAM(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(NSEC3PARAM)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Hash, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Flags, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Iterations, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.SaltLength, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Salt, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackOPENPGPKEY(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(OPENPGPKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.PublicKey, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackOPT(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(OPT)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Option, off, err = unpackDataOpt(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackPTR(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(PTR)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Ptr, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackPX(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(PX)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Map822, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Mapx400, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackRFC3597(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(RFC3597)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Rdata, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackRKEY(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(RKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Flags, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Protocol, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.PublicKey, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackRP(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(RP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Mbox, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Txt, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackRRSIG(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(RRSIG)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.TypeCovered, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Labels, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OrigTtl, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Expiration, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Inception, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeyTag, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.SignerName, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Signature, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackRT(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(RT)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Preference, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Host, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackSIG(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(SIG)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.TypeCovered, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Labels, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OrigTtl, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Expiration, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Inception, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeyTag, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.SignerName, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Signature, off, err = unpackStringBase64(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackSOA(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(SOA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Ns, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Mbox, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Serial, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Refresh, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Retry, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Expire, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Minttl, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackSPF(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(SPF)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Txt, off, err = unpackStringTxt(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackSRV(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(SRV)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Priority, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Weight, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Port, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Target, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackSSHFP(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(SSHFP)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Type, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.FingerPrint, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTA(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(TA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.KeyTag, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.DigestType, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Digest, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTALINK(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(TALINK)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.PreviousName, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.NextName, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTKEY(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(TKEY)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Inception, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Expiration, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Mode, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Error, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.KeySize, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Key, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OtherLen, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OtherData, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTLSA(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(TLSA)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Usage, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Selector, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.MatchingType, off, err = unpackUint8(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Certificate, off, err = unpackStringHex(msg, off, rdStart+int(rr.Hdr.Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTSIG(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(TSIG)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Algorithm, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.TimeSigned, off, err = unpackUint48(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Fudge, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.MACSize, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.MAC, off, err = unpackStringHex(msg, off, off+int(rr.MACSize))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OrigId, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Error, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OtherLen, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.OtherData, off, err = unpackStringHex(msg, off, off+int(rr.OtherLen))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTXT(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(TXT)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Txt, off, err = unpackStringTxt(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackUID(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(UID)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Uid, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackUINFO(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(UINFO)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Uinfo, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackURI(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(URI)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Priority, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Weight, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Target, off, err = unpackStringOctet(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackX25(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;		rr := new(X25)
0000000000000000000000000000000000000000;;		rr.Hdr = h
0000000000000000000000000000000000000000;;		if noRdata(h) {
0000000000000000000000000000000000000000;;			return rr, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		rdStart := off
0000000000000000000000000000000000000000;;		_ = rdStart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.PSDNAddress, off, err = unpackString(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var typeToUnpack = map[uint16]func(RR_Header, []byte, int) (RR, int, error){
0000000000000000000000000000000000000000;;		TypeA:          unpackA,
0000000000000000000000000000000000000000;;		TypeAAAA:       unpackAAAA,
0000000000000000000000000000000000000000;;		TypeAFSDB:      unpackAFSDB,
0000000000000000000000000000000000000000;;		TypeANY:        unpackANY,
0000000000000000000000000000000000000000;;		TypeCAA:        unpackCAA,
0000000000000000000000000000000000000000;;		TypeCDNSKEY:    unpackCDNSKEY,
0000000000000000000000000000000000000000;;		TypeCDS:        unpackCDS,
0000000000000000000000000000000000000000;;		TypeCERT:       unpackCERT,
0000000000000000000000000000000000000000;;		TypeCNAME:      unpackCNAME,
0000000000000000000000000000000000000000;;		TypeDHCID:      unpackDHCID,
0000000000000000000000000000000000000000;;		TypeDLV:        unpackDLV,
0000000000000000000000000000000000000000;;		TypeDNAME:      unpackDNAME,
0000000000000000000000000000000000000000;;		TypeDNSKEY:     unpackDNSKEY,
0000000000000000000000000000000000000000;;		TypeDS:         unpackDS,
0000000000000000000000000000000000000000;;		TypeEID:        unpackEID,
0000000000000000000000000000000000000000;;		TypeEUI48:      unpackEUI48,
0000000000000000000000000000000000000000;;		TypeEUI64:      unpackEUI64,
0000000000000000000000000000000000000000;;		TypeGID:        unpackGID,
0000000000000000000000000000000000000000;;		TypeGPOS:       unpackGPOS,
0000000000000000000000000000000000000000;;		TypeHINFO:      unpackHINFO,
0000000000000000000000000000000000000000;;		TypeHIP:        unpackHIP,
0000000000000000000000000000000000000000;;		TypeKEY:        unpackKEY,
0000000000000000000000000000000000000000;;		TypeKX:         unpackKX,
0000000000000000000000000000000000000000;;		TypeL32:        unpackL32,
0000000000000000000000000000000000000000;;		TypeL64:        unpackL64,
0000000000000000000000000000000000000000;;		TypeLOC:        unpackLOC,
0000000000000000000000000000000000000000;;		TypeLP:         unpackLP,
0000000000000000000000000000000000000000;;		TypeMB:         unpackMB,
0000000000000000000000000000000000000000;;		TypeMD:         unpackMD,
0000000000000000000000000000000000000000;;		TypeMF:         unpackMF,
0000000000000000000000000000000000000000;;		TypeMG:         unpackMG,
0000000000000000000000000000000000000000;;		TypeMINFO:      unpackMINFO,
0000000000000000000000000000000000000000;;		TypeMR:         unpackMR,
0000000000000000000000000000000000000000;;		TypeMX:         unpackMX,
0000000000000000000000000000000000000000;;		TypeNAPTR:      unpackNAPTR,
0000000000000000000000000000000000000000;;		TypeNID:        unpackNID,
0000000000000000000000000000000000000000;;		TypeNIMLOC:     unpackNIMLOC,
0000000000000000000000000000000000000000;;		TypeNINFO:      unpackNINFO,
0000000000000000000000000000000000000000;;		TypeNS:         unpackNS,
0000000000000000000000000000000000000000;;		TypeNSAPPTR:    unpackNSAPPTR,
0000000000000000000000000000000000000000;;		TypeNSEC:       unpackNSEC,
0000000000000000000000000000000000000000;;		TypeNSEC3:      unpackNSEC3,
0000000000000000000000000000000000000000;;		TypeNSEC3PARAM: unpackNSEC3PARAM,
0000000000000000000000000000000000000000;;		TypeOPENPGPKEY: unpackOPENPGPKEY,
0000000000000000000000000000000000000000;;		TypeOPT:        unpackOPT,
0000000000000000000000000000000000000000;;		TypePTR:        unpackPTR,
0000000000000000000000000000000000000000;;		TypePX:         unpackPX,
0000000000000000000000000000000000000000;;		TypeRKEY:       unpackRKEY,
0000000000000000000000000000000000000000;;		TypeRP:         unpackRP,
0000000000000000000000000000000000000000;;		TypeRRSIG:      unpackRRSIG,
0000000000000000000000000000000000000000;;		TypeRT:         unpackRT,
0000000000000000000000000000000000000000;;		TypeSIG:        unpackSIG,
0000000000000000000000000000000000000000;;		TypeSOA:        unpackSOA,
0000000000000000000000000000000000000000;;		TypeSPF:        unpackSPF,
0000000000000000000000000000000000000000;;		TypeSRV:        unpackSRV,
0000000000000000000000000000000000000000;;		TypeSSHFP:      unpackSSHFP,
0000000000000000000000000000000000000000;;		TypeTA:         unpackTA,
0000000000000000000000000000000000000000;;		TypeTALINK:     unpackTALINK,
0000000000000000000000000000000000000000;;		TypeTKEY:       unpackTKEY,
0000000000000000000000000000000000000000;;		TypeTLSA:       unpackTLSA,
0000000000000000000000000000000000000000;;		TypeTSIG:       unpackTSIG,
0000000000000000000000000000000000000000;;		TypeTXT:        unpackTXT,
0000000000000000000000000000000000000000;;		TypeUID:        unpackUID,
0000000000000000000000000000000000000000;;		TypeUINFO:      unpackUINFO,
0000000000000000000000000000000000000000;;		TypeURI:        unpackURI,
0000000000000000000000000000000000000000;;		TypeX25:        unpackX25,
0000000000000000000000000000000000000000;;	}
