0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/clientconfig.go[Godeps/_workspace/src/github.com/miekg/dns/clientconfig.go][vendor/github.com/miekg/dns/clientconfig.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfig wraps the contents of the /etc/resolv.conf file.
0000000000000000000000000000000000000000;;	type ClientConfig struct {
0000000000000000000000000000000000000000;;		Servers  []string // servers to use
0000000000000000000000000000000000000000;;		Search   []string // suffixes to append to local name
0000000000000000000000000000000000000000;;		Port     string   // what port to use
0000000000000000000000000000000000000000;;		Ndots    int      // number of dots in name to trigger absolute lookup
0000000000000000000000000000000000000000;;		Timeout  int      // seconds before giving up on packet
0000000000000000000000000000000000000000;;		Attempts int      // lost packets before giving up on server, not used in the package dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClientConfigFromFile parses a resolv.conf(5) like file and returns
0000000000000000000000000000000000000000;;	// a *ClientConfig.
0000000000000000000000000000000000000000;;	func ClientConfigFromFile(resolvconf string) (*ClientConfig, error) {
0000000000000000000000000000000000000000;;		file, err := os.Open(resolvconf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer file.Close()
0000000000000000000000000000000000000000;;		c := new(ClientConfig)
0000000000000000000000000000000000000000;;		scanner := bufio.NewScanner(file)
0000000000000000000000000000000000000000;;		c.Servers = make([]string, 0)
0000000000000000000000000000000000000000;;		c.Search = make([]string, 0)
0000000000000000000000000000000000000000;;		c.Port = "53"
0000000000000000000000000000000000000000;;		c.Ndots = 1
0000000000000000000000000000000000000000;;		c.Timeout = 5
0000000000000000000000000000000000000000;;		c.Attempts = 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for scanner.Scan() {
0000000000000000000000000000000000000000;;			if err := scanner.Err(); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			line := scanner.Text()
0000000000000000000000000000000000000000;;			f := strings.Fields(line)
0000000000000000000000000000000000000000;;			if len(f) < 1 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch f[0] {
0000000000000000000000000000000000000000;;			case "nameserver": // add one name server
0000000000000000000000000000000000000000;;				if len(f) > 1 {
0000000000000000000000000000000000000000;;					// One more check: make sure server name is
0000000000000000000000000000000000000000;;					// just an IP address.  Otherwise we need DNS
0000000000000000000000000000000000000000;;					// to look it up.
0000000000000000000000000000000000000000;;					name := f[1]
0000000000000000000000000000000000000000;;					c.Servers = append(c.Servers, name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case "domain": // set search path to just this domain
0000000000000000000000000000000000000000;;				if len(f) > 1 {
0000000000000000000000000000000000000000;;					c.Search = make([]string, 1)
0000000000000000000000000000000000000000;;					c.Search[0] = f[1]
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					c.Search = make([]string, 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case "search": // set search path to given servers
0000000000000000000000000000000000000000;;				c.Search = make([]string, len(f)-1)
0000000000000000000000000000000000000000;;				for i := 0; i < len(c.Search); i++ {
0000000000000000000000000000000000000000;;					c.Search[i] = f[i+1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case "options": // magic options
0000000000000000000000000000000000000000;;				for i := 1; i < len(f); i++ {
0000000000000000000000000000000000000000;;					s := f[i]
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case len(s) >= 6 && s[:6] == "ndots:":
0000000000000000000000000000000000000000;;						n, _ := strconv.Atoi(s[6:])
0000000000000000000000000000000000000000;;						if n < 1 {
0000000000000000000000000000000000000000;;							n = 1
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						c.Ndots = n
0000000000000000000000000000000000000000;;					case len(s) >= 8 && s[:8] == "timeout:":
0000000000000000000000000000000000000000;;						n, _ := strconv.Atoi(s[8:])
0000000000000000000000000000000000000000;;						if n < 1 {
0000000000000000000000000000000000000000;;							n = 1
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						c.Timeout = n
0000000000000000000000000000000000000000;;					case len(s) >= 8 && s[:9] == "attempts:":
0000000000000000000000000000000000000000;;						n, _ := strconv.Atoi(s[9:])
0000000000000000000000000000000000000000;;						if n < 1 {
0000000000000000000000000000000000000000;;							n = 1
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						c.Attempts = n
0000000000000000000000000000000000000000;;					case s == "rotate":
0000000000000000000000000000000000000000;;						/* not imp */
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c, nil
0000000000000000000000000000000000000000;;	}
