0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/kscan.go[Godeps/_workspace/src/github.com/miekg/dns/kscan.go][vendor/github.com/miekg/dns/dnssec_keyscan.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/dsa"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewPrivateKey returns a PrivateKey by parsing the string s.
0000000000000000000000000000000000000000;;	// s should be in the same form of the BIND private key files.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) NewPrivateKey(s string) (crypto.PrivateKey, error) {
0000000000000000000000000000000000000000;;		if s[len(s)-1] != '\n' { // We need a closing newline
0000000000000000000000000000000000000000;;			return k.ReadPrivateKey(strings.NewReader(s+"\n"), "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return k.ReadPrivateKey(strings.NewReader(s), "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadPrivateKey reads a private key from the io.Reader q. The string file is
0000000000000000000000000000000000000000;;	// only used in error reporting.
0000000000000000000000000000000000000000;;	// The public key must be known, because some cryptographic algorithms embed
0000000000000000000000000000000000000000;;	// the public inside the privatekey.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) ReadPrivateKey(q io.Reader, file string) (crypto.PrivateKey, error) {
0000000000000000000000000000000000000000;;		m, err := parseKey(q, file)
0000000000000000000000000000000000000000;;		if m == nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := m["private-key-format"]; !ok {
0000000000000000000000000000000000000000;;			return nil, ErrPrivKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if m["private-key-format"] != "v1.2" && m["private-key-format"] != "v1.3" {
0000000000000000000000000000000000000000;;			return nil, ErrPrivKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(mg): check if the pubkey matches the private key
0000000000000000000000000000000000000000;;		algo, err := strconv.Atoi(strings.SplitN(m["algorithm"], " ", 2)[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, ErrPrivKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch uint8(algo) {
0000000000000000000000000000000000000000;;		case DSA:
0000000000000000000000000000000000000000;;			priv, err := readPrivateKeyDSA(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pub := k.publicKeyDSA()
0000000000000000000000000000000000000000;;			if pub == nil {
0000000000000000000000000000000000000000;;				return nil, ErrKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			priv.PublicKey = *pub
0000000000000000000000000000000000000000;;			return priv, nil
0000000000000000000000000000000000000000;;		case RSAMD5:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case RSASHA1:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case RSASHA1NSEC3SHA1:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case RSASHA256:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case RSASHA512:
0000000000000000000000000000000000000000;;			priv, err := readPrivateKeyRSA(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pub := k.publicKeyRSA()
0000000000000000000000000000000000000000;;			if pub == nil {
0000000000000000000000000000000000000000;;				return nil, ErrKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			priv.PublicKey = *pub
0000000000000000000000000000000000000000;;			return priv, nil
0000000000000000000000000000000000000000;;		case ECCGOST:
0000000000000000000000000000000000000000;;			return nil, ErrPrivKey
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256:
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			priv, err := readPrivateKeyECDSA(m)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pub := k.publicKeyECDSA()
0000000000000000000000000000000000000000;;			if pub == nil {
0000000000000000000000000000000000000000;;				return nil, ErrKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			priv.PublicKey = *pub
0000000000000000000000000000000000000000;;			return priv, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, ErrPrivKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read a private key (file) string and create a public key. Return the private key.
0000000000000000000000000000000000000000;;	func readPrivateKeyRSA(m map[string]string) (*rsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		p := new(rsa.PrivateKey)
0000000000000000000000000000000000000000;;		p.Primes = []*big.Int{nil, nil}
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case "modulus", "publicexponent", "privateexponent", "prime1", "prime2":
0000000000000000000000000000000000000000;;				v1, err := fromBase64([]byte(v))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch k {
0000000000000000000000000000000000000000;;				case "modulus":
0000000000000000000000000000000000000000;;					p.PublicKey.N = big.NewInt(0)
0000000000000000000000000000000000000000;;					p.PublicKey.N.SetBytes(v1)
0000000000000000000000000000000000000000;;				case "publicexponent":
0000000000000000000000000000000000000000;;					i := big.NewInt(0)
0000000000000000000000000000000000000000;;					i.SetBytes(v1)
0000000000000000000000000000000000000000;;					p.PublicKey.E = int(i.Int64()) // int64 should be large enough
0000000000000000000000000000000000000000;;				case "privateexponent":
0000000000000000000000000000000000000000;;					p.D = big.NewInt(0)
0000000000000000000000000000000000000000;;					p.D.SetBytes(v1)
0000000000000000000000000000000000000000;;				case "prime1":
0000000000000000000000000000000000000000;;					p.Primes[0] = big.NewInt(0)
0000000000000000000000000000000000000000;;					p.Primes[0].SetBytes(v1)
0000000000000000000000000000000000000000;;				case "prime2":
0000000000000000000000000000000000000000;;					p.Primes[1] = big.NewInt(0)
0000000000000000000000000000000000000000;;					p.Primes[1].SetBytes(v1)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case "exponent1", "exponent2", "coefficient":
0000000000000000000000000000000000000000;;				// not used in Go (yet)
0000000000000000000000000000000000000000;;			case "created", "publish", "activate":
0000000000000000000000000000000000000000;;				// not used in Go (yet)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readPrivateKeyDSA(m map[string]string) (*dsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		p := new(dsa.PrivateKey)
0000000000000000000000000000000000000000;;		p.X = big.NewInt(0)
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case "private_value(x)":
0000000000000000000000000000000000000000;;				v1, err := fromBase64([]byte(v))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.X.SetBytes(v1)
0000000000000000000000000000000000000000;;			case "created", "publish", "activate":
0000000000000000000000000000000000000000;;				/* not used in Go (yet) */
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func readPrivateKeyECDSA(m map[string]string) (*ecdsa.PrivateKey, error) {
0000000000000000000000000000000000000000;;		p := new(ecdsa.PrivateKey)
0000000000000000000000000000000000000000;;		p.D = big.NewInt(0)
0000000000000000000000000000000000000000;;		// TODO: validate that the required flags are present
0000000000000000000000000000000000000000;;		for k, v := range m {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case "privatekey":
0000000000000000000000000000000000000000;;				v1, err := fromBase64([]byte(v))
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.D.SetBytes(v1)
0000000000000000000000000000000000000000;;			case "created", "publish", "activate":
0000000000000000000000000000000000000000;;				/* not used in Go (yet) */
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parseKey reads a private key from r. It returns a map[string]string,
0000000000000000000000000000000000000000;;	// with the key-value pairs, or an error when the file is not correct.
0000000000000000000000000000000000000000;;	func parseKey(r io.Reader, file string) (map[string]string, error) {
0000000000000000000000000000000000000000;;		s := scanInit(r)
0000000000000000000000000000000000000000;;		m := make(map[string]string)
0000000000000000000000000000000000000000;;		c := make(chan lex)
0000000000000000000000000000000000000000;;		k := ""
0000000000000000000000000000000000000000;;		// Start the lexer
0000000000000000000000000000000000000000;;		go klexer(s, c)
0000000000000000000000000000000000000000;;		for l := range c {
0000000000000000000000000000000000000000;;			// It should alternate
0000000000000000000000000000000000000000;;			switch l.value {
0000000000000000000000000000000000000000;;			case zKey:
0000000000000000000000000000000000000000;;				k = l.token
0000000000000000000000000000000000000000;;			case zValue:
0000000000000000000000000000000000000000;;				if k == "" {
0000000000000000000000000000000000000000;;					return nil, &ParseError{file, "no private key seen", l}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				//println("Setting", strings.ToLower(k), "to", l.token, "b")
0000000000000000000000000000000000000000;;				m[strings.ToLower(k)] = l.token
0000000000000000000000000000000000000000;;				k = ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// klexer scans the sourcefile and returns tokens on the channel c.
0000000000000000000000000000000000000000;;	func klexer(s *scan, c chan lex) {
0000000000000000000000000000000000000000;;		var l lex
0000000000000000000000000000000000000000;;		str := "" // Hold the current read text
0000000000000000000000000000000000000000;;		commt := false
0000000000000000000000000000000000000000;;		key := true
0000000000000000000000000000000000000000;;		x, err := s.tokenText()
0000000000000000000000000000000000000000;;		defer close(c)
0000000000000000000000000000000000000000;;		for err == nil {
0000000000000000000000000000000000000000;;			l.column = s.position.Column
0000000000000000000000000000000000000000;;			l.line = s.position.Line
0000000000000000000000000000000000000000;;			switch x {
0000000000000000000000000000000000000000;;			case ':':
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.token = str
0000000000000000000000000000000000000000;;				if key {
0000000000000000000000000000000000000000;;					l.value = zKey
0000000000000000000000000000000000000000;;					c <- l
0000000000000000000000000000000000000000;;					// Next token is a space, eat it
0000000000000000000000000000000000000000;;					s.tokenText()
0000000000000000000000000000000000000000;;					key = false
0000000000000000000000000000000000000000;;					str = ""
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					l.value = zValue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ';':
0000000000000000000000000000000000000000;;				commt = true
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					// Reset a comment
0000000000000000000000000000000000000000;;					commt = false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				l.value = zValue
0000000000000000000000000000000000000000;;				l.token = str
0000000000000000000000000000000000000000;;				c <- l
0000000000000000000000000000000000000000;;				str = ""
0000000000000000000000000000000000000000;;				commt = false
0000000000000000000000000000000000000000;;				key = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if commt {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				str += string(x)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			x, err = s.tokenText()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(str) > 0 {
0000000000000000000000000000000000000000;;			// Send remainder
0000000000000000000000000000000000000000;;			l.token = str
0000000000000000000000000000000000000000;;			l.value = zValue
0000000000000000000000000000000000000000;;			c <- l
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
