0000000000000000000000000000000000000000;;	// DNS packet assembly, see RFC 1035. Converting from - Unpack() -
0000000000000000000000000000000000000000;;	// and to - Pack() - wire format.
0000000000000000000000000000000000000000;;	// All the packers and unpackers take a (msg []byte, off int)
0000000000000000000000000000000000000000;;	// and return (off1 int, ok bool).  If they return ok==false, they
0000000000000000000000000000000000000000;;	// also return off1==len(msg), so that the next unpacker will
0000000000000000000000000000000000000000;;	// also fail.  This lets us avoid checks of ok until the end of a
0000000000000000000000000000000000000000;;	// packing sequence.
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/msg.go[Godeps/_workspace/src/github.com/miekg/dns/msg.go][vendor/github.com/miekg/dns/msg.go];	
0000000000000000000000000000000000000000;;	package dns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//go:generate go run msg_generate.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		crand "crypto/rand"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"math/rand"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		// Initialize default math/rand source using crypto/rand to provide better
0000000000000000000000000000000000000000;;		// security without the performance trade-off.
0000000000000000000000000000000000000000;;		buf := make([]byte, 8)
0000000000000000000000000000000000000000;;		_, err := crand.Read(buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			// Failed to read from cryptographic source, fallback to default initial
0000000000000000000000000000000000000000;;			// seed (1) by returning early
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		seed := binary.BigEndian.Uint64(buf)
0000000000000000000000000000000000000000;;		rand.Seed(int64(seed))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxCompressionOffset = 2 << 13 // We have 14 bits for the compression pointer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		ErrAlg           error = &Error{err: "bad algorithm"}                  // ErrAlg indicates an error with the (DNSSEC) algorithm.
0000000000000000000000000000000000000000;;		ErrAuth          error = &Error{err: "bad authentication"}             // ErrAuth indicates an error in the TSIG authentication.
0000000000000000000000000000000000000000;;		ErrBuf           error = &Error{err: "buffer size too small"}          // ErrBuf indicates that the buffer used it too small for the message.
0000000000000000000000000000000000000000;;		ErrConnEmpty     error = &Error{err: "conn has no connection"}         // ErrConnEmpty indicates a connection is being uses before it is initialized.
0000000000000000000000000000000000000000;;		ErrExtendedRcode error = &Error{err: "bad extended rcode"}             // ErrExtendedRcode ...
0000000000000000000000000000000000000000;;		ErrFqdn          error = &Error{err: "domain must be fully qualified"} // ErrFqdn indicates that a domain name does not have a closing dot.
0000000000000000000000000000000000000000;;		ErrId            error = &Error{err: "id mismatch"}                    // ErrId indicates there is a mismatch with the message's ID.
0000000000000000000000000000000000000000;;		ErrKeyAlg        error = &Error{err: "bad key algorithm"}              // ErrKeyAlg indicates that the algorithm in the key is not valid.
0000000000000000000000000000000000000000;;		ErrKey           error = &Error{err: "bad key"}
0000000000000000000000000000000000000000;;		ErrKeySize       error = &Error{err: "bad key size"}
0000000000000000000000000000000000000000;;		ErrNoSig         error = &Error{err: "no signature found"}
0000000000000000000000000000000000000000;;		ErrPrivKey       error = &Error{err: "bad private key"}
0000000000000000000000000000000000000000;;		ErrRcode         error = &Error{err: "bad rcode"}
0000000000000000000000000000000000000000;;		ErrRdata         error = &Error{err: "bad rdata"}
0000000000000000000000000000000000000000;;		ErrRRset         error = &Error{err: "bad rrset"}
0000000000000000000000000000000000000000;;		ErrSecret        error = &Error{err: "no secrets defined"}
0000000000000000000000000000000000000000;;		ErrShortRead     error = &Error{err: "short read"}
0000000000000000000000000000000000000000;;		ErrSig           error = &Error{err: "bad signature"}                      // ErrSig indicates that a signature can not be cryptographically validated.
0000000000000000000000000000000000000000;;		ErrSoa           error = &Error{err: "no SOA"}                             // ErrSOA indicates that no SOA RR was seen when doing zone transfers.
0000000000000000000000000000000000000000;;		ErrTime          error = &Error{err: "bad time"}                           // ErrTime indicates a timing error in TSIG authentication.
0000000000000000000000000000000000000000;;		ErrTruncated     error = &Error{err: "failed to unpack truncated message"} // ErrTruncated indicates that we failed to unpack a truncated message. We unpacked as much as we had so Msg can still be used, if desired.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Id, by default, returns a 16 bits random number to be used as a
0000000000000000000000000000000000000000;;	// message id. The random provided should be good enough. This being a
0000000000000000000000000000000000000000;;	// variable the function can be reassigned to a custom function.
0000000000000000000000000000000000000000;;	// For instance, to make it return a static value:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	dns.Id = func() uint16 { return 3 }
0000000000000000000000000000000000000000;;	var Id func() uint16 = id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// id returns a 16 bits random number to be used as a
0000000000000000000000000000000000000000;;	// message id. The random provided should be good enough.
0000000000000000000000000000000000000000;;	func id() uint16 {
0000000000000000000000000000000000000000;;		id32 := rand.Uint32()
0000000000000000000000000000000000000000;;		return uint16(id32)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MsgHdr is a a manually-unpacked version of (id, bits).
0000000000000000000000000000000000000000;;	type MsgHdr struct {
0000000000000000000000000000000000000000;;		Id                 uint16
0000000000000000000000000000000000000000;;		Response           bool
0000000000000000000000000000000000000000;;		Opcode             int
0000000000000000000000000000000000000000;;		Authoritative      bool
0000000000000000000000000000000000000000;;		Truncated          bool
0000000000000000000000000000000000000000;;		RecursionDesired   bool
0000000000000000000000000000000000000000;;		RecursionAvailable bool
0000000000000000000000000000000000000000;;		Zero               bool
0000000000000000000000000000000000000000;;		AuthenticatedData  bool
0000000000000000000000000000000000000000;;		CheckingDisabled   bool
0000000000000000000000000000000000000000;;		Rcode              int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Msg contains the layout of a DNS message.
0000000000000000000000000000000000000000;;	type Msg struct {
0000000000000000000000000000000000000000;;		MsgHdr
0000000000000000000000000000000000000000;;		Compress bool       `json:"-"` // If true, the message will be compressed when converted to wire format.
0000000000000000000000000000000000000000;;		Question []Question // Holds the RR(s) of the question section.
0000000000000000000000000000000000000000;;		Answer   []RR       // Holds the RR(s) of the answer section.
0000000000000000000000000000000000000000;;		Ns       []RR       // Holds the RR(s) of the authority section.
0000000000000000000000000000000000000000;;		Extra    []RR       // Holds the RR(s) of the additional section.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClassToString is a maps Classes to strings for each CLASS wire type.
0000000000000000000000000000000000000000;;	var ClassToString = map[uint16]string{
0000000000000000000000000000000000000000;;		ClassINET:   "IN",
0000000000000000000000000000000000000000;;		ClassCSNET:  "CS",
0000000000000000000000000000000000000000;;		ClassCHAOS:  "CH",
0000000000000000000000000000000000000000;;		ClassHESIOD: "HS",
0000000000000000000000000000000000000000;;		ClassNONE:   "NONE",
0000000000000000000000000000000000000000;;		ClassANY:    "ANY",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpcodeToString maps Opcodes to strings.
0000000000000000000000000000000000000000;;	var OpcodeToString = map[int]string{
0000000000000000000000000000000000000000;;		OpcodeQuery:  "QUERY",
0000000000000000000000000000000000000000;;		OpcodeIQuery: "IQUERY",
0000000000000000000000000000000000000000;;		OpcodeStatus: "STATUS",
0000000000000000000000000000000000000000;;		OpcodeNotify: "NOTIFY",
0000000000000000000000000000000000000000;;		OpcodeUpdate: "UPDATE",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RcodeToString maps Rcodes to strings.
0000000000000000000000000000000000000000;;	var RcodeToString = map[int]string{
0000000000000000000000000000000000000000;;		RcodeSuccess:        "NOERROR",
0000000000000000000000000000000000000000;;		RcodeFormatError:    "FORMERR",
0000000000000000000000000000000000000000;;		RcodeServerFailure:  "SERVFAIL",
0000000000000000000000000000000000000000;;		RcodeNameError:      "NXDOMAIN",
0000000000000000000000000000000000000000;;		RcodeNotImplemented: "NOTIMPL",
0000000000000000000000000000000000000000;;		RcodeRefused:        "REFUSED",
0000000000000000000000000000000000000000;;		RcodeYXDomain:       "YXDOMAIN", // See RFC 2136
0000000000000000000000000000000000000000;;		RcodeYXRrset:        "YXRRSET",
0000000000000000000000000000000000000000;;		RcodeNXRrset:        "NXRRSET",
0000000000000000000000000000000000000000;;		RcodeNotAuth:        "NOTAUTH",
0000000000000000000000000000000000000000;;		RcodeNotZone:        "NOTZONE",
0000000000000000000000000000000000000000;;		RcodeBadSig:         "BADSIG", // Also known as RcodeBadVers, see RFC 6891
0000000000000000000000000000000000000000;;		//	RcodeBadVers:        "BADVERS",
0000000000000000000000000000000000000000;;		RcodeBadKey:    "BADKEY",
0000000000000000000000000000000000000000;;		RcodeBadTime:   "BADTIME",
0000000000000000000000000000000000000000;;		RcodeBadMode:   "BADMODE",
0000000000000000000000000000000000000000;;		RcodeBadName:   "BADNAME",
0000000000000000000000000000000000000000;;		RcodeBadAlg:    "BADALG",
0000000000000000000000000000000000000000;;		RcodeBadTrunc:  "BADTRUNC",
0000000000000000000000000000000000000000;;		RcodeBadCookie: "BADCOOKIE",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Domain names are a sequence of counted strings
0000000000000000000000000000000000000000;;	// split at the dots. They end with a zero-length string.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PackDomainName packs a domain name s into msg[off:].
0000000000000000000000000000000000000000;;	// If compression is wanted compress must be true and the compression
0000000000000000000000000000000000000000;;	// map needs to hold a mapping between domain names and offsets
0000000000000000000000000000000000000000;;	// pointing into msg.
0000000000000000000000000000000000000000;;	func PackDomainName(s string, msg []byte, off int, compression map[string]int, compress bool) (off1 int, err error) {
0000000000000000000000000000000000000000;;		off1, _, err = packDomainName(s, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packDomainName(s string, msg []byte, off int, compression map[string]int, compress bool) (off1 int, labels int, err error) {
0000000000000000000000000000000000000000;;		// special case if msg == nil
0000000000000000000000000000000000000000;;		lenmsg := 256
0000000000000000000000000000000000000000;;		if msg != nil {
0000000000000000000000000000000000000000;;			lenmsg = len(msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ls := len(s)
0000000000000000000000000000000000000000;;		if ls == 0 { // Ok, for instance when dealing with update RR without any rdata.
0000000000000000000000000000000000000000;;			return off, 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If not fully qualified, error out, but only if msg == nil #ugly
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case msg == nil:
0000000000000000000000000000000000000000;;			if s[ls-1] != '.' {
0000000000000000000000000000000000000000;;				s += "."
0000000000000000000000000000000000000000;;				ls++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case msg != nil:
0000000000000000000000000000000000000000;;			if s[ls-1] != '.' {
0000000000000000000000000000000000000000;;				return lenmsg, 0, ErrFqdn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Each dot ends a segment of the name.
0000000000000000000000000000000000000000;;		// We trade each dot byte for a length byte.
0000000000000000000000000000000000000000;;		// Except for escaped dots (\.), which are normal dots.
0000000000000000000000000000000000000000;;		// There is also a trailing zero.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Compression
0000000000000000000000000000000000000000;;		nameoffset := -1
0000000000000000000000000000000000000000;;		pointer := -1
0000000000000000000000000000000000000000;;		// Emit sequence of counted strings, chopping at dots.
0000000000000000000000000000000000000000;;		begin := 0
0000000000000000000000000000000000000000;;		bs := []byte(s)
0000000000000000000000000000000000000000;;		roBs, bsFresh, escapedDot := s, true, false
0000000000000000000000000000000000000000;;		for i := 0; i < ls; i++ {
0000000000000000000000000000000000000000;;			if bs[i] == '\\' {
0000000000000000000000000000000000000000;;				for j := i; j < ls-1; j++ {
0000000000000000000000000000000000000000;;					bs[j] = bs[j+1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ls--
0000000000000000000000000000000000000000;;				if off+1 > lenmsg {
0000000000000000000000000000000000000000;;					return lenmsg, labels, ErrBuf
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for \DDD
0000000000000000000000000000000000000000;;				if i+2 < ls && isDigit(bs[i]) && isDigit(bs[i+1]) && isDigit(bs[i+2]) {
0000000000000000000000000000000000000000;;					bs[i] = dddToByte(bs[i:])
0000000000000000000000000000000000000000;;					for j := i + 1; j < ls-2; j++ {
0000000000000000000000000000000000000000;;						bs[j] = bs[j+2]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					ls -= 2
0000000000000000000000000000000000000000;;				} else if bs[i] == 't' {
0000000000000000000000000000000000000000;;					bs[i] = '\t'
0000000000000000000000000000000000000000;;				} else if bs[i] == 'r' {
0000000000000000000000000000000000000000;;					bs[i] = '\r'
0000000000000000000000000000000000000000;;				} else if bs[i] == 'n' {
0000000000000000000000000000000000000000;;					bs[i] = '\n'
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				escapedDot = bs[i] == '.'
0000000000000000000000000000000000000000;;				bsFresh = false
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if bs[i] == '.' {
0000000000000000000000000000000000000000;;				if i > 0 && bs[i-1] == '.' && !escapedDot {
0000000000000000000000000000000000000000;;					// two dots back to back is not legal
0000000000000000000000000000000000000000;;					return lenmsg, labels, ErrRdata
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i-begin >= 1<<6 { // top two bits of length must be clear
0000000000000000000000000000000000000000;;					return lenmsg, labels, ErrRdata
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// off can already (we're in a loop) be bigger than len(msg)
0000000000000000000000000000000000000000;;				// this happens when a name isn't fully qualified
0000000000000000000000000000000000000000;;				if off+1 > lenmsg {
0000000000000000000000000000000000000000;;					return lenmsg, labels, ErrBuf
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if msg != nil {
0000000000000000000000000000000000000000;;					msg[off] = byte(i - begin)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				offset := off
0000000000000000000000000000000000000000;;				off++
0000000000000000000000000000000000000000;;				for j := begin; j < i; j++ {
0000000000000000000000000000000000000000;;					if off+1 > lenmsg {
0000000000000000000000000000000000000000;;						return lenmsg, labels, ErrBuf
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if msg != nil {
0000000000000000000000000000000000000000;;						msg[off] = bs[j]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					off++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if compress && !bsFresh {
0000000000000000000000000000000000000000;;					roBs = string(bs)
0000000000000000000000000000000000000000;;					bsFresh = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Don't try to compress '.'
0000000000000000000000000000000000000000;;				if compress && roBs[begin:] != "." {
0000000000000000000000000000000000000000;;					if p, ok := compression[roBs[begin:]]; !ok {
0000000000000000000000000000000000000000;;						// Only offsets smaller than this can be used.
0000000000000000000000000000000000000000;;						if offset < maxCompressionOffset {
0000000000000000000000000000000000000000;;							compression[roBs[begin:]] = offset
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// The first hit is the longest matching dname
0000000000000000000000000000000000000000;;						// keep the pointer offset we get back and store
0000000000000000000000000000000000000000;;						// the offset of the current name, because that's
0000000000000000000000000000000000000000;;						// where we need to insert the pointer later
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;						// If compress is true, we're allowed to compress this dname
0000000000000000000000000000000000000000;;						if pointer == -1 && compress {
0000000000000000000000000000000000000000;;							pointer = p         // Where to point to
0000000000000000000000000000000000000000;;							nameoffset = offset // Where to point from
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				labels++
0000000000000000000000000000000000000000;;				begin = i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			escapedDot = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Root label is special
0000000000000000000000000000000000000000;;		if len(bs) == 1 && bs[0] == '.' {
0000000000000000000000000000000000000000;;			return off, labels, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we did compression and we find something add the pointer here
0000000000000000000000000000000000000000;;		if pointer != -1 {
0000000000000000000000000000000000000000;;			// We have two bytes (14 bits) to put the pointer in
0000000000000000000000000000000000000000;;			// if msg == nil, we will never do compression
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint16(msg[nameoffset:], uint16(pointer^0xC000))
0000000000000000000000000000000000000000;;			off = nameoffset + 1
0000000000000000000000000000000000000000;;			goto End
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if msg != nil && off < len(msg) {
0000000000000000000000000000000000000000;;			msg[off] = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	End:
0000000000000000000000000000000000000000;;		off++
0000000000000000000000000000000000000000;;		return off, labels, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unpack a domain name.
0000000000000000000000000000000000000000;;	// In addition to the simple sequences of counted strings above,
0000000000000000000000000000000000000000;;	// domain names are allowed to refer to strings elsewhere in the
0000000000000000000000000000000000000000;;	// packet, to avoid repeating common suffixes when returning
0000000000000000000000000000000000000000;;	// many entries in a single domain.  The pointers are marked
0000000000000000000000000000000000000000;;	// by a length byte with the top two bits set.  Ignoring those
0000000000000000000000000000000000000000;;	// two bits, that byte and the next give a 14 bit offset from msg[0]
0000000000000000000000000000000000000000;;	// where we should pick up the trail.
0000000000000000000000000000000000000000;;	// Note that if we jump elsewhere in the packet,
0000000000000000000000000000000000000000;;	// we return off1 == the offset after the first pointer we found,
0000000000000000000000000000000000000000;;	// which is where the next record will start.
0000000000000000000000000000000000000000;;	// In theory, the pointers are only allowed to jump backward.
0000000000000000000000000000000000000000;;	// We let them jump anywhere and stop jumping after a while.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnpackDomainName unpacks a domain name into a string.
0000000000000000000000000000000000000000;;	func UnpackDomainName(msg []byte, off int) (string, int, error) {
0000000000000000000000000000000000000000;;		s := make([]byte, 0, 64)
0000000000000000000000000000000000000000;;		off1 := 0
0000000000000000000000000000000000000000;;		lenmsg := len(msg)
0000000000000000000000000000000000000000;;		ptr := 0 // number of pointers followed
0000000000000000000000000000000000000000;;	Loop:
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if off >= lenmsg {
0000000000000000000000000000000000000000;;				return "", lenmsg, ErrBuf
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c := int(msg[off])
0000000000000000000000000000000000000000;;			off++
0000000000000000000000000000000000000000;;			switch c & 0xC0 {
0000000000000000000000000000000000000000;;			case 0x00:
0000000000000000000000000000000000000000;;				if c == 0x00 {
0000000000000000000000000000000000000000;;					// end of name
0000000000000000000000000000000000000000;;					break Loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// literal string
0000000000000000000000000000000000000000;;				if off+c > lenmsg {
0000000000000000000000000000000000000000;;					return "", lenmsg, ErrBuf
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for j := off; j < off+c; j++ {
0000000000000000000000000000000000000000;;					switch b := msg[j]; b {
0000000000000000000000000000000000000000;;					case '.', '(', ')', ';', ' ', '@':
0000000000000000000000000000000000000000;;						fallthrough
0000000000000000000000000000000000000000;;					case '"', '\\':
0000000000000000000000000000000000000000;;						s = append(s, '\\', b)
0000000000000000000000000000000000000000;;					case '\t':
0000000000000000000000000000000000000000;;						s = append(s, '\\', 't')
0000000000000000000000000000000000000000;;					case '\r':
0000000000000000000000000000000000000000;;						s = append(s, '\\', 'r')
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						if b < 32 || b >= 127 { // unprintable use \DDD
0000000000000000000000000000000000000000;;							var buf [3]byte
0000000000000000000000000000000000000000;;							bufs := strconv.AppendInt(buf[:0], int64(b), 10)
0000000000000000000000000000000000000000;;							s = append(s, '\\')
0000000000000000000000000000000000000000;;							for i := 0; i < 3-len(bufs); i++ {
0000000000000000000000000000000000000000;;								s = append(s, '0')
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							for _, r := range bufs {
0000000000000000000000000000000000000000;;								s = append(s, r)
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						} else {
0000000000000000000000000000000000000000;;							s = append(s, b)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				s = append(s, '.')
0000000000000000000000000000000000000000;;				off += c
0000000000000000000000000000000000000000;;			case 0xC0:
0000000000000000000000000000000000000000;;				// pointer to somewhere else in msg.
0000000000000000000000000000000000000000;;				// remember location after first ptr,
0000000000000000000000000000000000000000;;				// since that's how many bytes we consumed.
0000000000000000000000000000000000000000;;				// also, don't follow too many pointers --
0000000000000000000000000000000000000000;;				// maybe there's a loop.
0000000000000000000000000000000000000000;;				if off >= lenmsg {
0000000000000000000000000000000000000000;;					return "", lenmsg, ErrBuf
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c1 := msg[off]
0000000000000000000000000000000000000000;;				off++
0000000000000000000000000000000000000000;;				if ptr == 0 {
0000000000000000000000000000000000000000;;					off1 = off
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if ptr++; ptr > 10 {
0000000000000000000000000000000000000000;;					return "", lenmsg, &Error{err: "too many compression pointers"}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				off = (c^0xC0)<<8 | int(c1)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// 0x80 and 0x40 are reserved
0000000000000000000000000000000000000000;;				return "", lenmsg, ErrRdata
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ptr == 0 {
0000000000000000000000000000000000000000;;			off1 = off
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(s) == 0 {
0000000000000000000000000000000000000000;;			s = []byte(".")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(s), off1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packTxt(txt []string, msg []byte, offset int, tmp []byte) (int, error) {
0000000000000000000000000000000000000000;;		if len(txt) == 0 {
0000000000000000000000000000000000000000;;			if offset >= len(msg) {
0000000000000000000000000000000000000000;;				return offset, ErrBuf
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			msg[offset] = 0
0000000000000000000000000000000000000000;;			return offset, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := range txt {
0000000000000000000000000000000000000000;;			if len(txt[i]) > len(tmp) {
0000000000000000000000000000000000000000;;				return offset, ErrBuf
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			offset, err = packTxtString(txt[i], msg, offset, tmp)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return offset, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return offset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packTxtString(s string, msg []byte, offset int, tmp []byte) (int, error) {
0000000000000000000000000000000000000000;;		lenByteOffset := offset
0000000000000000000000000000000000000000;;		if offset >= len(msg) || len(s) > len(tmp) {
0000000000000000000000000000000000000000;;			return offset, ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		offset++
0000000000000000000000000000000000000000;;		bs := tmp[:len(s)]
0000000000000000000000000000000000000000;;		copy(bs, s)
0000000000000000000000000000000000000000;;		for i := 0; i < len(bs); i++ {
0000000000000000000000000000000000000000;;			if len(msg) <= offset {
0000000000000000000000000000000000000000;;				return offset, ErrBuf
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bs[i] == '\\' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				if i == len(bs) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for \DDD
0000000000000000000000000000000000000000;;				if i+2 < len(bs) && isDigit(bs[i]) && isDigit(bs[i+1]) && isDigit(bs[i+2]) {
0000000000000000000000000000000000000000;;					msg[offset] = dddToByte(bs[i:])
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;				} else if bs[i] == 't' {
0000000000000000000000000000000000000000;;					msg[offset] = '\t'
0000000000000000000000000000000000000000;;				} else if bs[i] == 'r' {
0000000000000000000000000000000000000000;;					msg[offset] = '\r'
0000000000000000000000000000000000000000;;				} else if bs[i] == 'n' {
0000000000000000000000000000000000000000;;					msg[offset] = '\n'
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg[offset] = bs[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg[offset] = bs[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			offset++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := offset - lenByteOffset - 1
0000000000000000000000000000000000000000;;		if l > 255 {
0000000000000000000000000000000000000000;;			return offset, &Error{err: "string exceeded 255 bytes in txt"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg[lenByteOffset] = byte(l)
0000000000000000000000000000000000000000;;		return offset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packOctetString(s string, msg []byte, offset int, tmp []byte) (int, error) {
0000000000000000000000000000000000000000;;		if offset >= len(msg) || len(s) > len(tmp) {
0000000000000000000000000000000000000000;;			return offset, ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		bs := tmp[:len(s)]
0000000000000000000000000000000000000000;;		copy(bs, s)
0000000000000000000000000000000000000000;;		for i := 0; i < len(bs); i++ {
0000000000000000000000000000000000000000;;			if len(msg) <= offset {
0000000000000000000000000000000000000000;;				return offset, ErrBuf
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bs[i] == '\\' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				if i == len(bs) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// check for \DDD
0000000000000000000000000000000000000000;;				if i+2 < len(bs) && isDigit(bs[i]) && isDigit(bs[i+1]) && isDigit(bs[i+2]) {
0000000000000000000000000000000000000000;;					msg[offset] = dddToByte(bs[i:])
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					msg[offset] = bs[i]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				msg[offset] = bs[i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			offset++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return offset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTxt(msg []byte, off0 int) (ss []string, off int, err error) {
0000000000000000000000000000000000000000;;		off = off0
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;		for off < len(msg) && err == nil {
0000000000000000000000000000000000000000;;			s, off, err = unpackTxtString(msg, off)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				ss = append(ss, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackTxtString(msg []byte, offset int) (string, int, error) {
0000000000000000000000000000000000000000;;		if offset+1 > len(msg) {
0000000000000000000000000000000000000000;;			return "", offset, &Error{err: "overflow unpacking txt"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := int(msg[offset])
0000000000000000000000000000000000000000;;		if offset+l+1 > len(msg) {
0000000000000000000000000000000000000000;;			return "", offset, &Error{err: "overflow unpacking txt"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := make([]byte, 0, l)
0000000000000000000000000000000000000000;;		for _, b := range msg[offset+1 : offset+1+l] {
0000000000000000000000000000000000000000;;			switch b {
0000000000000000000000000000000000000000;;			case '"', '\\':
0000000000000000000000000000000000000000;;				s = append(s, '\\', b)
0000000000000000000000000000000000000000;;			case '\t':
0000000000000000000000000000000000000000;;				s = append(s, `\t`...)
0000000000000000000000000000000000000000;;			case '\r':
0000000000000000000000000000000000000000;;				s = append(s, `\r`...)
0000000000000000000000000000000000000000;;			case '\n':
0000000000000000000000000000000000000000;;				s = append(s, `\n`...)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if b < 32 || b > 127 { // unprintable
0000000000000000000000000000000000000000;;					var buf [3]byte
0000000000000000000000000000000000000000;;					bufs := strconv.AppendInt(buf[:0], int64(b), 10)
0000000000000000000000000000000000000000;;					s = append(s, '\\')
0000000000000000000000000000000000000000;;					for i := 0; i < 3-len(bufs); i++ {
0000000000000000000000000000000000000000;;						s = append(s, '0')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, r := range bufs {
0000000000000000000000000000000000000000;;						s = append(s, r)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					s = append(s, b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		offset += 1 + l
0000000000000000000000000000000000000000;;		return string(s), offset, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helpers for dealing with escaped bytes
0000000000000000000000000000000000000000;;	func isDigit(b byte) bool { return b >= '0' && b <= '9' }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func dddToByte(s []byte) byte {
0000000000000000000000000000000000000000;;		return byte((s[0]-'0')*100 + (s[1]-'0')*10 + (s[2] - '0'))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Helper function for packing and unpacking
0000000000000000000000000000000000000000;;	func intToBytes(i *big.Int, length int) []byte {
0000000000000000000000000000000000000000;;		buf := i.Bytes()
0000000000000000000000000000000000000000;;		if len(buf) < length {
0000000000000000000000000000000000000000;;			b := make([]byte, length)
0000000000000000000000000000000000000000;;			copy(b[length-len(buf):], buf)
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PackRR packs a resource record rr into msg[off:].
0000000000000000000000000000000000000000;;	// See PackDomainName for documentation about the compression.
0000000000000000000000000000000000000000;;	func PackRR(rr RR, msg []byte, off int, compression map[string]int, compress bool) (off1 int, err error) {
0000000000000000000000000000000000000000;;		if rr == nil {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "nil rr"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		off1, err = rr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(miek): Not sure if this is needed? If removed we can remove rawmsg.go as well.
0000000000000000000000000000000000000000;;		if rawSetRdlength(msg, off, off1) {
0000000000000000000000000000000000000000;;			return off1, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, ErrRdata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnpackRR unpacks msg[off:] into an RR.
0000000000000000000000000000000000000000;;	func UnpackRR(msg []byte, off int) (rr RR, off1 int, err error) {
0000000000000000000000000000000000000000;;		h, off, msg, err := unpackHeader(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end := off + int(h.Rdlength)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if fn, known := typeToUnpack[h.Rrtype]; !known {
0000000000000000000000000000000000000000;;			rr, off, err = unpackRFC3597(h, msg, off)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			rr, off, err = fn(h, msg, off)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off != end {
0000000000000000000000000000000000000000;;			return &h, end, &Error{err: "bad rdlength"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unpackRRslice unpacks msg[off:] into an []RR.
0000000000000000000000000000000000000000;;	// If we cannot unpack the whole array, then it will return nil
0000000000000000000000000000000000000000;;	func unpackRRslice(l int, msg []byte, off int) (dst1 []RR, off1 int, err error) {
0000000000000000000000000000000000000000;;		var r RR
0000000000000000000000000000000000000000;;		// Optimistically make dst be the length that was sent
0000000000000000000000000000000000000000;;		dst := make([]RR, 0, l)
0000000000000000000000000000000000000000;;		for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;			off1 := off
0000000000000000000000000000000000000000;;			r, off, err = UnpackRR(msg, off)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				off = len(msg)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// If offset does not increase anymore, l is a lie
0000000000000000000000000000000000000000;;			if off1 == off {
0000000000000000000000000000000000000000;;				l = i
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dst = append(dst, r)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil && off == len(msg) {
0000000000000000000000000000000000000000;;			dst = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dst, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert a MsgHdr to a string, with dig-like headers:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//;; opcode: QUERY, status: NOERROR, id: 48404
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//;; flags: qr aa rd ra;
0000000000000000000000000000000000000000;;	func (h *MsgHdr) String() string {
0000000000000000000000000000000000000000;;		if h == nil {
0000000000000000000000000000000000000000;;			return "<nil> MsgHdr"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := ";; opcode: " + OpcodeToString[h.Opcode]
0000000000000000000000000000000000000000;;		s += ", status: " + RcodeToString[h.Rcode]
0000000000000000000000000000000000000000;;		s += ", id: " + strconv.Itoa(int(h.Id)) + "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s += ";; flags:"
0000000000000000000000000000000000000000;;		if h.Response {
0000000000000000000000000000000000000000;;			s += " qr"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.Authoritative {
0000000000000000000000000000000000000000;;			s += " aa"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.Truncated {
0000000000000000000000000000000000000000;;			s += " tc"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.RecursionDesired {
0000000000000000000000000000000000000000;;			s += " rd"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.RecursionAvailable {
0000000000000000000000000000000000000000;;			s += " ra"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.Zero { // Hmm
0000000000000000000000000000000000000000;;			s += " z"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.AuthenticatedData {
0000000000000000000000000000000000000000;;			s += " ad"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if h.CheckingDisabled {
0000000000000000000000000000000000000000;;			s += " cd"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s += ";"
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pack packs a Msg: it is converted to to wire format.
0000000000000000000000000000000000000000;;	// If the dns.Compress is true the message will be in compressed wire format.
0000000000000000000000000000000000000000;;	func (dns *Msg) Pack() (msg []byte, err error) {
0000000000000000000000000000000000000000;;		return dns.PackBuffer(nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PackBuffer packs a Msg, using the given buffer buf. If buf is too small
0000000000000000000000000000000000000000;;	// a new buffer is allocated.
0000000000000000000000000000000000000000;;	func (dns *Msg) PackBuffer(buf []byte) (msg []byte, err error) {
0000000000000000000000000000000000000000;;		// We use a similar function in tsig.go's stripTsig.
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dh          Header
0000000000000000000000000000000000000000;;			compression map[string]int
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dns.Compress {
0000000000000000000000000000000000000000;;			compression = make(map[string]int) // Compression pointer mappings
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dns.Rcode < 0 || dns.Rcode > 0xFFF {
0000000000000000000000000000000000000000;;			return nil, ErrRcode
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.Rcode > 0xF {
0000000000000000000000000000000000000000;;			// Regular RCODE field is 4 bits
0000000000000000000000000000000000000000;;			opt := dns.IsEdns0()
0000000000000000000000000000000000000000;;			if opt == nil {
0000000000000000000000000000000000000000;;				return nil, ErrExtendedRcode
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			opt.SetExtendedRcode(uint8(dns.Rcode >> 4))
0000000000000000000000000000000000000000;;			dns.Rcode &= 0xF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert convenient Msg into wire-like Header.
0000000000000000000000000000000000000000;;		dh.Id = dns.Id
0000000000000000000000000000000000000000;;		dh.Bits = uint16(dns.Opcode)<<11 | uint16(dns.Rcode)
0000000000000000000000000000000000000000;;		if dns.Response {
0000000000000000000000000000000000000000;;			dh.Bits |= _QR
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.Authoritative {
0000000000000000000000000000000000000000;;			dh.Bits |= _AA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.Truncated {
0000000000000000000000000000000000000000;;			dh.Bits |= _TC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.RecursionDesired {
0000000000000000000000000000000000000000;;			dh.Bits |= _RD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.RecursionAvailable {
0000000000000000000000000000000000000000;;			dh.Bits |= _RA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.Zero {
0000000000000000000000000000000000000000;;			dh.Bits |= _Z
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.AuthenticatedData {
0000000000000000000000000000000000000000;;			dh.Bits |= _AD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dns.CheckingDisabled {
0000000000000000000000000000000000000000;;			dh.Bits |= _CD
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Prepare variable sized arrays.
0000000000000000000000000000000000000000;;		question := dns.Question
0000000000000000000000000000000000000000;;		answer := dns.Answer
0000000000000000000000000000000000000000;;		ns := dns.Ns
0000000000000000000000000000000000000000;;		extra := dns.Extra
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dh.Qdcount = uint16(len(question))
0000000000000000000000000000000000000000;;		dh.Ancount = uint16(len(answer))
0000000000000000000000000000000000000000;;		dh.Nscount = uint16(len(ns))
0000000000000000000000000000000000000000;;		dh.Arcount = uint16(len(extra))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// We need the uncompressed length here, because we first pack it and then compress it.
0000000000000000000000000000000000000000;;		msg = buf
0000000000000000000000000000000000000000;;		compress := dns.Compress
0000000000000000000000000000000000000000;;		dns.Compress = false
0000000000000000000000000000000000000000;;		if packLen := dns.Len() + 1; len(msg) < packLen {
0000000000000000000000000000000000000000;;			msg = make([]byte, packLen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dns.Compress = compress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pack it in: header and then the pieces.
0000000000000000000000000000000000000000;;		off := 0
0000000000000000000000000000000000000000;;		off, err = dh.pack(msg, off, compression, dns.Compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(question); i++ {
0000000000000000000000000000000000000000;;			off, err = question[i].pack(msg, off, compression, dns.Compress)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(answer); i++ {
0000000000000000000000000000000000000000;;			off, err = PackRR(answer[i], msg, off, compression, dns.Compress)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(ns); i++ {
0000000000000000000000000000000000000000;;			off, err = PackRR(ns[i], msg, off, compression, dns.Compress)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(extra); i++ {
0000000000000000000000000000000000000000;;			off, err = PackRR(extra[i], msg, off, compression, dns.Compress)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg[:off], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unpack unpacks a binary message to a Msg structure.
0000000000000000000000000000000000000000;;	func (dns *Msg) Unpack(msg []byte) (err error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dh  Header
0000000000000000000000000000000000000000;;			off int
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if dh, off, err = unpackMsgHdr(msg, off); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return ErrTruncated
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dns.Id = dh.Id
0000000000000000000000000000000000000000;;		dns.Response = (dh.Bits & _QR) != 0
0000000000000000000000000000000000000000;;		dns.Opcode = int(dh.Bits>>11) & 0xF
0000000000000000000000000000000000000000;;		dns.Authoritative = (dh.Bits & _AA) != 0
0000000000000000000000000000000000000000;;		dns.Truncated = (dh.Bits & _TC) != 0
0000000000000000000000000000000000000000;;		dns.RecursionDesired = (dh.Bits & _RD) != 0
0000000000000000000000000000000000000000;;		dns.RecursionAvailable = (dh.Bits & _RA) != 0
0000000000000000000000000000000000000000;;		dns.Zero = (dh.Bits & _Z) != 0
0000000000000000000000000000000000000000;;		dns.AuthenticatedData = (dh.Bits & _AD) != 0
0000000000000000000000000000000000000000;;		dns.CheckingDisabled = (dh.Bits & _CD) != 0
0000000000000000000000000000000000000000;;		dns.Rcode = int(dh.Bits & 0xF)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Optimistically use the count given to us in the header
0000000000000000000000000000000000000000;;		dns.Question = make([]Question, 0, int(dh.Qdcount))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < int(dh.Qdcount); i++ {
0000000000000000000000000000000000000000;;			off1 := off
0000000000000000000000000000000000000000;;			var q Question
0000000000000000000000000000000000000000;;			q, off, err = unpackQuestion(msg, off)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				// Even if Truncated is set, we only will set ErrTruncated if we
0000000000000000000000000000000000000000;;				// actually got the questions
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if off1 == off { // Offset does not increase anymore, dh.Qdcount is a lie!
0000000000000000000000000000000000000000;;				dh.Qdcount = uint16(i)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dns.Question = append(dns.Question, q)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dns.Answer, off, err = unpackRRslice(int(dh.Ancount), msg, off)
0000000000000000000000000000000000000000;;		// The header counts might have been wrong so we need to update it
0000000000000000000000000000000000000000;;		dh.Ancount = uint16(len(dns.Answer))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			dns.Ns, off, err = unpackRRslice(int(dh.Nscount), msg, off)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The header counts might have been wrong so we need to update it
0000000000000000000000000000000000000000;;		dh.Nscount = uint16(len(dns.Ns))
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			dns.Extra, off, err = unpackRRslice(int(dh.Arcount), msg, off)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// The header counts might have been wrong so we need to update it
0000000000000000000000000000000000000000;;		dh.Arcount = uint16(len(dns.Extra))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if off != len(msg) {
0000000000000000000000000000000000000000;;			// TODO(miek) make this an error?
0000000000000000000000000000000000000000;;			// use PackOpt to let people tell how detailed the error reporting should be?
0000000000000000000000000000000000000000;;			// println("dns: extra bytes in dns packet", off, "<", len(msg))
0000000000000000000000000000000000000000;;		} else if dns.Truncated {
0000000000000000000000000000000000000000;;			// Whether we ran into a an error or not, we want to return that it
0000000000000000000000000000000000000000;;			// was truncated
0000000000000000000000000000000000000000;;			err = ErrTruncated
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert a complete message to a string with dig-like output.
0000000000000000000000000000000000000000;;	func (dns *Msg) String() string {
0000000000000000000000000000000000000000;;		if dns == nil {
0000000000000000000000000000000000000000;;			return "<nil> MsgHdr"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := dns.MsgHdr.String() + " "
0000000000000000000000000000000000000000;;		s += "QUERY: " + strconv.Itoa(len(dns.Question)) + ", "
0000000000000000000000000000000000000000;;		s += "ANSWER: " + strconv.Itoa(len(dns.Answer)) + ", "
0000000000000000000000000000000000000000;;		s += "AUTHORITY: " + strconv.Itoa(len(dns.Ns)) + ", "
0000000000000000000000000000000000000000;;		s += "ADDITIONAL: " + strconv.Itoa(len(dns.Extra)) + "\n"
0000000000000000000000000000000000000000;;		if len(dns.Question) > 0 {
0000000000000000000000000000000000000000;;			s += "\n;; QUESTION SECTION:\n"
0000000000000000000000000000000000000000;;			for i := 0; i < len(dns.Question); i++ {
0000000000000000000000000000000000000000;;				s += dns.Question[i].String() + "\n"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(dns.Answer) > 0 {
0000000000000000000000000000000000000000;;			s += "\n;; ANSWER SECTION:\n"
0000000000000000000000000000000000000000;;			for i := 0; i < len(dns.Answer); i++ {
0000000000000000000000000000000000000000;;				if dns.Answer[i] != nil {
0000000000000000000000000000000000000000;;					s += dns.Answer[i].String() + "\n"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(dns.Ns) > 0 {
0000000000000000000000000000000000000000;;			s += "\n;; AUTHORITY SECTION:\n"
0000000000000000000000000000000000000000;;			for i := 0; i < len(dns.Ns); i++ {
0000000000000000000000000000000000000000;;				if dns.Ns[i] != nil {
0000000000000000000000000000000000000000;;					s += dns.Ns[i].String() + "\n"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(dns.Extra) > 0 {
0000000000000000000000000000000000000000;;			s += "\n;; ADDITIONAL SECTION:\n"
0000000000000000000000000000000000000000;;			for i := 0; i < len(dns.Extra); i++ {
0000000000000000000000000000000000000000;;				if dns.Extra[i] != nil {
0000000000000000000000000000000000000000;;					s += dns.Extra[i].String() + "\n"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the message length when in (un)compressed wire format.
0000000000000000000000000000000000000000;;	// If dns.Compress is true compression it is taken into account. Len()
0000000000000000000000000000000000000000;;	// is provided to be a faster way to get the size of the resulting packet,
0000000000000000000000000000000000000000;;	// than packing it, measuring the size and discarding the buffer.
0000000000000000000000000000000000000000;;	func (dns *Msg) Len() int {
0000000000000000000000000000000000000000;;		// We always return one more than needed.
0000000000000000000000000000000000000000;;		l := 12 // Message header is always 12 bytes
0000000000000000000000000000000000000000;;		var compression map[string]int
0000000000000000000000000000000000000000;;		if dns.Compress {
0000000000000000000000000000000000000000;;			compression = make(map[string]int)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(dns.Question); i++ {
0000000000000000000000000000000000000000;;			l += dns.Question[i].len()
0000000000000000000000000000000000000000;;			if dns.Compress {
0000000000000000000000000000000000000000;;				compressionLenHelper(compression, dns.Question[i].Name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(dns.Answer); i++ {
0000000000000000000000000000000000000000;;			if dns.Answer[i] == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l += dns.Answer[i].len()
0000000000000000000000000000000000000000;;			if dns.Compress {
0000000000000000000000000000000000000000;;				k, ok := compressionLenSearch(compression, dns.Answer[i].Header().Name)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					l += 1 - k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				compressionLenHelper(compression, dns.Answer[i].Header().Name)
0000000000000000000000000000000000000000;;				k, ok = compressionLenSearchType(compression, dns.Answer[i])
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					l += 1 - k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				compressionLenHelperType(compression, dns.Answer[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(dns.Ns); i++ {
0000000000000000000000000000000000000000;;			if dns.Ns[i] == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l += dns.Ns[i].len()
0000000000000000000000000000000000000000;;			if dns.Compress {
0000000000000000000000000000000000000000;;				k, ok := compressionLenSearch(compression, dns.Ns[i].Header().Name)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					l += 1 - k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				compressionLenHelper(compression, dns.Ns[i].Header().Name)
0000000000000000000000000000000000000000;;				k, ok = compressionLenSearchType(compression, dns.Ns[i])
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					l += 1 - k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				compressionLenHelperType(compression, dns.Ns[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < len(dns.Extra); i++ {
0000000000000000000000000000000000000000;;			if dns.Extra[i] == nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l += dns.Extra[i].len()
0000000000000000000000000000000000000000;;			if dns.Compress {
0000000000000000000000000000000000000000;;				k, ok := compressionLenSearch(compression, dns.Extra[i].Header().Name)
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					l += 1 - k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				compressionLenHelper(compression, dns.Extra[i].Header().Name)
0000000000000000000000000000000000000000;;				k, ok = compressionLenSearchType(compression, dns.Extra[i])
0000000000000000000000000000000000000000;;				if ok {
0000000000000000000000000000000000000000;;					l += 1 - k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				compressionLenHelperType(compression, dns.Extra[i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Put the parts of the name in the compression map.
0000000000000000000000000000000000000000;;	func compressionLenHelper(c map[string]int, s string) {
0000000000000000000000000000000000000000;;		pref := ""
0000000000000000000000000000000000000000;;		lbs := Split(s)
0000000000000000000000000000000000000000;;		for j := len(lbs) - 1; j >= 0; j-- {
0000000000000000000000000000000000000000;;			pref = s[lbs[j]:]
0000000000000000000000000000000000000000;;			if _, ok := c[pref]; !ok {
0000000000000000000000000000000000000000;;				c[pref] = len(pref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Look for each part in the compression map and returns its length,
0000000000000000000000000000000000000000;;	// keep on searching so we get the longest match.
0000000000000000000000000000000000000000;;	func compressionLenSearch(c map[string]int, s string) (int, bool) {
0000000000000000000000000000000000000000;;		off := 0
0000000000000000000000000000000000000000;;		end := false
0000000000000000000000000000000000000000;;		if s == "" { // don't bork on bogus data
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			if _, ok := c[s[off:]]; ok {
0000000000000000000000000000000000000000;;				return len(s[off:]), true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if end {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			off, end = NextLabel(s, off)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO(miek): should add all types, because the all can be *used* for compression. Autogenerate from msg_generate and put in zmsg.go
0000000000000000000000000000000000000000;;	func compressionLenHelperType(c map[string]int, r RR) {
0000000000000000000000000000000000000000;;		switch x := r.(type) {
0000000000000000000000000000000000000000;;		case *NS:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Ns)
0000000000000000000000000000000000000000;;		case *MX:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Mx)
0000000000000000000000000000000000000000;;		case *CNAME:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Target)
0000000000000000000000000000000000000000;;		case *PTR:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Ptr)
0000000000000000000000000000000000000000;;		case *SOA:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Ns)
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Mbox)
0000000000000000000000000000000000000000;;		case *MB:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Mb)
0000000000000000000000000000000000000000;;		case *MG:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Mg)
0000000000000000000000000000000000000000;;		case *MR:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Mr)
0000000000000000000000000000000000000000;;		case *MF:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Mf)
0000000000000000000000000000000000000000;;		case *MD:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Md)
0000000000000000000000000000000000000000;;		case *RT:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Host)
0000000000000000000000000000000000000000;;		case *RP:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Mbox)
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Txt)
0000000000000000000000000000000000000000;;		case *MINFO:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Rmail)
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Email)
0000000000000000000000000000000000000000;;		case *AFSDB:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Hostname)
0000000000000000000000000000000000000000;;		case *SRV:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Target)
0000000000000000000000000000000000000000;;		case *NAPTR:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.Replacement)
0000000000000000000000000000000000000000;;		case *RRSIG:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.SignerName)
0000000000000000000000000000000000000000;;		case *NSEC:
0000000000000000000000000000000000000000;;			compressionLenHelper(c, x.NextDomain)
0000000000000000000000000000000000000000;;			// HIP?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Only search on compressing these types.
0000000000000000000000000000000000000000;;	func compressionLenSearchType(c map[string]int, r RR) (int, bool) {
0000000000000000000000000000000000000000;;		switch x := r.(type) {
0000000000000000000000000000000000000000;;		case *NS:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Ns)
0000000000000000000000000000000000000000;;		case *MX:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Mx)
0000000000000000000000000000000000000000;;		case *CNAME:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Target)
0000000000000000000000000000000000000000;;		case *DNAME:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Target)
0000000000000000000000000000000000000000;;		case *PTR:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Ptr)
0000000000000000000000000000000000000000;;		case *SOA:
0000000000000000000000000000000000000000;;			k, ok := compressionLenSearch(c, x.Ns)
0000000000000000000000000000000000000000;;			k1, ok1 := compressionLenSearch(c, x.Mbox)
0000000000000000000000000000000000000000;;			if !ok && !ok1 {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return k + k1, true
0000000000000000000000000000000000000000;;		case *MB:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Mb)
0000000000000000000000000000000000000000;;		case *MG:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Mg)
0000000000000000000000000000000000000000;;		case *MR:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Mr)
0000000000000000000000000000000000000000;;		case *MF:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Mf)
0000000000000000000000000000000000000000;;		case *MD:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Md)
0000000000000000000000000000000000000000;;		case *RT:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Host)
0000000000000000000000000000000000000000;;		case *MINFO:
0000000000000000000000000000000000000000;;			k, ok := compressionLenSearch(c, x.Rmail)
0000000000000000000000000000000000000000;;			k1, ok1 := compressionLenSearch(c, x.Email)
0000000000000000000000000000000000000000;;			if !ok && !ok1 {
0000000000000000000000000000000000000000;;				return 0, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return k + k1, true
0000000000000000000000000000000000000000;;		case *AFSDB:
0000000000000000000000000000000000000000;;			return compressionLenSearch(c, x.Hostname)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy returns a new RR which is a deep-copy of r.
0000000000000000000000000000000000000000;;	func Copy(r RR) RR { r1 := r.copy(); return r1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the length (in octets) of the uncompressed RR in wire format.
0000000000000000000000000000000000000000;;	func Len(r RR) int { return r.len() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copy returns a new *Msg which is a deep-copy of dns.
0000000000000000000000000000000000000000;;	func (dns *Msg) Copy() *Msg { return dns.CopyTo(new(Msg)) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CopyTo copies the contents to the provided message using a deep-copy and returns the copy.
0000000000000000000000000000000000000000;;	func (dns *Msg) CopyTo(r1 *Msg) *Msg {
0000000000000000000000000000000000000000;;		r1.MsgHdr = dns.MsgHdr
0000000000000000000000000000000000000000;;		r1.Compress = dns.Compress
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dns.Question) > 0 {
0000000000000000000000000000000000000000;;			r1.Question = make([]Question, len(dns.Question))
0000000000000000000000000000000000000000;;			copy(r1.Question, dns.Question) // TODO(miek): Question is an immutable value, ok to do a shallow-copy
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rrArr := make([]RR, len(dns.Answer)+len(dns.Ns)+len(dns.Extra))
0000000000000000000000000000000000000000;;		var rri int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dns.Answer) > 0 {
0000000000000000000000000000000000000000;;			rrbegin := rri
0000000000000000000000000000000000000000;;			for i := 0; i < len(dns.Answer); i++ {
0000000000000000000000000000000000000000;;				rrArr[rri] = dns.Answer[i].copy()
0000000000000000000000000000000000000000;;				rri++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r1.Answer = rrArr[rrbegin:rri:rri]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dns.Ns) > 0 {
0000000000000000000000000000000000000000;;			rrbegin := rri
0000000000000000000000000000000000000000;;			for i := 0; i < len(dns.Ns); i++ {
0000000000000000000000000000000000000000;;				rrArr[rri] = dns.Ns[i].copy()
0000000000000000000000000000000000000000;;				rri++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r1.Ns = rrArr[rrbegin:rri:rri]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(dns.Extra) > 0 {
0000000000000000000000000000000000000000;;			rrbegin := rri
0000000000000000000000000000000000000000;;			for i := 0; i < len(dns.Extra); i++ {
0000000000000000000000000000000000000000;;				rrArr[rri] = dns.Extra[i].copy()
0000000000000000000000000000000000000000;;				rri++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r1.Extra = rrArr[rrbegin:rri:rri]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (q *Question) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := PackDomainName(q.Name, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(q.Qtype, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(q.Qclass, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackQuestion(msg []byte, off int) (Question, int, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			q   Question
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		q.Name, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return q, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return q, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.Qtype, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return q, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return q, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		q.Qclass, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return q, off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q, off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dh *Header) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := packUint16(dh.Id, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(dh.Bits, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(dh.Qdcount, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(dh.Ancount, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(dh.Nscount, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(dh.Arcount, msg, off)
0000000000000000000000000000000000000000;;		return off, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackMsgHdr(msg []byte, off int) (Header, int, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dh  Header
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		dh.Id, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return dh, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dh.Bits, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return dh, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dh.Qdcount, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return dh, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dh.Ancount, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return dh, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dh.Nscount, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return dh, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dh.Arcount, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		return dh, off, err
0000000000000000000000000000000000000000;;	}
