0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/zgenerate.go[Godeps/_workspace/src/github.com/miekg/dns/zgenerate.go][vendor/github.com/miekg/dns/generate.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse the $GENERATE statement as used in BIND9 zones.
0000000000000000000000000000000000000000;;	// See http://www.zytrax.com/books/dns/ch8/generate.html for instance.
0000000000000000000000000000000000000000;;	// We are called after '$GENERATE '. After which we expect:
0000000000000000000000000000000000000000;;	// * the range (12-24/2)
0000000000000000000000000000000000000000;;	// * lhs (ownername)
0000000000000000000000000000000000000000;;	// * [[ttl][class]]
0000000000000000000000000000000000000000;;	// * type
0000000000000000000000000000000000000000;;	// * rhs (rdata)
0000000000000000000000000000000000000000;;	// But we are lazy here, only the range is parsed *all* occurrences
0000000000000000000000000000000000000000;;	// of $ after that are interpreted.
0000000000000000000000000000000000000000;;	// Any error are returned as a string value, the empty string signals
0000000000000000000000000000000000000000;;	// "no error".
0000000000000000000000000000000000000000;;	func generate(l lex, c chan lex, t chan *Token, o string) string {
0000000000000000000000000000000000000000;;		step := 1
0000000000000000000000000000000000000000;;		if i := strings.IndexAny(l.token, "/"); i != -1 {
0000000000000000000000000000000000000000;;			if i+1 == len(l.token) {
0000000000000000000000000000000000000000;;				return "bad step in $GENERATE range"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s, err := strconv.Atoi(l.token[i+1:]); err == nil {
0000000000000000000000000000000000000000;;				if s < 0 {
0000000000000000000000000000000000000000;;					return "bad step in $GENERATE range"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				step = s
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return "bad step in $GENERATE range"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l.token = l.token[:i]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sx := strings.SplitN(l.token, "-", 2)
0000000000000000000000000000000000000000;;		if len(sx) != 2 {
0000000000000000000000000000000000000000;;			return "bad start-stop in $GENERATE range"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		start, err := strconv.Atoi(sx[0])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "bad start in $GENERATE range"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		end, err := strconv.Atoi(sx[1])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "bad stop in $GENERATE range"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end < 0 || start < 0 || end < start {
0000000000000000000000000000000000000000;;			return "bad range in $GENERATE range"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		<-c // _BLANK
0000000000000000000000000000000000000000;;		// Create a complete new string, which we then parse again.
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;	BuildRR:
0000000000000000000000000000000000000000;;		l = <-c
0000000000000000000000000000000000000000;;		if l.value != zNewline && l.value != zEOF {
0000000000000000000000000000000000000000;;			s += l.token
0000000000000000000000000000000000000000;;			goto BuildRR
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := start; i <= end; i += step {
0000000000000000000000000000000000000000;;			var (
0000000000000000000000000000000000000000;;				escape bool
0000000000000000000000000000000000000000;;				dom    bytes.Buffer
0000000000000000000000000000000000000000;;				mod    string
0000000000000000000000000000000000000000;;				err    error
0000000000000000000000000000000000000000;;				offset int
0000000000000000000000000000000000000000;;			)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for j := 0; j < len(s); j++ { // No 'range' because we need to jump around
0000000000000000000000000000000000000000;;				switch s[j] {
0000000000000000000000000000000000000000;;				case '\\':
0000000000000000000000000000000000000000;;					if escape {
0000000000000000000000000000000000000000;;						dom.WriteByte('\\')
0000000000000000000000000000000000000000;;						escape = false
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					escape = true
0000000000000000000000000000000000000000;;				case '$':
0000000000000000000000000000000000000000;;					mod = "%d"
0000000000000000000000000000000000000000;;					offset = 0
0000000000000000000000000000000000000000;;					if escape {
0000000000000000000000000000000000000000;;						dom.WriteByte('$')
0000000000000000000000000000000000000000;;						escape = false
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					escape = false
0000000000000000000000000000000000000000;;					if j+1 >= len(s) { // End of the string
0000000000000000000000000000000000000000;;						dom.WriteString(fmt.Sprintf(mod, i+offset))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if s[j+1] == '$' {
0000000000000000000000000000000000000000;;							dom.WriteByte('$')
0000000000000000000000000000000000000000;;							j++
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// Search for { and }
0000000000000000000000000000000000000000;;					if s[j+1] == '{' { // Modifier block
0000000000000000000000000000000000000000;;						sep := strings.Index(s[j+2:], "}")
0000000000000000000000000000000000000000;;						if sep == -1 {
0000000000000000000000000000000000000000;;							return "bad modifier in $GENERATE"
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						mod, offset, err = modToPrintf(s[j+2 : j+2+sep])
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							return err.Error()
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						j += 2 + sep // Jump to it
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dom.WriteString(fmt.Sprintf(mod, i+offset))
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					if escape { // Pretty useless here
0000000000000000000000000000000000000000;;						escape = false
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					dom.WriteByte(s[j])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Re-parse the RR and send it on the current channel t
0000000000000000000000000000000000000000;;			rx, err := NewRR("$ORIGIN " + o + "\n" + dom.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err.Error()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			t <- &Token{RR: rx}
0000000000000000000000000000000000000000;;			// Its more efficient to first built the rrlist and then parse it in
0000000000000000000000000000000000000000;;			// one go! But is this a problem?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert a $GENERATE modifier 0,0,d to something Printf can deal with.
0000000000000000000000000000000000000000;;	func modToPrintf(s string) (string, int, error) {
0000000000000000000000000000000000000000;;		xs := strings.SplitN(s, ",", 3)
0000000000000000000000000000000000000000;;		if len(xs) != 3 {
0000000000000000000000000000000000000000;;			return "", 0, errors.New("bad modifier in $GENERATE")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// xs[0] is offset, xs[1] is width, xs[2] is base
0000000000000000000000000000000000000000;;		if xs[2] != "o" && xs[2] != "d" && xs[2] != "x" && xs[2] != "X" {
0000000000000000000000000000000000000000;;			return "", 0, errors.New("bad base in $GENERATE")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		offset, err := strconv.Atoi(xs[0])
0000000000000000000000000000000000000000;;		if err != nil || offset > 255 {
0000000000000000000000000000000000000000;;			return "", 0, errors.New("bad offset in $GENERATE")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		width, err := strconv.Atoi(xs[1])
0000000000000000000000000000000000000000;;		if err != nil || width > 255 {
0000000000000000000000000000000000000000;;			return "", offset, errors.New("bad width in $GENERATE")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case width < 0:
0000000000000000000000000000000000000000;;			return "", offset, errors.New("bad width in $GENERATE")
0000000000000000000000000000000000000000;;		case width == 0:
0000000000000000000000000000000000000000;;			return "%" + xs[1] + xs[2], offset, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "%0" + xs[1] + xs[2], offset, nil
0000000000000000000000000000000000000000;;	}
