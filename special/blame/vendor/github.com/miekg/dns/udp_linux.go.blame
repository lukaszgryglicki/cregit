0000000000000000000000000000000000000000;;	// +build linux
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/udp_linux.go[Godeps/_workspace/src/github.com/miekg/dns/udp_linux.go][vendor/github.com/miekg/dns/udp_linux.go];	
0000000000000000000000000000000000000000;;	package dns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// See:
0000000000000000000000000000000000000000;;	// * http://stackoverflow.com/questions/3062205/setting-the-source-ip-for-a-udp-socket and
0000000000000000000000000000000000000000;;	// * http://blog.powerdns.com/2012/10/08/on-binding-datagram-udp-sockets-to-the-any-addresses/
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Why do we need this: When listening on 0.0.0.0 with UDP so kernel decides what is the outgoing
0000000000000000000000000000000000000000;;	// interface, this might not always be the correct one. This code will make sure the egress
0000000000000000000000000000000000000000;;	// packet's interface matched the ingress' one.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setUDPSocketOptions4 prepares the v4 socket for sessions.
0000000000000000000000000000000000000000;;	func setUDPSocketOptions4(conn *net.UDPConn) error {
0000000000000000000000000000000000000000;;		file, err := conn.File()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.SetsockoptInt(int(file.Fd()), syscall.IPPROTO_IP, syscall.IP_PKTINFO, 1); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Calling File() above results in the connection becoming blocking, we must fix that.
0000000000000000000000000000000000000000;;		// See https://github.com/miekg/dns/issues/279
0000000000000000000000000000000000000000;;		err = syscall.SetNonblock(int(file.Fd()), true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setUDPSocketOptions6 prepares the v6 socket for sessions.
0000000000000000000000000000000000000000;;	func setUDPSocketOptions6(conn *net.UDPConn) error {
0000000000000000000000000000000000000000;;		file, err := conn.File()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := syscall.SetsockoptInt(int(file.Fd()), syscall.IPPROTO_IPV6, syscall.IPV6_RECVPKTINFO, 1); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = syscall.SetNonblock(int(file.Fd()), true)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getUDPSocketOption6Only return true if the socket is v6 only and false when it is v4/v6 combined
0000000000000000000000000000000000000000;;	// (dualstack).
0000000000000000000000000000000000000000;;	func getUDPSocketOptions6Only(conn *net.UDPConn) (bool, error) {
0000000000000000000000000000000000000000;;		file, err := conn.File()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// dual stack. See http://stackoverflow.com/questions/1618240/how-to-support-both-ipv4-and-ipv6-connections
0000000000000000000000000000000000000000;;		v6only, err := syscall.GetsockoptInt(int(file.Fd()), syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v6only == 1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getUDPSocketName(conn *net.UDPConn) (syscall.Sockaddr, error) {
0000000000000000000000000000000000000000;;		file, err := conn.File()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return syscall.Getsockname(int(file.Fd()))
0000000000000000000000000000000000000000;;	}
