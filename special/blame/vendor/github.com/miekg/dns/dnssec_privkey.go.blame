0000000000000000000000000000000000000000;;	package dns
b9f13aaa534682ec2030ddaa4366d37857ab7cbb;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/dsa"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const format = "Private-key-format: v1.3\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrivateKeyString converts a PrivateKey to a string. This string has the same
0000000000000000000000000000000000000000;;	// format as the private-key-file of BIND9 (Private-key-format: v1.3).
0000000000000000000000000000000000000000;;	// It needs some info from the key (the algorithm), so its a method of the DNSKEY
0000000000000000000000000000000000000000;;	// It supports rsa.PrivateKey, ecdsa.PrivateKey and dsa.PrivateKey
0000000000000000000000000000000000000000;;	func (r *DNSKEY) PrivateKeyString(p crypto.PrivateKey) string {
0000000000000000000000000000000000000000;;		algorithm := strconv.Itoa(int(r.Algorithm))
0000000000000000000000000000000000000000;;		algorithm += " (" + AlgorithmToString[r.Algorithm] + ")"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch p := p.(type) {
0000000000000000000000000000000000000000;;		case *rsa.PrivateKey:
0000000000000000000000000000000000000000;;			modulus := toBase64(p.PublicKey.N.Bytes())
0000000000000000000000000000000000000000;;			e := big.NewInt(int64(p.PublicKey.E))
0000000000000000000000000000000000000000;;			publicExponent := toBase64(e.Bytes())
0000000000000000000000000000000000000000;;			privateExponent := toBase64(p.D.Bytes())
0000000000000000000000000000000000000000;;			prime1 := toBase64(p.Primes[0].Bytes())
0000000000000000000000000000000000000000;;			prime2 := toBase64(p.Primes[1].Bytes())
0000000000000000000000000000000000000000;;			// Calculate Exponent1/2 and Coefficient as per: http://en.wikipedia.org/wiki/RSA#Using_the_Chinese_remainder_algorithm
0000000000000000000000000000000000000000;;			// and from: http://code.google.com/p/go/issues/detail?id=987
0000000000000000000000000000000000000000;;			one := big.NewInt(1)
0000000000000000000000000000000000000000;;			p1 := big.NewInt(0).Sub(p.Primes[0], one)
0000000000000000000000000000000000000000;;			q1 := big.NewInt(0).Sub(p.Primes[1], one)
0000000000000000000000000000000000000000;;			exp1 := big.NewInt(0).Mod(p.D, p1)
0000000000000000000000000000000000000000;;			exp2 := big.NewInt(0).Mod(p.D, q1)
0000000000000000000000000000000000000000;;			coeff := big.NewInt(0).ModInverse(p.Primes[1], p.Primes[0])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			exponent1 := toBase64(exp1.Bytes())
0000000000000000000000000000000000000000;;			exponent2 := toBase64(exp2.Bytes())
0000000000000000000000000000000000000000;;			coefficient := toBase64(coeff.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return format +
0000000000000000000000000000000000000000;;				"Algorithm: " + algorithm + "\n" +
0000000000000000000000000000000000000000;;				"Modulus: " + modulus + "\n" +
0000000000000000000000000000000000000000;;				"PublicExponent: " + publicExponent + "\n" +
0000000000000000000000000000000000000000;;				"PrivateExponent: " + privateExponent + "\n" +
0000000000000000000000000000000000000000;;				"Prime1: " + prime1 + "\n" +
0000000000000000000000000000000000000000;;				"Prime2: " + prime2 + "\n" +
0000000000000000000000000000000000000000;;				"Exponent1: " + exponent1 + "\n" +
0000000000000000000000000000000000000000;;				"Exponent2: " + exponent2 + "\n" +
0000000000000000000000000000000000000000;;				"Coefficient: " + coefficient + "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *ecdsa.PrivateKey:
0000000000000000000000000000000000000000;;			var intlen int
0000000000000000000000000000000000000000;;			switch r.Algorithm {
0000000000000000000000000000000000000000;;			case ECDSAP256SHA256:
0000000000000000000000000000000000000000;;				intlen = 32
0000000000000000000000000000000000000000;;			case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;				intlen = 48
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			private := toBase64(intToBytes(p.D, intlen))
0000000000000000000000000000000000000000;;			return format +
0000000000000000000000000000000000000000;;				"Algorithm: " + algorithm + "\n" +
0000000000000000000000000000000000000000;;				"PrivateKey: " + private + "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *dsa.PrivateKey:
0000000000000000000000000000000000000000;;			T := divRoundUp(divRoundUp(p.PublicKey.Parameters.G.BitLen(), 8)-64, 8)
0000000000000000000000000000000000000000;;			prime := toBase64(intToBytes(p.PublicKey.Parameters.P, 64+T*8))
0000000000000000000000000000000000000000;;			subprime := toBase64(intToBytes(p.PublicKey.Parameters.Q, 20))
0000000000000000000000000000000000000000;;			base := toBase64(intToBytes(p.PublicKey.Parameters.G, 64+T*8))
0000000000000000000000000000000000000000;;			priv := toBase64(intToBytes(p.X, 20))
0000000000000000000000000000000000000000;;			pub := toBase64(intToBytes(p.PublicKey.Y, 64+T*8))
0000000000000000000000000000000000000000;;			return format +
0000000000000000000000000000000000000000;;				"Algorithm: " + algorithm + "\n" +
0000000000000000000000000000000000000000;;				"Prime(p): " + prime + "\n" +
0000000000000000000000000000000000000000;;				"Subprime(q): " + subprime + "\n" +
0000000000000000000000000000000000000000;;				"Base(g): " + base + "\n" +
0000000000000000000000000000000000000000;;				"Private_value(x): " + priv + "\n" +
0000000000000000000000000000000000000000;;				"Public_value(y): " + pub + "\n"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
