0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/tlsa.go[Godeps/_workspace/src/github.com/miekg/dns/tlsa.go][vendor/github.com/miekg/dns/tlsa.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"crypto/sha512"
0000000000000000000000000000000000000000;;		"crypto/x509"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CertificateToDANE converts a certificate to a hex string as used in the TLSA record.
0000000000000000000000000000000000000000;;	func CertificateToDANE(selector, matchingType uint8, cert *x509.Certificate) (string, error) {
0000000000000000000000000000000000000000;;		switch matchingType {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			switch selector {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				return hex.EncodeToString(cert.Raw), nil
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				return hex.EncodeToString(cert.RawSubjectPublicKeyInfo), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			h := sha256.New()
0000000000000000000000000000000000000000;;			switch selector {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				io.WriteString(h, string(cert.Raw))
0000000000000000000000000000000000000000;;				return hex.EncodeToString(h.Sum(nil)), nil
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				io.WriteString(h, string(cert.RawSubjectPublicKeyInfo))
0000000000000000000000000000000000000000;;				return hex.EncodeToString(h.Sum(nil)), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			h := sha512.New()
0000000000000000000000000000000000000000;;			switch selector {
0000000000000000000000000000000000000000;;			case 0:
0000000000000000000000000000000000000000;;				io.WriteString(h, string(cert.Raw))
0000000000000000000000000000000000000000;;				return hex.EncodeToString(h.Sum(nil)), nil
0000000000000000000000000000000000000000;;			case 1:
0000000000000000000000000000000000000000;;				io.WriteString(h, string(cert.RawSubjectPublicKeyInfo))
0000000000000000000000000000000000000000;;				return hex.EncodeToString(h.Sum(nil)), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", errors.New("dns: bad TLSA MatchingType or TLSA Selector")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign creates a TLSA record from an SSL certificate.
0000000000000000000000000000000000000000;;	func (r *TLSA) Sign(usage, selector, matchingType int, cert *x509.Certificate) (err error) {
0000000000000000000000000000000000000000;;		r.Hdr.Rrtype = TypeTLSA
0000000000000000000000000000000000000000;;		r.Usage = uint8(usage)
0000000000000000000000000000000000000000;;		r.Selector = uint8(selector)
0000000000000000000000000000000000000000;;		r.MatchingType = uint8(matchingType)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.Certificate, err = CertificateToDANE(r.Selector, r.MatchingType, cert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify verifies a TLSA record against an SSL certificate. If it is OK
0000000000000000000000000000000000000000;;	// a nil error is returned.
0000000000000000000000000000000000000000;;	func (r *TLSA) Verify(cert *x509.Certificate) error {
0000000000000000000000000000000000000000;;		c, err := CertificateToDANE(r.Selector, r.MatchingType, cert)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err // Not also ErrSig?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if r.Certificate == c {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrSig // ErrSig, really?
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TLSAName returns the ownername of a TLSA resource record as per the
0000000000000000000000000000000000000000;;	// rules specified in RFC 6698, Section 3.
0000000000000000000000000000000000000000;;	func TLSAName(name, service, network string) (string, error) {
0000000000000000000000000000000000000000;;		if !IsFqdn(name) {
0000000000000000000000000000000000000000;;			return "", ErrFqdn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, err := net.LookupPort(network, service)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "_" + strconv.Itoa(p) + "._" + network + "." + name, nil
0000000000000000000000000000000000000000;;	}
