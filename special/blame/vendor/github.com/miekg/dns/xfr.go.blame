0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/xfr.go[Godeps/_workspace/src/github.com/miekg/dns/xfr.go][vendor/github.com/miekg/dns/xfr.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Envelope is used when doing a zone transfer with a remote server.
0000000000000000000000000000000000000000;;	type Envelope struct {
0000000000000000000000000000000000000000;;		RR    []RR  // The set of RRs in the answer section of the xfr reply message.
0000000000000000000000000000000000000000;;		Error error // If something went wrong, this contains the error.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Transfer defines parameters that are used during a zone transfer.
0000000000000000000000000000000000000000;;	type Transfer struct {
0000000000000000000000000000000000000000;;		*Conn
0000000000000000000000000000000000000000;;		DialTimeout    time.Duration     // net.DialTimeout, defaults to 2 seconds
0000000000000000000000000000000000000000;;		ReadTimeout    time.Duration     // net.Conn.SetReadTimeout value for connections, defaults to 2 seconds
0000000000000000000000000000000000000000;;		WriteTimeout   time.Duration     // net.Conn.SetWriteTimeout value for connections, defaults to 2 seconds
0000000000000000000000000000000000000000;;		TsigSecret     map[string]string // Secret(s) for Tsig map[<zonename>]<base64 secret>, zonename must be fully qualified
0000000000000000000000000000000000000000;;		tsigTimersOnly bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Think we need to away to stop the transfer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// In performs an incoming transfer with the server in a.
0000000000000000000000000000000000000000;;	// If you would like to set the source IP, or some other attribute
0000000000000000000000000000000000000000;;	// of a Dialer for a Transfer, you can do so by specifying the attributes
0000000000000000000000000000000000000000;;	// in the Transfer.Conn:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	d := net.Dialer{LocalAddr: transfer_source}
0000000000000000000000000000000000000000;;	//	con, err := d.Dial("tcp", master)
0000000000000000000000000000000000000000;;	//	dnscon := &dns.Conn{Conn:con}
0000000000000000000000000000000000000000;;	//	transfer = &dns.Transfer{Conn: dnscon}
0000000000000000000000000000000000000000;;	//	channel, err := transfer.In(message, master)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	func (t *Transfer) In(q *Msg, a string) (env chan *Envelope, err error) {
0000000000000000000000000000000000000000;;		timeout := dnsTimeout
0000000000000000000000000000000000000000;;		if t.DialTimeout != 0 {
0000000000000000000000000000000000000000;;			timeout = t.DialTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if t.Conn == nil {
0000000000000000000000000000000000000000;;			t.Conn, err = DialTimeout("tcp", a, timeout)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := t.WriteMsg(q); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		env = make(chan *Envelope)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			if q.Question[0].Qtype == TypeAXFR {
0000000000000000000000000000000000000000;;				go t.inAxfr(q.Id, env)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if q.Question[0].Qtype == TypeIXFR {
0000000000000000000000000000000000000000;;				go t.inIxfr(q.Id, env)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		return env, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transfer) inAxfr(id uint16, c chan *Envelope) {
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		defer t.Close()
0000000000000000000000000000000000000000;;		defer close(c)
0000000000000000000000000000000000000000;;		timeout := dnsTimeout
0000000000000000000000000000000000000000;;		if t.ReadTimeout != 0 {
0000000000000000000000000000000000000000;;			timeout = t.ReadTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			t.Conn.SetReadDeadline(time.Now().Add(timeout))
0000000000000000000000000000000000000000;;			in, err := t.ReadMsg()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				c <- &Envelope{nil, err}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if id != in.Id {
0000000000000000000000000000000000000000;;				c <- &Envelope{in.Answer, ErrId}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				if !isSOAFirst(in) {
0000000000000000000000000000000000000000;;					c <- &Envelope{in.Answer, ErrSoa}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				first = !first
0000000000000000000000000000000000000000;;				// only one answer that is SOA, receive more
0000000000000000000000000000000000000000;;				if len(in.Answer) == 1 {
0000000000000000000000000000000000000000;;					t.tsigTimersOnly = true
0000000000000000000000000000000000000000;;					c <- &Envelope{in.Answer, nil}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !first {
0000000000000000000000000000000000000000;;				t.tsigTimersOnly = true // Subsequent envelopes use this.
0000000000000000000000000000000000000000;;				if isSOALast(in) {
0000000000000000000000000000000000000000;;					c <- &Envelope{in.Answer, nil}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c <- &Envelope{in.Answer, nil}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *Transfer) inIxfr(id uint16, c chan *Envelope) {
0000000000000000000000000000000000000000;;		serial := uint32(0) // The first serial seen is the current server serial
0000000000000000000000000000000000000000;;		first := true
0000000000000000000000000000000000000000;;		defer t.Close()
0000000000000000000000000000000000000000;;		defer close(c)
0000000000000000000000000000000000000000;;		timeout := dnsTimeout
0000000000000000000000000000000000000000;;		if t.ReadTimeout != 0 {
0000000000000000000000000000000000000000;;			timeout = t.ReadTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			t.SetReadDeadline(time.Now().Add(timeout))
0000000000000000000000000000000000000000;;			in, err := t.ReadMsg()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				c <- &Envelope{nil, err}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if id != in.Id {
0000000000000000000000000000000000000000;;				c <- &Envelope{in.Answer, ErrId}
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if first {
0000000000000000000000000000000000000000;;				// A single SOA RR signals "no changes"
0000000000000000000000000000000000000000;;				if len(in.Answer) == 1 && isSOAFirst(in) {
0000000000000000000000000000000000000000;;					c <- &Envelope{in.Answer, nil}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Check if the returned answer is ok
0000000000000000000000000000000000000000;;				if !isSOAFirst(in) {
0000000000000000000000000000000000000000;;					c <- &Envelope{in.Answer, ErrSoa}
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// This serial is important
0000000000000000000000000000000000000000;;				serial = in.Answer[0].(*SOA).Serial
0000000000000000000000000000000000000000;;				first = !first
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Now we need to check each message for SOA records, to see what we need to do
0000000000000000000000000000000000000000;;			if !first {
0000000000000000000000000000000000000000;;				t.tsigTimersOnly = true
0000000000000000000000000000000000000000;;				// If the last record in the IXFR contains the servers' SOA,  we should quit
0000000000000000000000000000000000000000;;				if v, ok := in.Answer[len(in.Answer)-1].(*SOA); ok {
0000000000000000000000000000000000000000;;					if v.Serial == serial {
0000000000000000000000000000000000000000;;						c <- &Envelope{in.Answer, nil}
0000000000000000000000000000000000000000;;						return
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				c <- &Envelope{in.Answer, nil}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Out performs an outgoing transfer with the client connecting in w.
0000000000000000000000000000000000000000;;	// Basic use pattern:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	ch := make(chan *dns.Envelope)
0000000000000000000000000000000000000000;;	//	tr := new(dns.Transfer)
0000000000000000000000000000000000000000;;	//	go tr.Out(w, r, ch)
0000000000000000000000000000000000000000;;	//	ch <- &dns.Envelope{RR: []dns.RR{soa, rr1, rr2, rr3, soa}}
0000000000000000000000000000000000000000;;	//	close(ch)
0000000000000000000000000000000000000000;;	//	w.Hijack()
0000000000000000000000000000000000000000;;	//	// w.Close() // Client closes connection
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The server is responsible for sending the correct sequence of RRs through the
0000000000000000000000000000000000000000;;	// channel ch.
0000000000000000000000000000000000000000;;	func (t *Transfer) Out(w ResponseWriter, q *Msg, ch chan *Envelope) error {
0000000000000000000000000000000000000000;;		for x := range ch {
0000000000000000000000000000000000000000;;			r := new(Msg)
0000000000000000000000000000000000000000;;			// Compress?
0000000000000000000000000000000000000000;;			r.SetReply(q)
0000000000000000000000000000000000000000;;			r.Authoritative = true
0000000000000000000000000000000000000000;;			// assume it fits TODO(miek): fix
0000000000000000000000000000000000000000;;			r.Answer = append(r.Answer, x.RR...)
0000000000000000000000000000000000000000;;			if err := w.WriteMsg(r); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.TsigTimersOnly(true)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadMsg reads a message from the transfer connection t.
0000000000000000000000000000000000000000;;	func (t *Transfer) ReadMsg() (*Msg, error) {
0000000000000000000000000000000000000000;;		m := new(Msg)
0000000000000000000000000000000000000000;;		p := make([]byte, MaxMsgSize)
0000000000000000000000000000000000000000;;		n, err := t.Read(p)
0000000000000000000000000000000000000000;;		if err != nil && n == 0 {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p = p[:n]
0000000000000000000000000000000000000000;;		if err := m.Unpack(p); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ts := m.IsTsig(); ts != nil && t.TsigSecret != nil {
0000000000000000000000000000000000000000;;			if _, ok := t.TsigSecret[ts.Hdr.Name]; !ok {
0000000000000000000000000000000000000000;;				return m, ErrSecret
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Need to work on the original message p, as that was used to calculate the tsig.
0000000000000000000000000000000000000000;;			err = TsigVerify(p, t.TsigSecret[ts.Hdr.Name], t.tsigRequestMAC, t.tsigTimersOnly)
0000000000000000000000000000000000000000;;			t.tsigRequestMAC = ts.MAC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return m, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteMsg writes a message through the transfer connection t.
0000000000000000000000000000000000000000;;	func (t *Transfer) WriteMsg(m *Msg) (err error) {
0000000000000000000000000000000000000000;;		var out []byte
0000000000000000000000000000000000000000;;		if ts := m.IsTsig(); ts != nil && t.TsigSecret != nil {
0000000000000000000000000000000000000000;;			if _, ok := t.TsigSecret[ts.Hdr.Name]; !ok {
0000000000000000000000000000000000000000;;				return ErrSecret
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out, t.tsigRequestMAC, err = TsigGenerate(m, t.TsigSecret[ts.Hdr.Name], t.tsigRequestMAC, t.tsigTimersOnly)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out, err = m.Pack()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, err = t.Write(out); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSOAFirst(in *Msg) bool {
0000000000000000000000000000000000000000;;		if len(in.Answer) > 0 {
0000000000000000000000000000000000000000;;			return in.Answer[0].Header().Rrtype == TypeSOA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSOALast(in *Msg) bool {
0000000000000000000000000000000000000000;;		if len(in.Answer) > 0 {
0000000000000000000000000000000000000000;;			return in.Answer[len(in.Answer)-1].Header().Rrtype == TypeSOA
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
