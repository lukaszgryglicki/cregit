0000000000000000000000000000000000000000;;	// DNS server implementation.
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/server.go[Godeps/_workspace/src/github.com/miekg/dns/server.go][vendor/github.com/miekg/dns/server.go];	
0000000000000000000000000000000000000000;;	package dns
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto/tls"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Maximum number of TCP queries before we close the socket.
0000000000000000000000000000000000000000;;	const maxTCPQueries = 128
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handler is implemented by any value that implements ServeDNS.
0000000000000000000000000000000000000000;;	type Handler interface {
0000000000000000000000000000000000000000;;		ServeDNS(w ResponseWriter, r *Msg)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ResponseWriter interface is used by an DNS handler to
0000000000000000000000000000000000000000;;	// construct an DNS response.
0000000000000000000000000000000000000000;;	type ResponseWriter interface {
0000000000000000000000000000000000000000;;		// LocalAddr returns the net.Addr of the server
0000000000000000000000000000000000000000;;		LocalAddr() net.Addr
0000000000000000000000000000000000000000;;		// RemoteAddr returns the net.Addr of the client that sent the current request.
0000000000000000000000000000000000000000;;		RemoteAddr() net.Addr
0000000000000000000000000000000000000000;;		// WriteMsg writes a reply back to the client.
0000000000000000000000000000000000000000;;		WriteMsg(*Msg) error
0000000000000000000000000000000000000000;;		// Write writes a raw buffer back to the client.
0000000000000000000000000000000000000000;;		Write([]byte) (int, error)
0000000000000000000000000000000000000000;;		// Close closes the connection.
0000000000000000000000000000000000000000;;		Close() error
0000000000000000000000000000000000000000;;		// TsigStatus returns the status of the Tsig.
0000000000000000000000000000000000000000;;		TsigStatus() error
0000000000000000000000000000000000000000;;		// TsigTimersOnly sets the tsig timers only boolean.
0000000000000000000000000000000000000000;;		TsigTimersOnly(bool)
0000000000000000000000000000000000000000;;		// Hijack lets the caller take over the connection.
0000000000000000000000000000000000000000;;		// After a call to Hijack(), the DNS package will not do anything with the connection.
0000000000000000000000000000000000000000;;		Hijack()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type response struct {
0000000000000000000000000000000000000000;;		hijacked       bool // connection has been hijacked by handler
0000000000000000000000000000000000000000;;		tsigStatus     error
0000000000000000000000000000000000000000;;		tsigTimersOnly bool
0000000000000000000000000000000000000000;;		tsigRequestMAC string
0000000000000000000000000000000000000000;;		tsigSecret     map[string]string // the tsig secrets
0000000000000000000000000000000000000000;;		udp            *net.UDPConn      // i/o connection if UDP was used
0000000000000000000000000000000000000000;;		tcp            net.Conn          // i/o connection if TCP was used
0000000000000000000000000000000000000000;;		udpSession     *SessionUDP       // oob data to get egress interface right
0000000000000000000000000000000000000000;;		remoteAddr     net.Addr          // address of the client
0000000000000000000000000000000000000000;;		writer         Writer            // writer to output the raw DNS bits
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeMux is an DNS request multiplexer. It matches the
0000000000000000000000000000000000000000;;	// zone name of each incoming request against a list of
0000000000000000000000000000000000000000;;	// registered patterns add calls the handler for the pattern
0000000000000000000000000000000000000000;;	// that most closely matches the zone name. ServeMux is DNSSEC aware, meaning
0000000000000000000000000000000000000000;;	// that queries for the DS record are redirected to the parent zone (if that
0000000000000000000000000000000000000000;;	// is also registered), otherwise the child gets the query.
0000000000000000000000000000000000000000;;	// ServeMux is also safe for concurrent access from multiple goroutines.
0000000000000000000000000000000000000000;;	type ServeMux struct {
0000000000000000000000000000000000000000;;		z map[string]Handler
0000000000000000000000000000000000000000;;		m *sync.RWMutex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServeMux allocates and returns a new ServeMux.
0000000000000000000000000000000000000000;;	func NewServeMux() *ServeMux { return &ServeMux{z: make(map[string]Handler), m: new(sync.RWMutex)} }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultServeMux is the default ServeMux used by Serve.
0000000000000000000000000000000000000000;;	var DefaultServeMux = NewServeMux()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The HandlerFunc type is an adapter to allow the use of
0000000000000000000000000000000000000000;;	// ordinary functions as DNS handlers.  If f is a function
0000000000000000000000000000000000000000;;	// with the appropriate signature, HandlerFunc(f) is a
0000000000000000000000000000000000000000;;	// Handler object that calls f.
0000000000000000000000000000000000000000;;	type HandlerFunc func(ResponseWriter, *Msg)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeDNS calls f(w, r).
0000000000000000000000000000000000000000;;	func (f HandlerFunc) ServeDNS(w ResponseWriter, r *Msg) {
0000000000000000000000000000000000000000;;		f(w, r)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleFailed returns a HandlerFunc that returns SERVFAIL for every request it gets.
0000000000000000000000000000000000000000;;	func HandleFailed(w ResponseWriter, r *Msg) {
0000000000000000000000000000000000000000;;		m := new(Msg)
0000000000000000000000000000000000000000;;		m.SetRcode(r, RcodeServerFailure)
0000000000000000000000000000000000000000;;		// does not matter if this write fails
0000000000000000000000000000000000000000;;		w.WriteMsg(m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func failedHandler() Handler { return HandlerFunc(HandleFailed) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenAndServe Starts a server on address and network specified Invoke handler
0000000000000000000000000000000000000000;;	// for incoming queries.
0000000000000000000000000000000000000000;;	func ListenAndServe(addr string, network string, handler Handler) error {
0000000000000000000000000000000000000000;;		server := &Server{Addr: addr, Net: network, Handler: handler}
0000000000000000000000000000000000000000;;		return server.ListenAndServe()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenAndServeTLS acts like http.ListenAndServeTLS, more information in
0000000000000000000000000000000000000000;;	// http://golang.org/pkg/net/http/#ListenAndServeTLS
0000000000000000000000000000000000000000;;	func ListenAndServeTLS(addr, certFile, keyFile string, handler Handler) error {
0000000000000000000000000000000000000000;;		cert, err := tls.LoadX509KeyPair(certFile, keyFile)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := tls.Config{
0000000000000000000000000000000000000000;;			Certificates: []tls.Certificate{cert},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := &Server{
0000000000000000000000000000000000000000;;			Addr:      addr,
0000000000000000000000000000000000000000;;			Net:       "tcp-tls",
0000000000000000000000000000000000000000;;			TLSConfig: &config,
0000000000000000000000000000000000000000;;			Handler:   handler,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return server.ListenAndServe()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActivateAndServe activates a server with a listener from systemd,
0000000000000000000000000000000000000000;;	// l and p should not both be non-nil.
0000000000000000000000000000000000000000;;	// If both l and p are not nil only p will be used.
0000000000000000000000000000000000000000;;	// Invoke handler for incoming queries.
0000000000000000000000000000000000000000;;	func ActivateAndServe(l net.Listener, p net.PacketConn, handler Handler) error {
0000000000000000000000000000000000000000;;		server := &Server{Listener: l, PacketConn: p, Handler: handler}
0000000000000000000000000000000000000000;;		return server.ActivateAndServe()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (mux *ServeMux) match(q string, t uint16) Handler {
0000000000000000000000000000000000000000;;		mux.m.RLock()
0000000000000000000000000000000000000000;;		defer mux.m.RUnlock()
0000000000000000000000000000000000000000;;		var handler Handler
0000000000000000000000000000000000000000;;		b := make([]byte, len(q)) // worst case, one label of length q
0000000000000000000000000000000000000000;;		off := 0
0000000000000000000000000000000000000000;;		end := false
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			l := len(q[off:])
0000000000000000000000000000000000000000;;			for i := 0; i < l; i++ {
0000000000000000000000000000000000000000;;				b[i] = q[off+i]
0000000000000000000000000000000000000000;;				if b[i] >= 'A' && b[i] <= 'Z' {
0000000000000000000000000000000000000000;;					b[i] |= ('a' - 'A')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if h, ok := mux.z[string(b[:l])]; ok { // 'causes garbage, might want to change the map key
0000000000000000000000000000000000000000;;				if t != TypeDS {
0000000000000000000000000000000000000000;;					return h
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				// Continue for DS to see if we have a parent too, if so delegeate to the parent
0000000000000000000000000000000000000000;;				handler = h
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			off, end = NextLabel(q, off)
0000000000000000000000000000000000000000;;			if end {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Wildcard match, if we have found nothing try the root zone as a last resort.
0000000000000000000000000000000000000000;;		if h, ok := mux.z["."]; ok {
0000000000000000000000000000000000000000;;			return h
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return handler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle adds a handler to the ServeMux for pattern.
0000000000000000000000000000000000000000;;	func (mux *ServeMux) Handle(pattern string, handler Handler) {
0000000000000000000000000000000000000000;;		if pattern == "" {
0000000000000000000000000000000000000000;;			panic("dns: invalid pattern " + pattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mux.m.Lock()
0000000000000000000000000000000000000000;;		mux.z[Fqdn(pattern)] = handler
0000000000000000000000000000000000000000;;		mux.m.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleFunc adds a handler function to the ServeMux for pattern.
0000000000000000000000000000000000000000;;	func (mux *ServeMux) HandleFunc(pattern string, handler func(ResponseWriter, *Msg)) {
0000000000000000000000000000000000000000;;		mux.Handle(pattern, HandlerFunc(handler))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleRemove deregistrars the handler specific for pattern from the ServeMux.
0000000000000000000000000000000000000000;;	func (mux *ServeMux) HandleRemove(pattern string) {
0000000000000000000000000000000000000000;;		if pattern == "" {
0000000000000000000000000000000000000000;;			panic("dns: invalid pattern " + pattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mux.m.Lock()
0000000000000000000000000000000000000000;;		delete(mux.z, Fqdn(pattern))
0000000000000000000000000000000000000000;;		mux.m.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeDNS dispatches the request to the handler whose
0000000000000000000000000000000000000000;;	// pattern most closely matches the request message. If DefaultServeMux
0000000000000000000000000000000000000000;;	// is used the correct thing for DS queries is done: a possible parent
0000000000000000000000000000000000000000;;	// is sought.
0000000000000000000000000000000000000000;;	// If no handler is found a standard SERVFAIL message is returned
0000000000000000000000000000000000000000;;	// If the request message does not have exactly one question in the
0000000000000000000000000000000000000000;;	// question section a SERVFAIL is returned, unlesss Unsafe is true.
0000000000000000000000000000000000000000;;	func (mux *ServeMux) ServeDNS(w ResponseWriter, request *Msg) {
0000000000000000000000000000000000000000;;		var h Handler
0000000000000000000000000000000000000000;;		if len(request.Question) < 1 { // allow more than one question
0000000000000000000000000000000000000000;;			h = failedHandler()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if h = mux.match(request.Question[0].Name, request.Question[0].Qtype); h == nil {
0000000000000000000000000000000000000000;;				h = failedHandler()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.ServeDNS(w, request)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Handle registers the handler with the given pattern
0000000000000000000000000000000000000000;;	// in the DefaultServeMux. The documentation for
0000000000000000000000000000000000000000;;	// ServeMux explains how patterns are matched.
0000000000000000000000000000000000000000;;	func Handle(pattern string, handler Handler) { DefaultServeMux.Handle(pattern, handler) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleRemove deregisters the handle with the given pattern
0000000000000000000000000000000000000000;;	// in the DefaultServeMux.
0000000000000000000000000000000000000000;;	func HandleRemove(pattern string) { DefaultServeMux.HandleRemove(pattern) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HandleFunc registers the handler function with the given pattern
0000000000000000000000000000000000000000;;	// in the DefaultServeMux.
0000000000000000000000000000000000000000;;	func HandleFunc(pattern string, handler func(ResponseWriter, *Msg)) {
0000000000000000000000000000000000000000;;		DefaultServeMux.HandleFunc(pattern, handler)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Writer writes raw DNS messages; each call to Write should send an entire message.
0000000000000000000000000000000000000000;;	type Writer interface {
0000000000000000000000000000000000000000;;		io.Writer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reader reads raw DNS messages; each call to ReadTCP or ReadUDP should return an entire message.
0000000000000000000000000000000000000000;;	type Reader interface {
0000000000000000000000000000000000000000;;		// ReadTCP reads a raw message from a TCP connection. Implementations may alter
0000000000000000000000000000000000000000;;		// connection properties, for example the read-deadline.
0000000000000000000000000000000000000000;;		ReadTCP(conn net.Conn, timeout time.Duration) ([]byte, error)
0000000000000000000000000000000000000000;;		// ReadUDP reads a raw message from a UDP connection. Implementations may alter
0000000000000000000000000000000000000000;;		// connection properties, for example the read-deadline.
0000000000000000000000000000000000000000;;		ReadUDP(conn *net.UDPConn, timeout time.Duration) ([]byte, *SessionUDP, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// defaultReader is an adapter for the Server struct that implements the Reader interface
0000000000000000000000000000000000000000;;	// using the readTCP and readUDP func of the embedded Server.
0000000000000000000000000000000000000000;;	type defaultReader struct {
0000000000000000000000000000000000000000;;		*Server
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dr *defaultReader) ReadTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {
0000000000000000000000000000000000000000;;		return dr.readTCP(conn, timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (dr *defaultReader) ReadUDP(conn *net.UDPConn, timeout time.Duration) ([]byte, *SessionUDP, error) {
0000000000000000000000000000000000000000;;		return dr.readUDP(conn, timeout)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecorateReader is a decorator hook for extending or supplanting the functionality of a Reader.
0000000000000000000000000000000000000000;;	// Implementations should never return a nil Reader.
0000000000000000000000000000000000000000;;	type DecorateReader func(Reader) Reader
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecorateWriter is a decorator hook for extending or supplanting the functionality of a Writer.
0000000000000000000000000000000000000000;;	// Implementations should never return a nil Writer.
0000000000000000000000000000000000000000;;	type DecorateWriter func(Writer) Writer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Server defines parameters for running an DNS server.
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		// Address to listen on, ":dns" if empty.
0000000000000000000000000000000000000000;;		Addr string
0000000000000000000000000000000000000000;;		// if "tcp" or "tcp-tls" (DNS over TLS) it will invoke a TCP listener, otherwise an UDP one
0000000000000000000000000000000000000000;;		Net string
0000000000000000000000000000000000000000;;		// TCP Listener to use, this is to aid in systemd's socket activation.
0000000000000000000000000000000000000000;;		Listener net.Listener
0000000000000000000000000000000000000000;;		// TLS connection configuration
0000000000000000000000000000000000000000;;		TLSConfig *tls.Config
0000000000000000000000000000000000000000;;		// UDP "Listener" to use, this is to aid in systemd's socket activation.
0000000000000000000000000000000000000000;;		PacketConn net.PacketConn
0000000000000000000000000000000000000000;;		// Handler to invoke, dns.DefaultServeMux if nil.
0000000000000000000000000000000000000000;;		Handler Handler
0000000000000000000000000000000000000000;;		// Default buffer size to use to read incoming UDP messages. If not set
0000000000000000000000000000000000000000;;		// it defaults to MinMsgSize (512 B).
0000000000000000000000000000000000000000;;		UDPSize int
0000000000000000000000000000000000000000;;		// The net.Conn.SetReadTimeout value for new connections, defaults to 2 * time.Second.
0000000000000000000000000000000000000000;;		ReadTimeout time.Duration
0000000000000000000000000000000000000000;;		// The net.Conn.SetWriteTimeout value for new connections, defaults to 2 * time.Second.
0000000000000000000000000000000000000000;;		WriteTimeout time.Duration
0000000000000000000000000000000000000000;;		// TCP idle timeout for multiple queries, if nil, defaults to 8 * time.Second (RFC 5966).
0000000000000000000000000000000000000000;;		IdleTimeout func() time.Duration
0000000000000000000000000000000000000000;;		// Secret(s) for Tsig map[<zonename>]<base64 secret>.
0000000000000000000000000000000000000000;;		TsigSecret map[string]string
0000000000000000000000000000000000000000;;		// Unsafe instructs the server to disregard any sanity checks and directly hand the message to
0000000000000000000000000000000000000000;;		// the handler. It will specifically not check if the query has the QR bit not set.
0000000000000000000000000000000000000000;;		Unsafe bool
0000000000000000000000000000000000000000;;		// If NotifyStartedFunc is set it is called once the server has started listening.
0000000000000000000000000000000000000000;;		NotifyStartedFunc func()
0000000000000000000000000000000000000000;;		// DecorateReader is optional, allows customization of the process that reads raw DNS messages.
0000000000000000000000000000000000000000;;		DecorateReader DecorateReader
0000000000000000000000000000000000000000;;		// DecorateWriter is optional, allows customization of the process that writes raw DNS messages.
0000000000000000000000000000000000000000;;		DecorateWriter DecorateWriter
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Graceful shutdown handling
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inFlight sync.WaitGroup
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		lock    sync.RWMutex
0000000000000000000000000000000000000000;;		started bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListenAndServe starts a nameserver on the configured address in *Server.
0000000000000000000000000000000000000000;;	func (srv *Server) ListenAndServe() error {
0000000000000000000000000000000000000000;;		srv.lock.Lock()
0000000000000000000000000000000000000000;;		defer srv.lock.Unlock()
0000000000000000000000000000000000000000;;		if srv.started {
0000000000000000000000000000000000000000;;			return &Error{err: "server already started"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		addr := srv.Addr
0000000000000000000000000000000000000000;;		if addr == "" {
0000000000000000000000000000000000000000;;			addr = ":domain"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if srv.UDPSize == 0 {
0000000000000000000000000000000000000000;;			srv.UDPSize = MinMsgSize
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch srv.Net {
0000000000000000000000000000000000000000;;		case "tcp", "tcp4", "tcp6":
0000000000000000000000000000000000000000;;			a, err := net.ResolveTCPAddr(srv.Net, addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l, err := net.ListenTCP(srv.Net, a)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv.Listener = l
0000000000000000000000000000000000000000;;			srv.started = true
0000000000000000000000000000000000000000;;			srv.lock.Unlock()
0000000000000000000000000000000000000000;;			err = srv.serveTCP(l)
0000000000000000000000000000000000000000;;			srv.lock.Lock() // to satisfy the defer at the top
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		case "tcp-tls", "tcp4-tls", "tcp6-tls":
0000000000000000000000000000000000000000;;			network := "tcp"
0000000000000000000000000000000000000000;;			if srv.Net == "tcp4-tls" {
0000000000000000000000000000000000000000;;				network = "tcp4"
0000000000000000000000000000000000000000;;			} else if srv.Net == "tcp6" {
0000000000000000000000000000000000000000;;				network = "tcp6"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			l, err := tls.Listen(network, addr, srv.TLSConfig)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv.Listener = l
0000000000000000000000000000000000000000;;			srv.started = true
0000000000000000000000000000000000000000;;			srv.lock.Unlock()
0000000000000000000000000000000000000000;;			err = srv.serveTCP(l)
0000000000000000000000000000000000000000;;			srv.lock.Lock() // to satisfy the defer at the top
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		case "udp", "udp4", "udp6":
0000000000000000000000000000000000000000;;			a, err := net.ResolveUDPAddr(srv.Net, addr)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l, err := net.ListenUDP(srv.Net, a)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if e := setUDPSocketOptions(l); e != nil {
0000000000000000000000000000000000000000;;				return e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv.PacketConn = l
0000000000000000000000000000000000000000;;			srv.started = true
0000000000000000000000000000000000000000;;			srv.lock.Unlock()
0000000000000000000000000000000000000000;;			err = srv.serveUDP(l)
0000000000000000000000000000000000000000;;			srv.lock.Lock() // to satisfy the defer at the top
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Error{err: "bad network"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActivateAndServe starts a nameserver with the PacketConn or Listener
0000000000000000000000000000000000000000;;	// configured in *Server. Its main use is to start a server from systemd.
0000000000000000000000000000000000000000;;	func (srv *Server) ActivateAndServe() error {
0000000000000000000000000000000000000000;;		srv.lock.Lock()
0000000000000000000000000000000000000000;;		defer srv.lock.Unlock()
0000000000000000000000000000000000000000;;		if srv.started {
0000000000000000000000000000000000000000;;			return &Error{err: "server already started"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pConn := srv.PacketConn
0000000000000000000000000000000000000000;;		l := srv.Listener
0000000000000000000000000000000000000000;;		if pConn != nil {
0000000000000000000000000000000000000000;;			if srv.UDPSize == 0 {
0000000000000000000000000000000000000000;;				srv.UDPSize = MinMsgSize
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if t, ok := pConn.(*net.UDPConn); ok {
0000000000000000000000000000000000000000;;				if e := setUDPSocketOptions(t); e != nil {
0000000000000000000000000000000000000000;;					return e
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				srv.started = true
0000000000000000000000000000000000000000;;				srv.lock.Unlock()
0000000000000000000000000000000000000000;;				e := srv.serveUDP(t)
0000000000000000000000000000000000000000;;				srv.lock.Lock() // to satisfy the defer at the top
0000000000000000000000000000000000000000;;				return e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if l != nil {
0000000000000000000000000000000000000000;;			srv.started = true
0000000000000000000000000000000000000000;;			srv.lock.Unlock()
0000000000000000000000000000000000000000;;			e := srv.serveTCP(l)
0000000000000000000000000000000000000000;;			srv.lock.Lock() // to satisfy the defer at the top
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Error{err: "bad listeners"}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Shutdown gracefully shuts down a server. After a call to Shutdown, ListenAndServe and
0000000000000000000000000000000000000000;;	// ActivateAndServe will return. All in progress queries are completed before the server
0000000000000000000000000000000000000000;;	// is taken down. If the Shutdown is taking longer than the reading timeout an error
0000000000000000000000000000000000000000;;	// is returned.
0000000000000000000000000000000000000000;;	func (srv *Server) Shutdown() error {
0000000000000000000000000000000000000000;;		srv.lock.Lock()
0000000000000000000000000000000000000000;;		if !srv.started {
0000000000000000000000000000000000000000;;			srv.lock.Unlock()
0000000000000000000000000000000000000000;;			return &Error{err: "server not started"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		srv.started = false
0000000000000000000000000000000000000000;;		srv.lock.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if srv.PacketConn != nil {
0000000000000000000000000000000000000000;;			srv.PacketConn.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if srv.Listener != nil {
0000000000000000000000000000000000000000;;			srv.Listener.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fin := make(chan bool)
0000000000000000000000000000000000000000;;		go func() {
0000000000000000000000000000000000000000;;			srv.inFlight.Wait()
0000000000000000000000000000000000000000;;			fin <- true
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		select {
0000000000000000000000000000000000000000;;		case <-time.After(srv.getReadTimeout()):
0000000000000000000000000000000000000000;;			return &Error{err: "server shutdown is pending"}
0000000000000000000000000000000000000000;;		case <-fin:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getReadTimeout is a helper func to use system timeout if server did not intend to change it.
0000000000000000000000000000000000000000;;	func (srv *Server) getReadTimeout() time.Duration {
0000000000000000000000000000000000000000;;		rtimeout := dnsTimeout
0000000000000000000000000000000000000000;;		if srv.ReadTimeout != 0 {
0000000000000000000000000000000000000000;;			rtimeout = srv.ReadTimeout
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rtimeout
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveTCP starts a TCP listener for the server.
0000000000000000000000000000000000000000;;	// Each request is handled in a separate goroutine.
0000000000000000000000000000000000000000;;	func (srv *Server) serveTCP(l net.Listener) error {
0000000000000000000000000000000000000000;;		defer l.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if srv.NotifyStartedFunc != nil {
0000000000000000000000000000000000000000;;			srv.NotifyStartedFunc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := Reader(&defaultReader{srv})
0000000000000000000000000000000000000000;;		if srv.DecorateReader != nil {
0000000000000000000000000000000000000000;;			reader = srv.DecorateReader(reader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := srv.Handler
0000000000000000000000000000000000000000;;		if handler == nil {
0000000000000000000000000000000000000000;;			handler = DefaultServeMux
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rtimeout := srv.getReadTimeout()
0000000000000000000000000000000000000000;;		// deadline is not used here
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			rw, err := l.Accept()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				if neterr, ok := err.(net.Error); ok && neterr.Temporary() {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			m, err := reader.ReadTCP(rw, rtimeout)
0000000000000000000000000000000000000000;;			srv.lock.RLock()
0000000000000000000000000000000000000000;;			if !srv.started {
0000000000000000000000000000000000000000;;				srv.lock.RUnlock()
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv.lock.RUnlock()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv.inFlight.Add(1)
0000000000000000000000000000000000000000;;			go srv.serve(rw.RemoteAddr(), handler, m, nil, nil, rw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// serveUDP starts a UDP listener for the server.
0000000000000000000000000000000000000000;;	// Each request is handled in a separate goroutine.
0000000000000000000000000000000000000000;;	func (srv *Server) serveUDP(l *net.UDPConn) error {
0000000000000000000000000000000000000000;;		defer l.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if srv.NotifyStartedFunc != nil {
0000000000000000000000000000000000000000;;			srv.NotifyStartedFunc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := Reader(&defaultReader{srv})
0000000000000000000000000000000000000000;;		if srv.DecorateReader != nil {
0000000000000000000000000000000000000000;;			reader = srv.DecorateReader(reader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handler := srv.Handler
0000000000000000000000000000000000000000;;		if handler == nil {
0000000000000000000000000000000000000000;;			handler = DefaultServeMux
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rtimeout := srv.getReadTimeout()
0000000000000000000000000000000000000000;;		// deadline is not used here
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			m, s, err := reader.ReadUDP(l, rtimeout)
0000000000000000000000000000000000000000;;			srv.lock.RLock()
0000000000000000000000000000000000000000;;			if !srv.started {
0000000000000000000000000000000000000000;;				srv.lock.RUnlock()
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv.lock.RUnlock()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			srv.inFlight.Add(1)
0000000000000000000000000000000000000000;;			go srv.serve(s.RemoteAddr(), handler, m, l, s, nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serve a new connection.
0000000000000000000000000000000000000000;;	func (srv *Server) serve(a net.Addr, h Handler, m []byte, u *net.UDPConn, s *SessionUDP, t net.Conn) {
0000000000000000000000000000000000000000;;		defer srv.inFlight.Done()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w := &response{tsigSecret: srv.TsigSecret, udp: u, tcp: t, remoteAddr: a, udpSession: s}
0000000000000000000000000000000000000000;;		if srv.DecorateWriter != nil {
0000000000000000000000000000000000000000;;			w.writer = srv.DecorateWriter(w)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			w.writer = w
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		q := 0 // counter for the amount of TCP queries we get
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reader := Reader(&defaultReader{srv})
0000000000000000000000000000000000000000;;		if srv.DecorateReader != nil {
0000000000000000000000000000000000000000;;			reader = srv.DecorateReader(reader)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	Redo:
0000000000000000000000000000000000000000;;		req := new(Msg)
0000000000000000000000000000000000000000;;		err := req.Unpack(m)
0000000000000000000000000000000000000000;;		if err != nil { // Send a FormatError back
0000000000000000000000000000000000000000;;			x := new(Msg)
0000000000000000000000000000000000000000;;			x.SetRcodeFormatError(req)
0000000000000000000000000000000000000000;;			w.WriteMsg(x)
0000000000000000000000000000000000000000;;			goto Exit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !srv.Unsafe && req.Response {
0000000000000000000000000000000000000000;;			goto Exit
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		w.tsigStatus = nil
0000000000000000000000000000000000000000;;		if w.tsigSecret != nil {
0000000000000000000000000000000000000000;;			if t := req.IsTsig(); t != nil {
0000000000000000000000000000000000000000;;				secret := t.Hdr.Name
0000000000000000000000000000000000000000;;				if _, ok := w.tsigSecret[secret]; !ok {
0000000000000000000000000000000000000000;;					w.tsigStatus = ErrKeyAlg
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w.tsigStatus = TsigVerify(m, w.tsigSecret[secret], "", false)
0000000000000000000000000000000000000000;;				w.tsigTimersOnly = false
0000000000000000000000000000000000000000;;				w.tsigRequestMAC = req.Extra[len(req.Extra)-1].(*TSIG).MAC
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.ServeDNS(w, req) // Writes back to the client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Exit:
0000000000000000000000000000000000000000;;		if w.tcp == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO(miek): make this number configurable?
0000000000000000000000000000000000000000;;		if q > maxTCPQueries { // close socket after this many queries
0000000000000000000000000000000000000000;;			w.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if w.hijacked {
0000000000000000000000000000000000000000;;			return // client calls Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u != nil { // UDP, "close" and return
0000000000000000000000000000000000000000;;			w.Close()
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idleTimeout := tcpIdleTimeout
0000000000000000000000000000000000000000;;		if srv.IdleTimeout != nil {
0000000000000000000000000000000000000000;;			idleTimeout = srv.IdleTimeout()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m, err = reader.ReadTCP(w.tcp, idleTimeout)
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			q++
0000000000000000000000000000000000000000;;			goto Redo
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		w.Close()
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (srv *Server) readTCP(conn net.Conn, timeout time.Duration) ([]byte, error) {
0000000000000000000000000000000000000000;;		conn.SetReadDeadline(time.Now().Add(timeout))
0000000000000000000000000000000000000000;;		l := make([]byte, 2)
0000000000000000000000000000000000000000;;		n, err := conn.Read(l)
0000000000000000000000000000000000000000;;		if err != nil || n != 2 {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, ErrShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		length := binary.BigEndian.Uint16(l)
0000000000000000000000000000000000000000;;		if length == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m := make([]byte, int(length))
0000000000000000000000000000000000000000;;		n, err = conn.Read(m[:int(length)])
0000000000000000000000000000000000000000;;		if err != nil || n == 0 {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, ErrShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := n
0000000000000000000000000000000000000000;;		for i < int(length) {
0000000000000000000000000000000000000000;;			j, err := conn.Read(m[i:int(length)])
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += j
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		n = i
0000000000000000000000000000000000000000;;		m = m[:n]
0000000000000000000000000000000000000000;;		return m, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (srv *Server) readUDP(conn *net.UDPConn, timeout time.Duration) ([]byte, *SessionUDP, error) {
0000000000000000000000000000000000000000;;		conn.SetReadDeadline(time.Now().Add(timeout))
0000000000000000000000000000000000000000;;		m := make([]byte, srv.UDPSize)
0000000000000000000000000000000000000000;;		n, s, err := ReadFromSessionUDP(conn, m)
0000000000000000000000000000000000000000;;		if err != nil || n == 0 {
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, nil, ErrShortRead
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m = m[:n]
0000000000000000000000000000000000000000;;		return m, s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteMsg implements the ResponseWriter.WriteMsg method.
0000000000000000000000000000000000000000;;	func (w *response) WriteMsg(m *Msg) (err error) {
0000000000000000000000000000000000000000;;		var data []byte
0000000000000000000000000000000000000000;;		if w.tsigSecret != nil { // if no secrets, dont check for the tsig (which is a longer check)
0000000000000000000000000000000000000000;;			if t := m.IsTsig(); t != nil {
0000000000000000000000000000000000000000;;				data, w.tsigRequestMAC, err = TsigGenerate(m, w.tsigSecret[t.Hdr.Name], w.tsigRequestMAC, w.tsigTimersOnly)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				_, err = w.writer.Write(data)
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		data, err = m.Pack()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, err = w.writer.Write(data)
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write implements the ResponseWriter.Write method.
0000000000000000000000000000000000000000;;	func (w *response) Write(m []byte) (int, error) {
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case w.udp != nil:
0000000000000000000000000000000000000000;;			n, err := WriteToSessionUDP(w.udp, m, w.udpSession)
0000000000000000000000000000000000000000;;			return n, err
0000000000000000000000000000000000000000;;		case w.tcp != nil:
0000000000000000000000000000000000000000;;			lm := len(m)
0000000000000000000000000000000000000000;;			if lm < 2 {
0000000000000000000000000000000000000000;;				return 0, io.ErrShortBuffer
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if lm > MaxMsgSize {
0000000000000000000000000000000000000000;;				return 0, &Error{err: "message too large"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			l := make([]byte, 2, 2+lm)
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint16(l, uint16(lm))
0000000000000000000000000000000000000000;;			m = append(l, m...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n, err := io.Copy(w.tcp, bytes.NewReader(m))
0000000000000000000000000000000000000000;;			return int(n), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("not reached")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LocalAddr implements the ResponseWriter.LocalAddr method.
0000000000000000000000000000000000000000;;	func (w *response) LocalAddr() net.Addr {
0000000000000000000000000000000000000000;;		if w.tcp != nil {
0000000000000000000000000000000000000000;;			return w.tcp.LocalAddr()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return w.udp.LocalAddr()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteAddr implements the ResponseWriter.RemoteAddr method.
0000000000000000000000000000000000000000;;	func (w *response) RemoteAddr() net.Addr { return w.remoteAddr }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TsigStatus implements the ResponseWriter.TsigStatus method.
0000000000000000000000000000000000000000;;	func (w *response) TsigStatus() error { return w.tsigStatus }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TsigTimersOnly implements the ResponseWriter.TsigTimersOnly method.
0000000000000000000000000000000000000000;;	func (w *response) TsigTimersOnly(b bool) { w.tsigTimersOnly = b }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Hijack implements the ResponseWriter.Hijack method.
0000000000000000000000000000000000000000;;	func (w *response) Hijack() { w.hijacked = true }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close implements the ResponseWriter.Close method
0000000000000000000000000000000000000000;;	func (w *response) Close() error {
0000000000000000000000000000000000000000;;		// Can't close the udp conn, as that is actually the listener.
0000000000000000000000000000000000000000;;		if w.tcp != nil {
0000000000000000000000000000000000000000;;			e := w.tcp.Close()
0000000000000000000000000000000000000000;;			w.tcp = nil
0000000000000000000000000000000000000000;;			return e
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
