0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/nsecx.go[Godeps/_workspace/src/github.com/miekg/dns/nsecx.go][vendor/github.com/miekg/dns/nsecx.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type saltWireFmt struct {
0000000000000000000000000000000000000000;;		Salt string `dns:"size-hex"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HashName hashes a string (label) according to RFC 5155. It returns the hashed string in uppercase.
0000000000000000000000000000000000000000;;	func HashName(label string, ha uint8, iter uint16, salt string) string {
0000000000000000000000000000000000000000;;		saltwire := new(saltWireFmt)
0000000000000000000000000000000000000000;;		saltwire.Salt = salt
0000000000000000000000000000000000000000;;		wire := make([]byte, DefaultMsgSize)
0000000000000000000000000000000000000000;;		n, err := packSaltWire(saltwire, wire)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wire = wire[:n]
0000000000000000000000000000000000000000;;		name := make([]byte, 255)
0000000000000000000000000000000000000000;;		off, err := PackDomainName(strings.ToLower(label), name, 0, nil, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		name = name[:off]
0000000000000000000000000000000000000000;;		var s hash.Hash
0000000000000000000000000000000000000000;;		switch ha {
0000000000000000000000000000000000000000;;		case SHA1:
0000000000000000000000000000000000000000;;			s = sha1.New()
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// k = 0
0000000000000000000000000000000000000000;;		name = append(name, wire...)
0000000000000000000000000000000000000000;;		io.WriteString(s, string(name))
0000000000000000000000000000000000000000;;		nsec3 := s.Sum(nil)
0000000000000000000000000000000000000000;;		// k > 0
0000000000000000000000000000000000000000;;		for k := uint16(0); k < iter; k++ {
0000000000000000000000000000000000000000;;			s.Reset()
0000000000000000000000000000000000000000;;			nsec3 = append(nsec3, wire...)
0000000000000000000000000000000000000000;;			io.WriteString(s, string(nsec3))
0000000000000000000000000000000000000000;;			nsec3 = s.Sum(nil)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return toBase32(nsec3)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Denialer is an interface that should be implemented by types that are used to denial
0000000000000000000000000000000000000000;;	// answers in DNSSEC.
0000000000000000000000000000000000000000;;	type Denialer interface {
0000000000000000000000000000000000000000;;		// Cover will check if the (unhashed) name is being covered by this NSEC or NSEC3.
0000000000000000000000000000000000000000;;		Cover(name string) bool
0000000000000000000000000000000000000000;;		// Match will check if the ownername matches the (unhashed) name for this NSEC3 or NSEC3.
0000000000000000000000000000000000000000;;		Match(name string) bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cover implements the Denialer interface.
0000000000000000000000000000000000000000;;	func (rr *NSEC) Cover(name string) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match implements the Denialer interface.
0000000000000000000000000000000000000000;;	func (rr *NSEC) Match(name string) bool {
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cover implements the Denialer interface.
0000000000000000000000000000000000000000;;	func (rr *NSEC3) Cover(name string) bool {
0000000000000000000000000000000000000000;;		// FIXME(miek): check if the zones match
0000000000000000000000000000000000000000;;		// FIXME(miek): check if we're not dealing with parent nsec3
0000000000000000000000000000000000000000;;		hname := HashName(name, rr.Hash, rr.Iterations, rr.Salt)
0000000000000000000000000000000000000000;;		labels := Split(rr.Hdr.Name)
0000000000000000000000000000000000000000;;		if len(labels) < 2 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := strings.ToUpper(rr.Hdr.Name[labels[0] : labels[1]-1]) // -1 to remove the dot
0000000000000000000000000000000000000000;;		if hash == rr.NextDomain {
0000000000000000000000000000000000000000;;			return false // empty interval
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hash > rr.NextDomain { // last name, points to apex
0000000000000000000000000000000000000000;;			// hname > hash
0000000000000000000000000000000000000000;;			// hname > rr.NextDomain
0000000000000000000000000000000000000000;;			// TODO(miek)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hname <= hash {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if hname >= rr.NextDomain {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Match implements the Denialer interface.
0000000000000000000000000000000000000000;;	func (rr *NSEC3) Match(name string) bool {
0000000000000000000000000000000000000000;;		// FIXME(miek): Check if we are in the same zone
0000000000000000000000000000000000000000;;		hname := HashName(name, rr.Hash, rr.Iterations, rr.Salt)
0000000000000000000000000000000000000000;;		labels := Split(rr.Hdr.Name)
0000000000000000000000000000000000000000;;		if len(labels) < 2 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hash := strings.ToUpper(rr.Hdr.Name[labels[0] : labels[1]-1]) // -1 to remove the .
0000000000000000000000000000000000000000;;		if hash == hname {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packSaltWire(sw *saltWireFmt, msg []byte) (int, error) {
0000000000000000000000000000000000000000;;		off, err := packStringHex(sw.Salt, msg, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
