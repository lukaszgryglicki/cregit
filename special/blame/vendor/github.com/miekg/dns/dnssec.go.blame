0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/dnssec.go[Godeps/_workspace/src/github.com/miekg/dns/dnssec.go][vendor/github.com/miekg/dns/dnssec.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/dsa"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/elliptic"
0000000000000000000000000000000000000000;;		_ "crypto/md5"
0000000000000000000000000000000000000000;;		"crypto/rand"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		_ "crypto/sha1"
0000000000000000000000000000000000000000;;		_ "crypto/sha256"
0000000000000000000000000000000000000000;;		_ "crypto/sha512"
0000000000000000000000000000000000000000;;		"encoding/asn1"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DNSSEC encryption algorithm codes.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_ uint8 = iota
0000000000000000000000000000000000000000;;		RSAMD5
0000000000000000000000000000000000000000;;		DH
0000000000000000000000000000000000000000;;		DSA
0000000000000000000000000000000000000000;;		_ // Skip 4, RFC 6725, section 2.1
0000000000000000000000000000000000000000;;		RSASHA1
0000000000000000000000000000000000000000;;		DSANSEC3SHA1
0000000000000000000000000000000000000000;;		RSASHA1NSEC3SHA1
0000000000000000000000000000000000000000;;		RSASHA256
0000000000000000000000000000000000000000;;		_ // Skip 9, RFC 6725, section 2.1
0000000000000000000000000000000000000000;;		RSASHA512
0000000000000000000000000000000000000000;;		_ // Skip 11, RFC 6725, section 2.1
0000000000000000000000000000000000000000;;		ECCGOST
0000000000000000000000000000000000000000;;		ECDSAP256SHA256
0000000000000000000000000000000000000000;;		ECDSAP384SHA384
0000000000000000000000000000000000000000;;		INDIRECT   uint8 = 252
0000000000000000000000000000000000000000;;		PRIVATEDNS uint8 = 253 // Private (experimental keys)
0000000000000000000000000000000000000000;;		PRIVATEOID uint8 = 254
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map for algorithm names.
0000000000000000000000000000000000000000;;	var AlgorithmToString = map[uint8]string{
0000000000000000000000000000000000000000;;		RSAMD5:           "RSAMD5",
0000000000000000000000000000000000000000;;		DH:               "DH",
0000000000000000000000000000000000000000;;		DSA:              "DSA",
0000000000000000000000000000000000000000;;		RSASHA1:          "RSASHA1",
0000000000000000000000000000000000000000;;		DSANSEC3SHA1:     "DSA-NSEC3-SHA1",
0000000000000000000000000000000000000000;;		RSASHA1NSEC3SHA1: "RSASHA1-NSEC3-SHA1",
0000000000000000000000000000000000000000;;		RSASHA256:        "RSASHA256",
0000000000000000000000000000000000000000;;		RSASHA512:        "RSASHA512",
0000000000000000000000000000000000000000;;		ECCGOST:          "ECC-GOST",
0000000000000000000000000000000000000000;;		ECDSAP256SHA256:  "ECDSAP256SHA256",
0000000000000000000000000000000000000000;;		ECDSAP384SHA384:  "ECDSAP384SHA384",
0000000000000000000000000000000000000000;;		INDIRECT:         "INDIRECT",
0000000000000000000000000000000000000000;;		PRIVATEDNS:       "PRIVATEDNS",
0000000000000000000000000000000000000000;;		PRIVATEOID:       "PRIVATEOID",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map of algorithm strings.
0000000000000000000000000000000000000000;;	var StringToAlgorithm = reverseInt8(AlgorithmToString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map of algorithm crypto hashes.
0000000000000000000000000000000000000000;;	var AlgorithmToHash = map[uint8]crypto.Hash{
0000000000000000000000000000000000000000;;		RSAMD5:           crypto.MD5, // Deprecated in RFC 6725
0000000000000000000000000000000000000000;;		RSASHA1:          crypto.SHA1,
0000000000000000000000000000000000000000;;		RSASHA1NSEC3SHA1: crypto.SHA1,
0000000000000000000000000000000000000000;;		RSASHA256:        crypto.SHA256,
0000000000000000000000000000000000000000;;		ECDSAP256SHA256:  crypto.SHA256,
0000000000000000000000000000000000000000;;		ECDSAP384SHA384:  crypto.SHA384,
0000000000000000000000000000000000000000;;		RSASHA512:        crypto.SHA512,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DNSSEC hashing algorithm codes.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		_      uint8 = iota
0000000000000000000000000000000000000000;;		SHA1         // RFC 4034
0000000000000000000000000000000000000000;;		SHA256       // RFC 4509
0000000000000000000000000000000000000000;;		GOST94       // RFC 5933
0000000000000000000000000000000000000000;;		SHA384       // Experimental
0000000000000000000000000000000000000000;;		SHA512       // Experimental
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map for hash names.
0000000000000000000000000000000000000000;;	var HashToString = map[uint8]string{
0000000000000000000000000000000000000000;;		SHA1:   "SHA1",
0000000000000000000000000000000000000000;;		SHA256: "SHA256",
0000000000000000000000000000000000000000;;		GOST94: "GOST94",
0000000000000000000000000000000000000000;;		SHA384: "SHA384",
0000000000000000000000000000000000000000;;		SHA512: "SHA512",
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map of hash strings.
0000000000000000000000000000000000000000;;	var StringToHash = reverseInt8(HashToString)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DNSKEY flag values.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SEP    = 1
0000000000000000000000000000000000000000;;		REVOKE = 1 << 7
0000000000000000000000000000000000000000;;		ZONE   = 1 << 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The RRSIG needs to be converted to wireformat with some of the rdata (the signature) missing.
0000000000000000000000000000000000000000;;	type rrsigWireFmt struct {
0000000000000000000000000000000000000000;;		TypeCovered uint16
0000000000000000000000000000000000000000;;		Algorithm   uint8
0000000000000000000000000000000000000000;;		Labels      uint8
0000000000000000000000000000000000000000;;		OrigTtl     uint32
0000000000000000000000000000000000000000;;		Expiration  uint32
0000000000000000000000000000000000000000;;		Inception   uint32
0000000000000000000000000000000000000000;;		KeyTag      uint16
0000000000000000000000000000000000000000;;		SignerName  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		/* No Signature */
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Used for converting DNSKEY's rdata to wirefmt.
0000000000000000000000000000000000000000;;	type dnskeyWireFmt struct {
0000000000000000000000000000000000000000;;		Flags     uint16
0000000000000000000000000000000000000000;;		Protocol  uint8
0000000000000000000000000000000000000000;;		Algorithm uint8
0000000000000000000000000000000000000000;;		PublicKey string `dns:"base64"`
0000000000000000000000000000000000000000;;		/* Nothing is left out */
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func divRoundUp(a, b int) int {
0000000000000000000000000000000000000000;;		return (a + b - 1) / b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// KeyTag calculates the keytag (or key-id) of the DNSKEY.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) KeyTag() uint16 {
0000000000000000000000000000000000000000;;		if k == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var keytag int
0000000000000000000000000000000000000000;;		switch k.Algorithm {
0000000000000000000000000000000000000000;;		case RSAMD5:
0000000000000000000000000000000000000000;;			// Look at the bottom two bytes of the modules, which the last
0000000000000000000000000000000000000000;;			// item in the pubkey. We could do this faster by looking directly
0000000000000000000000000000000000000000;;			// at the base64 values. But I'm lazy.
0000000000000000000000000000000000000000;;			modulus, _ := fromBase64([]byte(k.PublicKey))
0000000000000000000000000000000000000000;;			if len(modulus) > 1 {
0000000000000000000000000000000000000000;;				x := binary.BigEndian.Uint16(modulus[len(modulus)-2:])
0000000000000000000000000000000000000000;;				keytag = int(x)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			keywire := new(dnskeyWireFmt)
0000000000000000000000000000000000000000;;			keywire.Flags = k.Flags
0000000000000000000000000000000000000000;;			keywire.Protocol = k.Protocol
0000000000000000000000000000000000000000;;			keywire.Algorithm = k.Algorithm
0000000000000000000000000000000000000000;;			keywire.PublicKey = k.PublicKey
0000000000000000000000000000000000000000;;			wire := make([]byte, DefaultMsgSize)
0000000000000000000000000000000000000000;;			n, err := packKeyWire(keywire, wire)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wire = wire[:n]
0000000000000000000000000000000000000000;;			for i, v := range wire {
0000000000000000000000000000000000000000;;				if i&1 != 0 {
0000000000000000000000000000000000000000;;					keytag += int(v) // must be larger than uint32
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					keytag += int(v) << 8
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			keytag += (keytag >> 16) & 0xFFFF
0000000000000000000000000000000000000000;;			keytag &= 0xFFFF
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint16(keytag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToDS converts a DNSKEY record to a DS record.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) ToDS(h uint8) *DS {
0000000000000000000000000000000000000000;;		if k == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		ds := new(DS)
0000000000000000000000000000000000000000;;		ds.Hdr.Name = k.Hdr.Name
0000000000000000000000000000000000000000;;		ds.Hdr.Class = k.Hdr.Class
0000000000000000000000000000000000000000;;		ds.Hdr.Rrtype = TypeDS
0000000000000000000000000000000000000000;;		ds.Hdr.Ttl = k.Hdr.Ttl
0000000000000000000000000000000000000000;;		ds.Algorithm = k.Algorithm
0000000000000000000000000000000000000000;;		ds.DigestType = h
0000000000000000000000000000000000000000;;		ds.KeyTag = k.KeyTag()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		keywire := new(dnskeyWireFmt)
0000000000000000000000000000000000000000;;		keywire.Flags = k.Flags
0000000000000000000000000000000000000000;;		keywire.Protocol = k.Protocol
0000000000000000000000000000000000000000;;		keywire.Algorithm = k.Algorithm
0000000000000000000000000000000000000000;;		keywire.PublicKey = k.PublicKey
0000000000000000000000000000000000000000;;		wire := make([]byte, DefaultMsgSize)
0000000000000000000000000000000000000000;;		n, err := packKeyWire(keywire, wire)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		wire = wire[:n]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		owner := make([]byte, 255)
0000000000000000000000000000000000000000;;		off, err1 := PackDomainName(strings.ToLower(k.Hdr.Name), owner, 0, nil, false)
0000000000000000000000000000000000000000;;		if err1 != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		owner = owner[:off]
0000000000000000000000000000000000000000;;		// RFC4034:
0000000000000000000000000000000000000000;;		// digest = digest_algorithm( DNSKEY owner name | DNSKEY RDATA);
0000000000000000000000000000000000000000;;		// "|" denotes concatenation
0000000000000000000000000000000000000000;;		// DNSKEY RDATA = Flags | Protocol | Algorithm | Public Key.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// digest buffer
0000000000000000000000000000000000000000;;		digest := append(owner, wire...) // another copy
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hash crypto.Hash
0000000000000000000000000000000000000000;;		switch h {
0000000000000000000000000000000000000000;;		case SHA1:
0000000000000000000000000000000000000000;;			hash = crypto.SHA1
0000000000000000000000000000000000000000;;		case SHA256:
0000000000000000000000000000000000000000;;			hash = crypto.SHA256
0000000000000000000000000000000000000000;;		case SHA384:
0000000000000000000000000000000000000000;;			hash = crypto.SHA384
0000000000000000000000000000000000000000;;		case SHA512:
0000000000000000000000000000000000000000;;			hash = crypto.SHA512
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := hash.New()
0000000000000000000000000000000000000000;;		s.Write(digest)
0000000000000000000000000000000000000000;;		ds.Digest = hex.EncodeToString(s.Sum(nil))
0000000000000000000000000000000000000000;;		return ds
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToCDNSKEY converts a DNSKEY record to a CDNSKEY record.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) ToCDNSKEY() *CDNSKEY {
0000000000000000000000000000000000000000;;		c := &CDNSKEY{DNSKEY: *k}
0000000000000000000000000000000000000000;;		c.Hdr = *k.Hdr.copyHeader()
0000000000000000000000000000000000000000;;		c.Hdr.Rrtype = TypeCDNSKEY
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToCDS converts a DS record to a CDS record.
0000000000000000000000000000000000000000;;	func (d *DS) ToCDS() *CDS {
0000000000000000000000000000000000000000;;		c := &CDS{DS: *d}
0000000000000000000000000000000000000000;;		c.Hdr = *d.Hdr.copyHeader()
0000000000000000000000000000000000000000;;		c.Hdr.Rrtype = TypeCDS
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign signs an RRSet. The signature needs to be filled in with the values:
0000000000000000000000000000000000000000;;	// Inception, Expiration, KeyTag, SignerName and Algorithm.  The rest is copied
0000000000000000000000000000000000000000;;	// from the RRset. Sign returns a non-nill error when the signing went OK.
0000000000000000000000000000000000000000;;	// There is no check if RRSet is a proper (RFC 2181) RRSet.  If OrigTTL is non
0000000000000000000000000000000000000000;;	// zero, it is used as-is, otherwise the TTL of the RRset is used as the
0000000000000000000000000000000000000000;;	// OrigTTL.
0000000000000000000000000000000000000000;;	func (rr *RRSIG) Sign(k crypto.Signer, rrset []RR) error {
0000000000000000000000000000000000000000;;		if k == nil {
0000000000000000000000000000000000000000;;			return ErrPrivKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// s.Inception and s.Expiration may be 0 (rollover etc.), the rest must be set
0000000000000000000000000000000000000000;;		if rr.KeyTag == 0 || len(rr.SignerName) == 0 || rr.Algorithm == 0 {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Hdr.Rrtype = TypeRRSIG
0000000000000000000000000000000000000000;;		rr.Hdr.Name = rrset[0].Header().Name
0000000000000000000000000000000000000000;;		rr.Hdr.Class = rrset[0].Header().Class
0000000000000000000000000000000000000000;;		if rr.OrigTtl == 0 { // If set don't override
0000000000000000000000000000000000000000;;			rr.OrigTtl = rrset[0].Header().Ttl
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.TypeCovered = rrset[0].Header().Rrtype
0000000000000000000000000000000000000000;;		rr.Labels = uint8(CountLabel(rrset[0].Header().Name))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasPrefix(rrset[0].Header().Name, "*") {
0000000000000000000000000000000000000000;;			rr.Labels-- // wildcard, remove from label count
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sigwire := new(rrsigWireFmt)
0000000000000000000000000000000000000000;;		sigwire.TypeCovered = rr.TypeCovered
0000000000000000000000000000000000000000;;		sigwire.Algorithm = rr.Algorithm
0000000000000000000000000000000000000000;;		sigwire.Labels = rr.Labels
0000000000000000000000000000000000000000;;		sigwire.OrigTtl = rr.OrigTtl
0000000000000000000000000000000000000000;;		sigwire.Expiration = rr.Expiration
0000000000000000000000000000000000000000;;		sigwire.Inception = rr.Inception
0000000000000000000000000000000000000000;;		sigwire.KeyTag = rr.KeyTag
0000000000000000000000000000000000000000;;		// For signing, lowercase this name
0000000000000000000000000000000000000000;;		sigwire.SignerName = strings.ToLower(rr.SignerName)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Create the desired binary blob
0000000000000000000000000000000000000000;;		signdata := make([]byte, DefaultMsgSize)
0000000000000000000000000000000000000000;;		n, err := packSigWire(sigwire, signdata)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signdata = signdata[:n]
0000000000000000000000000000000000000000;;		wire, err := rawSignatureData(rrset, rr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signdata = append(signdata, wire...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hash, ok := AlgorithmToHash[rr.Algorithm]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		h := hash.New()
0000000000000000000000000000000000000000;;		h.Write(signdata)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signature, err := sign(k, h.Sum(nil), hash, rr.Algorithm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Signature = toBase64(signature)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sign(k crypto.Signer, hashed []byte, hash crypto.Hash, alg uint8) ([]byte, error) {
0000000000000000000000000000000000000000;;		signature, err := k.Sign(rand.Reader, hashed, hash)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch alg {
0000000000000000000000000000000000000000;;		case RSASHA1, RSASHA1NSEC3SHA1, RSASHA256, RSASHA512:
0000000000000000000000000000000000000000;;			return signature, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256, ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			ecdsaSignature := &struct {
0000000000000000000000000000000000000000;;				R, S *big.Int
0000000000000000000000000000000000000000;;			}{}
0000000000000000000000000000000000000000;;			if _, err := asn1.Unmarshal(signature, ecdsaSignature); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var intlen int
0000000000000000000000000000000000000000;;			switch alg {
0000000000000000000000000000000000000000;;			case ECDSAP256SHA256:
0000000000000000000000000000000000000000;;				intlen = 32
0000000000000000000000000000000000000000;;			case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;				intlen = 48
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			signature := intToBytes(ecdsaSignature.R, intlen)
0000000000000000000000000000000000000000;;			signature = append(signature, intToBytes(ecdsaSignature.S, intlen)...)
0000000000000000000000000000000000000000;;			return signature, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// There is no defined interface for what a DSA backed crypto.Signer returns
0000000000000000000000000000000000000000;;		case DSA, DSANSEC3SHA1:
0000000000000000000000000000000000000000;;			// 	t := divRoundUp(divRoundUp(p.PublicKey.Y.BitLen(), 8)-64, 8)
0000000000000000000000000000000000000000;;			// 	signature := []byte{byte(t)}
0000000000000000000000000000000000000000;;			// 	signature = append(signature, intToBytes(r1, 20)...)
0000000000000000000000000000000000000000;;			// 	signature = append(signature, intToBytes(s1, 20)...)
0000000000000000000000000000000000000000;;			// 	rr.Signature = signature
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, ErrAlg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify validates an RRSet with the signature and key. This is only the
0000000000000000000000000000000000000000;;	// cryptographic test, the signature validity period must be checked separately.
0000000000000000000000000000000000000000;;	// This function copies the rdata of some RRs (to lowercase domain names) for the validation to work.
0000000000000000000000000000000000000000;;	func (rr *RRSIG) Verify(k *DNSKEY, rrset []RR) error {
0000000000000000000000000000000000000000;;		// First the easy checks
0000000000000000000000000000000000000000;;		if !IsRRset(rrset) {
0000000000000000000000000000000000000000;;			return ErrRRset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.KeyTag != k.KeyTag() {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Hdr.Class != k.Hdr.Class {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Algorithm != k.Algorithm {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if strings.ToLower(rr.SignerName) != strings.ToLower(k.Hdr.Name) {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if k.Protocol != 3 {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// IsRRset checked that we have at least one RR and that the RRs in
0000000000000000000000000000000000000000;;		// the set have consistent type, class, and name. Also check that type and
0000000000000000000000000000000000000000;;		// class matches the RRSIG record.
0000000000000000000000000000000000000000;;		if rrset[0].Header().Class != rr.Hdr.Class {
0000000000000000000000000000000000000000;;			return ErrRRset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rrset[0].Header().Rrtype != rr.TypeCovered {
0000000000000000000000000000000000000000;;			return ErrRRset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RFC 4035 5.3.2.  Reconstructing the Signed Data
0000000000000000000000000000000000000000;;		// Copy the sig, except the rrsig data
0000000000000000000000000000000000000000;;		sigwire := new(rrsigWireFmt)
0000000000000000000000000000000000000000;;		sigwire.TypeCovered = rr.TypeCovered
0000000000000000000000000000000000000000;;		sigwire.Algorithm = rr.Algorithm
0000000000000000000000000000000000000000;;		sigwire.Labels = rr.Labels
0000000000000000000000000000000000000000;;		sigwire.OrigTtl = rr.OrigTtl
0000000000000000000000000000000000000000;;		sigwire.Expiration = rr.Expiration
0000000000000000000000000000000000000000;;		sigwire.Inception = rr.Inception
0000000000000000000000000000000000000000;;		sigwire.KeyTag = rr.KeyTag
0000000000000000000000000000000000000000;;		sigwire.SignerName = strings.ToLower(rr.SignerName)
0000000000000000000000000000000000000000;;		// Create the desired binary blob
0000000000000000000000000000000000000000;;		signeddata := make([]byte, DefaultMsgSize)
0000000000000000000000000000000000000000;;		n, err := packSigWire(sigwire, signeddata)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signeddata = signeddata[:n]
0000000000000000000000000000000000000000;;		wire, err := rawSignatureData(rrset, rr)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		signeddata = append(signeddata, wire...)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sigbuf := rr.sigBuf()           // Get the binary signature data
0000000000000000000000000000000000000000;;		if rr.Algorithm == PRIVATEDNS { // PRIVATEOID
0000000000000000000000000000000000000000;;			// TODO(miek)
0000000000000000000000000000000000000000;;			// remove the domain name and assume its ours?
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hash, ok := AlgorithmToHash[rr.Algorithm]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return ErrAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch rr.Algorithm {
0000000000000000000000000000000000000000;;		case RSASHA1, RSASHA1NSEC3SHA1, RSASHA256, RSASHA512, RSAMD5:
0000000000000000000000000000000000000000;;			// TODO(mg): this can be done quicker, ie. cache the pubkey data somewhere??
0000000000000000000000000000000000000000;;			pubkey := k.publicKeyRSA() // Get the key
0000000000000000000000000000000000000000;;			if pubkey == nil {
0000000000000000000000000000000000000000;;				return ErrKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			h := hash.New()
0000000000000000000000000000000000000000;;			h.Write(signeddata)
0000000000000000000000000000000000000000;;			return rsa.VerifyPKCS1v15(pubkey, hash, h.Sum(nil), sigbuf)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256, ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			pubkey := k.publicKeyECDSA()
0000000000000000000000000000000000000000;;			if pubkey == nil {
0000000000000000000000000000000000000000;;				return ErrKey
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Split sigbuf into the r and s coordinates
0000000000000000000000000000000000000000;;			r := new(big.Int).SetBytes(sigbuf[:len(sigbuf)/2])
0000000000000000000000000000000000000000;;			s := new(big.Int).SetBytes(sigbuf[len(sigbuf)/2:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			h := hash.New()
0000000000000000000000000000000000000000;;			h.Write(signeddata)
0000000000000000000000000000000000000000;;			if ecdsa.Verify(pubkey, h.Sum(nil), r, s) {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return ErrSig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ValidityPeriod uses RFC1982 serial arithmetic to calculate
0000000000000000000000000000000000000000;;	// if a signature period is valid. If t is the zero time, the
0000000000000000000000000000000000000000;;	// current time is taken other t is. Returns true if the signature
0000000000000000000000000000000000000000;;	// is valid at the given time, otherwise returns false.
0000000000000000000000000000000000000000;;	func (rr *RRSIG) ValidityPeriod(t time.Time) bool {
0000000000000000000000000000000000000000;;		var utc int64
0000000000000000000000000000000000000000;;		if t.IsZero() {
0000000000000000000000000000000000000000;;			utc = time.Now().UTC().Unix()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			utc = t.UTC().Unix()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		modi := (int64(rr.Inception) - utc) / year68
0000000000000000000000000000000000000000;;		mode := (int64(rr.Expiration) - utc) / year68
0000000000000000000000000000000000000000;;		ti := int64(rr.Inception) + (modi * year68)
0000000000000000000000000000000000000000;;		te := int64(rr.Expiration) + (mode * year68)
0000000000000000000000000000000000000000;;		return ti <= utc && utc <= te
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the signatures base64 encodedig sigdata as a byte slice.
0000000000000000000000000000000000000000;;	func (rr *RRSIG) sigBuf() []byte {
0000000000000000000000000000000000000000;;		sigbuf, err := fromBase64([]byte(rr.Signature))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return sigbuf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// publicKeyRSA returns the RSA public key from a DNSKEY record.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) publicKeyRSA() *rsa.PublicKey {
0000000000000000000000000000000000000000;;		keybuf, err := fromBase64([]byte(k.PublicKey))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// RFC 2537/3110, section 2. RSA Public KEY Resource Records
0000000000000000000000000000000000000000;;		// Length is in the 0th byte, unless its zero, then it
0000000000000000000000000000000000000000;;		// it in bytes 1 and 2 and its a 16 bit number
0000000000000000000000000000000000000000;;		explen := uint16(keybuf[0])
0000000000000000000000000000000000000000;;		keyoff := 1
0000000000000000000000000000000000000000;;		if explen == 0 {
0000000000000000000000000000000000000000;;			explen = uint16(keybuf[1])<<8 | uint16(keybuf[2])
0000000000000000000000000000000000000000;;			keyoff = 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pubkey := new(rsa.PublicKey)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pubkey.N = big.NewInt(0)
0000000000000000000000000000000000000000;;		shift := uint64((explen - 1) * 8)
0000000000000000000000000000000000000000;;		expo := uint64(0)
0000000000000000000000000000000000000000;;		for i := int(explen - 1); i > 0; i-- {
0000000000000000000000000000000000000000;;			expo += uint64(keybuf[keyoff+i]) << shift
0000000000000000000000000000000000000000;;			shift -= 8
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Remainder
0000000000000000000000000000000000000000;;		expo += uint64(keybuf[keyoff])
0000000000000000000000000000000000000000;;		if expo > 2<<31 {
0000000000000000000000000000000000000000;;			// Larger expo than supported.
0000000000000000000000000000000000000000;;			// println("dns: F5 primes (or larger) are not supported")
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pubkey.E = int(expo)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pubkey.N.SetBytes(keybuf[keyoff+int(explen):])
0000000000000000000000000000000000000000;;		return pubkey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// publicKeyECDSA returns the Curve public key from the DNSKEY record.
0000000000000000000000000000000000000000;;	func (k *DNSKEY) publicKeyECDSA() *ecdsa.PublicKey {
0000000000000000000000000000000000000000;;		keybuf, err := fromBase64([]byte(k.PublicKey))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pubkey := new(ecdsa.PublicKey)
0000000000000000000000000000000000000000;;		switch k.Algorithm {
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256:
0000000000000000000000000000000000000000;;			pubkey.Curve = elliptic.P256()
0000000000000000000000000000000000000000;;			if len(keybuf) != 64 {
0000000000000000000000000000000000000000;;				// wrongly encoded key
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			pubkey.Curve = elliptic.P384()
0000000000000000000000000000000000000000;;			if len(keybuf) != 96 {
0000000000000000000000000000000000000000;;				// Wrongly encoded key
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pubkey.X = big.NewInt(0)
0000000000000000000000000000000000000000;;		pubkey.X.SetBytes(keybuf[:len(keybuf)/2])
0000000000000000000000000000000000000000;;		pubkey.Y = big.NewInt(0)
0000000000000000000000000000000000000000;;		pubkey.Y.SetBytes(keybuf[len(keybuf)/2:])
0000000000000000000000000000000000000000;;		return pubkey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (k *DNSKEY) publicKeyDSA() *dsa.PublicKey {
0000000000000000000000000000000000000000;;		keybuf, err := fromBase64([]byte(k.PublicKey))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(keybuf) < 22 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		t, keybuf := int(keybuf[0]), keybuf[1:]
0000000000000000000000000000000000000000;;		size := 64 + t*8
0000000000000000000000000000000000000000;;		q, keybuf := keybuf[:20], keybuf[20:]
0000000000000000000000000000000000000000;;		if len(keybuf) != 3*size {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p, keybuf := keybuf[:size], keybuf[size:]
0000000000000000000000000000000000000000;;		g, y := keybuf[:size], keybuf[size:]
0000000000000000000000000000000000000000;;		pubkey := new(dsa.PublicKey)
0000000000000000000000000000000000000000;;		pubkey.Parameters.Q = big.NewInt(0).SetBytes(q)
0000000000000000000000000000000000000000;;		pubkey.Parameters.P = big.NewInt(0).SetBytes(p)
0000000000000000000000000000000000000000;;		pubkey.Parameters.G = big.NewInt(0).SetBytes(g)
0000000000000000000000000000000000000000;;		pubkey.Y = big.NewInt(0).SetBytes(y)
0000000000000000000000000000000000000000;;		return pubkey
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type wireSlice [][]byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p wireSlice) Len() int      { return len(p) }
0000000000000000000000000000000000000000;;	func (p wireSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
0000000000000000000000000000000000000000;;	func (p wireSlice) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		_, ioff, _ := UnpackDomainName(p[i], 0)
0000000000000000000000000000000000000000;;		_, joff, _ := UnpackDomainName(p[j], 0)
0000000000000000000000000000000000000000;;		return bytes.Compare(p[i][ioff+10:], p[j][joff+10:]) < 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return the raw signature data.
0000000000000000000000000000000000000000;;	func rawSignatureData(rrset []RR, s *RRSIG) (buf []byte, err error) {
0000000000000000000000000000000000000000;;		wires := make(wireSlice, len(rrset))
0000000000000000000000000000000000000000;;		for i, r := range rrset {
0000000000000000000000000000000000000000;;			r1 := r.copy()
0000000000000000000000000000000000000000;;			r1.Header().Ttl = s.OrigTtl
0000000000000000000000000000000000000000;;			labels := SplitDomainName(r1.Header().Name)
0000000000000000000000000000000000000000;;			// 6.2. Canonical RR Form. (4) - wildcards
0000000000000000000000000000000000000000;;			if len(labels) > int(s.Labels) {
0000000000000000000000000000000000000000;;				// Wildcard
0000000000000000000000000000000000000000;;				r1.Header().Name = "*." + strings.Join(labels[len(labels)-int(s.Labels):], ".") + "."
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// RFC 4034: 6.2.  Canonical RR Form. (2) - domain name to lowercase
0000000000000000000000000000000000000000;;			r1.Header().Name = strings.ToLower(r1.Header().Name)
0000000000000000000000000000000000000000;;			// 6.2. Canonical RR Form. (3) - domain rdata to lowercase.
0000000000000000000000000000000000000000;;			//   NS, MD, MF, CNAME, SOA, MB, MG, MR, PTR,
0000000000000000000000000000000000000000;;			//   HINFO, MINFO, MX, RP, AFSDB, RT, SIG, PX, NXT, NAPTR, KX,
0000000000000000000000000000000000000000;;			//   SRV, DNAME, A6
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// RFC 6840 - Clarifications and Implementation Notes for DNS Security (DNSSEC):
0000000000000000000000000000000000000000;;			//	Section 6.2 of [RFC4034] also erroneously lists HINFO as a record
0000000000000000000000000000000000000000;;			//	that needs conversion to lowercase, and twice at that.  Since HINFO
0000000000000000000000000000000000000000;;			//	records contain no domain names, they are not subject to case
0000000000000000000000000000000000000000;;			//	conversion.
0000000000000000000000000000000000000000;;			switch x := r1.(type) {
0000000000000000000000000000000000000000;;			case *NS:
0000000000000000000000000000000000000000;;				x.Ns = strings.ToLower(x.Ns)
0000000000000000000000000000000000000000;;			case *CNAME:
0000000000000000000000000000000000000000;;				x.Target = strings.ToLower(x.Target)
0000000000000000000000000000000000000000;;			case *SOA:
0000000000000000000000000000000000000000;;				x.Ns = strings.ToLower(x.Ns)
0000000000000000000000000000000000000000;;				x.Mbox = strings.ToLower(x.Mbox)
0000000000000000000000000000000000000000;;			case *MB:
0000000000000000000000000000000000000000;;				x.Mb = strings.ToLower(x.Mb)
0000000000000000000000000000000000000000;;			case *MG:
0000000000000000000000000000000000000000;;				x.Mg = strings.ToLower(x.Mg)
0000000000000000000000000000000000000000;;			case *MR:
0000000000000000000000000000000000000000;;				x.Mr = strings.ToLower(x.Mr)
0000000000000000000000000000000000000000;;			case *PTR:
0000000000000000000000000000000000000000;;				x.Ptr = strings.ToLower(x.Ptr)
0000000000000000000000000000000000000000;;			case *MINFO:
0000000000000000000000000000000000000000;;				x.Rmail = strings.ToLower(x.Rmail)
0000000000000000000000000000000000000000;;				x.Email = strings.ToLower(x.Email)
0000000000000000000000000000000000000000;;			case *MX:
0000000000000000000000000000000000000000;;				x.Mx = strings.ToLower(x.Mx)
0000000000000000000000000000000000000000;;			case *NAPTR:
0000000000000000000000000000000000000000;;				x.Replacement = strings.ToLower(x.Replacement)
0000000000000000000000000000000000000000;;			case *KX:
0000000000000000000000000000000000000000;;				x.Exchanger = strings.ToLower(x.Exchanger)
0000000000000000000000000000000000000000;;			case *SRV:
0000000000000000000000000000000000000000;;				x.Target = strings.ToLower(x.Target)
0000000000000000000000000000000000000000;;			case *DNAME:
0000000000000000000000000000000000000000;;				x.Target = strings.ToLower(x.Target)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// 6.2. Canonical RR Form. (5) - origTTL
0000000000000000000000000000000000000000;;			wire := make([]byte, r1.len()+1) // +1 to be safe(r)
0000000000000000000000000000000000000000;;			off, err1 := PackRR(r1, wire, 0, nil, false)
0000000000000000000000000000000000000000;;			if err1 != nil {
0000000000000000000000000000000000000000;;				return nil, err1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			wire = wire[:off]
0000000000000000000000000000000000000000;;			wires[i] = wire
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(wires)
0000000000000000000000000000000000000000;;		for i, wire := range wires {
0000000000000000000000000000000000000000;;			if i > 0 && bytes.Equal(wire, wires[i-1]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf = append(buf, wire...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packSigWire(sw *rrsigWireFmt, msg []byte) (int, error) {
0000000000000000000000000000000000000000;;		// copied from zmsg.go RRSIG packing
0000000000000000000000000000000000000000;;		off, err := packUint16(sw.TypeCovered, msg, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(sw.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(sw.Labels, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(sw.OrigTtl, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(sw.Expiration, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(sw.Inception, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(sw.KeyTag, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = PackDomainName(sw.SignerName, msg, off, nil, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packKeyWire(dw *dnskeyWireFmt, msg []byte) (int, error) {
0000000000000000000000000000000000000000;;		// copied from zmsg.go DNSKEY packing
0000000000000000000000000000000000000000;;		off, err := packUint16(dw.Flags, msg, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(dw.Protocol, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint8(dw.Algorithm, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringBase64(dw.PublicKey, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
