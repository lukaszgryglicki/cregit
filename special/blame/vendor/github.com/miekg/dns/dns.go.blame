0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/dns.go[Godeps/_workspace/src/github.com/miekg/dns/dns.go][vendor/github.com/miekg/dns/dns.go];	
0000000000000000000000000000000000000000;;	import "strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		year68     = 1 << 31 // For RFC1982 (Serial Arithmetic) calculations in 32 bits.
0000000000000000000000000000000000000000;;		defaultTtl = 3600    // Default internal TTL.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		DefaultMsgSize = 4096  // DefaultMsgSize is the standard default for messages larger than 512 bytes.
0000000000000000000000000000000000000000;;		MinMsgSize     = 512   // MinMsgSize is the minimal size of a DNS packet.
0000000000000000000000000000000000000000;;		MaxMsgSize     = 65535 // MaxMsgSize is the largest possible DNS packet.
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error represents a DNS error.
0000000000000000000000000000000000000000;;	type Error struct{ err string }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *Error) Error() string {
0000000000000000000000000000000000000000;;		if e == nil {
0000000000000000000000000000000000000000;;			return "dns: <nil>"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "dns: " + e.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An RR represents a resource record.
0000000000000000000000000000000000000000;;	type RR interface {
0000000000000000000000000000000000000000;;		// Header returns the header of an resource record. The header contains
0000000000000000000000000000000000000000;;		// everything up to the rdata.
0000000000000000000000000000000000000000;;		Header() *RR_Header
0000000000000000000000000000000000000000;;		// String returns the text representation of the resource record.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// copy returns a copy of the RR
0000000000000000000000000000000000000000;;		copy() RR
0000000000000000000000000000000000000000;;		// len returns the length (in octets) of the uncompressed RR in wire format.
0000000000000000000000000000000000000000;;		len() int
0000000000000000000000000000000000000000;;		// pack packs an RR into wire format.
0000000000000000000000000000000000000000;;		pack([]byte, int, map[string]int, bool) (int, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RR_Header is the header all DNS resource records share.
0000000000000000000000000000000000000000;;	type RR_Header struct {
0000000000000000000000000000000000000000;;		Name     string `dns:"cdomain-name"`
0000000000000000000000000000000000000000;;		Rrtype   uint16
0000000000000000000000000000000000000000;;		Class    uint16
0000000000000000000000000000000000000000;;		Ttl      uint32
0000000000000000000000000000000000000000;;		Rdlength uint16 // Length of data after header.
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header returns itself. This is here to make RR_Header implements the RR interface.
0000000000000000000000000000000000000000;;	func (h *RR_Header) Header() *RR_Header { return h }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Just to implement the RR interface.
0000000000000000000000000000000000000000;;	func (h *RR_Header) copy() RR { return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *RR_Header) copyHeader() *RR_Header {
0000000000000000000000000000000000000000;;		r := new(RR_Header)
0000000000000000000000000000000000000000;;		r.Name = h.Name
0000000000000000000000000000000000000000;;		r.Rrtype = h.Rrtype
0000000000000000000000000000000000000000;;		r.Class = h.Class
0000000000000000000000000000000000000000;;		r.Ttl = h.Ttl
0000000000000000000000000000000000000000;;		r.Rdlength = h.Rdlength
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *RR_Header) String() string {
0000000000000000000000000000000000000000;;		var s string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if h.Rrtype == TypeOPT {
0000000000000000000000000000000000000000;;			s = ";"
0000000000000000000000000000000000000000;;			// and maybe other things
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s += sprintName(h.Name) + "\t"
0000000000000000000000000000000000000000;;		s += strconv.FormatInt(int64(h.Ttl), 10) + "\t"
0000000000000000000000000000000000000000;;		s += Class(h.Class).String() + "\t"
0000000000000000000000000000000000000000;;		s += Type(h.Rrtype).String() + "\t"
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (h *RR_Header) len() int {
0000000000000000000000000000000000000000;;		l := len(h.Name) + 1
0000000000000000000000000000000000000000;;		l += 10 // rrtype(2) + class(2) + ttl(4) + rdlength(2)
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToRFC3597 converts a known RR to the unknown RR representation from RFC 3597.
0000000000000000000000000000000000000000;;	func (rr *RFC3597) ToRFC3597(r RR) error {
0000000000000000000000000000000000000000;;		buf := make([]byte, r.len()*2)
0000000000000000000000000000000000000000;;		off, err := PackRR(r, buf, 0, nil, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf = buf[:off]
0000000000000000000000000000000000000000;;		if int(r.Header().Rdlength) > off {
0000000000000000000000000000000000000000;;			return ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rfc3597, _, err := unpackRFC3597(*r.Header(), buf, off-int(r.Header().Rdlength))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*rr = *rfc3597.(*RFC3597)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
