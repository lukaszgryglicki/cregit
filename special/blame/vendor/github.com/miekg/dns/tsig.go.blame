0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/tsig.go[Godeps/_workspace/src/github.com/miekg/dns/tsig.go][vendor/github.com/miekg/dns/tsig.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/hmac"
0000000000000000000000000000000000000000;;		"crypto/md5"
0000000000000000000000000000000000000000;;		"crypto/sha1"
0000000000000000000000000000000000000000;;		"crypto/sha256"
0000000000000000000000000000000000000000;;		"crypto/sha512"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"hash"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HMAC hashing codes. These are transmitted as domain names.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		HmacMD5    = "hmac-md5.sig-alg.reg.int."
0000000000000000000000000000000000000000;;		HmacSHA1   = "hmac-sha1."
0000000000000000000000000000000000000000;;		HmacSHA256 = "hmac-sha256."
0000000000000000000000000000000000000000;;		HmacSHA512 = "hmac-sha512."
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TSIG is the RR the holds the transaction signature of a message.
0000000000000000000000000000000000000000;;	// See RFC 2845 and RFC 4635.
0000000000000000000000000000000000000000;;	type TSIG struct {
0000000000000000000000000000000000000000;;		Hdr        RR_Header
0000000000000000000000000000000000000000;;		Algorithm  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		TimeSigned uint64 `dns:"uint48"`
0000000000000000000000000000000000000000;;		Fudge      uint16
0000000000000000000000000000000000000000;;		MACSize    uint16
0000000000000000000000000000000000000000;;		MAC        string `dns:"size-hex:MACSize"`
0000000000000000000000000000000000000000;;		OrigId     uint16
0000000000000000000000000000000000000000;;		Error      uint16
0000000000000000000000000000000000000000;;		OtherLen   uint16
0000000000000000000000000000000000000000;;		OtherData  string `dns:"size-hex:OtherLen"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TSIG has no official presentation format, but this will suffice.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *TSIG) String() string {
0000000000000000000000000000000000000000;;		s := "\n;; TSIG PSEUDOSECTION:\n"
0000000000000000000000000000000000000000;;		s += rr.Hdr.String() +
0000000000000000000000000000000000000000;;			" " + rr.Algorithm +
0000000000000000000000000000000000000000;;			" " + tsigTimeToString(rr.TimeSigned) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Fudge)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.MACSize)) +
0000000000000000000000000000000000000000;;			" " + strings.ToUpper(rr.MAC) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.OrigId)) +
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.Error)) + // BIND prints NOERROR
0000000000000000000000000000000000000000;;			" " + strconv.Itoa(int(rr.OtherLen)) +
0000000000000000000000000000000000000000;;			" " + rr.OtherData
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The following values must be put in wireformat, so that the MAC can be calculated.
0000000000000000000000000000000000000000;;	// RFC 2845, section 3.4.2. TSIG Variables.
0000000000000000000000000000000000000000;;	type tsigWireFmt struct {
0000000000000000000000000000000000000000;;		// From RR_Header
0000000000000000000000000000000000000000;;		Name  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		Class uint16
0000000000000000000000000000000000000000;;		Ttl   uint32
0000000000000000000000000000000000000000;;		// Rdata of the TSIG
0000000000000000000000000000000000000000;;		Algorithm  string `dns:"domain-name"`
0000000000000000000000000000000000000000;;		TimeSigned uint64 `dns:"uint48"`
0000000000000000000000000000000000000000;;		Fudge      uint16
0000000000000000000000000000000000000000;;		// MACSize, MAC and OrigId excluded
0000000000000000000000000000000000000000;;		Error     uint16
0000000000000000000000000000000000000000;;		OtherLen  uint16
0000000000000000000000000000000000000000;;		OtherData string `dns:"size-hex:OtherLen"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// If we have the MAC use this type to convert it to wiredata. Section 3.4.3. Request MAC
0000000000000000000000000000000000000000;;	type macWireFmt struct {
0000000000000000000000000000000000000000;;		MACSize uint16
0000000000000000000000000000000000000000;;		MAC     string `dns:"size-hex:MACSize"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// 3.3. Time values used in TSIG calculations
0000000000000000000000000000000000000000;;	type timerWireFmt struct {
0000000000000000000000000000000000000000;;		TimeSigned uint64 `dns:"uint48"`
0000000000000000000000000000000000000000;;		Fudge      uint16
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TsigGenerate fills out the TSIG record attached to the message.
0000000000000000000000000000000000000000;;	// The message should contain
0000000000000000000000000000000000000000;;	// a "stub" TSIG RR with the algorithm, key name (owner name of the RR),
0000000000000000000000000000000000000000;;	// time fudge (defaults to 300 seconds) and the current time
0000000000000000000000000000000000000000;;	// The TSIG MAC is saved in that Tsig RR.
0000000000000000000000000000000000000000;;	// When TsigGenerate is called for the first time requestMAC is set to the empty string and
0000000000000000000000000000000000000000;;	// timersOnly is false.
0000000000000000000000000000000000000000;;	// If something goes wrong an error is returned, otherwise it is nil.
0000000000000000000000000000000000000000;;	func TsigGenerate(m *Msg, secret, requestMAC string, timersOnly bool) ([]byte, string, error) {
0000000000000000000000000000000000000000;;		if m.IsTsig() == nil {
0000000000000000000000000000000000000000;;			panic("dns: TSIG not last RR in additional")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If we barf here, the caller is to blame
0000000000000000000000000000000000000000;;		rawsecret, err := fromBase64([]byte(secret))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr := m.Extra[len(m.Extra)-1].(*TSIG)
0000000000000000000000000000000000000000;;		m.Extra = m.Extra[0 : len(m.Extra)-1] // kill the TSIG from the msg
0000000000000000000000000000000000000000;;		mbuf, err := m.Pack()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf := tsigBuffer(mbuf, rr, requestMAC, timersOnly)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := new(TSIG)
0000000000000000000000000000000000000000;;		var h hash.Hash
0000000000000000000000000000000000000000;;		switch strings.ToLower(rr.Algorithm) {
0000000000000000000000000000000000000000;;		case HmacMD5:
0000000000000000000000000000000000000000;;			h = hmac.New(md5.New, []byte(rawsecret))
0000000000000000000000000000000000000000;;		case HmacSHA1:
0000000000000000000000000000000000000000;;			h = hmac.New(sha1.New, []byte(rawsecret))
0000000000000000000000000000000000000000;;		case HmacSHA256:
0000000000000000000000000000000000000000;;			h = hmac.New(sha256.New, []byte(rawsecret))
0000000000000000000000000000000000000000;;		case HmacSHA512:
0000000000000000000000000000000000000000;;			h = hmac.New(sha512.New, []byte(rawsecret))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, "", ErrKeyAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		io.WriteString(h, string(buf))
0000000000000000000000000000000000000000;;		t.MAC = hex.EncodeToString(h.Sum(nil))
0000000000000000000000000000000000000000;;		t.MACSize = uint16(len(t.MAC) / 2) // Size is half!
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t.Hdr = RR_Header{Name: rr.Hdr.Name, Rrtype: TypeTSIG, Class: ClassANY, Ttl: 0}
0000000000000000000000000000000000000000;;		t.Fudge = rr.Fudge
0000000000000000000000000000000000000000;;		t.TimeSigned = rr.TimeSigned
0000000000000000000000000000000000000000;;		t.Algorithm = rr.Algorithm
0000000000000000000000000000000000000000;;		t.OrigId = m.Id
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tbuf := make([]byte, t.len())
0000000000000000000000000000000000000000;;		if off, err := PackRR(t, tbuf, 0, nil, false); err == nil {
0000000000000000000000000000000000000000;;			tbuf = tbuf[:off] // reset to actual size used
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return nil, "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		mbuf = append(mbuf, tbuf...)
0000000000000000000000000000000000000000;;		// Update the ArCount directly in the buffer.
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(mbuf[10:], uint16(len(m.Extra)+1))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return mbuf, t.MAC, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TsigVerify verifies the TSIG on a message.
0000000000000000000000000000000000000000;;	// If the signature does not validate err contains the
0000000000000000000000000000000000000000;;	// error, otherwise it is nil.
0000000000000000000000000000000000000000;;	func TsigVerify(msg []byte, secret, requestMAC string, timersOnly bool) error {
0000000000000000000000000000000000000000;;		rawsecret, err := fromBase64([]byte(secret))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Strip the TSIG from the incoming msg
0000000000000000000000000000000000000000;;		stripped, tsig, err := stripTsig(msg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		msgMAC, err := hex.DecodeString(tsig.MAC)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := tsigBuffer(stripped, tsig, requestMAC, timersOnly)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Fudge factor works both ways. A message can arrive before it was signed because
0000000000000000000000000000000000000000;;		// of clock skew.
0000000000000000000000000000000000000000;;		now := uint64(time.Now().Unix())
0000000000000000000000000000000000000000;;		ti := now - tsig.TimeSigned
0000000000000000000000000000000000000000;;		if now < tsig.TimeSigned {
0000000000000000000000000000000000000000;;			ti = tsig.TimeSigned - now
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if uint64(tsig.Fudge) < ti {
0000000000000000000000000000000000000000;;			return ErrTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var h hash.Hash
0000000000000000000000000000000000000000;;		switch strings.ToLower(tsig.Algorithm) {
0000000000000000000000000000000000000000;;		case HmacMD5:
0000000000000000000000000000000000000000;;			h = hmac.New(md5.New, rawsecret)
0000000000000000000000000000000000000000;;		case HmacSHA1:
0000000000000000000000000000000000000000;;			h = hmac.New(sha1.New, rawsecret)
0000000000000000000000000000000000000000;;		case HmacSHA256:
0000000000000000000000000000000000000000;;			h = hmac.New(sha256.New, rawsecret)
0000000000000000000000000000000000000000;;		case HmacSHA512:
0000000000000000000000000000000000000000;;			h = hmac.New(sha512.New, rawsecret)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrKeyAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		h.Write(buf)
0000000000000000000000000000000000000000;;		if !hmac.Equal(h.Sum(nil), msgMAC) {
0000000000000000000000000000000000000000;;			return ErrSig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a wiredata buffer for the MAC calculation.
0000000000000000000000000000000000000000;;	func tsigBuffer(msgbuf []byte, rr *TSIG, requestMAC string, timersOnly bool) []byte {
0000000000000000000000000000000000000000;;		var buf []byte
0000000000000000000000000000000000000000;;		if rr.TimeSigned == 0 {
0000000000000000000000000000000000000000;;			rr.TimeSigned = uint64(time.Now().Unix())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.Fudge == 0 {
0000000000000000000000000000000000000000;;			rr.Fudge = 300 // Standard (RFC) default.
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if requestMAC != "" {
0000000000000000000000000000000000000000;;			m := new(macWireFmt)
0000000000000000000000000000000000000000;;			m.MACSize = uint16(len(requestMAC) / 2)
0000000000000000000000000000000000000000;;			m.MAC = requestMAC
0000000000000000000000000000000000000000;;			buf = make([]byte, len(requestMAC)) // long enough
0000000000000000000000000000000000000000;;			n, _ := packMacWire(m, buf)
0000000000000000000000000000000000000000;;			buf = buf[:n]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tsigvar := make([]byte, DefaultMsgSize)
0000000000000000000000000000000000000000;;		if timersOnly {
0000000000000000000000000000000000000000;;			tsig := new(timerWireFmt)
0000000000000000000000000000000000000000;;			tsig.TimeSigned = rr.TimeSigned
0000000000000000000000000000000000000000;;			tsig.Fudge = rr.Fudge
0000000000000000000000000000000000000000;;			n, _ := packTimerWire(tsig, tsigvar)
0000000000000000000000000000000000000000;;			tsigvar = tsigvar[:n]
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			tsig := new(tsigWireFmt)
0000000000000000000000000000000000000000;;			tsig.Name = strings.ToLower(rr.Hdr.Name)
0000000000000000000000000000000000000000;;			tsig.Class = ClassANY
0000000000000000000000000000000000000000;;			tsig.Ttl = rr.Hdr.Ttl
0000000000000000000000000000000000000000;;			tsig.Algorithm = strings.ToLower(rr.Algorithm)
0000000000000000000000000000000000000000;;			tsig.TimeSigned = rr.TimeSigned
0000000000000000000000000000000000000000;;			tsig.Fudge = rr.Fudge
0000000000000000000000000000000000000000;;			tsig.Error = rr.Error
0000000000000000000000000000000000000000;;			tsig.OtherLen = rr.OtherLen
0000000000000000000000000000000000000000;;			tsig.OtherData = rr.OtherData
0000000000000000000000000000000000000000;;			n, _ := packTsigWire(tsig, tsigvar)
0000000000000000000000000000000000000000;;			tsigvar = tsigvar[:n]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if requestMAC != "" {
0000000000000000000000000000000000000000;;			x := append(buf, msgbuf...)
0000000000000000000000000000000000000000;;			buf = append(x, tsigvar...)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			buf = append(msgbuf, tsigvar...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Strip the TSIG from the raw message.
0000000000000000000000000000000000000000;;	func stripTsig(msg []byte) ([]byte, *TSIG, error) {
0000000000000000000000000000000000000000;;		// Copied from msg.go's Unpack() Header, but modified.
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			dh  Header
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		off, tsigoff := 0, 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if dh, off, err = unpackMsgHdr(msg, off); err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if dh.Arcount == 0 {
0000000000000000000000000000000000000000;;			return nil, nil, ErrNoSig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rcode, see msg.go Unpack()
0000000000000000000000000000000000000000;;		if int(dh.Bits&0xF) == RcodeNotAuth {
0000000000000000000000000000000000000000;;			return nil, nil, ErrAuth
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := 0; i < int(dh.Qdcount); i++ {
0000000000000000000000000000000000000000;;			_, off, err = unpackQuestion(msg, off)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, off, err = unpackRRslice(int(dh.Ancount), msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, off, err = unpackRRslice(int(dh.Nscount), msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr := new(TSIG)
0000000000000000000000000000000000000000;;		var extra RR
0000000000000000000000000000000000000000;;		for i := 0; i < int(dh.Arcount); i++ {
0000000000000000000000000000000000000000;;			tsigoff = off
0000000000000000000000000000000000000000;;			extra, off, err = UnpackRR(msg, off)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if extra.Header().Rrtype == TypeTSIG {
0000000000000000000000000000000000000000;;				rr = extra.(*TSIG)
0000000000000000000000000000000000000000;;				// Adjust Arcount.
0000000000000000000000000000000000000000;;				arcount := binary.BigEndian.Uint16(msg[10:])
0000000000000000000000000000000000000000;;				binary.BigEndian.PutUint16(msg[10:], arcount-1)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr == nil {
0000000000000000000000000000000000000000;;			return nil, nil, ErrNoSig
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg[:tsigoff], rr, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Translate the TSIG time signed into a date. There is no
0000000000000000000000000000000000000000;;	// need for RFC1982 calculations as this date is 48 bits.
0000000000000000000000000000000000000000;;	func tsigTimeToString(t uint64) string {
0000000000000000000000000000000000000000;;		ti := time.Unix(int64(t), 0).UTC()
0000000000000000000000000000000000000000;;		return ti.Format("20060102150405")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packTsigWire(tw *tsigWireFmt, msg []byte) (int, error) {
0000000000000000000000000000000000000000;;		// copied from zmsg.go TSIG packing
0000000000000000000000000000000000000000;;		// RR_Header
0000000000000000000000000000000000000000;;		off, err := PackDomainName(tw.Name, msg, 0, nil, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(tw.Class, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(tw.Ttl, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		off, err = PackDomainName(tw.Algorithm, msg, off, nil, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint48(tw.TimeSigned, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(tw.Fudge, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		off, err = packUint16(tw.Error, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(tw.OtherLen, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(tw.OtherData, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packMacWire(mw *macWireFmt, msg []byte) (int, error) {
0000000000000000000000000000000000000000;;		off, err := packUint16(mw.MACSize, msg, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packStringHex(mw.MAC, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packTimerWire(tw *timerWireFmt, msg []byte) (int, error) {
0000000000000000000000000000000000000000;;		off, err := packUint48(tw.TimeSigned, msg, 0)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(tw.Fudge, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
