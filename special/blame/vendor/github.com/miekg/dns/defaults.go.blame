0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/defaults.go[Godeps/_workspace/src/github.com/miekg/dns/defaults.go][vendor/github.com/miekg/dns/defaults.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const hexDigit = "0123456789abcdef"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Everything is assumed in ClassINET.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetReply creates a reply message from a request message.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetReply(request *Msg) *Msg {
0000000000000000000000000000000000000000;;		dns.Id = request.Id
0000000000000000000000000000000000000000;;		dns.RecursionDesired = request.RecursionDesired // Copy rd bit
0000000000000000000000000000000000000000;;		dns.Response = true
0000000000000000000000000000000000000000;;		dns.Opcode = OpcodeQuery
0000000000000000000000000000000000000000;;		dns.Rcode = RcodeSuccess
0000000000000000000000000000000000000000;;		if len(request.Question) > 0 {
0000000000000000000000000000000000000000;;			dns.Question = make([]Question, 1)
0000000000000000000000000000000000000000;;			dns.Question[0] = request.Question[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetQuestion creates a question message, it sets the Question
0000000000000000000000000000000000000000;;	// section, generates an Id and sets the RecursionDesired (RD)
0000000000000000000000000000000000000000;;	// bit to true.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetQuestion(z string, t uint16) *Msg {
0000000000000000000000000000000000000000;;		dns.Id = Id()
0000000000000000000000000000000000000000;;		dns.RecursionDesired = true
0000000000000000000000000000000000000000;;		dns.Question = make([]Question, 1)
0000000000000000000000000000000000000000;;		dns.Question[0] = Question{z, t, ClassINET}
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetNotify creates a notify message, it sets the Question
0000000000000000000000000000000000000000;;	// section, generates an Id and sets the Authoritative (AA)
0000000000000000000000000000000000000000;;	// bit to true.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetNotify(z string) *Msg {
0000000000000000000000000000000000000000;;		dns.Opcode = OpcodeNotify
0000000000000000000000000000000000000000;;		dns.Authoritative = true
0000000000000000000000000000000000000000;;		dns.Id = Id()
0000000000000000000000000000000000000000;;		dns.Question = make([]Question, 1)
0000000000000000000000000000000000000000;;		dns.Question[0] = Question{z, TypeSOA, ClassINET}
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetRcode creates an error message suitable for the request.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetRcode(request *Msg, rcode int) *Msg {
0000000000000000000000000000000000000000;;		dns.SetReply(request)
0000000000000000000000000000000000000000;;		dns.Rcode = rcode
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetRcodeFormatError creates a message with FormError set.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetRcodeFormatError(request *Msg) *Msg {
0000000000000000000000000000000000000000;;		dns.Rcode = RcodeFormatError
0000000000000000000000000000000000000000;;		dns.Opcode = OpcodeQuery
0000000000000000000000000000000000000000;;		dns.Response = true
0000000000000000000000000000000000000000;;		dns.Authoritative = false
0000000000000000000000000000000000000000;;		dns.Id = request.Id
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUpdate makes the message a dynamic update message. It
0000000000000000000000000000000000000000;;	// sets the ZONE section to: z, TypeSOA, ClassINET.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetUpdate(z string) *Msg {
0000000000000000000000000000000000000000;;		dns.Id = Id()
0000000000000000000000000000000000000000;;		dns.Response = false
0000000000000000000000000000000000000000;;		dns.Opcode = OpcodeUpdate
0000000000000000000000000000000000000000;;		dns.Compress = false // BIND9 cannot handle compression
0000000000000000000000000000000000000000;;		dns.Question = make([]Question, 1)
0000000000000000000000000000000000000000;;		dns.Question[0] = Question{z, TypeSOA, ClassINET}
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetIxfr creates message for requesting an IXFR.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetIxfr(z string, serial uint32, ns, mbox string) *Msg {
0000000000000000000000000000000000000000;;		dns.Id = Id()
0000000000000000000000000000000000000000;;		dns.Question = make([]Question, 1)
0000000000000000000000000000000000000000;;		dns.Ns = make([]RR, 1)
0000000000000000000000000000000000000000;;		s := new(SOA)
0000000000000000000000000000000000000000;;		s.Hdr = RR_Header{z, TypeSOA, ClassINET, defaultTtl, 0}
0000000000000000000000000000000000000000;;		s.Serial = serial
0000000000000000000000000000000000000000;;		s.Ns = ns
0000000000000000000000000000000000000000;;		s.Mbox = mbox
0000000000000000000000000000000000000000;;		dns.Question[0] = Question{z, TypeIXFR, ClassINET}
0000000000000000000000000000000000000000;;		dns.Ns[0] = s
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetAxfr creates message for requesting an AXFR.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetAxfr(z string) *Msg {
0000000000000000000000000000000000000000;;		dns.Id = Id()
0000000000000000000000000000000000000000;;		dns.Question = make([]Question, 1)
0000000000000000000000000000000000000000;;		dns.Question[0] = Question{z, TypeAXFR, ClassINET}
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetTsig appends a TSIG RR to the message.
0000000000000000000000000000000000000000;;	// This is only a skeleton TSIG RR that is added as the last RR in the
0000000000000000000000000000000000000000;;	// additional section. The Tsig is calculated when the message is being send.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetTsig(z, algo string, fudge, timesigned int64) *Msg {
0000000000000000000000000000000000000000;;		t := new(TSIG)
0000000000000000000000000000000000000000;;		t.Hdr = RR_Header{z, TypeTSIG, ClassANY, 0, 0}
0000000000000000000000000000000000000000;;		t.Algorithm = algo
0000000000000000000000000000000000000000;;		t.Fudge = 300
0000000000000000000000000000000000000000;;		t.TimeSigned = uint64(timesigned)
0000000000000000000000000000000000000000;;		t.OrigId = dns.Id
0000000000000000000000000000000000000000;;		dns.Extra = append(dns.Extra, t)
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetEdns0 appends a EDNS0 OPT RR to the message.
0000000000000000000000000000000000000000;;	// TSIG should always the last RR in a message.
0000000000000000000000000000000000000000;;	func (dns *Msg) SetEdns0(udpsize uint16, do bool) *Msg {
0000000000000000000000000000000000000000;;		e := new(OPT)
0000000000000000000000000000000000000000;;		e.Hdr.Name = "."
0000000000000000000000000000000000000000;;		e.Hdr.Rrtype = TypeOPT
0000000000000000000000000000000000000000;;		e.SetUDPSize(udpsize)
0000000000000000000000000000000000000000;;		if do {
0000000000000000000000000000000000000000;;			e.SetDo()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		dns.Extra = append(dns.Extra, e)
0000000000000000000000000000000000000000;;		return dns
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsTsig checks if the message has a TSIG record as the last record
0000000000000000000000000000000000000000;;	// in the additional section. It returns the TSIG record found or nil.
0000000000000000000000000000000000000000;;	func (dns *Msg) IsTsig() *TSIG {
0000000000000000000000000000000000000000;;		if len(dns.Extra) > 0 {
0000000000000000000000000000000000000000;;			if dns.Extra[len(dns.Extra)-1].Header().Rrtype == TypeTSIG {
0000000000000000000000000000000000000000;;				return dns.Extra[len(dns.Extra)-1].(*TSIG)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEdns0 checks if the message has a EDNS0 (OPT) record, any EDNS0
0000000000000000000000000000000000000000;;	// record in the additional section will do. It returns the OPT record
0000000000000000000000000000000000000000;;	// found or nil.
0000000000000000000000000000000000000000;;	func (dns *Msg) IsEdns0() *OPT {
0000000000000000000000000000000000000000;;		// EDNS0 is at the end of the additional section, start there.
0000000000000000000000000000000000000000;;		// We might want to change this to *only* look at the last two
0000000000000000000000000000000000000000;;		// records. So we see TSIG and/or OPT - this a slightly bigger
0000000000000000000000000000000000000000;;		// change though.
0000000000000000000000000000000000000000;;		for i := len(dns.Extra) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			if dns.Extra[i].Header().Rrtype == TypeOPT {
0000000000000000000000000000000000000000;;				return dns.Extra[i].(*OPT)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDomainName checks if s is a valid domain name, it returns the number of
0000000000000000000000000000000000000000;;	// labels and true, when a domain name is valid.  Note that non fully qualified
0000000000000000000000000000000000000000;;	// domain name is considered valid, in this case the last label is counted in
0000000000000000000000000000000000000000;;	// the number of labels.  When false is returned the number of labels is not
0000000000000000000000000000000000000000;;	// defined.  Also note that this function is extremely liberal; almost any
0000000000000000000000000000000000000000;;	// string is a valid domain name as the DNS is 8 bit protocol. It checks if each
0000000000000000000000000000000000000000;;	// label fits in 63 characters, but there is no length check for the entire
0000000000000000000000000000000000000000;;	// string s. I.e.  a domain name longer than 255 characters is considered valid.
0000000000000000000000000000000000000000;;	func IsDomainName(s string) (labels int, ok bool) {
0000000000000000000000000000000000000000;;		_, labels, err := packDomainName(s, nil, 0, nil, false)
0000000000000000000000000000000000000000;;		return labels, err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsSubDomain checks if child is indeed a child of the parent. If child and parent
0000000000000000000000000000000000000000;;	// are the same domain true is returned as well.
0000000000000000000000000000000000000000;;	func IsSubDomain(parent, child string) bool {
0000000000000000000000000000000000000000;;		// Entire child is contained in parent
0000000000000000000000000000000000000000;;		return CompareDomainName(parent, child) == CountLabel(parent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsMsg sanity checks buf and returns an error if it isn't a valid DNS packet.
0000000000000000000000000000000000000000;;	// The checking is performed on the binary payload.
0000000000000000000000000000000000000000;;	func IsMsg(buf []byte) error {
0000000000000000000000000000000000000000;;		// Header
0000000000000000000000000000000000000000;;		if len(buf) < 12 {
0000000000000000000000000000000000000000;;			return errors.New("dns: bad message header")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Header: Opcode
0000000000000000000000000000000000000000;;		// TODO(miek): more checks here, e.g. check all header bits.
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsFqdn checks if a domain name is fully qualified.
0000000000000000000000000000000000000000;;	func IsFqdn(s string) bool {
0000000000000000000000000000000000000000;;		l := len(s)
0000000000000000000000000000000000000000;;		if l == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s[l-1] == '.'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRRset checks if a set of RRs is a valid RRset as defined by RFC 2181.
0000000000000000000000000000000000000000;;	// This means the RRs need to have the same type, name, and class. Returns true
0000000000000000000000000000000000000000;;	// if the RR set is valid, otherwise false.
0000000000000000000000000000000000000000;;	func IsRRset(rrset []RR) bool {
0000000000000000000000000000000000000000;;		if len(rrset) == 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(rrset) == 1 {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rrHeader := rrset[0].Header()
0000000000000000000000000000000000000000;;		rrType := rrHeader.Rrtype
0000000000000000000000000000000000000000;;		rrClass := rrHeader.Class
0000000000000000000000000000000000000000;;		rrName := rrHeader.Name
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, rr := range rrset[1:] {
0000000000000000000000000000000000000000;;			curRRHeader := rr.Header()
0000000000000000000000000000000000000000;;			if curRRHeader.Rrtype != rrType || curRRHeader.Class != rrClass || curRRHeader.Name != rrName {
0000000000000000000000000000000000000000;;				// Mismatch between the records, so this is not a valid rrset for
0000000000000000000000000000000000000000;;				//signing/verifying
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Fqdn return the fully qualified domain name from s.
0000000000000000000000000000000000000000;;	// If s is already fully qualified, it behaves as the identity function.
0000000000000000000000000000000000000000;;	func Fqdn(s string) string {
0000000000000000000000000000000000000000;;		if IsFqdn(s) {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s + "."
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copied from the official Go code.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReverseAddr returns the in-addr.arpa. or ip6.arpa. hostname of the IP
0000000000000000000000000000000000000000;;	// address suitable for reverse DNS (PTR) record lookups or an error if it fails
0000000000000000000000000000000000000000;;	// to parse the IP address.
0000000000000000000000000000000000000000;;	func ReverseAddr(addr string) (arpa string, err error) {
0000000000000000000000000000000000000000;;		ip := net.ParseIP(addr)
0000000000000000000000000000000000000000;;		if ip == nil {
0000000000000000000000000000000000000000;;			return "", &Error{err: "unrecognized address: " + addr}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ip.To4() != nil {
0000000000000000000000000000000000000000;;			return strconv.Itoa(int(ip[15])) + "." + strconv.Itoa(int(ip[14])) + "." + strconv.Itoa(int(ip[13])) + "." +
0000000000000000000000000000000000000000;;				strconv.Itoa(int(ip[12])) + ".in-addr.arpa.", nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Must be IPv6
0000000000000000000000000000000000000000;;		buf := make([]byte, 0, len(ip)*4+len("ip6.arpa."))
0000000000000000000000000000000000000000;;		// Add it, in reverse, to the buffer
0000000000000000000000000000000000000000;;		for i := len(ip) - 1; i >= 0; i-- {
0000000000000000000000000000000000000000;;			v := ip[i]
0000000000000000000000000000000000000000;;			buf = append(buf, hexDigit[v&0xF])
0000000000000000000000000000000000000000;;			buf = append(buf, '.')
0000000000000000000000000000000000000000;;			buf = append(buf, hexDigit[v>>4])
0000000000000000000000000000000000000000;;			buf = append(buf, '.')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Append "ip6.arpa." and return (buf already has the final .)
0000000000000000000000000000000000000000;;		buf = append(buf, "ip6.arpa."...)
0000000000000000000000000000000000000000;;		return string(buf), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation for the type t.
0000000000000000000000000000000000000000;;	func (t Type) String() string {
0000000000000000000000000000000000000000;;		if t1, ok := TypeToString[uint16(t)]; ok {
0000000000000000000000000000000000000000;;			return t1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "TYPE" + strconv.Itoa(int(t))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation for the class c.
0000000000000000000000000000000000000000;;	func (c Class) String() string {
0000000000000000000000000000000000000000;;		if c1, ok := ClassToString[uint16(c)]; ok {
0000000000000000000000000000000000000000;;			return c1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "CLASS" + strconv.Itoa(int(c))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the string representation for the name n.
0000000000000000000000000000000000000000;;	func (n Name) String() string {
0000000000000000000000000000000000000000;;		return sprintName(string(n))
0000000000000000000000000000000000000000;;	}
