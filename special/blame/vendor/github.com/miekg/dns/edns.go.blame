0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/edns.go[Godeps/_workspace/src/github.com/miekg/dns/edns.go][vendor/github.com/miekg/dns/edns.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EDNS0 Option codes.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EDNS0LLQ         = 0x1     // long lived queries: http://tools.ietf.org/html/draft-sekar-dns-llq-01
0000000000000000000000000000000000000000;;		EDNS0UL          = 0x2     // update lease draft: http://files.dns-sd.org/draft-sekar-dns-ul.txt
0000000000000000000000000000000000000000;;		EDNS0NSID        = 0x3     // nsid (RFC5001)
0000000000000000000000000000000000000000;;		EDNS0DAU         = 0x5     // DNSSEC Algorithm Understood
0000000000000000000000000000000000000000;;		EDNS0DHU         = 0x6     // DS Hash Understood
0000000000000000000000000000000000000000;;		EDNS0N3U         = 0x7     // NSEC3 Hash Understood
0000000000000000000000000000000000000000;;		EDNS0SUBNET      = 0x8     // client-subnet (RFC6891)
0000000000000000000000000000000000000000;;		EDNS0EXPIRE      = 0x9     // EDNS0 expire
0000000000000000000000000000000000000000;;		EDNS0COOKIE      = 0xa     // EDNS0 Cookie
0000000000000000000000000000000000000000;;		EDNS0SUBNETDRAFT = 0x50fa  // Don't use! Use EDNS0SUBNET
0000000000000000000000000000000000000000;;		EDNS0LOCALSTART  = 0xFDE9  // Beginning of range reserved for local/experimental use (RFC6891)
0000000000000000000000000000000000000000;;		EDNS0LOCALEND    = 0xFFFE  // End of range reserved for local/experimental use (RFC6891)
0000000000000000000000000000000000000000;;		_DO              = 1 << 15 // dnssec ok
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OPT is the EDNS0 RR appended to messages to convey extra (meta) information.
0000000000000000000000000000000000000000;;	// See RFC 6891.
0000000000000000000000000000000000000000;;	type OPT struct {
0000000000000000000000000000000000000000;;		Hdr    RR_Header
0000000000000000000000000000000000000000;;		Option []EDNS0 `dns:"opt"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *OPT) String() string {
0000000000000000000000000000000000000000;;		s := "\n;; OPT PSEUDOSECTION:\n; EDNS: version " + strconv.Itoa(int(rr.Version())) + "; "
0000000000000000000000000000000000000000;;		if rr.Do() {
0000000000000000000000000000000000000000;;			s += "flags: do; "
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s += "flags: ; "
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s += "udp: " + strconv.Itoa(int(rr.UDPSize()))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, o := range rr.Option {
0000000000000000000000000000000000000000;;			switch o.(type) {
0000000000000000000000000000000000000000;;			case *EDNS0_NSID:
0000000000000000000000000000000000000000;;				s += "\n; NSID: " + o.String()
0000000000000000000000000000000000000000;;				h, e := o.pack()
0000000000000000000000000000000000000000;;				var r string
0000000000000000000000000000000000000000;;				if e == nil {
0000000000000000000000000000000000000000;;					for _, c := range h {
0000000000000000000000000000000000000000;;						r += "(" + string(c) + ")"
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					s += "  " + r
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *EDNS0_SUBNET:
0000000000000000000000000000000000000000;;				s += "\n; SUBNET: " + o.String()
0000000000000000000000000000000000000000;;				if o.(*EDNS0_SUBNET).DraftOption {
0000000000000000000000000000000000000000;;					s += " (draft)"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case *EDNS0_COOKIE:
0000000000000000000000000000000000000000;;				s += "\n; COOKIE: " + o.String()
0000000000000000000000000000000000000000;;			case *EDNS0_UL:
0000000000000000000000000000000000000000;;				s += "\n; UPDATE LEASE: " + o.String()
0000000000000000000000000000000000000000;;			case *EDNS0_LLQ:
0000000000000000000000000000000000000000;;				s += "\n; LONG LIVED QUERIES: " + o.String()
0000000000000000000000000000000000000000;;			case *EDNS0_DAU:
0000000000000000000000000000000000000000;;				s += "\n; DNSSEC ALGORITHM UNDERSTOOD: " + o.String()
0000000000000000000000000000000000000000;;			case *EDNS0_DHU:
0000000000000000000000000000000000000000;;				s += "\n; DS HASH UNDERSTOOD: " + o.String()
0000000000000000000000000000000000000000;;			case *EDNS0_N3U:
0000000000000000000000000000000000000000;;				s += "\n; NSEC3 HASH UNDERSTOOD: " + o.String()
0000000000000000000000000000000000000000;;			case *EDNS0_LOCAL:
0000000000000000000000000000000000000000;;				s += "\n; LOCAL OPT: " + o.String()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (rr *OPT) len() int {
0000000000000000000000000000000000000000;;		l := rr.Hdr.len()
0000000000000000000000000000000000000000;;		for i := 0; i < len(rr.Option); i++ {
0000000000000000000000000000000000000000;;			l += 4 // Account for 2-byte option code and 2-byte option length.
0000000000000000000000000000000000000000;;			lo, _ := rr.Option[i].pack()
0000000000000000000000000000000000000000;;			l += len(lo)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return l
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// return the old value -> delete SetVersion?
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version returns the EDNS version used. Only zero is defined.
0000000000000000000000000000000000000000;;	func (rr *OPT) Version() uint8 {
0000000000000000000000000000000000000000;;		return uint8((rr.Hdr.Ttl & 0x00FF0000) >> 16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetVersion sets the version of EDNS. This is usually zero.
0000000000000000000000000000000000000000;;	func (rr *OPT) SetVersion(v uint8) {
0000000000000000000000000000000000000000;;		rr.Hdr.Ttl = rr.Hdr.Ttl&0xFF00FFFF | (uint32(v) << 16)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtendedRcode returns the EDNS extended RCODE field (the upper 8 bits of the TTL).
0000000000000000000000000000000000000000;;	func (rr *OPT) ExtendedRcode() int {
0000000000000000000000000000000000000000;;		return int((rr.Hdr.Ttl&0xFF000000)>>24) + 15
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetExtendedRcode sets the EDNS extended RCODE field.
0000000000000000000000000000000000000000;;	func (rr *OPT) SetExtendedRcode(v uint8) {
0000000000000000000000000000000000000000;;		if v < RcodeBadVers { // Smaller than 16.. Use the 4 bits you have!
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Hdr.Ttl = rr.Hdr.Ttl&0x00FFFFFF | (uint32(v-15) << 24)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UDPSize returns the UDP buffer size.
0000000000000000000000000000000000000000;;	func (rr *OPT) UDPSize() uint16 {
0000000000000000000000000000000000000000;;		return rr.Hdr.Class
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetUDPSize sets the UDP buffer size.
0000000000000000000000000000000000000000;;	func (rr *OPT) SetUDPSize(size uint16) {
0000000000000000000000000000000000000000;;		rr.Hdr.Class = size
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Do returns the value of the DO (DNSSEC OK) bit.
0000000000000000000000000000000000000000;;	func (rr *OPT) Do() bool {
0000000000000000000000000000000000000000;;		return rr.Hdr.Ttl&_DO == _DO
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetDo sets the DO (DNSSEC OK) bit.
0000000000000000000000000000000000000000;;	func (rr *OPT) SetDo() {
0000000000000000000000000000000000000000;;		rr.Hdr.Ttl |= _DO
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EDNS0 defines an EDNS0 Option. An OPT RR can have multiple options appended to it.
0000000000000000000000000000000000000000;;	type EDNS0 interface {
0000000000000000000000000000000000000000;;		// Option returns the option code for the option.
0000000000000000000000000000000000000000;;		Option() uint16
0000000000000000000000000000000000000000;;		// pack returns the bytes of the option data.
0000000000000000000000000000000000000000;;		pack() ([]byte, error)
0000000000000000000000000000000000000000;;		// unpack sets the data as found in the buffer. Is also sets
0000000000000000000000000000000000000000;;		// the length of the slice as the length of the option data.
0000000000000000000000000000000000000000;;		unpack([]byte) error
0000000000000000000000000000000000000000;;		// String returns the string representation of the option.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The nsid EDNS0 option is used to retrieve a nameserver
0000000000000000000000000000000000000000;;	// identifier. When sending a request Nsid must be set to the empty string
0000000000000000000000000000000000000000;;	// The identifier is an opaque string encoded as hex.
0000000000000000000000000000000000000000;;	// Basic use pattern for creating an nsid option:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	o := new(dns.OPT)
0000000000000000000000000000000000000000;;	//	o.Hdr.Name = "."
0000000000000000000000000000000000000000;;	//	o.Hdr.Rrtype = dns.TypeOPT
0000000000000000000000000000000000000000;;	//	e := new(dns.EDNS0_NSID)
0000000000000000000000000000000000000000;;	//	e.Code = dns.EDNS0NSID
0000000000000000000000000000000000000000;;	//	e.Nsid = "AA"
0000000000000000000000000000000000000000;;	//	o.Option = append(o.Option, e)
0000000000000000000000000000000000000000;;	type EDNS0_NSID struct {
0000000000000000000000000000000000000000;;		Code uint16 // Always EDNS0NSID
0000000000000000000000000000000000000000;;		Nsid string // This string needs to be hex encoded
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_NSID) pack() ([]byte, error) {
0000000000000000000000000000000000000000;;		h, err := hex.DecodeString(e.Nsid)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_NSID) Option() uint16        { return EDNS0NSID }
0000000000000000000000000000000000000000;;	func (e *EDNS0_NSID) unpack(b []byte) error { e.Nsid = hex.EncodeToString(b); return nil }
0000000000000000000000000000000000000000;;	func (e *EDNS0_NSID) String() string        { return string(e.Nsid) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EDNS0_SUBNET is the subnet option that is used to give the remote nameserver
0000000000000000000000000000000000000000;;	// an idea of where the client lives. It can then give back a different
0000000000000000000000000000000000000000;;	// answer depending on the location or network topology.
0000000000000000000000000000000000000000;;	// Basic use pattern for creating an subnet option:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	o := new(dns.OPT)
0000000000000000000000000000000000000000;;	//	o.Hdr.Name = "."
0000000000000000000000000000000000000000;;	//	o.Hdr.Rrtype = dns.TypeOPT
0000000000000000000000000000000000000000;;	//	e := new(dns.EDNS0_SUBNET)
0000000000000000000000000000000000000000;;	//	e.Code = dns.EDNS0SUBNET
0000000000000000000000000000000000000000;;	//	e.Family = 1	// 1 for IPv4 source address, 2 for IPv6
0000000000000000000000000000000000000000;;	//	e.NetMask = 32	// 32 for IPV4, 128 for IPv6
0000000000000000000000000000000000000000;;	//	e.SourceScope = 0
0000000000000000000000000000000000000000;;	//	e.Address = net.ParseIP("127.0.0.1").To4()	// for IPv4
0000000000000000000000000000000000000000;;	//	// e.Address = net.ParseIP("2001:7b8:32a::2")	// for IPV6
0000000000000000000000000000000000000000;;	//	o.Option = append(o.Option, e)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: the spec (draft-ietf-dnsop-edns-client-subnet-00) has some insane logic
0000000000000000000000000000000000000000;;	// for which netmask applies to the address. This code will parse all the
0000000000000000000000000000000000000000;;	// available bits when unpacking (up to optlen). When packing it will apply
0000000000000000000000000000000000000000;;	// SourceNetmask. If you need more advanced logic, patches welcome and good luck.
0000000000000000000000000000000000000000;;	type EDNS0_SUBNET struct {
0000000000000000000000000000000000000000;;		Code          uint16 // Always EDNS0SUBNET
0000000000000000000000000000000000000000;;		Family        uint16 // 1 for IP, 2 for IP6
0000000000000000000000000000000000000000;;		SourceNetmask uint8
0000000000000000000000000000000000000000;;		SourceScope   uint8
0000000000000000000000000000000000000000;;		Address       net.IP
0000000000000000000000000000000000000000;;		DraftOption   bool // Set to true if using the old (0x50fa) option code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_SUBNET) Option() uint16 {
0000000000000000000000000000000000000000;;		if e.DraftOption {
0000000000000000000000000000000000000000;;			return EDNS0SUBNETDRAFT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return EDNS0SUBNET
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_SUBNET) pack() ([]byte, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(b[0:], e.Family)
0000000000000000000000000000000000000000;;		b[2] = e.SourceNetmask
0000000000000000000000000000000000000000;;		b[3] = e.SourceScope
0000000000000000000000000000000000000000;;		switch e.Family {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			if e.SourceNetmask > net.IPv4len*8 {
0000000000000000000000000000000000000000;;				return nil, errors.New("dns: bad netmask")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(e.Address.To4()) != net.IPv4len {
0000000000000000000000000000000000000000;;				return nil, errors.New("dns: bad address")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ip := e.Address.To4().Mask(net.CIDRMask(int(e.SourceNetmask), net.IPv4len*8))
0000000000000000000000000000000000000000;;			needLength := (e.SourceNetmask + 8 - 1) / 8 // division rounding up
0000000000000000000000000000000000000000;;			b = append(b, ip[:needLength]...)
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			if e.SourceNetmask > net.IPv6len*8 {
0000000000000000000000000000000000000000;;				return nil, errors.New("dns: bad netmask")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(e.Address) != net.IPv6len {
0000000000000000000000000000000000000000;;				return nil, errors.New("dns: bad address")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ip := e.Address.Mask(net.CIDRMask(int(e.SourceNetmask), net.IPv6len*8))
0000000000000000000000000000000000000000;;			needLength := (e.SourceNetmask + 8 - 1) / 8 // division rounding up
0000000000000000000000000000000000000000;;			b = append(b, ip[:needLength]...)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, errors.New("dns: bad address family")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_SUBNET) unpack(b []byte) error {
0000000000000000000000000000000000000000;;		if len(b) < 4 {
0000000000000000000000000000000000000000;;			return ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.Family = binary.BigEndian.Uint16(b)
0000000000000000000000000000000000000000;;		e.SourceNetmask = b[2]
0000000000000000000000000000000000000000;;		e.SourceScope = b[3]
0000000000000000000000000000000000000000;;		switch e.Family {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			if e.SourceNetmask > net.IPv4len*8 || e.SourceScope > net.IPv4len*8 {
0000000000000000000000000000000000000000;;				return errors.New("dns: bad netmask")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addr := make([]byte, net.IPv4len)
0000000000000000000000000000000000000000;;			for i := 0; i < net.IPv4len && 4+i < len(b); i++ {
0000000000000000000000000000000000000000;;				addr[i] = b[4+i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.Address = net.IPv4(addr[0], addr[1], addr[2], addr[3])
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			if e.SourceNetmask > net.IPv6len*8 || e.SourceScope > net.IPv6len*8 {
0000000000000000000000000000000000000000;;				return errors.New("dns: bad netmask")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			addr := make([]byte, net.IPv6len)
0000000000000000000000000000000000000000;;			for i := 0; i < net.IPv6len && 4+i < len(b); i++ {
0000000000000000000000000000000000000000;;				addr[i] = b[4+i]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			e.Address = net.IP{addr[0], addr[1], addr[2], addr[3], addr[4],
0000000000000000000000000000000000000000;;				addr[5], addr[6], addr[7], addr[8], addr[9], addr[10],
0000000000000000000000000000000000000000;;				addr[11], addr[12], addr[13], addr[14], addr[15]}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.New("dns: bad address family")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_SUBNET) String() (s string) {
0000000000000000000000000000000000000000;;		if e.Address == nil {
0000000000000000000000000000000000000000;;			s = "<nil>"
0000000000000000000000000000000000000000;;		} else if e.Address.To4() != nil {
0000000000000000000000000000000000000000;;			s = e.Address.String()
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			s = "[" + e.Address.String() + "]"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s += "/" + strconv.Itoa(int(e.SourceNetmask)) + "/" + strconv.Itoa(int(e.SourceScope))
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The Cookie EDNS0 option
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	o := new(dns.OPT)
0000000000000000000000000000000000000000;;	//	o.Hdr.Name = "."
0000000000000000000000000000000000000000;;	//	o.Hdr.Rrtype = dns.TypeOPT
0000000000000000000000000000000000000000;;	//	e := new(dns.EDNS0_COOKIE)
0000000000000000000000000000000000000000;;	//	e.Code = dns.EDNS0COOKIE
0000000000000000000000000000000000000000;;	//	e.Cookie = "24a5ac.."
0000000000000000000000000000000000000000;;	//	o.Option = append(o.Option, e)
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Cookie field consists out of a client cookie (RFC 7873 Section 4), that is
0000000000000000000000000000000000000000;;	// always 8 bytes. It may then optionally be followed by the server cookie. The server
0000000000000000000000000000000000000000;;	// cookie is of variable length, 8 to a maximum of 32 bytes. In other words:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	cCookie := o.Cookie[:16]
0000000000000000000000000000000000000000;;	//	sCookie := o.Cookie[16:]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// There is no guarantee that the Cookie string has a specific length.
0000000000000000000000000000000000000000;;	type EDNS0_COOKIE struct {
0000000000000000000000000000000000000000;;		Code   uint16 // Always EDNS0COOKIE
0000000000000000000000000000000000000000;;		Cookie string // Hex-encoded cookie data
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_COOKIE) pack() ([]byte, error) {
0000000000000000000000000000000000000000;;		h, err := hex.DecodeString(e.Cookie)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return h, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_COOKIE) Option() uint16        { return EDNS0COOKIE }
0000000000000000000000000000000000000000;;	func (e *EDNS0_COOKIE) unpack(b []byte) error { e.Cookie = hex.EncodeToString(b); return nil }
0000000000000000000000000000000000000000;;	func (e *EDNS0_COOKIE) String() string        { return e.Cookie }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The EDNS0_UL (Update Lease) (draft RFC) option is used to tell the server to set
0000000000000000000000000000000000000000;;	// an expiration on an update RR. This is helpful for clients that cannot clean
0000000000000000000000000000000000000000;;	// up after themselves. This is a draft RFC and more information can be found at
0000000000000000000000000000000000000000;;	// http://files.dns-sd.org/draft-sekar-dns-ul.txt
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	o := new(dns.OPT)
0000000000000000000000000000000000000000;;	//	o.Hdr.Name = "."
0000000000000000000000000000000000000000;;	//	o.Hdr.Rrtype = dns.TypeOPT
0000000000000000000000000000000000000000;;	//	e := new(dns.EDNS0_UL)
0000000000000000000000000000000000000000;;	//	e.Code = dns.EDNS0UL
0000000000000000000000000000000000000000;;	//	e.Lease = 120 // in seconds
0000000000000000000000000000000000000000;;	//	o.Option = append(o.Option, e)
0000000000000000000000000000000000000000;;	type EDNS0_UL struct {
0000000000000000000000000000000000000000;;		Code  uint16 // Always EDNS0UL
0000000000000000000000000000000000000000;;		Lease uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_UL) Option() uint16 { return EDNS0UL }
0000000000000000000000000000000000000000;;	func (e *EDNS0_UL) String() string { return strconv.FormatUint(uint64(e.Lease), 10) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Copied: http://golang.org/src/pkg/net/dnsmsg.go
0000000000000000000000000000000000000000;;	func (e *EDNS0_UL) pack() ([]byte, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(b, e.Lease)
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_UL) unpack(b []byte) error {
0000000000000000000000000000000000000000;;		if len(b) < 4 {
0000000000000000000000000000000000000000;;			return ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.Lease = binary.BigEndian.Uint32(b)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EDNS0_LLQ stands for Long Lived Queries: http://tools.ietf.org/html/draft-sekar-dns-llq-01
0000000000000000000000000000000000000000;;	// Implemented for completeness, as the EDNS0 type code is assigned.
0000000000000000000000000000000000000000;;	type EDNS0_LLQ struct {
0000000000000000000000000000000000000000;;		Code      uint16 // Always EDNS0LLQ
0000000000000000000000000000000000000000;;		Version   uint16
0000000000000000000000000000000000000000;;		Opcode    uint16
0000000000000000000000000000000000000000;;		Error     uint16
0000000000000000000000000000000000000000;;		Id        uint64
0000000000000000000000000000000000000000;;		LeaseLife uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_LLQ) Option() uint16 { return EDNS0LLQ }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_LLQ) pack() ([]byte, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, 18)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(b[0:], e.Version)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(b[2:], e.Opcode)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(b[4:], e.Error)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(b[6:], e.Id)
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(b[14:], e.LeaseLife)
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_LLQ) unpack(b []byte) error {
0000000000000000000000000000000000000000;;		if len(b) < 18 {
0000000000000000000000000000000000000000;;			return ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.Version = binary.BigEndian.Uint16(b[0:])
0000000000000000000000000000000000000000;;		e.Opcode = binary.BigEndian.Uint16(b[2:])
0000000000000000000000000000000000000000;;		e.Error = binary.BigEndian.Uint16(b[4:])
0000000000000000000000000000000000000000;;		e.Id = binary.BigEndian.Uint64(b[6:])
0000000000000000000000000000000000000000;;		e.LeaseLife = binary.BigEndian.Uint32(b[14:])
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_LLQ) String() string {
0000000000000000000000000000000000000000;;		s := strconv.FormatUint(uint64(e.Version), 10) + " " + strconv.FormatUint(uint64(e.Opcode), 10) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatUint(uint64(e.Error), 10) + " " + strconv.FormatUint(uint64(e.Id), 10) +
0000000000000000000000000000000000000000;;			" " + strconv.FormatUint(uint64(e.LeaseLife), 10)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EDNS0_DAU struct {
0000000000000000000000000000000000000000;;		Code    uint16 // Always EDNS0DAU
0000000000000000000000000000000000000000;;		AlgCode []uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_DAU) Option() uint16        { return EDNS0DAU }
0000000000000000000000000000000000000000;;	func (e *EDNS0_DAU) pack() ([]byte, error) { return e.AlgCode, nil }
0000000000000000000000000000000000000000;;	func (e *EDNS0_DAU) unpack(b []byte) error { e.AlgCode = b; return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_DAU) String() string {
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		for i := 0; i < len(e.AlgCode); i++ {
0000000000000000000000000000000000000000;;			if a, ok := AlgorithmToString[e.AlgCode[i]]; ok {
0000000000000000000000000000000000000000;;				s += " " + a
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s += " " + strconv.Itoa(int(e.AlgCode[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EDNS0_DHU struct {
0000000000000000000000000000000000000000;;		Code    uint16 // Always EDNS0DHU
0000000000000000000000000000000000000000;;		AlgCode []uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_DHU) Option() uint16        { return EDNS0DHU }
0000000000000000000000000000000000000000;;	func (e *EDNS0_DHU) pack() ([]byte, error) { return e.AlgCode, nil }
0000000000000000000000000000000000000000;;	func (e *EDNS0_DHU) unpack(b []byte) error { e.AlgCode = b; return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_DHU) String() string {
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		for i := 0; i < len(e.AlgCode); i++ {
0000000000000000000000000000000000000000;;			if a, ok := HashToString[e.AlgCode[i]]; ok {
0000000000000000000000000000000000000000;;				s += " " + a
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s += " " + strconv.Itoa(int(e.AlgCode[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EDNS0_N3U struct {
0000000000000000000000000000000000000000;;		Code    uint16 // Always EDNS0N3U
0000000000000000000000000000000000000000;;		AlgCode []uint8
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_N3U) Option() uint16        { return EDNS0N3U }
0000000000000000000000000000000000000000;;	func (e *EDNS0_N3U) pack() ([]byte, error) { return e.AlgCode, nil }
0000000000000000000000000000000000000000;;	func (e *EDNS0_N3U) unpack(b []byte) error { e.AlgCode = b; return nil }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_N3U) String() string {
0000000000000000000000000000000000000000;;		// Re-use the hash map
0000000000000000000000000000000000000000;;		s := ""
0000000000000000000000000000000000000000;;		for i := 0; i < len(e.AlgCode); i++ {
0000000000000000000000000000000000000000;;			if a, ok := HashToString[e.AlgCode[i]]; ok {
0000000000000000000000000000000000000000;;				s += " " + a
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				s += " " + strconv.Itoa(int(e.AlgCode[i]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type EDNS0_EXPIRE struct {
0000000000000000000000000000000000000000;;		Code   uint16 // Always EDNS0EXPIRE
0000000000000000000000000000000000000000;;		Expire uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_EXPIRE) Option() uint16 { return EDNS0EXPIRE }
0000000000000000000000000000000000000000;;	func (e *EDNS0_EXPIRE) String() string { return strconv.FormatUint(uint64(e.Expire), 10) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_EXPIRE) pack() ([]byte, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, 4)
0000000000000000000000000000000000000000;;		b[0] = byte(e.Expire >> 24)
0000000000000000000000000000000000000000;;		b[1] = byte(e.Expire >> 16)
0000000000000000000000000000000000000000;;		b[2] = byte(e.Expire >> 8)
0000000000000000000000000000000000000000;;		b[3] = byte(e.Expire)
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_EXPIRE) unpack(b []byte) error {
0000000000000000000000000000000000000000;;		if len(b) < 4 {
0000000000000000000000000000000000000000;;			return ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		e.Expire = binary.BigEndian.Uint32(b)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The EDNS0_LOCAL option is used for local/experimental purposes. The option
0000000000000000000000000000000000000000;;	// code is recommended to be within the range [EDNS0LOCALSTART, EDNS0LOCALEND]
0000000000000000000000000000000000000000;;	// (RFC6891), although any unassigned code can actually be used.  The content of
0000000000000000000000000000000000000000;;	// the option is made available in Data, unaltered.
0000000000000000000000000000000000000000;;	// Basic use pattern for creating a local option:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	o := new(dns.OPT)
0000000000000000000000000000000000000000;;	//	o.Hdr.Name = "."
0000000000000000000000000000000000000000;;	//	o.Hdr.Rrtype = dns.TypeOPT
0000000000000000000000000000000000000000;;	//	e := new(dns.EDNS0_LOCAL)
0000000000000000000000000000000000000000;;	//	e.Code = dns.EDNS0LOCALSTART
0000000000000000000000000000000000000000;;	//	e.Data = []byte{72, 82, 74}
0000000000000000000000000000000000000000;;	//	o.Option = append(o.Option, e)
0000000000000000000000000000000000000000;;	type EDNS0_LOCAL struct {
0000000000000000000000000000000000000000;;		Code uint16
0000000000000000000000000000000000000000;;		Data []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_LOCAL) Option() uint16 { return e.Code }
0000000000000000000000000000000000000000;;	func (e *EDNS0_LOCAL) String() string {
0000000000000000000000000000000000000000;;		return strconv.FormatInt(int64(e.Code), 10) + ":0x" + hex.EncodeToString(e.Data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_LOCAL) pack() ([]byte, error) {
0000000000000000000000000000000000000000;;		b := make([]byte, len(e.Data))
0000000000000000000000000000000000000000;;		copied := copy(b, e.Data)
0000000000000000000000000000000000000000;;		if copied != len(e.Data) {
0000000000000000000000000000000000000000;;			return nil, ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *EDNS0_LOCAL) unpack(b []byte) error {
0000000000000000000000000000000000000000;;		e.Data = make([]byte, len(b))
0000000000000000000000000000000000000000;;		copied := copy(e.Data, b)
0000000000000000000000000000000000000000;;		if copied != len(b) {
0000000000000000000000000000000000000000;;			return ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
