0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package dns implements a full featured interface to the Domain Name System.
0000000000000000000000000000000000000000;;	Server- and client-side programming is supported.
0000000000000000000000000000000000000000;;	The package allows complete control over what is send out to the DNS. The package
0000000000000000000000000000000000000000;;	API follows the less-is-more principle, by presenting a small, clean interface.
b9f13aaa534682ec2030ddaa4366d37857ab7cbb;;	
0000000000000000000000000000000000000000;;	The package dns supports (asynchronous) querying/replying, incoming/outgoing zone transfers,
0000000000000000000000000000000000000000;;	TSIG, EDNS0, dynamic updates, notifies and DNSSEC validation/signing.
0000000000000000000000000000000000000000;;	Note that domain names MUST be fully qualified, before sending them, unqualified
0000000000000000000000000000000000000000;;	names in a message will result in a packing failure.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Resource records are native types. They are not stored in wire format.
0000000000000000000000000000000000000000;;	Basic usage pattern for creating a new resource record:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     r := new(dns.MX)
0000000000000000000000000000000000000000;;	     r.Hdr = dns.RR_Header{Name: "miek.nl.", Rrtype: dns.TypeMX,
0000000000000000000000000000000000000000;;		Class: dns.ClassINET, Ttl: 3600}
0000000000000000000000000000000000000000;;	     r.Preference = 10
0000000000000000000000000000000000000000;;	     r.Mx = "mx.miek.nl."
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Or directly from a string:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     mx, err := dns.NewRR("miek.nl. 3600 IN MX 10 mx.miek.nl.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Or when the default TTL (3600) and class (IN) suit you:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     mx, err := dns.NewRR("miek.nl. MX 10 mx.miek.nl.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Or even:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     mx, err := dns.NewRR("$ORIGIN nl.\nmiek 1H IN MX 10 mx.miek")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	In the DNS messages are exchanged, these messages contain resource
0000000000000000000000000000000000000000;;	records (sets).  Use pattern for creating a message:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     m := new(dns.Msg)
0000000000000000000000000000000000000000;;	     m.SetQuestion("miek.nl.", dns.TypeMX)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Or when not certain if the domain name is fully qualified:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m.SetQuestion(dns.Fqdn("miek.nl"), dns.TypeMX)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The message m is now a message with the question section set to ask
0000000000000000000000000000000000000000;;	the MX records for the miek.nl. zone.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The following is slightly more verbose, but more flexible:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     m1 := new(dns.Msg)
0000000000000000000000000000000000000000;;	     m1.Id = dns.Id()
0000000000000000000000000000000000000000;;	     m1.RecursionDesired = true
0000000000000000000000000000000000000000;;	     m1.Question = make([]dns.Question, 1)
0000000000000000000000000000000000000000;;	     m1.Question[0] = dns.Question{"miek.nl.", dns.TypeMX, dns.ClassINET}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	After creating a message it can be send.
0000000000000000000000000000000000000000;;	Basic use pattern for synchronous querying the DNS at a
0000000000000000000000000000000000000000;;	server configured on 127.0.0.1 and port 53:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     c := new(dns.Client)
0000000000000000000000000000000000000000;;	     in, rtt, err := c.Exchange(m1, "127.0.0.1:53")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Suppressing multiple outstanding queries (with the same question, type and
0000000000000000000000000000000000000000;;	class) is as easy as setting:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c.SingleInflight = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	If these "advanced" features are not needed, a simple UDP query can be send,
0000000000000000000000000000000000000000;;	with:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		in, err := dns.Exchange(m1, "127.0.0.1:53")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When this functions returns you will get dns message. A dns message consists
0000000000000000000000000000000000000000;;	out of four sections.
0000000000000000000000000000000000000000;;	The question section: in.Question, the answer section: in.Answer,
0000000000000000000000000000000000000000;;	the authority section: in.Ns and the additional section: in.Extra.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Each of these sections (except the Question section) contain a []RR. Basic
0000000000000000000000000000000000000000;;	use pattern for accessing the rdata of a TXT RR as the first RR in
0000000000000000000000000000000000000000;;	the Answer section:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t, ok := in.Answer[0].(*dns.TXT); ok {
0000000000000000000000000000000000000000;;			// do something with t.Txt
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Domain Name and TXT Character String Representations
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Both domain names and TXT character strings are converted to presentation
0000000000000000000000000000000000000000;;	form both when unpacked and when converted to strings.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For TXT character strings, tabs, carriage returns and line feeds will be
0000000000000000000000000000000000000000;;	converted to \t, \r and \n respectively. Back slashes and quotations marks
0000000000000000000000000000000000000000;;	will be escaped. Bytes below 32 and above 127 will be converted to \DDD
0000000000000000000000000000000000000000;;	form.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	For domain names, in addition to the above rules brackets, periods,
0000000000000000000000000000000000000000;;	spaces, semicolons and the at symbol are escaped.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	DNSSEC
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	DNSSEC (DNS Security Extension) adds a layer of security to the DNS. It
0000000000000000000000000000000000000000;;	uses public key cryptography to sign resource records. The
0000000000000000000000000000000000000000;;	public keys are stored in DNSKEY records and the signatures in RRSIG records.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Requesting DNSSEC information for a zone is done by adding the DO (DNSSEC OK) bit
0000000000000000000000000000000000000000;;	to a request.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	     m := new(dns.Msg)
0000000000000000000000000000000000000000;;	     m.SetEdns0(4096, true)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Signature generation, signature verification and key generation are all supported.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	DYNAMIC UPDATES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Dynamic updates reuses the DNS message format, but renames three of
0000000000000000000000000000000000000000;;	the sections. Question is Zone, Answer is Prerequisite, Authority is
0000000000000000000000000000000000000000;;	Update, only the Additional is not renamed. See RFC 2136 for the gory details.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can set a rather complex set of rules for the existence of absence of
0000000000000000000000000000000000000000;;	certain resource records or names in a zone to specify if resource records
0000000000000000000000000000000000000000;;	should be added or removed. The table from RFC 2136 supplemented with the Go
0000000000000000000000000000000000000000;;	DNS function shows which functions exist to specify the prerequisites.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 3.2.4 - Table Of Metavalues Used In Prerequisite Section
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  CLASS    TYPE     RDATA    Meaning                    Function
0000000000000000000000000000000000000000;;	  --------------------------------------------------------------
0000000000000000000000000000000000000000;;	  ANY      ANY      empty    Name is in use             dns.NameUsed
0000000000000000000000000000000000000000;;	  ANY      rrset    empty    RRset exists (value indep) dns.RRsetUsed
0000000000000000000000000000000000000000;;	  NONE     ANY      empty    Name is not in use         dns.NameNotUsed
0000000000000000000000000000000000000000;;	  NONE     rrset    empty    RRset does not exist       dns.RRsetNotUsed
0000000000000000000000000000000000000000;;	  zone     rrset    rr       RRset exists (value dep)   dns.Used
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The prerequisite section can also be left empty.
0000000000000000000000000000000000000000;;	If you have decided on the prerequisites you can tell what RRs should
0000000000000000000000000000000000000000;;	be added or deleted. The next table shows the options you have and
0000000000000000000000000000000000000000;;	what functions to call.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	 3.4.2.6 - Table Of Metavalues Used In Update Section
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  CLASS    TYPE     RDATA    Meaning                     Function
0000000000000000000000000000000000000000;;	  ---------------------------------------------------------------
0000000000000000000000000000000000000000;;	  ANY      ANY      empty    Delete all RRsets from name dns.RemoveName
0000000000000000000000000000000000000000;;	  ANY      rrset    empty    Delete an RRset             dns.RemoveRRset
0000000000000000000000000000000000000000;;	  NONE     rrset    rr       Delete an RR from RRset     dns.Remove
0000000000000000000000000000000000000000;;	  zone     rrset    rr       Add to an RRset             dns.Insert
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	TRANSACTION SIGNATURE
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	An TSIG or transaction signature adds a HMAC TSIG record to each message sent.
0000000000000000000000000000000000000000;;	The supported algorithms include: HmacMD5, HmacSHA1, HmacSHA256 and HmacSHA512.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Basic use pattern when querying with a TSIG name "axfr." (note that these key names
0000000000000000000000000000000000000000;;	must be fully qualified - as they are domain names) and the base64 secret
0000000000000000000000000000000000000000;;	"so6ZGir4GPAqINNh9U5c3A==":
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := new(dns.Client)
0000000000000000000000000000000000000000;;		c.TsigSecret = map[string]string{"axfr.": "so6ZGir4GPAqINNh9U5c3A=="}
0000000000000000000000000000000000000000;;		m := new(dns.Msg)
0000000000000000000000000000000000000000;;		m.SetQuestion("miek.nl.", dns.TypeMX)
0000000000000000000000000000000000000000;;		m.SetTsig("axfr.", dns.HmacMD5, 300, time.Now().Unix())
0000000000000000000000000000000000000000;;		...
0000000000000000000000000000000000000000;;		// When sending the TSIG RR is calculated and filled in before sending
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	When requesting an zone transfer (almost all TSIG usage is when requesting zone transfers), with
0000000000000000000000000000000000000000;;	TSIG, this is the basic use pattern. In this example we request an AXFR for
0000000000000000000000000000000000000000;;	miek.nl. with TSIG key named "axfr." and secret "so6ZGir4GPAqINNh9U5c3A=="
0000000000000000000000000000000000000000;;	and using the server 176.58.119.54:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := new(dns.Transfer)
0000000000000000000000000000000000000000;;		m := new(dns.Msg)
0000000000000000000000000000000000000000;;		t.TsigSecret = map[string]string{"axfr.": "so6ZGir4GPAqINNh9U5c3A=="}
0000000000000000000000000000000000000000;;		m.SetAxfr("miek.nl.")
0000000000000000000000000000000000000000;;		m.SetTsig("axfr.", dns.HmacMD5, 300, time.Now().Unix())
0000000000000000000000000000000000000000;;		c, err := t.In(m, "176.58.119.54:53")
0000000000000000000000000000000000000000;;		for r := range c { ... }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	You can now read the records from the transfer as they come in. Each envelope is checked with TSIG.
0000000000000000000000000000000000000000;;	If something is not correct an error is returned.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Basic use pattern validating and replying to a message that has TSIG set.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server := &dns.Server{Addr: ":53", Net: "udp"}
0000000000000000000000000000000000000000;;		server.TsigSecret = map[string]string{"axfr.": "so6ZGir4GPAqINNh9U5c3A=="}
0000000000000000000000000000000000000000;;		go server.ListenAndServe()
0000000000000000000000000000000000000000;;		dns.HandleFunc(".", handleRequest)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		func handleRequest(w dns.ResponseWriter, r *dns.Msg) {
0000000000000000000000000000000000000000;;			m := new(dns.Msg)
0000000000000000000000000000000000000000;;			m.SetReply(r)
0000000000000000000000000000000000000000;;			if r.IsTsig() != nil {
0000000000000000000000000000000000000000;;				if w.TsigStatus() == nil {
0000000000000000000000000000000000000000;;					// *Msg r has an TSIG record and it was validated
0000000000000000000000000000000000000000;;					m.SetTsig("axfr.", dns.HmacMD5, 300, time.Now().Unix())
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					// *Msg r has an TSIG records and it was not valided
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			w.WriteMsg(m)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	PRIVATE RRS
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	RFC 6895 sets aside a range of type codes for private use. This range
0000000000000000000000000000000000000000;;	is 65,280 - 65,534 (0xFF00 - 0xFFFE). When experimenting with new Resource Records these
0000000000000000000000000000000000000000;;	can be used, before requesting an official type code from IANA.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	see http://miek.nl/posts/2014/Sep/21/Private%20RRs%20and%20IDN%20in%20Go%20DNS/ for more
0000000000000000000000000000000000000000;;	information.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	EDNS0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	EDNS0 is an extension mechanism for the DNS defined in RFC 2671 and updated
0000000000000000000000000000000000000000;;	by RFC 6891. It defines an new RR type, the OPT RR, which is then completely
0000000000000000000000000000000000000000;;	abused.
0000000000000000000000000000000000000000;;	Basic use pattern for creating an (empty) OPT RR:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		o := new(dns.OPT)
0000000000000000000000000000000000000000;;		o.Hdr.Name = "." // MUST be the root zone, per definition.
0000000000000000000000000000000000000000;;		o.Hdr.Rrtype = dns.TypeOPT
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The rdata of an OPT RR consists out of a slice of EDNS0 (RFC 6891)
0000000000000000000000000000000000000000;;	interfaces. Currently only a few have been standardized: EDNS0_NSID
0000000000000000000000000000000000000000;;	(RFC 5001) and EDNS0_SUBNET (draft-vandergaast-edns-client-subnet-02). Note
0000000000000000000000000000000000000000;;	that these options may be combined in an OPT RR.
0000000000000000000000000000000000000000;;	Basic use pattern for a server to check if (and which) options are set:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// o is a dns.OPT
0000000000000000000000000000000000000000;;		for _, s := range o.Option {
0000000000000000000000000000000000000000;;			switch e := s.(type) {
0000000000000000000000000000000000000000;;			case *dns.EDNS0_NSID:
0000000000000000000000000000000000000000;;				// do stuff with e.Nsid
0000000000000000000000000000000000000000;;			case *dns.EDNS0_SUBNET:
0000000000000000000000000000000000000000;;				// access e.Family, e.Address, etc.
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	SIG(0)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	From RFC 2931:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	    SIG(0) provides protection for DNS transactions and requests ....
0000000000000000000000000000000000000000;;	    ... protection for glue records, DNS requests, protection for message headers
0000000000000000000000000000000000000000;;	    on requests and responses, and protection of the overall integrity of a response.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It works like TSIG, except that SIG(0) uses public key cryptography, instead of the shared
0000000000000000000000000000000000000000;;	secret approach in TSIG.
0000000000000000000000000000000000000000;;	Supported algorithms: DSA, ECDSAP256SHA256, ECDSAP384SHA384, RSASHA1, RSASHA256 and
0000000000000000000000000000000000000000;;	RSASHA512.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Signing subsequent messages in multi-message sessions is not implemented.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package dns
