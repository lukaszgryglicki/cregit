0000000000000000000000000000000000000000;;	package dns
f5d7b27a32c788d876881f6f8798fa310653e8fb;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base32"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"encoding/hex"
0000000000000000000000000000000000000000;;		"net"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper functions called from the generated zmsg.go
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These function are named after the tag to help pack/unpack, if there is no tag it is the name
0000000000000000000000000000000000000000;;	// of the type they pack/unpack (string, int, etc). We prefix all with unpackData or packData, so packDataA or
0000000000000000000000000000000000000000;;	// packDataDomainName.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDataA(msg []byte, off int) (net.IP, int, error) {
0000000000000000000000000000000000000000;;		if off+net.IPv4len > len(msg) {
0000000000000000000000000000000000000000;;			return nil, len(msg), &Error{err: "overflow unpacking a"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a := append(make(net.IP, 0, net.IPv4len), msg[off:off+net.IPv4len]...)
0000000000000000000000000000000000000000;;		off += net.IPv4len
0000000000000000000000000000000000000000;;		return a, off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packDataA(a net.IP, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		// It must be a slice of 4, even if it is 16, we encode only the first 4
0000000000000000000000000000000000000000;;		if off+net.IPv4len > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing a"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch len(a) {
0000000000000000000000000000000000000000;;		case net.IPv4len, net.IPv6len:
0000000000000000000000000000000000000000;;			copy(msg[off:], a.To4())
0000000000000000000000000000000000000000;;			off += net.IPv4len
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			// Allowed, for dynamic updates.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing a"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDataAAAA(msg []byte, off int) (net.IP, int, error) {
0000000000000000000000000000000000000000;;		if off+net.IPv6len > len(msg) {
0000000000000000000000000000000000000000;;			return nil, len(msg), &Error{err: "overflow unpacking aaaa"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		aaaa := append(make(net.IP, 0, net.IPv6len), msg[off:off+net.IPv6len]...)
0000000000000000000000000000000000000000;;		off += net.IPv6len
0000000000000000000000000000000000000000;;		return aaaa, off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packDataAAAA(aaaa net.IP, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		if off+net.IPv6len > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing aaaa"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch len(aaaa) {
0000000000000000000000000000000000000000;;		case net.IPv6len:
0000000000000000000000000000000000000000;;			copy(msg[off:], aaaa)
0000000000000000000000000000000000000000;;			off += net.IPv6len
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			// Allowed, dynamic updates.
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing aaaa"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unpackHeader unpacks an RR header, returning the offset to the end of the header and a
0000000000000000000000000000000000000000;;	// re-sliced msg according to the expected length of the RR.
0000000000000000000000000000000000000000;;	func unpackHeader(msg []byte, off int) (rr RR_Header, off1 int, truncmsg []byte, err error) {
0000000000000000000000000000000000000000;;		hdr := RR_Header{}
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return hdr, off, msg, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hdr.Name, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return hdr, len(msg), msg, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr.Rrtype, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return hdr, len(msg), msg, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr.Class, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return hdr, len(msg), msg, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr.Ttl, off, err = unpackUint32(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return hdr, len(msg), msg, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hdr.Rdlength, off, err = unpackUint16(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return hdr, len(msg), msg, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg, err = truncateMsgFromRdlength(msg, off, hdr.Rdlength)
0000000000000000000000000000000000000000;;		return hdr, off, msg, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pack packs an RR header, returning the offset to the end of the header.
0000000000000000000000000000000000000000;;	// See PackDomainName for documentation about the compression.
0000000000000000000000000000000000000000;;	func (hdr RR_Header) pack(msg []byte, off int, compression map[string]int, compress bool) (off1 int, err error) {
0000000000000000000000000000000000000000;;		if off == len(msg) {
0000000000000000000000000000000000000000;;			return off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		off, err = PackDomainName(hdr.Name, msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(hdr.Rrtype, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(hdr.Class, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint32(hdr.Ttl, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err = packUint16(hdr.Rdlength, msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// helper helper functions.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// truncateMsgFromRdLength truncates msg to match the expected length of the RR.
0000000000000000000000000000000000000000;;	// Returns an error if msg is smaller than the expected size.
0000000000000000000000000000000000000000;;	func truncateMsgFromRdlength(msg []byte, off int, rdlength uint16) (truncmsg []byte, err error) {
0000000000000000000000000000000000000000;;		lenrd := off + int(rdlength)
0000000000000000000000000000000000000000;;		if lenrd > len(msg) {
0000000000000000000000000000000000000000;;			return msg, &Error{err: "overflowing header size"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return msg[:lenrd], nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromBase32(s []byte) (buf []byte, err error) {
0000000000000000000000000000000000000000;;		buflen := base32.HexEncoding.DecodedLen(len(s))
0000000000000000000000000000000000000000;;		buf = make([]byte, buflen)
0000000000000000000000000000000000000000;;		n, err := base32.HexEncoding.Decode(buf, s)
0000000000000000000000000000000000000000;;		buf = buf[:n]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toBase32(b []byte) string { return base32.HexEncoding.EncodeToString(b) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fromBase64(s []byte) (buf []byte, err error) {
0000000000000000000000000000000000000000;;		buflen := base64.StdEncoding.DecodedLen(len(s))
0000000000000000000000000000000000000000;;		buf = make([]byte, buflen)
0000000000000000000000000000000000000000;;		n, err := base64.StdEncoding.Decode(buf, s)
0000000000000000000000000000000000000000;;		buf = buf[:n]
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toBase64(b []byte) string { return base64.StdEncoding.EncodeToString(b) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// dynamicUpdate returns true if the Rdlength is zero.
0000000000000000000000000000000000000000;;	func noRdata(h RR_Header) bool { return h.Rdlength == 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackUint8(msg []byte, off int) (i uint8, off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+1 > len(msg) {
0000000000000000000000000000000000000000;;			return 0, len(msg), &Error{err: "overflow unpacking uint8"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return uint8(msg[off]), off + 1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packUint8(i uint8, msg []byte, off int) (off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+1 > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing uint8"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg[off] = byte(i)
0000000000000000000000000000000000000000;;		return off + 1, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackUint16(msg []byte, off int) (i uint16, off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+2 > len(msg) {
0000000000000000000000000000000000000000;;			return 0, len(msg), &Error{err: "overflow unpacking uint16"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return binary.BigEndian.Uint16(msg[off:]), off + 2, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packUint16(i uint16, msg []byte, off int) (off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+2 > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing uint16"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(msg[off:], i)
0000000000000000000000000000000000000000;;		return off + 2, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackUint32(msg []byte, off int) (i uint32, off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+4 > len(msg) {
0000000000000000000000000000000000000000;;			return 0, len(msg), &Error{err: "overflow unpacking uint32"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return binary.BigEndian.Uint32(msg[off:]), off + 4, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packUint32(i uint32, msg []byte, off int) (off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+4 > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing uint32"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint32(msg[off:], i)
0000000000000000000000000000000000000000;;		return off + 4, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackUint48(msg []byte, off int) (i uint64, off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+6 > len(msg) {
0000000000000000000000000000000000000000;;			return 0, len(msg), &Error{err: "overflow unpacking uint64 as uint48"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Used in TSIG where the last 48 bits are occupied, so for now, assume a uint48 (6 bytes)
0000000000000000000000000000000000000000;;		i = (uint64(uint64(msg[off])<<40 | uint64(msg[off+1])<<32 | uint64(msg[off+2])<<24 | uint64(msg[off+3])<<16 |
0000000000000000000000000000000000000000;;			uint64(msg[off+4])<<8 | uint64(msg[off+5])))
0000000000000000000000000000000000000000;;		off += 6
0000000000000000000000000000000000000000;;		return i, off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packUint48(i uint64, msg []byte, off int) (off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+6 > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing uint64 as uint48"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		msg[off] = byte(i >> 40)
0000000000000000000000000000000000000000;;		msg[off+1] = byte(i >> 32)
0000000000000000000000000000000000000000;;		msg[off+2] = byte(i >> 24)
0000000000000000000000000000000000000000;;		msg[off+3] = byte(i >> 16)
0000000000000000000000000000000000000000;;		msg[off+4] = byte(i >> 8)
0000000000000000000000000000000000000000;;		msg[off+5] = byte(i)
0000000000000000000000000000000000000000;;		off += 6
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackUint64(msg []byte, off int) (i uint64, off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+8 > len(msg) {
0000000000000000000000000000000000000000;;			return 0, len(msg), &Error{err: "overflow unpacking uint64"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return binary.BigEndian.Uint64(msg[off:]), off + 8, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packUint64(i uint64, msg []byte, off int) (off1 int, err error) {
0000000000000000000000000000000000000000;;		if off+8 > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing uint64"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint64(msg[off:], i)
0000000000000000000000000000000000000000;;		off += 8
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackString(msg []byte, off int) (string, int, error) {
0000000000000000000000000000000000000000;;		if off+1 > len(msg) {
0000000000000000000000000000000000000000;;			return "", off, &Error{err: "overflow unpacking txt"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		l := int(msg[off])
0000000000000000000000000000000000000000;;		if off+l+1 > len(msg) {
0000000000000000000000000000000000000000;;			return "", off, &Error{err: "overflow unpacking txt"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := make([]byte, 0, l)
0000000000000000000000000000000000000000;;		for _, b := range msg[off+1 : off+1+l] {
0000000000000000000000000000000000000000;;			switch b {
0000000000000000000000000000000000000000;;			case '"', '\\':
0000000000000000000000000000000000000000;;				s = append(s, '\\', b)
0000000000000000000000000000000000000000;;			case '\t', '\r', '\n':
0000000000000000000000000000000000000000;;				s = append(s, b)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if b < 32 || b > 127 { // unprintable
0000000000000000000000000000000000000000;;					var buf [3]byte
0000000000000000000000000000000000000000;;					bufs := strconv.AppendInt(buf[:0], int64(b), 10)
0000000000000000000000000000000000000000;;					s = append(s, '\\')
0000000000000000000000000000000000000000;;					for i := 0; i < 3-len(bufs); i++ {
0000000000000000000000000000000000000000;;						s = append(s, '0')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, r := range bufs {
0000000000000000000000000000000000000000;;						s = append(s, r)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					s = append(s, b)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off += 1 + l
0000000000000000000000000000000000000000;;		return string(s), off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packString(s string, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		txtTmp := make([]byte, 256*4+1)
0000000000000000000000000000000000000000;;		off, err := packTxtString(s, msg, off, txtTmp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackStringBase32(msg []byte, off, end int) (string, int, error) {
0000000000000000000000000000000000000000;;		if end > len(msg) {
0000000000000000000000000000000000000000;;			return "", len(msg), &Error{err: "overflow unpacking base32"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := toBase32(msg[off:end])
0000000000000000000000000000000000000000;;		return s, end, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packStringBase32(s string, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		b32, err := fromBase32([]byte(s))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off+len(b32) > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing base32"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(msg[off:off+len(b32)], b32)
0000000000000000000000000000000000000000;;		off += len(b32)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackStringBase64(msg []byte, off, end int) (string, int, error) {
0000000000000000000000000000000000000000;;		// Rest of the RR is base64 encoded value, so we don't need an explicit length
0000000000000000000000000000000000000000;;		// to be set. Thus far all RR's that have base64 encoded fields have those as their
0000000000000000000000000000000000000000;;		// last one. What we do need is the end of the RR!
0000000000000000000000000000000000000000;;		if end > len(msg) {
0000000000000000000000000000000000000000;;			return "", len(msg), &Error{err: "overflow unpacking base64"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := toBase64(msg[off:end])
0000000000000000000000000000000000000000;;		return s, end, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packStringBase64(s string, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		b64, err := fromBase64([]byte(s))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off+len(b64) > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing base64"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(msg[off:off+len(b64)], b64)
0000000000000000000000000000000000000000;;		off += len(b64)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackStringHex(msg []byte, off, end int) (string, int, error) {
0000000000000000000000000000000000000000;;		// Rest of the RR is hex encoded value, so we don't need an explicit length
0000000000000000000000000000000000000000;;		// to be set. NSEC and TSIG have hex fields with a length field.
0000000000000000000000000000000000000000;;		// What we do need is the end of the RR!
0000000000000000000000000000000000000000;;		if end > len(msg) {
0000000000000000000000000000000000000000;;			return "", len(msg), &Error{err: "overflow unpacking hex"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		s := hex.EncodeToString(msg[off:end])
0000000000000000000000000000000000000000;;		return s, end, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packStringHex(s string, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		h, err := hex.DecodeString(s)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if off+(len(h)) > len(msg) {
0000000000000000000000000000000000000000;;			return len(msg), &Error{err: "overflow packing hex"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		copy(msg[off:off+len(h)], h)
0000000000000000000000000000000000000000;;		off += len(h)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackStringTxt(msg []byte, off int) ([]string, int, error) {
0000000000000000000000000000000000000000;;		txt, off, err := unpackTxt(msg, off)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return txt, off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packStringTxt(s []string, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		txtTmp := make([]byte, 256*4+1) // If the whole string consists out of \DDD we need this many.
0000000000000000000000000000000000000000;;		off, err := packTxt(s, msg, off, txtTmp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDataOpt(msg []byte, off int) ([]EDNS0, int, error) {
0000000000000000000000000000000000000000;;		var edns []EDNS0
0000000000000000000000000000000000000000;;	Option:
0000000000000000000000000000000000000000;;		code := uint16(0)
0000000000000000000000000000000000000000;;		if off+4 > len(msg) {
0000000000000000000000000000000000000000;;			return nil, len(msg), &Error{err: "overflow unpacking opt"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		code = binary.BigEndian.Uint16(msg[off:])
0000000000000000000000000000000000000000;;		off += 2
0000000000000000000000000000000000000000;;		optlen := binary.BigEndian.Uint16(msg[off:])
0000000000000000000000000000000000000000;;		off += 2
0000000000000000000000000000000000000000;;		if off+int(optlen) > len(msg) {
0000000000000000000000000000000000000000;;			return nil, len(msg), &Error{err: "overflow unpacking opt"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch code {
0000000000000000000000000000000000000000;;		case EDNS0NSID:
0000000000000000000000000000000000000000;;			e := new(EDNS0_NSID)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		case EDNS0SUBNET, EDNS0SUBNETDRAFT:
0000000000000000000000000000000000000000;;			e := new(EDNS0_SUBNET)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;			if code == EDNS0SUBNETDRAFT {
0000000000000000000000000000000000000000;;				e.DraftOption = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case EDNS0COOKIE:
0000000000000000000000000000000000000000;;			e := new(EDNS0_COOKIE)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		case EDNS0UL:
0000000000000000000000000000000000000000;;			e := new(EDNS0_UL)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		case EDNS0LLQ:
0000000000000000000000000000000000000000;;			e := new(EDNS0_LLQ)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		case EDNS0DAU:
0000000000000000000000000000000000000000;;			e := new(EDNS0_DAU)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		case EDNS0DHU:
0000000000000000000000000000000000000000;;			e := new(EDNS0_DHU)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		case EDNS0N3U:
0000000000000000000000000000000000000000;;			e := new(EDNS0_N3U)
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			e := new(EDNS0_LOCAL)
0000000000000000000000000000000000000000;;			e.Code = code
0000000000000000000000000000000000000000;;			if err := e.unpack(msg[off : off+int(optlen)]); err != nil {
0000000000000000000000000000000000000000;;				return nil, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			edns = append(edns, e)
0000000000000000000000000000000000000000;;			off += int(optlen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if off < len(msg) {
0000000000000000000000000000000000000000;;			goto Option
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return edns, off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packDataOpt(options []EDNS0, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		for _, el := range options {
0000000000000000000000000000000000000000;;			b, err := el.pack()
0000000000000000000000000000000000000000;;			if err != nil || off+3 > len(msg) {
0000000000000000000000000000000000000000;;				return len(msg), &Error{err: "overflow packing opt"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint16(msg[off:], el.Option())      // Option code
0000000000000000000000000000000000000000;;			binary.BigEndian.PutUint16(msg[off+2:], uint16(len(b))) // Length
0000000000000000000000000000000000000000;;			off += 4
0000000000000000000000000000000000000000;;			if off+len(b) > len(msg) {
0000000000000000000000000000000000000000;;				copy(msg[off:], b)
0000000000000000000000000000000000000000;;				off = len(msg)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Actual data
0000000000000000000000000000000000000000;;			copy(msg[off:off+len(b)], b)
0000000000000000000000000000000000000000;;			off += len(b)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackStringOctet(msg []byte, off int) (string, int, error) {
0000000000000000000000000000000000000000;;		s := string(msg[off:])
0000000000000000000000000000000000000000;;		return s, len(msg), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packStringOctet(s string, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		txtTmp := make([]byte, 256*4+1)
0000000000000000000000000000000000000000;;		off, err := packOctetString(s, msg, off, txtTmp)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDataNsec(msg []byte, off int) ([]uint16, int, error) {
0000000000000000000000000000000000000000;;		var nsec []uint16
0000000000000000000000000000000000000000;;		length, window, lastwindow := 0, 0, -1
0000000000000000000000000000000000000000;;		for off < len(msg) {
0000000000000000000000000000000000000000;;			if off+2 > len(msg) {
0000000000000000000000000000000000000000;;				return nsec, len(msg), &Error{err: "overflow unpacking nsecx"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			window = int(msg[off])
0000000000000000000000000000000000000000;;			length = int(msg[off+1])
0000000000000000000000000000000000000000;;			off += 2
0000000000000000000000000000000000000000;;			if window <= lastwindow {
0000000000000000000000000000000000000000;;				// RFC 4034: Blocks are present in the NSEC RR RDATA in
0000000000000000000000000000000000000000;;				// increasing numerical order.
0000000000000000000000000000000000000000;;				return nsec, len(msg), &Error{err: "out of order NSEC block"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if length == 0 {
0000000000000000000000000000000000000000;;				// RFC 4034: Blocks with no types present MUST NOT be included.
0000000000000000000000000000000000000000;;				return nsec, len(msg), &Error{err: "empty NSEC block"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if length > 32 {
0000000000000000000000000000000000000000;;				return nsec, len(msg), &Error{err: "NSEC block too long"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if off+length > len(msg) {
0000000000000000000000000000000000000000;;				return nsec, len(msg), &Error{err: "overflowing NSEC block"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Walk the bytes in the window and extract the type bits
0000000000000000000000000000000000000000;;			for j := 0; j < length; j++ {
0000000000000000000000000000000000000000;;				b := msg[off+j]
0000000000000000000000000000000000000000;;				// Check the bits one by one, and set the type
0000000000000000000000000000000000000000;;				if b&0x80 == 0x80 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+0))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b&0x40 == 0x40 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+1))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b&0x20 == 0x20 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+2))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b&0x10 == 0x10 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+3))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b&0x8 == 0x8 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+4))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b&0x4 == 0x4 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+5))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b&0x2 == 0x2 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+6))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if b&0x1 == 0x1 {
0000000000000000000000000000000000000000;;					nsec = append(nsec, uint16(window*256+j*8+7))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			off += length
0000000000000000000000000000000000000000;;			lastwindow = window
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nsec, off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packDataNsec(bitmap []uint16, msg []byte, off int) (int, error) {
0000000000000000000000000000000000000000;;		if len(bitmap) == 0 {
0000000000000000000000000000000000000000;;			return off, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var lastwindow, lastlength uint16
0000000000000000000000000000000000000000;;		for j := 0; j < len(bitmap); j++ {
0000000000000000000000000000000000000000;;			t := bitmap[j]
0000000000000000000000000000000000000000;;			window := t / 256
0000000000000000000000000000000000000000;;			length := (t-window*256)/8 + 1
0000000000000000000000000000000000000000;;			if window > lastwindow && lastlength != 0 { // New window, jump to the new offset
0000000000000000000000000000000000000000;;				off += int(lastlength) + 2
0000000000000000000000000000000000000000;;				lastlength = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if window < lastwindow || length < lastlength {
0000000000000000000000000000000000000000;;				return len(msg), &Error{err: "nsec bits out of order"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if off+2+int(length) > len(msg) {
0000000000000000000000000000000000000000;;				return len(msg), &Error{err: "overflow packing nsec"}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Setting the window #
0000000000000000000000000000000000000000;;			msg[off] = byte(window)
0000000000000000000000000000000000000000;;			// Setting the octets length
0000000000000000000000000000000000000000;;			msg[off+1] = byte(length)
0000000000000000000000000000000000000000;;			// Setting the bit value for the type in the right octet
0000000000000000000000000000000000000000;;			msg[off+1+int(length)] |= byte(1 << (7 - (t % 8)))
0000000000000000000000000000000000000000;;			lastwindow, lastlength = window, length
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off += int(lastlength) + 2
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unpackDataDomainNames(msg []byte, off, end int) ([]string, int, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			servers []string
0000000000000000000000000000000000000000;;			s       string
0000000000000000000000000000000000000000;;			err     error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;		if end > len(msg) {
0000000000000000000000000000000000000000;;			return nil, len(msg), &Error{err: "overflow unpacking domain names"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for off < end {
0000000000000000000000000000000000000000;;			s, off, err = UnpackDomainName(msg, off)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return servers, len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			servers = append(servers, s)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return servers, off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func packDataDomainNames(names []string, msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for j := 0; j < len(names); j++ {
0000000000000000000000000000000000000000;;			off, err = PackDomainName(names[j], msg, off, compression, false && compress)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return len(msg), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
