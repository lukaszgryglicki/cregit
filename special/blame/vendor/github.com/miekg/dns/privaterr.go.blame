0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/privaterr.go[Godeps/_workspace/src/github.com/miekg/dns/privaterr.go][vendor/github.com/miekg/dns/privaterr.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrivateRdata is an interface used for implementing "Private Use" RR types, see
0000000000000000000000000000000000000000;;	// RFC 6895. This allows one to experiment with new RR types, without requesting an
0000000000000000000000000000000000000000;;	// official type code. Also see dns.PrivateHandle and dns.PrivateHandleRemove.
0000000000000000000000000000000000000000;;	type PrivateRdata interface {
0000000000000000000000000000000000000000;;		// String returns the text presentaton of the Rdata of the Private RR.
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;		// Parse parses the Rdata of the private RR.
0000000000000000000000000000000000000000;;		Parse([]string) error
0000000000000000000000000000000000000000;;		// Pack is used when packing a private RR into a buffer.
0000000000000000000000000000000000000000;;		Pack([]byte) (int, error)
0000000000000000000000000000000000000000;;		// Unpack is used when unpacking a private RR from a buffer.
0000000000000000000000000000000000000000;;		// TODO(miek): diff. signature than Pack, see edns0.go for instance.
0000000000000000000000000000000000000000;;		Unpack([]byte) (int, error)
0000000000000000000000000000000000000000;;		// Copy copies the Rdata.
0000000000000000000000000000000000000000;;		Copy(PrivateRdata) error
0000000000000000000000000000000000000000;;		// Len returns the length in octets of the Rdata.
0000000000000000000000000000000000000000;;		Len() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrivateRR represents an RR that uses a PrivateRdata user-defined type.
0000000000000000000000000000000000000000;;	// It mocks normal RRs and implements dns.RR interface.
0000000000000000000000000000000000000000;;	type PrivateRR struct {
0000000000000000000000000000000000000000;;		Hdr  RR_Header
0000000000000000000000000000000000000000;;		Data PrivateRdata
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mkPrivateRR(rrtype uint16) *PrivateRR {
0000000000000000000000000000000000000000;;		// Panics if RR is not an instance of PrivateRR.
0000000000000000000000000000000000000000;;		rrfunc, ok := TypeToRR[rrtype]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			panic(fmt.Sprintf("dns: invalid operation with Private RR type %d", rrtype))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		anyrr := rrfunc()
0000000000000000000000000000000000000000;;		switch rr := anyrr.(type) {
0000000000000000000000000000000000000000;;		case *PrivateRR:
0000000000000000000000000000000000000000;;			return rr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic(fmt.Sprintf("dns: RR is not a PrivateRR, TypeToRR[%d] generator returned %T", rrtype, anyrr))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Header return the RR header of r.
0000000000000000000000000000000000000000;;	func (r *PrivateRR) Header() *RR_Header { return &r.Hdr }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *PrivateRR) String() string { return r.Hdr.String() + r.Data.String() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Private len and copy parts to satisfy RR interface.
0000000000000000000000000000000000000000;;	func (r *PrivateRR) len() int { return r.Hdr.len() + r.Data.Len() }
0000000000000000000000000000000000000000;;	func (r *PrivateRR) copy() RR {
0000000000000000000000000000000000000000;;		// make new RR like this:
0000000000000000000000000000000000000000;;		rr := mkPrivateRR(r.Hdr.Rrtype)
0000000000000000000000000000000000000000;;		newh := r.Hdr.copyHeader()
0000000000000000000000000000000000000000;;		rr.Hdr = *newh
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := r.Data.Copy(rr.Data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic("dns: got value that could not be used to copy Private rdata")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return rr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *PrivateRR) pack(msg []byte, off int, compression map[string]int, compress bool) (int, error) {
0000000000000000000000000000000000000000;;		off, err := r.Hdr.pack(msg, off, compression, compress)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		headerEnd := off
0000000000000000000000000000000000000000;;		n, err := r.Data.Pack(msg[off:])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return len(msg), err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off += n
0000000000000000000000000000000000000000;;		r.Header().Rdlength = uint16(off - headerEnd)
0000000000000000000000000000000000000000;;		return off, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrivateHandle registers a private resource record type. It requires
0000000000000000000000000000000000000000;;	// string and numeric representation of private RR type and generator function as argument.
0000000000000000000000000000000000000000;;	func PrivateHandle(rtypestr string, rtype uint16, generator func() PrivateRdata) {
0000000000000000000000000000000000000000;;		rtypestr = strings.ToUpper(rtypestr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		TypeToRR[rtype] = func() RR { return &PrivateRR{RR_Header{}, generator()} }
0000000000000000000000000000000000000000;;		TypeToString[rtype] = rtypestr
0000000000000000000000000000000000000000;;		StringToType[rtypestr] = rtype
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeToUnpack[rtype] = func(h RR_Header, msg []byte, off int) (RR, int, error) {
0000000000000000000000000000000000000000;;			if noRdata(h) {
0000000000000000000000000000000000000000;;				return &h, off, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			rr := mkPrivateRR(h.Rrtype)
0000000000000000000000000000000000000000;;			rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			off1, err := rr.Data.Unpack(msg[off:])
0000000000000000000000000000000000000000;;			off += off1
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return rr, off, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return rr, off, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setPrivateRR := func(h RR_Header, c chan lex, o, f string) (RR, *ParseError, string) {
0000000000000000000000000000000000000000;;			rr := mkPrivateRR(h.Rrtype)
0000000000000000000000000000000000000000;;			rr.Hdr = h
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var l lex
0000000000000000000000000000000000000000;;			text := make([]string, 0, 2) // could be 0..N elements, median is probably 1
0000000000000000000000000000000000000000;;		Fetch:
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				// TODO(miek): we could also be returning _QUOTE, this might or might not
0000000000000000000000000000000000000000;;				// be an issue (basically parsing TXT becomes hard)
0000000000000000000000000000000000000000;;				switch l = <-c; l.value {
0000000000000000000000000000000000000000;;				case zNewline, zEOF:
0000000000000000000000000000000000000000;;					break Fetch
0000000000000000000000000000000000000000;;				case zString:
0000000000000000000000000000000000000000;;					text = append(text, l.token)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := rr.Data.Parse(text)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, &ParseError{f, err.Error(), l}, ""
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return rr, nil, ""
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		typeToparserFunc[rtype] = parserFunc{setPrivateRR, true}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PrivateHandleRemove removes defenitions required to support private RR type.
0000000000000000000000000000000000000000;;	func PrivateHandleRemove(rtype uint16) {
0000000000000000000000000000000000000000;;		rtypestr, ok := TypeToString[rtype]
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			delete(TypeToRR, rtype)
0000000000000000000000000000000000000000;;			delete(TypeToString, rtype)
0000000000000000000000000000000000000000;;			delete(typeToparserFunc, rtype)
0000000000000000000000000000000000000000;;			delete(StringToType, rtypestr)
0000000000000000000000000000000000000000;;			delete(typeToUnpack, rtype)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
