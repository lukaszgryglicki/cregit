0000000000000000000000000000000000000000;;	package dns
7b453296e4ade7a4f2c9d7f5717f0f864e37dcac;Godeps/_workspace/src/github.com/miekg/dns/sig0.go[Godeps/_workspace/src/github.com/miekg/dns/sig0.go][vendor/github.com/miekg/dns/sig0.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto"
0000000000000000000000000000000000000000;;		"crypto/dsa"
0000000000000000000000000000000000000000;;		"crypto/ecdsa"
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"math/big"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Sign signs a dns.Msg. It fills the signature with the appropriate data.
0000000000000000000000000000000000000000;;	// The SIG record should have the SignerName, KeyTag, Algorithm, Inception
0000000000000000000000000000000000000000;;	// and Expiration set.
0000000000000000000000000000000000000000;;	func (rr *SIG) Sign(k crypto.Signer, m *Msg) ([]byte, error) {
0000000000000000000000000000000000000000;;		if k == nil {
0000000000000000000000000000000000000000;;			return nil, ErrPrivKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.KeyTag == 0 || len(rr.SignerName) == 0 || rr.Algorithm == 0 {
0000000000000000000000000000000000000000;;			return nil, ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		rr.Header().Rrtype = TypeSIG
0000000000000000000000000000000000000000;;		rr.Header().Class = ClassANY
0000000000000000000000000000000000000000;;		rr.Header().Ttl = 0
0000000000000000000000000000000000000000;;		rr.Header().Name = "."
0000000000000000000000000000000000000000;;		rr.OrigTtl = 0
0000000000000000000000000000000000000000;;		rr.TypeCovered = 0
0000000000000000000000000000000000000000;;		rr.Labels = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf := make([]byte, m.Len()+rr.len())
0000000000000000000000000000000000000000;;		mbuf, err := m.PackBuffer(buf)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if &buf[0] != &mbuf[0] {
0000000000000000000000000000000000000000;;			return nil, ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		off, err := PackRR(rr, buf, len(mbuf), nil, false)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		buf = buf[:off:cap(buf)]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hash, ok := AlgorithmToHash[rr.Algorithm]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return nil, ErrAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hasher := hash.New()
0000000000000000000000000000000000000000;;		// Write SIG rdata
0000000000000000000000000000000000000000;;		hasher.Write(buf[len(mbuf)+1+2+2+4+2:])
0000000000000000000000000000000000000000;;		// Write message
0000000000000000000000000000000000000000;;		hasher.Write(buf[:len(mbuf)])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		signature, err := sign(k, hasher.Sum(nil), hash, rr.Algorithm)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rr.Signature = toBase64(signature)
0000000000000000000000000000000000000000;;		sig := string(signature)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buf = append(buf, sig...)
0000000000000000000000000000000000000000;;		if len(buf) > int(^uint16(0)) {
0000000000000000000000000000000000000000;;			return nil, ErrBuf
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Adjust sig data length
0000000000000000000000000000000000000000;;		rdoff := len(mbuf) + 1 + 2 + 2 + 4
0000000000000000000000000000000000000000;;		rdlen := binary.BigEndian.Uint16(buf[rdoff:])
0000000000000000000000000000000000000000;;		rdlen += uint16(len(sig))
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(buf[rdoff:], rdlen)
0000000000000000000000000000000000000000;;		// Adjust additional count
0000000000000000000000000000000000000000;;		adc := binary.BigEndian.Uint16(buf[10:])
0000000000000000000000000000000000000000;;		adc++
0000000000000000000000000000000000000000;;		binary.BigEndian.PutUint16(buf[10:], adc)
0000000000000000000000000000000000000000;;		return buf, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Verify validates the message buf using the key k.
0000000000000000000000000000000000000000;;	// It's assumed that buf is a valid message from which rr was unpacked.
0000000000000000000000000000000000000000;;	func (rr *SIG) Verify(k *KEY, buf []byte) error {
0000000000000000000000000000000000000000;;		if k == nil {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rr.KeyTag == 0 || len(rr.SignerName) == 0 || rr.Algorithm == 0 {
0000000000000000000000000000000000000000;;			return ErrKey
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var hash crypto.Hash
0000000000000000000000000000000000000000;;		switch rr.Algorithm {
0000000000000000000000000000000000000000;;		case DSA, RSASHA1:
0000000000000000000000000000000000000000;;			hash = crypto.SHA1
0000000000000000000000000000000000000000;;		case RSASHA256, ECDSAP256SHA256:
0000000000000000000000000000000000000000;;			hash = crypto.SHA256
0000000000000000000000000000000000000000;;		case ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			hash = crypto.SHA384
0000000000000000000000000000000000000000;;		case RSASHA512:
0000000000000000000000000000000000000000;;			hash = crypto.SHA512
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return ErrAlg
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		hasher := hash.New()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buflen := len(buf)
0000000000000000000000000000000000000000;;		qdc := binary.BigEndian.Uint16(buf[4:])
0000000000000000000000000000000000000000;;		anc := binary.BigEndian.Uint16(buf[6:])
0000000000000000000000000000000000000000;;		auc := binary.BigEndian.Uint16(buf[8:])
0000000000000000000000000000000000000000;;		adc := binary.BigEndian.Uint16(buf[10:])
0000000000000000000000000000000000000000;;		offset := 12
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		for i := uint16(0); i < qdc && offset < buflen; i++ {
0000000000000000000000000000000000000000;;			_, offset, err = UnpackDomainName(buf, offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Skip past Type and Class
0000000000000000000000000000000000000000;;			offset += 2 + 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := uint16(1); i < anc+auc+adc && offset < buflen; i++ {
0000000000000000000000000000000000000000;;			_, offset, err = UnpackDomainName(buf, offset)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Skip past Type, Class and TTL
0000000000000000000000000000000000000000;;			offset += 2 + 2 + 4
0000000000000000000000000000000000000000;;			if offset+1 >= buflen {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var rdlen uint16
0000000000000000000000000000000000000000;;			rdlen = binary.BigEndian.Uint16(buf[offset:])
0000000000000000000000000000000000000000;;			offset += 2
0000000000000000000000000000000000000000;;			offset += int(rdlen)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if offset >= buflen {
0000000000000000000000000000000000000000;;			return &Error{err: "overflowing unpacking signed message"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// offset should be just prior to SIG
0000000000000000000000000000000000000000;;		bodyend := offset
0000000000000000000000000000000000000000;;		// owner name SHOULD be root
0000000000000000000000000000000000000000;;		_, offset, err = UnpackDomainName(buf, offset)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Skip Type, Class, TTL, RDLen
0000000000000000000000000000000000000000;;		offset += 2 + 2 + 4 + 2
0000000000000000000000000000000000000000;;		sigstart := offset
0000000000000000000000000000000000000000;;		// Skip Type Covered, Algorithm, Labels, Original TTL
0000000000000000000000000000000000000000;;		offset += 2 + 1 + 1 + 4
0000000000000000000000000000000000000000;;		if offset+4+4 >= buflen {
0000000000000000000000000000000000000000;;			return &Error{err: "overflow unpacking signed message"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		expire := binary.BigEndian.Uint32(buf[offset:])
0000000000000000000000000000000000000000;;		offset += 4
0000000000000000000000000000000000000000;;		incept := binary.BigEndian.Uint32(buf[offset:])
0000000000000000000000000000000000000000;;		offset += 4
0000000000000000000000000000000000000000;;		now := uint32(time.Now().Unix())
0000000000000000000000000000000000000000;;		if now < incept || now > expire {
0000000000000000000000000000000000000000;;			return ErrTime
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Skip key tag
0000000000000000000000000000000000000000;;		offset += 2
0000000000000000000000000000000000000000;;		var signername string
0000000000000000000000000000000000000000;;		signername, offset, err = UnpackDomainName(buf, offset)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If key has come from the DNS name compression might
0000000000000000000000000000000000000000;;		// have mangled the case of the name
0000000000000000000000000000000000000000;;		if strings.ToLower(signername) != strings.ToLower(k.Header().Name) {
0000000000000000000000000000000000000000;;			return &Error{err: "signer name doesn't match key name"}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sigend := offset
0000000000000000000000000000000000000000;;		hasher.Write(buf[sigstart:sigend])
0000000000000000000000000000000000000000;;		hasher.Write(buf[:10])
0000000000000000000000000000000000000000;;		hasher.Write([]byte{
0000000000000000000000000000000000000000;;			byte((adc - 1) << 8),
0000000000000000000000000000000000000000;;			byte(adc - 1),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		hasher.Write(buf[12:bodyend])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hashed := hasher.Sum(nil)
0000000000000000000000000000000000000000;;		sig := buf[sigend:]
0000000000000000000000000000000000000000;;		switch k.Algorithm {
0000000000000000000000000000000000000000;;		case DSA:
0000000000000000000000000000000000000000;;			pk := k.publicKeyDSA()
0000000000000000000000000000000000000000;;			sig = sig[1:]
0000000000000000000000000000000000000000;;			r := big.NewInt(0)
0000000000000000000000000000000000000000;;			r.SetBytes(sig[:len(sig)/2])
0000000000000000000000000000000000000000;;			s := big.NewInt(0)
0000000000000000000000000000000000000000;;			s.SetBytes(sig[len(sig)/2:])
0000000000000000000000000000000000000000;;			if pk != nil {
0000000000000000000000000000000000000000;;				if dsa.Verify(pk, hashed, r, s) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return ErrSig
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case RSASHA1, RSASHA256, RSASHA512:
0000000000000000000000000000000000000000;;			pk := k.publicKeyRSA()
0000000000000000000000000000000000000000;;			if pk != nil {
0000000000000000000000000000000000000000;;				return rsa.VerifyPKCS1v15(pk, hash, hashed, sig)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case ECDSAP256SHA256, ECDSAP384SHA384:
0000000000000000000000000000000000000000;;			pk := k.publicKeyECDSA()
0000000000000000000000000000000000000000;;			r := big.NewInt(0)
0000000000000000000000000000000000000000;;			r.SetBytes(sig[:len(sig)/2])
0000000000000000000000000000000000000000;;			s := big.NewInt(0)
0000000000000000000000000000000000000000;;			s.SetBytes(sig[len(sig)/2:])
0000000000000000000000000000000000000000;;			if pk != nil {
0000000000000000000000000000000000000000;;				if ecdsa.Verify(pk, hashed, r, s) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return ErrSig
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ErrKeyAlg
0000000000000000000000000000000000000000;;	}
