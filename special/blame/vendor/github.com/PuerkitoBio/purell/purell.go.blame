0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	Package purell offers URL normalization as described on the wikipedia page:
0000000000000000000000000000000000000000;;	http://en.wikipedia.org/wiki/URL_normalization
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	package purell
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/PuerkitoBio/urlesc"
0000000000000000000000000000000000000000;;		"golang.org/x/net/idna"
0000000000000000000000000000000000000000;;		"golang.org/x/text/secure/precis"
0000000000000000000000000000000000000000;;		"golang.org/x/text/unicode/norm"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A set of normalization flags determines how a URL will
0000000000000000000000000000000000000000;;	// be normalized.
0000000000000000000000000000000000000000;;	type NormalizationFlags uint
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		// Safe normalizations
0000000000000000000000000000000000000000;;		FlagLowercaseScheme           NormalizationFlags = 1 << iota // HTTP://host -> http://host, applied by default in Go1.1
0000000000000000000000000000000000000000;;		FlagLowercaseHost                                            // http://HOST -> http://host
0000000000000000000000000000000000000000;;		FlagUppercaseEscapes                                         // http://host/t%ef -> http://host/t%EF
0000000000000000000000000000000000000000;;		FlagDecodeUnnecessaryEscapes                                 // http://host/t%41 -> http://host/tA
0000000000000000000000000000000000000000;;		FlagEncodeNecessaryEscapes                                   // http://host/!"#$ -> http://host/%21%22#$
0000000000000000000000000000000000000000;;		FlagRemoveDefaultPort                                        // http://host:80 -> http://host
0000000000000000000000000000000000000000;;		FlagRemoveEmptyQuerySeparator                                // http://host/path? -> http://host/path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Usually safe normalizations
0000000000000000000000000000000000000000;;		FlagRemoveTrailingSlash // http://host/path/ -> http://host/path
0000000000000000000000000000000000000000;;		FlagAddTrailingSlash    // http://host/path -> http://host/path/ (should choose only one of these add/remove trailing slash flags)
0000000000000000000000000000000000000000;;		FlagRemoveDotSegments   // http://host/path/./a/b/../c -> http://host/path/a/c
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Unsafe normalizations
0000000000000000000000000000000000000000;;		FlagRemoveDirectoryIndex   // http://host/path/index.html -> http://host/path/
0000000000000000000000000000000000000000;;		FlagRemoveFragment         // http://host/path#fragment -> http://host/path
0000000000000000000000000000000000000000;;		FlagForceHTTP              // https://host -> http://host
0000000000000000000000000000000000000000;;		FlagRemoveDuplicateSlashes // http://host/path//a///b -> http://host/path/a/b
0000000000000000000000000000000000000000;;		FlagRemoveWWW              // http://www.host/ -> http://host/
0000000000000000000000000000000000000000;;		FlagAddWWW                 // http://host/ -> http://www.host/ (should choose only one of these add/remove WWW flags)
0000000000000000000000000000000000000000;;		FlagSortQuery              // http://host/path?c=3&b=2&a=1&b=1 -> http://host/path?a=1&b=1&b=2&c=3
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Normalizations not in the wikipedia article, required to cover tests cases
0000000000000000000000000000000000000000;;		// submitted by jehiah
0000000000000000000000000000000000000000;;		FlagDecodeDWORDHost           // http://1113982867 -> http://66.102.7.147
0000000000000000000000000000000000000000;;		FlagDecodeOctalHost           // http://0102.0146.07.0223 -> http://66.102.7.147
0000000000000000000000000000000000000000;;		FlagDecodeHexHost             // http://0x42660793 -> http://66.102.7.147
0000000000000000000000000000000000000000;;		FlagRemoveUnnecessaryHostDots // http://.host../path -> http://host/path
0000000000000000000000000000000000000000;;		FlagRemoveEmptyPortSeparator  // http://host:/path -> http://host/path
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convenience set of safe normalizations
0000000000000000000000000000000000000000;;		FlagsSafe NormalizationFlags = FlagLowercaseHost | FlagLowercaseScheme | FlagUppercaseEscapes | FlagDecodeUnnecessaryEscapes | FlagEncodeNecessaryEscapes | FlagRemoveDefaultPort | FlagRemoveEmptyQuerySeparator
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// For convenience sets, "greedy" uses the "remove trailing slash" and "remove www. prefix" flags,
0000000000000000000000000000000000000000;;		// while "non-greedy" uses the "add (or keep) the trailing slash" and "add www. prefix".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convenience set of usually safe normalizations (includes FlagsSafe)
0000000000000000000000000000000000000000;;		FlagsUsuallySafeGreedy    NormalizationFlags = FlagsSafe | FlagRemoveTrailingSlash | FlagRemoveDotSegments
0000000000000000000000000000000000000000;;		FlagsUsuallySafeNonGreedy NormalizationFlags = FlagsSafe | FlagAddTrailingSlash | FlagRemoveDotSegments
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convenience set of unsafe normalizations (includes FlagsUsuallySafe)
0000000000000000000000000000000000000000;;		FlagsUnsafeGreedy    NormalizationFlags = FlagsUsuallySafeGreedy | FlagRemoveDirectoryIndex | FlagRemoveFragment | FlagForceHTTP | FlagRemoveDuplicateSlashes | FlagRemoveWWW | FlagSortQuery
0000000000000000000000000000000000000000;;		FlagsUnsafeNonGreedy NormalizationFlags = FlagsUsuallySafeNonGreedy | FlagRemoveDirectoryIndex | FlagRemoveFragment | FlagForceHTTP | FlagRemoveDuplicateSlashes | FlagAddWWW | FlagSortQuery
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convenience set of all available flags
0000000000000000000000000000000000000000;;		FlagsAllGreedy    = FlagsUnsafeGreedy | FlagDecodeDWORDHost | FlagDecodeOctalHost | FlagDecodeHexHost | FlagRemoveUnnecessaryHostDots | FlagRemoveEmptyPortSeparator
0000000000000000000000000000000000000000;;		FlagsAllNonGreedy = FlagsUnsafeNonGreedy | FlagDecodeDWORDHost | FlagDecodeOctalHost | FlagDecodeHexHost | FlagRemoveUnnecessaryHostDots | FlagRemoveEmptyPortSeparator
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		defaultHttpPort  = ":80"
0000000000000000000000000000000000000000;;		defaultHttpsPort = ":443"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Regular expressions used by the normalizations
0000000000000000000000000000000000000000;;	var rxPort = regexp.MustCompile(`(:\d+)/?$`)
0000000000000000000000000000000000000000;;	var rxDirIndex = regexp.MustCompile(`(^|/)((?:default|index)\.\w{1,4})$`)
0000000000000000000000000000000000000000;;	var rxDupSlashes = regexp.MustCompile(`/{2,}`)
0000000000000000000000000000000000000000;;	var rxDWORDHost = regexp.MustCompile(`^(\d+)((?:\.+)?(?:\:\d*)?)$`)
0000000000000000000000000000000000000000;;	var rxOctalHost = regexp.MustCompile(`^(0\d*)\.(0\d*)\.(0\d*)\.(0\d*)((?:\.+)?(?:\:\d*)?)$`)
0000000000000000000000000000000000000000;;	var rxHexHost = regexp.MustCompile(`^0x([0-9A-Fa-f]+)((?:\.+)?(?:\:\d*)?)$`)
0000000000000000000000000000000000000000;;	var rxHostDots = regexp.MustCompile(`^(.+?)(:\d+)?$`)
0000000000000000000000000000000000000000;;	var rxEmptyPort = regexp.MustCompile(`:+$`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Map of flags to implementation function.
0000000000000000000000000000000000000000;;	// FlagDecodeUnnecessaryEscapes has no action, since it is done automatically
0000000000000000000000000000000000000000;;	// by parsing the string as an URL. Same for FlagUppercaseEscapes and FlagRemoveEmptyQuerySeparator.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Since maps have undefined traversing order, make a slice of ordered keys
0000000000000000000000000000000000000000;;	var flagsOrder = []NormalizationFlags{
0000000000000000000000000000000000000000;;		FlagLowercaseScheme,
0000000000000000000000000000000000000000;;		FlagLowercaseHost,
0000000000000000000000000000000000000000;;		FlagRemoveDefaultPort,
0000000000000000000000000000000000000000;;		FlagRemoveDirectoryIndex,
0000000000000000000000000000000000000000;;		FlagRemoveDotSegments,
0000000000000000000000000000000000000000;;		FlagRemoveFragment,
0000000000000000000000000000000000000000;;		FlagForceHTTP, // Must be after remove default port (because https=443/http=80)
0000000000000000000000000000000000000000;;		FlagRemoveDuplicateSlashes,
0000000000000000000000000000000000000000;;		FlagRemoveWWW,
0000000000000000000000000000000000000000;;		FlagAddWWW,
0000000000000000000000000000000000000000;;		FlagSortQuery,
0000000000000000000000000000000000000000;;		FlagDecodeDWORDHost,
0000000000000000000000000000000000000000;;		FlagDecodeOctalHost,
0000000000000000000000000000000000000000;;		FlagDecodeHexHost,
0000000000000000000000000000000000000000;;		FlagRemoveUnnecessaryHostDots,
0000000000000000000000000000000000000000;;		FlagRemoveEmptyPortSeparator,
0000000000000000000000000000000000000000;;		FlagRemoveTrailingSlash, // These two (add/remove trailing slash) must be last
0000000000000000000000000000000000000000;;		FlagAddTrailingSlash,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ... and then the map, where order is unimportant
0000000000000000000000000000000000000000;;	var flags = map[NormalizationFlags]func(*url.URL){
0000000000000000000000000000000000000000;;		FlagLowercaseScheme:           lowercaseScheme,
0000000000000000000000000000000000000000;;		FlagLowercaseHost:             lowercaseHost,
0000000000000000000000000000000000000000;;		FlagRemoveDefaultPort:         removeDefaultPort,
0000000000000000000000000000000000000000;;		FlagRemoveDirectoryIndex:      removeDirectoryIndex,
0000000000000000000000000000000000000000;;		FlagRemoveDotSegments:         removeDotSegments,
0000000000000000000000000000000000000000;;		FlagRemoveFragment:            removeFragment,
0000000000000000000000000000000000000000;;		FlagForceHTTP:                 forceHTTP,
0000000000000000000000000000000000000000;;		FlagRemoveDuplicateSlashes:    removeDuplicateSlashes,
0000000000000000000000000000000000000000;;		FlagRemoveWWW:                 removeWWW,
0000000000000000000000000000000000000000;;		FlagAddWWW:                    addWWW,
0000000000000000000000000000000000000000;;		FlagSortQuery:                 sortQuery,
0000000000000000000000000000000000000000;;		FlagDecodeDWORDHost:           decodeDWORDHost,
0000000000000000000000000000000000000000;;		FlagDecodeOctalHost:           decodeOctalHost,
0000000000000000000000000000000000000000;;		FlagDecodeHexHost:             decodeHexHost,
0000000000000000000000000000000000000000;;		FlagRemoveUnnecessaryHostDots: removeUnncessaryHostDots,
0000000000000000000000000000000000000000;;		FlagRemoveEmptyPortSeparator:  removeEmptyPortSeparator,
0000000000000000000000000000000000000000;;		FlagRemoveTrailingSlash:       removeTrailingSlash,
0000000000000000000000000000000000000000;;		FlagAddTrailingSlash:          addTrailingSlash,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustNormalizeURLString returns the normalized string, and panics if an error occurs.
0000000000000000000000000000000000000000;;	// It takes an URL string as input, as well as the normalization flags.
0000000000000000000000000000000000000000;;	func MustNormalizeURLString(u string, f NormalizationFlags) string {
0000000000000000000000000000000000000000;;		result, e := NormalizeURLString(u, f)
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			panic(e)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NormalizeURLString returns the normalized string, or an error if it can't be parsed into an URL object.
0000000000000000000000000000000000000000;;	// It takes an URL string as input, as well as the normalization flags.
0000000000000000000000000000000000000000;;	func NormalizeURLString(u string, f NormalizationFlags) (string, error) {
0000000000000000000000000000000000000000;;		if parsed, e := url.Parse(u); e != nil {
0000000000000000000000000000000000000000;;			return "", e
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			options := make([]precis.Option, 1, 3)
0000000000000000000000000000000000000000;;			options[0] = precis.IgnoreCase
0000000000000000000000000000000000000000;;			if f&FlagLowercaseHost == FlagLowercaseHost {
0000000000000000000000000000000000000000;;				options = append(options, precis.FoldCase())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options = append(options, precis.Norm(norm.NFC))
0000000000000000000000000000000000000000;;			profile := precis.NewFreeform(options...)
0000000000000000000000000000000000000000;;			if parsed.Host, e = idna.ToASCII(profile.NewTransformer().String(parsed.Host)); e != nil {
0000000000000000000000000000000000000000;;				return "", e
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return NormalizeURL(parsed, f), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		panic("Unreachable code.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NormalizeURL returns the normalized string.
0000000000000000000000000000000000000000;;	// It takes a parsed URL object as input, as well as the normalization flags.
0000000000000000000000000000000000000000;;	func NormalizeURL(u *url.URL, f NormalizationFlags) string {
0000000000000000000000000000000000000000;;		for _, k := range flagsOrder {
0000000000000000000000000000000000000000;;			if f&k == k {
0000000000000000000000000000000000000000;;				flags[k](u)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return urlesc.Escape(u)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lowercaseScheme(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Scheme) > 0 {
0000000000000000000000000000000000000000;;			u.Scheme = strings.ToLower(u.Scheme)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func lowercaseHost(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 {
0000000000000000000000000000000000000000;;			u.Host = strings.ToLower(u.Host)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeDefaultPort(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 {
0000000000000000000000000000000000000000;;			scheme := strings.ToLower(u.Scheme)
0000000000000000000000000000000000000000;;			u.Host = rxPort.ReplaceAllStringFunc(u.Host, func(val string) string {
0000000000000000000000000000000000000000;;				if (scheme == "http" && val == defaultHttpPort) || (scheme == "https" && val == defaultHttpsPort) {
0000000000000000000000000000000000000000;;					return ""
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return val
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeTrailingSlash(u *url.URL) {
0000000000000000000000000000000000000000;;		if l := len(u.Path); l > 0 {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(u.Path, "/") {
0000000000000000000000000000000000000000;;				u.Path = u.Path[:l-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if l = len(u.Host); l > 0 {
0000000000000000000000000000000000000000;;			if strings.HasSuffix(u.Host, "/") {
0000000000000000000000000000000000000000;;				u.Host = u.Host[:l-1]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addTrailingSlash(u *url.URL) {
0000000000000000000000000000000000000000;;		if l := len(u.Path); l > 0 {
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(u.Path, "/") {
0000000000000000000000000000000000000000;;				u.Path += "/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else if l = len(u.Host); l > 0 {
0000000000000000000000000000000000000000;;			if !strings.HasSuffix(u.Host, "/") {
0000000000000000000000000000000000000000;;				u.Host += "/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeDotSegments(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Path) > 0 {
0000000000000000000000000000000000000000;;			var dotFree []string
0000000000000000000000000000000000000000;;			var lastIsDot bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			sections := strings.Split(u.Path, "/")
0000000000000000000000000000000000000000;;			for _, s := range sections {
0000000000000000000000000000000000000000;;				if s == ".." {
0000000000000000000000000000000000000000;;					if len(dotFree) > 0 {
0000000000000000000000000000000000000000;;						dotFree = dotFree[:len(dotFree)-1]
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else if s != "." {
0000000000000000000000000000000000000000;;					dotFree = append(dotFree, s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				lastIsDot = (s == "." || s == "..")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Special case if host does not end with / and new path does not begin with /
0000000000000000000000000000000000000000;;			u.Path = strings.Join(dotFree, "/")
0000000000000000000000000000000000000000;;			if u.Host != "" && !strings.HasSuffix(u.Host, "/") && !strings.HasPrefix(u.Path, "/") {
0000000000000000000000000000000000000000;;				u.Path = "/" + u.Path
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// Special case if the last segment was a dot, make sure the path ends with a slash
0000000000000000000000000000000000000000;;			if lastIsDot && !strings.HasSuffix(u.Path, "/") {
0000000000000000000000000000000000000000;;				u.Path += "/"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeDirectoryIndex(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Path) > 0 {
0000000000000000000000000000000000000000;;			u.Path = rxDirIndex.ReplaceAllString(u.Path, "$1")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeFragment(u *url.URL) {
0000000000000000000000000000000000000000;;		u.Fragment = ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func forceHTTP(u *url.URL) {
0000000000000000000000000000000000000000;;		if strings.ToLower(u.Scheme) == "https" {
0000000000000000000000000000000000000000;;			u.Scheme = "http"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeDuplicateSlashes(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Path) > 0 {
0000000000000000000000000000000000000000;;			u.Path = rxDupSlashes.ReplaceAllString(u.Path, "/")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeWWW(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 && strings.HasPrefix(strings.ToLower(u.Host), "www.") {
0000000000000000000000000000000000000000;;			u.Host = u.Host[4:]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func addWWW(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 && !strings.HasPrefix(strings.ToLower(u.Host), "www.") {
0000000000000000000000000000000000000000;;			u.Host = "www." + u.Host
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sortQuery(u *url.URL) {
0000000000000000000000000000000000000000;;		q := u.Query()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(q) > 0 {
0000000000000000000000000000000000000000;;			arKeys := make([]string, len(q))
0000000000000000000000000000000000000000;;			i := 0
0000000000000000000000000000000000000000;;			for k, _ := range q {
0000000000000000000000000000000000000000;;				arKeys[i] = k
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sort.Strings(arKeys)
0000000000000000000000000000000000000000;;			buf := new(bytes.Buffer)
0000000000000000000000000000000000000000;;			for _, k := range arKeys {
0000000000000000000000000000000000000000;;				sort.Strings(q[k])
0000000000000000000000000000000000000000;;				for _, v := range q[k] {
0000000000000000000000000000000000000000;;					if buf.Len() > 0 {
0000000000000000000000000000000000000000;;						buf.WriteRune('&')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					buf.WriteString(fmt.Sprintf("%s=%s", k, urlesc.QueryEscape(v)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Rebuild the raw query string
0000000000000000000000000000000000000000;;			u.RawQuery = buf.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeDWORDHost(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 {
0000000000000000000000000000000000000000;;			if matches := rxDWORDHost.FindStringSubmatch(u.Host); len(matches) > 2 {
0000000000000000000000000000000000000000;;				var parts [4]int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				dword, _ := strconv.ParseInt(matches[1], 10, 0)
0000000000000000000000000000000000000000;;				for i, shift := range []uint{24, 16, 8, 0} {
0000000000000000000000000000000000000000;;					parts[i] = dword >> shift & 0xFF
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				u.Host = fmt.Sprintf("%d.%d.%d.%d%s", parts[0], parts[1], parts[2], parts[3], matches[2])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeOctalHost(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 {
0000000000000000000000000000000000000000;;			if matches := rxOctalHost.FindStringSubmatch(u.Host); len(matches) > 5 {
0000000000000000000000000000000000000000;;				var parts [4]int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i := 1; i <= 4; i++ {
0000000000000000000000000000000000000000;;					parts[i-1], _ = strconv.ParseInt(matches[i], 8, 0)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				u.Host = fmt.Sprintf("%d.%d.%d.%d%s", parts[0], parts[1], parts[2], parts[3], matches[5])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decodeHexHost(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 {
0000000000000000000000000000000000000000;;			if matches := rxHexHost.FindStringSubmatch(u.Host); len(matches) > 2 {
0000000000000000000000000000000000000000;;				// Conversion is safe because of regex validation
0000000000000000000000000000000000000000;;				parsed, _ := strconv.ParseInt(matches[1], 16, 0)
0000000000000000000000000000000000000000;;				// Set host as DWORD (base 10) encoded host
0000000000000000000000000000000000000000;;				u.Host = fmt.Sprintf("%d%s", parsed, matches[2])
0000000000000000000000000000000000000000;;				// The rest is the same as decoding a DWORD host
0000000000000000000000000000000000000000;;				decodeDWORDHost(u)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeUnncessaryHostDots(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 {
0000000000000000000000000000000000000000;;			if matches := rxHostDots.FindStringSubmatch(u.Host); len(matches) > 1 {
0000000000000000000000000000000000000000;;				// Trim the leading and trailing dots
0000000000000000000000000000000000000000;;				u.Host = strings.Trim(matches[1], ".")
0000000000000000000000000000000000000000;;				if len(matches) > 2 {
0000000000000000000000000000000000000000;;					u.Host += matches[2]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func removeEmptyPortSeparator(u *url.URL) {
0000000000000000000000000000000000000000;;		if len(u.Host) > 0 {
0000000000000000000000000000000000000000;;			u.Host = rxEmptyPort.ReplaceAllString(u.Host, "")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
