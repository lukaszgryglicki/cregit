0000000000000000000000000000000000000000;;	// Copyright 2009 The Go Authors. All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// Package urlesc implements query escaping as per RFC 3986.
0000000000000000000000000000000000000000;;	// It contains some parts of the net/url package, modified so as to allow
0000000000000000000000000000000000000000;;	// some reserved characters incorrectly escaped by net/url.
0000000000000000000000000000000000000000;;	// See https://github.com/golang/go/issues/5684
0000000000000000000000000000000000000000;;	package urlesc
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type encoding int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		encodePath encoding = 1 + iota
0000000000000000000000000000000000000000;;		encodeUserPassword
0000000000000000000000000000000000000000;;		encodeQueryComponent
0000000000000000000000000000000000000000;;		encodeFragment
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return true if the specified character should be escaped when
0000000000000000000000000000000000000000;;	// appearing in a URL string, according to RFC 3986.
0000000000000000000000000000000000000000;;	func shouldEscape(c byte, mode encoding) bool {
0000000000000000000000000000000000000000;;		// §2.3 Unreserved characters (alphanum)
0000000000000000000000000000000000000000;;		if 'A' <= c && c <= 'Z' || 'a' <= c && c <= 'z' || '0' <= c && c <= '9' {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch c {
0000000000000000000000000000000000000000;;		case '-', '.', '_', '~': // §2.3 Unreserved characters (mark)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// §2.2 Reserved characters (reserved)
0000000000000000000000000000000000000000;;		case ':', '/', '?', '#', '[', ']', '@', // gen-delims
0000000000000000000000000000000000000000;;			'!', '$', '&', '\'', '(', ')', '*', '+', ',', ';', '=': // sub-delims
0000000000000000000000000000000000000000;;			// Different sections of the URL allow a few of
0000000000000000000000000000000000000000;;			// the reserved characters to appear unescaped.
0000000000000000000000000000000000000000;;			switch mode {
0000000000000000000000000000000000000000;;			case encodePath: // §3.3
0000000000000000000000000000000000000000;;				// The RFC allows sub-delims and : @.
0000000000000000000000000000000000000000;;				// '/', '[' and ']' can be used to assign meaning to individual path
0000000000000000000000000000000000000000;;				// segments.  This package only manipulates the path as a whole,
0000000000000000000000000000000000000000;;				// so we allow those as well.  That leaves only ? and # to escape.
0000000000000000000000000000000000000000;;				return c == '?' || c == '#'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case encodeUserPassword: // §3.2.1
0000000000000000000000000000000000000000;;				// The RFC allows : and sub-delims in
0000000000000000000000000000000000000000;;				// userinfo.  The parsing of userinfo treats ':' as special so we must escape
0000000000000000000000000000000000000000;;				// all the gen-delims.
0000000000000000000000000000000000000000;;				return c == ':' || c == '/' || c == '?' || c == '#' || c == '[' || c == ']' || c == '@'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case encodeQueryComponent: // §3.4
0000000000000000000000000000000000000000;;				// The RFC allows / and ?.
0000000000000000000000000000000000000000;;				return c != '/' && c != '?'
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case encodeFragment: // §4.1
0000000000000000000000000000000000000000;;				// The RFC text is silent but the grammar allows
0000000000000000000000000000000000000000;;				// everything, so escape nothing but #
0000000000000000000000000000000000000000;;				return c == '#'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Everything else must be escaped.
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// QueryEscape escapes the string so it can be safely placed
0000000000000000000000000000000000000000;;	// inside a URL query.
0000000000000000000000000000000000000000;;	func QueryEscape(s string) string {
0000000000000000000000000000000000000000;;		return escape(s, encodeQueryComponent)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escape(s string, mode encoding) string {
0000000000000000000000000000000000000000;;		spaceCount, hexCount := 0, 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			c := s[i]
0000000000000000000000000000000000000000;;			if shouldEscape(c, mode) {
0000000000000000000000000000000000000000;;				if c == ' ' && mode == encodeQueryComponent {
0000000000000000000000000000000000000000;;					spaceCount++
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					hexCount++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spaceCount == 0 && hexCount == 0 {
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		t := make([]byte, len(s)+2*hexCount)
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(s); i++ {
0000000000000000000000000000000000000000;;			switch c := s[i]; {
0000000000000000000000000000000000000000;;			case c == ' ' && mode == encodeQueryComponent:
0000000000000000000000000000000000000000;;				t[j] = '+'
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;			case shouldEscape(c, mode):
0000000000000000000000000000000000000000;;				t[j] = '%'
0000000000000000000000000000000000000000;;				t[j+1] = "0123456789ABCDEF"[c>>4]
0000000000000000000000000000000000000000;;				t[j+2] = "0123456789ABCDEF"[c&15]
0000000000000000000000000000000000000000;;				j += 3
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				t[j] = s[i]
0000000000000000000000000000000000000000;;				j++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return string(t)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var uiReplacer = strings.NewReplacer(
0000000000000000000000000000000000000000;;		"%21", "!",
0000000000000000000000000000000000000000;;		"%27", "'",
0000000000000000000000000000000000000000;;		"%28", "(",
0000000000000000000000000000000000000000;;		"%29", ")",
0000000000000000000000000000000000000000;;		"%2A", "*",
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// unescapeUserinfo unescapes some characters that need not to be escaped as per RFC3986.
0000000000000000000000000000000000000000;;	func unescapeUserinfo(s string) string {
0000000000000000000000000000000000000000;;		return uiReplacer.Replace(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Escape reassembles the URL into a valid URL string.
0000000000000000000000000000000000000000;;	// The general form of the result is one of:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//	scheme:opaque
0000000000000000000000000000000000000000;;	//	scheme://userinfo@host/path?query#fragment
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If u.Opaque is non-empty, String uses the first form;
0000000000000000000000000000000000000000;;	// otherwise it uses the second form.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In the second form, the following rules apply:
0000000000000000000000000000000000000000;;	//	- if u.Scheme is empty, scheme: is omitted.
0000000000000000000000000000000000000000;;	//	- if u.User is nil, userinfo@ is omitted.
0000000000000000000000000000000000000000;;	//	- if u.Host is empty, host/ is omitted.
0000000000000000000000000000000000000000;;	//	- if u.Scheme and u.Host are empty and u.User is nil,
0000000000000000000000000000000000000000;;	//	   the entire scheme://userinfo@host/ is omitted.
0000000000000000000000000000000000000000;;	//	- if u.Host is non-empty and u.Path begins with a /,
0000000000000000000000000000000000000000;;	//	   the form host/path does not add its own /.
0000000000000000000000000000000000000000;;	//	- if u.RawQuery is empty, ?query is omitted.
0000000000000000000000000000000000000000;;	//	- if u.Fragment is empty, #fragment is omitted.
0000000000000000000000000000000000000000;;	func Escape(u *url.URL) string {
0000000000000000000000000000000000000000;;		var buf bytes.Buffer
0000000000000000000000000000000000000000;;		if u.Scheme != "" {
0000000000000000000000000000000000000000;;			buf.WriteString(u.Scheme)
0000000000000000000000000000000000000000;;			buf.WriteByte(':')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.Opaque != "" {
0000000000000000000000000000000000000000;;			buf.WriteString(u.Opaque)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if u.Scheme != "" || u.Host != "" || u.User != nil {
0000000000000000000000000000000000000000;;				buf.WriteString("//")
0000000000000000000000000000000000000000;;				if ui := u.User; ui != nil {
0000000000000000000000000000000000000000;;					buf.WriteString(unescapeUserinfo(ui.String()))
0000000000000000000000000000000000000000;;					buf.WriteByte('@')
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if h := u.Host; h != "" {
0000000000000000000000000000000000000000;;					buf.WriteString(h)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if u.Path != "" && u.Path[0] != '/' && u.Host != "" {
0000000000000000000000000000000000000000;;				buf.WriteByte('/')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			buf.WriteString(escape(u.Path, encodePath))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.RawQuery != "" {
0000000000000000000000000000000000000000;;			buf.WriteByte('?')
0000000000000000000000000000000000000000;;			buf.WriteString(u.RawQuery)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if u.Fragment != "" {
0000000000000000000000000000000000000000;;			buf.WriteByte('#')
0000000000000000000000000000000000000000;;			buf.WriteString(escape(u.Fragment, encodeFragment))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.String()
0000000000000000000000000000000000000000;;	}
