0000000000000000000000000000000000000000;;	// Package difflib is a partial port of Python difflib module.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It provides tools to compare sequences of strings and generate textual diffs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The following class and functions have been ported:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - SequenceMatcher
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - unified_diff
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// - context_diff
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Getting unified diffs was the main goal of the port. Keep in mind this code
0000000000000000000000000000000000000000;;	// is mostly suitable to output text differences in a human friendly way, there
0000000000000000000000000000000000000000;;	// are no guarantees generated diffs are consumable by patch(1).
0000000000000000000000000000000000000000;;	package difflib
cbbd4a4f1808f50f3134f19f04b8766ac02d04f9;Godeps/_workspace/src/github.com/pmezard/go-difflib/difflib/difflib.go[Godeps/_workspace/src/github.com/pmezard/go-difflib/difflib/difflib.go][vendor/github.com/pmezard/go-difflib/difflib/difflib.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bufio"
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func min(a, b int) int {
0000000000000000000000000000000000000000;;		if a < b {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func max(a, b int) int {
0000000000000000000000000000000000000000;;		if a > b {
0000000000000000000000000000000000000000;;			return a
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func calculateRatio(matches, length int) float64 {
0000000000000000000000000000000000000000;;		if length > 0 {
0000000000000000000000000000000000000000;;			return 2.0 * float64(matches) / float64(length)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 1.0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type Match struct {
0000000000000000000000000000000000000000;;		A    int
0000000000000000000000000000000000000000;;		B    int
0000000000000000000000000000000000000000;;		Size int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type OpCode struct {
0000000000000000000000000000000000000000;;		Tag byte
0000000000000000000000000000000000000000;;		I1  int
0000000000000000000000000000000000000000;;		I2  int
0000000000000000000000000000000000000000;;		J1  int
0000000000000000000000000000000000000000;;		J2  int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SequenceMatcher compares sequence of strings. The basic
0000000000000000000000000000000000000000;;	// algorithm predates, and is a little fancier than, an algorithm
0000000000000000000000000000000000000000;;	// published in the late 1980's by Ratcliff and Obershelp under the
0000000000000000000000000000000000000000;;	// hyperbolic name "gestalt pattern matching".  The basic idea is to find
0000000000000000000000000000000000000000;;	// the longest contiguous matching subsequence that contains no "junk"
0000000000000000000000000000000000000000;;	// elements (R-O doesn't address junk).  The same idea is then applied
0000000000000000000000000000000000000000;;	// recursively to the pieces of the sequences to the left and to the right
0000000000000000000000000000000000000000;;	// of the matching subsequence.  This does not yield minimal edit
0000000000000000000000000000000000000000;;	// sequences, but does tend to yield matches that "look right" to people.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// SequenceMatcher tries to compute a "human-friendly diff" between two
0000000000000000000000000000000000000000;;	// sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the
0000000000000000000000000000000000000000;;	// longest *contiguous* & junk-free matching subsequence.  That's what
0000000000000000000000000000000000000000;;	// catches peoples' eyes.  The Windows(tm) windiff has another interesting
0000000000000000000000000000000000000000;;	// notion, pairing up elements that appear uniquely in each sequence.
0000000000000000000000000000000000000000;;	// That, and the method here, appear to yield more intuitive difference
0000000000000000000000000000000000000000;;	// reports than does diff.  This method appears to be the least vulnerable
0000000000000000000000000000000000000000;;	// to synching up on blocks of "junk lines", though (like blank lines in
0000000000000000000000000000000000000000;;	// ordinary text files, or maybe "<P>" lines in HTML files).  That may be
0000000000000000000000000000000000000000;;	// because this is the only method of the 3 that has a *concept* of
0000000000000000000000000000000000000000;;	// "junk" <wink>.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Timing:  Basic R-O is cubic time worst case and quadratic time expected
0000000000000000000000000000000000000000;;	// case.  SequenceMatcher is quadratic time for the worst case and has
0000000000000000000000000000000000000000;;	// expected-case behavior dependent in a complicated way on how many
0000000000000000000000000000000000000000;;	// elements the sequences have in common; best case time is linear.
0000000000000000000000000000000000000000;;	type SequenceMatcher struct {
0000000000000000000000000000000000000000;;		a              []string
0000000000000000000000000000000000000000;;		b              []string
0000000000000000000000000000000000000000;;		b2j            map[string][]int
0000000000000000000000000000000000000000;;		IsJunk         func(string) bool
0000000000000000000000000000000000000000;;		autoJunk       bool
0000000000000000000000000000000000000000;;		bJunk          map[string]struct{}
0000000000000000000000000000000000000000;;		matchingBlocks []Match
0000000000000000000000000000000000000000;;		fullBCount     map[string]int
0000000000000000000000000000000000000000;;		bPopular       map[string]struct{}
0000000000000000000000000000000000000000;;		opCodes        []OpCode
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMatcher(a, b []string) *SequenceMatcher {
0000000000000000000000000000000000000000;;		m := SequenceMatcher{autoJunk: true}
0000000000000000000000000000000000000000;;		m.SetSeqs(a, b)
0000000000000000000000000000000000000000;;		return &m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func NewMatcherWithJunk(a, b []string, autoJunk bool,
0000000000000000000000000000000000000000;;		isJunk func(string) bool) *SequenceMatcher {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		m := SequenceMatcher{IsJunk: isJunk, autoJunk: autoJunk}
0000000000000000000000000000000000000000;;		m.SetSeqs(a, b)
0000000000000000000000000000000000000000;;		return &m
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set two sequences to be compared.
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) SetSeqs(a, b []string) {
0000000000000000000000000000000000000000;;		m.SetSeq1(a)
0000000000000000000000000000000000000000;;		m.SetSeq2(b)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the first sequence to be compared. The second sequence to be compared is
0000000000000000000000000000000000000000;;	// not changed.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// SequenceMatcher computes and caches detailed information about the second
0000000000000000000000000000000000000000;;	// sequence, so if you want to compare one sequence S against many sequences,
0000000000000000000000000000000000000000;;	// use .SetSeq2(s) once and call .SetSeq1(x) repeatedly for each of the other
0000000000000000000000000000000000000000;;	// sequences.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See also SetSeqs() and SetSeq2().
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) SetSeq1(a []string) {
0000000000000000000000000000000000000000;;		if &a == &m.a {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.a = a
0000000000000000000000000000000000000000;;		m.matchingBlocks = nil
0000000000000000000000000000000000000000;;		m.opCodes = nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Set the second sequence to be compared. The first sequence to be compared is
0000000000000000000000000000000000000000;;	// not changed.
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) SetSeq2(b []string) {
0000000000000000000000000000000000000000;;		if &b == &m.b {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.b = b
0000000000000000000000000000000000000000;;		m.matchingBlocks = nil
0000000000000000000000000000000000000000;;		m.opCodes = nil
0000000000000000000000000000000000000000;;		m.fullBCount = nil
0000000000000000000000000000000000000000;;		m.chainB()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) chainB() {
0000000000000000000000000000000000000000;;		// Populate line -> index mapping
0000000000000000000000000000000000000000;;		b2j := map[string][]int{}
0000000000000000000000000000000000000000;;		for i, s := range m.b {
0000000000000000000000000000000000000000;;			indices := b2j[s]
0000000000000000000000000000000000000000;;			indices = append(indices, i)
0000000000000000000000000000000000000000;;			b2j[s] = indices
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Purge junk elements
0000000000000000000000000000000000000000;;		m.bJunk = map[string]struct{}{}
0000000000000000000000000000000000000000;;		if m.IsJunk != nil {
0000000000000000000000000000000000000000;;			junk := m.bJunk
0000000000000000000000000000000000000000;;			for s, _ := range b2j {
0000000000000000000000000000000000000000;;				if m.IsJunk(s) {
0000000000000000000000000000000000000000;;					junk[s] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for s, _ := range junk {
0000000000000000000000000000000000000000;;				delete(b2j, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Purge remaining popular elements
0000000000000000000000000000000000000000;;		popular := map[string]struct{}{}
0000000000000000000000000000000000000000;;		n := len(m.b)
0000000000000000000000000000000000000000;;		if m.autoJunk && n >= 200 {
0000000000000000000000000000000000000000;;			ntest := n/100 + 1
0000000000000000000000000000000000000000;;			for s, indices := range b2j {
0000000000000000000000000000000000000000;;				if len(indices) > ntest {
0000000000000000000000000000000000000000;;					popular[s] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for s, _ := range popular {
0000000000000000000000000000000000000000;;				delete(b2j, s)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.bPopular = popular
0000000000000000000000000000000000000000;;		m.b2j = b2j
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) isBJunk(s string) bool {
0000000000000000000000000000000000000000;;		_, ok := m.bJunk[s]
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find longest matching block in a[alo:ahi] and b[blo:bhi].
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If IsJunk is not defined:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
0000000000000000000000000000000000000000;;	//     alo <= i <= i+k <= ahi
0000000000000000000000000000000000000000;;	//     blo <= j <= j+k <= bhi
0000000000000000000000000000000000000000;;	// and for all (i',j',k') meeting those conditions,
0000000000000000000000000000000000000000;;	//     k >= k'
0000000000000000000000000000000000000000;;	//     i <= i'
0000000000000000000000000000000000000000;;	//     and if i == i', j <= j'
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In other words, of all maximal matching blocks, return one that
0000000000000000000000000000000000000000;;	// starts earliest in a, and of all those maximal matching blocks that
0000000000000000000000000000000000000000;;	// start earliest in a, return the one that starts earliest in b.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If IsJunk is defined, first the longest matching block is
0000000000000000000000000000000000000000;;	// determined as above, but with the additional restriction that no
0000000000000000000000000000000000000000;;	// junk element appears in the block.  Then that block is extended as
0000000000000000000000000000000000000000;;	// far as possible by matching (only) junk elements on both sides.  So
0000000000000000000000000000000000000000;;	// the resulting block never matches on junk except as identical junk
0000000000000000000000000000000000000000;;	// happens to be adjacent to an "interesting" match.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If no blocks match, return (alo, blo, 0).
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) findLongestMatch(alo, ahi, blo, bhi int) Match {
0000000000000000000000000000000000000000;;		// CAUTION:  stripping common prefix or suffix would be incorrect.
0000000000000000000000000000000000000000;;		// E.g.,
0000000000000000000000000000000000000000;;		//    ab
0000000000000000000000000000000000000000;;		//    acab
0000000000000000000000000000000000000000;;		// Longest matching block is "ab", but if common prefix is
0000000000000000000000000000000000000000;;		// stripped, it's "a" (tied with "b").  UNIX(tm) diff does so
0000000000000000000000000000000000000000;;		// strip, so ends up claiming that ab is changed to acab by
0000000000000000000000000000000000000000;;		// inserting "ca" in the middle.  That's minimal but unintuitive:
0000000000000000000000000000000000000000;;		// "it's obvious" that someone inserted "ac" at the front.
0000000000000000000000000000000000000000;;		// Windiff ends up at the same place as diff, but by pairing up
0000000000000000000000000000000000000000;;		// the unique 'b's and then matching the first two 'a's.
0000000000000000000000000000000000000000;;		besti, bestj, bestsize := alo, blo, 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find longest junk-free match
0000000000000000000000000000000000000000;;		// during an iteration of the loop, j2len[j] = length of longest
0000000000000000000000000000000000000000;;		// junk-free match ending with a[i-1] and b[j]
0000000000000000000000000000000000000000;;		j2len := map[int]int{}
0000000000000000000000000000000000000000;;		for i := alo; i != ahi; i++ {
0000000000000000000000000000000000000000;;			// look at all instances of a[i] in b; note that because
0000000000000000000000000000000000000000;;			// b2j has no junk keys, the loop is skipped if a[i] is junk
0000000000000000000000000000000000000000;;			newj2len := map[int]int{}
0000000000000000000000000000000000000000;;			for _, j := range m.b2j[m.a[i]] {
0000000000000000000000000000000000000000;;				// a[i] matches b[j]
0000000000000000000000000000000000000000;;				if j < blo {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if j >= bhi {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				k := j2len[j-1] + 1
0000000000000000000000000000000000000000;;				newj2len[j] = k
0000000000000000000000000000000000000000;;				if k > bestsize {
0000000000000000000000000000000000000000;;					besti, bestj, bestsize = i-k+1, j-k+1, k
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			j2len = newj2len
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Extend the best by non-junk elements on each end.  In particular,
0000000000000000000000000000000000000000;;		// "popular" non-junk elements aren't in b2j, which greatly speeds
0000000000000000000000000000000000000000;;		// the inner loop above, but also means "the best" match so far
0000000000000000000000000000000000000000;;		// doesn't contain any junk *or* popular non-junk elements.
0000000000000000000000000000000000000000;;		for besti > alo && bestj > blo && !m.isBJunk(m.b[bestj-1]) &&
0000000000000000000000000000000000000000;;			m.a[besti-1] == m.b[bestj-1] {
0000000000000000000000000000000000000000;;			besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for besti+bestsize < ahi && bestj+bestsize < bhi &&
0000000000000000000000000000000000000000;;			!m.isBJunk(m.b[bestj+bestsize]) &&
0000000000000000000000000000000000000000;;			m.a[besti+bestsize] == m.b[bestj+bestsize] {
0000000000000000000000000000000000000000;;			bestsize += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now that we have a wholly interesting match (albeit possibly
0000000000000000000000000000000000000000;;		// empty!), we may as well suck up the matching junk on each
0000000000000000000000000000000000000000;;		// side of it too.  Can't think of a good reason not to, and it
0000000000000000000000000000000000000000;;		// saves post-processing the (possibly considerable) expense of
0000000000000000000000000000000000000000;;		// figuring out what to do with it.  In the case of an empty
0000000000000000000000000000000000000000;;		// interesting match, this is clearly the right thing to do,
0000000000000000000000000000000000000000;;		// because no other kind of match is possible in the regions.
0000000000000000000000000000000000000000;;		for besti > alo && bestj > blo && m.isBJunk(m.b[bestj-1]) &&
0000000000000000000000000000000000000000;;			m.a[besti-1] == m.b[bestj-1] {
0000000000000000000000000000000000000000;;			besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for besti+bestsize < ahi && bestj+bestsize < bhi &&
0000000000000000000000000000000000000000;;			m.isBJunk(m.b[bestj+bestsize]) &&
0000000000000000000000000000000000000000;;			m.a[besti+bestsize] == m.b[bestj+bestsize] {
0000000000000000000000000000000000000000;;			bestsize += 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return Match{A: besti, B: bestj, Size: bestsize}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return list of triples describing matching subsequences.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each triple is of the form (i, j, n), and means that
0000000000000000000000000000000000000000;;	// a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
0000000000000000000000000000000000000000;;	// i and in j. It's also guaranteed that if (i, j, n) and (i', j', n') are
0000000000000000000000000000000000000000;;	// adjacent triples in the list, and the second is not the last triple in the
0000000000000000000000000000000000000000;;	// list, then i+n != i' or j+n != j'. IOW, adjacent triples never describe
0000000000000000000000000000000000000000;;	// adjacent equal blocks.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The last triple is a dummy, (len(a), len(b), 0), and is the only
0000000000000000000000000000000000000000;;	// triple with n==0.
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) GetMatchingBlocks() []Match {
0000000000000000000000000000000000000000;;		if m.matchingBlocks != nil {
0000000000000000000000000000000000000000;;			return m.matchingBlocks
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var matchBlocks func(alo, ahi, blo, bhi int, matched []Match) []Match
0000000000000000000000000000000000000000;;		matchBlocks = func(alo, ahi, blo, bhi int, matched []Match) []Match {
0000000000000000000000000000000000000000;;			match := m.findLongestMatch(alo, ahi, blo, bhi)
0000000000000000000000000000000000000000;;			i, j, k := match.A, match.B, match.Size
0000000000000000000000000000000000000000;;			if match.Size > 0 {
0000000000000000000000000000000000000000;;				if alo < i && blo < j {
0000000000000000000000000000000000000000;;					matched = matchBlocks(alo, i, blo, j, matched)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				matched = append(matched, match)
0000000000000000000000000000000000000000;;				if i+k < ahi && j+k < bhi {
0000000000000000000000000000000000000000;;					matched = matchBlocks(i+k, ahi, j+k, bhi, matched)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return matched
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		matched := matchBlocks(0, len(m.a), 0, len(m.b), nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// It's possible that we have adjacent equal blocks in the
0000000000000000000000000000000000000000;;		// matching_blocks list now.
0000000000000000000000000000000000000000;;		nonAdjacent := []Match{}
0000000000000000000000000000000000000000;;		i1, j1, k1 := 0, 0, 0
0000000000000000000000000000000000000000;;		for _, b := range matched {
0000000000000000000000000000000000000000;;			// Is this block adjacent to i1, j1, k1?
0000000000000000000000000000000000000000;;			i2, j2, k2 := b.A, b.B, b.Size
0000000000000000000000000000000000000000;;			if i1+k1 == i2 && j1+k1 == j2 {
0000000000000000000000000000000000000000;;				// Yes, so collapse them -- this just increases the length of
0000000000000000000000000000000000000000;;				// the first block by the length of the second, and the first
0000000000000000000000000000000000000000;;				// block so lengthened remains the block to compare against.
0000000000000000000000000000000000000000;;				k1 += k2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// Not adjacent.  Remember the first block (k1==0 means it's
0000000000000000000000000000000000000000;;				// the dummy we started with), and make the second block the
0000000000000000000000000000000000000000;;				// new block to compare against.
0000000000000000000000000000000000000000;;				if k1 > 0 {
0000000000000000000000000000000000000000;;					nonAdjacent = append(nonAdjacent, Match{i1, j1, k1})
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i1, j1, k1 = i2, j2, k2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if k1 > 0 {
0000000000000000000000000000000000000000;;			nonAdjacent = append(nonAdjacent, Match{i1, j1, k1})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nonAdjacent = append(nonAdjacent, Match{len(m.a), len(m.b), 0})
0000000000000000000000000000000000000000;;		m.matchingBlocks = nonAdjacent
0000000000000000000000000000000000000000;;		return m.matchingBlocks
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return list of 5-tuples describing how to turn a into b.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
0000000000000000000000000000000000000000;;	// has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
0000000000000000000000000000000000000000;;	// tuple preceding it, and likewise for j1 == the previous j2.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The tags are characters, with these meanings:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'r' (replace):  a[i1:i2] should be replaced by b[j1:j2]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'd' (delete):   a[i1:i2] should be deleted, j1==j2 in this case.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'i' (insert):   b[j1:j2] should be inserted at a[i1:i1], i1==i2 in this case.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 'e' (equal):    a[i1:i2] == b[j1:j2]
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) GetOpCodes() []OpCode {
0000000000000000000000000000000000000000;;		if m.opCodes != nil {
0000000000000000000000000000000000000000;;			return m.opCodes
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i, j := 0, 0
0000000000000000000000000000000000000000;;		matching := m.GetMatchingBlocks()
0000000000000000000000000000000000000000;;		opCodes := make([]OpCode, 0, len(matching))
0000000000000000000000000000000000000000;;		for _, m := range matching {
0000000000000000000000000000000000000000;;			//  invariant:  we've pumped out correct diffs to change
0000000000000000000000000000000000000000;;			//  a[:i] into b[:j], and the next matching block is
0000000000000000000000000000000000000000;;			//  a[ai:ai+size] == b[bj:bj+size]. So we need to pump
0000000000000000000000000000000000000000;;			//  out a diff to change a[i:ai] into b[j:bj], pump out
0000000000000000000000000000000000000000;;			//  the matching block, and move (i,j) beyond the match
0000000000000000000000000000000000000000;;			ai, bj, size := m.A, m.B, m.Size
0000000000000000000000000000000000000000;;			tag := byte(0)
0000000000000000000000000000000000000000;;			if i < ai && j < bj {
0000000000000000000000000000000000000000;;				tag = 'r'
0000000000000000000000000000000000000000;;			} else if i < ai {
0000000000000000000000000000000000000000;;				tag = 'd'
0000000000000000000000000000000000000000;;			} else if j < bj {
0000000000000000000000000000000000000000;;				tag = 'i'
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if tag > 0 {
0000000000000000000000000000000000000000;;				opCodes = append(opCodes, OpCode{tag, i, ai, j, bj})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i, j = ai+size, bj+size
0000000000000000000000000000000000000000;;			// the list of matching blocks is terminated by a
0000000000000000000000000000000000000000;;			// sentinel with size 0
0000000000000000000000000000000000000000;;			if size > 0 {
0000000000000000000000000000000000000000;;				opCodes = append(opCodes, OpCode{'e', ai, i, bj, j})
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		m.opCodes = opCodes
0000000000000000000000000000000000000000;;		return m.opCodes
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Isolate change clusters by eliminating ranges with no changes.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Return a generator of groups with up to n lines of context.
0000000000000000000000000000000000000000;;	// Each group is in the same format as returned by GetOpCodes().
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) GetGroupedOpCodes(n int) [][]OpCode {
0000000000000000000000000000000000000000;;		if n < 0 {
0000000000000000000000000000000000000000;;			n = 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		codes := m.GetOpCodes()
0000000000000000000000000000000000000000;;		if len(codes) == 0 {
0000000000000000000000000000000000000000;;			codes = []OpCode{OpCode{'e', 0, 1, 0, 1}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Fixup leading and trailing groups if they show no changes.
0000000000000000000000000000000000000000;;		if codes[0].Tag == 'e' {
0000000000000000000000000000000000000000;;			c := codes[0]
0000000000000000000000000000000000000000;;			i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
0000000000000000000000000000000000000000;;			codes[0] = OpCode{c.Tag, max(i1, i2-n), i2, max(j1, j2-n), j2}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if codes[len(codes)-1].Tag == 'e' {
0000000000000000000000000000000000000000;;			c := codes[len(codes)-1]
0000000000000000000000000000000000000000;;			i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
0000000000000000000000000000000000000000;;			codes[len(codes)-1] = OpCode{c.Tag, i1, min(i2, i1+n), j1, min(j2, j1+n)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nn := n + n
0000000000000000000000000000000000000000;;		groups := [][]OpCode{}
0000000000000000000000000000000000000000;;		group := []OpCode{}
0000000000000000000000000000000000000000;;		for _, c := range codes {
0000000000000000000000000000000000000000;;			i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
0000000000000000000000000000000000000000;;			// End the current group and start a new one whenever
0000000000000000000000000000000000000000;;			// there is a large range with no changes.
0000000000000000000000000000000000000000;;			if c.Tag == 'e' && i2-i1 > nn {
0000000000000000000000000000000000000000;;				group = append(group, OpCode{c.Tag, i1, min(i2, i1+n),
0000000000000000000000000000000000000000;;					j1, min(j2, j1+n)})
0000000000000000000000000000000000000000;;				groups = append(groups, group)
0000000000000000000000000000000000000000;;				group = []OpCode{}
0000000000000000000000000000000000000000;;				i1, j1 = max(i1, i2-n), max(j1, j2-n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			group = append(group, OpCode{c.Tag, i1, i2, j1, j2})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(group) > 0 && !(len(group) == 1 && group[0].Tag == 'e') {
0000000000000000000000000000000000000000;;			groups = append(groups, group)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return groups
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return a measure of the sequences' similarity (float in [0,1]).
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Where T is the total number of elements in both sequences, and
0000000000000000000000000000000000000000;;	// M is the number of matches, this is 2.0*M / T.
0000000000000000000000000000000000000000;;	// Note that this is 1 if the sequences are identical, and 0 if
0000000000000000000000000000000000000000;;	// they have nothing in common.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// .Ratio() is expensive to compute if you haven't already computed
0000000000000000000000000000000000000000;;	// .GetMatchingBlocks() or .GetOpCodes(), in which case you may
0000000000000000000000000000000000000000;;	// want to try .QuickRatio() or .RealQuickRation() first to get an
0000000000000000000000000000000000000000;;	// upper bound.
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) Ratio() float64 {
0000000000000000000000000000000000000000;;		matches := 0
0000000000000000000000000000000000000000;;		for _, m := range m.GetMatchingBlocks() {
0000000000000000000000000000000000000000;;			matches += m.Size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return calculateRatio(matches, len(m.a)+len(m.b))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return an upper bound on ratio() relatively quickly.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This isn't defined beyond that it is an upper bound on .Ratio(), and
0000000000000000000000000000000000000000;;	// is faster to compute.
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) QuickRatio() float64 {
0000000000000000000000000000000000000000;;		// viewing a and b as multisets, set matches to the cardinality
0000000000000000000000000000000000000000;;		// of their intersection; this counts the number of matches
0000000000000000000000000000000000000000;;		// without regard to order, so is clearly an upper bound
0000000000000000000000000000000000000000;;		if m.fullBCount == nil {
0000000000000000000000000000000000000000;;			m.fullBCount = map[string]int{}
0000000000000000000000000000000000000000;;			for _, s := range m.b {
0000000000000000000000000000000000000000;;				m.fullBCount[s] = m.fullBCount[s] + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// avail[x] is the number of times x appears in 'b' less the
0000000000000000000000000000000000000000;;		// number of times we've seen it in 'a' so far ... kinda
0000000000000000000000000000000000000000;;		avail := map[string]int{}
0000000000000000000000000000000000000000;;		matches := 0
0000000000000000000000000000000000000000;;		for _, s := range m.a {
0000000000000000000000000000000000000000;;			n, ok := avail[s]
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				n = m.fullBCount[s]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			avail[s] = n - 1
0000000000000000000000000000000000000000;;			if n > 0 {
0000000000000000000000000000000000000000;;				matches += 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return calculateRatio(matches, len(m.a)+len(m.b))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Return an upper bound on ratio() very quickly.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This isn't defined beyond that it is an upper bound on .Ratio(), and
0000000000000000000000000000000000000000;;	// is faster to compute than either .Ratio() or .QuickRatio().
0000000000000000000000000000000000000000;;	func (m *SequenceMatcher) RealQuickRatio() float64 {
0000000000000000000000000000000000000000;;		la, lb := len(m.a), len(m.b)
0000000000000000000000000000000000000000;;		return calculateRatio(min(la, lb), la+lb)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert range to the "ed" format
0000000000000000000000000000000000000000;;	func formatRangeUnified(start, stop int) string {
0000000000000000000000000000000000000000;;		// Per the diff spec at http://www.unix.org/single_unix_specification/
0000000000000000000000000000000000000000;;		beginning := start + 1 // lines start numbering with one
0000000000000000000000000000000000000000;;		length := stop - start
0000000000000000000000000000000000000000;;		if length == 1 {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%d", beginning)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if length == 0 {
0000000000000000000000000000000000000000;;			beginning -= 1 // empty ranges begin at line just before the range
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d,%d", beginning, length)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unified diff parameters
0000000000000000000000000000000000000000;;	type UnifiedDiff struct {
0000000000000000000000000000000000000000;;		A        []string // First sequence lines
0000000000000000000000000000000000000000;;		FromFile string   // First file name
0000000000000000000000000000000000000000;;		FromDate string   // First file time
0000000000000000000000000000000000000000;;		B        []string // Second sequence lines
0000000000000000000000000000000000000000;;		ToFile   string   // Second file name
0000000000000000000000000000000000000000;;		ToDate   string   // Second file time
0000000000000000000000000000000000000000;;		Eol      string   // Headers end of line, defaults to LF
0000000000000000000000000000000000000000;;		Context  int      // Number of context lines
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare two sequences of lines; generate the delta as a unified diff.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unified diffs are a compact way of showing line changes and a few
0000000000000000000000000000000000000000;;	// lines of context.  The number of context lines is set by 'n' which
0000000000000000000000000000000000000000;;	// defaults to three.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// By default, the diff control lines (those with ---, +++, or @@) are
0000000000000000000000000000000000000000;;	// created with a trailing newline.  This is helpful so that inputs
0000000000000000000000000000000000000000;;	// created from file.readlines() result in diffs that are suitable for
0000000000000000000000000000000000000000;;	// file.writelines() since both the inputs and outputs have trailing
0000000000000000000000000000000000000000;;	// newlines.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For inputs that do not have trailing newlines, set the lineterm
0000000000000000000000000000000000000000;;	// argument to "" so that the output will be uniformly newline free.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The unidiff format normally has a header for filenames and modification
0000000000000000000000000000000000000000;;	// times.  Any or all of these may be specified using strings for
0000000000000000000000000000000000000000;;	// 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
0000000000000000000000000000000000000000;;	// The modification times are normally expressed in the ISO 8601 format.
0000000000000000000000000000000000000000;;	func WriteUnifiedDiff(writer io.Writer, diff UnifiedDiff) error {
0000000000000000000000000000000000000000;;		buf := bufio.NewWriter(writer)
0000000000000000000000000000000000000000;;		defer buf.Flush()
0000000000000000000000000000000000000000;;		w := func(format string, args ...interface{}) error {
0000000000000000000000000000000000000000;;			_, err := buf.WriteString(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(diff.Eol) == 0 {
0000000000000000000000000000000000000000;;			diff.Eol = "\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		started := false
0000000000000000000000000000000000000000;;		m := NewMatcher(diff.A, diff.B)
0000000000000000000000000000000000000000;;		for _, g := range m.GetGroupedOpCodes(diff.Context) {
0000000000000000000000000000000000000000;;			if !started {
0000000000000000000000000000000000000000;;				started = true
0000000000000000000000000000000000000000;;				fromDate := ""
0000000000000000000000000000000000000000;;				if len(diff.FromDate) > 0 {
0000000000000000000000000000000000000000;;					fromDate = "\t" + diff.FromDate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				toDate := ""
0000000000000000000000000000000000000000;;				if len(diff.ToDate) > 0 {
0000000000000000000000000000000000000000;;					toDate = "\t" + diff.ToDate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err := w("--- %s%s%s", diff.FromFile, fromDate, diff.Eol)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				err = w("+++ %s%s%s", diff.ToFile, toDate, diff.Eol)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			first, last := g[0], g[len(g)-1]
0000000000000000000000000000000000000000;;			range1 := formatRangeUnified(first.I1, last.I2)
0000000000000000000000000000000000000000;;			range2 := formatRangeUnified(first.J1, last.J2)
0000000000000000000000000000000000000000;;			if err := w("@@ -%s +%s @@%s", range1, range2, diff.Eol); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for _, c := range g {
0000000000000000000000000000000000000000;;				i1, i2, j1, j2 := c.I1, c.I2, c.J1, c.J2
0000000000000000000000000000000000000000;;				if c.Tag == 'e' {
0000000000000000000000000000000000000000;;					for _, line := range diff.A[i1:i2] {
0000000000000000000000000000000000000000;;						if err := w(" " + line); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.Tag == 'r' || c.Tag == 'd' {
0000000000000000000000000000000000000000;;					for _, line := range diff.A[i1:i2] {
0000000000000000000000000000000000000000;;						if err := w("-" + line); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if c.Tag == 'r' || c.Tag == 'i' {
0000000000000000000000000000000000000000;;					for _, line := range diff.B[j1:j2] {
0000000000000000000000000000000000000000;;						if err := w("+" + line); err != nil {
0000000000000000000000000000000000000000;;							return err
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Like WriteUnifiedDiff but returns the diff a string.
0000000000000000000000000000000000000000;;	func GetUnifiedDiffString(diff UnifiedDiff) (string, error) {
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		err := WriteUnifiedDiff(w, diff)
0000000000000000000000000000000000000000;;		return string(w.Bytes()), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convert range to the "ed" format.
0000000000000000000000000000000000000000;;	func formatRangeContext(start, stop int) string {
0000000000000000000000000000000000000000;;		// Per the diff spec at http://www.unix.org/single_unix_specification/
0000000000000000000000000000000000000000;;		beginning := start + 1 // lines start numbering with one
0000000000000000000000000000000000000000;;		length := stop - start
0000000000000000000000000000000000000000;;		if length == 0 {
0000000000000000000000000000000000000000;;			beginning -= 1 // empty ranges begin at line just before the range
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if length <= 1 {
0000000000000000000000000000000000000000;;			return fmt.Sprintf("%d", beginning)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%d,%d", beginning, beginning+length-1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ContextDiff UnifiedDiff
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Compare two sequences of lines; generate the delta as a context diff.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Context diffs are a compact way of showing line changes and a few
0000000000000000000000000000000000000000;;	// lines of context. The number of context lines is set by diff.Context
0000000000000000000000000000000000000000;;	// which defaults to three.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// By default, the diff control lines (those with *** or ---) are
0000000000000000000000000000000000000000;;	// created with a trailing newline.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For inputs that do not have trailing newlines, set the diff.Eol
0000000000000000000000000000000000000000;;	// argument to "" so that the output will be uniformly newline free.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The context diff format normally has a header for filenames and
0000000000000000000000000000000000000000;;	// modification times.  Any or all of these may be specified using
0000000000000000000000000000000000000000;;	// strings for diff.FromFile, diff.ToFile, diff.FromDate, diff.ToDate.
0000000000000000000000000000000000000000;;	// The modification times are normally expressed in the ISO 8601 format.
0000000000000000000000000000000000000000;;	// If not specified, the strings default to blanks.
0000000000000000000000000000000000000000;;	func WriteContextDiff(writer io.Writer, diff ContextDiff) error {
0000000000000000000000000000000000000000;;		buf := bufio.NewWriter(writer)
0000000000000000000000000000000000000000;;		defer buf.Flush()
0000000000000000000000000000000000000000;;		var diffErr error
0000000000000000000000000000000000000000;;		w := func(format string, args ...interface{}) {
0000000000000000000000000000000000000000;;			_, err := buf.WriteString(fmt.Sprintf(format, args...))
0000000000000000000000000000000000000000;;			if diffErr == nil && err != nil {
0000000000000000000000000000000000000000;;				diffErr = err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(diff.Eol) == 0 {
0000000000000000000000000000000000000000;;			diff.Eol = "\n"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prefix := map[byte]string{
0000000000000000000000000000000000000000;;			'i': "+ ",
0000000000000000000000000000000000000000;;			'd': "- ",
0000000000000000000000000000000000000000;;			'r': "! ",
0000000000000000000000000000000000000000;;			'e': "  ",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		started := false
0000000000000000000000000000000000000000;;		m := NewMatcher(diff.A, diff.B)
0000000000000000000000000000000000000000;;		for _, g := range m.GetGroupedOpCodes(diff.Context) {
0000000000000000000000000000000000000000;;			if !started {
0000000000000000000000000000000000000000;;				started = true
0000000000000000000000000000000000000000;;				fromDate := ""
0000000000000000000000000000000000000000;;				if len(diff.FromDate) > 0 {
0000000000000000000000000000000000000000;;					fromDate = "\t" + diff.FromDate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				toDate := ""
0000000000000000000000000000000000000000;;				if len(diff.ToDate) > 0 {
0000000000000000000000000000000000000000;;					toDate = "\t" + diff.ToDate
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				w("*** %s%s%s", diff.FromFile, fromDate, diff.Eol)
0000000000000000000000000000000000000000;;				w("--- %s%s%s", diff.ToFile, toDate, diff.Eol)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			first, last := g[0], g[len(g)-1]
0000000000000000000000000000000000000000;;			w("***************" + diff.Eol)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			range1 := formatRangeContext(first.I1, last.I2)
0000000000000000000000000000000000000000;;			w("*** %s ****%s", range1, diff.Eol)
0000000000000000000000000000000000000000;;			for _, c := range g {
0000000000000000000000000000000000000000;;				if c.Tag == 'r' || c.Tag == 'd' {
0000000000000000000000000000000000000000;;					for _, cc := range g {
0000000000000000000000000000000000000000;;						if cc.Tag == 'i' {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for _, line := range diff.A[cc.I1:cc.I2] {
0000000000000000000000000000000000000000;;							w(prefix[cc.Tag] + line)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			range2 := formatRangeContext(first.J1, last.J2)
0000000000000000000000000000000000000000;;			w("--- %s ----%s", range2, diff.Eol)
0000000000000000000000000000000000000000;;			for _, c := range g {
0000000000000000000000000000000000000000;;				if c.Tag == 'r' || c.Tag == 'i' {
0000000000000000000000000000000000000000;;					for _, cc := range g {
0000000000000000000000000000000000000000;;						if cc.Tag == 'd' {
0000000000000000000000000000000000000000;;							continue
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						for _, line := range diff.B[cc.J1:cc.J2] {
0000000000000000000000000000000000000000;;							w(prefix[cc.Tag] + line)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return diffErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Like WriteContextDiff but returns the diff a string.
0000000000000000000000000000000000000000;;	func GetContextDiffString(diff ContextDiff) (string, error) {
0000000000000000000000000000000000000000;;		w := &bytes.Buffer{}
0000000000000000000000000000000000000000;;		err := WriteContextDiff(w, diff)
0000000000000000000000000000000000000000;;		return string(w.Bytes()), err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Split a string on "\n" while preserving them. The output can be used
0000000000000000000000000000000000000000;;	// as input for UnifiedDiff and ContextDiff structures.
0000000000000000000000000000000000000000;;	func SplitLines(s string) []string {
0000000000000000000000000000000000000000;;		lines := strings.SplitAfter(s, "\n")
0000000000000000000000000000000000000000;;		lines[len(lines)-1] += "\n"
0000000000000000000000000000000000000000;;		return lines
0000000000000000000000000000000000000000;;	}
