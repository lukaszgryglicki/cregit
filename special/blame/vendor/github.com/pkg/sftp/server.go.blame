0000000000000000000000000000000000000000;;	package sftp
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	// sftp server counterpart
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"io/ioutil"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pkg/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		sftpServerWorkerCount = 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server is an SSH File Transfer Protocol (sftp) server.
0000000000000000000000000000000000000000;;	// This is intended to provide the sftp subsystem to an ssh server daemon.
0000000000000000000000000000000000000000;;	// This implementation currently supports most of sftp server protocol version 3,
0000000000000000000000000000000000000000;;	// as specified at http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		serverConn
0000000000000000000000000000000000000000;;		debugStream   io.Writer
0000000000000000000000000000000000000000;;		readOnly      bool
0000000000000000000000000000000000000000;;		pktChan       chan rxPacket
0000000000000000000000000000000000000000;;		openFiles     map[string]*os.File
0000000000000000000000000000000000000000;;		openFilesLock sync.RWMutex
0000000000000000000000000000000000000000;;		handleCount   int
0000000000000000000000000000000000000000;;		maxTxPacket   uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (svr *Server) nextHandle(f *os.File) string {
0000000000000000000000000000000000000000;;		svr.openFilesLock.Lock()
0000000000000000000000000000000000000000;;		defer svr.openFilesLock.Unlock()
0000000000000000000000000000000000000000;;		svr.handleCount++
0000000000000000000000000000000000000000;;		handle := strconv.Itoa(svr.handleCount)
0000000000000000000000000000000000000000;;		svr.openFiles[handle] = f
0000000000000000000000000000000000000000;;		return handle
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (svr *Server) closeHandle(handle string) error {
0000000000000000000000000000000000000000;;		svr.openFilesLock.Lock()
0000000000000000000000000000000000000000;;		defer svr.openFilesLock.Unlock()
0000000000000000000000000000000000000000;;		if f, ok := svr.openFiles[handle]; ok {
0000000000000000000000000000000000000000;;			delete(svr.openFiles, handle)
0000000000000000000000000000000000000000;;			return f.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return syscall.EBADF
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (svr *Server) getHandle(handle string) (*os.File, bool) {
0000000000000000000000000000000000000000;;		svr.openFilesLock.RLock()
0000000000000000000000000000000000000000;;		defer svr.openFilesLock.RUnlock()
0000000000000000000000000000000000000000;;		f, ok := svr.openFiles[handle]
0000000000000000000000000000000000000000;;		return f, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverRespondablePacket interface {
0000000000000000000000000000000000000000;;		encoding.BinaryUnmarshaler
0000000000000000000000000000000000000000;;		id() uint32
0000000000000000000000000000000000000000;;		respond(svr *Server) error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewServer creates a new Server instance around the provided streams, serving
0000000000000000000000000000000000000000;;	// content from the root of the filesystem.  Optionally, ServerOption
0000000000000000000000000000000000000000;;	// functions may be specified to further configure the Server.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// A subsequent call to Serve() is required to begin serving files over SFTP.
0000000000000000000000000000000000000000;;	func NewServer(rwc io.ReadWriteCloser, options ...ServerOption) (*Server, error) {
0000000000000000000000000000000000000000;;		s := &Server{
0000000000000000000000000000000000000000;;			serverConn: serverConn{
0000000000000000000000000000000000000000;;				conn: conn{
0000000000000000000000000000000000000000;;					Reader:      rwc,
0000000000000000000000000000000000000000;;					WriteCloser: rwc,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			debugStream: ioutil.Discard,
0000000000000000000000000000000000000000;;			pktChan:     make(chan rxPacket, sftpServerWorkerCount),
0000000000000000000000000000000000000000;;			openFiles:   make(map[string]*os.File),
0000000000000000000000000000000000000000;;			maxTxPacket: 1 << 15,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, o := range options {
0000000000000000000000000000000000000000;;			if err := o(s); err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ServerOption is a function which applies configuration to a Server.
0000000000000000000000000000000000000000;;	type ServerOption func(*Server) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDebug enables Server debugging output to the supplied io.Writer.
0000000000000000000000000000000000000000;;	func WithDebug(w io.Writer) ServerOption {
0000000000000000000000000000000000000000;;		return func(s *Server) error {
0000000000000000000000000000000000000000;;			s.debugStream = w
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadOnly configures a Server to serve files in read-only mode.
0000000000000000000000000000000000000000;;	func ReadOnly() ServerOption {
0000000000000000000000000000000000000000;;		return func(s *Server) error {
0000000000000000000000000000000000000000;;			s.readOnly = true
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type rxPacket struct {
0000000000000000000000000000000000000000;;		pktType  fxp
0000000000000000000000000000000000000000;;		pktBytes []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Up to N parallel servers
0000000000000000000000000000000000000000;;	func (svr *Server) sftpServerWorker() error {
0000000000000000000000000000000000000000;;		for p := range svr.pktChan {
0000000000000000000000000000000000000000;;			var pkt interface {
0000000000000000000000000000000000000000;;				encoding.BinaryUnmarshaler
0000000000000000000000000000000000000000;;				id() uint32
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var readonly = true
0000000000000000000000000000000000000000;;			switch p.pktType {
0000000000000000000000000000000000000000;;			case ssh_FXP_INIT:
0000000000000000000000000000000000000000;;				pkt = &sshFxInitPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_LSTAT:
0000000000000000000000000000000000000000;;				pkt = &sshFxpLstatPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_OPEN:
0000000000000000000000000000000000000000;;				pkt = &sshFxpOpenPacket{}
0000000000000000000000000000000000000000;;				// readonly handled specially below
0000000000000000000000000000000000000000;;			case ssh_FXP_CLOSE:
0000000000000000000000000000000000000000;;				pkt = &sshFxpClosePacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_READ:
0000000000000000000000000000000000000000;;				pkt = &sshFxpReadPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_WRITE:
0000000000000000000000000000000000000000;;				pkt = &sshFxpWritePacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_FSTAT:
0000000000000000000000000000000000000000;;				pkt = &sshFxpFstatPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_SETSTAT:
0000000000000000000000000000000000000000;;				pkt = &sshFxpSetstatPacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_FSETSTAT:
0000000000000000000000000000000000000000;;				pkt = &sshFxpFsetstatPacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_OPENDIR:
0000000000000000000000000000000000000000;;				pkt = &sshFxpOpendirPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_READDIR:
0000000000000000000000000000000000000000;;				pkt = &sshFxpReaddirPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_REMOVE:
0000000000000000000000000000000000000000;;				pkt = &sshFxpRemovePacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_MKDIR:
0000000000000000000000000000000000000000;;				pkt = &sshFxpMkdirPacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_RMDIR:
0000000000000000000000000000000000000000;;				pkt = &sshFxpRmdirPacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_REALPATH:
0000000000000000000000000000000000000000;;				pkt = &sshFxpRealpathPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_STAT:
0000000000000000000000000000000000000000;;				pkt = &sshFxpStatPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_RENAME:
0000000000000000000000000000000000000000;;				pkt = &sshFxpRenamePacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_READLINK:
0000000000000000000000000000000000000000;;				pkt = &sshFxpReadlinkPacket{}
0000000000000000000000000000000000000000;;			case ssh_FXP_SYMLINK:
0000000000000000000000000000000000000000;;				pkt = &sshFxpSymlinkPacket{}
0000000000000000000000000000000000000000;;				readonly = false
0000000000000000000000000000000000000000;;			case ssh_FXP_EXTENDED:
0000000000000000000000000000000000000000;;				pkt = &sshFxpExtendedPacket{}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return errors.Errorf("unhandled packet type: %s", p.pktType)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if err := pkt.UnmarshalBinary(p.pktBytes); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// handle FXP_OPENDIR specially
0000000000000000000000000000000000000000;;			switch pkt := pkt.(type) {
0000000000000000000000000000000000000000;;			case *sshFxpOpenPacket:
0000000000000000000000000000000000000000;;				readonly = pkt.readonly()
0000000000000000000000000000000000000000;;			case *sshFxpExtendedPacket:
0000000000000000000000000000000000000000;;				readonly = pkt.SpecificPacket.readonly()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If server is operating read-only and a write operation is requested,
0000000000000000000000000000000000000000;;			// return permission denied
0000000000000000000000000000000000000000;;			if !readonly && svr.readOnly {
0000000000000000000000000000000000000000;;				if err := svr.sendError(pkt, syscall.EPERM); err != nil {
0000000000000000000000000000000000000000;;					return errors.Wrap(err, "failed to send read only packet response")
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := handlePacket(svr, pkt); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func handlePacket(s *Server, p interface{}) error {
0000000000000000000000000000000000000000;;		switch p := p.(type) {
0000000000000000000000000000000000000000;;		case *sshFxInitPacket:
0000000000000000000000000000000000000000;;			return s.sendPacket(sshFxVersionPacket{sftpProtocolVersion, nil})
0000000000000000000000000000000000000000;;		case *sshFxpStatPacket:
0000000000000000000000000000000000000000;;			// stat the requested file
0000000000000000000000000000000000000000;;			info, err := os.Stat(p.Path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return s.sendError(p, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.sendPacket(sshFxpStatResponse{
0000000000000000000000000000000000000000;;				ID:   p.ID,
0000000000000000000000000000000000000000;;				info: info,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case *sshFxpLstatPacket:
0000000000000000000000000000000000000000;;			// stat the requested file
0000000000000000000000000000000000000000;;			info, err := os.Lstat(p.Path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return s.sendError(p, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.sendPacket(sshFxpStatResponse{
0000000000000000000000000000000000000000;;				ID:   p.ID,
0000000000000000000000000000000000000000;;				info: info,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case *sshFxpFstatPacket:
0000000000000000000000000000000000000000;;			f, ok := s.getHandle(p.Handle)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return s.sendError(p, syscall.EBADF)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			info, err := f.Stat()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return s.sendError(p, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return s.sendPacket(sshFxpStatResponse{
0000000000000000000000000000000000000000;;				ID:   p.ID,
0000000000000000000000000000000000000000;;				info: info,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case *sshFxpMkdirPacket:
0000000000000000000000000000000000000000;;			// TODO FIXME: ignore flags field
0000000000000000000000000000000000000000;;			err := os.Mkdir(p.Path, 0755)
0000000000000000000000000000000000000000;;			return s.sendError(p, err)
0000000000000000000000000000000000000000;;		case *sshFxpRmdirPacket:
0000000000000000000000000000000000000000;;			err := os.Remove(p.Path)
0000000000000000000000000000000000000000;;			return s.sendError(p, err)
0000000000000000000000000000000000000000;;		case *sshFxpRemovePacket:
0000000000000000000000000000000000000000;;			err := os.Remove(p.Filename)
0000000000000000000000000000000000000000;;			return s.sendError(p, err)
0000000000000000000000000000000000000000;;		case *sshFxpRenamePacket:
0000000000000000000000000000000000000000;;			err := os.Rename(p.Oldpath, p.Newpath)
0000000000000000000000000000000000000000;;			return s.sendError(p, err)
0000000000000000000000000000000000000000;;		case *sshFxpSymlinkPacket:
0000000000000000000000000000000000000000;;			err := os.Symlink(p.Targetpath, p.Linkpath)
0000000000000000000000000000000000000000;;			return s.sendError(p, err)
0000000000000000000000000000000000000000;;		case *sshFxpClosePacket:
0000000000000000000000000000000000000000;;			return s.sendError(p, s.closeHandle(p.Handle))
0000000000000000000000000000000000000000;;		case *sshFxpReadlinkPacket:
0000000000000000000000000000000000000000;;			f, err := os.Readlink(p.Path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return s.sendError(p, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return s.sendPacket(sshFxpNamePacket{
0000000000000000000000000000000000000000;;				ID: p.ID,
0000000000000000000000000000000000000000;;				NameAttrs: []sshFxpNameAttr{{
0000000000000000000000000000000000000000;;					Name:     f,
0000000000000000000000000000000000000000;;					LongName: f,
0000000000000000000000000000000000000000;;					Attrs:    emptyFileStat,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case *sshFxpRealpathPacket:
0000000000000000000000000000000000000000;;			f, err := filepath.Abs(p.Path)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return s.sendError(p, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f = filepath.Clean(f)
0000000000000000000000000000000000000000;;			return s.sendPacket(sshFxpNamePacket{
0000000000000000000000000000000000000000;;				ID: p.ID,
0000000000000000000000000000000000000000;;				NameAttrs: []sshFxpNameAttr{{
0000000000000000000000000000000000000000;;					Name:     f,
0000000000000000000000000000000000000000;;					LongName: f,
0000000000000000000000000000000000000000;;					Attrs:    emptyFileStat,
0000000000000000000000000000000000000000;;				}},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case *sshFxpOpendirPacket:
0000000000000000000000000000000000000000;;			return sshFxpOpenPacket{
0000000000000000000000000000000000000000;;				ID:     p.ID,
0000000000000000000000000000000000000000;;				Path:   p.Path,
0000000000000000000000000000000000000000;;				Pflags: ssh_FXF_READ,
0000000000000000000000000000000000000000;;			}.respond(s)
0000000000000000000000000000000000000000;;		case *sshFxpReadPacket:
0000000000000000000000000000000000000000;;			f, ok := s.getHandle(p.Handle)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return s.sendError(p, syscall.EBADF)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			data := make([]byte, clamp(p.Len, s.maxTxPacket))
0000000000000000000000000000000000000000;;			n, err := f.ReadAt(data, int64(p.Offset))
0000000000000000000000000000000000000000;;			if err != nil && (err != io.EOF || n == 0) {
0000000000000000000000000000000000000000;;				return s.sendError(p, err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.sendPacket(sshFxpDataPacket{
0000000000000000000000000000000000000000;;				ID:     p.ID,
0000000000000000000000000000000000000000;;				Length: uint32(n),
0000000000000000000000000000000000000000;;				Data:   data[:n],
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		case *sshFxpWritePacket:
0000000000000000000000000000000000000000;;			f, ok := s.getHandle(p.Handle)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return s.sendError(p, syscall.EBADF)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			_, err := f.WriteAt(p.Data, int64(p.Offset))
0000000000000000000000000000000000000000;;			return s.sendError(p, err)
0000000000000000000000000000000000000000;;		case serverRespondablePacket:
0000000000000000000000000000000000000000;;			err := p.respond(s)
0000000000000000000000000000000000000000;;			return errors.Wrap(err, "pkt.respond failed")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return errors.Errorf("unexpected packet type %T", p)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Serve serves SFTP connections until the streams stop or the SFTP subsystem
0000000000000000000000000000000000000000;;	// is stopped.
0000000000000000000000000000000000000000;;	func (svr *Server) Serve() error {
0000000000000000000000000000000000000000;;		var wg sync.WaitGroup
0000000000000000000000000000000000000000;;		wg.Add(sftpServerWorkerCount)
0000000000000000000000000000000000000000;;		for i := 0; i < sftpServerWorkerCount; i++ {
0000000000000000000000000000000000000000;;			go func() {
0000000000000000000000000000000000000000;;				defer wg.Done()
0000000000000000000000000000000000000000;;				if err := svr.sftpServerWorker(); err != nil {
0000000000000000000000000000000000000000;;					svr.conn.Close() // shuts down recvPacket
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		var pktType uint8
0000000000000000000000000000000000000000;;		var pktBytes []byte
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			pktType, pktBytes, err = svr.recvPacket()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			svr.pktChan <- rxPacket{fxp(pktType), pktBytes}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		close(svr.pktChan) // shuts down sftpServerWorkers
0000000000000000000000000000000000000000;;		wg.Wait()          // wait for all workers to exit
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// close any still-open files
0000000000000000000000000000000000000000;;		for handle, file := range svr.openFiles {
0000000000000000000000000000000000000000;;			fmt.Fprintf(svr.debugStream, "sftp server file with handle %q left open: %v\n", handle, file.Name())
0000000000000000000000000000000000000000;;			file.Close()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err // error from recvPacket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type id interface {
0000000000000000000000000000000000000000;;		id() uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The init packet has no ID, so we just return a zero-value ID
0000000000000000000000000000000000000000;;	func (p sshFxInitPacket) id() uint32 { return 0 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type sshFxpStatResponse struct {
0000000000000000000000000000000000000000;;		ID   uint32
0000000000000000000000000000000000000000;;		info os.FileInfo
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sshFxpStatResponse) MarshalBinary() ([]byte, error) {
0000000000000000000000000000000000000000;;		b := []byte{ssh_FXP_ATTRS}
0000000000000000000000000000000000000000;;		b = marshalUint32(b, p.ID)
0000000000000000000000000000000000000000;;		b = marshalFileInfo(b, p.info)
0000000000000000000000000000000000000000;;		return b, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var emptyFileStat = []interface{}{uint32(0)}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sshFxpOpenPacket) readonly() bool {
0000000000000000000000000000000000000000;;		return !p.hasPflags(ssh_FXF_WRITE)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sshFxpOpenPacket) hasPflags(flags ...uint32) bool {
0000000000000000000000000000000000000000;;		for _, f := range flags {
0000000000000000000000000000000000000000;;			if p.Pflags&f == 0 {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sshFxpOpenPacket) respond(svr *Server) error {
0000000000000000000000000000000000000000;;		var osFlags int
0000000000000000000000000000000000000000;;		if p.hasPflags(ssh_FXF_READ, ssh_FXF_WRITE) {
0000000000000000000000000000000000000000;;			osFlags |= os.O_RDWR
0000000000000000000000000000000000000000;;		} else if p.hasPflags(ssh_FXF_WRITE) {
0000000000000000000000000000000000000000;;			osFlags |= os.O_WRONLY
0000000000000000000000000000000000000000;;		} else if p.hasPflags(ssh_FXF_READ) {
0000000000000000000000000000000000000000;;			osFlags |= os.O_RDONLY
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// how are they opening?
0000000000000000000000000000000000000000;;			return svr.sendError(p, syscall.EINVAL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.hasPflags(ssh_FXF_APPEND) {
0000000000000000000000000000000000000000;;			osFlags |= os.O_APPEND
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.hasPflags(ssh_FXF_CREAT) {
0000000000000000000000000000000000000000;;			osFlags |= os.O_CREATE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.hasPflags(ssh_FXF_TRUNC) {
0000000000000000000000000000000000000000;;			osFlags |= os.O_TRUNC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if p.hasPflags(ssh_FXF_EXCL) {
0000000000000000000000000000000000000000;;			osFlags |= os.O_EXCL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		f, err := os.OpenFile(p.Path, osFlags, 0644)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return svr.sendError(p, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		handle := svr.nextHandle(f)
0000000000000000000000000000000000000000;;		return svr.sendPacket(sshFxpHandlePacket{p.ID, handle})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sshFxpReaddirPacket) respond(svr *Server) error {
0000000000000000000000000000000000000000;;		f, ok := svr.getHandle(p.Handle)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return svr.sendError(p, syscall.EBADF)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dirname := f.Name()
0000000000000000000000000000000000000000;;		dirents, err := f.Readdir(128)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return svr.sendError(p, err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := sshFxpNamePacket{ID: p.ID}
0000000000000000000000000000000000000000;;		for _, dirent := range dirents {
0000000000000000000000000000000000000000;;			ret.NameAttrs = append(ret.NameAttrs, sshFxpNameAttr{
0000000000000000000000000000000000000000;;				Name:     dirent.Name(),
0000000000000000000000000000000000000000;;				LongName: runLs(dirname, dirent),
0000000000000000000000000000000000000000;;				Attrs:    []interface{}{dirent},
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return svr.sendPacket(ret)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sshFxpSetstatPacket) respond(svr *Server) error {
0000000000000000000000000000000000000000;;		// additional unmarshalling is required for each possibility here
0000000000000000000000000000000000000000;;		b := p.Attrs.([]byte)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debug("setstat name \"%s\"", p.Path)
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_SIZE) != 0 {
0000000000000000000000000000000000000000;;			var size uint64
0000000000000000000000000000000000000000;;			if size, b, err = unmarshalUint64Safe(b); err == nil {
0000000000000000000000000000000000000000;;				err = os.Truncate(p.Path, int64(size))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_PERMISSIONS) != 0 {
0000000000000000000000000000000000000000;;			var mode uint32
0000000000000000000000000000000000000000;;			if mode, b, err = unmarshalUint32Safe(b); err == nil {
0000000000000000000000000000000000000000;;				err = os.Chmod(p.Path, os.FileMode(mode))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_ACMODTIME) != 0 {
0000000000000000000000000000000000000000;;			var atime uint32
0000000000000000000000000000000000000000;;			var mtime uint32
0000000000000000000000000000000000000000;;			if atime, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else if mtime, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				atimeT := time.Unix(int64(atime), 0)
0000000000000000000000000000000000000000;;				mtimeT := time.Unix(int64(mtime), 0)
0000000000000000000000000000000000000000;;				err = os.Chtimes(p.Path, atimeT, mtimeT)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_UIDGID) != 0 {
0000000000000000000000000000000000000000;;			var uid uint32
0000000000000000000000000000000000000000;;			var gid uint32
0000000000000000000000000000000000000000;;			if uid, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else if gid, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = os.Chown(p.Path, int(uid), int(gid))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return svr.sendError(p, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p sshFxpFsetstatPacket) respond(svr *Server) error {
0000000000000000000000000000000000000000;;		f, ok := svr.getHandle(p.Handle)
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			return svr.sendError(p, syscall.EBADF)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// additional unmarshalling is required for each possibility here
0000000000000000000000000000000000000000;;		b := p.Attrs.([]byte)
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		debug("fsetstat name \"%s\"", f.Name())
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_SIZE) != 0 {
0000000000000000000000000000000000000000;;			var size uint64
0000000000000000000000000000000000000000;;			if size, b, err = unmarshalUint64Safe(b); err == nil {
0000000000000000000000000000000000000000;;				err = f.Truncate(int64(size))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_PERMISSIONS) != 0 {
0000000000000000000000000000000000000000;;			var mode uint32
0000000000000000000000000000000000000000;;			if mode, b, err = unmarshalUint32Safe(b); err == nil {
0000000000000000000000000000000000000000;;				err = f.Chmod(os.FileMode(mode))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_ACMODTIME) != 0 {
0000000000000000000000000000000000000000;;			var atime uint32
0000000000000000000000000000000000000000;;			var mtime uint32
0000000000000000000000000000000000000000;;			if atime, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else if mtime, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				atimeT := time.Unix(int64(atime), 0)
0000000000000000000000000000000000000000;;				mtimeT := time.Unix(int64(mtime), 0)
0000000000000000000000000000000000000000;;				err = os.Chtimes(f.Name(), atimeT, mtimeT)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if (p.Flags & ssh_FILEXFER_ATTR_UIDGID) != 0 {
0000000000000000000000000000000000000000;;			var uid uint32
0000000000000000000000000000000000000000;;			var gid uint32
0000000000000000000000000000000000000000;;			if uid, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else if gid, b, err = unmarshalUint32Safe(b); err != nil {
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				err = f.Chown(int(uid), int(gid))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return svr.sendError(p, err)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// translateErrno translates a syscall error number to a SFTP error code.
0000000000000000000000000000000000000000;;	func translateErrno(errno syscall.Errno) uint32 {
0000000000000000000000000000000000000000;;		switch errno {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return ssh_FX_OK
0000000000000000000000000000000000000000;;		case syscall.ENOENT:
0000000000000000000000000000000000000000;;			return ssh_FX_NO_SUCH_FILE
0000000000000000000000000000000000000000;;		case syscall.EPERM:
0000000000000000000000000000000000000000;;			return ssh_FX_PERMISSION_DENIED
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ssh_FX_FAILURE
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func statusFromError(p id, err error) sshFxpStatusPacket {
0000000000000000000000000000000000000000;;		ret := sshFxpStatusPacket{
0000000000000000000000000000000000000000;;			ID: p.id(),
0000000000000000000000000000000000000000;;			StatusError: StatusError{
0000000000000000000000000000000000000000;;				// ssh_FX_OK                = 0
0000000000000000000000000000000000000000;;				// ssh_FX_EOF               = 1
0000000000000000000000000000000000000000;;				// ssh_FX_NO_SUCH_FILE      = 2 ENOENT
0000000000000000000000000000000000000000;;				// ssh_FX_PERMISSION_DENIED = 3
0000000000000000000000000000000000000000;;				// ssh_FX_FAILURE           = 4
0000000000000000000000000000000000000000;;				// ssh_FX_BAD_MESSAGE       = 5
0000000000000000000000000000000000000000;;				// ssh_FX_NO_CONNECTION     = 6
0000000000000000000000000000000000000000;;				// ssh_FX_CONNECTION_LOST   = 7
0000000000000000000000000000000000000000;;				// ssh_FX_OP_UNSUPPORTED    = 8
0000000000000000000000000000000000000000;;				Code: ssh_FX_OK,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			debug("statusFromError: error is %T %#v", err, err)
0000000000000000000000000000000000000000;;			ret.StatusError.Code = ssh_FX_FAILURE
0000000000000000000000000000000000000000;;			ret.StatusError.msg = err.Error()
0000000000000000000000000000000000000000;;			if err == io.EOF {
0000000000000000000000000000000000000000;;				ret.StatusError.Code = ssh_FX_EOF
0000000000000000000000000000000000000000;;			} else if errno, ok := err.(syscall.Errno); ok {
0000000000000000000000000000000000000000;;				ret.StatusError.Code = translateErrno(errno)
0000000000000000000000000000000000000000;;			} else if pathError, ok := err.(*os.PathError); ok {
0000000000000000000000000000000000000000;;				debug("statusFromError: error is %T %#v", pathError.Err, pathError.Err)
0000000000000000000000000000000000000000;;				if errno, ok := pathError.Err.(syscall.Errno); ok {
0000000000000000000000000000000000000000;;					ret.StatusError.Code = translateErrno(errno)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clamp(v, max uint32) uint32 {
0000000000000000000000000000000000000000;;		if v > max {
0000000000000000000000000000000000000000;;			return max
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v
0000000000000000000000000000000000000000;;	}
