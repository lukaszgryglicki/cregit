0000000000000000000000000000000000000000;;	package sftp
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/pkg/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// conn implements a bidirectional channel on which client and server
0000000000000000000000000000000000000000;;	// connections are multiplexed.
0000000000000000000000000000000000000000;;	type conn struct {
0000000000000000000000000000000000000000;;		io.Reader
0000000000000000000000000000000000000000;;		io.WriteCloser
0000000000000000000000000000000000000000;;		sync.Mutex // used to serialise writes to sendPacket
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) recvPacket() (uint8, []byte, error) {
0000000000000000000000000000000000000000;;		return recvPacket(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *conn) sendPacket(m encoding.BinaryMarshaler) error {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		defer c.Unlock()
0000000000000000000000000000000000000000;;		return sendPacket(c, m)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type clientConn struct {
0000000000000000000000000000000000000000;;		conn
0000000000000000000000000000000000000000;;		wg         sync.WaitGroup
0000000000000000000000000000000000000000;;		sync.Mutex                          // protects inflight
0000000000000000000000000000000000000000;;		inflight   map[uint32]chan<- result // outstanding requests
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the SFTP session.
0000000000000000000000000000000000000000;;	func (c *clientConn) Close() error {
0000000000000000000000000000000000000000;;		defer c.wg.Wait()
0000000000000000000000000000000000000000;;		return c.conn.Close()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *clientConn) loop() {
0000000000000000000000000000000000000000;;		defer c.wg.Done()
0000000000000000000000000000000000000000;;		err := c.recv()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			c.broadcastErr(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// recv continuously reads from the server and forwards responses to the
0000000000000000000000000000000000000000;;	// appropriate channel.
0000000000000000000000000000000000000000;;	func (c *clientConn) recv() error {
0000000000000000000000000000000000000000;;		defer c.conn.Close()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			typ, data, err := c.recvPacket()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sid, _ := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			c.Lock()
0000000000000000000000000000000000000000;;			ch, ok := c.inflight[sid]
0000000000000000000000000000000000000000;;			delete(c.inflight, sid)
0000000000000000000000000000000000000000;;			c.Unlock()
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				// This is an unexpected occurrence. Send the error
0000000000000000000000000000000000000000;;				// back to all listeners so that they terminate
0000000000000000000000000000000000000000;;				// gracefully.
0000000000000000000000000000000000000000;;				return errors.Errorf("sid: %v not fond", sid)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			ch <- result{typ: typ, data: data}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// result captures the result of receiving the a packet from the server
0000000000000000000000000000000000000000;;	type result struct {
0000000000000000000000000000000000000000;;		typ  byte
0000000000000000000000000000000000000000;;		data []byte
0000000000000000000000000000000000000000;;		err  error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type idmarshaler interface {
0000000000000000000000000000000000000000;;		id() uint32
0000000000000000000000000000000000000000;;		encoding.BinaryMarshaler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *clientConn) sendPacket(p idmarshaler) (byte, []byte, error) {
0000000000000000000000000000000000000000;;		ch := make(chan result, 1)
0000000000000000000000000000000000000000;;		c.dispatchRequest(ch, p)
0000000000000000000000000000000000000000;;		s := <-ch
0000000000000000000000000000000000000000;;		return s.typ, s.data, s.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *clientConn) dispatchRequest(ch chan<- result, p idmarshaler) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		c.inflight[p.id()] = ch
0000000000000000000000000000000000000000;;		if err := c.conn.sendPacket(p); err != nil {
0000000000000000000000000000000000000000;;			delete(c.inflight, p.id())
0000000000000000000000000000000000000000;;			ch <- result{err: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// broadcastErr sends an error to all goroutines waiting for a response.
0000000000000000000000000000000000000000;;	func (c *clientConn) broadcastErr(err error) {
0000000000000000000000000000000000000000;;		c.Lock()
0000000000000000000000000000000000000000;;		listeners := make([]chan<- result, 0, len(c.inflight))
0000000000000000000000000000000000000000;;		for _, ch := range c.inflight {
0000000000000000000000000000000000000000;;			listeners = append(listeners, ch)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c.Unlock()
0000000000000000000000000000000000000000;;		for _, ch := range listeners {
0000000000000000000000000000000000000000;;			ch <- result{err: err}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverConn struct {
0000000000000000000000000000000000000000;;		conn
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *serverConn) sendError(p id, err error) error {
0000000000000000000000000000000000000000;;		return s.sendPacket(statusFromError(p, err))
0000000000000000000000000000000000000000;;	}
