0000000000000000000000000000000000000000;;	package sftp
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"sync/atomic"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/kr/fs"
0000000000000000000000000000000000000000;;		"github.com/pkg/errors"
0000000000000000000000000000000000000000;;		"golang.org/x/crypto/ssh"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxPacket sets the maximum size of the payload.
0000000000000000000000000000000000000000;;	func MaxPacket(size int) func(*Client) error {
0000000000000000000000000000000000000000;;		return func(c *Client) error {
0000000000000000000000000000000000000000;;			if size < 1<<15 {
0000000000000000000000000000000000000000;;				return errors.Errorf("size must be greater or equal to 32k")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			c.maxPacket = size
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient creates a new SFTP client on conn, using zero or more option
0000000000000000000000000000000000000000;;	// functions.
0000000000000000000000000000000000000000;;	func NewClient(conn *ssh.Client, opts ...func(*Client) error) (*Client, error) {
0000000000000000000000000000000000000000;;		s, err := conn.NewSession()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := s.RequestSubsystem("sftp"); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pw, err := s.StdinPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pr, err := s.StdoutPipe()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return NewClientPipe(pr, pw, opts...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClientPipe creates a new SFTP client given a Reader and a WriteCloser.
0000000000000000000000000000000000000000;;	// This can be used for connecting to an SFTP server over TCP/TLS or by using
0000000000000000000000000000000000000000;;	// the system's ssh client program (e.g. via exec.Command).
0000000000000000000000000000000000000000;;	func NewClientPipe(rd io.Reader, wr io.WriteCloser, opts ...func(*Client) error) (*Client, error) {
0000000000000000000000000000000000000000;;		sftp := &Client{
0000000000000000000000000000000000000000;;			clientConn: clientConn{
0000000000000000000000000000000000000000;;				conn: conn{
0000000000000000000000000000000000000000;;					Reader:      rd,
0000000000000000000000000000000000000000;;					WriteCloser: wr,
0000000000000000000000000000000000000000;;				},
0000000000000000000000000000000000000000;;				inflight: make(map[uint32]chan<- result),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			maxPacket: 1 << 15,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := sftp.applyOptions(opts...); err != nil {
0000000000000000000000000000000000000000;;			wr.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := sftp.sendInit(); err != nil {
0000000000000000000000000000000000000000;;			wr.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := sftp.recvVersion(); err != nil {
0000000000000000000000000000000000000000;;			wr.Close()
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sftp.clientConn.wg.Add(1)
0000000000000000000000000000000000000000;;		go sftp.loop()
0000000000000000000000000000000000000000;;		return sftp, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client represents an SFTP session on a *ssh.ClientConn SSH connection.
0000000000000000000000000000000000000000;;	// Multiple Clients can be active on a single SSH connection, and a Client
0000000000000000000000000000000000000000;;	// may be called concurrently from multiple Goroutines.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Client implements the github.com/kr/fs.FileSystem interface.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		clientConn
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maxPacket int // max packet size read or written.
0000000000000000000000000000000000000000;;		nextid    uint32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create creates the named file mode 0666 (before umask), truncating it if
0000000000000000000000000000000000000000;;	// it already exists. If successful, methods on the returned File can be
0000000000000000000000000000000000000000;;	// used for I/O; the associated file descriptor has mode O_RDWR.
0000000000000000000000000000000000000000;;	func (c *Client) Create(path string) (*File, error) {
0000000000000000000000000000000000000000;;		return c.open(path, flags(os.O_RDWR|os.O_CREATE|os.O_TRUNC))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const sftpProtocolVersion = 3 // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) sendInit() error {
0000000000000000000000000000000000000000;;		return c.clientConn.conn.sendPacket(sshFxInitPacket{
0000000000000000000000000000000000000000;;			Version: sftpProtocolVersion, // http://tools.ietf.org/html/draft-ietf-secsh-filexfer-02
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns the next value of c.nextid
0000000000000000000000000000000000000000;;	func (c *Client) nextID() uint32 {
0000000000000000000000000000000000000000;;		return atomic.AddUint32(&c.nextid, 1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) recvVersion() error {
0000000000000000000000000000000000000000;;		typ, data, err := c.recvPacket()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if typ != ssh_FXP_VERSION {
0000000000000000000000000000000000000000;;			return &unexpectedPacketErr{ssh_FXP_VERSION, typ}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		version, _ := unmarshalUint32(data)
0000000000000000000000000000000000000000;;		if version != sftpProtocolVersion {
0000000000000000000000000000000000000000;;			return &unexpectedVersionErr{sftpProtocolVersion, version}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Walk returns a new Walker rooted at root.
0000000000000000000000000000000000000000;;	func (c *Client) Walk(root string) *fs.Walker {
0000000000000000000000000000000000000000;;		return fs.WalkFS(root, c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadDir reads the directory named by dirname and returns a list of
0000000000000000000000000000000000000000;;	// directory entries.
0000000000000000000000000000000000000000;;	func (c *Client) ReadDir(p string) ([]os.FileInfo, error) {
0000000000000000000000000000000000000000;;		handle, err := c.opendir(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer c.close(handle) // this has to defer earlier than the lock below
0000000000000000000000000000000000000000;;		var attrs []os.FileInfo
0000000000000000000000000000000000000000;;		var done = false
0000000000000000000000000000000000000000;;		for !done {
0000000000000000000000000000000000000000;;			id := c.nextID()
0000000000000000000000000000000000000000;;			typ, data, err1 := c.sendPacket(sshFxpReaddirPacket{
0000000000000000000000000000000000000000;;				ID:     id,
0000000000000000000000000000000000000000;;				Handle: handle,
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			if err1 != nil {
0000000000000000000000000000000000000000;;				err = err1
0000000000000000000000000000000000000000;;				done = true
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch typ {
0000000000000000000000000000000000000000;;			case ssh_FXP_NAME:
0000000000000000000000000000000000000000;;				sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;				if sid != id {
0000000000000000000000000000000000000000;;					return nil, &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				count, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;				for i := uint32(0); i < count; i++ {
0000000000000000000000000000000000000000;;					var filename string
0000000000000000000000000000000000000000;;					filename, data = unmarshalString(data)
0000000000000000000000000000000000000000;;					_, data = unmarshalString(data) // discard longname
0000000000000000000000000000000000000000;;					var attr *FileStat
0000000000000000000000000000000000000000;;					attr, data = unmarshalAttrs(data)
0000000000000000000000000000000000000000;;					if filename == "." || filename == ".." {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					attrs = append(attrs, fileInfoFromStat(attr, path.Base(filename)))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;				// TODO(dfc) scope warning!
0000000000000000000000000000000000000000;;				err = normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;				done = true
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return nil, unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err == io.EOF {
0000000000000000000000000000000000000000;;			err = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return attrs, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) opendir(path string) (string, error) {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpOpendirPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: path,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_HANDLE:
0000000000000000000000000000000000000000;;			sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if sid != id {
0000000000000000000000000000000000000000;;				return "", &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handle, _ := unmarshalString(data)
0000000000000000000000000000000000000000;;			return handle, nil
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return "", unmarshalStatus(id, data)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stat returns a FileInfo structure describing the file specified by path 'p'.
0000000000000000000000000000000000000000;;	// If 'p' is a symbolic link, the returned FileInfo structure describes the referent file.
0000000000000000000000000000000000000000;;	func (c *Client) Stat(p string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpStatPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: p,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_ATTRS:
0000000000000000000000000000000000000000;;			sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if sid != id {
0000000000000000000000000000000000000000;;				return nil, &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attr, _ := unmarshalAttrs(data)
0000000000000000000000000000000000000000;;			return fileInfoFromStat(attr, path.Base(p)), nil
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return nil, normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Lstat returns a FileInfo structure describing the file specified by path 'p'.
0000000000000000000000000000000000000000;;	// If 'p' is a symbolic link, the returned FileInfo structure describes the symbolic link.
0000000000000000000000000000000000000000;;	func (c *Client) Lstat(p string) (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpLstatPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: p,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_ATTRS:
0000000000000000000000000000000000000000;;			sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if sid != id {
0000000000000000000000000000000000000000;;				return nil, &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attr, _ := unmarshalAttrs(data)
0000000000000000000000000000000000000000;;			return fileInfoFromStat(attr, path.Base(p)), nil
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return nil, normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadLink reads the target of a symbolic link.
0000000000000000000000000000000000000000;;	func (c *Client) ReadLink(p string) (string, error) {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpReadlinkPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: p,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_NAME:
0000000000000000000000000000000000000000;;			sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if sid != id {
0000000000000000000000000000000000000000;;				return "", &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if count != 1 {
0000000000000000000000000000000000000000;;				return "", unexpectedCount(1, count)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filename, _ := unmarshalString(data) // ignore dummy attributes
0000000000000000000000000000000000000000;;			return filename, nil
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return "", unmarshalStatus(id, data)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Symlink creates a symbolic link at 'newname', pointing at target 'oldname'
0000000000000000000000000000000000000000;;	func (c *Client) Symlink(oldname, newname string) error {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpSymlinkPacket{
0000000000000000000000000000000000000000;;			ID:         id,
0000000000000000000000000000000000000000;;			Linkpath:   newname,
0000000000000000000000000000000000000000;;			Targetpath: oldname,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// setstat is a convience wrapper to allow for changing of various parts of the file descriptor.
0000000000000000000000000000000000000000;;	func (c *Client) setstat(path string, flags uint32, attrs interface{}) error {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpSetstatPacket{
0000000000000000000000000000000000000000;;			ID:    id,
0000000000000000000000000000000000000000;;			Path:  path,
0000000000000000000000000000000000000000;;			Flags: flags,
0000000000000000000000000000000000000000;;			Attrs: attrs,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chtimes changes the access and modification times of the named file.
0000000000000000000000000000000000000000;;	func (c *Client) Chtimes(path string, atime time.Time, mtime time.Time) error {
0000000000000000000000000000000000000000;;		type times struct {
0000000000000000000000000000000000000000;;			Atime uint32
0000000000000000000000000000000000000000;;			Mtime uint32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := times{uint32(atime.Unix()), uint32(mtime.Unix())}
0000000000000000000000000000000000000000;;		return c.setstat(path, ssh_FILEXFER_ATTR_ACMODTIME, attrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chown changes the user and group owners of the named file.
0000000000000000000000000000000000000000;;	func (c *Client) Chown(path string, uid, gid int) error {
0000000000000000000000000000000000000000;;		type owner struct {
0000000000000000000000000000000000000000;;			UID uint32
0000000000000000000000000000000000000000;;			GID uint32
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrs := owner{uint32(uid), uint32(gid)}
0000000000000000000000000000000000000000;;		return c.setstat(path, ssh_FILEXFER_ATTR_UIDGID, attrs)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chmod changes the permissions of the named file.
0000000000000000000000000000000000000000;;	func (c *Client) Chmod(path string, mode os.FileMode) error {
0000000000000000000000000000000000000000;;		return c.setstat(path, ssh_FILEXFER_ATTR_PERMISSIONS, uint32(mode))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Truncate sets the size of the named file. Although it may be safely assumed
0000000000000000000000000000000000000000;;	// that if the size is less than its current size it will be truncated to fit,
0000000000000000000000000000000000000000;;	// the SFTP protocol does not specify what behavior the server should do when setting
0000000000000000000000000000000000000000;;	// size greater than the current size.
0000000000000000000000000000000000000000;;	func (c *Client) Truncate(path string, size int64) error {
0000000000000000000000000000000000000000;;		return c.setstat(path, ssh_FILEXFER_ATTR_SIZE, uint64(size))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Open opens the named file for reading. If successful, methods on the
0000000000000000000000000000000000000000;;	// returned file can be used for reading; the associated file descriptor
0000000000000000000000000000000000000000;;	// has mode O_RDONLY.
0000000000000000000000000000000000000000;;	func (c *Client) Open(path string) (*File, error) {
0000000000000000000000000000000000000000;;		return c.open(path, flags(os.O_RDONLY))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OpenFile is the generalized open call; most users will use Open or
0000000000000000000000000000000000000000;;	// Create instead. It opens the named file with specified flag (O_RDONLY
0000000000000000000000000000000000000000;;	// etc.). If successful, methods on the returned File can be used for I/O.
0000000000000000000000000000000000000000;;	func (c *Client) OpenFile(path string, f int) (*File, error) {
0000000000000000000000000000000000000000;;		return c.open(path, flags(f))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) open(path string, pflags uint32) (*File, error) {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpOpenPacket{
0000000000000000000000000000000000000000;;			ID:     id,
0000000000000000000000000000000000000000;;			Path:   path,
0000000000000000000000000000000000000000;;			Pflags: pflags,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_HANDLE:
0000000000000000000000000000000000000000;;			sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if sid != id {
0000000000000000000000000000000000000000;;				return nil, &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			handle, _ := unmarshalString(data)
0000000000000000000000000000000000000000;;			return &File{c: c, path: path, handle: handle}, nil
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return nil, normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// close closes a handle handle previously returned in the response
0000000000000000000000000000000000000000;;	// to SSH_FXP_OPEN or SSH_FXP_OPENDIR. The handle becomes invalid
0000000000000000000000000000000000000000;;	// immediately after this request has been sent.
0000000000000000000000000000000000000000;;	func (c *Client) close(handle string) error {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpClosePacket{
0000000000000000000000000000000000000000;;			ID:     id,
0000000000000000000000000000000000000000;;			Handle: handle,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) fstat(handle string) (*FileStat, error) {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpFstatPacket{
0000000000000000000000000000000000000000;;			ID:     id,
0000000000000000000000000000000000000000;;			Handle: handle,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_ATTRS:
0000000000000000000000000000000000000000;;			sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if sid != id {
0000000000000000000000000000000000000000;;				return nil, &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attr, _ := unmarshalAttrs(data)
0000000000000000000000000000000000000000;;			return attr, nil
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return nil, unmarshalStatus(id, data)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StatVFS retrieves VFS statistics from a remote host.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It implements the statvfs@openssh.com SSH_FXP_EXTENDED feature
0000000000000000000000000000000000000000;;	// from http://www.opensource.apple.com/source/OpenSSH/OpenSSH-175/openssh/PROTOCOL?txt.
0000000000000000000000000000000000000000;;	func (c *Client) StatVFS(path string) (*StatVFS, error) {
0000000000000000000000000000000000000000;;		// send the StatVFS packet to the server
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpStatvfsPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: path,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		// server responded with valid data
0000000000000000000000000000000000000000;;		case ssh_FXP_EXTENDED_REPLY:
0000000000000000000000000000000000000000;;			var response StatVFS
0000000000000000000000000000000000000000;;			err = binary.Read(bytes.NewReader(data), binary.BigEndian, &response)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, errors.New("can not parse reply")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return &response, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the resquest failed
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return nil, errors.New(fxp(ssh_FXP_STATUS).String())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Join joins any number of path elements into a single path, adding a
0000000000000000000000000000000000000000;;	// separating slash if necessary. The result is Cleaned; in particular, all
0000000000000000000000000000000000000000;;	// empty strings are ignored.
0000000000000000000000000000000000000000;;	func (c *Client) Join(elem ...string) string { return path.Join(elem...) }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Remove removes the specified file or directory. An error will be returned if no
0000000000000000000000000000000000000000;;	// file or directory with the specified path exists, or if the specified directory
0000000000000000000000000000000000000000;;	// is not empty.
0000000000000000000000000000000000000000;;	func (c *Client) Remove(path string) error {
0000000000000000000000000000000000000000;;		err := c.removeFile(path)
0000000000000000000000000000000000000000;;		if err, ok := err.(*StatusError); ok {
0000000000000000000000000000000000000000;;			switch err.Code {
0000000000000000000000000000000000000000;;			// some servers, *cough* osx *cough*, return EPERM, not ENODIR.
0000000000000000000000000000000000000000;;			// serv-u returns ssh_FX_FILE_IS_A_DIRECTORY
0000000000000000000000000000000000000000;;			case ssh_FX_PERMISSION_DENIED, ssh_FX_FAILURE, ssh_FX_FILE_IS_A_DIRECTORY:
0000000000000000000000000000000000000000;;				return c.removeDirectory(path)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) removeFile(path string) error {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpRemovePacket{
0000000000000000000000000000000000000000;;			ID:       id,
0000000000000000000000000000000000000000;;			Filename: path,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) removeDirectory(path string) error {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpRmdirPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: path,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rename renames a file.
0000000000000000000000000000000000000000;;	func (c *Client) Rename(oldname, newname string) error {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpRenamePacket{
0000000000000000000000000000000000000000;;			ID:      id,
0000000000000000000000000000000000000000;;			Oldpath: oldname,
0000000000000000000000000000000000000000;;			Newpath: newname,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *Client) realpath(path string) (string, error) {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpRealpathPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: path,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_NAME:
0000000000000000000000000000000000000000;;			sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if sid != id {
0000000000000000000000000000000000000000;;				return "", &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			count, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;			if count != 1 {
0000000000000000000000000000000000000000;;				return "", unexpectedCount(1, count)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			filename, _ := unmarshalString(data) // ignore attributes
0000000000000000000000000000000000000000;;			return filename, nil
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return "", normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Getwd returns the current working directory of the server. Operations
0000000000000000000000000000000000000000;;	// involving relative paths will be based at this location.
0000000000000000000000000000000000000000;;	func (c *Client) Getwd() (string, error) {
0000000000000000000000000000000000000000;;		return c.realpath(".")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Mkdir creates the specified directory. An error will be returned if a file or
0000000000000000000000000000000000000000;;	// directory with the specified path already exists, or if the directory's
0000000000000000000000000000000000000000;;	// parent folder does not exist (the method cannot create complete paths).
0000000000000000000000000000000000000000;;	func (c *Client) Mkdir(path string) error {
0000000000000000000000000000000000000000;;		id := c.nextID()
0000000000000000000000000000000000000000;;		typ, data, err := c.sendPacket(sshFxpMkdirPacket{
0000000000000000000000000000000000000000;;			ID:   id,
0000000000000000000000000000000000000000;;			Path: path,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch typ {
0000000000000000000000000000000000000000;;		case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;			return normaliseError(unmarshalStatus(id, data))
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return unimplementedPacketErr(typ)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// applyOptions applies options functions to the Client.
0000000000000000000000000000000000000000;;	// If an error is encountered, option processing ceases.
0000000000000000000000000000000000000000;;	func (c *Client) applyOptions(opts ...func(*Client) error) error {
0000000000000000000000000000000000000000;;		for _, f := range opts {
0000000000000000000000000000000000000000;;			if err := f(c); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File represents a remote file.
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		c      *Client
0000000000000000000000000000000000000000;;		path   string
0000000000000000000000000000000000000000;;		handle string
0000000000000000000000000000000000000000;;		offset uint64 // current offset within remote file
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Close closes the File, rendering it unusable for I/O. It returns an
0000000000000000000000000000000000000000;;	// error, if any.
0000000000000000000000000000000000000000;;	func (f *File) Close() error {
0000000000000000000000000000000000000000;;		return f.c.close(f.handle)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Name returns the name of the file as presented to Open or Create.
0000000000000000000000000000000000000000;;	func (f *File) Name() string {
0000000000000000000000000000000000000000;;		return f.path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const maxConcurrentRequests = 64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Read reads up to len(b) bytes from the File. It returns the number of
0000000000000000000000000000000000000000;;	// bytes read and an error, if any. EOF is signaled by a zero count with
0000000000000000000000000000000000000000;;	// err set to io.EOF.
0000000000000000000000000000000000000000;;	func (f *File) Read(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		// Split the read into multiple maxPacket sized concurrent reads
0000000000000000000000000000000000000000;;		// bounded by maxConcurrentRequests. This allows reads with a suitably
0000000000000000000000000000000000000000;;		// large buffer to transfer data at a much faster rate due to
0000000000000000000000000000000000000000;;		// overlapping round trip times.
0000000000000000000000000000000000000000;;		inFlight := 0
0000000000000000000000000000000000000000;;		desiredInFlight := 1
0000000000000000000000000000000000000000;;		offset := f.offset
0000000000000000000000000000000000000000;;		ch := make(chan result, 1)
0000000000000000000000000000000000000000;;		type inflightRead struct {
0000000000000000000000000000000000000000;;			b      []byte
0000000000000000000000000000000000000000;;			offset uint64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reqs := map[uint32]inflightRead{}
0000000000000000000000000000000000000000;;		type offsetErr struct {
0000000000000000000000000000000000000000;;			offset uint64
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var firstErr offsetErr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sendReq := func(b []byte, offset uint64) {
0000000000000000000000000000000000000000;;			reqID := f.c.nextID()
0000000000000000000000000000000000000000;;			f.c.dispatchRequest(ch, sshFxpReadPacket{
0000000000000000000000000000000000000000;;				ID:     reqID,
0000000000000000000000000000000000000000;;				Handle: f.handle,
0000000000000000000000000000000000000000;;				Offset: offset,
0000000000000000000000000000000000000000;;				Len:    uint32(len(b)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			inFlight++
0000000000000000000000000000000000000000;;			reqs[reqID] = inflightRead{b: b, offset: offset}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var read int
0000000000000000000000000000000000000000;;		for len(b) > 0 || inFlight > 0 {
0000000000000000000000000000000000000000;;			for inFlight < desiredInFlight && len(b) > 0 && firstErr.err == nil {
0000000000000000000000000000000000000000;;				l := min(len(b), f.c.maxPacket)
0000000000000000000000000000000000000000;;				rb := b[:l]
0000000000000000000000000000000000000000;;				sendReq(rb, offset)
0000000000000000000000000000000000000000;;				offset += uint64(l)
0000000000000000000000000000000000000000;;				b = b[l:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if inFlight == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case res := <-ch:
0000000000000000000000000000000000000000;;				inFlight--
0000000000000000000000000000000000000000;;				if res.err != nil {
0000000000000000000000000000000000000000;;					firstErr = offsetErr{offset: 0, err: res.err}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				reqID, data := unmarshalUint32(res.data)
0000000000000000000000000000000000000000;;				req, ok := reqs[reqID]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					firstErr = offsetErr{offset: 0, err: errors.Errorf("sid: %v not found", reqID)}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(reqs, reqID)
0000000000000000000000000000000000000000;;				switch res.typ {
0000000000000000000000000000000000000000;;				case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;					if firstErr.err == nil || req.offset < firstErr.offset {
0000000000000000000000000000000000000000;;						firstErr = offsetErr{
0000000000000000000000000000000000000000;;							offset: req.offset,
0000000000000000000000000000000000000000;;							err:    normaliseError(unmarshalStatus(reqID, res.data)),
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case ssh_FXP_DATA:
0000000000000000000000000000000000000000;;					l, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;					n := copy(req.b, data[:l])
0000000000000000000000000000000000000000;;					read += n
0000000000000000000000000000000000000000;;					if n < len(req.b) {
0000000000000000000000000000000000000000;;						sendReq(req.b[l:], req.offset+uint64(l))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if desiredInFlight < maxConcurrentRequests {
0000000000000000000000000000000000000000;;						desiredInFlight++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					firstErr = offsetErr{offset: 0, err: unimplementedPacketErr(res.typ)}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If the error is anything other than EOF, then there
0000000000000000000000000000000000000000;;		// may be gaps in the data copied to the buffer so it's
0000000000000000000000000000000000000000;;		// best to return 0 so the caller can't make any
0000000000000000000000000000000000000000;;		// incorrect assumptions about the state of the buffer.
0000000000000000000000000000000000000000;;		if firstErr.err != nil && firstErr.err != io.EOF {
0000000000000000000000000000000000000000;;			read = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.offset += uint64(read)
0000000000000000000000000000000000000000;;		return read, firstErr.err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteTo writes the file to w. The return value is the number of bytes
0000000000000000000000000000000000000000;;	// written. Any error encountered during the write is also returned.
0000000000000000000000000000000000000000;;	func (f *File) WriteTo(w io.Writer) (int64, error) {
0000000000000000000000000000000000000000;;		fi, err := f.Stat()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return 0, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		inFlight := 0
0000000000000000000000000000000000000000;;		desiredInFlight := 1
0000000000000000000000000000000000000000;;		offset := f.offset
0000000000000000000000000000000000000000;;		writeOffset := offset
0000000000000000000000000000000000000000;;		fileSize := uint64(fi.Size())
0000000000000000000000000000000000000000;;		ch := make(chan result, 1)
0000000000000000000000000000000000000000;;		type inflightRead struct {
0000000000000000000000000000000000000000;;			b      []byte
0000000000000000000000000000000000000000;;			offset uint64
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reqs := map[uint32]inflightRead{}
0000000000000000000000000000000000000000;;		pendingWrites := map[uint64][]byte{}
0000000000000000000000000000000000000000;;		type offsetErr struct {
0000000000000000000000000000000000000000;;			offset uint64
0000000000000000000000000000000000000000;;			err    error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var firstErr offsetErr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		sendReq := func(b []byte, offset uint64) {
0000000000000000000000000000000000000000;;			reqID := f.c.nextID()
0000000000000000000000000000000000000000;;			f.c.dispatchRequest(ch, sshFxpReadPacket{
0000000000000000000000000000000000000000;;				ID:     reqID,
0000000000000000000000000000000000000000;;				Handle: f.handle,
0000000000000000000000000000000000000000;;				Offset: offset,
0000000000000000000000000000000000000000;;				Len:    uint32(len(b)),
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;			inFlight++
0000000000000000000000000000000000000000;;			reqs[reqID] = inflightRead{b: b, offset: offset}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var copied int64
0000000000000000000000000000000000000000;;		for firstErr.err == nil || inFlight > 0 {
0000000000000000000000000000000000000000;;			for inFlight < desiredInFlight && firstErr.err == nil {
0000000000000000000000000000000000000000;;				b := make([]byte, f.c.maxPacket)
0000000000000000000000000000000000000000;;				sendReq(b, offset)
0000000000000000000000000000000000000000;;				offset += uint64(f.c.maxPacket)
0000000000000000000000000000000000000000;;				if offset > fileSize {
0000000000000000000000000000000000000000;;					desiredInFlight = 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if inFlight == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case res := <-ch:
0000000000000000000000000000000000000000;;				inFlight--
0000000000000000000000000000000000000000;;				if res.err != nil {
0000000000000000000000000000000000000000;;					firstErr = offsetErr{offset: 0, err: res.err}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				reqID, data := unmarshalUint32(res.data)
0000000000000000000000000000000000000000;;				req, ok := reqs[reqID]
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					firstErr = offsetErr{offset: 0, err: errors.Errorf("sid: %v not found", reqID)}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				delete(reqs, reqID)
0000000000000000000000000000000000000000;;				switch res.typ {
0000000000000000000000000000000000000000;;				case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;					if firstErr.err == nil || req.offset < firstErr.offset {
0000000000000000000000000000000000000000;;						firstErr = offsetErr{offset: req.offset, err: normaliseError(unmarshalStatus(reqID, res.data))}
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				case ssh_FXP_DATA:
0000000000000000000000000000000000000000;;					l, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;					if req.offset == writeOffset {
0000000000000000000000000000000000000000;;						nbytes, err := w.Write(data)
0000000000000000000000000000000000000000;;						copied += int64(nbytes)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							firstErr = offsetErr{offset: req.offset + uint64(nbytes), err: err}
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if nbytes < int(l) {
0000000000000000000000000000000000000000;;							firstErr = offsetErr{offset: req.offset + uint64(nbytes), err: io.ErrShortWrite}
0000000000000000000000000000000000000000;;							break
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						switch {
0000000000000000000000000000000000000000;;						case offset > fileSize:
0000000000000000000000000000000000000000;;							desiredInFlight = 1
0000000000000000000000000000000000000000;;						case desiredInFlight < maxConcurrentRequests:
0000000000000000000000000000000000000000;;							desiredInFlight++
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						writeOffset += uint64(nbytes)
0000000000000000000000000000000000000000;;						for pendingData, ok := pendingWrites[writeOffset]; ok; pendingData, ok = pendingWrites[writeOffset] {
0000000000000000000000000000000000000000;;							nbytes, err := w.Write(pendingData)
0000000000000000000000000000000000000000;;							if err != nil {
0000000000000000000000000000000000000000;;								firstErr = offsetErr{offset: writeOffset + uint64(nbytes), err: err}
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							if nbytes < len(pendingData) {
0000000000000000000000000000000000000000;;								firstErr = offsetErr{offset: writeOffset + uint64(nbytes), err: io.ErrShortWrite}
0000000000000000000000000000000000000000;;								break
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;							writeOffset += uint64(nbytes)
0000000000000000000000000000000000000000;;							inFlight--
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// Don't write the data yet because
0000000000000000000000000000000000000000;;						// this response came in out of order
0000000000000000000000000000000000000000;;						// and we need to wait for responses
0000000000000000000000000000000000000000;;						// for earlier segments of the file.
0000000000000000000000000000000000000000;;						inFlight++ // Pending writes should still be considered inFlight.
0000000000000000000000000000000000000000;;						pendingWrites[req.offset] = data
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					firstErr = offsetErr{offset: 0, err: unimplementedPacketErr(res.typ)}
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if firstErr.err != io.EOF {
0000000000000000000000000000000000000000;;			return copied, firstErr.err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return copied, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Stat returns the FileInfo structure describing file. If there is an
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	func (f *File) Stat() (os.FileInfo, error) {
0000000000000000000000000000000000000000;;		fs, err := f.c.fstat(f.handle)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return fileInfoFromStat(fs, path.Base(f.path)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Write writes len(b) bytes to the File. It returns the number of bytes
0000000000000000000000000000000000000000;;	// written and an error, if any. Write returns a non-nil error when n !=
0000000000000000000000000000000000000000;;	// len(b).
0000000000000000000000000000000000000000;;	func (f *File) Write(b []byte) (int, error) {
0000000000000000000000000000000000000000;;		// Split the write into multiple maxPacket sized concurrent writes
0000000000000000000000000000000000000000;;		// bounded by maxConcurrentRequests. This allows writes with a suitably
0000000000000000000000000000000000000000;;		// large buffer to transfer data at a much faster rate due to
0000000000000000000000000000000000000000;;		// overlapping round trip times.
0000000000000000000000000000000000000000;;		inFlight := 0
0000000000000000000000000000000000000000;;		desiredInFlight := 1
0000000000000000000000000000000000000000;;		offset := f.offset
0000000000000000000000000000000000000000;;		ch := make(chan result, 1)
0000000000000000000000000000000000000000;;		var firstErr error
0000000000000000000000000000000000000000;;		written := len(b)
0000000000000000000000000000000000000000;;		for len(b) > 0 || inFlight > 0 {
0000000000000000000000000000000000000000;;			for inFlight < desiredInFlight && len(b) > 0 && firstErr == nil {
0000000000000000000000000000000000000000;;				l := min(len(b), f.c.maxPacket)
0000000000000000000000000000000000000000;;				rb := b[:l]
0000000000000000000000000000000000000000;;				f.c.dispatchRequest(ch, sshFxpWritePacket{
0000000000000000000000000000000000000000;;					ID:     f.c.nextID(),
0000000000000000000000000000000000000000;;					Handle: f.handle,
0000000000000000000000000000000000000000;;					Offset: offset,
0000000000000000000000000000000000000000;;					Length: uint32(len(rb)),
0000000000000000000000000000000000000000;;					Data:   rb,
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				inFlight++
0000000000000000000000000000000000000000;;				offset += uint64(l)
0000000000000000000000000000000000000000;;				b = b[l:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if inFlight == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case res := <-ch:
0000000000000000000000000000000000000000;;				inFlight--
0000000000000000000000000000000000000000;;				if res.err != nil {
0000000000000000000000000000000000000000;;					firstErr = res.err
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch res.typ {
0000000000000000000000000000000000000000;;				case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;					id, _ := unmarshalUint32(res.data)
0000000000000000000000000000000000000000;;					err := normaliseError(unmarshalStatus(id, res.data))
0000000000000000000000000000000000000000;;					if err != nil && firstErr == nil {
0000000000000000000000000000000000000000;;						firstErr = err
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if desiredInFlight < maxConcurrentRequests {
0000000000000000000000000000000000000000;;						desiredInFlight++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					firstErr = unimplementedPacketErr(res.typ)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If error is non-nil, then there may be gaps in the data written to
0000000000000000000000000000000000000000;;		// the file so it's best to return 0 so the caller can't make any
0000000000000000000000000000000000000000;;		// incorrect assumptions about the state of the file.
0000000000000000000000000000000000000000;;		if firstErr != nil {
0000000000000000000000000000000000000000;;			written = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.offset += uint64(written)
0000000000000000000000000000000000000000;;		return written, firstErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadFrom reads data from r until EOF and writes it to the file. The return
0000000000000000000000000000000000000000;;	// value is the number of bytes read. Any error except io.EOF encountered
0000000000000000000000000000000000000000;;	// during the read is also returned.
0000000000000000000000000000000000000000;;	func (f *File) ReadFrom(r io.Reader) (int64, error) {
0000000000000000000000000000000000000000;;		inFlight := 0
0000000000000000000000000000000000000000;;		desiredInFlight := 1
0000000000000000000000000000000000000000;;		offset := f.offset
0000000000000000000000000000000000000000;;		ch := make(chan result, 1)
0000000000000000000000000000000000000000;;		var firstErr error
0000000000000000000000000000000000000000;;		read := int64(0)
0000000000000000000000000000000000000000;;		b := make([]byte, f.c.maxPacket)
0000000000000000000000000000000000000000;;		for inFlight > 0 || firstErr == nil {
0000000000000000000000000000000000000000;;			for inFlight < desiredInFlight && firstErr == nil {
0000000000000000000000000000000000000000;;				n, err := r.Read(b)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					firstErr = err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				f.c.dispatchRequest(ch, sshFxpWritePacket{
0000000000000000000000000000000000000000;;					ID:     f.c.nextID(),
0000000000000000000000000000000000000000;;					Handle: f.handle,
0000000000000000000000000000000000000000;;					Offset: offset,
0000000000000000000000000000000000000000;;					Length: uint32(n),
0000000000000000000000000000000000000000;;					Data:   b[:n],
0000000000000000000000000000000000000000;;				})
0000000000000000000000000000000000000000;;				inFlight++
0000000000000000000000000000000000000000;;				offset += uint64(n)
0000000000000000000000000000000000000000;;				read += int64(n)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if inFlight == 0 {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case res := <-ch:
0000000000000000000000000000000000000000;;				inFlight--
0000000000000000000000000000000000000000;;				if res.err != nil {
0000000000000000000000000000000000000000;;					firstErr = res.err
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				switch res.typ {
0000000000000000000000000000000000000000;;				case ssh_FXP_STATUS:
0000000000000000000000000000000000000000;;					id, _ := unmarshalUint32(res.data)
0000000000000000000000000000000000000000;;					err := normaliseError(unmarshalStatus(id, res.data))
0000000000000000000000000000000000000000;;					if err != nil && firstErr == nil {
0000000000000000000000000000000000000000;;						firstErr = err
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if desiredInFlight < maxConcurrentRequests {
0000000000000000000000000000000000000000;;						desiredInFlight++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					firstErr = unimplementedPacketErr(res.typ)
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if firstErr == io.EOF {
0000000000000000000000000000000000000000;;			firstErr = nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// If error is non-nil, then there may be gaps in the data written to
0000000000000000000000000000000000000000;;		// the file so it's best to return 0 so the caller can't make any
0000000000000000000000000000000000000000;;		// incorrect assumptions about the state of the file.
0000000000000000000000000000000000000000;;		if firstErr != nil {
0000000000000000000000000000000000000000;;			read = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		f.offset += uint64(read)
0000000000000000000000000000000000000000;;		return read, firstErr
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Seek implements io.Seeker by setting the client offset for the next Read or
0000000000000000000000000000000000000000;;	// Write. It returns the next offset read. Seeking before or after the end of
0000000000000000000000000000000000000000;;	// the file is undefined. Seeking relative to the end calls Stat.
0000000000000000000000000000000000000000;;	func (f *File) Seek(offset int64, whence int) (int64, error) {
0000000000000000000000000000000000000000;;		switch whence {
0000000000000000000000000000000000000000;;		case os.SEEK_SET:
0000000000000000000000000000000000000000;;			f.offset = uint64(offset)
0000000000000000000000000000000000000000;;		case os.SEEK_CUR:
0000000000000000000000000000000000000000;;			f.offset = uint64(int64(f.offset) + offset)
0000000000000000000000000000000000000000;;		case os.SEEK_END:
0000000000000000000000000000000000000000;;			fi, err := f.Stat()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return int64(f.offset), err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			f.offset = uint64(fi.Size() + offset)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return int64(f.offset), unimplementedSeekWhence(whence)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int64(f.offset), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chown changes the uid/gid of the current file.
0000000000000000000000000000000000000000;;	func (f *File) Chown(uid, gid int) error {
0000000000000000000000000000000000000000;;		return f.c.Chown(f.path, uid, gid)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Chmod changes the permissions of the current file.
0000000000000000000000000000000000000000;;	func (f *File) Chmod(mode os.FileMode) error {
0000000000000000000000000000000000000000;;		return f.c.Chmod(f.path, mode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Truncate sets the size of the current file. Although it may be safely assumed
0000000000000000000000000000000000000000;;	// that if the size is less than its current size it will be truncated to fit,
0000000000000000000000000000000000000000;;	// the SFTP protocol does not specify what behavior the server should do when setting
0000000000000000000000000000000000000000;;	// size greater than the current size.
0000000000000000000000000000000000000000;;	func (f *File) Truncate(size int64) error {
0000000000000000000000000000000000000000;;		return f.c.Truncate(f.path, size)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func min(a, b int) int {
0000000000000000000000000000000000000000;;		if a > b {
0000000000000000000000000000000000000000;;			return b
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// normaliseError normalises an error into a more standard form that can be
0000000000000000000000000000000000000000;;	// checked against stdlib errors like io.EOF or os.ErrNotExist.
0000000000000000000000000000000000000000;;	func normaliseError(err error) error {
0000000000000000000000000000000000000000;;		switch err := err.(type) {
0000000000000000000000000000000000000000;;		case *StatusError:
0000000000000000000000000000000000000000;;			switch err.Code {
0000000000000000000000000000000000000000;;			case ssh_FX_EOF:
0000000000000000000000000000000000000000;;				return io.EOF
0000000000000000000000000000000000000000;;			case ssh_FX_NO_SUCH_FILE:
0000000000000000000000000000000000000000;;				return os.ErrNotExist
0000000000000000000000000000000000000000;;			case ssh_FX_OK:
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unmarshalStatus(id uint32, data []byte) error {
0000000000000000000000000000000000000000;;		sid, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;		if sid != id {
0000000000000000000000000000000000000000;;			return &unexpectedIDErr{id, sid}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		code, data := unmarshalUint32(data)
0000000000000000000000000000000000000000;;		msg, data, err := unmarshalStringSafe(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lang, _, _ := unmarshalStringSafe(data)
0000000000000000000000000000000000000000;;		return &StatusError{
0000000000000000000000000000000000000000;;			Code: code,
0000000000000000000000000000000000000000;;			msg:  msg,
0000000000000000000000000000000000000000;;			lang: lang,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func marshalStatus(b []byte, err StatusError) []byte {
0000000000000000000000000000000000000000;;		b = marshalUint32(b, err.Code)
0000000000000000000000000000000000000000;;		b = marshalString(b, err.msg)
0000000000000000000000000000000000000000;;		b = marshalString(b, err.lang)
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// flags converts the flags passed to OpenFile into ssh flags.
0000000000000000000000000000000000000000;;	// Unsupported flags are ignored.
0000000000000000000000000000000000000000;;	func flags(f int) uint32 {
0000000000000000000000000000000000000000;;		var out uint32
0000000000000000000000000000000000000000;;		switch f & os.O_WRONLY {
0000000000000000000000000000000000000000;;		case os.O_WRONLY:
0000000000000000000000000000000000000000;;			out |= ssh_FXF_WRITE
0000000000000000000000000000000000000000;;		case os.O_RDONLY:
0000000000000000000000000000000000000000;;			out |= ssh_FXF_READ
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f&os.O_RDWR == os.O_RDWR {
0000000000000000000000000000000000000000;;			out |= ssh_FXF_READ | ssh_FXF_WRITE
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f&os.O_APPEND == os.O_APPEND {
0000000000000000000000000000000000000000;;			out |= ssh_FXF_APPEND
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f&os.O_CREATE == os.O_CREATE {
0000000000000000000000000000000000000000;;			out |= ssh_FXF_CREAT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f&os.O_TRUNC == os.O_TRUNC {
0000000000000000000000000000000000000000;;			out |= ssh_FXF_TRUNC
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if f&os.O_EXCL == os.O_EXCL {
0000000000000000000000000000000000000000;;			out |= ssh_FXF_EXCL
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out
0000000000000000000000000000000000000000;;	}
