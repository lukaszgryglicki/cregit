0000000000000000000000000000000000000000;;	package errors
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Frame represents a program counter inside a stack frame.
0000000000000000000000000000000000000000;;	type Frame uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// pc returns the program counter for this frame;
0000000000000000000000000000000000000000;;	// multiple frames may have the same PC value.
0000000000000000000000000000000000000000;;	func (f Frame) pc() uintptr { return uintptr(f) - 1 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// file returns the full path to the file that contains the
0000000000000000000000000000000000000000;;	// function for this Frame's pc.
0000000000000000000000000000000000000000;;	func (f Frame) file() string {
0000000000000000000000000000000000000000;;		fn := runtime.FuncForPC(f.pc())
0000000000000000000000000000000000000000;;		if fn == nil {
0000000000000000000000000000000000000000;;			return "unknown"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		file, _ := fn.FileLine(f.pc())
0000000000000000000000000000000000000000;;		return file
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// line returns the line number of source code of the
0000000000000000000000000000000000000000;;	// function for this Frame's pc.
0000000000000000000000000000000000000000;;	func (f Frame) line() int {
0000000000000000000000000000000000000000;;		fn := runtime.FuncForPC(f.pc())
0000000000000000000000000000000000000000;;		if fn == nil {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, line := fn.FileLine(f.pc())
0000000000000000000000000000000000000000;;		return line
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Format formats the frame according to the fmt.Formatter interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    %s    source file
0000000000000000000000000000000000000000;;	//    %d    source line
0000000000000000000000000000000000000000;;	//    %n    function name
0000000000000000000000000000000000000000;;	//    %v    equivalent to %s:%d
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Format accepts flags that alter the printing of some verbs, as follows:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    %+s   path of source file relative to the compile time GOPATH
0000000000000000000000000000000000000000;;	//    %+v   equivalent to %+s:%d
0000000000000000000000000000000000000000;;	func (f Frame) Format(s fmt.State, verb rune) {
0000000000000000000000000000000000000000;;		switch verb {
0000000000000000000000000000000000000000;;		case 's':
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case s.Flag('+'):
0000000000000000000000000000000000000000;;				pc := f.pc()
0000000000000000000000000000000000000000;;				fn := runtime.FuncForPC(pc)
0000000000000000000000000000000000000000;;				if fn == nil {
0000000000000000000000000000000000000000;;					io.WriteString(s, "unknown")
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					file, _ := fn.FileLine(pc)
0000000000000000000000000000000000000000;;					fmt.Fprintf(s, "%s\n\t%s", fn.Name(), file)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				io.WriteString(s, path.Base(f.file()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 'd':
0000000000000000000000000000000000000000;;			fmt.Fprintf(s, "%d", f.line())
0000000000000000000000000000000000000000;;		case 'n':
0000000000000000000000000000000000000000;;			name := runtime.FuncForPC(f.pc()).Name()
0000000000000000000000000000000000000000;;			io.WriteString(s, funcname(name))
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			f.Format(s, 's')
0000000000000000000000000000000000000000;;			io.WriteString(s, ":")
0000000000000000000000000000000000000000;;			f.Format(s, 'd')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StackTrace is stack of Frames from innermost (newest) to outermost (oldest).
0000000000000000000000000000000000000000;;	type StackTrace []Frame
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (st StackTrace) Format(s fmt.State, verb rune) {
0000000000000000000000000000000000000000;;		switch verb {
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case s.Flag('+'):
0000000000000000000000000000000000000000;;				for _, f := range st {
0000000000000000000000000000000000000000;;					fmt.Fprintf(s, "\n%+v", f)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			case s.Flag('#'):
0000000000000000000000000000000000000000;;				fmt.Fprintf(s, "%#v", []Frame(st))
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				fmt.Fprintf(s, "%v", []Frame(st))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case 's':
0000000000000000000000000000000000000000;;			fmt.Fprintf(s, "%s", []Frame(st))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// stack represents a stack of program counters.
0000000000000000000000000000000000000000;;	type stack []uintptr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stack) Format(st fmt.State, verb rune) {
0000000000000000000000000000000000000000;;		switch verb {
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case st.Flag('+'):
0000000000000000000000000000000000000000;;				for _, pc := range *s {
0000000000000000000000000000000000000000;;					f := Frame(pc)
0000000000000000000000000000000000000000;;					fmt.Fprintf(st, "\n%+v", f)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stack) StackTrace() StackTrace {
0000000000000000000000000000000000000000;;		f := make([]Frame, len(*s))
0000000000000000000000000000000000000000;;		for i := 0; i < len(f); i++ {
0000000000000000000000000000000000000000;;			f[i] = Frame((*s)[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return f
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func callers() *stack {
0000000000000000000000000000000000000000;;		const depth = 32
0000000000000000000000000000000000000000;;		var pcs [depth]uintptr
0000000000000000000000000000000000000000;;		n := runtime.Callers(3, pcs[:])
0000000000000000000000000000000000000000;;		var st stack = pcs[0:n]
0000000000000000000000000000000000000000;;		return &st
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// funcname removes the path prefix component of a function's name reported by func.Name().
0000000000000000000000000000000000000000;;	func funcname(name string) string {
0000000000000000000000000000000000000000;;		i := strings.LastIndex(name, "/")
0000000000000000000000000000000000000000;;		name = name[i+1:]
0000000000000000000000000000000000000000;;		i = strings.Index(name, ".")
0000000000000000000000000000000000000000;;		return name[i+1:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func trimGOPATH(name, file string) string {
0000000000000000000000000000000000000000;;		// Here we want to get the source file path relative to the compile time
0000000000000000000000000000000000000000;;		// GOPATH. As of Go 1.6.x there is no direct way to know the compiled
0000000000000000000000000000000000000000;;		// GOPATH at runtime, but we can infer the number of path segments in the
0000000000000000000000000000000000000000;;		// GOPATH. We note that fn.Name() returns the function name qualified by
0000000000000000000000000000000000000000;;		// the import path, which does not include the GOPATH. Thus we can trim
0000000000000000000000000000000000000000;;		// segments from the beginning of the file path until the number of path
0000000000000000000000000000000000000000;;		// separators remaining is one more than the number of path separators in
0000000000000000000000000000000000000000;;		// the function name. For example, given:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//    GOPATH     /home/user
0000000000000000000000000000000000000000;;		//    file       /home/user/src/pkg/sub/file.go
0000000000000000000000000000000000000000;;		//    fn.Name()  pkg/sub.Type.Method
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// We want to produce:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//    pkg/sub/file.go
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// From this we can easily see that fn.Name() has one less path separator
0000000000000000000000000000000000000000;;		// than our desired output. We count separators from the end of the file
0000000000000000000000000000000000000000;;		// path until it finds two more than in the function name and then move
0000000000000000000000000000000000000000;;		// one character forward to preserve the initial path segment without a
0000000000000000000000000000000000000000;;		// leading separator.
0000000000000000000000000000000000000000;;		const sep = "/"
0000000000000000000000000000000000000000;;		goal := strings.Count(name, sep) + 2
0000000000000000000000000000000000000000;;		i := len(file)
0000000000000000000000000000000000000000;;		for n := 0; n < goal; n++ {
0000000000000000000000000000000000000000;;			i = strings.LastIndex(file[:i], sep)
0000000000000000000000000000000000000000;;			if i == -1 {
0000000000000000000000000000000000000000;;				// not enough separators found, set i so that the slice expression
0000000000000000000000000000000000000000;;				// below leaves file unmodified
0000000000000000000000000000000000000000;;				i = -len(sep)
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// get back to 0 or trim the leading separator
0000000000000000000000000000000000000000;;		file = file[i+len(sep):]
0000000000000000000000000000000000000000;;		return file
0000000000000000000000000000000000000000;;	}
