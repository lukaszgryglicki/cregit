0000000000000000000000000000000000000000;;	// Package errors provides simple error handling primitives.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The traditional error handling idiom in Go is roughly akin to
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     if err != nil {
0000000000000000000000000000000000000000;;	//             return err
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// which applied recursively up the call stack results in error reports
0000000000000000000000000000000000000000;;	// without context or debugging information. The errors package allows
0000000000000000000000000000000000000000;;	// programmers to add context to the failure path in their code in a way
0000000000000000000000000000000000000000;;	// that does not destroy the original value of the error.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Adding context to an error
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The errors.Wrap function returns a new error that adds context to the
0000000000000000000000000000000000000000;;	// original error. For example
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     _, err := ioutil.ReadAll(r)
0000000000000000000000000000000000000000;;	//     if err != nil {
0000000000000000000000000000000000000000;;	//             return errors.Wrap(err, "read failed")
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Retrieving the cause of an error
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Using errors.Wrap constructs a stack of errors, adding context to the
0000000000000000000000000000000000000000;;	// preceding error. Depending on the nature of the error it may be necessary
0000000000000000000000000000000000000000;;	// to reverse the operation of errors.Wrap to retrieve the original error
0000000000000000000000000000000000000000;;	// for inspection. Any error value which implements this interface
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     type causer interface {
0000000000000000000000000000000000000000;;	//             Cause() error
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// can be inspected by errors.Cause. errors.Cause will recursively retrieve
0000000000000000000000000000000000000000;;	// the topmost error which does not implement causer, which is assumed to be
0000000000000000000000000000000000000000;;	// the original cause. For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     switch err := errors.Cause(err).(type) {
0000000000000000000000000000000000000000;;	//     case *MyError:
0000000000000000000000000000000000000000;;	//             // handle specifically
0000000000000000000000000000000000000000;;	//     default:
0000000000000000000000000000000000000000;;	//             // unknown error
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// causer interface is not exported by this package, but is considered a part
0000000000000000000000000000000000000000;;	// of stable public API.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Formatted printing of errors
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// All error values returned from this package implement fmt.Formatter and can
0000000000000000000000000000000000000000;;	// be formatted by the fmt package. The following verbs are supported
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     %s    print the error. If the error has a Cause it will be
0000000000000000000000000000000000000000;;	//           printed recursively
0000000000000000000000000000000000000000;;	//     %v    see %s
0000000000000000000000000000000000000000;;	//     %+v   extended format. Each Frame of the error's StackTrace will
0000000000000000000000000000000000000000;;	//           be printed in detail.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Retrieving the stack trace of an error or wrapper
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// New, Errorf, Wrap, and Wrapf record a stack trace at the point they are
0000000000000000000000000000000000000000;;	// invoked. This information can be retrieved with the following interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     type stackTracer interface {
0000000000000000000000000000000000000000;;	//             StackTrace() errors.StackTrace
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Where errors.StackTrace is defined as
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     type StackTrace []Frame
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The Frame type represents a call site in the stack trace. Frame supports
0000000000000000000000000000000000000000;;	// the fmt.Formatter interface that can be used for printing information about
0000000000000000000000000000000000000000;;	// the stack trace of this error. For example:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     if err, ok := err.(stackTracer); ok {
0000000000000000000000000000000000000000;;	//             for _, f := range err.StackTrace() {
0000000000000000000000000000000000000000;;	//                     fmt.Printf("%+s:%d", f)
0000000000000000000000000000000000000000;;	//             }
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// stackTracer interface is not exported by this package, but is considered a part
0000000000000000000000000000000000000000;;	// of stable public API.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// See the documentation for Frame.Format for more details.
0000000000000000000000000000000000000000;;	package errors
1ff933fb12f53e8c83a97bf4a48f852f030855aa;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New returns an error with the supplied message.
0000000000000000000000000000000000000000;;	// New also records the stack trace at the point it was called.
0000000000000000000000000000000000000000;;	func New(message string) error {
0000000000000000000000000000000000000000;;		return &fundamental{
0000000000000000000000000000000000000000;;			msg:   message,
0000000000000000000000000000000000000000;;			stack: callers(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Errorf formats according to a format specifier and returns the string
0000000000000000000000000000000000000000;;	// as a value that satisfies error.
0000000000000000000000000000000000000000;;	// Errorf also records the stack trace at the point it was called.
0000000000000000000000000000000000000000;;	func Errorf(format string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		return &fundamental{
0000000000000000000000000000000000000000;;			msg:   fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;			stack: callers(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// fundamental is an error that has a message and a stack, but no caller.
0000000000000000000000000000000000000000;;	type fundamental struct {
0000000000000000000000000000000000000000;;		msg string
0000000000000000000000000000000000000000;;		*stack
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fundamental) Error() string { return f.msg }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *fundamental) Format(s fmt.State, verb rune) {
0000000000000000000000000000000000000000;;		switch verb {
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			if s.Flag('+') {
0000000000000000000000000000000000000000;;				io.WriteString(s, f.msg)
0000000000000000000000000000000000000000;;				f.stack.Format(s, verb)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case 's', 'q':
0000000000000000000000000000000000000000;;			io.WriteString(s, f.msg)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type withStack struct {
0000000000000000000000000000000000000000;;		error
0000000000000000000000000000000000000000;;		*stack
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *withStack) Cause() error { return w.error }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *withStack) Format(s fmt.State, verb rune) {
0000000000000000000000000000000000000000;;		switch verb {
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			if s.Flag('+') {
0000000000000000000000000000000000000000;;				fmt.Fprintf(s, "%+v", w.Cause())
0000000000000000000000000000000000000000;;				w.stack.Format(s, verb)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case 's':
0000000000000000000000000000000000000000;;			io.WriteString(s, w.Error())
0000000000000000000000000000000000000000;;		case 'q':
0000000000000000000000000000000000000000;;			fmt.Fprintf(s, "%q", w.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wrap returns an error annotating err with message.
0000000000000000000000000000000000000000;;	// If err is nil, Wrap returns nil.
0000000000000000000000000000000000000000;;	func Wrap(err error, message string) error {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = &withMessage{
0000000000000000000000000000000000000000;;			cause: err,
0000000000000000000000000000000000000000;;			msg:   message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &withStack{
0000000000000000000000000000000000000000;;			err,
0000000000000000000000000000000000000000;;			callers(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Wrapf returns an error annotating err with the format specifier.
0000000000000000000000000000000000000000;;	// If err is nil, Wrapf returns nil.
0000000000000000000000000000000000000000;;	func Wrapf(err error, format string, args ...interface{}) error {
0000000000000000000000000000000000000000;;		if err == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = &withMessage{
0000000000000000000000000000000000000000;;			cause: err,
0000000000000000000000000000000000000000;;			msg:   fmt.Sprintf(format, args...),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &withStack{
0000000000000000000000000000000000000000;;			err,
0000000000000000000000000000000000000000;;			callers(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type withMessage struct {
0000000000000000000000000000000000000000;;		cause error
0000000000000000000000000000000000000000;;		msg   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *withMessage) Error() string { return w.msg + ": " + w.cause.Error() }
0000000000000000000000000000000000000000;;	func (w *withMessage) Cause() error  { return w.cause }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (w *withMessage) Format(s fmt.State, verb rune) {
0000000000000000000000000000000000000000;;		switch verb {
0000000000000000000000000000000000000000;;		case 'v':
0000000000000000000000000000000000000000;;			if s.Flag('+') {
0000000000000000000000000000000000000000;;				fmt.Fprintf(s, "%+v\n", w.Cause())
0000000000000000000000000000000000000000;;				io.WriteString(s, w.msg)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fallthrough
0000000000000000000000000000000000000000;;		case 's', 'q':
0000000000000000000000000000000000000000;;			io.WriteString(s, w.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Cause returns the underlying cause of the error, if possible.
0000000000000000000000000000000000000000;;	// An error value has a cause if it implements the following
0000000000000000000000000000000000000000;;	// interface:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//     type causer interface {
0000000000000000000000000000000000000000;;	//            Cause() error
0000000000000000000000000000000000000000;;	//     }
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// If the error does not implement Cause, the original error will
0000000000000000000000000000000000000000;;	// be returned. If the error is nil, nil will be returned without further
0000000000000000000000000000000000000000;;	// investigation.
0000000000000000000000000000000000000000;;	func Cause(err error) error {
0000000000000000000000000000000000000000;;		type causer interface {
0000000000000000000000000000000000000000;;			Cause() error
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for err != nil {
0000000000000000000000000000000000000000;;			cause, ok := err.(causer)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			err = cause.Cause()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
