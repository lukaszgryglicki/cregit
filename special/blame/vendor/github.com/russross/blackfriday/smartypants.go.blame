0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Blackfriday Markdown Processor
0000000000000000000000000000000000000000;;	// Available at http://github.com/russross/blackfriday
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright © 2011 Russ Ross <russ@russross.com>.
0000000000000000000000000000000000000000;;	// Distributed under the Simplified BSD License.
0000000000000000000000000000000000000000;;	// See README.md for details.
0000000000000000000000000000000000000000;;	//
50f9755c60b2914e7a0c6daa6fbd3a38d2cab61c;Godeps/_workspace/src/github.com/russross/blackfriday/smartypants.go[Godeps/_workspace/src/github.com/russross/blackfriday/smartypants.go][vendor/github.com/russross/blackfriday/smartypants.go];	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// SmartyPants rendering
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package blackfriday
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type smartypantsData struct {
0000000000000000000000000000000000000000;;		inSingleQuote bool
0000000000000000000000000000000000000000;;		inDoubleQuote bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func wordBoundary(c byte) bool {
0000000000000000000000000000000000000000;;		return c == 0 || isspace(c) || ispunct(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func tolower(c byte) byte {
0000000000000000000000000000000000000000;;		if c >= 'A' && c <= 'Z' {
0000000000000000000000000000000000000000;;			return c - 'A' + 'a'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isdigit(c byte) bool {
0000000000000000000000000000000000000000;;		return c >= '0' && c <= '9'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartQuoteHelper(out *bytes.Buffer, previousChar byte, nextChar byte, quote byte, isOpen *bool) bool {
0000000000000000000000000000000000000000;;		// edge of the buffer is likely to be a tag that we don't get to see,
0000000000000000000000000000000000000000;;		// so we treat it like text sometimes
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// enumerate all sixteen possibilities for (previousChar, nextChar)
0000000000000000000000000000000000000000;;		// each can be one of {0, space, punct, other}
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case previousChar == 0 && nextChar == 0:
0000000000000000000000000000000000000000;;			// context is not any help here, so toggle
0000000000000000000000000000000000000000;;			*isOpen = !*isOpen
0000000000000000000000000000000000000000;;		case isspace(previousChar) && nextChar == 0:
0000000000000000000000000000000000000000;;			// [ "] might be [ "<code>foo...]
0000000000000000000000000000000000000000;;			*isOpen = true
0000000000000000000000000000000000000000;;		case ispunct(previousChar) && nextChar == 0:
0000000000000000000000000000000000000000;;			// [!"] hmm... could be [Run!"] or [("<code>...]
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		case /* isnormal(previousChar) && */ nextChar == 0:
0000000000000000000000000000000000000000;;			// [a"] is probably a close
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		case previousChar == 0 && isspace(nextChar):
0000000000000000000000000000000000000000;;			// [" ] might be [...foo</code>" ]
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		case isspace(previousChar) && isspace(nextChar):
0000000000000000000000000000000000000000;;			// [ " ] context is not any help here, so toggle
0000000000000000000000000000000000000000;;			*isOpen = !*isOpen
0000000000000000000000000000000000000000;;		case ispunct(previousChar) && isspace(nextChar):
0000000000000000000000000000000000000000;;			// [!" ] is probably a close
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		case /* isnormal(previousChar) && */ isspace(nextChar):
0000000000000000000000000000000000000000;;			// [a" ] this is one of the easy cases
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		case previousChar == 0 && ispunct(nextChar):
0000000000000000000000000000000000000000;;			// ["!] hmm... could be ["$1.95] or [</code>"!...]
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		case isspace(previousChar) && ispunct(nextChar):
0000000000000000000000000000000000000000;;			// [ "!] looks more like [ "$1.95]
0000000000000000000000000000000000000000;;			*isOpen = true
0000000000000000000000000000000000000000;;		case ispunct(previousChar) && ispunct(nextChar):
0000000000000000000000000000000000000000;;			// [!"!] context is not any help here, so toggle
0000000000000000000000000000000000000000;;			*isOpen = !*isOpen
0000000000000000000000000000000000000000;;		case /* isnormal(previousChar) && */ ispunct(nextChar):
0000000000000000000000000000000000000000;;			// [a"!] is probably a close
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		case previousChar == 0 /* && isnormal(nextChar) */ :
0000000000000000000000000000000000000000;;			// ["a] is probably an open
0000000000000000000000000000000000000000;;			*isOpen = true
0000000000000000000000000000000000000000;;		case isspace(previousChar) /* && isnormal(nextChar) */ :
0000000000000000000000000000000000000000;;			// [ "a] this is one of the easy cases
0000000000000000000000000000000000000000;;			*isOpen = true
0000000000000000000000000000000000000000;;		case ispunct(previousChar) /* && isnormal(nextChar) */ :
0000000000000000000000000000000000000000;;			// [!"a] is probably an open
0000000000000000000000000000000000000000;;			*isOpen = true
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			// [a'b] maybe a contraction?
0000000000000000000000000000000000000000;;			*isOpen = false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte('&')
0000000000000000000000000000000000000000;;		if *isOpen {
0000000000000000000000000000000000000000;;			out.WriteByte('l')
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteByte('r')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteByte(quote)
0000000000000000000000000000000000000000;;		out.WriteString("quo;")
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartSingleQuote(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if len(text) >= 2 {
0000000000000000000000000000000000000000;;			t1 := tolower(text[1])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t1 == '\'' {
0000000000000000000000000000000000000000;;				nextChar := byte(0)
0000000000000000000000000000000000000000;;				if len(text) >= 3 {
0000000000000000000000000000000000000000;;					nextChar = text[2]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if smartQuoteHelper(out, previousChar, nextChar, 'd', &smrt.inDoubleQuote) {
0000000000000000000000000000000000000000;;					return 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if (t1 == 's' || t1 == 't' || t1 == 'm' || t1 == 'd') && (len(text) < 3 || wordBoundary(text[2])) {
0000000000000000000000000000000000000000;;				out.WriteString("&rsquo;")
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(text) >= 3 {
0000000000000000000000000000000000000000;;				t2 := tolower(text[2])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if ((t1 == 'r' && t2 == 'e') || (t1 == 'l' && t2 == 'l') || (t1 == 'v' && t2 == 'e')) &&
0000000000000000000000000000000000000000;;					(len(text) < 4 || wordBoundary(text[3])) {
0000000000000000000000000000000000000000;;					out.WriteString("&rsquo;")
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nextChar := byte(0)
0000000000000000000000000000000000000000;;		if len(text) > 1 {
0000000000000000000000000000000000000000;;			nextChar = text[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if smartQuoteHelper(out, previousChar, nextChar, 's', &smrt.inSingleQuote) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartParens(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if len(text) >= 3 {
0000000000000000000000000000000000000000;;			t1 := tolower(text[1])
0000000000000000000000000000000000000000;;			t2 := tolower(text[2])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t1 == 'c' && t2 == ')' {
0000000000000000000000000000000000000000;;				out.WriteString("&copy;")
0000000000000000000000000000000000000000;;				return 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t1 == 'r' && t2 == ')' {
0000000000000000000000000000000000000000;;				out.WriteString("&reg;")
0000000000000000000000000000000000000000;;				return 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(text) >= 4 && t1 == 't' && t2 == 'm' && text[3] == ')' {
0000000000000000000000000000000000000000;;				out.WriteString("&trade;")
0000000000000000000000000000000000000000;;				return 3
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartDash(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if len(text) >= 2 {
0000000000000000000000000000000000000000;;			if text[1] == '-' {
0000000000000000000000000000000000000000;;				out.WriteString("&mdash;")
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if wordBoundary(previousChar) && wordBoundary(text[1]) {
0000000000000000000000000000000000000000;;				out.WriteString("&ndash;")
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartDashLatex(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if len(text) >= 3 && text[1] == '-' && text[2] == '-' {
0000000000000000000000000000000000000000;;			out.WriteString("&mdash;")
0000000000000000000000000000000000000000;;			return 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(text) >= 2 && text[1] == '-' {
0000000000000000000000000000000000000000;;			out.WriteString("&ndash;")
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartAmpVariant(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte, quote byte) int {
0000000000000000000000000000000000000000;;		if bytes.HasPrefix(text, []byte("&quot;")) {
0000000000000000000000000000000000000000;;			nextChar := byte(0)
0000000000000000000000000000000000000000;;			if len(text) >= 7 {
0000000000000000000000000000000000000000;;				nextChar = text[6]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if smartQuoteHelper(out, previousChar, nextChar, quote, &smrt.inDoubleQuote) {
0000000000000000000000000000000000000000;;				return 5
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if bytes.HasPrefix(text, []byte("&#0;")) {
0000000000000000000000000000000000000000;;			return 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte('&')
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartAmp(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		return smartAmpVariant(out, smrt, previousChar, text, 'd')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartAmpAngledQuote(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		return smartAmpVariant(out, smrt, previousChar, text, 'a')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartPeriod(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if len(text) >= 3 && text[1] == '.' && text[2] == '.' {
0000000000000000000000000000000000000000;;			out.WriteString("&hellip;")
0000000000000000000000000000000000000000;;			return 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(text) >= 5 && text[1] == ' ' && text[2] == '.' && text[3] == ' ' && text[4] == '.' {
0000000000000000000000000000000000000000;;			out.WriteString("&hellip;")
0000000000000000000000000000000000000000;;			return 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartBacktick(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if len(text) >= 2 && text[1] == '`' {
0000000000000000000000000000000000000000;;			nextChar := byte(0)
0000000000000000000000000000000000000000;;			if len(text) >= 3 {
0000000000000000000000000000000000000000;;				nextChar = text[2]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if smartQuoteHelper(out, previousChar, nextChar, 'd', &smrt.inDoubleQuote) {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartNumberGeneric(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if wordBoundary(previousChar) && previousChar != '/' && len(text) >= 3 {
0000000000000000000000000000000000000000;;			// is it of the form digits/digits(word boundary)?, i.e., \d+/\d+\b
0000000000000000000000000000000000000000;;			// note: check for regular slash (/) or fraction slash (⁄, 0x2044, or 0xe2 81 84 in utf-8)
0000000000000000000000000000000000000000;;			//       and avoid changing dates like 1/23/2005 into fractions.
0000000000000000000000000000000000000000;;			numEnd := 0
0000000000000000000000000000000000000000;;			for len(text) > numEnd && isdigit(text[numEnd]) {
0000000000000000000000000000000000000000;;				numEnd++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if numEnd == 0 {
0000000000000000000000000000000000000000;;				out.WriteByte(text[0])
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			denStart := numEnd + 1
0000000000000000000000000000000000000000;;			if len(text) > numEnd+3 && text[numEnd] == 0xe2 && text[numEnd+1] == 0x81 && text[numEnd+2] == 0x84 {
0000000000000000000000000000000000000000;;				denStart = numEnd + 3
0000000000000000000000000000000000000000;;			} else if len(text) < numEnd+2 || text[numEnd] != '/' {
0000000000000000000000000000000000000000;;				out.WriteByte(text[0])
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			denEnd := denStart
0000000000000000000000000000000000000000;;			for len(text) > denEnd && isdigit(text[denEnd]) {
0000000000000000000000000000000000000000;;				denEnd++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if denEnd == denStart {
0000000000000000000000000000000000000000;;				out.WriteByte(text[0])
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(text) == denEnd || wordBoundary(text[denEnd]) && text[denEnd] != '/' {
0000000000000000000000000000000000000000;;				out.WriteString("<sup>")
0000000000000000000000000000000000000000;;				out.Write(text[:numEnd])
0000000000000000000000000000000000000000;;				out.WriteString("</sup>&frasl;<sub>")
0000000000000000000000000000000000000000;;				out.Write(text[denStart:denEnd])
0000000000000000000000000000000000000000;;				out.WriteString("</sub>")
0000000000000000000000000000000000000000;;				return denEnd - 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartNumber(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		if wordBoundary(previousChar) && previousChar != '/' && len(text) >= 3 {
0000000000000000000000000000000000000000;;			if text[0] == '1' && text[1] == '/' && text[2] == '2' {
0000000000000000000000000000000000000000;;				if len(text) < 4 || wordBoundary(text[3]) && text[3] != '/' {
0000000000000000000000000000000000000000;;					out.WriteString("&frac12;")
0000000000000000000000000000000000000000;;					return 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if text[0] == '1' && text[1] == '/' && text[2] == '4' {
0000000000000000000000000000000000000000;;				if len(text) < 4 || wordBoundary(text[3]) && text[3] != '/' || (len(text) >= 5 && tolower(text[3]) == 't' && tolower(text[4]) == 'h') {
0000000000000000000000000000000000000000;;					out.WriteString("&frac14;")
0000000000000000000000000000000000000000;;					return 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if text[0] == '3' && text[1] == '/' && text[2] == '4' {
0000000000000000000000000000000000000000;;				if len(text) < 4 || wordBoundary(text[3]) && text[3] != '/' || (len(text) >= 6 && tolower(text[3]) == 't' && tolower(text[4]) == 'h' && tolower(text[5]) == 's') {
0000000000000000000000000000000000000000;;					out.WriteString("&frac34;")
0000000000000000000000000000000000000000;;					return 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte(text[0])
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartDoubleQuoteVariant(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte, quote byte) int {
0000000000000000000000000000000000000000;;		nextChar := byte(0)
0000000000000000000000000000000000000000;;		if len(text) > 1 {
0000000000000000000000000000000000000000;;			nextChar = text[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !smartQuoteHelper(out, previousChar, nextChar, quote, &smrt.inDoubleQuote) {
0000000000000000000000000000000000000000;;			out.WriteString("&quot;")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartDoubleQuote(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		return smartDoubleQuoteVariant(out, smrt, previousChar, text, 'd')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartAngledDoubleQuote(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		return smartDoubleQuoteVariant(out, smrt, previousChar, text, 'a')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartLeftAngle(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i < len(text) && text[i] != '>' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Write(text[:i+1])
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type smartCallback func(out *bytes.Buffer, smrt *smartypantsData, previousChar byte, text []byte) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type smartypantsRenderer [256]smartCallback
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func smartypants(flags int) *smartypantsRenderer {
0000000000000000000000000000000000000000;;		r := new(smartypantsRenderer)
0000000000000000000000000000000000000000;;		if flags&HTML_SMARTYPANTS_ANGLED_QUOTES == 0 {
0000000000000000000000000000000000000000;;			r['"'] = smartDoubleQuote
0000000000000000000000000000000000000000;;			r['&'] = smartAmp
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			r['"'] = smartAngledDoubleQuote
0000000000000000000000000000000000000000;;			r['&'] = smartAmpAngledQuote
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r['\''] = smartSingleQuote
0000000000000000000000000000000000000000;;		r['('] = smartParens
0000000000000000000000000000000000000000;;		if flags&HTML_SMARTYPANTS_DASHES != 0 {
0000000000000000000000000000000000000000;;			if flags&HTML_SMARTYPANTS_LATEX_DASHES == 0 {
0000000000000000000000000000000000000000;;				r['-'] = smartDash
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				r['-'] = smartDashLatex
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r['.'] = smartPeriod
0000000000000000000000000000000000000000;;		if flags&HTML_SMARTYPANTS_FRACTIONS == 0 {
0000000000000000000000000000000000000000;;			r['1'] = smartNumber
0000000000000000000000000000000000000000;;			r['3'] = smartNumber
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for ch := '1'; ch <= '9'; ch++ {
0000000000000000000000000000000000000000;;				r[ch] = smartNumberGeneric
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r['<'] = smartLeftAngle
0000000000000000000000000000000000000000;;		r['`'] = smartBacktick
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
