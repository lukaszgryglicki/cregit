0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Blackfriday Markdown Processor
0000000000000000000000000000000000000000;;	// Available at http://github.com/russross/blackfriday
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright Â© 2011 Russ Ross <russ@russross.com>.
0000000000000000000000000000000000000000;;	// Distributed under the Simplified BSD License.
0000000000000000000000000000000000000000;;	// See README.md for details.
0000000000000000000000000000000000000000;;	//
50f9755c60b2914e7a0c6daa6fbd3a38d2cab61c;Godeps/_workspace/src/github.com/russross/blackfriday/latex.go[Godeps/_workspace/src/github.com/russross/blackfriday/latex.go][vendor/github.com/russross/blackfriday/latex.go];	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// LaTeX rendering backend
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package blackfriday
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Latex is a type that implements the Renderer interface for LaTeX output.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Do not create this directly, instead use the LatexRenderer function.
0000000000000000000000000000000000000000;;	type Latex struct {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// LatexRenderer creates and configures a Latex object, which
0000000000000000000000000000000000000000;;	// satisfies the Renderer interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// flags is a set of LATEX_* options ORed together (currently no such options
0000000000000000000000000000000000000000;;	// are defined).
0000000000000000000000000000000000000000;;	func LatexRenderer(flags int) Renderer {
0000000000000000000000000000000000000000;;		return &Latex{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) GetFlags() int {
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// render code chunks using verbatim, or listings if we have a language
0000000000000000000000000000000000000000;;	func (options *Latex) BlockCode(out *bytes.Buffer, text []byte, lang string) {
0000000000000000000000000000000000000000;;		if lang == "" {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\begin{verbatim}\n")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\begin{lstlisting}[language=")
0000000000000000000000000000000000000000;;			out.WriteString(lang)
0000000000000000000000000000000000000000;;			out.WriteString("]\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		if lang == "" {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\end{verbatim}\n")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\end{lstlisting}\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) TitleBlock(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) BlockQuote(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("\n\\begin{quotation}\n")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("\n\\end{quotation}\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) BlockHtml(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		// a pretty lame thing to do...
0000000000000000000000000000000000000000;;		out.WriteString("\n\\begin{verbatim}\n")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("\n\\end{verbatim}\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) Header(out *bytes.Buffer, text func() bool, level int, id string) {
0000000000000000000000000000000000000000;;		marker := out.Len()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch level {
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			out.WriteString("\n\\section{")
0000000000000000000000000000000000000000;;		case 2:
0000000000000000000000000000000000000000;;			out.WriteString("\n\\subsection{")
0000000000000000000000000000000000000000;;		case 3:
0000000000000000000000000000000000000000;;			out.WriteString("\n\\subsubsection{")
0000000000000000000000000000000000000000;;		case 4:
0000000000000000000000000000000000000000;;			out.WriteString("\n\\paragraph{")
0000000000000000000000000000000000000000;;		case 5:
0000000000000000000000000000000000000000;;			out.WriteString("\n\\subparagraph{")
0000000000000000000000000000000000000000;;		case 6:
0000000000000000000000000000000000000000;;			out.WriteString("\n\\textbf{")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !text() {
0000000000000000000000000000000000000000;;			out.Truncate(marker)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("}\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) HRule(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		out.WriteString("\n\\HRule\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) List(out *bytes.Buffer, text func() bool, flags int) {
0000000000000000000000000000000000000000;;		marker := out.Len()
0000000000000000000000000000000000000000;;		if flags&LIST_TYPE_ORDERED != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\begin{enumerate}\n")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\begin{itemize}\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !text() {
0000000000000000000000000000000000000000;;			out.Truncate(marker)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flags&LIST_TYPE_ORDERED != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\end{enumerate}\n")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("\n\\end{itemize}\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) ListItem(out *bytes.Buffer, text []byte, flags int) {
0000000000000000000000000000000000000000;;		out.WriteString("\n\\item ")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) Paragraph(out *bytes.Buffer, text func() bool) {
0000000000000000000000000000000000000000;;		marker := out.Len()
0000000000000000000000000000000000000000;;		out.WriteString("\n")
0000000000000000000000000000000000000000;;		if !text() {
0000000000000000000000000000000000000000;;			out.Truncate(marker)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) Table(out *bytes.Buffer, header []byte, body []byte, columnData []int) {
0000000000000000000000000000000000000000;;		out.WriteString("\n\\begin{tabular}{")
0000000000000000000000000000000000000000;;		for _, elt := range columnData {
0000000000000000000000000000000000000000;;			switch elt {
0000000000000000000000000000000000000000;;			case TABLE_ALIGNMENT_LEFT:
0000000000000000000000000000000000000000;;				out.WriteByte('l')
0000000000000000000000000000000000000000;;			case TABLE_ALIGNMENT_RIGHT:
0000000000000000000000000000000000000000;;				out.WriteByte('r')
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				out.WriteByte('c')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("}\n")
0000000000000000000000000000000000000000;;		out.Write(header)
0000000000000000000000000000000000000000;;		out.WriteString(" \\\\\n\\hline\n")
0000000000000000000000000000000000000000;;		out.Write(body)
0000000000000000000000000000000000000000;;		out.WriteString("\n\\end{tabular}\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) TableRow(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		if out.Len() > 0 {
0000000000000000000000000000000000000000;;			out.WriteString(" \\\\\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) TableHeaderCell(out *bytes.Buffer, text []byte, align int) {
0000000000000000000000000000000000000000;;		if out.Len() > 0 {
0000000000000000000000000000000000000000;;			out.WriteString(" & ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) TableCell(out *bytes.Buffer, text []byte, align int) {
0000000000000000000000000000000000000000;;		if out.Len() > 0 {
0000000000000000000000000000000000000000;;			out.WriteString(" & ")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: this
0000000000000000000000000000000000000000;;	func (options *Latex) Footnotes(out *bytes.Buffer, text func() bool) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) FootnoteItem(out *bytes.Buffer, name, text []byte, flags int) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) AutoLink(out *bytes.Buffer, link []byte, kind int) {
0000000000000000000000000000000000000000;;		out.WriteString("\\href{")
0000000000000000000000000000000000000000;;		if kind == LINK_TYPE_EMAIL {
0000000000000000000000000000000000000000;;			out.WriteString("mailto:")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Write(link)
0000000000000000000000000000000000000000;;		out.WriteString("}{")
0000000000000000000000000000000000000000;;		out.Write(link)
0000000000000000000000000000000000000000;;		out.WriteString("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) CodeSpan(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("\\texttt{")
0000000000000000000000000000000000000000;;		escapeSpecialChars(out, text)
0000000000000000000000000000000000000000;;		out.WriteString("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) DoubleEmphasis(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("\\textbf{")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) Emphasis(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("\\textit{")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) Image(out *bytes.Buffer, link []byte, title []byte, alt []byte) {
0000000000000000000000000000000000000000;;		if bytes.HasPrefix(link, []byte("http://")) || bytes.HasPrefix(link, []byte("https://")) {
0000000000000000000000000000000000000000;;			// treat it like a link
0000000000000000000000000000000000000000;;			out.WriteString("\\href{")
0000000000000000000000000000000000000000;;			out.Write(link)
0000000000000000000000000000000000000000;;			out.WriteString("}{")
0000000000000000000000000000000000000000;;			out.Write(alt)
0000000000000000000000000000000000000000;;			out.WriteString("}")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("\\includegraphics{")
0000000000000000000000000000000000000000;;			out.Write(link)
0000000000000000000000000000000000000000;;			out.WriteString("}")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) LineBreak(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		out.WriteString(" \\\\\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) Link(out *bytes.Buffer, link []byte, title []byte, content []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("\\href{")
0000000000000000000000000000000000000000;;		out.Write(link)
0000000000000000000000000000000000000000;;		out.WriteString("}{")
0000000000000000000000000000000000000000;;		out.Write(content)
0000000000000000000000000000000000000000;;		out.WriteString("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) RawHtmlTag(out *bytes.Buffer, tag []byte) {
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) TripleEmphasis(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("\\textbf{\\textit{")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("}}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) StrikeThrough(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("\\sout{")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("}")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TODO: this
0000000000000000000000000000000000000000;;	func (options *Latex) FootnoteRef(out *bytes.Buffer, ref []byte, id int) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func needsBackslash(c byte) bool {
0000000000000000000000000000000000000000;;		for _, r := range []byte("_{}%$&\\~#") {
0000000000000000000000000000000000000000;;			if c == r {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escapeSpecialChars(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		for i := 0; i < len(text); i++ {
0000000000000000000000000000000000000000;;			// directly copy normal characters
0000000000000000000000000000000000000000;;			org := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i < len(text) && !needsBackslash(text[i]) {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i > org {
0000000000000000000000000000000000000000;;				out.Write(text[org:i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// escape a character
0000000000000000000000000000000000000000;;			if i >= len(text) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.WriteByte('\\')
0000000000000000000000000000000000000000;;			out.WriteByte(text[i])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) Entity(out *bytes.Buffer, entity []byte) {
0000000000000000000000000000000000000000;;		// TODO: convert this into a unicode character or something
0000000000000000000000000000000000000000;;		out.Write(entity)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) NormalText(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		escapeSpecialChars(out, text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// header and footer
0000000000000000000000000000000000000000;;	func (options *Latex) DocumentHeader(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		out.WriteString("\\documentclass{article}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\usepackage{graphicx}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\usepackage{listings}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\usepackage[margin=1in]{geometry}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\usepackage[utf8]{inputenc}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\usepackage{verbatim}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\usepackage[normalem]{ulem}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\usepackage{hyperref}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\hypersetup{colorlinks,%\n")
0000000000000000000000000000000000000000;;		out.WriteString("  citecolor=black,%\n")
0000000000000000000000000000000000000000;;		out.WriteString("  filecolor=black,%\n")
0000000000000000000000000000000000000000;;		out.WriteString("  linkcolor=black,%\n")
0000000000000000000000000000000000000000;;		out.WriteString("  urlcolor=black,%\n")
0000000000000000000000000000000000000000;;		out.WriteString("  pdfstartview=FitH,%\n")
0000000000000000000000000000000000000000;;		out.WriteString("  breaklinks=true,%\n")
0000000000000000000000000000000000000000;;		out.WriteString("  pdfauthor={Blackfriday Markdown Processor v")
0000000000000000000000000000000000000000;;		out.WriteString(VERSION)
0000000000000000000000000000000000000000;;		out.WriteString("}}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\newcommand{\\HRule}{\\rule{\\linewidth}{0.5mm}}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\addtolength{\\parskip}{0.5\\baselineskip}\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\parindent=0pt\n")
0000000000000000000000000000000000000000;;		out.WriteString("\n")
0000000000000000000000000000000000000000;;		out.WriteString("\\begin{document}\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Latex) DocumentFooter(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		out.WriteString("\n\\end{document}\n")
0000000000000000000000000000000000000000;;	}
