0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Blackfriday Markdown Processor
0000000000000000000000000000000000000000;;	// Available at http://github.com/russross/blackfriday
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright Â© 2011 Russ Ross <russ@russross.com>.
0000000000000000000000000000000000000000;;	// Distributed under the Simplified BSD License.
0000000000000000000000000000000000000000;;	// See README.md for details.
0000000000000000000000000000000000000000;;	//
50f9755c60b2914e7a0c6daa6fbd3a38d2cab61c;Godeps/_workspace/src/github.com/russross/blackfriday/markdown.go[Godeps/_workspace/src/github.com/russross/blackfriday/markdown.go][vendor/github.com/russross/blackfriday/markdown.go];	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Markdown parsing and processing
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Blackfriday markdown processor.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Translates plain text with simple formatting rules into HTML or LaTeX.
0000000000000000000000000000000000000000;;	package blackfriday
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const VERSION = "1.4"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the supported markdown parsing extensions.
0000000000000000000000000000000000000000;;	// OR these values together to select multiple extensions.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		EXTENSION_NO_INTRA_EMPHASIS          = 1 << iota // ignore emphasis markers inside words
0000000000000000000000000000000000000000;;		EXTENSION_TABLES                                 // render tables
0000000000000000000000000000000000000000;;		EXTENSION_FENCED_CODE                            // render fenced code blocks
0000000000000000000000000000000000000000;;		EXTENSION_AUTOLINK                               // detect embedded URLs that are not explicitly marked
0000000000000000000000000000000000000000;;		EXTENSION_STRIKETHROUGH                          // strikethrough text using ~~test~~
0000000000000000000000000000000000000000;;		EXTENSION_LAX_HTML_BLOCKS                        // loosen up HTML block parsing rules
0000000000000000000000000000000000000000;;		EXTENSION_SPACE_HEADERS                          // be strict about prefix header rules
0000000000000000000000000000000000000000;;		EXTENSION_HARD_LINE_BREAK                        // translate newlines into line breaks
0000000000000000000000000000000000000000;;		EXTENSION_TAB_SIZE_EIGHT                         // expand tabs to eight spaces instead of four
0000000000000000000000000000000000000000;;		EXTENSION_FOOTNOTES                              // Pandoc-style footnotes
0000000000000000000000000000000000000000;;		EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK             // No need to insert an empty line to start a (code, quote, ordered list, unordered list) block
0000000000000000000000000000000000000000;;		EXTENSION_HEADER_IDS                             // specify header IDs  with {#id}
0000000000000000000000000000000000000000;;		EXTENSION_TITLEBLOCK                             // Titleblock ala pandoc
0000000000000000000000000000000000000000;;		EXTENSION_AUTO_HEADER_IDS                        // Create the header ID from the text
0000000000000000000000000000000000000000;;		EXTENSION_BACKSLASH_LINE_BREAK                   // translate trailing backslashes into line breaks
0000000000000000000000000000000000000000;;		EXTENSION_DEFINITION_LISTS                       // render definition lists
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commonHtmlFlags = 0 |
0000000000000000000000000000000000000000;;			HTML_USE_XHTML |
0000000000000000000000000000000000000000;;			HTML_USE_SMARTYPANTS |
0000000000000000000000000000000000000000;;			HTML_SMARTYPANTS_FRACTIONS |
0000000000000000000000000000000000000000;;			HTML_SMARTYPANTS_DASHES |
0000000000000000000000000000000000000000;;			HTML_SMARTYPANTS_LATEX_DASHES
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		commonExtensions = 0 |
0000000000000000000000000000000000000000;;			EXTENSION_NO_INTRA_EMPHASIS |
0000000000000000000000000000000000000000;;			EXTENSION_TABLES |
0000000000000000000000000000000000000000;;			EXTENSION_FENCED_CODE |
0000000000000000000000000000000000000000;;			EXTENSION_AUTOLINK |
0000000000000000000000000000000000000000;;			EXTENSION_STRIKETHROUGH |
0000000000000000000000000000000000000000;;			EXTENSION_SPACE_HEADERS |
0000000000000000000000000000000000000000;;			EXTENSION_HEADER_IDS |
0000000000000000000000000000000000000000;;			EXTENSION_BACKSLASH_LINE_BREAK |
0000000000000000000000000000000000000000;;			EXTENSION_DEFINITION_LISTS
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the possible flag values for the link renderer.
0000000000000000000000000000000000000000;;	// Only a single one of these values will be used; they are not ORed together.
0000000000000000000000000000000000000000;;	// These are mostly of interest if you are writing a new output format.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LINK_TYPE_NOT_AUTOLINK = iota
0000000000000000000000000000000000000000;;		LINK_TYPE_NORMAL
0000000000000000000000000000000000000000;;		LINK_TYPE_EMAIL
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the possible flag values for the ListItem renderer.
0000000000000000000000000000000000000000;;	// Multiple flag values may be ORed together.
0000000000000000000000000000000000000000;;	// These are mostly of interest if you are writing a new output format.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		LIST_TYPE_ORDERED = 1 << iota
0000000000000000000000000000000000000000;;		LIST_TYPE_DEFINITION
0000000000000000000000000000000000000000;;		LIST_TYPE_TERM
0000000000000000000000000000000000000000;;		LIST_ITEM_CONTAINS_BLOCK
0000000000000000000000000000000000000000;;		LIST_ITEM_BEGINNING_OF_LIST
0000000000000000000000000000000000000000;;		LIST_ITEM_END_OF_LIST
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These are the possible flag values for the table cell renderer.
0000000000000000000000000000000000000000;;	// Only a single one of these values will be used; they are not ORed together.
0000000000000000000000000000000000000000;;	// These are mostly of interest if you are writing a new output format.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TABLE_ALIGNMENT_LEFT = 1 << iota
0000000000000000000000000000000000000000;;		TABLE_ALIGNMENT_RIGHT
0000000000000000000000000000000000000000;;		TABLE_ALIGNMENT_CENTER = (TABLE_ALIGNMENT_LEFT | TABLE_ALIGNMENT_RIGHT)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The size of a tab stop.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		TAB_SIZE_DEFAULT = 4
0000000000000000000000000000000000000000;;		TAB_SIZE_EIGHT   = 8
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// blockTags is a set of tags that are recognized as HTML block tags.
0000000000000000000000000000000000000000;;	// Any of these can be included in markdown text without special escaping.
0000000000000000000000000000000000000000;;	var blockTags = map[string]struct{}{
0000000000000000000000000000000000000000;;		"blockquote": struct{}{},
0000000000000000000000000000000000000000;;		"del":        struct{}{},
0000000000000000000000000000000000000000;;		"div":        struct{}{},
0000000000000000000000000000000000000000;;		"dl":         struct{}{},
0000000000000000000000000000000000000000;;		"fieldset":   struct{}{},
0000000000000000000000000000000000000000;;		"form":       struct{}{},
0000000000000000000000000000000000000000;;		"h1":         struct{}{},
0000000000000000000000000000000000000000;;		"h2":         struct{}{},
0000000000000000000000000000000000000000;;		"h3":         struct{}{},
0000000000000000000000000000000000000000;;		"h4":         struct{}{},
0000000000000000000000000000000000000000;;		"h5":         struct{}{},
0000000000000000000000000000000000000000;;		"h6":         struct{}{},
0000000000000000000000000000000000000000;;		"iframe":     struct{}{},
0000000000000000000000000000000000000000;;		"ins":        struct{}{},
0000000000000000000000000000000000000000;;		"math":       struct{}{},
0000000000000000000000000000000000000000;;		"noscript":   struct{}{},
0000000000000000000000000000000000000000;;		"ol":         struct{}{},
0000000000000000000000000000000000000000;;		"pre":        struct{}{},
0000000000000000000000000000000000000000;;		"p":          struct{}{},
0000000000000000000000000000000000000000;;		"script":     struct{}{},
0000000000000000000000000000000000000000;;		"style":      struct{}{},
0000000000000000000000000000000000000000;;		"table":      struct{}{},
0000000000000000000000000000000000000000;;		"ul":         struct{}{},
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// HTML5
0000000000000000000000000000000000000000;;		"address":    struct{}{},
0000000000000000000000000000000000000000;;		"article":    struct{}{},
0000000000000000000000000000000000000000;;		"aside":      struct{}{},
0000000000000000000000000000000000000000;;		"canvas":     struct{}{},
0000000000000000000000000000000000000000;;		"figcaption": struct{}{},
0000000000000000000000000000000000000000;;		"figure":     struct{}{},
0000000000000000000000000000000000000000;;		"footer":     struct{}{},
0000000000000000000000000000000000000000;;		"header":     struct{}{},
0000000000000000000000000000000000000000;;		"hgroup":     struct{}{},
0000000000000000000000000000000000000000;;		"main":       struct{}{},
0000000000000000000000000000000000000000;;		"nav":        struct{}{},
0000000000000000000000000000000000000000;;		"output":     struct{}{},
0000000000000000000000000000000000000000;;		"progress":   struct{}{},
0000000000000000000000000000000000000000;;		"section":    struct{}{},
0000000000000000000000000000000000000000;;		"video":      struct{}{},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Renderer is the rendering interface.
0000000000000000000000000000000000000000;;	// This is mostly of interest if you are implementing a new rendering format.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When a byte slice is provided, it contains the (rendered) contents of the
0000000000000000000000000000000000000000;;	// element.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// When a callback is provided instead, it will write the contents of the
0000000000000000000000000000000000000000;;	// respective element directly to the output buffer and return true on success.
0000000000000000000000000000000000000000;;	// If the callback returns false, the rendering function should reset the
0000000000000000000000000000000000000000;;	// output buffer as though it had never been called.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Currently Html and Latex implementations are provided
0000000000000000000000000000000000000000;;	type Renderer interface {
0000000000000000000000000000000000000000;;		// block-level callbacks
0000000000000000000000000000000000000000;;		BlockCode(out *bytes.Buffer, text []byte, lang string)
0000000000000000000000000000000000000000;;		BlockQuote(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		BlockHtml(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		Header(out *bytes.Buffer, text func() bool, level int, id string)
0000000000000000000000000000000000000000;;		HRule(out *bytes.Buffer)
0000000000000000000000000000000000000000;;		List(out *bytes.Buffer, text func() bool, flags int)
0000000000000000000000000000000000000000;;		ListItem(out *bytes.Buffer, text []byte, flags int)
0000000000000000000000000000000000000000;;		Paragraph(out *bytes.Buffer, text func() bool)
0000000000000000000000000000000000000000;;		Table(out *bytes.Buffer, header []byte, body []byte, columnData []int)
0000000000000000000000000000000000000000;;		TableRow(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		TableHeaderCell(out *bytes.Buffer, text []byte, flags int)
0000000000000000000000000000000000000000;;		TableCell(out *bytes.Buffer, text []byte, flags int)
0000000000000000000000000000000000000000;;		Footnotes(out *bytes.Buffer, text func() bool)
0000000000000000000000000000000000000000;;		FootnoteItem(out *bytes.Buffer, name, text []byte, flags int)
0000000000000000000000000000000000000000;;		TitleBlock(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Span-level callbacks
0000000000000000000000000000000000000000;;		AutoLink(out *bytes.Buffer, link []byte, kind int)
0000000000000000000000000000000000000000;;		CodeSpan(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		DoubleEmphasis(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		Emphasis(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		Image(out *bytes.Buffer, link []byte, title []byte, alt []byte)
0000000000000000000000000000000000000000;;		LineBreak(out *bytes.Buffer)
0000000000000000000000000000000000000000;;		Link(out *bytes.Buffer, link []byte, title []byte, content []byte)
0000000000000000000000000000000000000000;;		RawHtmlTag(out *bytes.Buffer, tag []byte)
0000000000000000000000000000000000000000;;		TripleEmphasis(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		StrikeThrough(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;		FootnoteRef(out *bytes.Buffer, ref []byte, id int)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Low-level callbacks
0000000000000000000000000000000000000000;;		Entity(out *bytes.Buffer, entity []byte)
0000000000000000000000000000000000000000;;		NormalText(out *bytes.Buffer, text []byte)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Header and footer
0000000000000000000000000000000000000000;;		DocumentHeader(out *bytes.Buffer)
0000000000000000000000000000000000000000;;		DocumentFooter(out *bytes.Buffer)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GetFlags() int
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Callback functions for inline parsing. One such function is defined
0000000000000000000000000000000000000000;;	// for each character that triggers a response when parsing inline data.
0000000000000000000000000000000000000000;;	type inlineParser func(p *parser, out *bytes.Buffer, data []byte, offset int) int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parser holds runtime state used by the parser.
0000000000000000000000000000000000000000;;	// This is constructed by the Markdown function.
0000000000000000000000000000000000000000;;	type parser struct {
0000000000000000000000000000000000000000;;		r              Renderer
0000000000000000000000000000000000000000;;		refOverride    ReferenceOverrideFunc
0000000000000000000000000000000000000000;;		refs           map[string]*reference
0000000000000000000000000000000000000000;;		inlineCallback [256]inlineParser
0000000000000000000000000000000000000000;;		flags          int
0000000000000000000000000000000000000000;;		nesting        int
0000000000000000000000000000000000000000;;		maxNesting     int
0000000000000000000000000000000000000000;;		insideLink     bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Footnotes need to be ordered as well as available to quickly check for
0000000000000000000000000000000000000000;;		// presence. If a ref is also a footnote, it's stored both in refs and here
0000000000000000000000000000000000000000;;		// in notes. Slice is nil if footnotes not enabled.
0000000000000000000000000000000000000000;;		notes []*reference
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) getRef(refid string) (ref *reference, found bool) {
0000000000000000000000000000000000000000;;		if p.refOverride != nil {
0000000000000000000000000000000000000000;;			r, overridden := p.refOverride(refid)
0000000000000000000000000000000000000000;;			if overridden {
0000000000000000000000000000000000000000;;				if r == nil {
0000000000000000000000000000000000000000;;					return nil, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return &reference{
0000000000000000000000000000000000000000;;					link:     []byte(r.Link),
0000000000000000000000000000000000000000;;					title:    []byte(r.Title),
0000000000000000000000000000000000000000;;					noteId:   0,
0000000000000000000000000000000000000000;;					hasBlock: false,
0000000000000000000000000000000000000000;;					text:     []byte(r.Text)}, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// refs are case insensitive
0000000000000000000000000000000000000000;;		ref, found = p.refs[strings.ToLower(refid)]
0000000000000000000000000000000000000000;;		return ref, found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Public interface
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reference represents the details of a link.
0000000000000000000000000000000000000000;;	// See the documentation in Options for more details on use-case.
0000000000000000000000000000000000000000;;	type Reference struct {
0000000000000000000000000000000000000000;;		// Link is usually the URL the reference points to.
0000000000000000000000000000000000000000;;		Link string
0000000000000000000000000000000000000000;;		// Title is the alternate text describing the link in more detail.
0000000000000000000000000000000000000000;;		Title string
0000000000000000000000000000000000000000;;		// Text is the optional text to override the ref with if the syntax used was
0000000000000000000000000000000000000000;;		// [refid][]
0000000000000000000000000000000000000000;;		Text string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReferenceOverrideFunc is expected to be called with a reference string and
0000000000000000000000000000000000000000;;	// return either a valid Reference type that the reference string maps to or
0000000000000000000000000000000000000000;;	// nil. If overridden is false, the default reference logic will be executed.
0000000000000000000000000000000000000000;;	// See the documentation in Options for more details on use-case.
0000000000000000000000000000000000000000;;	type ReferenceOverrideFunc func(reference string) (ref *Reference, overridden bool)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Options represents configurable overrides and callbacks (in addition to the
0000000000000000000000000000000000000000;;	// extension flag set) for configuring a Markdown parse.
0000000000000000000000000000000000000000;;	type Options struct {
0000000000000000000000000000000000000000;;		// Extensions is a flag set of bit-wise ORed extension bits. See the
0000000000000000000000000000000000000000;;		// EXTENSION_* flags defined in this package.
0000000000000000000000000000000000000000;;		Extensions int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ReferenceOverride is an optional function callback that is called every
0000000000000000000000000000000000000000;;		// time a reference is resolved.
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// In Markdown, the link reference syntax can be made to resolve a link to
0000000000000000000000000000000000000000;;		// a reference instead of an inline URL, in one of the following ways:
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		//  * [link text][refid]
0000000000000000000000000000000000000000;;		//  * [refid][]
0000000000000000000000000000000000000000;;		//
0000000000000000000000000000000000000000;;		// Usually, the refid is defined at the bottom of the Markdown document. If
0000000000000000000000000000000000000000;;		// this override function is provided, the refid is passed to the override
0000000000000000000000000000000000000000;;		// function first, before consulting the defined refids at the bottom. If
0000000000000000000000000000000000000000;;		// the override function indicates an override did not occur, the refids at
0000000000000000000000000000000000000000;;		// the bottom will be used to fill in the link details.
0000000000000000000000000000000000000000;;		ReferenceOverride ReferenceOverrideFunc
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarkdownBasic is a convenience function for simple rendering.
0000000000000000000000000000000000000000;;	// It processes markdown input with no extensions enabled.
0000000000000000000000000000000000000000;;	func MarkdownBasic(input []byte) []byte {
0000000000000000000000000000000000000000;;		// set up the HTML renderer
0000000000000000000000000000000000000000;;		htmlFlags := HTML_USE_XHTML
0000000000000000000000000000000000000000;;		renderer := HtmlRenderer(htmlFlags, "", "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// set up the parser
0000000000000000000000000000000000000000;;		return MarkdownOptions(input, renderer, Options{Extensions: 0})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Call Markdown with most useful extensions enabled
0000000000000000000000000000000000000000;;	// MarkdownCommon is a convenience function for simple rendering.
0000000000000000000000000000000000000000;;	// It processes markdown input with common extensions enabled, including:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Smartypants processing with smart fractions and LaTeX dashes
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Intra-word emphasis suppression
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Tables
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Fenced code blocks
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Autolinking
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Strikethrough support
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Strict header parsing
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// * Custom Header IDs
0000000000000000000000000000000000000000;;	func MarkdownCommon(input []byte) []byte {
0000000000000000000000000000000000000000;;		// set up the HTML renderer
0000000000000000000000000000000000000000;;		renderer := HtmlRenderer(commonHtmlFlags, "", "")
0000000000000000000000000000000000000000;;		return MarkdownOptions(input, renderer, Options{
0000000000000000000000000000000000000000;;			Extensions: commonExtensions})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Markdown is the main rendering function.
0000000000000000000000000000000000000000;;	// It parses and renders a block of markdown-encoded text.
0000000000000000000000000000000000000000;;	// The supplied Renderer is used to format the output, and extensions dictates
0000000000000000000000000000000000000000;;	// which non-standard extensions are enabled.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// To use the supplied Html or LaTeX renderers, see HtmlRenderer and
0000000000000000000000000000000000000000;;	// LatexRenderer, respectively.
0000000000000000000000000000000000000000;;	func Markdown(input []byte, renderer Renderer, extensions int) []byte {
0000000000000000000000000000000000000000;;		return MarkdownOptions(input, renderer, Options{
0000000000000000000000000000000000000000;;			Extensions: extensions})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarkdownOptions is just like Markdown but takes additional options through
0000000000000000000000000000000000000000;;	// the Options struct.
0000000000000000000000000000000000000000;;	func MarkdownOptions(input []byte, renderer Renderer, opts Options) []byte {
0000000000000000000000000000000000000000;;		// no point in parsing if we can't render
0000000000000000000000000000000000000000;;		if renderer == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		extensions := opts.Extensions
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// fill in the render structure
0000000000000000000000000000000000000000;;		p := new(parser)
0000000000000000000000000000000000000000;;		p.r = renderer
0000000000000000000000000000000000000000;;		p.flags = extensions
0000000000000000000000000000000000000000;;		p.refOverride = opts.ReferenceOverride
0000000000000000000000000000000000000000;;		p.refs = make(map[string]*reference)
0000000000000000000000000000000000000000;;		p.maxNesting = 16
0000000000000000000000000000000000000000;;		p.insideLink = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// register inline parsers
0000000000000000000000000000000000000000;;		p.inlineCallback['*'] = emphasis
0000000000000000000000000000000000000000;;		p.inlineCallback['_'] = emphasis
0000000000000000000000000000000000000000;;		if extensions&EXTENSION_STRIKETHROUGH != 0 {
0000000000000000000000000000000000000000;;			p.inlineCallback['~'] = emphasis
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.inlineCallback['`'] = codeSpan
0000000000000000000000000000000000000000;;		p.inlineCallback['\n'] = lineBreak
0000000000000000000000000000000000000000;;		p.inlineCallback['['] = link
0000000000000000000000000000000000000000;;		p.inlineCallback['<'] = leftAngle
0000000000000000000000000000000000000000;;		p.inlineCallback['\\'] = escape
0000000000000000000000000000000000000000;;		p.inlineCallback['&'] = entity
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if extensions&EXTENSION_AUTOLINK != 0 {
0000000000000000000000000000000000000000;;			p.inlineCallback[':'] = autoLink
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if extensions&EXTENSION_FOOTNOTES != 0 {
0000000000000000000000000000000000000000;;			p.notes = make([]*reference, 0)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		first := firstPass(p, input)
0000000000000000000000000000000000000000;;		second := secondPass(p, first)
0000000000000000000000000000000000000000;;		return second
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// first pass:
0000000000000000000000000000000000000000;;	// - extract references
0000000000000000000000000000000000000000;;	// - expand tabs
0000000000000000000000000000000000000000;;	// - normalize newlines
0000000000000000000000000000000000000000;;	// - copy everything else
0000000000000000000000000000000000000000;;	func firstPass(p *parser, input []byte) []byte {
0000000000000000000000000000000000000000;;		var out bytes.Buffer
0000000000000000000000000000000000000000;;		tabSize := TAB_SIZE_DEFAULT
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_TAB_SIZE_EIGHT != 0 {
0000000000000000000000000000000000000000;;			tabSize = TAB_SIZE_EIGHT
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		beg, end := 0, 0
0000000000000000000000000000000000000000;;		lastFencedCodeBlockEnd := 0
0000000000000000000000000000000000000000;;		for beg < len(input) { // iterate over lines
0000000000000000000000000000000000000000;;			if end = isReference(p, input[beg:], tabSize); end > 0 {
0000000000000000000000000000000000000000;;				beg += end
0000000000000000000000000000000000000000;;			} else { // skip to the next line
0000000000000000000000000000000000000000;;				end = beg
0000000000000000000000000000000000000000;;				for end < len(input) && input[end] != '\n' && input[end] != '\r' {
0000000000000000000000000000000000000000;;					end++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if p.flags&EXTENSION_FENCED_CODE != 0 {
0000000000000000000000000000000000000000;;					// track fenced code block boundaries to suppress tab expansion
0000000000000000000000000000000000000000;;					// inside them:
0000000000000000000000000000000000000000;;					if beg >= lastFencedCodeBlockEnd {
0000000000000000000000000000000000000000;;						if i := p.fencedCode(&out, input[beg:], false); i > 0 {
0000000000000000000000000000000000000000;;							lastFencedCodeBlockEnd = beg + i
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// add the line body if present
0000000000000000000000000000000000000000;;				if end > beg {
0000000000000000000000000000000000000000;;					if end < lastFencedCodeBlockEnd { // Do not expand tabs while inside fenced code blocks.
0000000000000000000000000000000000000000;;						out.Write(input[beg:end])
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						expandTabs(&out, input[beg:end], tabSize)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				out.WriteByte('\n')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if end < len(input) && input[end] == '\r' {
0000000000000000000000000000000000000000;;					end++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if end < len(input) && input[end] == '\n' {
0000000000000000000000000000000000000000;;					end++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				beg = end
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// empty input?
0000000000000000000000000000000000000000;;		if out.Len() == 0 {
0000000000000000000000000000000000000000;;			out.WriteByte('\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return out.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// second pass: actual rendering
0000000000000000000000000000000000000000;;	func secondPass(p *parser, input []byte) []byte {
0000000000000000000000000000000000000000;;		var output bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.r.DocumentHeader(&output)
0000000000000000000000000000000000000000;;		p.block(&output, input)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_FOOTNOTES != 0 && len(p.notes) > 0 {
0000000000000000000000000000000000000000;;			p.r.Footnotes(&output, func() bool {
0000000000000000000000000000000000000000;;				flags := LIST_ITEM_BEGINNING_OF_LIST
0000000000000000000000000000000000000000;;				for i := 0; i < len(p.notes); i += 1 {
0000000000000000000000000000000000000000;;					ref := p.notes[i]
0000000000000000000000000000000000000000;;					var buf bytes.Buffer
0000000000000000000000000000000000000000;;					if ref.hasBlock {
0000000000000000000000000000000000000000;;						flags |= LIST_ITEM_CONTAINS_BLOCK
0000000000000000000000000000000000000000;;						p.block(&buf, ref.title)
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.inline(&buf, ref.title)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.r.FootnoteItem(&output, ref.link, buf.Bytes(), flags)
0000000000000000000000000000000000000000;;					flags &^= LIST_ITEM_BEGINNING_OF_LIST | LIST_ITEM_CONTAINS_BLOCK
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.r.DocumentFooter(&output)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.nesting != 0 {
0000000000000000000000000000000000000000;;			panic("Nesting level did not end at zero")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return output.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Link references
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This section implements support for references that (usually) appear
0000000000000000000000000000000000000000;;	// as footnotes in a document, and can be referenced anywhere in the document.
0000000000000000000000000000000000000000;;	// The basic format is:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    [1]: http://www.google.com/ "Google"
0000000000000000000000000000000000000000;;	//    [2]: http://www.github.com/ "Github"
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Anywhere in the document, the reference can be linked by referring to its
0000000000000000000000000000000000000000;;	// label, i.e., 1 and 2 in this example, as in:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    This library is hosted on [Github][2], a git hosting site.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Actual footnotes as specified in Pandoc and supported by some other Markdown
0000000000000000000000000000000000000000;;	// libraries such as php-markdown are also taken care of. They look like this:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    This sentence needs a bit of further explanation.[^note]
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    [^note]: This is the explanation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Footnotes should be placed at the end of the document in an ordered list.
0000000000000000000000000000000000000000;;	// Inline footnotes such as:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    Inline footnotes^[Not supported.] also exist.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// are not yet supported.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// References are parsed and stored in this struct.
0000000000000000000000000000000000000000;;	type reference struct {
0000000000000000000000000000000000000000;;		link     []byte
0000000000000000000000000000000000000000;;		title    []byte
0000000000000000000000000000000000000000;;		noteId   int // 0 if not a footnote ref
0000000000000000000000000000000000000000;;		hasBlock bool
0000000000000000000000000000000000000000;;		text     []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *reference) String() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("{link: %q, title: %q, text: %q, noteId: %d, hasBlock: %v}",
0000000000000000000000000000000000000000;;			r.link, r.title, r.text, r.noteId, r.hasBlock)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Check whether or not data starts with a reference link.
0000000000000000000000000000000000000000;;	// If so, it is parsed and stored in the list of references
0000000000000000000000000000000000000000;;	// (in the render struct).
0000000000000000000000000000000000000000;;	// Returns the number of bytes to skip to move past it,
0000000000000000000000000000000000000000;;	// or zero if the first line is not a reference.
0000000000000000000000000000000000000000;;	func isReference(p *parser, data []byte, tabSize int) int {
0000000000000000000000000000000000000000;;		// up to 3 optional leading spaces
0000000000000000000000000000000000000000;;		if len(data) < 4 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < 3 && data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		noteId := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// id part: anything but a newline between brackets
0000000000000000000000000000000000000000;;		if data[i] != '[' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_FOOTNOTES != 0 {
0000000000000000000000000000000000000000;;			if i < len(data) && data[i] == '^' {
0000000000000000000000000000000000000000;;				// we can set it to anything here because the proper noteIds will
0000000000000000000000000000000000000000;;				// be assigned later during the second pass. It just has to be != 0
0000000000000000000000000000000000000000;;				noteId = 1
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idOffset := i
0000000000000000000000000000000000000000;;		for i < len(data) && data[i] != '\n' && data[i] != '\r' && data[i] != ']' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i >= len(data) || data[i] != ']' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		idEnd := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// spacer: colon (space | tab)* newline? (space | tab)*
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		if i >= len(data) || data[i] != ':' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		for i < len(data) && (data[i] == ' ' || data[i] == '\t') {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i < len(data) && (data[i] == '\n' || data[i] == '\r') {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			if i < len(data) && data[i] == '\n' && data[i-1] == '\r' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i < len(data) && (data[i] == ' ' || data[i] == '\t') {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			linkOffset, linkEnd   int
0000000000000000000000000000000000000000;;			titleOffset, titleEnd int
0000000000000000000000000000000000000000;;			lineEnd               int
0000000000000000000000000000000000000000;;			raw                   []byte
0000000000000000000000000000000000000000;;			hasBlock              bool
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_FOOTNOTES != 0 && noteId != 0 {
0000000000000000000000000000000000000000;;			linkOffset, linkEnd, raw, hasBlock = scanFootnote(p, data, i, tabSize)
0000000000000000000000000000000000000000;;			lineEnd = linkEnd
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			linkOffset, linkEnd, titleOffset, titleEnd, lineEnd = scanLinkRef(p, data, i)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if lineEnd == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a valid ref has been found
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ref := &reference{
0000000000000000000000000000000000000000;;			noteId:   noteId,
0000000000000000000000000000000000000000;;			hasBlock: hasBlock,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if noteId > 0 {
0000000000000000000000000000000000000000;;			// reusing the link field for the id since footnotes don't have links
0000000000000000000000000000000000000000;;			ref.link = data[idOffset:idEnd]
0000000000000000000000000000000000000000;;			// if footnote, it's not really a title, it's the contained text
0000000000000000000000000000000000000000;;			ref.title = raw
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			ref.link = data[linkOffset:linkEnd]
0000000000000000000000000000000000000000;;			ref.title = data[titleOffset:titleEnd]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// id matches are case-insensitive
0000000000000000000000000000000000000000;;		id := string(bytes.ToLower(data[idOffset:idEnd]))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.refs[id] = ref
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return lineEnd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func scanLinkRef(p *parser, data []byte, i int) (linkOffset, linkEnd, titleOffset, titleEnd, lineEnd int) {
0000000000000000000000000000000000000000;;		// link: whitespace-free sequence, optionally between angle brackets
0000000000000000000000000000000000000000;;		if data[i] == '<' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		linkOffset = i
0000000000000000000000000000000000000000;;		for i < len(data) && data[i] != ' ' && data[i] != '\t' && data[i] != '\n' && data[i] != '\r' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i == len(data) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		linkEnd = i
0000000000000000000000000000000000000000;;		if data[linkOffset] == '<' && data[linkEnd-1] == '>' {
0000000000000000000000000000000000000000;;			linkOffset++
0000000000000000000000000000000000000000;;			linkEnd--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// optional spacer: (space | tab)* (newline | '\'' | '"' | '(' )
0000000000000000000000000000000000000000;;		for i < len(data) && (data[i] == ' ' || data[i] == '\t') {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i < len(data) && data[i] != '\n' && data[i] != '\r' && data[i] != '\'' && data[i] != '"' && data[i] != '(' {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// compute end-of-line
0000000000000000000000000000000000000000;;		if i >= len(data) || data[i] == '\r' || data[i] == '\n' {
0000000000000000000000000000000000000000;;			lineEnd = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i+1 < len(data) && data[i] == '\r' && data[i+1] == '\n' {
0000000000000000000000000000000000000000;;			lineEnd++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// optional (space|tab)* spacer after a newline
0000000000000000000000000000000000000000;;		if lineEnd > 0 {
0000000000000000000000000000000000000000;;			i = lineEnd + 1
0000000000000000000000000000000000000000;;			for i < len(data) && (data[i] == ' ' || data[i] == '\t') {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// optional title: any non-newline sequence enclosed in '"() alone on its line
0000000000000000000000000000000000000000;;		if i+1 < len(data) && (data[i] == '\'' || data[i] == '"' || data[i] == '(') {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			titleOffset = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// look for EOL
0000000000000000000000000000000000000000;;			for i < len(data) && data[i] != '\n' && data[i] != '\r' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i+1 < len(data) && data[i] == '\n' && data[i+1] == '\r' {
0000000000000000000000000000000000000000;;				titleEnd = i + 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				titleEnd = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// step back
0000000000000000000000000000000000000000;;			i--
0000000000000000000000000000000000000000;;			for i > titleOffset && (data[i] == ' ' || data[i] == '\t') {
0000000000000000000000000000000000000000;;				i--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i > titleOffset && (data[i] == '\'' || data[i] == '"' || data[i] == ')') {
0000000000000000000000000000000000000000;;				lineEnd = titleEnd
0000000000000000000000000000000000000000;;				titleEnd = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// The first bit of this logic is the same as (*parser).listItem, but the rest
0000000000000000000000000000000000000000;;	// is much simpler. This function simply finds the entire block and shifts it
0000000000000000000000000000000000000000;;	// over by one tab if it is indeed a block (just returns the line if it's not).
0000000000000000000000000000000000000000;;	// blockEnd is the end of the section in the input buffer, and contents is the
0000000000000000000000000000000000000000;;	// extracted text that was shifted over one tab. It will need to be rendered at
0000000000000000000000000000000000000000;;	// the end of the document.
0000000000000000000000000000000000000000;;	func scanFootnote(p *parser, data []byte, i, indentSize int) (blockStart, blockEnd int, contents []byte, hasBlock bool) {
0000000000000000000000000000000000000000;;		if i == 0 || len(data) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip leading whitespace on first line
0000000000000000000000000000000000000000;;		for i < len(data) && data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		blockStart = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the end of the line
0000000000000000000000000000000000000000;;		blockEnd = i
0000000000000000000000000000000000000000;;		for i < len(data) && data[i-1] != '\n' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get working buffer
0000000000000000000000000000000000000000;;		var raw bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// put the first line into the working buffer
0000000000000000000000000000000000000000;;		raw.Write(data[blockEnd:i])
0000000000000000000000000000000000000000;;		blockEnd = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// process the following lines
0000000000000000000000000000000000000000;;		containsBlankLine := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	gatherLines:
0000000000000000000000000000000000000000;;		for blockEnd < len(data) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// find the end of this line
0000000000000000000000000000000000000000;;			for i < len(data) && data[i-1] != '\n' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if it is an empty line, guess that it is part of this item
0000000000000000000000000000000000000000;;			// and move on to the next line
0000000000000000000000000000000000000000;;			if p.isEmpty(data[blockEnd:i]) > 0 {
0000000000000000000000000000000000000000;;				containsBlankLine = true
0000000000000000000000000000000000000000;;				blockEnd = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			n := 0
0000000000000000000000000000000000000000;;			if n = isIndented(data[blockEnd:i], indentSize); n == 0 {
0000000000000000000000000000000000000000;;				// this is the end of the block.
0000000000000000000000000000000000000000;;				// we don't want to include this last line in the index.
0000000000000000000000000000000000000000;;				break gatherLines
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if there were blank lines before this one, insert a new one now
0000000000000000000000000000000000000000;;			if containsBlankLine {
0000000000000000000000000000000000000000;;				raw.WriteByte('\n')
0000000000000000000000000000000000000000;;				containsBlankLine = false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// get rid of that first tab, write to buffer
0000000000000000000000000000000000000000;;			raw.Write(data[blockEnd+n : i])
0000000000000000000000000000000000000000;;			hasBlock = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			blockEnd = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if data[blockEnd-1] != '\n' {
0000000000000000000000000000000000000000;;			raw.WriteByte('\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		contents = raw.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Miscellaneous helper functions
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if a character is a punctuation symbol.
0000000000000000000000000000000000000000;;	// Taken from a private function in regexp in the stdlib.
0000000000000000000000000000000000000000;;	func ispunct(c byte) bool {
0000000000000000000000000000000000000000;;		for _, r := range []byte("!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~") {
0000000000000000000000000000000000000000;;			if c == r {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if a character is a whitespace character.
0000000000000000000000000000000000000000;;	func isspace(c byte) bool {
0000000000000000000000000000000000000000;;		return c == ' ' || c == '\t' || c == '\n' || c == '\r' || c == '\f' || c == '\v'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if a character is letter.
0000000000000000000000000000000000000000;;	func isletter(c byte) bool {
0000000000000000000000000000000000000000;;		return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Test if a character is a letter or a digit.
0000000000000000000000000000000000000000;;	// TODO: check when this is looking for ASCII alnum and when it should use unicode
0000000000000000000000000000000000000000;;	func isalnum(c byte) bool {
0000000000000000000000000000000000000000;;		return (c >= '0' && c <= '9') || isletter(c)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Replace tab characters with spaces, aligning to the next TAB_SIZE column.
0000000000000000000000000000000000000000;;	// always ends output with a newline
0000000000000000000000000000000000000000;;	func expandTabs(out *bytes.Buffer, line []byte, tabSize int) {
0000000000000000000000000000000000000000;;		// first, check for common cases: no tabs, or only tabs at beginning of line
0000000000000000000000000000000000000000;;		i, prefix := 0, 0
0000000000000000000000000000000000000000;;		slowcase := false
0000000000000000000000000000000000000000;;		for i = 0; i < len(line); i++ {
0000000000000000000000000000000000000000;;			if line[i] == '\t' {
0000000000000000000000000000000000000000;;				if prefix == i {
0000000000000000000000000000000000000000;;					prefix++
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					slowcase = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no need to decode runes if all tabs are at the beginning of the line
0000000000000000000000000000000000000000;;		if !slowcase {
0000000000000000000000000000000000000000;;			for i = 0; i < prefix*tabSize; i++ {
0000000000000000000000000000000000000000;;				out.WriteByte(' ')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out.Write(line[prefix:])
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the slow case: we need to count runes to figure out how
0000000000000000000000000000000000000000;;		// many spaces to insert for each tab
0000000000000000000000000000000000000000;;		column := 0
0000000000000000000000000000000000000000;;		i = 0
0000000000000000000000000000000000000000;;		for i < len(line) {
0000000000000000000000000000000000000000;;			start := i
0000000000000000000000000000000000000000;;			for i < len(line) && line[i] != '\t' {
0000000000000000000000000000000000000000;;				_, size := utf8.DecodeRune(line[i:])
0000000000000000000000000000000000000000;;				i += size
0000000000000000000000000000000000000000;;				column++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i > start {
0000000000000000000000000000000000000000;;				out.Write(line[start:i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i >= len(line) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for {
0000000000000000000000000000000000000000;;				out.WriteByte(' ')
0000000000000000000000000000000000000000;;				column++
0000000000000000000000000000000000000000;;				if column%tabSize == 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Find if a line counts as indented or not.
0000000000000000000000000000000000000000;;	// Returns number of characters the indent is (0 = not indented).
0000000000000000000000000000000000000000;;	func isIndented(data []byte, indentSize int) int {
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if data[0] == '\t' {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(data) < indentSize {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := 0; i < indentSize; i++ {
0000000000000000000000000000000000000000;;			if data[i] != ' ' {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return indentSize
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create a url-safe slug for fragments
0000000000000000000000000000000000000000;;	func slugify(in []byte) []byte {
0000000000000000000000000000000000000000;;		if len(in) == 0 {
0000000000000000000000000000000000000000;;			return in
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out := make([]byte, 0, len(in))
0000000000000000000000000000000000000000;;		sym := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, ch := range in {
0000000000000000000000000000000000000000;;			if isalnum(ch) {
0000000000000000000000000000000000000000;;				sym = false
0000000000000000000000000000000000000000;;				out = append(out, ch)
0000000000000000000000000000000000000000;;			} else if sym {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out = append(out, '-')
0000000000000000000000000000000000000000;;				sym = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var a, b int
0000000000000000000000000000000000000000;;		var ch byte
0000000000000000000000000000000000000000;;		for a, ch = range out {
0000000000000000000000000000000000000000;;			if ch != '-' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for b = len(out) - 1; b > 0; b-- {
0000000000000000000000000000000000000000;;			if out[b] != '-' {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return out[a : b+1]
0000000000000000000000000000000000000000;;	}
