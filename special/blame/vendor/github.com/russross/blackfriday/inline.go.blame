0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Blackfriday Markdown Processor
0000000000000000000000000000000000000000;;	// Available at http://github.com/russross/blackfriday
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright Â© 2011 Russ Ross <russ@russross.com>.
0000000000000000000000000000000000000000;;	// Distributed under the Simplified BSD License.
0000000000000000000000000000000000000000;;	// See README.md for details.
0000000000000000000000000000000000000000;;	//
50f9755c60b2914e7a0c6daa6fbd3a38d2cab61c;Godeps/_workspace/src/github.com/russross/blackfriday/inline.go[Godeps/_workspace/src/github.com/russross/blackfriday/inline.go][vendor/github.com/russross/blackfriday/inline.go];	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Functions to parse inline elements.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package blackfriday
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		urlRe    = `((https?|ftp):\/\/|\/)[-A-Za-z0-9+&@#\/%?=~_|!:,.;\(\)]+`
0000000000000000000000000000000000000000;;		anchorRe = regexp.MustCompile(`^(<a\shref="` + urlRe + `"(\stitle="[^"<>]+")?\s?>` + urlRe + `<\/a>)`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Functions to parse text within a block
0000000000000000000000000000000000000000;;	// Each function returns the number of chars taken care of
0000000000000000000000000000000000000000;;	// data is the complete block being rendered
0000000000000000000000000000000000000000;;	// offset is the number of valid chars before the current cursor
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) inline(out *bytes.Buffer, data []byte) {
0000000000000000000000000000000000000000;;		// this is called recursively: enforce a maximum depth
0000000000000000000000000000000000000000;;		if p.nesting >= p.maxNesting {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.nesting++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i, end := 0, 0
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			// copy inactive chars into the output
0000000000000000000000000000000000000000;;			for end < len(data) && p.inlineCallback[data[end]] == nil {
0000000000000000000000000000000000000000;;				end++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.r.NormalText(out, data[i:end])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if end >= len(data) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i = end
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// call the trigger
0000000000000000000000000000000000000000;;			handler := p.inlineCallback[data[end]]
0000000000000000000000000000000000000000;;			if consumed := handler(p, out, data, i); consumed == 0 {
0000000000000000000000000000000000000000;;				// no action from the callback; buffer the byte for later
0000000000000000000000000000000000000000;;				end = i + 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// skip past whatever the callback used
0000000000000000000000000000000000000000;;				i += consumed
0000000000000000000000000000000000000000;;				end = i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.nesting--
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// single and double emphasis parsing
0000000000000000000000000000000000000000;;	func emphasis(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		data = data[offset:]
0000000000000000000000000000000000000000;;		c := data[0]
0000000000000000000000000000000000000000;;		ret := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) > 2 && data[1] != c {
0000000000000000000000000000000000000000;;			// whitespace cannot follow an opening emphasis;
0000000000000000000000000000000000000000;;			// strikethrough only takes two characters '~~'
0000000000000000000000000000000000000000;;			if c == '~' || isspace(data[1]) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ret = helperEmphasis(p, out, data[1:], c); ret == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ret + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) > 3 && data[1] == c && data[2] != c {
0000000000000000000000000000000000000000;;			if isspace(data[2]) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ret = helperDoubleEmphasis(p, out, data[2:], c); ret == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ret + 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) > 4 && data[1] == c && data[2] == c && data[3] != c {
0000000000000000000000000000000000000000;;			if c == '~' || isspace(data[3]) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if ret = helperTripleEmphasis(p, out, data, 3, c); ret == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return ret + 3
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func codeSpan(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		data = data[offset:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nb := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// count the number of backticks in the delimiter
0000000000000000000000000000000000000000;;		for nb < len(data) && data[nb] == '`' {
0000000000000000000000000000000000000000;;			nb++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the next delimiter
0000000000000000000000000000000000000000;;		i, end := 0, 0
0000000000000000000000000000000000000000;;		for end = nb; end < len(data) && i < nb; end++ {
0000000000000000000000000000000000000000;;			if data[end] == '`' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				i = 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// no matching delimiter?
0000000000000000000000000000000000000000;;		if i < nb && end >= len(data) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// trim outside whitespace
0000000000000000000000000000000000000000;;		fBegin := nb
0000000000000000000000000000000000000000;;		for fBegin < end && data[fBegin] == ' ' {
0000000000000000000000000000000000000000;;			fBegin++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fEnd := end - nb
0000000000000000000000000000000000000000;;		for fEnd > fBegin && data[fEnd-1] == ' ' {
0000000000000000000000000000000000000000;;			fEnd--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// render the code span
0000000000000000000000000000000000000000;;		if fBegin != fEnd {
0000000000000000000000000000000000000000;;			p.r.CodeSpan(out, data[fBegin:fEnd])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// newline preceded by two spaces becomes <br>
0000000000000000000000000000000000000000;;	// newline without two spaces works when EXTENSION_HARD_LINE_BREAK is enabled
0000000000000000000000000000000000000000;;	func lineBreak(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		// remove trailing spaces from out
0000000000000000000000000000000000000000;;		outBytes := out.Bytes()
0000000000000000000000000000000000000000;;		end := len(outBytes)
0000000000000000000000000000000000000000;;		eol := end
0000000000000000000000000000000000000000;;		for eol > 0 && outBytes[eol-1] == ' ' {
0000000000000000000000000000000000000000;;			eol--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Truncate(eol)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		precededByTwoSpaces := offset >= 2 && data[offset-2] == ' ' && data[offset-1] == ' '
0000000000000000000000000000000000000000;;		precededByBackslash := offset >= 1 && data[offset-1] == '\\' // see http://spec.commonmark.org/0.18/#example-527
0000000000000000000000000000000000000000;;		precededByBackslash = precededByBackslash && p.flags&EXTENSION_BACKSLASH_LINE_BREAK != 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// should there be a hard line break here?
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_HARD_LINE_BREAK == 0 && !precededByTwoSpaces && !precededByBackslash {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if precededByBackslash && eol > 0 {
0000000000000000000000000000000000000000;;			out.Truncate(eol - 1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.r.LineBreak(out)
0000000000000000000000000000000000000000;;		return 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type linkType int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		linkNormal linkType = iota
0000000000000000000000000000000000000000;;		linkImg
0000000000000000000000000000000000000000;;		linkDeferredFootnote
0000000000000000000000000000000000000000;;		linkInlineFootnote
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isReferenceStyleLink(data []byte, pos int, t linkType) bool {
0000000000000000000000000000000000000000;;		if t == linkDeferredFootnote {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pos < len(data)-1 && data[pos] == '[' && data[pos+1] != '^'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// '[': parse a link or an image or a footnote
0000000000000000000000000000000000000000;;	func link(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		// no links allowed inside regular links, footnote, and deferred footnotes
0000000000000000000000000000000000000000;;		if p.insideLink && (offset > 0 && data[offset-1] == '[' || len(data)-1 > offset && data[offset+1] == '^') {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var t linkType
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		// special case: ![^text] == deferred footnote (that follows something with
0000000000000000000000000000000000000000;;		// an exclamation point)
0000000000000000000000000000000000000000;;		case p.flags&EXTENSION_FOOTNOTES != 0 && len(data)-1 > offset && data[offset+1] == '^':
0000000000000000000000000000000000000000;;			t = linkDeferredFootnote
0000000000000000000000000000000000000000;;		// ![alt] == image
0000000000000000000000000000000000000000;;		case offset > 0 && data[offset-1] == '!':
0000000000000000000000000000000000000000;;			t = linkImg
0000000000000000000000000000000000000000;;		// ^[text] == inline footnote
0000000000000000000000000000000000000000;;		// [^refId] == deferred footnote
0000000000000000000000000000000000000000;;		case p.flags&EXTENSION_FOOTNOTES != 0:
0000000000000000000000000000000000000000;;			if offset > 0 && data[offset-1] == '^' {
0000000000000000000000000000000000000000;;				t = linkInlineFootnote
0000000000000000000000000000000000000000;;			} else if len(data)-1 > offset && data[offset+1] == '^' {
0000000000000000000000000000000000000000;;				t = linkDeferredFootnote
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		// [text] == regular link
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			t = linkNormal
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data = data[offset:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			i                       = 1
0000000000000000000000000000000000000000;;			noteId                  int
0000000000000000000000000000000000000000;;			title, link, altContent []byte
0000000000000000000000000000000000000000;;			textHasNl               = false
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t == linkDeferredFootnote {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// look for the matching closing bracket
0000000000000000000000000000000000000000;;		for level := 1; level > 0 && i < len(data); i++ {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case data[i] == '\n':
0000000000000000000000000000000000000000;;				textHasNl = true
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case data[i-1] == '\\':
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case data[i] == '[':
0000000000000000000000000000000000000000;;				level++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case data[i] == ']':
0000000000000000000000000000000000000000;;				level--
0000000000000000000000000000000000000000;;				if level <= 0 {
0000000000000000000000000000000000000000;;					i-- // compensate for extra i++ in for loop
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		txtE := i
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip any amount of whitespace or newline
0000000000000000000000000000000000000000;;		// (this is much more lax than original markdown syntax)
0000000000000000000000000000000000000000;;		for i < len(data) && isspace(data[i]) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// inline style link
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case i < len(data) && data[i] == '(':
0000000000000000000000000000000000000000;;			// skip initial whitespace
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i < len(data) && isspace(data[i]) {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			linkB := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// look for link end: ' " )
0000000000000000000000000000000000000000;;		findlinkend:
0000000000000000000000000000000000000000;;			for i < len(data) {
0000000000000000000000000000000000000000;;				switch {
0000000000000000000000000000000000000000;;				case data[i] == '\\':
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				case data[i] == ')' || data[i] == '\'' || data[i] == '"':
0000000000000000000000000000000000000000;;					break findlinkend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				default:
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i >= len(data) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			linkE := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// look for title end if present
0000000000000000000000000000000000000000;;			titleB, titleE := 0, 0
0000000000000000000000000000000000000000;;			if data[i] == '\'' || data[i] == '"' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				titleB = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			findtitleend:
0000000000000000000000000000000000000000;;				for i < len(data) {
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case data[i] == '\\':
0000000000000000000000000000000000000000;;						i += 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					case data[i] == ')':
0000000000000000000000000000000000000000;;						break findtitleend
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					default:
0000000000000000000000000000000000000000;;						i++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if i >= len(data) {
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// skip whitespace after title
0000000000000000000000000000000000000000;;				titleE = i - 1
0000000000000000000000000000000000000000;;				for titleE > titleB && isspace(data[titleE]) {
0000000000000000000000000000000000000000;;					titleE--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// check for closing quote presence
0000000000000000000000000000000000000000;;				if data[titleE] != '\'' && data[titleE] != '"' {
0000000000000000000000000000000000000000;;					titleB, titleE = 0, 0
0000000000000000000000000000000000000000;;					linkE = i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// remove whitespace at the end of the link
0000000000000000000000000000000000000000;;			for linkE > linkB && isspace(data[linkE-1]) {
0000000000000000000000000000000000000000;;				linkE--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// remove optional angle brackets around the link
0000000000000000000000000000000000000000;;			if data[linkB] == '<' {
0000000000000000000000000000000000000000;;				linkB++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if data[linkE-1] == '>' {
0000000000000000000000000000000000000000;;				linkE--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// build escaped link and title
0000000000000000000000000000000000000000;;			if linkE > linkB {
0000000000000000000000000000000000000000;;				link = data[linkB:linkE]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if titleE > titleB {
0000000000000000000000000000000000000000;;				title = data[titleB:titleE]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// reference style link
0000000000000000000000000000000000000000;;		case isReferenceStyleLink(data, i, t):
0000000000000000000000000000000000000000;;			var id []byte
0000000000000000000000000000000000000000;;			altContentConsidered := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// look for the id
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			linkB := i
0000000000000000000000000000000000000000;;			for i < len(data) && data[i] != ']' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i >= len(data) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			linkE := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// find the reference
0000000000000000000000000000000000000000;;			if linkB == linkE {
0000000000000000000000000000000000000000;;				if textHasNl {
0000000000000000000000000000000000000000;;					var b bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					for j := 1; j < txtE; j++ {
0000000000000000000000000000000000000000;;						switch {
0000000000000000000000000000000000000000;;						case data[j] != '\n':
0000000000000000000000000000000000000000;;							b.WriteByte(data[j])
0000000000000000000000000000000000000000;;						case data[j-1] != ' ':
0000000000000000000000000000000000000000;;							b.WriteByte(' ')
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					id = b.Bytes()
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					id = data[1:txtE]
0000000000000000000000000000000000000000;;					altContentConsidered = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				id = data[linkB:linkE]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// find the reference with matching id
0000000000000000000000000000000000000000;;			lr, ok := p.getRef(string(id))
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// keep link and title from reference
0000000000000000000000000000000000000000;;			link = lr.link
0000000000000000000000000000000000000000;;			title = lr.title
0000000000000000000000000000000000000000;;			if altContentConsidered {
0000000000000000000000000000000000000000;;				altContent = lr.text
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// shortcut reference style link or reference or inline footnote
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			var id []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// craft the id
0000000000000000000000000000000000000000;;			if textHasNl {
0000000000000000000000000000000000000000;;				var b bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for j := 1; j < txtE; j++ {
0000000000000000000000000000000000000000;;					switch {
0000000000000000000000000000000000000000;;					case data[j] != '\n':
0000000000000000000000000000000000000000;;						b.WriteByte(data[j])
0000000000000000000000000000000000000000;;					case data[j-1] != ' ':
0000000000000000000000000000000000000000;;						b.WriteByte(' ')
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				id = b.Bytes()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if t == linkDeferredFootnote {
0000000000000000000000000000000000000000;;					id = data[2:txtE] // get rid of the ^
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					id = data[1:txtE]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if t == linkInlineFootnote {
0000000000000000000000000000000000000000;;				// create a new reference
0000000000000000000000000000000000000000;;				noteId = len(p.notes) + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var fragment []byte
0000000000000000000000000000000000000000;;				if len(id) > 0 {
0000000000000000000000000000000000000000;;					if len(id) < 16 {
0000000000000000000000000000000000000000;;						fragment = make([]byte, len(id))
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						fragment = make([]byte, 16)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					copy(fragment, slugify(id))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					fragment = append([]byte("footnote-"), []byte(strconv.Itoa(noteId))...)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ref := &reference{
0000000000000000000000000000000000000000;;					noteId:   noteId,
0000000000000000000000000000000000000000;;					hasBlock: false,
0000000000000000000000000000000000000000;;					link:     fragment,
0000000000000000000000000000000000000000;;					title:    id,
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p.notes = append(p.notes, ref)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				link = ref.link
0000000000000000000000000000000000000000;;				title = ref.title
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// find the reference with matching id
0000000000000000000000000000000000000000;;				lr, ok := p.getRef(string(id))
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if t == linkDeferredFootnote {
0000000000000000000000000000000000000000;;					lr.noteId = len(p.notes) + 1
0000000000000000000000000000000000000000;;					p.notes = append(p.notes, lr)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// keep link and title from reference
0000000000000000000000000000000000000000;;				link = lr.link
0000000000000000000000000000000000000000;;				// if inline footnote, title == footnote contents
0000000000000000000000000000000000000000;;				title = lr.title
0000000000000000000000000000000000000000;;				noteId = lr.noteId
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// rewind the whitespace
0000000000000000000000000000000000000000;;			i = txtE + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// build content: img alt is escaped, link content is parsed
0000000000000000000000000000000000000000;;		var content bytes.Buffer
0000000000000000000000000000000000000000;;		if txtE > 1 {
0000000000000000000000000000000000000000;;			if t == linkImg {
0000000000000000000000000000000000000000;;				content.Write(data[1:txtE])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// links cannot contain other links, so turn off link parsing temporarily
0000000000000000000000000000000000000000;;				insideLink := p.insideLink
0000000000000000000000000000000000000000;;				p.insideLink = true
0000000000000000000000000000000000000000;;				p.inline(&content, data[1:txtE])
0000000000000000000000000000000000000000;;				p.insideLink = insideLink
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var uLink []byte
0000000000000000000000000000000000000000;;		if t == linkNormal || t == linkImg {
0000000000000000000000000000000000000000;;			if len(link) > 0 {
0000000000000000000000000000000000000000;;				var uLinkBuf bytes.Buffer
0000000000000000000000000000000000000000;;				unescapeText(&uLinkBuf, link)
0000000000000000000000000000000000000000;;				uLink = uLinkBuf.Bytes()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// links need something to click on and somewhere to go
0000000000000000000000000000000000000000;;			if len(uLink) == 0 || (t == linkNormal && content.Len() == 0) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// call the relevant rendering function
0000000000000000000000000000000000000000;;		switch t {
0000000000000000000000000000000000000000;;		case linkNormal:
0000000000000000000000000000000000000000;;			if len(altContent) > 0 {
0000000000000000000000000000000000000000;;				p.r.Link(out, uLink, title, altContent)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.r.Link(out, uLink, title, content.Bytes())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case linkImg:
0000000000000000000000000000000000000000;;			outSize := out.Len()
0000000000000000000000000000000000000000;;			outBytes := out.Bytes()
0000000000000000000000000000000000000000;;			if outSize > 0 && outBytes[outSize-1] == '!' {
0000000000000000000000000000000000000000;;				out.Truncate(outSize - 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.r.Image(out, uLink, title, content.Bytes())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case linkInlineFootnote:
0000000000000000000000000000000000000000;;			outSize := out.Len()
0000000000000000000000000000000000000000;;			outBytes := out.Bytes()
0000000000000000000000000000000000000000;;			if outSize > 0 && outBytes[outSize-1] == '^' {
0000000000000000000000000000000000000000;;				out.Truncate(outSize - 1)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.r.FootnoteRef(out, link, noteId)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case linkDeferredFootnote:
0000000000000000000000000000000000000000;;			p.r.FootnoteRef(out, link, noteId)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) inlineHtmlComment(out *bytes.Buffer, data []byte) int {
0000000000000000000000000000000000000000;;		if len(data) < 5 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if data[0] != '<' || data[1] != '!' || data[2] != '-' || data[3] != '-' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := 5
0000000000000000000000000000000000000000;;		// scan for an end-of-comment marker, across lines if necessary
0000000000000000000000000000000000000000;;		for i < len(data) && !(data[i-2] == '-' && data[i-1] == '-' && data[i] == '>') {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// no end-of-comment marker
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// '<' when tags or autolinks are allowed
0000000000000000000000000000000000000000;;	func leftAngle(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		data = data[offset:]
0000000000000000000000000000000000000000;;		altype := LINK_TYPE_NOT_AUTOLINK
0000000000000000000000000000000000000000;;		end := tagLength(data, &altype)
0000000000000000000000000000000000000000;;		if size := p.inlineHtmlComment(out, data); size > 0 {
0000000000000000000000000000000000000000;;			end = size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end > 2 {
0000000000000000000000000000000000000000;;			if altype != LINK_TYPE_NOT_AUTOLINK {
0000000000000000000000000000000000000000;;				var uLink bytes.Buffer
0000000000000000000000000000000000000000;;				unescapeText(&uLink, data[1:end+1-2])
0000000000000000000000000000000000000000;;				if uLink.Len() > 0 {
0000000000000000000000000000000000000000;;					p.r.AutoLink(out, uLink.Bytes(), altype)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.r.RawHtmlTag(out, data[:end])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// '\\' backslash escape
0000000000000000000000000000000000000000;;	var escapeChars = []byte("\\`*_{}[]()#+-.!:|&<>~")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func escape(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		data = data[offset:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(data) > 1 {
0000000000000000000000000000000000000000;;			if bytes.IndexByte(escapeChars, data[1]) < 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			p.r.NormalText(out, data[1:2])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func unescapeText(ob *bytes.Buffer, src []byte) {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < len(src) {
0000000000000000000000000000000000000000;;			org := i
0000000000000000000000000000000000000000;;			for i < len(src) && src[i] != '\\' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i > org {
0000000000000000000000000000000000000000;;				ob.Write(src[org:i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i+1 >= len(src) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ob.WriteByte(src[i+1])
0000000000000000000000000000000000000000;;			i += 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// '&' escaped when it doesn't belong to an entity
0000000000000000000000000000000000000000;;	// valid entities are assumed to be anything matching &#?[A-Za-z0-9]+;
0000000000000000000000000000000000000000;;	func entity(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		data = data[offset:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		end := 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if end < len(data) && data[end] == '#' {
0000000000000000000000000000000000000000;;			end++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for end < len(data) && isalnum(data[end]) {
0000000000000000000000000000000000000000;;			end++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if end < len(data) && data[end] == ';' {
0000000000000000000000000000000000000000;;			end++ // real entity
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			return 0 // lone '&'
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.r.Entity(out, data[:end])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func linkEndsWithEntity(data []byte, linkEnd int) bool {
0000000000000000000000000000000000000000;;		entityRanges := htmlEntity.FindAllIndex(data[:linkEnd], -1)
0000000000000000000000000000000000000000;;		return entityRanges != nil && entityRanges[len(entityRanges)-1][1] == linkEnd
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func autoLink(p *parser, out *bytes.Buffer, data []byte, offset int) int {
0000000000000000000000000000000000000000;;		// quick check to rule out most false hits on ':'
0000000000000000000000000000000000000000;;		if p.insideLink || len(data) < offset+3 || data[offset+1] != '/' || data[offset+2] != '/' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Now a more expensive check to see if we're not inside an anchor element
0000000000000000000000000000000000000000;;		anchorStart := offset
0000000000000000000000000000000000000000;;		offsetFromAnchor := 0
0000000000000000000000000000000000000000;;		for anchorStart > 0 && data[anchorStart] != '<' {
0000000000000000000000000000000000000000;;			anchorStart--
0000000000000000000000000000000000000000;;			offsetFromAnchor++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		anchorStr := anchorRe.Find(data[anchorStart:])
0000000000000000000000000000000000000000;;		if anchorStr != nil {
0000000000000000000000000000000000000000;;			out.Write(anchorStr[offsetFromAnchor:])
0000000000000000000000000000000000000000;;			return len(anchorStr) - offsetFromAnchor
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scan backward for a word boundary
0000000000000000000000000000000000000000;;		rewind := 0
0000000000000000000000000000000000000000;;		for offset-rewind > 0 && rewind <= 7 && isletter(data[offset-rewind-1]) {
0000000000000000000000000000000000000000;;			rewind++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if rewind > 6 { // longest supported protocol is "mailto" which has 6 letters
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		origData := data
0000000000000000000000000000000000000000;;		data = data[offset-rewind:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !isSafeLink(data) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		linkEnd := 0
0000000000000000000000000000000000000000;;		for linkEnd < len(data) && !isEndOfLink(data[linkEnd]) {
0000000000000000000000000000000000000000;;			linkEnd++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Skip punctuation at the end of the link
0000000000000000000000000000000000000000;;		if (data[linkEnd-1] == '.' || data[linkEnd-1] == ',') && data[linkEnd-2] != '\\' {
0000000000000000000000000000000000000000;;			linkEnd--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// But don't skip semicolon if it's a part of escaped entity:
0000000000000000000000000000000000000000;;		if data[linkEnd-1] == ';' && data[linkEnd-2] != '\\' && !linkEndsWithEntity(data, linkEnd) {
0000000000000000000000000000000000000000;;			linkEnd--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// See if the link finishes with a punctuation sign that can be closed.
0000000000000000000000000000000000000000;;		var copen byte
0000000000000000000000000000000000000000;;		switch data[linkEnd-1] {
0000000000000000000000000000000000000000;;		case '"':
0000000000000000000000000000000000000000;;			copen = '"'
0000000000000000000000000000000000000000;;		case '\'':
0000000000000000000000000000000000000000;;			copen = '\''
0000000000000000000000000000000000000000;;		case ')':
0000000000000000000000000000000000000000;;			copen = '('
0000000000000000000000000000000000000000;;		case ']':
0000000000000000000000000000000000000000;;			copen = '['
0000000000000000000000000000000000000000;;		case '}':
0000000000000000000000000000000000000000;;			copen = '{'
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			copen = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if copen != 0 {
0000000000000000000000000000000000000000;;			bufEnd := offset - rewind + linkEnd - 2
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			openDelim := 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			/* Try to close the final punctuation sign in this same line;
0000000000000000000000000000000000000000;;			 * if we managed to close it outside of the URL, that means that it's
0000000000000000000000000000000000000000;;			 * not part of the URL. If it closes inside the URL, that means it
0000000000000000000000000000000000000000;;			 * is part of the URL.
0000000000000000000000000000000000000000;;			 *
0000000000000000000000000000000000000000;;			 * Examples:
0000000000000000000000000000000000000000;;			 *
0000000000000000000000000000000000000000;;			 *      foo http://www.pokemon.com/Pikachu_(Electric) bar
0000000000000000000000000000000000000000;;			 *              => http://www.pokemon.com/Pikachu_(Electric)
0000000000000000000000000000000000000000;;			 *
0000000000000000000000000000000000000000;;			 *      foo (http://www.pokemon.com/Pikachu_(Electric)) bar
0000000000000000000000000000000000000000;;			 *              => http://www.pokemon.com/Pikachu_(Electric)
0000000000000000000000000000000000000000;;			 *
0000000000000000000000000000000000000000;;			 *      foo http://www.pokemon.com/Pikachu_(Electric)) bar
0000000000000000000000000000000000000000;;			 *              => http://www.pokemon.com/Pikachu_(Electric))
0000000000000000000000000000000000000000;;			 *
0000000000000000000000000000000000000000;;			 *      (foo http://www.pokemon.com/Pikachu_(Electric)) bar
0000000000000000000000000000000000000000;;			 *              => foo http://www.pokemon.com/Pikachu_(Electric)
0000000000000000000000000000000000000000;;			 */
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for bufEnd >= 0 && origData[bufEnd] != '\n' && openDelim != 0 {
0000000000000000000000000000000000000000;;				if origData[bufEnd] == data[linkEnd-1] {
0000000000000000000000000000000000000000;;					openDelim++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if origData[bufEnd] == copen {
0000000000000000000000000000000000000000;;					openDelim--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				bufEnd--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if openDelim == 0 {
0000000000000000000000000000000000000000;;				linkEnd--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we were triggered on the ':', so we need to rewind the output a bit
0000000000000000000000000000000000000000;;		if out.Len() >= rewind {
0000000000000000000000000000000000000000;;			out.Truncate(len(out.Bytes()) - rewind)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var uLink bytes.Buffer
0000000000000000000000000000000000000000;;		unescapeText(&uLink, data[:linkEnd])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if uLink.Len() > 0 {
0000000000000000000000000000000000000000;;			p.r.AutoLink(out, uLink.Bytes(), LINK_TYPE_NORMAL)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return linkEnd - rewind
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isEndOfLink(char byte) bool {
0000000000000000000000000000000000000000;;		return isspace(char) || char == '<'
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var validUris = [][]byte{[]byte("http://"), []byte("https://"), []byte("ftp://"), []byte("mailto://")}
0000000000000000000000000000000000000000;;	var validPaths = [][]byte{[]byte("/"), []byte("./"), []byte("../")}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isSafeLink(link []byte) bool {
0000000000000000000000000000000000000000;;		for _, path := range validPaths {
0000000000000000000000000000000000000000;;			if len(link) >= len(path) && bytes.Equal(link[:len(path)], path) {
0000000000000000000000000000000000000000;;				if len(link) == len(path) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				} else if isalnum(link[len(path)]) {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, prefix := range validUris {
0000000000000000000000000000000000000000;;			// TODO: handle unicode here
0000000000000000000000000000000000000000;;			// case-insensitive prefix test
0000000000000000000000000000000000000000;;			if len(link) > len(prefix) && bytes.Equal(bytes.ToLower(link[:len(prefix)]), prefix) && isalnum(link[len(prefix)]) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// return the length of the given tag, or 0 is it's not valid
0000000000000000000000000000000000000000;;	func tagLength(data []byte, autolink *int) int {
0000000000000000000000000000000000000000;;		var i, j int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// a valid tag can't be shorter than 3 chars
0000000000000000000000000000000000000000;;		if len(data) < 3 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// begins with a '<' optionally followed by '/', followed by letter or number
0000000000000000000000000000000000000000;;		if data[0] != '<' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if data[1] == '/' {
0000000000000000000000000000000000000000;;			i = 2
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			i = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !isalnum(data[i]) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// scheme test
0000000000000000000000000000000000000000;;		*autolink = LINK_TYPE_NOT_AUTOLINK
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// try to find the beginning of an URI
0000000000000000000000000000000000000000;;		for i < len(data) && (isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-') {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i > 1 && i < len(data) && data[i] == '@' {
0000000000000000000000000000000000000000;;			if j = isMailtoAutoLink(data[i:]); j != 0 {
0000000000000000000000000000000000000000;;				*autolink = LINK_TYPE_EMAIL
0000000000000000000000000000000000000000;;				return i + j
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i > 2 && i < len(data) && data[i] == ':' {
0000000000000000000000000000000000000000;;			*autolink = LINK_TYPE_NORMAL
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// complete autolink test: no whitespace or ' or "
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case i >= len(data):
0000000000000000000000000000000000000000;;			*autolink = LINK_TYPE_NOT_AUTOLINK
0000000000000000000000000000000000000000;;		case *autolink != 0:
0000000000000000000000000000000000000000;;			j = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for i < len(data) {
0000000000000000000000000000000000000000;;				if data[i] == '\\' {
0000000000000000000000000000000000000000;;					i += 2
0000000000000000000000000000000000000000;;				} else if data[i] == '>' || data[i] == '\'' || data[i] == '"' || isspace(data[i]) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i >= len(data) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i > j && data[i] == '>' {
0000000000000000000000000000000000000000;;				return i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// one of the forbidden chars has been found
0000000000000000000000000000000000000000;;			*autolink = LINK_TYPE_NOT_AUTOLINK
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// look for something looking like a tag end
0000000000000000000000000000000000000000;;		for i < len(data) && data[i] != '>' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// look for the address part of a mail autolink and '>'
0000000000000000000000000000000000000000;;	// this is less strict than the original markdown e-mail address matching
0000000000000000000000000000000000000000;;	func isMailtoAutoLink(data []byte) int {
0000000000000000000000000000000000000000;;		nb := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@'
0000000000000000000000000000000000000000;;		for i := 0; i < len(data); i++ {
0000000000000000000000000000000000000000;;			if isalnum(data[i]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch data[i] {
0000000000000000000000000000000000000000;;			case '@':
0000000000000000000000000000000000000000;;				nb++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '-', '.', '_':
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case '>':
0000000000000000000000000000000000000000;;				if nb == 1 {
0000000000000000000000000000000000000000;;					return i + 1
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// look for the next emph char, skipping other constructs
0000000000000000000000000000000000000000;;	func helperFindEmphChar(data []byte, c byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			for i < len(data) && data[i] != c && data[i] != '`' && data[i] != '[' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if i >= len(data) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// do not count escaped chars
0000000000000000000000000000000000000000;;			if i != 0 && data[i-1] == '\\' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if data[i] == c {
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if data[i] == '`' {
0000000000000000000000000000000000000000;;				// skip a code span
0000000000000000000000000000000000000000;;				tmpI := 0
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				for i < len(data) && data[i] != '`' {
0000000000000000000000000000000000000000;;					if tmpI == 0 && data[i] == c {
0000000000000000000000000000000000000000;;						tmpI = i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i >= len(data) {
0000000000000000000000000000000000000000;;					return tmpI
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			} else if data[i] == '[' {
0000000000000000000000000000000000000000;;				// skip a link
0000000000000000000000000000000000000000;;				tmpI := 0
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				for i < len(data) && data[i] != ']' {
0000000000000000000000000000000000000000;;					if tmpI == 0 && data[i] == c {
0000000000000000000000000000000000000000;;						tmpI = i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				for i < len(data) && (data[i] == ' ' || data[i] == '\n') {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i >= len(data) {
0000000000000000000000000000000000000000;;					return tmpI
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if data[i] != '[' && data[i] != '(' { // not a link
0000000000000000000000000000000000000000;;					if tmpI > 0 {
0000000000000000000000000000000000000000;;						return tmpI
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				cc := data[i]
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				for i < len(data) && data[i] != cc {
0000000000000000000000000000000000000000;;					if tmpI == 0 && data[i] == c {
0000000000000000000000000000000000000000;;						return i
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if i >= len(data) {
0000000000000000000000000000000000000000;;					return tmpI
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func helperEmphasis(p *parser, out *bytes.Buffer, data []byte, c byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip one symbol if coming from emph3
0000000000000000000000000000000000000000;;		if len(data) > 1 && data[0] == c && data[1] == c {
0000000000000000000000000000000000000000;;			i = 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			length := helperFindEmphChar(data[i:], c)
0000000000000000000000000000000000000000;;			if length == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += length
0000000000000000000000000000000000000000;;			if i >= len(data) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i+1 < len(data) && data[i+1] == c {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if data[i] == c && !isspace(data[i-1]) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if p.flags&EXTENSION_NO_INTRA_EMPHASIS != 0 {
0000000000000000000000000000000000000000;;					if !(i+1 == len(data) || isspace(data[i+1]) || ispunct(data[i+1])) {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var work bytes.Buffer
0000000000000000000000000000000000000000;;				p.inline(&work, data[:i])
0000000000000000000000000000000000000000;;				p.r.Emphasis(out, work.Bytes())
0000000000000000000000000000000000000000;;				return i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func helperDoubleEmphasis(p *parser, out *bytes.Buffer, data []byte, c byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			length := helperFindEmphChar(data[i:], c)
0000000000000000000000000000000000000000;;			if length == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += length
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i+1 < len(data) && data[i] == c && data[i+1] == c && i > 0 && !isspace(data[i-1]) {
0000000000000000000000000000000000000000;;				var work bytes.Buffer
0000000000000000000000000000000000000000;;				p.inline(&work, data[:i])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if work.Len() > 0 {
0000000000000000000000000000000000000000;;					// pick the right renderer
0000000000000000000000000000000000000000;;					if c == '~' {
0000000000000000000000000000000000000000;;						p.r.StrikeThrough(out, work.Bytes())
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						p.r.DoubleEmphasis(out, work.Bytes())
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return i + 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func helperTripleEmphasis(p *parser, out *bytes.Buffer, data []byte, offset int, c byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		origData := data
0000000000000000000000000000000000000000;;		data = data[offset:]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			length := helperFindEmphChar(data[i:], c)
0000000000000000000000000000000000000000;;			if length == 0 {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i += length
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// skip whitespace preceded symbols
0000000000000000000000000000000000000000;;			if data[i] != c || isspace(data[i-1]) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case i+2 < len(data) && data[i+1] == c && data[i+2] == c:
0000000000000000000000000000000000000000;;				// triple symbol found
0000000000000000000000000000000000000000;;				var work bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p.inline(&work, data[:i])
0000000000000000000000000000000000000000;;				if work.Len() > 0 {
0000000000000000000000000000000000000000;;					p.r.TripleEmphasis(out, work.Bytes())
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return i + 3
0000000000000000000000000000000000000000;;			case (i+1 < len(data) && data[i+1] == c):
0000000000000000000000000000000000000000;;				// double symbol found, hand over to emph1
0000000000000000000000000000000000000000;;				length = helperEmphasis(p, out, origData[offset-2:], c)
0000000000000000000000000000000000000000;;				if length == 0 {
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return length - 2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// single symbol found, hand over to emph2
0000000000000000000000000000000000000000;;				length = helperDoubleEmphasis(p, out, origData[offset-1:], c)
0000000000000000000000000000000000000000;;				if length == 0 {
0000000000000000000000000000000000000000;;					return 0
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					return length - 1
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
