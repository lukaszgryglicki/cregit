0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Blackfriday Markdown Processor
0000000000000000000000000000000000000000;;	// Available at http://github.com/russross/blackfriday
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright Â© 2011 Russ Ross <russ@russross.com>.
0000000000000000000000000000000000000000;;	// Distributed under the Simplified BSD License.
0000000000000000000000000000000000000000;;	// See README.md for details.
0000000000000000000000000000000000000000;;	//
50f9755c60b2914e7a0c6daa6fbd3a38d2cab61c;Godeps/_workspace/src/github.com/russross/blackfriday/block.go[Godeps/_workspace/src/github.com/russross/blackfriday/block.go][vendor/github.com/russross/blackfriday/block.go];	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Functions to parse block-level elements.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package blackfriday
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/shurcooL/sanitized_anchor_name"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse block-level data.
0000000000000000000000000000000000000000;;	// Note: this function and many that it calls assume that
0000000000000000000000000000000000000000;;	// the input buffer ends with a newline.
0000000000000000000000000000000000000000;;	func (p *parser) block(out *bytes.Buffer, data []byte) {
0000000000000000000000000000000000000000;;		if len(data) == 0 || data[len(data)-1] != '\n' {
0000000000000000000000000000000000000000;;			panic("block input is missing terminating newline")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// this is called recursively: enforce a maximum depth
0000000000000000000000000000000000000000;;		if p.nesting >= p.maxNesting {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.nesting++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse out one block-level construct at a time
0000000000000000000000000000000000000000;;		for len(data) > 0 {
0000000000000000000000000000000000000000;;			// prefixed header:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// # Header 1
0000000000000000000000000000000000000000;;			// ## Header 2
0000000000000000000000000000000000000000;;			// ...
0000000000000000000000000000000000000000;;			// ###### Header 6
0000000000000000000000000000000000000000;;			if p.isPrefixHeader(data) {
0000000000000000000000000000000000000000;;				data = data[p.prefixHeader(out, data):]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// block of preformatted HTML:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// <div>
0000000000000000000000000000000000000000;;			//     ...
0000000000000000000000000000000000000000;;			// </div>
0000000000000000000000000000000000000000;;			if data[0] == '<' {
0000000000000000000000000000000000000000;;				if i := p.html(out, data, true); i > 0 {
0000000000000000000000000000000000000000;;					data = data[i:]
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// title block
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// % stuff
0000000000000000000000000000000000000000;;			// % more stuff
0000000000000000000000000000000000000000;;			// % even more stuff
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_TITLEBLOCK != 0 {
0000000000000000000000000000000000000000;;				if data[0] == '%' {
0000000000000000000000000000000000000000;;					if i := p.titleBlock(out, data, true); i > 0 {
0000000000000000000000000000000000000000;;						data = data[i:]
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// blank lines.  note: returns the # of bytes to skip
0000000000000000000000000000000000000000;;			if i := p.isEmpty(data); i > 0 {
0000000000000000000000000000000000000000;;				data = data[i:]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// indented code block:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			//     func max(a, b int) int {
0000000000000000000000000000000000000000;;			//         if a > b {
0000000000000000000000000000000000000000;;			//             return a
0000000000000000000000000000000000000000;;			//         }
0000000000000000000000000000000000000000;;			//         return b
0000000000000000000000000000000000000000;;			//      }
0000000000000000000000000000000000000000;;			if p.codePrefix(data) > 0 {
0000000000000000000000000000000000000000;;				data = data[p.code(out, data):]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// fenced code block:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// ``` go
0000000000000000000000000000000000000000;;			// func fact(n int) int {
0000000000000000000000000000000000000000;;			//     if n <= 1 {
0000000000000000000000000000000000000000;;			//         return n
0000000000000000000000000000000000000000;;			//     }
0000000000000000000000000000000000000000;;			//     return n * fact(n-1)
0000000000000000000000000000000000000000;;			// }
0000000000000000000000000000000000000000;;			// ```
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_FENCED_CODE != 0 {
0000000000000000000000000000000000000000;;				if i := p.fencedCode(out, data, true); i > 0 {
0000000000000000000000000000000000000000;;					data = data[i:]
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// horizontal rule:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// ------
0000000000000000000000000000000000000000;;			// or
0000000000000000000000000000000000000000;;			// ******
0000000000000000000000000000000000000000;;			// or
0000000000000000000000000000000000000000;;			// ______
0000000000000000000000000000000000000000;;			if p.isHRule(data) {
0000000000000000000000000000000000000000;;				p.r.HRule(out)
0000000000000000000000000000000000000000;;				var i int
0000000000000000000000000000000000000000;;				for i = 0; data[i] != '\n'; i++ {
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				data = data[i:]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// block quote:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// > A big quote I found somewhere
0000000000000000000000000000000000000000;;			// > on the web
0000000000000000000000000000000000000000;;			if p.quotePrefix(data) > 0 {
0000000000000000000000000000000000000000;;				data = data[p.quote(out, data):]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// table:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Name  | Age | Phone
0000000000000000000000000000000000000000;;			// ------|-----|---------
0000000000000000000000000000000000000000;;			// Bob   | 31  | 555-1234
0000000000000000000000000000000000000000;;			// Alice | 27  | 555-4321
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_TABLES != 0 {
0000000000000000000000000000000000000000;;				if i := p.table(out, data); i > 0 {
0000000000000000000000000000000000000000;;					data = data[i:]
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// an itemized/unordered list:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// * Item 1
0000000000000000000000000000000000000000;;			// * Item 2
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// also works with + or -
0000000000000000000000000000000000000000;;			if p.uliPrefix(data) > 0 {
0000000000000000000000000000000000000000;;				data = data[p.list(out, data, 0):]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// a numbered/ordered list:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// 1. Item 1
0000000000000000000000000000000000000000;;			// 2. Item 2
0000000000000000000000000000000000000000;;			if p.oliPrefix(data) > 0 {
0000000000000000000000000000000000000000;;				data = data[p.list(out, data, LIST_TYPE_ORDERED):]
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// definition lists:
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Term 1
0000000000000000000000000000000000000000;;			// :   Definition a
0000000000000000000000000000000000000000;;			// :   Definition b
0000000000000000000000000000000000000000;;			//
0000000000000000000000000000000000000000;;			// Term 2
0000000000000000000000000000000000000000;;			// :   Definition c
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_DEFINITION_LISTS != 0 {
0000000000000000000000000000000000000000;;				if p.dliPrefix(data) > 0 {
0000000000000000000000000000000000000000;;					data = data[p.list(out, data, LIST_TYPE_DEFINITION):]
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// anything else must look like a normal paragraph
0000000000000000000000000000000000000000;;			// note: this finds underlined headers, too
0000000000000000000000000000000000000000;;			data = data[p.paragraph(out, data):]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.nesting--
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) isPrefixHeader(data []byte) bool {
0000000000000000000000000000000000000000;;		if data[0] != '#' {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_SPACE_HEADERS != 0 {
0000000000000000000000000000000000000000;;			level := 0
0000000000000000000000000000000000000000;;			for level < 6 && data[level] == '#' {
0000000000000000000000000000000000000000;;				level++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if data[level] != ' ' {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) prefixHeader(out *bytes.Buffer, data []byte) int {
0000000000000000000000000000000000000000;;		level := 0
0000000000000000000000000000000000000000;;		for level < 6 && data[level] == '#' {
0000000000000000000000000000000000000000;;			level++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := skipChar(data, level, ' ')
0000000000000000000000000000000000000000;;		end := skipUntilChar(data, i, '\n')
0000000000000000000000000000000000000000;;		skip := end
0000000000000000000000000000000000000000;;		id := ""
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_HEADER_IDS != 0 {
0000000000000000000000000000000000000000;;			j, k := 0, 0
0000000000000000000000000000000000000000;;			// find start/end of header id
0000000000000000000000000000000000000000;;			for j = i; j < end-1 && (data[j] != '{' || data[j+1] != '#'); j++ {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k = j + 1; k < end && data[k] != '}'; k++ {
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			// extract header id iff found
0000000000000000000000000000000000000000;;			if j < end && k < end {
0000000000000000000000000000000000000000;;				id = string(data[j+2 : k])
0000000000000000000000000000000000000000;;				end = j
0000000000000000000000000000000000000000;;				skip = k + 1
0000000000000000000000000000000000000000;;				for end > 0 && data[end-1] == ' ' {
0000000000000000000000000000000000000000;;					end--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for end > 0 && data[end-1] == '#' {
0000000000000000000000000000000000000000;;			if isBackslashEscaped(data, end-1) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for end > 0 && data[end-1] == ' ' {
0000000000000000000000000000000000000000;;			end--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end > i {
0000000000000000000000000000000000000000;;			if id == "" && p.flags&EXTENSION_AUTO_HEADER_IDS != 0 {
0000000000000000000000000000000000000000;;				id = sanitized_anchor_name.Create(string(data[i:end]))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			work := func() bool {
0000000000000000000000000000000000000000;;				p.inline(out, data[i:end])
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.r.Header(out, work, level, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return skip
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) isUnderlinedHeader(data []byte) int {
0000000000000000000000000000000000000000;;		// test of level 1 header
0000000000000000000000000000000000000000;;		if data[0] == '=' {
0000000000000000000000000000000000000000;;			i := skipChar(data, 1, '=')
0000000000000000000000000000000000000000;;			i = skipChar(data, i, ' ')
0000000000000000000000000000000000000000;;			if data[i] == '\n' {
0000000000000000000000000000000000000000;;				return 1
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// test of level 2 header
0000000000000000000000000000000000000000;;		if data[0] == '-' {
0000000000000000000000000000000000000000;;			i := skipChar(data, 1, '-')
0000000000000000000000000000000000000000;;			i = skipChar(data, i, ' ')
0000000000000000000000000000000000000000;;			if data[i] == '\n' {
0000000000000000000000000000000000000000;;				return 2
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) titleBlock(out *bytes.Buffer, data []byte, doRender bool) int {
0000000000000000000000000000000000000000;;		if data[0] != '%' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		splitData := bytes.Split(data, []byte("\n"))
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		for idx, b := range splitData {
0000000000000000000000000000000000000000;;			if !bytes.HasPrefix(b, []byte("%")) {
0000000000000000000000000000000000000000;;				i = idx // - 1
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data = bytes.Join(splitData[0:i], []byte("\n"))
0000000000000000000000000000000000000000;;		p.r.TitleBlock(out, data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return len(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) html(out *bytes.Buffer, data []byte, doRender bool) int {
0000000000000000000000000000000000000000;;		var i, j int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// identify the opening tag
0000000000000000000000000000000000000000;;		if data[0] != '<' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		curtag, tagfound := p.htmlFindTag(data[1:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// handle special cases
0000000000000000000000000000000000000000;;		if !tagfound {
0000000000000000000000000000000000000000;;			// check for an HTML comment
0000000000000000000000000000000000000000;;			if size := p.htmlComment(out, data, doRender); size > 0 {
0000000000000000000000000000000000000000;;				return size
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check for an <hr> tag
0000000000000000000000000000000000000000;;			if size := p.htmlHr(out, data, doRender); size > 0 {
0000000000000000000000000000000000000000;;				return size
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// no special case recognized
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// look for an unindented matching closing tag
0000000000000000000000000000000000000000;;		// followed by a blank line
0000000000000000000000000000000000000000;;		found := false
0000000000000000000000000000000000000000;;		/*
0000000000000000000000000000000000000000;;			closetag := []byte("\n</" + curtag + ">")
0000000000000000000000000000000000000000;;			j = len(curtag) + 1
0000000000000000000000000000000000000000;;			for !found {
0000000000000000000000000000000000000000;;				// scan for a closing tag at the beginning of a line
0000000000000000000000000000000000000000;;				if skip := bytes.Index(data[j:], closetag); skip >= 0 {
0000000000000000000000000000000000000000;;					j += skip + len(closetag)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// see if it is the only thing on the line
0000000000000000000000000000000000000000;;				if skip := p.isEmpty(data[j:]); skip > 0 {
0000000000000000000000000000000000000000;;					// see if it is followed by a blank line/eof
0000000000000000000000000000000000000000;;					j += skip
0000000000000000000000000000000000000000;;					if j >= len(data) {
0000000000000000000000000000000000000000;;						found = true
0000000000000000000000000000000000000000;;						i = j
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if skip := p.isEmpty(data[j:]); skip > 0 {
0000000000000000000000000000000000000000;;							j += skip
0000000000000000000000000000000000000000;;							found = true
0000000000000000000000000000000000000000;;							i = j
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		*/
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if not found, try a second pass looking for indented match
0000000000000000000000000000000000000000;;		// but not if tag is "ins" or "del" (following original Markdown.pl)
0000000000000000000000000000000000000000;;		if !found && curtag != "ins" && curtag != "del" {
0000000000000000000000000000000000000000;;			i = 1
0000000000000000000000000000000000000000;;			for i < len(data) {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				for i < len(data) && !(data[i-1] == '<' && data[i] == '/') {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if i+2+len(curtag) >= len(data) {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				j = p.htmlFindEnd(curtag, data[i-1:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if j > 0 {
0000000000000000000000000000000000000000;;					i += j - 1
0000000000000000000000000000000000000000;;					found = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !found {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the end of the block has been found
0000000000000000000000000000000000000000;;		if doRender {
0000000000000000000000000000000000000000;;			// trim newlines
0000000000000000000000000000000000000000;;			end := i
0000000000000000000000000000000000000000;;			for end > 0 && data[end-1] == '\n' {
0000000000000000000000000000000000000000;;				end--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			p.r.BlockHtml(out, data[:end])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HTML comment, lax form
0000000000000000000000000000000000000000;;	func (p *parser) htmlComment(out *bytes.Buffer, data []byte, doRender bool) int {
0000000000000000000000000000000000000000;;		i := p.inlineHtmlComment(out, data)
0000000000000000000000000000000000000000;;		// needs to end with a blank line
0000000000000000000000000000000000000000;;		if j := p.isEmpty(data[i:]); j > 0 {
0000000000000000000000000000000000000000;;			size := i + j
0000000000000000000000000000000000000000;;			if doRender {
0000000000000000000000000000000000000000;;				// trim trailing newlines
0000000000000000000000000000000000000000;;				end := size
0000000000000000000000000000000000000000;;				for end > 0 && data[end-1] == '\n' {
0000000000000000000000000000000000000000;;					end--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				p.r.BlockHtml(out, data[:end])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return size
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HR, which is the only self-closing block tag considered
0000000000000000000000000000000000000000;;	func (p *parser) htmlHr(out *bytes.Buffer, data []byte, doRender bool) int {
0000000000000000000000000000000000000000;;		if data[0] != '<' || (data[1] != 'h' && data[1] != 'H') || (data[2] != 'r' && data[2] != 'R') {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if data[3] != ' ' && data[3] != '/' && data[3] != '>' {
0000000000000000000000000000000000000000;;			// not an <hr> tag after all; at least not a valid one
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 3
0000000000000000000000000000000000000000;;		for data[i] != '>' && data[i] != '\n' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if data[i] == '>' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			if j := p.isEmpty(data[i:]); j > 0 {
0000000000000000000000000000000000000000;;				size := i + j
0000000000000000000000000000000000000000;;				if doRender {
0000000000000000000000000000000000000000;;					// trim newlines
0000000000000000000000000000000000000000;;					end := size
0000000000000000000000000000000000000000;;					for end > 0 && data[end-1] == '\n' {
0000000000000000000000000000000000000000;;						end--
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					p.r.BlockHtml(out, data[:end])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return size
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) htmlFindTag(data []byte) (string, bool) {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for isalnum(data[i]) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		key := string(data[:i])
0000000000000000000000000000000000000000;;		if _, ok := blockTags[key]; ok {
0000000000000000000000000000000000000000;;			return key, true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) htmlFindEnd(tag string, data []byte) int {
0000000000000000000000000000000000000000;;		// assume data[0] == '<' && data[1] == '/' already tested
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if tag is a match
0000000000000000000000000000000000000000;;		closetag := []byte("</" + tag + ">")
0000000000000000000000000000000000000000;;		if !bytes.HasPrefix(data, closetag) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i := len(closetag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check that the rest of the line is blank
0000000000000000000000000000000000000000;;		skip := 0
0000000000000000000000000000000000000000;;		if skip = p.isEmpty(data[i:]); skip == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i += skip
0000000000000000000000000000000000000000;;		skip = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if p.flags&EXTENSION_LAX_HTML_BLOCKS != 0 {
0000000000000000000000000000000000000000;;			return i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if skip = p.isEmpty(data[i:]); skip == 0 {
0000000000000000000000000000000000000000;;			// following line must be blank
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i + skip
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) isEmpty(data []byte) int {
0000000000000000000000000000000000000000;;		// it is okay to call isEmpty on an empty buffer
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var i int
0000000000000000000000000000000000000000;;		for i = 0; i < len(data) && data[i] != '\n'; i++ {
0000000000000000000000000000000000000000;;			if data[i] != ' ' && data[i] != '\t' {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i + 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) isHRule(data []byte) bool {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip up to three spaces
0000000000000000000000000000000000000000;;		for i < 3 && data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// look at the hrule char
0000000000000000000000000000000000000000;;		if data[i] != '*' && data[i] != '-' && data[i] != '_' {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		c := data[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the whole line must be the char or whitespace
0000000000000000000000000000000000000000;;		n := 0
0000000000000000000000000000000000000000;;		for data[i] != '\n' {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case data[i] == c:
0000000000000000000000000000000000000000;;				n++
0000000000000000000000000000000000000000;;			case data[i] != ' ':
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return n >= 3
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) isFencedCode(data []byte, syntax **string, oldmarker string) (skip int, marker string) {
0000000000000000000000000000000000000000;;		i, size := 0, 0
0000000000000000000000000000000000000000;;		skip = 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip up to three spaces
0000000000000000000000000000000000000000;;		for i < len(data) && i < 3 && data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for the marker characters: ~ or `
0000000000000000000000000000000000000000;;		if data[i] != '~' && data[i] != '`' {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		c := data[i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the whole line must be the same char or whitespace
0000000000000000000000000000000000000000;;		for i < len(data) && data[i] == c {
0000000000000000000000000000000000000000;;			size++
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// the marker char must occur at least 3 times
0000000000000000000000000000000000000000;;		if size < 3 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		marker = string(data[i-size : i])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// if this is the end marker, it must match the beginning marker
0000000000000000000000000000000000000000;;		if oldmarker != "" && marker != oldmarker {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if syntax != nil {
0000000000000000000000000000000000000000;;			syn := 0
0000000000000000000000000000000000000000;;			i = skipChar(data, i, ' ')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i >= len(data) {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			syntaxStart := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if data[i] == '{' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				syntaxStart++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i < len(data) && data[i] != '}' && data[i] != '\n' {
0000000000000000000000000000000000000000;;					syn++
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if i >= len(data) || data[i] != '}' {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// strip all whitespace at the beginning and the end
0000000000000000000000000000000000000000;;				// of the {} block
0000000000000000000000000000000000000000;;				for syn > 0 && isspace(data[syntaxStart]) {
0000000000000000000000000000000000000000;;					syntaxStart++
0000000000000000000000000000000000000000;;					syn--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for syn > 0 && isspace(data[syntaxStart+syn-1]) {
0000000000000000000000000000000000000000;;					syn--
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				for i < len(data) && !isspace(data[i]) {
0000000000000000000000000000000000000000;;					syn++
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			language := string(data[syntaxStart : syntaxStart+syn])
0000000000000000000000000000000000000000;;			*syntax = &language
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i = skipChar(data, i, ' ')
0000000000000000000000000000000000000000;;		if i >= len(data) || data[i] != '\n' {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		skip = i + 1
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) fencedCode(out *bytes.Buffer, data []byte, doRender bool) int {
0000000000000000000000000000000000000000;;		var lang *string
0000000000000000000000000000000000000000;;		beg, marker := p.isFencedCode(data, &lang, "")
0000000000000000000000000000000000000000;;		if beg == 0 || beg >= len(data) {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var work bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// safe to assume beg < len(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// check for the end of the code block
0000000000000000000000000000000000000000;;			fenceEnd, _ := p.isFencedCode(data[beg:], nil, marker)
0000000000000000000000000000000000000000;;			if fenceEnd != 0 {
0000000000000000000000000000000000000000;;				beg += fenceEnd
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// copy the current line
0000000000000000000000000000000000000000;;			end := skipUntilChar(data, beg, '\n') + 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// did we reach the end of the buffer without a closing marker?
0000000000000000000000000000000000000000;;			if end >= len(data) {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verbatim copy to the working buffer
0000000000000000000000000000000000000000;;			if doRender {
0000000000000000000000000000000000000000;;				work.Write(data[beg:end])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			beg = end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		syntax := ""
0000000000000000000000000000000000000000;;		if lang != nil {
0000000000000000000000000000000000000000;;			syntax = *lang
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if doRender {
0000000000000000000000000000000000000000;;			p.r.BlockCode(out, work.Bytes(), syntax)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return beg
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) table(out *bytes.Buffer, data []byte) int {
0000000000000000000000000000000000000000;;		var header bytes.Buffer
0000000000000000000000000000000000000000;;		i, columns := p.tableHeader(&header, data)
0000000000000000000000000000000000000000;;		if i == 0 {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var body bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			pipes, rowStart := 0, i
0000000000000000000000000000000000000000;;			for ; data[i] != '\n'; i++ {
0000000000000000000000000000000000000000;;				if data[i] == '|' {
0000000000000000000000000000000000000000;;					pipes++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pipes == 0 {
0000000000000000000000000000000000000000;;				i = rowStart
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// include the newline in data sent to tableRow
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;			p.tableRow(&body, data[rowStart:i], columns, false)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.r.Table(out, header.Bytes(), body.Bytes(), columns)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// check if the specified position is preceded by an odd number of backslashes
0000000000000000000000000000000000000000;;	func isBackslashEscaped(data []byte, i int) bool {
0000000000000000000000000000000000000000;;		backslashes := 0
0000000000000000000000000000000000000000;;		for i-backslashes-1 >= 0 && data[i-backslashes-1] == '\\' {
0000000000000000000000000000000000000000;;			backslashes++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return backslashes&1 == 1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) tableHeader(out *bytes.Buffer, data []byte) (size int, columns []int) {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		colCount := 1
0000000000000000000000000000000000000000;;		for i = 0; data[i] != '\n'; i++ {
0000000000000000000000000000000000000000;;			if data[i] == '|' && !isBackslashEscaped(data, i) {
0000000000000000000000000000000000000000;;				colCount++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// doesn't look like a table header
0000000000000000000000000000000000000000;;		if colCount == 1 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// include the newline in the data sent to tableRow
0000000000000000000000000000000000000000;;		header := data[:i+1]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// column count ignores pipes at beginning or end of line
0000000000000000000000000000000000000000;;		if data[0] == '|' {
0000000000000000000000000000000000000000;;			colCount--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i > 2 && data[i-1] == '|' && !isBackslashEscaped(data, i-1) {
0000000000000000000000000000000000000000;;			colCount--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		columns = make([]int, colCount)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// move on to the header underline
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		if i >= len(data) {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if data[i] == '|' && !isBackslashEscaped(data, i) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i = skipChar(data, i, ' ')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// each column header is of form: / *:?-+:? *|/ with # dashes + # colons >= 3
0000000000000000000000000000000000000000;;		// and trailing | optional on last column
0000000000000000000000000000000000000000;;		col := 0
0000000000000000000000000000000000000000;;		for data[i] != '\n' {
0000000000000000000000000000000000000000;;			dashes := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if data[i] == ':' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				columns[col] |= TABLE_ALIGNMENT_LEFT
0000000000000000000000000000000000000000;;				dashes++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for data[i] == '-' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				dashes++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if data[i] == ':' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				columns[col] |= TABLE_ALIGNMENT_RIGHT
0000000000000000000000000000000000000000;;				dashes++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for data[i] == ' ' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// end of column test is messy
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case dashes < 3:
0000000000000000000000000000000000000000;;				// not a valid column
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case data[i] == '|' && !isBackslashEscaped(data, i):
0000000000000000000000000000000000000000;;				// marker found, now skip past trailing whitespace
0000000000000000000000000000000000000000;;				col++
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;				for data[i] == ' ' {
0000000000000000000000000000000000000000;;					i++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// trailing junk found after last column
0000000000000000000000000000000000000000;;				if col >= colCount && data[i] != '\n' {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case (data[i] != '|' || isBackslashEscaped(data, i)) && col+1 < colCount:
0000000000000000000000000000000000000000;;				// something else found where marker was required
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case data[i] == '\n':
0000000000000000000000000000000000000000;;				// marker is optional for the last column
0000000000000000000000000000000000000000;;				col++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				// trailing junk found after last column
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if col != colCount {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.tableRow(out, header, columns, true)
0000000000000000000000000000000000000000;;		size = i + 1
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) tableRow(out *bytes.Buffer, data []byte, columns []int, header bool) {
0000000000000000000000000000000000000000;;		i, col := 0, 0
0000000000000000000000000000000000000000;;		var rowWork bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if data[i] == '|' && !isBackslashEscaped(data, i) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for col = 0; col < len(columns) && i < len(data); col++ {
0000000000000000000000000000000000000000;;			for data[i] == ' ' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cellStart := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for (data[i] != '|' || isBackslashEscaped(data, i)) && data[i] != '\n' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			cellEnd := i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// skip the end-of-cell marker, possibly taking us past end of buffer
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for cellEnd > cellStart && data[cellEnd-1] == ' ' {
0000000000000000000000000000000000000000;;				cellEnd--
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var cellWork bytes.Buffer
0000000000000000000000000000000000000000;;			p.inline(&cellWork, data[cellStart:cellEnd])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if header {
0000000000000000000000000000000000000000;;				p.r.TableHeaderCell(&rowWork, cellWork.Bytes(), columns[col])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.r.TableCell(&rowWork, cellWork.Bytes(), columns[col])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// pad it out with empty columns to get the right number
0000000000000000000000000000000000000000;;		for ; col < len(columns); col++ {
0000000000000000000000000000000000000000;;			if header {
0000000000000000000000000000000000000000;;				p.r.TableHeaderCell(&rowWork, nil, columns[col])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.r.TableCell(&rowWork, nil, columns[col])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// silently ignore rows with too many cells
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.r.TableRow(out, rowWork.Bytes())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns blockquote prefix length
0000000000000000000000000000000000000000;;	func (p *parser) quotePrefix(data []byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < 3 && data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if data[i] == '>' {
0000000000000000000000000000000000000000;;			if data[i+1] == ' ' {
0000000000000000000000000000000000000000;;				return i + 2
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return i + 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// blockquote ends with at least one blank line
0000000000000000000000000000000000000000;;	// followed by something without a blockquote prefix
0000000000000000000000000000000000000000;;	func (p *parser) terminateBlockquote(data []byte, beg, end int) bool {
0000000000000000000000000000000000000000;;		if p.isEmpty(data[beg:]) <= 0 {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if end >= len(data) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p.quotePrefix(data[end:]) == 0 && p.isEmpty(data[end:]) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse a blockquote fragment
0000000000000000000000000000000000000000;;	func (p *parser) quote(out *bytes.Buffer, data []byte) int {
0000000000000000000000000000000000000000;;		var raw bytes.Buffer
0000000000000000000000000000000000000000;;		beg, end := 0, 0
0000000000000000000000000000000000000000;;		for beg < len(data) {
0000000000000000000000000000000000000000;;			end = beg
0000000000000000000000000000000000000000;;			// Step over whole lines, collecting them. While doing that, check for
0000000000000000000000000000000000000000;;			// fenced code and if one's found, incorporate it altogether,
0000000000000000000000000000000000000000;;			// irregardless of any contents inside it
0000000000000000000000000000000000000000;;			for data[end] != '\n' {
0000000000000000000000000000000000000000;;				if p.flags&EXTENSION_FENCED_CODE != 0 {
0000000000000000000000000000000000000000;;					if i := p.fencedCode(out, data[end:], false); i > 0 {
0000000000000000000000000000000000000000;;						// -1 to compensate for the extra end++ after the loop:
0000000000000000000000000000000000000000;;						end += i - 1
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				end++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			end++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if pre := p.quotePrefix(data[beg:]); pre > 0 {
0000000000000000000000000000000000000000;;				// skip the prefix
0000000000000000000000000000000000000000;;				beg += pre
0000000000000000000000000000000000000000;;			} else if p.terminateBlockquote(data, beg, end) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// this line is part of the blockquote
0000000000000000000000000000000000000000;;			raw.Write(data[beg:end])
0000000000000000000000000000000000000000;;			beg = end
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var cooked bytes.Buffer
0000000000000000000000000000000000000000;;		p.block(&cooked, raw.Bytes())
0000000000000000000000000000000000000000;;		p.r.BlockQuote(out, cooked.Bytes())
0000000000000000000000000000000000000000;;		return end
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns prefix length for block code
0000000000000000000000000000000000000000;;	func (p *parser) codePrefix(data []byte) int {
0000000000000000000000000000000000000000;;		if data[0] == ' ' && data[1] == ' ' && data[2] == ' ' && data[3] == ' ' {
0000000000000000000000000000000000000000;;			return 4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) code(out *bytes.Buffer, data []byte) int {
0000000000000000000000000000000000000000;;		var work bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			beg := i
0000000000000000000000000000000000000000;;			for data[i] != '\n' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			blankline := p.isEmpty(data[beg:i]) > 0
0000000000000000000000000000000000000000;;			if pre := p.codePrefix(data[beg:i]); pre > 0 {
0000000000000000000000000000000000000000;;				beg += pre
0000000000000000000000000000000000000000;;			} else if !blankline {
0000000000000000000000000000000000000000;;				// non-empty, non-prefixed line breaks the pre
0000000000000000000000000000000000000000;;				i = beg
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// verbatim copy to the working buffeu
0000000000000000000000000000000000000000;;			if blankline {
0000000000000000000000000000000000000000;;				work.WriteByte('\n')
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				work.Write(data[beg:i])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// trim all the \n off the end of work
0000000000000000000000000000000000000000;;		workbytes := work.Bytes()
0000000000000000000000000000000000000000;;		eol := len(workbytes)
0000000000000000000000000000000000000000;;		for eol > 0 && workbytes[eol-1] == '\n' {
0000000000000000000000000000000000000000;;			eol--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if eol != len(workbytes) {
0000000000000000000000000000000000000000;;			work.Truncate(eol)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		work.WriteByte('\n')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.r.BlockCode(out, work.Bytes(), "")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns unordered list item prefix
0000000000000000000000000000000000000000;;	func (p *parser) uliPrefix(data []byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start with up to 3 spaces
0000000000000000000000000000000000000000;;		for i < 3 && data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need a *, +, or - followed by a space
0000000000000000000000000000000000000000;;		if (data[i] != '*' && data[i] != '+' && data[i] != '-') ||
0000000000000000000000000000000000000000;;			data[i+1] != ' ' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i + 2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns ordered list item prefix
0000000000000000000000000000000000000000;;	func (p *parser) oliPrefix(data []byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// start with up to 3 spaces
0000000000000000000000000000000000000000;;		for i < 3 && data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// count the digits
0000000000000000000000000000000000000000;;		start := i
0000000000000000000000000000000000000000;;		for data[i] >= '0' && data[i] <= '9' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// we need >= 1 digits followed by a dot and a space
0000000000000000000000000000000000000000;;		if start == i || data[i] != '.' || data[i+1] != ' ' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i + 2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// returns definition list item prefix
0000000000000000000000000000000000000000;;	func (p *parser) dliPrefix(data []byte) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// need a : followed by a spaces
0000000000000000000000000000000000000000;;		if data[i] != ':' || data[i+1] != ' ' {
0000000000000000000000000000000000000000;;			return 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i + 2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// parse ordered or unordered list block
0000000000000000000000000000000000000000;;	func (p *parser) list(out *bytes.Buffer, data []byte, flags int) int {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		flags |= LIST_ITEM_BEGINNING_OF_LIST
0000000000000000000000000000000000000000;;		work := func() bool {
0000000000000000000000000000000000000000;;			for i < len(data) {
0000000000000000000000000000000000000000;;				skip := p.listItem(out, data[i:], &flags)
0000000000000000000000000000000000000000;;				i += skip
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if skip == 0 || flags&LIST_ITEM_END_OF_LIST != 0 {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				flags &= ^LIST_ITEM_BEGINNING_OF_LIST
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.r.List(out, work, flags)
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Parse a single list item.
0000000000000000000000000000000000000000;;	// Assumes initial prefix is already removed if this is a sublist.
0000000000000000000000000000000000000000;;	func (p *parser) listItem(out *bytes.Buffer, data []byte, flags *int) int {
0000000000000000000000000000000000000000;;		// keep track of the indentation of the first line
0000000000000000000000000000000000000000;;		itemIndent := 0
0000000000000000000000000000000000000000;;		for itemIndent < 3 && data[itemIndent] == ' ' {
0000000000000000000000000000000000000000;;			itemIndent++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i := p.uliPrefix(data)
0000000000000000000000000000000000000000;;		if i == 0 {
0000000000000000000000000000000000000000;;			i = p.oliPrefix(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i == 0 {
0000000000000000000000000000000000000000;;			i = p.dliPrefix(data)
0000000000000000000000000000000000000000;;			// reset definition term flag
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				*flags &= ^LIST_TYPE_TERM
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if i == 0 {
0000000000000000000000000000000000000000;;			// if in defnition list, set term flag and continue
0000000000000000000000000000000000000000;;			if *flags&LIST_TYPE_DEFINITION != 0 {
0000000000000000000000000000000000000000;;				*flags |= LIST_TYPE_TERM
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return 0
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// skip leading whitespace on first line
0000000000000000000000000000000000000000;;		for data[i] == ' ' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// find the end of the line
0000000000000000000000000000000000000000;;		line := i
0000000000000000000000000000000000000000;;		for i > 0 && data[i-1] != '\n' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// get working buffer
0000000000000000000000000000000000000000;;		var raw bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// put the first line into the working buffer
0000000000000000000000000000000000000000;;		raw.Write(data[line:i])
0000000000000000000000000000000000000000;;		line = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// process the following lines
0000000000000000000000000000000000000000;;		containsBlankLine := false
0000000000000000000000000000000000000000;;		sublist := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	gatherlines:
0000000000000000000000000000000000000000;;		for line < len(data) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// find the end of this line
0000000000000000000000000000000000000000;;			for data[i-1] != '\n' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if it is an empty line, guess that it is part of this item
0000000000000000000000000000000000000000;;			// and move on to the next line
0000000000000000000000000000000000000000;;			if p.isEmpty(data[line:i]) > 0 {
0000000000000000000000000000000000000000;;				containsBlankLine = true
0000000000000000000000000000000000000000;;				line = i
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// calculate the indentation
0000000000000000000000000000000000000000;;			indent := 0
0000000000000000000000000000000000000000;;			for indent < 4 && line+indent < i && data[line+indent] == ' ' {
0000000000000000000000000000000000000000;;				indent++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			chunk := data[line+indent : i]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// evaluate how this line fits in
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			// is this a nested list item?
0000000000000000000000000000000000000000;;			case (p.uliPrefix(chunk) > 0 && !p.isHRule(chunk)) ||
0000000000000000000000000000000000000000;;				p.oliPrefix(chunk) > 0 ||
0000000000000000000000000000000000000000;;				p.dliPrefix(chunk) > 0:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if containsBlankLine {
0000000000000000000000000000000000000000;;					*flags |= LIST_ITEM_CONTAINS_BLOCK
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// to be a nested list, it must be indented more
0000000000000000000000000000000000000000;;				// if not, it is the next item in the same list
0000000000000000000000000000000000000000;;				if indent <= itemIndent {
0000000000000000000000000000000000000000;;					break gatherlines
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// is this the first item in the nested list?
0000000000000000000000000000000000000000;;				if sublist == 0 {
0000000000000000000000000000000000000000;;					sublist = raw.Len()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// is this a nested prefix header?
0000000000000000000000000000000000000000;;			case p.isPrefixHeader(chunk):
0000000000000000000000000000000000000000;;				// if the header is not indented, it is not nested in the list
0000000000000000000000000000000000000000;;				// and thus ends the list
0000000000000000000000000000000000000000;;				if containsBlankLine && indent < 4 {
0000000000000000000000000000000000000000;;					*flags |= LIST_ITEM_END_OF_LIST
0000000000000000000000000000000000000000;;					break gatherlines
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*flags |= LIST_ITEM_CONTAINS_BLOCK
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// anything following an empty line is only part
0000000000000000000000000000000000000000;;			// of this item if it is indented 4 spaces
0000000000000000000000000000000000000000;;			// (regardless of the indentation of the beginning of the item)
0000000000000000000000000000000000000000;;			case containsBlankLine && indent < 4:
0000000000000000000000000000000000000000;;				if *flags&LIST_TYPE_DEFINITION != 0 && i < len(data)-1 {
0000000000000000000000000000000000000000;;					// is the next item still a part of this list?
0000000000000000000000000000000000000000;;					next := i
0000000000000000000000000000000000000000;;					for data[next] != '\n' {
0000000000000000000000000000000000000000;;						next++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for next < len(data)-1 && data[next] == '\n' {
0000000000000000000000000000000000000000;;						next++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if i < len(data)-1 && data[i] != ':' && data[next] != ':' {
0000000000000000000000000000000000000000;;						*flags |= LIST_ITEM_END_OF_LIST
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					*flags |= LIST_ITEM_END_OF_LIST
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				break gatherlines
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// a blank line means this should be parsed as a block
0000000000000000000000000000000000000000;;			case containsBlankLine:
0000000000000000000000000000000000000000;;				raw.WriteByte('\n')
0000000000000000000000000000000000000000;;				*flags |= LIST_ITEM_CONTAINS_BLOCK
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if this line was preceeded by one or more blanks,
0000000000000000000000000000000000000000;;			// re-introduce the blank into the buffer
0000000000000000000000000000000000000000;;			if containsBlankLine {
0000000000000000000000000000000000000000;;				containsBlankLine = false
0000000000000000000000000000000000000000;;				raw.WriteByte('\n')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// add the line into the working buffer without prefix
0000000000000000000000000000000000000000;;			raw.Write(data[line+indent : i])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			line = i
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rawBytes := raw.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// render the contents of the list item
0000000000000000000000000000000000000000;;		var cooked bytes.Buffer
0000000000000000000000000000000000000000;;		if *flags&LIST_ITEM_CONTAINS_BLOCK != 0 && *flags&LIST_TYPE_TERM == 0 {
0000000000000000000000000000000000000000;;			// intermediate render of block item, except for definition term
0000000000000000000000000000000000000000;;			if sublist > 0 {
0000000000000000000000000000000000000000;;				p.block(&cooked, rawBytes[:sublist])
0000000000000000000000000000000000000000;;				p.block(&cooked, rawBytes[sublist:])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.block(&cooked, rawBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// intermediate render of inline item
0000000000000000000000000000000000000000;;			if sublist > 0 {
0000000000000000000000000000000000000000;;				p.inline(&cooked, rawBytes[:sublist])
0000000000000000000000000000000000000000;;				p.block(&cooked, rawBytes[sublist:])
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				p.inline(&cooked, rawBytes)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// render the actual list item
0000000000000000000000000000000000000000;;		cookedBytes := cooked.Bytes()
0000000000000000000000000000000000000000;;		parsedEnd := len(cookedBytes)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// strip trailing newlines
0000000000000000000000000000000000000000;;		for parsedEnd > 0 && cookedBytes[parsedEnd-1] == '\n' {
0000000000000000000000000000000000000000;;			parsedEnd--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.r.ListItem(out, cookedBytes[:parsedEnd], *flags)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return line
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// render a single paragraph that has already been parsed out
0000000000000000000000000000000000000000;;	func (p *parser) renderParagraph(out *bytes.Buffer, data []byte) {
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// trim leading spaces
0000000000000000000000000000000000000000;;		beg := 0
0000000000000000000000000000000000000000;;		for data[beg] == ' ' {
0000000000000000000000000000000000000000;;			beg++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// trim trailing newline
0000000000000000000000000000000000000000;;		end := len(data) - 1
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// trim trailing spaces
0000000000000000000000000000000000000000;;		for end > beg && data[end-1] == ' ' {
0000000000000000000000000000000000000000;;			end--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		work := func() bool {
0000000000000000000000000000000000000000;;			p.inline(out, data[beg:end])
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		p.r.Paragraph(out, work)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *parser) paragraph(out *bytes.Buffer, data []byte) int {
0000000000000000000000000000000000000000;;		// prev: index of 1st char of previous line
0000000000000000000000000000000000000000;;		// line: index of 1st char of current line
0000000000000000000000000000000000000000;;		// i: index of cursor/end of current line
0000000000000000000000000000000000000000;;		var prev, line, i int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// keep going until we find something to mark the end of the paragraph
0000000000000000000000000000000000000000;;		for i < len(data) {
0000000000000000000000000000000000000000;;			// mark the beginning of the current line
0000000000000000000000000000000000000000;;			prev = line
0000000000000000000000000000000000000000;;			current := data[i:]
0000000000000000000000000000000000000000;;			line = i
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// did we find a blank line marking the end of the paragraph?
0000000000000000000000000000000000000000;;			if n := p.isEmpty(current); n > 0 {
0000000000000000000000000000000000000000;;				// did this blank line followed by a definition list item?
0000000000000000000000000000000000000000;;				if p.flags&EXTENSION_DEFINITION_LISTS != 0 {
0000000000000000000000000000000000000000;;					if i < len(data)-1 && data[i+1] == ':' {
0000000000000000000000000000000000000000;;						return p.list(out, data[prev:], LIST_TYPE_DEFINITION)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				p.renderParagraph(out, data[:i])
0000000000000000000000000000000000000000;;				return i + n
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// an underline under some text marks a header, so our paragraph ended on prev line
0000000000000000000000000000000000000000;;			if i > 0 {
0000000000000000000000000000000000000000;;				if level := p.isUnderlinedHeader(current); level > 0 {
0000000000000000000000000000000000000000;;					// render the paragraph
0000000000000000000000000000000000000000;;					p.renderParagraph(out, data[:prev])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// ignore leading and trailing whitespace
0000000000000000000000000000000000000000;;					eol := i - 1
0000000000000000000000000000000000000000;;					for prev < eol && data[prev] == ' ' {
0000000000000000000000000000000000000000;;						prev++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for eol > prev && data[eol-1] == ' ' {
0000000000000000000000000000000000000000;;						eol--
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// render the header
0000000000000000000000000000000000000000;;					// this ugly double closure avoids forcing variables onto the heap
0000000000000000000000000000000000000000;;					work := func(o *bytes.Buffer, pp *parser, d []byte) func() bool {
0000000000000000000000000000000000000000;;						return func() bool {
0000000000000000000000000000000000000000;;							pp.inline(o, d)
0000000000000000000000000000000000000000;;							return true
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}(out, p, data[prev:eol])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					id := ""
0000000000000000000000000000000000000000;;					if p.flags&EXTENSION_AUTO_HEADER_IDS != 0 {
0000000000000000000000000000000000000000;;						id = sanitized_anchor_name.Create(string(data[prev:eol]))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					p.r.Header(out, work, level, id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// find the end of the underline
0000000000000000000000000000000000000000;;					for data[i] != '\n' {
0000000000000000000000000000000000000000;;						i++
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if the next line starts a block of HTML, then the paragraph ends here
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_LAX_HTML_BLOCKS != 0 {
0000000000000000000000000000000000000000;;				if data[i] == '<' && p.html(out, current, false) > 0 {
0000000000000000000000000000000000000000;;					// rewind to before the HTML block
0000000000000000000000000000000000000000;;					p.renderParagraph(out, data[:i])
0000000000000000000000000000000000000000;;					return i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if there's a prefixed header or a horizontal rule after this, paragraph is over
0000000000000000000000000000000000000000;;			if p.isPrefixHeader(current) || p.isHRule(current) {
0000000000000000000000000000000000000000;;				p.renderParagraph(out, data[:i])
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if there's a fenced code block, paragraph is over
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_FENCED_CODE != 0 {
0000000000000000000000000000000000000000;;				if p.fencedCode(out, current, false) > 0 {
0000000000000000000000000000000000000000;;					p.renderParagraph(out, data[:i])
0000000000000000000000000000000000000000;;					return i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if there's a definition list item, prev line is a definition term
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_DEFINITION_LISTS != 0 {
0000000000000000000000000000000000000000;;				if p.dliPrefix(current) != 0 {
0000000000000000000000000000000000000000;;					return p.list(out, data[prev:], LIST_TYPE_DEFINITION)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// if there's a list after this, paragraph is over
0000000000000000000000000000000000000000;;			if p.flags&EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK != 0 {
0000000000000000000000000000000000000000;;				if p.uliPrefix(current) != 0 ||
0000000000000000000000000000000000000000;;					p.oliPrefix(current) != 0 ||
0000000000000000000000000000000000000000;;					p.quotePrefix(current) != 0 ||
0000000000000000000000000000000000000000;;					p.codePrefix(current) != 0 {
0000000000000000000000000000000000000000;;					p.renderParagraph(out, data[:i])
0000000000000000000000000000000000000000;;					return i
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// otherwise, scan to the beginning of the next line
0000000000000000000000000000000000000000;;			for data[i] != '\n' {
0000000000000000000000000000000000000000;;				i++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		p.renderParagraph(out, data[:i])
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
