0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Blackfriday Markdown Processor
0000000000000000000000000000000000000000;;	// Available at http://github.com/russross/blackfriday
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Copyright Â© 2011 Russ Ross <russ@russross.com>.
0000000000000000000000000000000000000000;;	// Distributed under the Simplified BSD License.
0000000000000000000000000000000000000000;;	// See README.md for details.
0000000000000000000000000000000000000000;;	//
50f9755c60b2914e7a0c6daa6fbd3a38d2cab61c;Godeps/_workspace/src/github.com/russross/blackfriday/html.go[Godeps/_workspace/src/github.com/russross/blackfriday/html.go][vendor/github.com/russross/blackfriday/html.go];	
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// HTML rendering backend
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package blackfriday
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Html renderer configuration options.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		HTML_SKIP_HTML                 = 1 << iota // skip preformatted HTML blocks
0000000000000000000000000000000000000000;;		HTML_SKIP_STYLE                            // skip embedded <style> elements
0000000000000000000000000000000000000000;;		HTML_SKIP_IMAGES                           // skip embedded images
0000000000000000000000000000000000000000;;		HTML_SKIP_LINKS                            // skip all links
0000000000000000000000000000000000000000;;		HTML_SAFELINK                              // only link to trusted protocols
0000000000000000000000000000000000000000;;		HTML_NOFOLLOW_LINKS                        // only link with rel="nofollow"
0000000000000000000000000000000000000000;;		HTML_NOREFERRER_LINKS                      // only link with rel="noreferrer"
0000000000000000000000000000000000000000;;		HTML_HREF_TARGET_BLANK                     // add a blank target
0000000000000000000000000000000000000000;;		HTML_TOC                                   // generate a table of contents
0000000000000000000000000000000000000000;;		HTML_OMIT_CONTENTS                         // skip the main contents (for a standalone table of contents)
0000000000000000000000000000000000000000;;		HTML_COMPLETE_PAGE                         // generate a complete HTML page
0000000000000000000000000000000000000000;;		HTML_USE_XHTML                             // generate XHTML output instead of HTML
0000000000000000000000000000000000000000;;		HTML_USE_SMARTYPANTS                       // enable smart punctuation substitutions
0000000000000000000000000000000000000000;;		HTML_SMARTYPANTS_FRACTIONS                 // enable smart fractions (with HTML_USE_SMARTYPANTS)
0000000000000000000000000000000000000000;;		HTML_SMARTYPANTS_DASHES                    // enable smart dashes (with HTML_USE_SMARTYPANTS)
0000000000000000000000000000000000000000;;		HTML_SMARTYPANTS_LATEX_DASHES              // enable LaTeX-style dashes (with HTML_USE_SMARTYPANTS and HTML_SMARTYPANTS_DASHES)
0000000000000000000000000000000000000000;;		HTML_SMARTYPANTS_ANGLED_QUOTES             // enable angled double quotes (with HTML_USE_SMARTYPANTS) for double quotes rendering
0000000000000000000000000000000000000000;;		HTML_FOOTNOTE_RETURN_LINKS                 // generate a link at the end of a footnote to return to the source
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		alignments = []string{
0000000000000000000000000000000000000000;;			"left",
0000000000000000000000000000000000000000;;			"right",
0000000000000000000000000000000000000000;;			"center",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: improve this regexp to catch all possible entities:
0000000000000000000000000000000000000000;;		htmlEntity = regexp.MustCompile(`&[a-z]{2,5};`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type HtmlRendererParameters struct {
0000000000000000000000000000000000000000;;		// Prepend this text to each relative URL.
0000000000000000000000000000000000000000;;		AbsolutePrefix string
0000000000000000000000000000000000000000;;		// Add this text to each footnote anchor, to ensure uniqueness.
0000000000000000000000000000000000000000;;		FootnoteAnchorPrefix string
0000000000000000000000000000000000000000;;		// Show this text inside the <a> tag for a footnote return link, if the
0000000000000000000000000000000000000000;;		// HTML_FOOTNOTE_RETURN_LINKS flag is enabled. If blank, the string
0000000000000000000000000000000000000000;;		// <sup>[return]</sup> is used.
0000000000000000000000000000000000000000;;		FootnoteReturnLinkContents string
0000000000000000000000000000000000000000;;		// If set, add this text to the front of each Header ID, to ensure
0000000000000000000000000000000000000000;;		// uniqueness.
0000000000000000000000000000000000000000;;		HeaderIDPrefix string
0000000000000000000000000000000000000000;;		// If set, add this text to the back of each Header ID, to ensure uniqueness.
0000000000000000000000000000000000000000;;		HeaderIDSuffix string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Html is a type that implements the Renderer interface for HTML output.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Do not create this directly, instead use the HtmlRenderer function.
0000000000000000000000000000000000000000;;	type Html struct {
0000000000000000000000000000000000000000;;		flags    int    // HTML_* options
0000000000000000000000000000000000000000;;		closeTag string // how to end singleton tags: either " />" or ">"
0000000000000000000000000000000000000000;;		title    string // document title
0000000000000000000000000000000000000000;;		css      string // optional css file url (used with HTML_COMPLETE_PAGE)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parameters HtmlRendererParameters
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// table of contents data
0000000000000000000000000000000000000000;;		tocMarker    int
0000000000000000000000000000000000000000;;		headerCount  int
0000000000000000000000000000000000000000;;		currentLevel int
0000000000000000000000000000000000000000;;		toc          *bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Track header IDs to prevent ID collision in a single generation.
0000000000000000000000000000000000000000;;		headerIDs map[string]int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		smartypants *smartypantsRenderer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		xhtmlClose = " />"
0000000000000000000000000000000000000000;;		htmlClose  = ">"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// HtmlRenderer creates and configures an Html object, which
0000000000000000000000000000000000000000;;	// satisfies the Renderer interface.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// flags is a set of HTML_* options ORed together.
0000000000000000000000000000000000000000;;	// title is the title of the document, and css is a URL for the document's
0000000000000000000000000000000000000000;;	// stylesheet.
0000000000000000000000000000000000000000;;	// title and css are only used when HTML_COMPLETE_PAGE is selected.
0000000000000000000000000000000000000000;;	func HtmlRenderer(flags int, title string, css string) Renderer {
0000000000000000000000000000000000000000;;		return HtmlRendererWithParameters(flags, title, css, HtmlRendererParameters{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func HtmlRendererWithParameters(flags int, title string,
0000000000000000000000000000000000000000;;		css string, renderParameters HtmlRendererParameters) Renderer {
0000000000000000000000000000000000000000;;		// configure the rendering engine
0000000000000000000000000000000000000000;;		closeTag := htmlClose
0000000000000000000000000000000000000000;;		if flags&HTML_USE_XHTML != 0 {
0000000000000000000000000000000000000000;;			closeTag = xhtmlClose
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if renderParameters.FootnoteReturnLinkContents == "" {
0000000000000000000000000000000000000000;;			renderParameters.FootnoteReturnLinkContents = `<sup>[return]</sup>`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Html{
0000000000000000000000000000000000000000;;			flags:      flags,
0000000000000000000000000000000000000000;;			closeTag:   closeTag,
0000000000000000000000000000000000000000;;			title:      title,
0000000000000000000000000000000000000000;;			css:        css,
0000000000000000000000000000000000000000;;			parameters: renderParameters,
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			headerCount:  0,
0000000000000000000000000000000000000000;;			currentLevel: 0,
0000000000000000000000000000000000000000;;			toc:          new(bytes.Buffer),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			headerIDs: make(map[string]int),
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			smartypants: smartypants(flags),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Using if statements is a bit faster than a switch statement. As the compiler
0000000000000000000000000000000000000000;;	// improves, this should be unnecessary this is only worthwhile because
0000000000000000000000000000000000000000;;	// attrEscape is the single largest CPU user in normal use.
0000000000000000000000000000000000000000;;	// Also tried using map, but that gave a ~3x slowdown.
0000000000000000000000000000000000000000;;	func escapeSingleChar(char byte) (string, bool) {
0000000000000000000000000000000000000000;;		if char == '"' {
0000000000000000000000000000000000000000;;			return "&quot;", true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if char == '&' {
0000000000000000000000000000000000000000;;			return "&amp;", true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if char == '<' {
0000000000000000000000000000000000000000;;			return "&lt;", true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if char == '>' {
0000000000000000000000000000000000000000;;			return "&gt;", true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func attrEscape(out *bytes.Buffer, src []byte) {
0000000000000000000000000000000000000000;;		org := 0
0000000000000000000000000000000000000000;;		for i, ch := range src {
0000000000000000000000000000000000000000;;			if entity, ok := escapeSingleChar(ch); ok {
0000000000000000000000000000000000000000;;				if i > org {
0000000000000000000000000000000000000000;;					// copy all the normal characters since the last escape
0000000000000000000000000000000000000000;;					out.Write(src[org:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				org = i + 1
0000000000000000000000000000000000000000;;				out.WriteString(entity)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if org < len(src) {
0000000000000000000000000000000000000000;;			out.Write(src[org:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func entityEscapeWithSkip(out *bytes.Buffer, src []byte, skipRanges [][]int) {
0000000000000000000000000000000000000000;;		end := 0
0000000000000000000000000000000000000000;;		for _, rang := range skipRanges {
0000000000000000000000000000000000000000;;			attrEscape(out, src[end:rang[0]])
0000000000000000000000000000000000000000;;			out.Write(src[rang[0]:rang[1]])
0000000000000000000000000000000000000000;;			end = rang[1]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		attrEscape(out, src[end:])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) GetFlags() int {
0000000000000000000000000000000000000000;;		return options.flags
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TitleBlock(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		text = bytes.TrimPrefix(text, []byte("% "))
0000000000000000000000000000000000000000;;		text = bytes.Replace(text, []byte("\n% "), []byte("\n"), -1)
0000000000000000000000000000000000000000;;		out.WriteString("<h1 class=\"title\">")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("\n</h1>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Header(out *bytes.Buffer, text func() bool, level int, id string) {
0000000000000000000000000000000000000000;;		marker := out.Len()
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if id == "" && options.flags&HTML_TOC != 0 {
0000000000000000000000000000000000000000;;			id = fmt.Sprintf("toc_%d", options.headerCount)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if id != "" {
0000000000000000000000000000000000000000;;			id = options.ensureUniqueHeaderID(id)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if options.parameters.HeaderIDPrefix != "" {
0000000000000000000000000000000000000000;;				id = options.parameters.HeaderIDPrefix + id
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if options.parameters.HeaderIDSuffix != "" {
0000000000000000000000000000000000000000;;				id = id + options.parameters.HeaderIDSuffix
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			out.WriteString(fmt.Sprintf("<h%d id=\"%s\">", level, id))
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString(fmt.Sprintf("<h%d>", level))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tocMarker := out.Len()
0000000000000000000000000000000000000000;;		if !text() {
0000000000000000000000000000000000000000;;			out.Truncate(marker)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// are we building a table of contents?
0000000000000000000000000000000000000000;;		if options.flags&HTML_TOC != 0 {
0000000000000000000000000000000000000000;;			options.TocHeaderWithAnchor(out.Bytes()[tocMarker:], level, id)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString(fmt.Sprintf("</h%d>\n", level))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) BlockHtml(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		if options.flags&HTML_SKIP_HTML != 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteByte('\n')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) HRule(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;		out.WriteString("<hr")
0000000000000000000000000000000000000000;;		out.WriteString(options.closeTag)
0000000000000000000000000000000000000000;;		out.WriteByte('\n')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) BlockCode(out *bytes.Buffer, text []byte, lang string) {
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parse out the language names/classes
0000000000000000000000000000000000000000;;		count := 0
0000000000000000000000000000000000000000;;		for _, elt := range strings.Fields(lang) {
0000000000000000000000000000000000000000;;			if elt[0] == '.' {
0000000000000000000000000000000000000000;;				elt = elt[1:]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if len(elt) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if count == 0 {
0000000000000000000000000000000000000000;;				out.WriteString("<pre><code class=\"language-")
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out.WriteByte(' ')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			attrEscape(out, []byte(elt))
0000000000000000000000000000000000000000;;			count++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if count == 0 {
0000000000000000000000000000000000000000;;			out.WriteString("<pre><code>")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("\">")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		attrEscape(out, text)
0000000000000000000000000000000000000000;;		out.WriteString("</code></pre>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) BlockQuote(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;		out.WriteString("<blockquote>\n")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("</blockquote>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Table(out *bytes.Buffer, header []byte, body []byte, columnData []int) {
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;		out.WriteString("<table>\n<thead>\n")
0000000000000000000000000000000000000000;;		out.Write(header)
0000000000000000000000000000000000000000;;		out.WriteString("</thead>\n\n<tbody>\n")
0000000000000000000000000000000000000000;;		out.Write(body)
0000000000000000000000000000000000000000;;		out.WriteString("</tbody>\n</table>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TableRow(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;		out.WriteString("<tr>\n")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("\n</tr>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TableHeaderCell(out *bytes.Buffer, text []byte, align int) {
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;		switch align {
0000000000000000000000000000000000000000;;		case TABLE_ALIGNMENT_LEFT:
0000000000000000000000000000000000000000;;			out.WriteString("<th align=\"left\">")
0000000000000000000000000000000000000000;;		case TABLE_ALIGNMENT_RIGHT:
0000000000000000000000000000000000000000;;			out.WriteString("<th align=\"right\">")
0000000000000000000000000000000000000000;;		case TABLE_ALIGNMENT_CENTER:
0000000000000000000000000000000000000000;;			out.WriteString("<th align=\"center\">")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			out.WriteString("<th>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("</th>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TableCell(out *bytes.Buffer, text []byte, align int) {
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;		switch align {
0000000000000000000000000000000000000000;;		case TABLE_ALIGNMENT_LEFT:
0000000000000000000000000000000000000000;;			out.WriteString("<td align=\"left\">")
0000000000000000000000000000000000000000;;		case TABLE_ALIGNMENT_RIGHT:
0000000000000000000000000000000000000000;;			out.WriteString("<td align=\"right\">")
0000000000000000000000000000000000000000;;		case TABLE_ALIGNMENT_CENTER:
0000000000000000000000000000000000000000;;			out.WriteString("<td align=\"center\">")
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			out.WriteString("<td>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("</td>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Footnotes(out *bytes.Buffer, text func() bool) {
0000000000000000000000000000000000000000;;		out.WriteString("<div class=\"footnotes\">\n")
0000000000000000000000000000000000000000;;		options.HRule(out)
0000000000000000000000000000000000000000;;		options.List(out, text, LIST_TYPE_ORDERED)
0000000000000000000000000000000000000000;;		out.WriteString("</div>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) FootnoteItem(out *bytes.Buffer, name, text []byte, flags int) {
0000000000000000000000000000000000000000;;		if flags&LIST_ITEM_CONTAINS_BLOCK != 0 || flags&LIST_ITEM_BEGINNING_OF_LIST != 0 {
0000000000000000000000000000000000000000;;			doubleSpace(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		slug := slugify(name)
0000000000000000000000000000000000000000;;		out.WriteString(`<li id="`)
0000000000000000000000000000000000000000;;		out.WriteString(`fn:`)
0000000000000000000000000000000000000000;;		out.WriteString(options.parameters.FootnoteAnchorPrefix)
0000000000000000000000000000000000000000;;		out.Write(slug)
0000000000000000000000000000000000000000;;		out.WriteString(`">`)
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		if options.flags&HTML_FOOTNOTE_RETURN_LINKS != 0 {
0000000000000000000000000000000000000000;;			out.WriteString(` <a class="footnote-return" href="#`)
0000000000000000000000000000000000000000;;			out.WriteString(`fnref:`)
0000000000000000000000000000000000000000;;			out.WriteString(options.parameters.FootnoteAnchorPrefix)
0000000000000000000000000000000000000000;;			out.Write(slug)
0000000000000000000000000000000000000000;;			out.WriteString(`">`)
0000000000000000000000000000000000000000;;			out.WriteString(options.parameters.FootnoteReturnLinkContents)
0000000000000000000000000000000000000000;;			out.WriteString(`</a>`)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("</li>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) List(out *bytes.Buffer, text func() bool, flags int) {
0000000000000000000000000000000000000000;;		marker := out.Len()
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if flags&LIST_TYPE_DEFINITION != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("<dl>")
0000000000000000000000000000000000000000;;		} else if flags&LIST_TYPE_ORDERED != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("<ol>")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("<ul>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !text() {
0000000000000000000000000000000000000000;;			out.Truncate(marker)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flags&LIST_TYPE_DEFINITION != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("</dl>\n")
0000000000000000000000000000000000000000;;		} else if flags&LIST_TYPE_ORDERED != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("</ol>\n")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("</ul>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) ListItem(out *bytes.Buffer, text []byte, flags int) {
0000000000000000000000000000000000000000;;		if (flags&LIST_ITEM_CONTAINS_BLOCK != 0 && flags&LIST_TYPE_DEFINITION == 0) ||
0000000000000000000000000000000000000000;;			flags&LIST_ITEM_BEGINNING_OF_LIST != 0 {
0000000000000000000000000000000000000000;;			doubleSpace(out)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if flags&LIST_TYPE_TERM != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("<dt>")
0000000000000000000000000000000000000000;;		} else if flags&LIST_TYPE_DEFINITION != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("<dd>")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("<li>")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		if flags&LIST_TYPE_TERM != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("</dt>\n")
0000000000000000000000000000000000000000;;		} else if flags&LIST_TYPE_DEFINITION != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("</dd>\n")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("</li>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Paragraph(out *bytes.Buffer, text func() bool) {
0000000000000000000000000000000000000000;;		marker := out.Len()
0000000000000000000000000000000000000000;;		doubleSpace(out)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString("<p>")
0000000000000000000000000000000000000000;;		if !text() {
0000000000000000000000000000000000000000;;			out.Truncate(marker)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("</p>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) AutoLink(out *bytes.Buffer, link []byte, kind int) {
0000000000000000000000000000000000000000;;		skipRanges := htmlEntity.FindAllIndex(link, -1)
0000000000000000000000000000000000000000;;		if options.flags&HTML_SAFELINK != 0 && !isSafeLink(link) && kind != LINK_TYPE_EMAIL {
0000000000000000000000000000000000000000;;			// mark it but don't link it if it is not a safe link: no smartypants
0000000000000000000000000000000000000000;;			out.WriteString("<tt>")
0000000000000000000000000000000000000000;;			entityEscapeWithSkip(out, link, skipRanges)
0000000000000000000000000000000000000000;;			out.WriteString("</tt>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString("<a href=\"")
0000000000000000000000000000000000000000;;		if kind == LINK_TYPE_EMAIL {
0000000000000000000000000000000000000000;;			out.WriteString("mailto:")
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			options.maybeWriteAbsolutePrefix(out, link)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		entityEscapeWithSkip(out, link, skipRanges)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var relAttrs []string
0000000000000000000000000000000000000000;;		if options.flags&HTML_NOFOLLOW_LINKS != 0 && !isRelativeLink(link) {
0000000000000000000000000000000000000000;;			relAttrs = append(relAttrs, "nofollow")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.flags&HTML_NOREFERRER_LINKS != 0 && !isRelativeLink(link) {
0000000000000000000000000000000000000000;;			relAttrs = append(relAttrs, "noreferrer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(relAttrs) > 0 {
0000000000000000000000000000000000000000;;			out.WriteString(fmt.Sprintf("\" rel=\"%s", strings.Join(relAttrs, " ")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// blank target only add to external link
0000000000000000000000000000000000000000;;		if options.flags&HTML_HREF_TARGET_BLANK != 0 && !isRelativeLink(link) {
0000000000000000000000000000000000000000;;			out.WriteString("\" target=\"_blank")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString("\">")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Pretty print: if we get an email address as
0000000000000000000000000000000000000000;;		// an actual URI, e.g. `mailto:foo@bar.com`, we don't
0000000000000000000000000000000000000000;;		// want to print the `mailto:` prefix
0000000000000000000000000000000000000000;;		switch {
0000000000000000000000000000000000000000;;		case bytes.HasPrefix(link, []byte("mailto://")):
0000000000000000000000000000000000000000;;			attrEscape(out, link[len("mailto://"):])
0000000000000000000000000000000000000000;;		case bytes.HasPrefix(link, []byte("mailto:")):
0000000000000000000000000000000000000000;;			attrEscape(out, link[len("mailto:"):])
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			entityEscapeWithSkip(out, link, skipRanges)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString("</a>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) CodeSpan(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("<code>")
0000000000000000000000000000000000000000;;		attrEscape(out, text)
0000000000000000000000000000000000000000;;		out.WriteString("</code>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) DoubleEmphasis(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("<strong>")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("</strong>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Emphasis(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		if len(text) == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("<em>")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("</em>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) maybeWriteAbsolutePrefix(out *bytes.Buffer, link []byte) {
0000000000000000000000000000000000000000;;		if options.parameters.AbsolutePrefix != "" && isRelativeLink(link) && link[0] != '.' {
0000000000000000000000000000000000000000;;			out.WriteString(options.parameters.AbsolutePrefix)
0000000000000000000000000000000000000000;;			if link[0] != '/' {
0000000000000000000000000000000000000000;;				out.WriteByte('/')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Image(out *bytes.Buffer, link []byte, title []byte, alt []byte) {
0000000000000000000000000000000000000000;;		if options.flags&HTML_SKIP_IMAGES != 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString("<img src=\"")
0000000000000000000000000000000000000000;;		options.maybeWriteAbsolutePrefix(out, link)
0000000000000000000000000000000000000000;;		attrEscape(out, link)
0000000000000000000000000000000000000000;;		out.WriteString("\" alt=\"")
0000000000000000000000000000000000000000;;		if len(alt) > 0 {
0000000000000000000000000000000000000000;;			attrEscape(out, alt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(title) > 0 {
0000000000000000000000000000000000000000;;			out.WriteString("\" title=\"")
0000000000000000000000000000000000000000;;			attrEscape(out, title)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteByte('"')
0000000000000000000000000000000000000000;;		out.WriteString(options.closeTag)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) LineBreak(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		out.WriteString("<br")
0000000000000000000000000000000000000000;;		out.WriteString(options.closeTag)
0000000000000000000000000000000000000000;;		out.WriteByte('\n')
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Link(out *bytes.Buffer, link []byte, title []byte, content []byte) {
0000000000000000000000000000000000000000;;		if options.flags&HTML_SKIP_LINKS != 0 {
0000000000000000000000000000000000000000;;			// write the link text out but don't link it, just mark it with typewriter font
0000000000000000000000000000000000000000;;			out.WriteString("<tt>")
0000000000000000000000000000000000000000;;			attrEscape(out, content)
0000000000000000000000000000000000000000;;			out.WriteString("</tt>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.flags&HTML_SAFELINK != 0 && !isSafeLink(link) {
0000000000000000000000000000000000000000;;			// write the link text out but don't link it, just mark it with typewriter font
0000000000000000000000000000000000000000;;			out.WriteString("<tt>")
0000000000000000000000000000000000000000;;			attrEscape(out, content)
0000000000000000000000000000000000000000;;			out.WriteString("</tt>")
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString("<a href=\"")
0000000000000000000000000000000000000000;;		options.maybeWriteAbsolutePrefix(out, link)
0000000000000000000000000000000000000000;;		attrEscape(out, link)
0000000000000000000000000000000000000000;;		if len(title) > 0 {
0000000000000000000000000000000000000000;;			out.WriteString("\" title=\"")
0000000000000000000000000000000000000000;;			attrEscape(out, title)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var relAttrs []string
0000000000000000000000000000000000000000;;		if options.flags&HTML_NOFOLLOW_LINKS != 0 && !isRelativeLink(link) {
0000000000000000000000000000000000000000;;			relAttrs = append(relAttrs, "nofollow")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.flags&HTML_NOREFERRER_LINKS != 0 && !isRelativeLink(link) {
0000000000000000000000000000000000000000;;			relAttrs = append(relAttrs, "noreferrer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(relAttrs) > 0 {
0000000000000000000000000000000000000000;;			out.WriteString(fmt.Sprintf("\" rel=\"%s", strings.Join(relAttrs, " ")))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// blank target only add to external link
0000000000000000000000000000000000000000;;		if options.flags&HTML_HREF_TARGET_BLANK != 0 && !isRelativeLink(link) {
0000000000000000000000000000000000000000;;			out.WriteString("\" target=\"_blank")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		out.WriteString("\">")
0000000000000000000000000000000000000000;;		out.Write(content)
0000000000000000000000000000000000000000;;		out.WriteString("</a>")
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) RawHtmlTag(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		if options.flags&HTML_SKIP_HTML != 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.flags&HTML_SKIP_STYLE != 0 && isHtmlTag(text, "style") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.flags&HTML_SKIP_LINKS != 0 && isHtmlTag(text, "a") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.flags&HTML_SKIP_IMAGES != 0 && isHtmlTag(text, "img") {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TripleEmphasis(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("<strong><em>")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("</em></strong>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) StrikeThrough(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		out.WriteString("<del>")
0000000000000000000000000000000000000000;;		out.Write(text)
0000000000000000000000000000000000000000;;		out.WriteString("</del>")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) FootnoteRef(out *bytes.Buffer, ref []byte, id int) {
0000000000000000000000000000000000000000;;		slug := slugify(ref)
0000000000000000000000000000000000000000;;		out.WriteString(`<sup class="footnote-ref" id="`)
0000000000000000000000000000000000000000;;		out.WriteString(`fnref:`)
0000000000000000000000000000000000000000;;		out.WriteString(options.parameters.FootnoteAnchorPrefix)
0000000000000000000000000000000000000000;;		out.Write(slug)
0000000000000000000000000000000000000000;;		out.WriteString(`"><a rel="footnote" href="#`)
0000000000000000000000000000000000000000;;		out.WriteString(`fn:`)
0000000000000000000000000000000000000000;;		out.WriteString(options.parameters.FootnoteAnchorPrefix)
0000000000000000000000000000000000000000;;		out.Write(slug)
0000000000000000000000000000000000000000;;		out.WriteString(`">`)
0000000000000000000000000000000000000000;;		out.WriteString(strconv.Itoa(id))
0000000000000000000000000000000000000000;;		out.WriteString(`</a></sup>`)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Entity(out *bytes.Buffer, entity []byte) {
0000000000000000000000000000000000000000;;		out.Write(entity)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) NormalText(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		if options.flags&HTML_USE_SMARTYPANTS != 0 {
0000000000000000000000000000000000000000;;			options.Smartypants(out, text)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			attrEscape(out, text)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) Smartypants(out *bytes.Buffer, text []byte) {
0000000000000000000000000000000000000000;;		smrt := smartypantsData{false, false}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// first do normal entity escaping
0000000000000000000000000000000000000000;;		var escaped bytes.Buffer
0000000000000000000000000000000000000000;;		attrEscape(&escaped, text)
0000000000000000000000000000000000000000;;		text = escaped.Bytes()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mark := 0
0000000000000000000000000000000000000000;;		for i := 0; i < len(text); i++ {
0000000000000000000000000000000000000000;;			if action := options.smartypants[text[i]]; action != nil {
0000000000000000000000000000000000000000;;				if i > mark {
0000000000000000000000000000000000000000;;					out.Write(text[mark:i])
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				previousChar := byte(0)
0000000000000000000000000000000000000000;;				if i > 0 {
0000000000000000000000000000000000000000;;					previousChar = text[i-1]
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				i += action(out, &smrt, previousChar, text[i:])
0000000000000000000000000000000000000000;;				mark = i + 1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if mark < len(text) {
0000000000000000000000000000000000000000;;			out.Write(text[mark:])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) DocumentHeader(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		if options.flags&HTML_COMPLETE_PAGE == 0 {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ending := ""
0000000000000000000000000000000000000000;;		if options.flags&HTML_USE_XHTML != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" ")
0000000000000000000000000000000000000000;;			out.WriteString("\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n")
0000000000000000000000000000000000000000;;			out.WriteString("<html xmlns=\"http://www.w3.org/1999/xhtml\">\n")
0000000000000000000000000000000000000000;;			ending = " /"
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			out.WriteString("<!DOCTYPE html>\n")
0000000000000000000000000000000000000000;;			out.WriteString("<html>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("<head>\n")
0000000000000000000000000000000000000000;;		out.WriteString("  <title>")
0000000000000000000000000000000000000000;;		options.NormalText(out, []byte(options.title))
0000000000000000000000000000000000000000;;		out.WriteString("</title>\n")
0000000000000000000000000000000000000000;;		out.WriteString("  <meta name=\"GENERATOR\" content=\"Blackfriday Markdown Processor v")
0000000000000000000000000000000000000000;;		out.WriteString(VERSION)
0000000000000000000000000000000000000000;;		out.WriteString("\"")
0000000000000000000000000000000000000000;;		out.WriteString(ending)
0000000000000000000000000000000000000000;;		out.WriteString(">\n")
0000000000000000000000000000000000000000;;		out.WriteString("  <meta charset=\"utf-8\"")
0000000000000000000000000000000000000000;;		out.WriteString(ending)
0000000000000000000000000000000000000000;;		out.WriteString(">\n")
0000000000000000000000000000000000000000;;		if options.css != "" {
0000000000000000000000000000000000000000;;			out.WriteString("  <link rel=\"stylesheet\" type=\"text/css\" href=\"")
0000000000000000000000000000000000000000;;			attrEscape(out, []byte(options.css))
0000000000000000000000000000000000000000;;			out.WriteString("\"")
0000000000000000000000000000000000000000;;			out.WriteString(ending)
0000000000000000000000000000000000000000;;			out.WriteString(">\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		out.WriteString("</head>\n")
0000000000000000000000000000000000000000;;		out.WriteString("<body>\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options.tocMarker = out.Len()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) DocumentFooter(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		// finalize and insert the table of contents
0000000000000000000000000000000000000000;;		if options.flags&HTML_TOC != 0 {
0000000000000000000000000000000000000000;;			options.TocFinalize()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// now we have to insert the table of contents into the document
0000000000000000000000000000000000000000;;			var temp bytes.Buffer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// start by making a copy of everything after the document header
0000000000000000000000000000000000000000;;			temp.Write(out.Bytes()[options.tocMarker:])
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// now clear the copied material from the main output buffer
0000000000000000000000000000000000000000;;			out.Truncate(options.tocMarker)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// corner case spacing issue
0000000000000000000000000000000000000000;;			if options.flags&HTML_COMPLETE_PAGE != 0 {
0000000000000000000000000000000000000000;;				out.WriteByte('\n')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// insert the table of contents
0000000000000000000000000000000000000000;;			out.WriteString("<nav>\n")
0000000000000000000000000000000000000000;;			out.Write(options.toc.Bytes())
0000000000000000000000000000000000000000;;			out.WriteString("</nav>\n")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// corner case spacing issue
0000000000000000000000000000000000000000;;			if options.flags&HTML_COMPLETE_PAGE == 0 && options.flags&HTML_OMIT_CONTENTS == 0 {
0000000000000000000000000000000000000000;;				out.WriteByte('\n')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// write out everything that came after it
0000000000000000000000000000000000000000;;			if options.flags&HTML_OMIT_CONTENTS == 0 {
0000000000000000000000000000000000000000;;				out.Write(temp.Bytes())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.flags&HTML_COMPLETE_PAGE != 0 {
0000000000000000000000000000000000000000;;			out.WriteString("\n</body>\n")
0000000000000000000000000000000000000000;;			out.WriteString("</html>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TocHeaderWithAnchor(text []byte, level int, anchor string) {
0000000000000000000000000000000000000000;;		for level > options.currentLevel {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case bytes.HasSuffix(options.toc.Bytes(), []byte("</li>\n")):
0000000000000000000000000000000000000000;;				// this sublist can nest underneath a header
0000000000000000000000000000000000000000;;				size := options.toc.Len()
0000000000000000000000000000000000000000;;				options.toc.Truncate(size - len("</li>\n"))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			case options.currentLevel > 0:
0000000000000000000000000000000000000000;;				options.toc.WriteString("<li>")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if options.toc.Len() > 0 {
0000000000000000000000000000000000000000;;				options.toc.WriteByte('\n')
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options.toc.WriteString("<ul>\n")
0000000000000000000000000000000000000000;;			options.currentLevel++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for level < options.currentLevel {
0000000000000000000000000000000000000000;;			options.toc.WriteString("</ul>")
0000000000000000000000000000000000000000;;			if options.currentLevel > 1 {
0000000000000000000000000000000000000000;;				options.toc.WriteString("</li>\n")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			options.currentLevel--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options.toc.WriteString("<li><a href=\"#")
0000000000000000000000000000000000000000;;		if anchor != "" {
0000000000000000000000000000000000000000;;			options.toc.WriteString(anchor)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			options.toc.WriteString("toc_")
0000000000000000000000000000000000000000;;			options.toc.WriteString(strconv.Itoa(options.headerCount))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		options.toc.WriteString("\">")
0000000000000000000000000000000000000000;;		options.headerCount++
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options.toc.Write(text)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		options.toc.WriteString("</a></li>\n")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TocHeader(text []byte, level int) {
0000000000000000000000000000000000000000;;		options.TocHeaderWithAnchor(text, level, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) TocFinalize() {
0000000000000000000000000000000000000000;;		for options.currentLevel > 1 {
0000000000000000000000000000000000000000;;			options.toc.WriteString("</ul></li>\n")
0000000000000000000000000000000000000000;;			options.currentLevel--
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.currentLevel > 0 {
0000000000000000000000000000000000000000;;			options.toc.WriteString("</ul>\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isHtmlTag(tag []byte, tagname string) bool {
0000000000000000000000000000000000000000;;		found, _ := findHtmlTagPos(tag, tagname)
0000000000000000000000000000000000000000;;		return found
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Look for a character, but ignore it when it's in any kind of quotes, it
0000000000000000000000000000000000000000;;	// might be JavaScript
0000000000000000000000000000000000000000;;	func skipUntilCharIgnoreQuotes(html []byte, start int, char byte) int {
0000000000000000000000000000000000000000;;		inSingleQuote := false
0000000000000000000000000000000000000000;;		inDoubleQuote := false
0000000000000000000000000000000000000000;;		inGraveQuote := false
0000000000000000000000000000000000000000;;		i := start
0000000000000000000000000000000000000000;;		for i < len(html) {
0000000000000000000000000000000000000000;;			switch {
0000000000000000000000000000000000000000;;			case html[i] == char && !inSingleQuote && !inDoubleQuote && !inGraveQuote:
0000000000000000000000000000000000000000;;				return i
0000000000000000000000000000000000000000;;			case html[i] == '\'':
0000000000000000000000000000000000000000;;				inSingleQuote = !inSingleQuote
0000000000000000000000000000000000000000;;			case html[i] == '"':
0000000000000000000000000000000000000000;;				inDoubleQuote = !inDoubleQuote
0000000000000000000000000000000000000000;;			case html[i] == '`':
0000000000000000000000000000000000000000;;				inGraveQuote = !inGraveQuote
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return start
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func findHtmlTagPos(tag []byte, tagname string) (bool, int) {
0000000000000000000000000000000000000000;;		i := 0
0000000000000000000000000000000000000000;;		if i < len(tag) && tag[0] != '<' {
0000000000000000000000000000000000000000;;			return false, -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		i++
0000000000000000000000000000000000000000;;		i = skipSpace(tag, i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i < len(tag) && tag[i] == '/' {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		i = skipSpace(tag, i)
0000000000000000000000000000000000000000;;		j := 0
0000000000000000000000000000000000000000;;		for ; i < len(tag); i, j = i+1, j+1 {
0000000000000000000000000000000000000000;;			if j >= len(tagname) {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if strings.ToLower(string(tag[i]))[0] != tagname[j] {
0000000000000000000000000000000000000000;;				return false, -1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if i == len(tag) {
0000000000000000000000000000000000000000;;			return false, -1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rightAngle := skipUntilCharIgnoreQuotes(tag, i, '>')
0000000000000000000000000000000000000000;;		if rightAngle > i {
0000000000000000000000000000000000000000;;			return true, rightAngle
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false, -1
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func skipUntilChar(text []byte, start int, char byte) int {
0000000000000000000000000000000000000000;;		i := start
0000000000000000000000000000000000000000;;		for i < len(text) && text[i] != char {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func skipSpace(tag []byte, i int) int {
0000000000000000000000000000000000000000;;		for i < len(tag) && isspace(tag[i]) {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func skipChar(data []byte, start int, char byte) int {
0000000000000000000000000000000000000000;;		i := start
0000000000000000000000000000000000000000;;		for i < len(data) && data[i] == char {
0000000000000000000000000000000000000000;;			i++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func doubleSpace(out *bytes.Buffer) {
0000000000000000000000000000000000000000;;		if out.Len() > 0 {
0000000000000000000000000000000000000000;;			out.WriteByte('\n')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isRelativeLink(link []byte) (yes bool) {
0000000000000000000000000000000000000000;;		// a tag begin with '#'
0000000000000000000000000000000000000000;;		if link[0] == '#' {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// link begin with '/' but not '//', the second maybe a protocol relative link
0000000000000000000000000000000000000000;;		if len(link) >= 2 && link[0] == '/' && link[1] != '/' {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// only the root '/'
0000000000000000000000000000000000000000;;		if len(link) == 1 && link[0] == '/' {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// current directory : begin with "./"
0000000000000000000000000000000000000000;;		if bytes.HasPrefix(link, []byte("./")) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// parent directory : begin with "../"
0000000000000000000000000000000000000000;;		if bytes.HasPrefix(link, []byte("../")) {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options *Html) ensureUniqueHeaderID(id string) string {
0000000000000000000000000000000000000000;;		for count, found := options.headerIDs[id]; found; count, found = options.headerIDs[id] {
0000000000000000000000000000000000000000;;			tmp := fmt.Sprintf("%s-%d", id, count+1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if _, tmpFound := options.headerIDs[tmp]; !tmpFound {
0000000000000000000000000000000000000000;;				options.headerIDs[id] = count + 1
0000000000000000000000000000000000000000;;				id = tmp
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				id = id + "-1"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if _, found := options.headerIDs[id]; !found {
0000000000000000000000000000000000000000;;			options.headerIDs[id] = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return id
0000000000000000000000000000000000000000;;	}
