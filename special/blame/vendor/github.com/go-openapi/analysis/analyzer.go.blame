0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package analysis
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		slashpath "path"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonpointer"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type referenceAnalysis struct {
0000000000000000000000000000000000000000;;		schemas    map[string]spec.Ref
0000000000000000000000000000000000000000;;		responses  map[string]spec.Ref
0000000000000000000000000000000000000000;;		parameters map[string]spec.Ref
0000000000000000000000000000000000000000;;		items      map[string]spec.Ref
0000000000000000000000000000000000000000;;		allRefs    map[string]spec.Ref
0000000000000000000000000000000000000000;;		referenced struct {
0000000000000000000000000000000000000000;;			schemas    map[string]SchemaRef
0000000000000000000000000000000000000000;;			responses  map[string]*spec.Response
0000000000000000000000000000000000000000;;			parameters map[string]*spec.Parameter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *referenceAnalysis) addRef(key string, ref spec.Ref) {
0000000000000000000000000000000000000000;;		r.allRefs["#"+key] = ref
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *referenceAnalysis) addItemsRef(key string, items *spec.Items) {
0000000000000000000000000000000000000000;;		r.items["#"+key] = items.Ref
0000000000000000000000000000000000000000;;		r.addRef(key, items.Ref)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *referenceAnalysis) addSchemaRef(key string, ref SchemaRef) {
0000000000000000000000000000000000000000;;		r.schemas["#"+key] = ref.Schema.Ref
0000000000000000000000000000000000000000;;		r.addRef(key, ref.Schema.Ref)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *referenceAnalysis) addResponseRef(key string, resp *spec.Response) {
0000000000000000000000000000000000000000;;		r.responses["#"+key] = resp.Ref
0000000000000000000000000000000000000000;;		r.addRef(key, resp.Ref)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *referenceAnalysis) addParamRef(key string, param *spec.Parameter) {
0000000000000000000000000000000000000000;;		r.parameters["#"+key] = param.Ref
0000000000000000000000000000000000000000;;		r.addRef(key, param.Ref)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New takes a swagger spec object and returns an analyzed spec document.
0000000000000000000000000000000000000000;;	// The analyzed document contains a number of indices that make it easier to
0000000000000000000000000000000000000000;;	// reason about semantics of a swagger specification for use in code generation
0000000000000000000000000000000000000000;;	// or validation etc.
0000000000000000000000000000000000000000;;	func New(doc *spec.Swagger) *Spec {
0000000000000000000000000000000000000000;;		a := &Spec{
0000000000000000000000000000000000000000;;			spec:        doc,
0000000000000000000000000000000000000000;;			consumes:    make(map[string]struct{}, 150),
0000000000000000000000000000000000000000;;			produces:    make(map[string]struct{}, 150),
0000000000000000000000000000000000000000;;			authSchemes: make(map[string]struct{}, 150),
0000000000000000000000000000000000000000;;			operations:  make(map[string]map[string]*spec.Operation, 150),
0000000000000000000000000000000000000000;;			allSchemas:  make(map[string]SchemaRef, 150),
0000000000000000000000000000000000000000;;			allOfs:      make(map[string]SchemaRef, 150),
0000000000000000000000000000000000000000;;			references: referenceAnalysis{
0000000000000000000000000000000000000000;;				schemas:    make(map[string]spec.Ref, 150),
0000000000000000000000000000000000000000;;				responses:  make(map[string]spec.Ref, 150),
0000000000000000000000000000000000000000;;				parameters: make(map[string]spec.Ref, 150),
0000000000000000000000000000000000000000;;				items:      make(map[string]spec.Ref, 150),
0000000000000000000000000000000000000000;;				allRefs:    make(map[string]spec.Ref, 150),
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		a.references.referenced.schemas = make(map[string]SchemaRef, 150)
0000000000000000000000000000000000000000;;		a.references.referenced.responses = make(map[string]*spec.Response, 150)
0000000000000000000000000000000000000000;;		a.references.referenced.parameters = make(map[string]*spec.Parameter, 150)
0000000000000000000000000000000000000000;;		a.initialize()
0000000000000000000000000000000000000000;;		return a
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec takes a swagger spec object and turns it into a registry
0000000000000000000000000000000000000000;;	// with a bunch of utility methods to act on the information in the spec
0000000000000000000000000000000000000000;;	type Spec struct {
0000000000000000000000000000000000000000;;		spec        *spec.Swagger
0000000000000000000000000000000000000000;;		consumes    map[string]struct{}
0000000000000000000000000000000000000000;;		produces    map[string]struct{}
0000000000000000000000000000000000000000;;		authSchemes map[string]struct{}
0000000000000000000000000000000000000000;;		operations  map[string]map[string]*spec.Operation
0000000000000000000000000000000000000000;;		references  referenceAnalysis
0000000000000000000000000000000000000000;;		allSchemas  map[string]SchemaRef
0000000000000000000000000000000000000000;;		allOfs      map[string]SchemaRef
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Spec) initialize() {
0000000000000000000000000000000000000000;;		for _, c := range s.spec.Consumes {
0000000000000000000000000000000000000000;;			s.consumes[c] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range s.spec.Produces {
0000000000000000000000000000000000000000;;			s.produces[c] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ss := range s.spec.Security {
0000000000000000000000000000000000000000;;			for k := range ss {
0000000000000000000000000000000000000000;;				s.authSchemes[k] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for path, pathItem := range s.AllPaths() {
0000000000000000000000000000000000000000;;			s.analyzeOperations(path, &pathItem)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, parameter := range s.spec.Parameters {
0000000000000000000000000000000000000000;;			refPref := slashpath.Join("/parameters", jsonpointer.Escape(name))
0000000000000000000000000000000000000000;;			if parameter.Items != nil {
0000000000000000000000000000000000000000;;				s.analyzeItems("items", parameter.Items, refPref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if parameter.In == "body" && parameter.Schema != nil {
0000000000000000000000000000000000000000;;				s.analyzeSchema("schema", *parameter.Schema, refPref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, response := range s.spec.Responses {
0000000000000000000000000000000000000000;;			refPref := slashpath.Join("/responses", jsonpointer.Escape(name))
0000000000000000000000000000000000000000;;			for _, v := range response.Headers {
0000000000000000000000000000000000000000;;				if v.Items != nil {
0000000000000000000000000000000000000000;;					s.analyzeItems("items", v.Items, refPref)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if response.Schema != nil {
0000000000000000000000000000000000000000;;				s.analyzeSchema("schema", *response.Schema, refPref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for name, schema := range s.spec.Definitions {
0000000000000000000000000000000000000000;;			s.analyzeSchema(name, schema, "/definitions")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// TODO: after analyzing all things and flattening schemas etc
0000000000000000000000000000000000000000;;		// resolve all the collected references to their final representations
0000000000000000000000000000000000000000;;		// best put in a separate method because this could get expensive
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Spec) analyzeOperations(path string, pi *spec.PathItem) {
0000000000000000000000000000000000000000;;		// TODO: resolve refs here?
0000000000000000000000000000000000000000;;		op := pi
0000000000000000000000000000000000000000;;		s.analyzeOperation("GET", path, op.Get)
0000000000000000000000000000000000000000;;		s.analyzeOperation("PUT", path, op.Put)
0000000000000000000000000000000000000000;;		s.analyzeOperation("POST", path, op.Post)
0000000000000000000000000000000000000000;;		s.analyzeOperation("PATCH", path, op.Patch)
0000000000000000000000000000000000000000;;		s.analyzeOperation("DELETE", path, op.Delete)
0000000000000000000000000000000000000000;;		s.analyzeOperation("HEAD", path, op.Head)
0000000000000000000000000000000000000000;;		s.analyzeOperation("OPTIONS", path, op.Options)
0000000000000000000000000000000000000000;;		for i, param := range op.Parameters {
0000000000000000000000000000000000000000;;			refPref := slashpath.Join("/paths", jsonpointer.Escape(path), "parameters", strconv.Itoa(i))
0000000000000000000000000000000000000000;;			if param.Ref.String() != "" {
0000000000000000000000000000000000000000;;				s.references.addParamRef(refPref, &param)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if param.Items != nil {
0000000000000000000000000000000000000000;;				s.analyzeItems("items", param.Items, refPref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if param.Schema != nil {
0000000000000000000000000000000000000000;;				s.analyzeSchema("schema", *param.Schema, refPref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Spec) analyzeItems(name string, items *spec.Items, prefix string) {
0000000000000000000000000000000000000000;;		if items == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		refPref := slashpath.Join(prefix, name)
0000000000000000000000000000000000000000;;		s.analyzeItems(name, items.Items, refPref)
0000000000000000000000000000000000000000;;		if items.Ref.String() != "" {
0000000000000000000000000000000000000000;;			s.references.addItemsRef(refPref, items)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Spec) analyzeOperation(method, path string, op *spec.Operation) {
0000000000000000000000000000000000000000;;		if op == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, c := range op.Consumes {
0000000000000000000000000000000000000000;;			s.consumes[c] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, c := range op.Produces {
0000000000000000000000000000000000000000;;			s.produces[c] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, ss := range op.Security {
0000000000000000000000000000000000000000;;			for k := range ss {
0000000000000000000000000000000000000000;;				s.authSchemes[k] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if _, ok := s.operations[method]; !ok {
0000000000000000000000000000000000000000;;			s.operations[method] = make(map[string]*spec.Operation)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.operations[method][path] = op
0000000000000000000000000000000000000000;;		prefix := slashpath.Join("/paths", jsonpointer.Escape(path), strings.ToLower(method))
0000000000000000000000000000000000000000;;		for i, param := range op.Parameters {
0000000000000000000000000000000000000000;;			refPref := slashpath.Join(prefix, "parameters", strconv.Itoa(i))
0000000000000000000000000000000000000000;;			if param.Ref.String() != "" {
0000000000000000000000000000000000000000;;				s.references.addParamRef(refPref, &param)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.analyzeItems("items", param.Items, refPref)
0000000000000000000000000000000000000000;;			if param.In == "body" && param.Schema != nil {
0000000000000000000000000000000000000000;;				s.analyzeSchema("schema", *param.Schema, refPref)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if op.Responses != nil {
0000000000000000000000000000000000000000;;			if op.Responses.Default != nil {
0000000000000000000000000000000000000000;;				refPref := slashpath.Join(prefix, "responses", "default")
0000000000000000000000000000000000000000;;				if op.Responses.Default.Ref.String() != "" {
0000000000000000000000000000000000000000;;					s.references.addResponseRef(refPref, op.Responses.Default)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, v := range op.Responses.Default.Headers {
0000000000000000000000000000000000000000;;					s.analyzeItems("items", v.Items, refPref)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if op.Responses.Default.Schema != nil {
0000000000000000000000000000000000000000;;					s.analyzeSchema("schema", *op.Responses.Default.Schema, refPref)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for k, res := range op.Responses.StatusCodeResponses {
0000000000000000000000000000000000000000;;				refPref := slashpath.Join(prefix, "responses", strconv.Itoa(k))
0000000000000000000000000000000000000000;;				if res.Ref.String() != "" {
0000000000000000000000000000000000000000;;					s.references.addResponseRef(refPref, &res)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, v := range res.Headers {
0000000000000000000000000000000000000000;;					s.analyzeItems("items", v.Items, refPref)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if res.Schema != nil {
0000000000000000000000000000000000000000;;					s.analyzeSchema("schema", *res.Schema, refPref)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Spec) analyzeSchema(name string, schema spec.Schema, prefix string) {
0000000000000000000000000000000000000000;;		refURI := slashpath.Join(prefix, jsonpointer.Escape(name))
0000000000000000000000000000000000000000;;		schRef := SchemaRef{
0000000000000000000000000000000000000000;;			Name:   name,
0000000000000000000000000000000000000000;;			Schema: &schema,
0000000000000000000000000000000000000000;;			Ref:    spec.MustCreateRef("#" + refURI),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.allSchemas["#"+refURI] = schRef
0000000000000000000000000000000000000000;;		if schema.Ref.String() != "" {
0000000000000000000000000000000000000000;;			s.references.addSchemaRef(refURI, schRef)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range schema.Definitions {
0000000000000000000000000000000000000000;;			s.analyzeSchema(k, v, slashpath.Join(refURI, "definitions"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range schema.Properties {
0000000000000000000000000000000000000000;;			s.analyzeSchema(k, v, slashpath.Join(refURI, "properties"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range schema.PatternProperties {
0000000000000000000000000000000000000000;;			s.analyzeSchema(k, v, slashpath.Join(refURI, "patternProperties"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range schema.AllOf {
0000000000000000000000000000000000000000;;			s.analyzeSchema(strconv.Itoa(i), v, slashpath.Join(refURI, "allOf"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(schema.AllOf) > 0 {
0000000000000000000000000000000000000000;;			s.allOfs["#"+refURI] = SchemaRef{Name: name, Schema: &schema, Ref: spec.MustCreateRef("#" + refURI)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range schema.AnyOf {
0000000000000000000000000000000000000000;;			s.analyzeSchema(strconv.Itoa(i), v, slashpath.Join(refURI, "anyOf"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, v := range schema.OneOf {
0000000000000000000000000000000000000000;;			s.analyzeSchema(strconv.Itoa(i), v, slashpath.Join(refURI, "oneOf"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.Not != nil {
0000000000000000000000000000000000000000;;			s.analyzeSchema("not", *schema.Not, refURI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.AdditionalProperties != nil && schema.AdditionalProperties.Schema != nil {
0000000000000000000000000000000000000000;;			s.analyzeSchema("additionalProperties", *schema.AdditionalProperties.Schema, refURI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.AdditionalItems != nil && schema.AdditionalItems.Schema != nil {
0000000000000000000000000000000000000000;;			s.analyzeSchema("additionalItems", *schema.AdditionalItems.Schema, refURI)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if schema.Items != nil {
0000000000000000000000000000000000000000;;			if schema.Items.Schema != nil {
0000000000000000000000000000000000000000;;				s.analyzeSchema("items", *schema.Items.Schema, refURI)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, sch := range schema.Items.Schemas {
0000000000000000000000000000000000000000;;				s.analyzeSchema(strconv.Itoa(i), sch, slashpath.Join(refURI, "items"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecurityRequirement is a representation of a security requirement for an operation
0000000000000000000000000000000000000000;;	type SecurityRequirement struct {
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Scopes []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecurityRequirementsFor gets the security requirements for the operation
0000000000000000000000000000000000000000;;	func (s *Spec) SecurityRequirementsFor(operation *spec.Operation) []SecurityRequirement {
0000000000000000000000000000000000000000;;		if s.spec.Security == nil && operation.Security == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schemes := s.spec.Security
0000000000000000000000000000000000000000;;		if operation.Security != nil {
0000000000000000000000000000000000000000;;			schemes = operation.Security
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		unique := make(map[string]SecurityRequirement)
0000000000000000000000000000000000000000;;		for _, scheme := range schemes {
0000000000000000000000000000000000000000;;			for k, v := range scheme {
0000000000000000000000000000000000000000;;				if _, ok := unique[k]; !ok {
0000000000000000000000000000000000000000;;					unique[k] = SecurityRequirement{Name: k, Scopes: v}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result []SecurityRequirement
0000000000000000000000000000000000000000;;		for _, v := range unique {
0000000000000000000000000000000000000000;;			result = append(result, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecurityDefinitionsFor gets the matching security definitions for a set of requirements
0000000000000000000000000000000000000000;;	func (s *Spec) SecurityDefinitionsFor(operation *spec.Operation) map[string]spec.SecurityScheme {
0000000000000000000000000000000000000000;;		requirements := s.SecurityRequirementsFor(operation)
0000000000000000000000000000000000000000;;		if len(requirements) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make(map[string]spec.SecurityScheme)
0000000000000000000000000000000000000000;;		for _, v := range requirements {
0000000000000000000000000000000000000000;;			if definition, ok := s.spec.SecurityDefinitions[v.Name]; ok {
0000000000000000000000000000000000000000;;				if definition != nil {
0000000000000000000000000000000000000000;;					result[v.Name] = *definition
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConsumesFor gets the mediatypes for the operation
0000000000000000000000000000000000000000;;	func (s *Spec) ConsumesFor(operation *spec.Operation) []string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(operation.Consumes) == 0 {
0000000000000000000000000000000000000000;;			cons := make(map[string]struct{}, len(s.spec.Consumes))
0000000000000000000000000000000000000000;;			for _, k := range s.spec.Consumes {
0000000000000000000000000000000000000000;;				cons[k] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.structMapKeys(cons)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cons := make(map[string]struct{}, len(operation.Consumes))
0000000000000000000000000000000000000000;;		for _, c := range operation.Consumes {
0000000000000000000000000000000000000000;;			cons[c] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.structMapKeys(cons)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ProducesFor gets the mediatypes for the operation
0000000000000000000000000000000000000000;;	func (s *Spec) ProducesFor(operation *spec.Operation) []string {
0000000000000000000000000000000000000000;;		if len(operation.Produces) == 0 {
0000000000000000000000000000000000000000;;			prod := make(map[string]struct{}, len(s.spec.Produces))
0000000000000000000000000000000000000000;;			for _, k := range s.spec.Produces {
0000000000000000000000000000000000000000;;				prod[k] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return s.structMapKeys(prod)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		prod := make(map[string]struct{}, len(operation.Produces))
0000000000000000000000000000000000000000;;		for _, c := range operation.Produces {
0000000000000000000000000000000000000000;;			prod[c] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.structMapKeys(prod)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func mapKeyFromParam(param *spec.Parameter) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s#%s", param.In, fieldNameFromParam(param))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func fieldNameFromParam(param *spec.Parameter) string {
0000000000000000000000000000000000000000;;		if nm, ok := param.Extensions.GetString("go-name"); ok {
0000000000000000000000000000000000000000;;			return nm
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return swag.ToGoName(param.Name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Spec) paramsAsMap(parameters []spec.Parameter, res map[string]spec.Parameter) {
0000000000000000000000000000000000000000;;		for _, param := range parameters {
0000000000000000000000000000000000000000;;			pr := param
0000000000000000000000000000000000000000;;			if pr.Ref.String() != "" {
0000000000000000000000000000000000000000;;				obj, _, err := pr.Ref.GetPointer().Get(s.spec)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					panic(err)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				pr = obj.(spec.Parameter)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			res[mapKeyFromParam(&pr)] = pr
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParametersFor the specified operation id
0000000000000000000000000000000000000000;;	func (s *Spec) ParametersFor(operationID string) []spec.Parameter {
0000000000000000000000000000000000000000;;		gatherParams := func(pi *spec.PathItem, op *spec.Operation) []spec.Parameter {
0000000000000000000000000000000000000000;;			bag := make(map[string]spec.Parameter)
0000000000000000000000000000000000000000;;			s.paramsAsMap(pi.Parameters, bag)
0000000000000000000000000000000000000000;;			s.paramsAsMap(op.Parameters, bag)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var res []spec.Parameter
0000000000000000000000000000000000000000;;			for _, v := range bag {
0000000000000000000000000000000000000000;;				res = append(res, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, pi := range s.spec.Paths.Paths {
0000000000000000000000000000000000000000;;			if pi.Get != nil && pi.Get.ID == operationID {
0000000000000000000000000000000000000000;;				return gatherParams(&pi, pi.Get)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pi.Head != nil && pi.Head.ID == operationID {
0000000000000000000000000000000000000000;;				return gatherParams(&pi, pi.Head)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pi.Options != nil && pi.Options.ID == operationID {
0000000000000000000000000000000000000000;;				return gatherParams(&pi, pi.Options)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pi.Post != nil && pi.Post.ID == operationID {
0000000000000000000000000000000000000000;;				return gatherParams(&pi, pi.Post)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pi.Patch != nil && pi.Patch.ID == operationID {
0000000000000000000000000000000000000000;;				return gatherParams(&pi, pi.Patch)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pi.Put != nil && pi.Put.ID == operationID {
0000000000000000000000000000000000000000;;				return gatherParams(&pi, pi.Put)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if pi.Delete != nil && pi.Delete.ID == operationID {
0000000000000000000000000000000000000000;;				return gatherParams(&pi, pi.Delete)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParamsFor the specified method and path. Aggregates them with the defaults etc, so it's all the params that
0000000000000000000000000000000000000000;;	// apply for the method and path.
0000000000000000000000000000000000000000;;	func (s *Spec) ParamsFor(method, path string) map[string]spec.Parameter {
0000000000000000000000000000000000000000;;		res := make(map[string]spec.Parameter)
0000000000000000000000000000000000000000;;		if pi, ok := s.spec.Paths.Paths[path]; ok {
0000000000000000000000000000000000000000;;			s.paramsAsMap(pi.Parameters, res)
0000000000000000000000000000000000000000;;			s.paramsAsMap(s.operations[strings.ToUpper(method)][path].Parameters, res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OperationForName gets the operation for the given id
0000000000000000000000000000000000000000;;	func (s *Spec) OperationForName(operationID string) (string, string, *spec.Operation, bool) {
0000000000000000000000000000000000000000;;		for method, pathItem := range s.operations {
0000000000000000000000000000000000000000;;			for path, op := range pathItem {
0000000000000000000000000000000000000000;;				if operationID == op.ID {
0000000000000000000000000000000000000000;;					return method, path, op, true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", "", nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OperationFor the given method and path
0000000000000000000000000000000000000000;;	func (s *Spec) OperationFor(method, path string) (*spec.Operation, bool) {
0000000000000000000000000000000000000000;;		if mp, ok := s.operations[strings.ToUpper(method)]; ok {
0000000000000000000000000000000000000000;;			op, fn := mp[path]
0000000000000000000000000000000000000000;;			return op, fn
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Operations gathers all the operations specified in the spec document
0000000000000000000000000000000000000000;;	func (s *Spec) Operations() map[string]map[string]*spec.Operation {
0000000000000000000000000000000000000000;;		return s.operations
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *Spec) structMapKeys(mp map[string]struct{}) []string {
0000000000000000000000000000000000000000;;		if len(mp) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := make([]string, 0, len(mp))
0000000000000000000000000000000000000000;;		for k := range mp {
0000000000000000000000000000000000000000;;			result = append(result, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllPaths returns all the paths in the swagger spec
0000000000000000000000000000000000000000;;	func (s *Spec) AllPaths() map[string]spec.PathItem {
0000000000000000000000000000000000000000;;		if s.spec == nil || s.spec.Paths == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s.spec.Paths.Paths
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// OperationIDs gets all the operation ids based on method an dpath
0000000000000000000000000000000000000000;;	func (s *Spec) OperationIDs() []string {
0000000000000000000000000000000000000000;;		if len(s.operations) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := make([]string, 0, len(s.operations))
0000000000000000000000000000000000000000;;		for method, v := range s.operations {
0000000000000000000000000000000000000000;;			for p, o := range v {
0000000000000000000000000000000000000000;;				if o.ID != "" {
0000000000000000000000000000000000000000;;					result = append(result, o.ID)
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					result = append(result, fmt.Sprintf("%s %s", strings.ToUpper(method), p))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequiredConsumes gets all the distinct consumes that are specified in the specification document
0000000000000000000000000000000000000000;;	func (s *Spec) RequiredConsumes() []string {
0000000000000000000000000000000000000000;;		return s.structMapKeys(s.consumes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequiredProduces gets all the distinct produces that are specified in the specification document
0000000000000000000000000000000000000000;;	func (s *Spec) RequiredProduces() []string {
0000000000000000000000000000000000000000;;		return s.structMapKeys(s.produces)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequiredSecuritySchemes gets all the distinct security schemes that are specified in the swagger spec
0000000000000000000000000000000000000000;;	func (s *Spec) RequiredSecuritySchemes() []string {
0000000000000000000000000000000000000000;;		return s.structMapKeys(s.authSchemes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchemaRef is a reference to a schema
0000000000000000000000000000000000000000;;	type SchemaRef struct {
0000000000000000000000000000000000000000;;		Name   string
0000000000000000000000000000000000000000;;		Ref    spec.Ref
0000000000000000000000000000000000000000;;		Schema *spec.Schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchemasWithAllOf returns schema references to all schemas that are defined
0000000000000000000000000000000000000000;;	// with an allOf key
0000000000000000000000000000000000000000;;	func (s *Spec) SchemasWithAllOf() (result []SchemaRef) {
0000000000000000000000000000000000000000;;		for _, v := range s.allOfs {
0000000000000000000000000000000000000000;;			result = append(result, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllDefinitions returns schema references for all the definitions that were discovered
0000000000000000000000000000000000000000;;	func (s *Spec) AllDefinitions() (result []SchemaRef) {
0000000000000000000000000000000000000000;;		for _, v := range s.allSchemas {
0000000000000000000000000000000000000000;;			result = append(result, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllDefinitionReferences returns json refs for all the discovered schemas
0000000000000000000000000000000000000000;;	func (s *Spec) AllDefinitionReferences() (result []string) {
0000000000000000000000000000000000000000;;		for _, v := range s.references.schemas {
0000000000000000000000000000000000000000;;			result = append(result, v.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllParameterReferences returns json refs for all the discovered parameters
0000000000000000000000000000000000000000;;	func (s *Spec) AllParameterReferences() (result []string) {
0000000000000000000000000000000000000000;;		for _, v := range s.references.parameters {
0000000000000000000000000000000000000000;;			result = append(result, v.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllResponseReferences returns json refs for all the discovered responses
0000000000000000000000000000000000000000;;	func (s *Spec) AllResponseReferences() (result []string) {
0000000000000000000000000000000000000000;;		for _, v := range s.references.responses {
0000000000000000000000000000000000000000;;			result = append(result, v.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllItemsReferences returns the references for all the items
0000000000000000000000000000000000000000;;	func (s *Spec) AllItemsReferences() (result []string) {
0000000000000000000000000000000000000000;;		for _, v := range s.references.items {
0000000000000000000000000000000000000000;;			result = append(result, v.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllReferences returns all the references found in the document
0000000000000000000000000000000000000000;;	func (s *Spec) AllReferences() (result []string) {
0000000000000000000000000000000000000000;;		for _, v := range s.references.allRefs {
0000000000000000000000000000000000000000;;			result = append(result, v.String())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllRefs returns all the unique references found in the document
0000000000000000000000000000000000000000;;	func (s *Spec) AllRefs() (result []spec.Ref) {
0000000000000000000000000000000000000000;;		set := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for _, v := range s.references.allRefs {
0000000000000000000000000000000000000000;;			a := v.String()
0000000000000000000000000000000000000000;;			if a == "" {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if _, ok := set[a]; !ok {
0000000000000000000000000000000000000000;;				set[a] = struct{}{}
0000000000000000000000000000000000000000;;				result = append(result, v)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
