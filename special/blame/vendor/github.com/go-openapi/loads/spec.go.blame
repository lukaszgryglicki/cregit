0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package loads
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/analysis"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONDoc loads a json document from either a file or a remote url
0000000000000000000000000000000000000000;;	func JSONDoc(path string) (json.RawMessage, error) {
0000000000000000000000000000000000000000;;		data, err := swag.LoadFromFileOrHTTP(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.RawMessage(data), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DocLoader represents a doc loader type
0000000000000000000000000000000000000000;;	type DocLoader func(string) (json.RawMessage, error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DocMatcher represents a predicate to check if a loader matches
0000000000000000000000000000000000000000;;	type DocMatcher func(string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var loaders = &loader{Match: func(_ string) bool { return true }, Fn: JSONDoc}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddLoader for a document
0000000000000000000000000000000000000000;;	func AddLoader(predicate DocMatcher, load DocLoader) {
0000000000000000000000000000000000000000;;		prev := loaders
0000000000000000000000000000000000000000;;		loaders = &loader{
0000000000000000000000000000000000000000;;			Match: predicate,
0000000000000000000000000000000000000000;;			Fn:    load,
0000000000000000000000000000000000000000;;			Next:  prev,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type loader struct {
0000000000000000000000000000000000000000;;		Fn    DocLoader
0000000000000000000000000000000000000000;;		Match DocMatcher
0000000000000000000000000000000000000000;;		Next  *loader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONSpec loads a spec from a json document
0000000000000000000000000000000000000000;;	func JSONSpec(path string) (*Document, error) {
0000000000000000000000000000000000000000;;		data, err := JSONDoc(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// convert to json
0000000000000000000000000000000000000000;;		return Analyzed(json.RawMessage(data), "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Document represents a swagger spec document
0000000000000000000000000000000000000000;;	type Document struct {
0000000000000000000000000000000000000000;;		// specAnalyzer
0000000000000000000000000000000000000000;;		Analyzer *analysis.Spec
0000000000000000000000000000000000000000;;		spec     *spec.Swagger
0000000000000000000000000000000000000000;;		origSpec *spec.Swagger
0000000000000000000000000000000000000000;;		schema   *spec.Schema
0000000000000000000000000000000000000000;;		raw      json.RawMessage
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec loads a new spec document
0000000000000000000000000000000000000000;;	func Spec(path string) (*Document, error) {
0000000000000000000000000000000000000000;;		specURL, err := url.Parse(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for l := loaders.Next; l != nil; l = l.Next {
0000000000000000000000000000000000000000;;			if loaders.Match(specURL.Path) {
0000000000000000000000000000000000000000;;				b, err2 := loaders.Fn(path)
0000000000000000000000000000000000000000;;				if err2 != nil {
0000000000000000000000000000000000000000;;					return nil, err2
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return Analyzed(b, "")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b, err := loaders.Fn(path)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Analyzed(b, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var swag20Schema = spec.MustLoadSwagger20Schema()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Analyzed creates a new analyzed spec document
0000000000000000000000000000000000000000;;	func Analyzed(data json.RawMessage, version string) (*Document, error) {
0000000000000000000000000000000000000000;;		if version == "" {
0000000000000000000000000000000000000000;;			version = "2.0"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if version != "2.0" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("spec version %q is not supported", version)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		swspec := new(spec.Swagger)
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, swspec); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		origsqspec := new(spec.Swagger)
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, origsqspec); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d := &Document{
0000000000000000000000000000000000000000;;			Analyzer: analysis.New(swspec),
0000000000000000000000000000000000000000;;			schema:   swag20Schema,
0000000000000000000000000000000000000000;;			spec:     swspec,
0000000000000000000000000000000000000000;;			raw:      data,
0000000000000000000000000000000000000000;;			origSpec: origsqspec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return d, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Expanded expands the ref fields in the spec document and returns a new spec document
0000000000000000000000000000000000000000;;	func (d *Document) Expanded() (*Document, error) {
0000000000000000000000000000000000000000;;		swspec := new(spec.Swagger)
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(d.raw, swspec); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := spec.ExpandSpec(swspec); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		dd := &Document{
0000000000000000000000000000000000000000;;			Analyzer: analysis.New(swspec),
0000000000000000000000000000000000000000;;			spec:     swspec,
0000000000000000000000000000000000000000;;			schema:   swag20Schema,
0000000000000000000000000000000000000000;;			raw:      d.raw,
0000000000000000000000000000000000000000;;			origSpec: d.origSpec,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return dd, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BasePath the base path for this spec
0000000000000000000000000000000000000000;;	func (d *Document) BasePath() string {
0000000000000000000000000000000000000000;;		return d.spec.BasePath
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Version returns the version of this spec
0000000000000000000000000000000000000000;;	func (d *Document) Version() string {
0000000000000000000000000000000000000000;;		return d.spec.Swagger
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Schema returns the swagger 2.0 schema
0000000000000000000000000000000000000000;;	func (d *Document) Schema() *spec.Schema {
0000000000000000000000000000000000000000;;		return d.schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec returns the swagger spec object model
0000000000000000000000000000000000000000;;	func (d *Document) Spec() *spec.Swagger {
0000000000000000000000000000000000000000;;		return d.spec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Host returns the host for the API
0000000000000000000000000000000000000000;;	func (d *Document) Host() string {
0000000000000000000000000000000000000000;;		return d.spec.Host
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Raw returns the raw swagger spec as json bytes
0000000000000000000000000000000000000000;;	func (d *Document) Raw() json.RawMessage {
0000000000000000000000000000000000000000;;		return d.raw
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Document) OrigSpec() *spec.Swagger {
0000000000000000000000000000000000000000;;		return d.origSpec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetDefinitions gives a shallow copy with the models reset
0000000000000000000000000000000000000000;;	func (d *Document) ResetDefinitions() *Document {
0000000000000000000000000000000000000000;;		defs := make(map[string]spec.Schema, len(d.origSpec.Definitions))
0000000000000000000000000000000000000000;;		for k, v := range d.origSpec.Definitions {
0000000000000000000000000000000000000000;;			defs[k] = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		d.spec.Definitions = defs
0000000000000000000000000000000000000000;;		return d
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pristine creates a new pristine document instance based on the input data
0000000000000000000000000000000000000000;;	func (d *Document) Pristine() *Document {
0000000000000000000000000000000000000000;;		dd, _ := Analyzed(d.Raw(), d.Version())
0000000000000000000000000000000000000000;;		return dd
0000000000000000000000000000000000000000;;	}
