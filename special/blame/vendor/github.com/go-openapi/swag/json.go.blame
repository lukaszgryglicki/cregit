0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package swag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/mailru/easyjson/jlexer"
0000000000000000000000000000000000000000;;		"github.com/mailru/easyjson/jwriter"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultJSONNameProvider the default cache for types
0000000000000000000000000000000000000000;;	var DefaultJSONNameProvider = NewNameProvider()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const comma = byte(',')
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var closers = map[byte]byte{
0000000000000000000000000000000000000000;;		'{': '}',
0000000000000000000000000000000000000000;;		'[': ']',
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ejMarshaler interface {
0000000000000000000000000000000000000000;;		MarshalEasyJSON(w *jwriter.Writer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type ejUnmarshaler interface {
0000000000000000000000000000000000000000;;		UnmarshalEasyJSON(w *jlexer.Lexer)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WriteJSON writes json data, prefers finding an appropriate interface to short-circuit the marshaller
0000000000000000000000000000000000000000;;	// so it takes the fastest option available.
0000000000000000000000000000000000000000;;	func WriteJSON(data interface{}) ([]byte, error) {
0000000000000000000000000000000000000000;;		if d, ok := data.(ejMarshaler); ok {
0000000000000000000000000000000000000000;;			jw := new(jwriter.Writer)
0000000000000000000000000000000000000000;;			d.MarshalEasyJSON(jw)
0000000000000000000000000000000000000000;;			return jw.BuildBytes()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d, ok := data.(json.Marshaler); ok {
0000000000000000000000000000000000000000;;			return d.MarshalJSON()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(data)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ReadJSON reads json data, prefers finding an appropriate interface to short-circuit the unmarshaller
0000000000000000000000000000000000000000;;	// so it takes the fastes option available
0000000000000000000000000000000000000000;;	func ReadJSON(data []byte, value interface{}) error {
0000000000000000000000000000000000000000;;		if d, ok := value.(ejUnmarshaler); ok {
0000000000000000000000000000000000000000;;			jl := &jlexer.Lexer{Data: data}
0000000000000000000000000000000000000000;;			d.UnmarshalEasyJSON(jl)
0000000000000000000000000000000000000000;;			return jl.Error()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if d, ok := value.(json.Unmarshaler); ok {
0000000000000000000000000000000000000000;;			return d.UnmarshalJSON(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Unmarshal(data, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DynamicJSONToStruct converts an untyped json structure into a struct
0000000000000000000000000000000000000000;;	func DynamicJSONToStruct(data interface{}, target interface{}) error {
0000000000000000000000000000000000000000;;		// TODO: convert straight to a json typed map  (mergo + iterate?)
0000000000000000000000000000000000000000;;		b, err := WriteJSON(data)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := ReadJSON(b, target); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConcatJSON concatenates multiple json objects efficiently
0000000000000000000000000000000000000000;;	func ConcatJSON(blobs ...[]byte) []byte {
0000000000000000000000000000000000000000;;		if len(blobs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if len(blobs) == 1 {
0000000000000000000000000000000000000000;;			return blobs[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		last := len(blobs) - 1
0000000000000000000000000000000000000000;;		var opening, closing byte
0000000000000000000000000000000000000000;;		a := 0
0000000000000000000000000000000000000000;;		idx := 0
0000000000000000000000000000000000000000;;		buf := bytes.NewBuffer(nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, b := range blobs {
0000000000000000000000000000000000000000;;			if len(b) > 0 && opening == 0 { // is this an array or an object?
0000000000000000000000000000000000000000;;				opening, closing = b[0], closers[b[0]]
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if opening != '{' && opening != '[' {
0000000000000000000000000000000000000000;;				continue // don't know how to concatenate non container objects
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(b) < 3 { // yep empty but also the last one, so closing this thing
0000000000000000000000000000000000000000;;				if i == last && a > 0 {
0000000000000000000000000000000000000000;;					buf.WriteByte(closing)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			idx = 0
0000000000000000000000000000000000000000;;			if a > 0 { // we need to join with a comma for everything beyond the first non-empty item
0000000000000000000000000000000000000000;;				buf.WriteByte(comma)
0000000000000000000000000000000000000000;;				idx = 1 // this is not the first or the last so we want to drop the leading bracket
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if i != last { // not the last one, strip brackets
0000000000000000000000000000000000000000;;				buf.Write(b[idx : len(b)-1])
0000000000000000000000000000000000000000;;			} else { // last one, strip only the leading bracket
0000000000000000000000000000000000000000;;				buf.Write(b[idx:])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			a++
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// somehow it ended up being empty, so provide a default value
0000000000000000000000000000000000000000;;		if buf.Len() == 0 {
0000000000000000000000000000000000000000;;			buf.WriteByte(opening)
0000000000000000000000000000000000000000;;			buf.WriteByte(closing)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return buf.Bytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToDynamicJSON turns an object into a properly JSON typed structure
0000000000000000000000000000000000000000;;	func ToDynamicJSON(data interface{}) interface{} {
0000000000000000000000000000000000000000;;		// TODO: convert straight to a json typed map (mergo + iterate?)
0000000000000000000000000000000000000000;;		b, _ := json.Marshal(data)
0000000000000000000000000000000000000000;;		var res interface{}
0000000000000000000000000000000000000000;;		json.Unmarshal(b, &res)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FromDynamicJSON turns an object into a properly JSON typed structure
0000000000000000000000000000000000000000;;	func FromDynamicJSON(data, target interface{}) error {
0000000000000000000000000000000000000000;;		b, _ := json.Marshal(data)
0000000000000000000000000000000000000000;;		return json.Unmarshal(b, target)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameProvider represents an object capabale of translating from go property names
0000000000000000000000000000000000000000;;	// to json property names
0000000000000000000000000000000000000000;;	// This type is thread-safe.
0000000000000000000000000000000000000000;;	type NameProvider struct {
0000000000000000000000000000000000000000;;		lock  *sync.Mutex
0000000000000000000000000000000000000000;;		index map[reflect.Type]nameIndex
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type nameIndex struct {
0000000000000000000000000000000000000000;;		jsonNames map[string]string
0000000000000000000000000000000000000000;;		goNames   map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewNameProvider creates a new name provider
0000000000000000000000000000000000000000;;	func NewNameProvider() *NameProvider {
0000000000000000000000000000000000000000;;		return &NameProvider{
0000000000000000000000000000000000000000;;			lock:  &sync.Mutex{},
0000000000000000000000000000000000000000;;			index: make(map[reflect.Type]nameIndex),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func buildnameIndex(tpe reflect.Type, idx, reverseIdx map[string]string) {
0000000000000000000000000000000000000000;;		for i := 0; i < tpe.NumField(); i++ {
0000000000000000000000000000000000000000;;			targetDes := tpe.Field(i)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if targetDes.PkgPath != "" { // unexported
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if targetDes.Anonymous { // walk embedded structures tree down first
0000000000000000000000000000000000000000;;				buildnameIndex(targetDes.Type, idx, reverseIdx)
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if tag := targetDes.Tag.Get("json"); tag != "" {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				parts := strings.Split(tag, ",")
0000000000000000000000000000000000000000;;				if len(parts) == 0 {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				nm := parts[0]
0000000000000000000000000000000000000000;;				if nm == "-" {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if nm == "" { // empty string means we want to use the Go name
0000000000000000000000000000000000000000;;					nm = targetDes.Name
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				idx[nm] = targetDes.Name
0000000000000000000000000000000000000000;;				reverseIdx[targetDes.Name] = nm
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newNameIndex(tpe reflect.Type) nameIndex {
0000000000000000000000000000000000000000;;		var idx = make(map[string]string, tpe.NumField())
0000000000000000000000000000000000000000;;		var reverseIdx = make(map[string]string, tpe.NumField())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		buildnameIndex(tpe, idx, reverseIdx)
0000000000000000000000000000000000000000;;		return nameIndex{jsonNames: idx, goNames: reverseIdx}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetJSONNames gets all the json property names for a type
0000000000000000000000000000000000000000;;	func (n *NameProvider) GetJSONNames(subject interface{}) []string {
0000000000000000000000000000000000000000;;		tpe := reflect.Indirect(reflect.ValueOf(subject)).Type()
0000000000000000000000000000000000000000;;		names, ok := n.index[tpe]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			names = n.makeNameIndex(tpe)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res []string
0000000000000000000000000000000000000000;;		for k := range names.jsonNames {
0000000000000000000000000000000000000000;;			res = append(res, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetJSONName gets the json name for a go property name
0000000000000000000000000000000000000000;;	func (n *NameProvider) GetJSONName(subject interface{}, name string) (string, bool) {
0000000000000000000000000000000000000000;;		tpe := reflect.Indirect(reflect.ValueOf(subject)).Type()
0000000000000000000000000000000000000000;;		return n.GetJSONNameForType(tpe, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetJSONNameForType gets the json name for a go property name on a given type
0000000000000000000000000000000000000000;;	func (n *NameProvider) GetJSONNameForType(tpe reflect.Type, name string) (string, bool) {
0000000000000000000000000000000000000000;;		names, ok := n.index[tpe]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			names = n.makeNameIndex(tpe)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nme, ok := names.goNames[name]
0000000000000000000000000000000000000000;;		return nme, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *NameProvider) makeNameIndex(tpe reflect.Type) nameIndex {
0000000000000000000000000000000000000000;;		n.lock.Lock()
0000000000000000000000000000000000000000;;		defer n.lock.Unlock()
0000000000000000000000000000000000000000;;		names := newNameIndex(tpe)
0000000000000000000000000000000000000000;;		n.index[tpe] = names
0000000000000000000000000000000000000000;;		return names
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetGoName gets the go name for a json property name
0000000000000000000000000000000000000000;;	func (n *NameProvider) GetGoName(subject interface{}, name string) (string, bool) {
0000000000000000000000000000000000000000;;		tpe := reflect.Indirect(reflect.ValueOf(subject)).Type()
0000000000000000000000000000000000000000;;		return n.GetGoNameForType(tpe, name)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetGoNameForType gets the go name for a given type for a json property name
0000000000000000000000000000000000000000;;	func (n *NameProvider) GetGoNameForType(tpe reflect.Type, name string) (string, bool) {
0000000000000000000000000000000000000000;;		names, ok := n.index[tpe]
0000000000000000000000000000000000000000;;		if !ok {
0000000000000000000000000000000000000000;;			names = n.makeNameIndex(tpe)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		nme, ok := names.jsonNames[name]
0000000000000000000000000000000000000000;;		return nme, ok
0000000000000000000000000000000000000000;;	}
