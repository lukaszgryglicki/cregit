0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package swag
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"math"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"sort"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Taken from https://github.com/golang/lint/blob/1fab560e16097e5b69afb66eb93aab843ef77845/lint.go#L663-L698
0000000000000000000000000000000000000000;;	var commonInitialisms = map[string]bool{
0000000000000000000000000000000000000000;;		"API":   true,
0000000000000000000000000000000000000000;;		"ASCII": true,
0000000000000000000000000000000000000000;;		"CPU":   true,
0000000000000000000000000000000000000000;;		"CSS":   true,
0000000000000000000000000000000000000000;;		"DNS":   true,
0000000000000000000000000000000000000000;;		"EOF":   true,
0000000000000000000000000000000000000000;;		"GUID":  true,
0000000000000000000000000000000000000000;;		"HTML":  true,
0000000000000000000000000000000000000000;;		"HTTPS": true,
0000000000000000000000000000000000000000;;		"HTTP":  true,
0000000000000000000000000000000000000000;;		"ID":    true,
0000000000000000000000000000000000000000;;		"IP":    true,
0000000000000000000000000000000000000000;;		"JSON":  true,
0000000000000000000000000000000000000000;;		"LHS":   true,
0000000000000000000000000000000000000000;;		"QPS":   true,
0000000000000000000000000000000000000000;;		"RAM":   true,
0000000000000000000000000000000000000000;;		"RHS":   true,
0000000000000000000000000000000000000000;;		"RPC":   true,
0000000000000000000000000000000000000000;;		"SLA":   true,
0000000000000000000000000000000000000000;;		"SMTP":  true,
0000000000000000000000000000000000000000;;		"SSH":   true,
0000000000000000000000000000000000000000;;		"TCP":   true,
0000000000000000000000000000000000000000;;		"TLS":   true,
0000000000000000000000000000000000000000;;		"TTL":   true,
0000000000000000000000000000000000000000;;		"UDP":   true,
0000000000000000000000000000000000000000;;		"UUID":  true,
0000000000000000000000000000000000000000;;		"UID":   true,
0000000000000000000000000000000000000000;;		"UI":    true,
0000000000000000000000000000000000000000;;		"URI":   true,
0000000000000000000000000000000000000000;;		"URL":   true,
0000000000000000000000000000000000000000;;		"UTF8":  true,
0000000000000000000000000000000000000000;;		"VM":    true,
0000000000000000000000000000000000000000;;		"XML":   true,
0000000000000000000000000000000000000000;;		"XSRF":  true,
0000000000000000000000000000000000000000;;		"XSS":   true,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	var initialisms []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		for k := range commonInitialisms {
0000000000000000000000000000000000000000;;			initialisms = append(initialisms, k)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		sort.Sort(sort.Reverse(byLength(initialisms)))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JoinByFormat joins a string array by a known format:
0000000000000000000000000000000000000000;;	//		ssv: space separated value
0000000000000000000000000000000000000000;;	//		tsv: tab separated value
0000000000000000000000000000000000000000;;	//		pipes: pipe (|) separated value
0000000000000000000000000000000000000000;;	//		csv: comma separated value (default)
0000000000000000000000000000000000000000;;	func JoinByFormat(data []string, format string) []string {
0000000000000000000000000000000000000000;;		if len(data) == 0 {
0000000000000000000000000000000000000000;;			return data
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var sep string
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case "ssv":
0000000000000000000000000000000000000000;;			sep = " "
0000000000000000000000000000000000000000;;		case "tsv":
0000000000000000000000000000000000000000;;			sep = "\t"
0000000000000000000000000000000000000000;;		case "pipes":
0000000000000000000000000000000000000000;;			sep = "|"
0000000000000000000000000000000000000000;;		case "multi":
0000000000000000000000000000000000000000;;			return data
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			sep = ","
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return []string{strings.Join(data, sep)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SplitByFormat splits a string by a known format:
0000000000000000000000000000000000000000;;	//		ssv: space separated value
0000000000000000000000000000000000000000;;	//		tsv: tab separated value
0000000000000000000000000000000000000000;;	//		pipes: pipe (|) separated value
0000000000000000000000000000000000000000;;	//		csv: comma separated value (default)
0000000000000000000000000000000000000000;;	func SplitByFormat(data, format string) []string {
0000000000000000000000000000000000000000;;		if data == "" {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var sep string
0000000000000000000000000000000000000000;;		switch format {
0000000000000000000000000000000000000000;;		case "ssv":
0000000000000000000000000000000000000000;;			sep = " "
0000000000000000000000000000000000000000;;		case "tsv":
0000000000000000000000000000000000000000;;			sep = "\t"
0000000000000000000000000000000000000000;;		case "pipes":
0000000000000000000000000000000000000000;;			sep = "|"
0000000000000000000000000000000000000000;;		case "multi":
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			sep = ","
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var result []string
0000000000000000000000000000000000000000;;		for _, s := range strings.Split(data, sep) {
0000000000000000000000000000000000000000;;			if ts := strings.TrimSpace(s); ts != "" {
0000000000000000000000000000000000000000;;				result = append(result, ts)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type byLength []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s byLength) Len() int {
0000000000000000000000000000000000000000;;		return len(s)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s byLength) Swap(i, j int) {
0000000000000000000000000000000000000000;;		s[i], s[j] = s[j], s[i]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (s byLength) Less(i, j int) bool {
0000000000000000000000000000000000000000;;		return len(s[i]) < len(s[j])
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Prepares strings by splitting by caps, spaces, dashes, and underscore
0000000000000000000000000000000000000000;;	func split(str string) (words []string) {
0000000000000000000000000000000000000000;;		repl := strings.NewReplacer(
0000000000000000000000000000000000000000;;			"@", "At ",
0000000000000000000000000000000000000000;;			"&", "And ",
0000000000000000000000000000000000000000;;			"|", "Pipe ",
0000000000000000000000000000000000000000;;			"$", "Dollar ",
0000000000000000000000000000000000000000;;			"!", "Bang ",
0000000000000000000000000000000000000000;;			"-", " ",
0000000000000000000000000000000000000000;;			"_", " ",
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rex1 := regexp.MustCompile(`(\p{Lu})`)
0000000000000000000000000000000000000000;;		rex2 := regexp.MustCompile(`(\pL|\pM|\pN|\p{Pc})+`)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		str = trim(str)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Convert dash and underscore to spaces
0000000000000000000000000000000000000000;;		str = repl.Replace(str)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Split when uppercase is found (needed for Snake)
0000000000000000000000000000000000000000;;		str = rex1.ReplaceAllString(str, " $1")
0000000000000000000000000000000000000000;;		// check if consecutive single char things make up an initialism
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, k := range initialisms {
0000000000000000000000000000000000000000;;			str = strings.Replace(str, rex1.ReplaceAllString(k, " $1"), " "+k, -1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get the final list of words
0000000000000000000000000000000000000000;;		words = rex2.FindAllString(str, -1)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Removes leading whitespaces
0000000000000000000000000000000000000000;;	func trim(str string) string {
0000000000000000000000000000000000000000;;		return strings.Trim(str, " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Shortcut to strings.ToUpper()
0000000000000000000000000000000000000000;;	func upper(str string) string {
0000000000000000000000000000000000000000;;		return strings.ToUpper(trim(str))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Shortcut to strings.ToLower()
0000000000000000000000000000000000000000;;	func lower(str string) string {
0000000000000000000000000000000000000000;;		return strings.ToLower(trim(str))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToFileName lowercases and underscores a go type name
0000000000000000000000000000000000000000;;	func ToFileName(name string) string {
0000000000000000000000000000000000000000;;		var out []string
0000000000000000000000000000000000000000;;		for _, w := range split(name) {
0000000000000000000000000000000000000000;;			out = append(out, lower(w))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, "_")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToCommandName lowercases and underscores a go type name
0000000000000000000000000000000000000000;;	func ToCommandName(name string) string {
0000000000000000000000000000000000000000;;		var out []string
0000000000000000000000000000000000000000;;		for _, w := range split(name) {
0000000000000000000000000000000000000000;;			out = append(out, lower(w))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, "-")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToHumanNameLower represents a code name as a human series of words
0000000000000000000000000000000000000000;;	func ToHumanNameLower(name string) string {
0000000000000000000000000000000000000000;;		var out []string
0000000000000000000000000000000000000000;;		for _, w := range split(name) {
0000000000000000000000000000000000000000;;			if !commonInitialisms[upper(w)] {
0000000000000000000000000000000000000000;;				out = append(out, lower(w))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out = append(out, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToHumanNameTitle represents a code name as a human series of words with the first letters titleized
0000000000000000000000000000000000000000;;	func ToHumanNameTitle(name string) string {
0000000000000000000000000000000000000000;;		var out []string
0000000000000000000000000000000000000000;;		for _, w := range split(name) {
0000000000000000000000000000000000000000;;			uw := upper(w)
0000000000000000000000000000000000000000;;			if !commonInitialisms[uw] {
0000000000000000000000000000000000000000;;				out = append(out, upper(w[:1])+lower(w[1:]))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				out = append(out, w)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, " ")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToJSONName camelcases a name which can be underscored or pascal cased
0000000000000000000000000000000000000000;;	func ToJSONName(name string) string {
0000000000000000000000000000000000000000;;		var out []string
0000000000000000000000000000000000000000;;		for i, w := range split(name) {
0000000000000000000000000000000000000000;;			if i == 0 {
0000000000000000000000000000000000000000;;				out = append(out, lower(w))
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, upper(w[:1])+lower(w[1:]))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToVarName camelcases a name which can be underscored or pascal cased
0000000000000000000000000000000000000000;;	func ToVarName(name string) string {
0000000000000000000000000000000000000000;;		res := ToGoName(name)
0000000000000000000000000000000000000000;;		if len(res) <= 1 {
0000000000000000000000000000000000000000;;			return lower(res)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return lower(res[:1]) + res[1:]
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToGoName translates a swagger name which can be underscored or camel cased to a name that golint likes
0000000000000000000000000000000000000000;;	func ToGoName(name string) string {
0000000000000000000000000000000000000000;;		var out []string
0000000000000000000000000000000000000000;;		for _, w := range split(name) {
0000000000000000000000000000000000000000;;			uw := upper(w)
0000000000000000000000000000000000000000;;			mod := int(math.Min(float64(len(uw)), 2))
0000000000000000000000000000000000000000;;			if !commonInitialisms[uw] && !commonInitialisms[uw[:len(uw)-mod]] {
0000000000000000000000000000000000000000;;				uw = upper(w[:1]) + lower(w[1:])
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			out = append(out, uw)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return strings.Join(out, "")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainsStringsCI searches a slice of strings for a case-insensitive match
0000000000000000000000000000000000000000;;	func ContainsStringsCI(coll []string, item string) bool {
0000000000000000000000000000000000000000;;		for _, a := range coll {
0000000000000000000000000000000000000000;;			if strings.EqualFold(a, item) {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type zeroable interface {
0000000000000000000000000000000000000000;;		IsZero() bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsZero returns true when the value passed into the function is a zero value.
0000000000000000000000000000000000000000;;	// This allows for safer checking of interface values.
0000000000000000000000000000000000000000;;	func IsZero(data interface{}) bool {
0000000000000000000000000000000000000000;;		// check for things that have an IsZero method instead
0000000000000000000000000000000000000000;;		if vv, ok := data.(zeroable); ok {
0000000000000000000000000000000000000000;;			return vv.IsZero()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// continue with slightly more complex reflection
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.String:
0000000000000000000000000000000000000000;;			return v.Len() == 0
0000000000000000000000000000000000000000;;		case reflect.Bool:
0000000000000000000000000000000000000000;;			return !v.Bool()
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return v.Int() == 0
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:
0000000000000000000000000000000000000000;;			return v.Uint() == 0
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float() == 0
0000000000000000000000000000000000000000;;		case reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		case reflect.Struct, reflect.Array:
0000000000000000000000000000000000000000;;			return reflect.DeepEqual(data, reflect.Zero(v.Type()).Interface())
0000000000000000000000000000000000000000;;		case reflect.Invalid:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CommandLineOptionsGroup represents a group of user-defined command line options
0000000000000000000000000000000000000000;;	type CommandLineOptionsGroup struct {
0000000000000000000000000000000000000000;;		ShortDescription string
0000000000000000000000000000000000000000;;		LongDescription  string
0000000000000000000000000000000000000000;;		Options          interface{}
0000000000000000000000000000000000000000;;	}
