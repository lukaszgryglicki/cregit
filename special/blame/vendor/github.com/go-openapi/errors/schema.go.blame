0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package errors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		invalidType               = "%s is an invalid type name"
0000000000000000000000000000000000000000;;		typeFail                  = "%s in %s must be of type %s"
0000000000000000000000000000000000000000;;		typeFailWithData          = "%s in %s must be of type %s: %q"
0000000000000000000000000000000000000000;;		typeFailWithError         = "%s in %s must be of type %s, because: %s"
0000000000000000000000000000000000000000;;		requiredFail              = "%s in %s is required"
0000000000000000000000000000000000000000;;		tooLongMessage            = "%s in %s should be at most %d chars long"
0000000000000000000000000000000000000000;;		tooShortMessage           = "%s in %s should be at least %d chars long"
0000000000000000000000000000000000000000;;		patternFail               = "%s in %s should match '%s'"
0000000000000000000000000000000000000000;;		enumFail                  = "%s in %s should be one of %v"
0000000000000000000000000000000000000000;;		multipleOfFail            = "%s in %s should be a multiple of %v"
0000000000000000000000000000000000000000;;		maxIncFail                = "%s in %s should be less than or equal to %v"
0000000000000000000000000000000000000000;;		maxExcFail                = "%s in %s should be less than %v"
0000000000000000000000000000000000000000;;		minIncFail                = "%s in %s should be greater than or equal to %v"
0000000000000000000000000000000000000000;;		minExcFail                = "%s in %s should be greater than %v"
0000000000000000000000000000000000000000;;		uniqueFail                = "%s in %s shouldn't contain duplicates"
0000000000000000000000000000000000000000;;		maxItemsFail              = "%s in %s should have at most %d items"
0000000000000000000000000000000000000000;;		minItemsFail              = "%s in %s should have at least %d items"
0000000000000000000000000000000000000000;;		typeFailNoIn              = "%s must be of type %s"
0000000000000000000000000000000000000000;;		typeFailWithDataNoIn      = "%s must be of type %s: %q"
0000000000000000000000000000000000000000;;		typeFailWithErrorNoIn     = "%s must be of type %s, because: %s"
0000000000000000000000000000000000000000;;		requiredFailNoIn          = "%s is required"
0000000000000000000000000000000000000000;;		tooLongMessageNoIn        = "%s should be at most %d chars long"
0000000000000000000000000000000000000000;;		tooShortMessageNoIn       = "%s should be at least %d chars long"
0000000000000000000000000000000000000000;;		patternFailNoIn           = "%s should match '%s'"
0000000000000000000000000000000000000000;;		enumFailNoIn              = "%s should be one of %v"
0000000000000000000000000000000000000000;;		multipleOfFailNoIn        = "%s should be a multiple of %v"
0000000000000000000000000000000000000000;;		maxIncFailNoIn            = "%s should be less than or equal to %v"
0000000000000000000000000000000000000000;;		maxExcFailNoIn            = "%s should be less than %v"
0000000000000000000000000000000000000000;;		minIncFailNoIn            = "%s should be greater than or equal to %v"
0000000000000000000000000000000000000000;;		minExcFailNoIn            = "%s should be greater than %v"
0000000000000000000000000000000000000000;;		uniqueFailNoIn            = "%s shouldn't contain duplicates"
0000000000000000000000000000000000000000;;		maxItemsFailNoIn          = "%s should have at most %d items"
0000000000000000000000000000000000000000;;		minItemsFailNoIn          = "%s should have at least %d items"
0000000000000000000000000000000000000000;;		noAdditionalItems         = "%s in %s can't have additional items"
0000000000000000000000000000000000000000;;		noAdditionalItemsNoIn     = "%s can't have additional items"
0000000000000000000000000000000000000000;;		tooFewProperties          = "%s in %s should have at least %d properties"
0000000000000000000000000000000000000000;;		tooFewPropertiesNoIn      = "%s should have at least %d properties"
0000000000000000000000000000000000000000;;		tooManyProperties         = "%s in %s should have at most %d properties"
0000000000000000000000000000000000000000;;		tooManyPropertiesNoIn     = "%s should have at most %d properties"
0000000000000000000000000000000000000000;;		unallowedProperty         = "%s.%s in %s is a forbidden property"
0000000000000000000000000000000000000000;;		unallowedPropertyNoIn     = "%s.%s is a forbidden property"
0000000000000000000000000000000000000000;;		failedAllPatternProps     = "%s.%s in %s failed all pattern properties"
0000000000000000000000000000000000000000;;		failedAllPatternPropsNoIn = "%s.%s failed all pattern properties"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompositeError is an error that groups several errors together
0000000000000000000000000000000000000000;;	type CompositeError struct {
0000000000000000000000000000000000000000;;		Errors  []error
0000000000000000000000000000000000000000;;		code    int32
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Code for this error
0000000000000000000000000000000000000000;;	func (c *CompositeError) Code() int32 {
0000000000000000000000000000000000000000;;		return c.code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (c *CompositeError) Error() string {
0000000000000000000000000000000000000000;;		if len(c.Errors) > 0 {
0000000000000000000000000000000000000000;;			msgs := []string{c.message + ":"}
0000000000000000000000000000000000000000;;			for _, e := range c.Errors {
0000000000000000000000000000000000000000;;				msgs = append(msgs, e.Error())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strings.Join(msgs, "\n")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return c.message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CompositeValidationError an error to wrap a bunch of other errors
0000000000000000000000000000000000000000;;	func CompositeValidationError(errors ...error) *CompositeError {
0000000000000000000000000000000000000000;;		return &CompositeError{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Errors:  append([]error{}, errors...),
0000000000000000000000000000000000000000;;			message: "validation failure list",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FailedAllPatternProperties an error for when the property doesn't match a pattern
0000000000000000000000000000000000000000;;	func FailedAllPatternProperties(name, in, key string) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(failedAllPatternProps, name, key, in)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(failedAllPatternPropsNoIn, name, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   key,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// PropertyNotAllowed an error for when the property doesn't match a pattern
0000000000000000000000000000000000000000;;	func PropertyNotAllowed(name, in, key string) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(unallowedProperty, name, key, in)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(unallowedPropertyNoIn, name, key)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   key,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TooFewProperties an error for an object with too few properties
0000000000000000000000000000000000000000;;	func TooFewProperties(name, in string, n int64) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(tooFewProperties, name, in, n)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(tooFewPropertiesNoIn, name, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   n,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TooManyProperties an error for an object with too many properties
0000000000000000000000000000000000000000;;	func TooManyProperties(name, in string, n int64) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(tooManyProperties, name, in, n)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(tooManyPropertiesNoIn, name, n)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   n,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AdditionalItemsNotAllowed an error for invalid additional items
0000000000000000000000000000000000000000;;	func AdditionalItemsNotAllowed(name, in string) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(noAdditionalItems, name, in)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(noAdditionalItemsNoIn, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidCollectionFormat another flavor of invalid type error
0000000000000000000000000000000000000000;;	func InvalidCollectionFormat(name, in, format string) *Validation {
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   format,
0000000000000000000000000000000000000000;;			message: fmt.Sprintf("the collection format %q is not supported for the %s param %q", format, in, name),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidTypeName an error for when the type is invalid
0000000000000000000000000000000000000000;;	func InvalidTypeName(typeName string) *Validation {
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Value:   typeName,
0000000000000000000000000000000000000000;;			message: fmt.Sprintf(invalidType, typeName),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InvalidType creates an error for when the type is invalid
0000000000000000000000000000000000000000;;	func InvalidType(name, in, typeName string, value interface{}) *Validation {
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if in != "" {
0000000000000000000000000000000000000000;;			switch value.(type) {
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				message = fmt.Sprintf(typeFailWithData, name, in, typeName, value)
0000000000000000000000000000000000000000;;			case error:
0000000000000000000000000000000000000000;;				message = fmt.Sprintf(typeFailWithError, name, in, typeName, value)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				message = fmt.Sprintf(typeFail, name, in, typeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			switch value.(type) {
0000000000000000000000000000000000000000;;			case string:
0000000000000000000000000000000000000000;;				message = fmt.Sprintf(typeFailWithDataNoIn, name, typeName, value)
0000000000000000000000000000000000000000;;			case error:
0000000000000000000000000000000000000000;;				message = fmt.Sprintf(typeFailWithErrorNoIn, name, typeName, value)
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				message = fmt.Sprintf(typeFailNoIn, name, typeName)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   value,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DuplicateItems error for when an array contains duplicates
0000000000000000000000000000000000000000;;	func DuplicateItems(name, in string) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(uniqueFail, name, in)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(uniqueFailNoIn, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TooManyItems error for when an array contains too many items
0000000000000000000000000000000000000000;;	func TooManyItems(name, in string, max int64) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(maxItemsFail, name, in, max)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(maxItemsFailNoIn, name, max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TooFewItems error for when an array contains too few items
0000000000000000000000000000000000000000;;	func TooFewItems(name, in string, min int64) *Validation {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf(minItemsFail, name, in, min)
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(minItemsFailNoIn, name, min)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExceedsMaximumInt error for when maxinum validation fails
0000000000000000000000000000000000000000;;	func ExceedsMaximumInt(name, in string, max int64, exclusive bool) *Validation {
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			m := maxIncFailNoIn
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = maxExcFailNoIn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, max)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m := maxIncFail
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = maxExcFail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, in, max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   max,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExceedsMaximumUint error for when maxinum validation fails
0000000000000000000000000000000000000000;;	func ExceedsMaximumUint(name, in string, max uint64, exclusive bool) *Validation {
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			m := maxIncFailNoIn
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = maxExcFailNoIn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, max)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m := maxIncFail
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = maxExcFail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, in, max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   max,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExceedsMaximum error for when maxinum validation fails
0000000000000000000000000000000000000000;;	func ExceedsMaximum(name, in string, max float64, exclusive bool) *Validation {
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			m := maxIncFailNoIn
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = maxExcFailNoIn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, max)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m := maxIncFail
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = maxExcFail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, in, max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   max,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExceedsMinimumInt error for when maxinum validation fails
0000000000000000000000000000000000000000;;	func ExceedsMinimumInt(name, in string, min int64, exclusive bool) *Validation {
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			m := minIncFailNoIn
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = minExcFailNoIn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, min)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m := minIncFail
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = minExcFail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, in, min)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   min,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExceedsMinimumUint error for when maxinum validation fails
0000000000000000000000000000000000000000;;	func ExceedsMinimumUint(name, in string, min uint64, exclusive bool) *Validation {
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			m := minIncFailNoIn
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = minExcFailNoIn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, min)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m := minIncFail
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = minExcFail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, in, min)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   min,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExceedsMinimum error for when maxinum validation fails
0000000000000000000000000000000000000000;;	func ExceedsMinimum(name, in string, min float64, exclusive bool) *Validation {
0000000000000000000000000000000000000000;;		var message string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			m := minIncFailNoIn
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = minExcFailNoIn
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, min)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			m := minIncFail
0000000000000000000000000000000000000000;;			if exclusive {
0000000000000000000000000000000000000000;;				m = minExcFail
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			message = fmt.Sprintf(m, name, in, min)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   min,
0000000000000000000000000000000000000000;;			message: message,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotMultipleOf error for when multiple of validation fails
0000000000000000000000000000000000000000;;	func NotMultipleOf(name, in string, multiple float64) *Validation {
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(multipleOfFailNoIn, name, multiple)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(multipleOfFail, name, in, multiple)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   multiple,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnumFail error for when an enum validation fails
0000000000000000000000000000000000000000;;	func EnumFail(name, in string, value interface{}, values []interface{}) *Validation {
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(enumFailNoIn, name, values)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(enumFail, name, in, values)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			Value:   value,
0000000000000000000000000000000000000000;;			Values:  values,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Required error for when a value is missing
0000000000000000000000000000000000000000;;	func Required(name, in string) *Validation {
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(requiredFailNoIn, name)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(requiredFail, name, in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TooLong error for when a string is too long
0000000000000000000000000000000000000000;;	func TooLong(name, in string, max int64) *Validation {
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(tooLongMessageNoIn, name, max)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(tooLongMessage, name, in, max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// TooShort error for when a string is too short
0000000000000000000000000000000000000000;;	func TooShort(name, in string, min int64) *Validation {
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(tooShortMessageNoIn, name, min)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(tooShortMessage, name, in, min)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FailedPattern error for when a string fails a regex pattern match
0000000000000000000000000000000000000000;;	// the pattern that is returned is the ECMA syntax version of the pattern not the golang version.
0000000000000000000000000000000000000000;;	func FailedPattern(name, in, pattern string) *Validation {
0000000000000000000000000000000000000000;;		var msg string
0000000000000000000000000000000000000000;;		if in == "" {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(patternFailNoIn, name, pattern)
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			msg = fmt.Sprintf(patternFail, name, in, pattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Validation{
0000000000000000000000000000000000000000;;			code:    422,
0000000000000000000000000000000000000000;;			Name:    name,
0000000000000000000000000000000000000000;;			In:      in,
0000000000000000000000000000000000000000;;			message: msg,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
