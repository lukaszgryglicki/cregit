0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package errors
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error represents a error interface all swagger framework errors implement
0000000000000000000000000000000000000000;;	type Error interface {
0000000000000000000000000000000000000000;;		error
0000000000000000000000000000000000000000;;		Code() int32
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type apiError struct {
0000000000000000000000000000000000000000;;		code    int32
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *apiError) Error() string {
0000000000000000000000000000000000000000;;		return a.message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (a *apiError) Code() int32 {
0000000000000000000000000000000000000000;;		return a.code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new API error with a code and a message
0000000000000000000000000000000000000000;;	func New(code int32, message string, args ...interface{}) Error {
0000000000000000000000000000000000000000;;		if len(args) > 0 {
0000000000000000000000000000000000000000;;			return &apiError{code, fmt.Sprintf(message, args...)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &apiError{code, message}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotFound creates a new not found error
0000000000000000000000000000000000000000;;	func NotFound(message string, args ...interface{}) Error {
0000000000000000000000000000000000000000;;		if message == "" {
0000000000000000000000000000000000000000;;			message = "Not found"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return New(http.StatusNotFound, fmt.Sprintf(message, args...))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NotImplemented creates a new not implemented error
0000000000000000000000000000000000000000;;	func NotImplemented(message string) Error {
0000000000000000000000000000000000000000;;		return New(http.StatusNotImplemented, message)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MethodNotAllowedError represents an error for when the path matches but the method doesn't
0000000000000000000000000000000000000000;;	type MethodNotAllowedError struct {
0000000000000000000000000000000000000000;;		code    int32
0000000000000000000000000000000000000000;;		Allowed []string
0000000000000000000000000000000000000000;;		message string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (m *MethodNotAllowedError) Error() string {
0000000000000000000000000000000000000000;;		return m.message
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Code the error code
0000000000000000000000000000000000000000;;	func (m *MethodNotAllowedError) Code() int32 {
0000000000000000000000000000000000000000;;		return m.code
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func errorAsJSON(err Error) []byte {
0000000000000000000000000000000000000000;;		b, _ := json.Marshal(struct {
0000000000000000000000000000000000000000;;			Code    int32  `json:"code"`
0000000000000000000000000000000000000000;;			Message string `json:"message"`
0000000000000000000000000000000000000000;;		}{err.Code(), err.Error()})
0000000000000000000000000000000000000000;;		return b
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func flattenComposite(errs *CompositeError) *CompositeError {
0000000000000000000000000000000000000000;;		var res []error
0000000000000000000000000000000000000000;;		for _, er := range errs.Errors {
0000000000000000000000000000000000000000;;			switch e := er.(type) {
0000000000000000000000000000000000000000;;			case *CompositeError:
0000000000000000000000000000000000000000;;				if len(e.Errors) > 0 {
0000000000000000000000000000000000000000;;					flat := flattenComposite(e)
0000000000000000000000000000000000000000;;					if len(flat.Errors) > 0 {
0000000000000000000000000000000000000000;;						res = append(res, flat.Errors...)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			default:
0000000000000000000000000000000000000000;;				if e != nil {
0000000000000000000000000000000000000000;;					res = append(res, e)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return CompositeValidationError(res...)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MethodNotAllowed creates a new method not allowed error
0000000000000000000000000000000000000000;;	func MethodNotAllowed(requested string, allow []string) Error {
0000000000000000000000000000000000000000;;		msg := fmt.Sprintf("method %s is not allowed, but [%s] are", requested, strings.Join(allow, ","))
0000000000000000000000000000000000000000;;		return &MethodNotAllowedError{code: http.StatusMethodNotAllowed, Allowed: allow, message: msg}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServeError the error handler interface implemenation
0000000000000000000000000000000000000000;;	func ServeError(rw http.ResponseWriter, r *http.Request, err error) {
0000000000000000000000000000000000000000;;		switch e := err.(type) {
0000000000000000000000000000000000000000;;		case *CompositeError:
0000000000000000000000000000000000000000;;			er := flattenComposite(e)
0000000000000000000000000000000000000000;;			ServeError(rw, r, er.Errors[0])
0000000000000000000000000000000000000000;;		case *MethodNotAllowedError:
0000000000000000000000000000000000000000;;			rw.Header().Add("Allow", strings.Join(err.(*MethodNotAllowedError).Allowed, ","))
0000000000000000000000000000000000000000;;			rw.WriteHeader(int(e.Code()))
0000000000000000000000000000000000000000;;			if r == nil || r.Method != "HEAD" {
0000000000000000000000000000000000000000;;				rw.Write(errorAsJSON(e))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		case Error:
0000000000000000000000000000000000000000;;			if e == nil {
0000000000000000000000000000000000000000;;				rw.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;				rw.Write(errorAsJSON(New(http.StatusInternalServerError, "Unknown error")))
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rw.WriteHeader(int(e.Code()))
0000000000000000000000000000000000000000;;			if r == nil || r.Method != "HEAD" {
0000000000000000000000000000000000000000;;				rw.Write(errorAsJSON(e))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			rw.WriteHeader(http.StatusInternalServerError)
0000000000000000000000000000000000000000;;			if r == nil || r.Method != "HEAD" {
0000000000000000000000000000000000000000;;				rw.Write(errorAsJSON(New(http.StatusInternalServerError, err.Error())))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
