0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonpointer"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BooleanProperty creates a boolean property
0000000000000000000000000000000000000000;;	func BooleanProperty() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"boolean"}}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// BoolProperty creates a boolean property
0000000000000000000000000000000000000000;;	func BoolProperty() *Schema { return BooleanProperty() }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringProperty creates a string property
0000000000000000000000000000000000000000;;	func StringProperty() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"string"}}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CharProperty creates a string property
0000000000000000000000000000000000000000;;	func CharProperty() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"string"}}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float64Property creates a float64/double property
0000000000000000000000000000000000000000;;	func Float64Property() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"number"}, Format: "double"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Float32Property creates a float32/float property
0000000000000000000000000000000000000000;;	func Float32Property() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"number"}, Format: "float"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int8Property creates an int8 property
0000000000000000000000000000000000000000;;	func Int8Property() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"integer"}, Format: "int8"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int16Property creates an int16 property
0000000000000000000000000000000000000000;;	func Int16Property() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"integer"}, Format: "int16"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int32Property creates an int32 property
0000000000000000000000000000000000000000;;	func Int32Property() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"integer"}, Format: "int32"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Int64Property creates an int64 property
0000000000000000000000000000000000000000;;	func Int64Property() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"integer"}, Format: "int64"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StrFmtProperty creates a property for the named string format
0000000000000000000000000000000000000000;;	func StrFmtProperty(format string) *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"string"}, Format: format}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DateProperty creates a date property
0000000000000000000000000000000000000000;;	func DateProperty() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"string"}, Format: "date"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DateTimeProperty creates a date time property
0000000000000000000000000000000000000000;;	func DateTimeProperty() *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"string"}, Format: "date-time"}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MapProperty creates a map property
0000000000000000000000000000000000000000;;	func MapProperty(property *Schema) *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Type: []string{"object"}, AdditionalProperties: &SchemaOrBool{Allows: true, Schema: property}}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RefProperty creates a ref property
0000000000000000000000000000000000000000;;	func RefProperty(name string) *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Ref: MustCreateRef(name)}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RefSchema creates a ref property
0000000000000000000000000000000000000000;;	func RefSchema(name string) *Schema {
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Ref: MustCreateRef(name)}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ArrayProperty creates an array property
0000000000000000000000000000000000000000;;	func ArrayProperty(items *Schema) *Schema {
0000000000000000000000000000000000000000;;		if items == nil {
0000000000000000000000000000000000000000;;			return &Schema{SchemaProps: SchemaProps{Type: []string{"array"}}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Schema{SchemaProps: SchemaProps{Items: &SchemaOrArray{Schema: items}, Type: []string{"array"}}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ComposedSchema creates a schema with allOf
0000000000000000000000000000000000000000;;	func ComposedSchema(schemas ...Schema) *Schema {
0000000000000000000000000000000000000000;;		s := new(Schema)
0000000000000000000000000000000000000000;;		s.AllOf = schemas
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchemaURL represents a schema url
0000000000000000000000000000000000000000;;	type SchemaURL string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshal this to JSON
0000000000000000000000000000000000000000;;	func (r SchemaURL) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if r == "" {
0000000000000000000000000000000000000000;;			return []byte("{}"), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := map[string]interface{}{"$schema": string(r)}
0000000000000000000000000000000000000000;;		return json.Marshal(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON unmarshal this from JSON
0000000000000000000000000000000000000000;;	func (r *SchemaURL) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var v map[string]interface{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &v); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if vv, ok := v["$schema"]; ok {
0000000000000000000000000000000000000000;;			if str, ok := vv.(string); ok {
0000000000000000000000000000000000000000;;				u, err := url.Parse(str)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				*r = SchemaURL(u.String())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// type ExtraSchemaProps map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// // JSONSchema represents a structure that is a json schema draft 04
0000000000000000000000000000000000000000;;	// type JSONSchema struct {
0000000000000000000000000000000000000000;;	// 	SchemaProps
0000000000000000000000000000000000000000;;	// 	ExtraSchemaProps
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// // MarshalJSON marshal this to JSON
0000000000000000000000000000000000000000;;	// func (s JSONSchema) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;	// 	b1, err := json.Marshal(s.SchemaProps)
0000000000000000000000000000000000000000;;	// 	if err != nil {
0000000000000000000000000000000000000000;;	// 		return nil, err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	b2, err := s.Ref.MarshalJSON()
0000000000000000000000000000000000000000;;	// 	if err != nil {
0000000000000000000000000000000000000000;;	// 		return nil, err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	b3, err := s.Schema.MarshalJSON()
0000000000000000000000000000000000000000;;	// 	if err != nil {
0000000000000000000000000000000000000000;;	// 		return nil, err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	b4, err := json.Marshal(s.ExtraSchemaProps)
0000000000000000000000000000000000000000;;	// 	if err != nil {
0000000000000000000000000000000000000000;;	// 		return nil, err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	return swag.ConcatJSON(b1, b2, b3, b4), nil
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// // UnmarshalJSON marshal this from JSON
0000000000000000000000000000000000000000;;	// func (s *JSONSchema) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;	// 	var sch JSONSchema
0000000000000000000000000000000000000000;;	// 	if err := json.Unmarshal(data, &sch.SchemaProps); err != nil {
0000000000000000000000000000000000000000;;	// 		return err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	if err := json.Unmarshal(data, &sch.Ref); err != nil {
0000000000000000000000000000000000000000;;	// 		return err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	if err := json.Unmarshal(data, &sch.Schema); err != nil {
0000000000000000000000000000000000000000;;	// 		return err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	if err := json.Unmarshal(data, &sch.ExtraSchemaProps); err != nil {
0000000000000000000000000000000000000000;;	// 		return err
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// 	*s = sch
0000000000000000000000000000000000000000;;	// 	return nil
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SchemaProps struct {
0000000000000000000000000000000000000000;;		ID                   string            `json:"id,omitempty"`
0000000000000000000000000000000000000000;;		Ref                  Ref               `json:"-,omitempty"`
0000000000000000000000000000000000000000;;		Schema               SchemaURL         `json:"-,omitempty"`
0000000000000000000000000000000000000000;;		Description          string            `json:"description,omitempty"`
0000000000000000000000000000000000000000;;		Type                 StringOrArray     `json:"type,omitempty"`
0000000000000000000000000000000000000000;;		Format               string            `json:"format,omitempty"`
0000000000000000000000000000000000000000;;		Title                string            `json:"title,omitempty"`
0000000000000000000000000000000000000000;;		Default              interface{}       `json:"default,omitempty"`
0000000000000000000000000000000000000000;;		Maximum              *float64          `json:"maximum,omitempty"`
0000000000000000000000000000000000000000;;		ExclusiveMaximum     bool              `json:"exclusiveMaximum,omitempty"`
0000000000000000000000000000000000000000;;		Minimum              *float64          `json:"minimum,omitempty"`
0000000000000000000000000000000000000000;;		ExclusiveMinimum     bool              `json:"exclusiveMinimum,omitempty"`
0000000000000000000000000000000000000000;;		MaxLength            *int64            `json:"maxLength,omitempty"`
0000000000000000000000000000000000000000;;		MinLength            *int64            `json:"minLength,omitempty"`
0000000000000000000000000000000000000000;;		Pattern              string            `json:"pattern,omitempty"`
0000000000000000000000000000000000000000;;		MaxItems             *int64            `json:"maxItems,omitempty"`
0000000000000000000000000000000000000000;;		MinItems             *int64            `json:"minItems,omitempty"`
0000000000000000000000000000000000000000;;		UniqueItems          bool              `json:"uniqueItems,omitempty"`
0000000000000000000000000000000000000000;;		MultipleOf           *float64          `json:"multipleOf,omitempty"`
0000000000000000000000000000000000000000;;		Enum                 []interface{}     `json:"enum,omitempty"`
0000000000000000000000000000000000000000;;		MaxProperties        *int64            `json:"maxProperties,omitempty"`
0000000000000000000000000000000000000000;;		MinProperties        *int64            `json:"minProperties,omitempty"`
0000000000000000000000000000000000000000;;		Required             []string          `json:"required,omitempty"`
0000000000000000000000000000000000000000;;		Items                *SchemaOrArray    `json:"items,omitempty"`
0000000000000000000000000000000000000000;;		AllOf                []Schema          `json:"allOf,omitempty"`
0000000000000000000000000000000000000000;;		OneOf                []Schema          `json:"oneOf,omitempty"`
0000000000000000000000000000000000000000;;		AnyOf                []Schema          `json:"anyOf,omitempty"`
0000000000000000000000000000000000000000;;		Not                  *Schema           `json:"not,omitempty"`
0000000000000000000000000000000000000000;;		Properties           map[string]Schema `json:"properties,omitempty"`
0000000000000000000000000000000000000000;;		AdditionalProperties *SchemaOrBool     `json:"additionalProperties,omitempty"`
0000000000000000000000000000000000000000;;		PatternProperties    map[string]Schema `json:"patternProperties,omitempty"`
0000000000000000000000000000000000000000;;		Dependencies         Dependencies      `json:"dependencies,omitempty"`
0000000000000000000000000000000000000000;;		AdditionalItems      *SchemaOrBool     `json:"additionalItems,omitempty"`
0000000000000000000000000000000000000000;;		Definitions          Definitions       `json:"definitions,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SwaggerSchemaProps struct {
0000000000000000000000000000000000000000;;		Discriminator string                 `json:"discriminator,omitempty"`
0000000000000000000000000000000000000000;;		ReadOnly      bool                   `json:"readOnly,omitempty"`
0000000000000000000000000000000000000000;;		XML           *XMLObject             `json:"xml,omitempty"`
0000000000000000000000000000000000000000;;		ExternalDocs  *ExternalDocumentation `json:"externalDocs,omitempty"`
0000000000000000000000000000000000000000;;		Example       interface{}            `json:"example,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Schema the schema object allows the definition of input and output data types.
0000000000000000000000000000000000000000;;	// These types can be objects, but also primitives and arrays.
0000000000000000000000000000000000000000;;	// This object is based on the [JSON Schema Specification Draft 4](http://json-schema.org/)
0000000000000000000000000000000000000000;;	// and uses a predefined subset of it.
0000000000000000000000000000000000000000;;	// On top of this subset, there are extensions provided by this specification to allow for more complete documentation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information: http://goo.gl/8us55a#schemaObject
0000000000000000000000000000000000000000;;	type Schema struct {
0000000000000000000000000000000000000000;;		VendorExtensible
0000000000000000000000000000000000000000;;		SchemaProps
0000000000000000000000000000000000000000;;		SwaggerSchemaProps
0000000000000000000000000000000000000000;;		ExtraProps map[string]interface{} `json:"-"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONLookup implements an interface to customize json pointer lookup
0000000000000000000000000000000000000000;;	func (s Schema) JSONLookup(token string) (interface{}, error) {
0000000000000000000000000000000000000000;;		if ex, ok := s.Extensions[token]; ok {
0000000000000000000000000000000000000000;;			return &ex, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ex, ok := s.ExtraProps[token]; ok {
0000000000000000000000000000000000000000;;			return &ex, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r, _, err := jsonpointer.GetForToken(s.SchemaProps, token)
0000000000000000000000000000000000000000;;		if r != nil || err != nil {
0000000000000000000000000000000000000000;;			return r, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, _, err = jsonpointer.GetForToken(s.SwaggerSchemaProps, token)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithID sets the id for this schema, allows for chaining
0000000000000000000000000000000000000000;;	func (s *Schema) WithID(id string) *Schema {
0000000000000000000000000000000000000000;;		s.ID = id
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithTitle sets the title for this schema, allows for chaining
0000000000000000000000000000000000000000;;	func (s *Schema) WithTitle(title string) *Schema {
0000000000000000000000000000000000000000;;		s.Title = title
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDescription sets the description for this schema, allows for chaining
0000000000000000000000000000000000000000;;	func (s *Schema) WithDescription(description string) *Schema {
0000000000000000000000000000000000000000;;		s.Description = description
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithProperties sets the properties for this schema
0000000000000000000000000000000000000000;;	func (s *Schema) WithProperties(schemas map[string]Schema) *Schema {
0000000000000000000000000000000000000000;;		s.Properties = schemas
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetProperty sets a property on this schema
0000000000000000000000000000000000000000;;	func (s *Schema) SetProperty(name string, schema Schema) *Schema {
0000000000000000000000000000000000000000;;		if s.Properties == nil {
0000000000000000000000000000000000000000;;			s.Properties = make(map[string]Schema)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.Properties[name] = schema
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithAllOf sets the all of property
0000000000000000000000000000000000000000;;	func (s *Schema) WithAllOf(schemas ...Schema) *Schema {
0000000000000000000000000000000000000000;;		s.AllOf = schemas
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMaxProperties sets the max number of properties an object can have
0000000000000000000000000000000000000000;;	func (s *Schema) WithMaxProperties(max int64) *Schema {
0000000000000000000000000000000000000000;;		s.MaxProperties = &max
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMinProperties sets the min number of properties an object must have
0000000000000000000000000000000000000000;;	func (s *Schema) WithMinProperties(min int64) *Schema {
0000000000000000000000000000000000000000;;		s.MinProperties = &min
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Typed sets the type of this schema for a single value item
0000000000000000000000000000000000000000;;	func (s *Schema) Typed(tpe, format string) *Schema {
0000000000000000000000000000000000000000;;		s.Type = []string{tpe}
0000000000000000000000000000000000000000;;		s.Format = format
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddType adds a type with potential format to the types for this schema
0000000000000000000000000000000000000000;;	func (s *Schema) AddType(tpe, format string) *Schema {
0000000000000000000000000000000000000000;;		s.Type = append(s.Type, tpe)
0000000000000000000000000000000000000000;;		if format != "" {
0000000000000000000000000000000000000000;;			s.Format = format
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CollectionOf a fluent builder method for an array parameter
0000000000000000000000000000000000000000;;	func (s *Schema) CollectionOf(items Schema) *Schema {
0000000000000000000000000000000000000000;;		s.Type = []string{"array"}
0000000000000000000000000000000000000000;;		s.Items = &SchemaOrArray{Schema: &items}
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDefault sets the default value on this parameter
0000000000000000000000000000000000000000;;	func (s *Schema) WithDefault(defaultValue interface{}) *Schema {
0000000000000000000000000000000000000000;;		s.Default = defaultValue
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithRequired flags this parameter as required
0000000000000000000000000000000000000000;;	func (s *Schema) WithRequired(items ...string) *Schema {
0000000000000000000000000000000000000000;;		s.Required = items
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddRequired  adds field names to the required properties array
0000000000000000000000000000000000000000;;	func (s *Schema) AddRequired(items ...string) *Schema {
0000000000000000000000000000000000000000;;		s.Required = append(s.Required, items...)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMaxLength sets a max length value
0000000000000000000000000000000000000000;;	func (s *Schema) WithMaxLength(max int64) *Schema {
0000000000000000000000000000000000000000;;		s.MaxLength = &max
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMinLength sets a min length value
0000000000000000000000000000000000000000;;	func (s *Schema) WithMinLength(min int64) *Schema {
0000000000000000000000000000000000000000;;		s.MinLength = &min
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithPattern sets a pattern value
0000000000000000000000000000000000000000;;	func (s *Schema) WithPattern(pattern string) *Schema {
0000000000000000000000000000000000000000;;		s.Pattern = pattern
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMultipleOf sets a multiple of value
0000000000000000000000000000000000000000;;	func (s *Schema) WithMultipleOf(number float64) *Schema {
0000000000000000000000000000000000000000;;		s.MultipleOf = &number
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMaximum sets a maximum number value
0000000000000000000000000000000000000000;;	func (s *Schema) WithMaximum(max float64, exclusive bool) *Schema {
0000000000000000000000000000000000000000;;		s.Maximum = &max
0000000000000000000000000000000000000000;;		s.ExclusiveMaximum = exclusive
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMinimum sets a minimum number value
0000000000000000000000000000000000000000;;	func (s *Schema) WithMinimum(min float64, exclusive bool) *Schema {
0000000000000000000000000000000000000000;;		s.Minimum = &min
0000000000000000000000000000000000000000;;		s.ExclusiveMinimum = exclusive
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithEnum sets a the enum values (replace)
0000000000000000000000000000000000000000;;	func (s *Schema) WithEnum(values ...interface{}) *Schema {
0000000000000000000000000000000000000000;;		s.Enum = append([]interface{}{}, values...)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMaxItems sets the max items
0000000000000000000000000000000000000000;;	func (s *Schema) WithMaxItems(size int64) *Schema {
0000000000000000000000000000000000000000;;		s.MaxItems = &size
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithMinItems sets the min items
0000000000000000000000000000000000000000;;	func (s *Schema) WithMinItems(size int64) *Schema {
0000000000000000000000000000000000000000;;		s.MinItems = &size
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UniqueValues dictates that this array can only have unique items
0000000000000000000000000000000000000000;;	func (s *Schema) UniqueValues() *Schema {
0000000000000000000000000000000000000000;;		s.UniqueItems = true
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AllowDuplicates this array can have duplicates
0000000000000000000000000000000000000000;;	func (s *Schema) AllowDuplicates() *Schema {
0000000000000000000000000000000000000000;;		s.UniqueItems = false
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddToAllOf adds a schema to the allOf property
0000000000000000000000000000000000000000;;	func (s *Schema) AddToAllOf(schemas ...Schema) *Schema {
0000000000000000000000000000000000000000;;		s.AllOf = append(s.AllOf, schemas...)
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithDiscriminator sets the name of the discriminator field
0000000000000000000000000000000000000000;;	func (s *Schema) WithDiscriminator(discriminator string) *Schema {
0000000000000000000000000000000000000000;;		s.Discriminator = discriminator
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsReadOnly flags this schema as readonly
0000000000000000000000000000000000000000;;	func (s *Schema) AsReadOnly() *Schema {
0000000000000000000000000000000000000000;;		s.ReadOnly = true
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsWritable flags this schema as writeable (not read-only)
0000000000000000000000000000000000000000;;	func (s *Schema) AsWritable() *Schema {
0000000000000000000000000000000000000000;;		s.ReadOnly = false
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithExample sets the example for this schema
0000000000000000000000000000000000000000;;	func (s *Schema) WithExample(example interface{}) *Schema {
0000000000000000000000000000000000000000;;		s.Example = example
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithExternalDocs sets/removes the external docs for/from this schema.
0000000000000000000000000000000000000000;;	// When you pass empty strings as params the external documents will be removed.
0000000000000000000000000000000000000000;;	// When you pass non-empty string as one value then those values will be used on the external docs object.
0000000000000000000000000000000000000000;;	// So when you pass a non-empty description, you should also pass the url and vice versa.
0000000000000000000000000000000000000000;;	func (s *Schema) WithExternalDocs(description, url string) *Schema {
0000000000000000000000000000000000000000;;		if description == "" && url == "" {
0000000000000000000000000000000000000000;;			s.ExternalDocs = nil
0000000000000000000000000000000000000000;;			return s
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.ExternalDocs == nil {
0000000000000000000000000000000000000000;;			s.ExternalDocs = &ExternalDocumentation{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.ExternalDocs.Description = description
0000000000000000000000000000000000000000;;		s.ExternalDocs.URL = url
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithXMLName sets the xml name for the object
0000000000000000000000000000000000000000;;	func (s *Schema) WithXMLName(name string) *Schema {
0000000000000000000000000000000000000000;;		if s.XML == nil {
0000000000000000000000000000000000000000;;			s.XML = new(XMLObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.XML.Name = name
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithXMLNamespace sets the xml namespace for the object
0000000000000000000000000000000000000000;;	func (s *Schema) WithXMLNamespace(namespace string) *Schema {
0000000000000000000000000000000000000000;;		if s.XML == nil {
0000000000000000000000000000000000000000;;			s.XML = new(XMLObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.XML.Namespace = namespace
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WithXMLPrefix sets the xml prefix for the object
0000000000000000000000000000000000000000;;	func (s *Schema) WithXMLPrefix(prefix string) *Schema {
0000000000000000000000000000000000000000;;		if s.XML == nil {
0000000000000000000000000000000000000000;;			s.XML = new(XMLObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.XML.Prefix = prefix
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsXMLAttribute flags this object as xml attribute
0000000000000000000000000000000000000000;;	func (s *Schema) AsXMLAttribute() *Schema {
0000000000000000000000000000000000000000;;		if s.XML == nil {
0000000000000000000000000000000000000000;;			s.XML = new(XMLObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.XML.Attribute = true
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsXMLElement flags this object as an xml node
0000000000000000000000000000000000000000;;	func (s *Schema) AsXMLElement() *Schema {
0000000000000000000000000000000000000000;;		if s.XML == nil {
0000000000000000000000000000000000000000;;			s.XML = new(XMLObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.XML.Attribute = false
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsWrappedXML flags this object as wrapped, this is mostly useful for array types
0000000000000000000000000000000000000000;;	func (s *Schema) AsWrappedXML() *Schema {
0000000000000000000000000000000000000000;;		if s.XML == nil {
0000000000000000000000000000000000000000;;			s.XML = new(XMLObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.XML.Wrapped = true
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AsUnwrappedXML flags this object as an xml node
0000000000000000000000000000000000000000;;	func (s *Schema) AsUnwrappedXML() *Schema {
0000000000000000000000000000000000000000;;		if s.XML == nil {
0000000000000000000000000000000000000000;;			s.XML = new(XMLObject)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.XML.Wrapped = false
0000000000000000000000000000000000000000;;		return s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshal this to JSON
0000000000000000000000000000000000000000;;	func (s Schema) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		b1, err := json.Marshal(s.SchemaProps)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("schema props %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b2, err := json.Marshal(s.VendorExtensible)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("vendor props %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b3, err := s.Ref.MarshalJSON()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("ref prop %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b4, err := s.Schema.MarshalJSON()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("schema prop %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b5, err := json.Marshal(s.SwaggerSchemaProps)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("common validations %v", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var b6 []byte
0000000000000000000000000000000000000000;;		if s.ExtraProps != nil {
0000000000000000000000000000000000000000;;			jj, err := json.Marshal(s.ExtraProps)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("extra props %v", err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			b6 = jj
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return swag.ConcatJSON(b1, b2, b3, b4, b5, b6), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON marshal this from JSON
0000000000000000000000000000000000000000;;	func (s *Schema) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var sch Schema
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &sch.SchemaProps); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &sch.Ref); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &sch.Schema); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &sch.SwaggerSchemaProps); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var d map[string]interface{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &d); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		delete(d, "$ref")
0000000000000000000000000000000000000000;;		delete(d, "$schema")
0000000000000000000000000000000000000000;;		for _, pn := range swag.DefaultJSONNameProvider.GetJSONNames(s) {
0000000000000000000000000000000000000000;;			delete(d, pn)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, vv := range d {
0000000000000000000000000000000000000000;;			lk := strings.ToLower(k)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(lk, "x-") {
0000000000000000000000000000000000000000;;				if sch.Extensions == nil {
0000000000000000000000000000000000000000;;					sch.Extensions = map[string]interface{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				sch.Extensions[k] = vv
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if sch.ExtraProps == nil {
0000000000000000000000000000000000000000;;				sch.ExtraProps = map[string]interface{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sch.ExtraProps[k] = vv
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		*s = sch
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
