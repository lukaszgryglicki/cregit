0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"os"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonreference"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Refable is a struct for things that accept a $ref property
0000000000000000000000000000000000000000;;	type Refable struct {
0000000000000000000000000000000000000000;;		Ref Ref
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshals the ref to json
0000000000000000000000000000000000000000;;	func (r Refable) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		return r.Ref.MarshalJSON()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON unmarshalss the ref from json
0000000000000000000000000000000000000000;;	func (r *Refable) UnmarshalJSON(d []byte) error {
0000000000000000000000000000000000000000;;		return json.Unmarshal(d, &r.Ref)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ref represents a json reference that is potentially resolved
0000000000000000000000000000000000000000;;	type Ref struct {
0000000000000000000000000000000000000000;;		jsonreference.Ref
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RemoteURI gets the remote uri part of the ref
0000000000000000000000000000000000000000;;	func (r *Ref) RemoteURI() string {
0000000000000000000000000000000000000000;;		if r.String() == "" {
0000000000000000000000000000000000000000;;			return r.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		u := *r.GetURL()
0000000000000000000000000000000000000000;;		u.Fragment = ""
0000000000000000000000000000000000000000;;		return u.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsValidURI returns true when the url the ref points to can be found
0000000000000000000000000000000000000000;;	func (r *Ref) IsValidURI() bool {
0000000000000000000000000000000000000000;;		if r.String() == "" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		v := r.RemoteURI()
0000000000000000000000000000000000000000;;		if v == "" {
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.HasFullURL {
0000000000000000000000000000000000000000;;			rr, err := http.Get(v)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return rr.StatusCode/100 == 2
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !(r.HasFileScheme || r.HasFullFilePath || r.HasURLPathOnly) {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check for local file
0000000000000000000000000000000000000000;;		pth := v
0000000000000000000000000000000000000000;;		if r.HasURLPathOnly {
0000000000000000000000000000000000000000;;			p, e := filepath.Abs(pth)
0000000000000000000000000000000000000000;;			if e != nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			pth = p
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		fi, err := os.Stat(pth)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return !fi.IsDir()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Inherits creates a new reference from a parent and a child
0000000000000000000000000000000000000000;;	// If the child cannot inherit from the parent, an error is returned
0000000000000000000000000000000000000000;;	func (r *Ref) Inherits(child Ref) (*Ref, error) {
0000000000000000000000000000000000000000;;		ref, err := r.Ref.Inherits(child.Ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &Ref{Ref: *ref}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewRef creates a new instance of a ref object
0000000000000000000000000000000000000000;;	// returns an error when the reference uri is an invalid uri
0000000000000000000000000000000000000000;;	func NewRef(refURI string) (Ref, error) {
0000000000000000000000000000000000000000;;		ref, err := jsonreference.New(refURI)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return Ref{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return Ref{Ref: ref}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustCreateRef creates a ref object but
0000000000000000000000000000000000000000;;	func MustCreateRef(refURI string) Ref {
0000000000000000000000000000000000000000;;		return Ref{Ref: jsonreference.MustCreateRef(refURI)}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// // NewResolvedRef creates a resolved ref
0000000000000000000000000000000000000000;;	// func NewResolvedRef(refURI string, data interface{}) Ref {
0000000000000000000000000000000000000000;;	// 	return Ref{
0000000000000000000000000000000000000000;;	// 		Ref:      jsonreference.MustCreateRef(refURI),
0000000000000000000000000000000000000000;;	// 		Resolved: data,
0000000000000000000000000000000000000000;;	// 	}
0000000000000000000000000000000000000000;;	// }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshals this ref into a JSON object
0000000000000000000000000000000000000000;;	func (r Ref) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		str := r.String()
0000000000000000000000000000000000000000;;		if str == "" {
0000000000000000000000000000000000000000;;			if r.IsRoot() {
0000000000000000000000000000000000000000;;				return []byte(`{"$ref":"#"}`), nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return []byte("{}"), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v := map[string]interface{}{"$ref": str}
0000000000000000000000000000000000000000;;		return json.Marshal(v)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON unmarshals this ref from a JSON object
0000000000000000000000000000000000000000;;	func (r *Ref) UnmarshalJSON(d []byte) error {
0000000000000000000000000000000000000000;;		var v map[string]interface{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(d, &v); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if v == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if vv, ok := v["$ref"]; ok {
0000000000000000000000000000000000000000;;			if str, ok := vv.(string); ok {
0000000000000000000000000000000000000000;;				ref, err := jsonreference.New(str)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*r = Ref{Ref: ref}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
