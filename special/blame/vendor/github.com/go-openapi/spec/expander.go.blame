0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonpointer"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolutionCache a cache for resolving urls
0000000000000000000000000000000000000000;;	type ResolutionCache interface {
0000000000000000000000000000000000000000;;		Get(string) (interface{}, bool)
0000000000000000000000000000000000000000;;		Set(string, interface{})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type simpleCache struct {
0000000000000000000000000000000000000000;;		lock  sync.Mutex
0000000000000000000000000000000000000000;;		store map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var resCache = initResolutionCache()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func initResolutionCache() ResolutionCache {
0000000000000000000000000000000000000000;;		return &simpleCache{store: map[string]interface{}{
0000000000000000000000000000000000000000;;			"http://swagger.io/v2/schema.json":       MustLoadSwagger20Schema(),
0000000000000000000000000000000000000000;;			"http://json-schema.org/draft-04/schema": MustLoadJSONSchemaDraft04(),
0000000000000000000000000000000000000000;;		}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleCache) Get(uri string) (interface{}, bool) {
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		v, ok := s.store[uri]
0000000000000000000000000000000000000000;;		s.lock.Unlock()
0000000000000000000000000000000000000000;;		return v, ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *simpleCache) Set(uri string, data interface{}) {
0000000000000000000000000000000000000000;;		s.lock.Lock()
0000000000000000000000000000000000000000;;		s.store[uri] = data
0000000000000000000000000000000000000000;;		s.lock.Unlock()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveRef resolves a reference against a context root
0000000000000000000000000000000000000000;;	func ResolveRef(root interface{}, ref *Ref) (*Schema, error) {
0000000000000000000000000000000000000000;;		resolver, err := defaultSchemaLoader(root, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := new(Schema)
0000000000000000000000000000000000000000;;		if err := resolver.Resolve(ref, result); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveParameter resolves a paramter reference against a context root
0000000000000000000000000000000000000000;;	func ResolveParameter(root interface{}, ref Ref) (*Parameter, error) {
0000000000000000000000000000000000000000;;		resolver, err := defaultSchemaLoader(root, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := new(Parameter)
0000000000000000000000000000000000000000;;		if err := resolver.Resolve(&ref, result); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResolveResponse resolves response a reference against a context root
0000000000000000000000000000000000000000;;	func ResolveResponse(root interface{}, ref Ref) (*Response, error) {
0000000000000000000000000000000000000000;;		resolver, err := defaultSchemaLoader(root, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		result := new(Response)
0000000000000000000000000000000000000000;;		if err := resolver.Resolve(&ref, result); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type schemaLoader struct {
0000000000000000000000000000000000000000;;		loadingRef  *Ref
0000000000000000000000000000000000000000;;		startingRef *Ref
0000000000000000000000000000000000000000;;		currentRef  *Ref
0000000000000000000000000000000000000000;;		root        interface{}
0000000000000000000000000000000000000000;;		cache       ResolutionCache
0000000000000000000000000000000000000000;;		loadDoc     func(string) (json.RawMessage, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var idPtr, _ = jsonpointer.New("/id")
0000000000000000000000000000000000000000;;	var schemaPtr, _ = jsonpointer.New("/$schema")
0000000000000000000000000000000000000000;;	var refPtr, _ = jsonpointer.New("/$ref")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaultSchemaLoader(root interface{}, ref *Ref, cache ResolutionCache) (*schemaLoader, error) {
0000000000000000000000000000000000000000;;		if cache == nil {
0000000000000000000000000000000000000000;;			cache = resCache
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var ptr *jsonpointer.Pointer
0000000000000000000000000000000000000000;;		if ref != nil {
0000000000000000000000000000000000000000;;			ptr = ref.GetPointer()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		currentRef := nextRef(root, ref, ptr)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &schemaLoader{
0000000000000000000000000000000000000000;;			root:        root,
0000000000000000000000000000000000000000;;			loadingRef:  ref,
0000000000000000000000000000000000000000;;			startingRef: ref,
0000000000000000000000000000000000000000;;			cache:       cache,
0000000000000000000000000000000000000000;;			loadDoc: func(path string) (json.RawMessage, error) {
0000000000000000000000000000000000000000;;				data, err := swag.LoadFromFileOrHTTP(path)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return json.RawMessage(data), nil
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			currentRef: currentRef,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func idFromNode(node interface{}) (*Ref, error) {
0000000000000000000000000000000000000000;;		if idValue, _, err := idPtr.Get(node); err == nil {
0000000000000000000000000000000000000000;;			if refStr, ok := idValue.(string); ok && refStr != "" {
0000000000000000000000000000000000000000;;				idRef, err := NewRef(refStr)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return &idRef, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func nextRef(startingNode interface{}, startingRef *Ref, ptr *jsonpointer.Pointer) *Ref {
0000000000000000000000000000000000000000;;		if startingRef == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ptr == nil {
0000000000000000000000000000000000000000;;			return startingRef
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ret := startingRef
0000000000000000000000000000000000000000;;		var idRef *Ref
0000000000000000000000000000000000000000;;		node := startingNode
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, tok := range ptr.DecodedTokens() {
0000000000000000000000000000000000000000;;			node, _, _ = jsonpointer.GetForToken(node, tok)
0000000000000000000000000000000000000000;;			if node == nil {
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			idRef, _ = idFromNode(node)
0000000000000000000000000000000000000000;;			if idRef != nil {
0000000000000000000000000000000000000000;;				nw, err := ret.Inherits(*idRef)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ret = nw
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			refRef, _, _ := refPtr.Get(node)
0000000000000000000000000000000000000000;;			if refRef != nil {
0000000000000000000000000000000000000000;;				rf, _ := NewRef(refRef.(string))
0000000000000000000000000000000000000000;;				nw, err := ret.Inherits(rf)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				ret = nw
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return ret
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *schemaLoader) resolveRef(currentRef, ref *Ref, node, target interface{}) error {
0000000000000000000000000000000000000000;;		tgt := reflect.ValueOf(target)
0000000000000000000000000000000000000000;;		if tgt.Kind() != reflect.Ptr {
0000000000000000000000000000000000000000;;			return fmt.Errorf("resolve ref: target needs to be a pointer")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		oldRef := currentRef
0000000000000000000000000000000000000000;;		if currentRef != nil {
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			currentRef, err = currentRef.Inherits(*nextRef(node, ref, currentRef.GetPointer()))
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if currentRef == nil {
0000000000000000000000000000000000000000;;			currentRef = ref
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refURL := currentRef.GetURL()
0000000000000000000000000000000000000000;;		if refURL == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if currentRef.IsRoot() {
0000000000000000000000000000000000000000;;			nv := reflect.ValueOf(node)
0000000000000000000000000000000000000000;;			reflect.Indirect(tgt).Set(reflect.Indirect(nv))
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if strings.HasPrefix(refURL.String(), "#") {
0000000000000000000000000000000000000000;;			res, _, err := ref.GetPointer().Get(node)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				res, _, err = ref.GetPointer().Get(r.root)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rv := reflect.Indirect(reflect.ValueOf(res))
0000000000000000000000000000000000000000;;			tgtType := reflect.Indirect(tgt).Type()
0000000000000000000000000000000000000000;;			if rv.Type().AssignableTo(tgtType) {
0000000000000000000000000000000000000000;;				reflect.Indirect(tgt).Set(reflect.Indirect(reflect.ValueOf(res)))
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				if err := swag.DynamicJSONToStruct(rv.Interface(), target); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if refURL.Scheme != "" && refURL.Host != "" {
0000000000000000000000000000000000000000;;			// most definitely take the red pill
0000000000000000000000000000000000000000;;			data, _, _, err := r.load(refURL)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if ((oldRef == nil && currentRef != nil) ||
0000000000000000000000000000000000000000;;				(oldRef != nil && currentRef == nil) ||
0000000000000000000000000000000000000000;;				oldRef.String() != currentRef.String()) &&
0000000000000000000000000000000000000000;;				((oldRef == nil && ref != nil) ||
0000000000000000000000000000000000000000;;					(oldRef != nil && ref == nil) ||
0000000000000000000000000000000000000000;;					(oldRef.String() != ref.String())) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				return r.resolveRef(currentRef, ref, data, target)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var res interface{}
0000000000000000000000000000000000000000;;			if currentRef.String() != "" {
0000000000000000000000000000000000000000;;				res, _, err = currentRef.GetPointer().Get(data)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				res = data
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := swag.DynamicJSONToStruct(res, target); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (r *schemaLoader) load(refURL *url.URL) (interface{}, url.URL, bool, error) {
0000000000000000000000000000000000000000;;		toFetch := *refURL
0000000000000000000000000000000000000000;;		toFetch.Fragment = ""
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		data, fromCache := r.cache.Get(toFetch.String())
0000000000000000000000000000000000000000;;		if !fromCache {
0000000000000000000000000000000000000000;;			b, err := r.loadDoc(toFetch.String())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, url.URL{}, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(b, &data); err != nil {
0000000000000000000000000000000000000000;;				return nil, url.URL{}, false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			r.cache.Set(toFetch.String(), data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return data, toFetch, fromCache, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	func (r *schemaLoader) Resolve(ref *Ref, target interface{}) error {
0000000000000000000000000000000000000000;;		if err := r.resolveRef(r.currentRef, ref, r.root, target); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type specExpander struct {
0000000000000000000000000000000000000000;;		spec     *Swagger
0000000000000000000000000000000000000000;;		resolver *schemaLoader
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpandSpec expands the references in a swagger spec
0000000000000000000000000000000000000000;;	func ExpandSpec(spec *Swagger) error {
0000000000000000000000000000000000000000;;		resolver, err := defaultSchemaLoader(spec, nil, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, defintition := range spec.Definitions {
0000000000000000000000000000000000000000;;			var def *Schema
0000000000000000000000000000000000000000;;			var err error
0000000000000000000000000000000000000000;;			if def, err = expandSchema(defintition, []string{"#/definitions/" + key}, resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			spec.Definitions[key] = *def
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, parameter := range spec.Parameters {
0000000000000000000000000000000000000000;;			if err := expandParameter(&parameter, resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			spec.Parameters[key] = parameter
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, response := range spec.Responses {
0000000000000000000000000000000000000000;;			if err := expandResponse(&response, resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			spec.Responses[key] = response
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if spec.Paths != nil {
0000000000000000000000000000000000000000;;			for key, path := range spec.Paths.Paths {
0000000000000000000000000000000000000000;;				if err := expandPathItem(&path, resolver); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				spec.Paths.Paths[key] = path
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExpandSchema expands the refs in the schema object
0000000000000000000000000000000000000000;;	func ExpandSchema(schema *Schema, root interface{}, cache ResolutionCache) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if schema == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if root == nil {
0000000000000000000000000000000000000000;;			root = schema
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nrr, _ := NewRef(schema.ID)
0000000000000000000000000000000000000000;;		var rrr *Ref
0000000000000000000000000000000000000000;;		if nrr.String() != "" {
0000000000000000000000000000000000000000;;			switch root.(type) {
0000000000000000000000000000000000000000;;			case *Schema:
0000000000000000000000000000000000000000;;				rid, _ := NewRef(root.(*Schema).ID)
0000000000000000000000000000000000000000;;				rrr, _ = rid.Inherits(nrr)
0000000000000000000000000000000000000000;;			case *Swagger:
0000000000000000000000000000000000000000;;				rid, _ := NewRef(root.(*Swagger).ID)
0000000000000000000000000000000000000000;;				rrr, _ = rid.Inherits(nrr)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resolver, err := defaultSchemaLoader(root, rrr, cache)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		refs := []string{""}
0000000000000000000000000000000000000000;;		if rrr != nil {
0000000000000000000000000000000000000000;;			refs[0] = rrr.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var s *Schema
0000000000000000000000000000000000000000;;		if s, err = expandSchema(*schema, refs, resolver); err != nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*schema = *s
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandItems(target Schema, parentRefs []string, resolver *schemaLoader) (*Schema, error) {
0000000000000000000000000000000000000000;;		if target.Items != nil {
0000000000000000000000000000000000000000;;			if target.Items.Schema != nil {
0000000000000000000000000000000000000000;;				t, err := expandSchema(*target.Items.Schema, parentRefs, resolver)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*target.Items.Schema = *t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := range target.Items.Schemas {
0000000000000000000000000000000000000000;;				t, err := expandSchema(target.Items.Schemas[i], parentRefs, resolver)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				target.Items.Schemas[i] = *t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &target, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandSchema(target Schema, parentRefs []string, resolver *schemaLoader) (schema *Schema, err error) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			schema = &target
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;		if target.Ref.String() == "" && target.Ref.IsRoot() {
0000000000000000000000000000000000000000;;			target = *resolver.root.(*Schema)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// t is the new expanded schema
0000000000000000000000000000000000000000;;		var t *Schema
0000000000000000000000000000000000000000;;		for target.Ref.String() != "" {
0000000000000000000000000000000000000000;;			// var newTarget Schema
0000000000000000000000000000000000000000;;			pRefs := strings.Join(parentRefs, ",")
0000000000000000000000000000000000000000;;			pRefs += ","
0000000000000000000000000000000000000000;;			if strings.Contains(pRefs, target.Ref.String()+",") {
0000000000000000000000000000000000000000;;				err = nil
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if err = resolver.Resolve(&target.Ref, &t); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			parentRefs = append(parentRefs, target.Ref.String())
0000000000000000000000000000000000000000;;			target = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if t, err = expandItems(target, parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		target = *t
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range target.AllOf {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(target.AllOf[i], parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.AllOf[i] = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range target.AnyOf {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(target.AnyOf[i], parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.AnyOf[i] = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i := range target.OneOf {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(target.OneOf[i], parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.OneOf[i] = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if target.Not != nil {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(*target.Not, parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*target.Not = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, _ := range target.Properties {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(target.Properties[k], parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.Properties[k] = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if target.AdditionalProperties != nil && target.AdditionalProperties.Schema != nil {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(*target.AdditionalProperties.Schema, parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*target.AdditionalProperties.Schema = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, _ := range target.PatternProperties {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(target.PatternProperties[k], parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.PatternProperties[k] = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, _ := range target.Dependencies {
0000000000000000000000000000000000000000;;			if target.Dependencies[k].Schema != nil {
0000000000000000000000000000000000000000;;				if t, err = expandSchema(*target.Dependencies[k].Schema, parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				*target.Dependencies[k].Schema = *t
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if target.AdditionalItems != nil && target.AdditionalItems.Schema != nil {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(*target.AdditionalItems.Schema, parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*target.AdditionalItems.Schema = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, _ := range target.Definitions {
0000000000000000000000000000000000000000;;			if t, err = expandSchema(target.Definitions[k], parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			target.Definitions[k] = *t
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandPathItem(pathItem *PathItem, resolver *schemaLoader) error {
0000000000000000000000000000000000000000;;		if pathItem == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if pathItem.Ref.String() != "" {
0000000000000000000000000000000000000000;;			if err := resolver.Resolve(&pathItem.Ref, &pathItem); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for idx := range pathItem.Parameters {
0000000000000000000000000000000000000000;;			if err := expandParameter(&(pathItem.Parameters[idx]), resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expandOperation(pathItem.Get, resolver); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expandOperation(pathItem.Head, resolver); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expandOperation(pathItem.Options, resolver); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expandOperation(pathItem.Put, resolver); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expandOperation(pathItem.Post, resolver); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expandOperation(pathItem.Patch, resolver); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := expandOperation(pathItem.Delete, resolver); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandOperation(op *Operation, resolver *schemaLoader) error {
0000000000000000000000000000000000000000;;		if op == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for i, param := range op.Parameters {
0000000000000000000000000000000000000000;;			if err := expandParameter(&param, resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			op.Parameters[i] = param
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if op.Responses != nil {
0000000000000000000000000000000000000000;;			responses := op.Responses
0000000000000000000000000000000000000000;;			if err := expandResponse(responses.Default, resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for code, response := range responses.StatusCodeResponses {
0000000000000000000000000000000000000000;;				if err := expandResponse(&response, resolver); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				responses.StatusCodeResponses[code] = response
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandResponse(response *Response, resolver *schemaLoader) error {
0000000000000000000000000000000000000000;;		if response == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.Ref.String() != "" {
0000000000000000000000000000000000000000;;			if err := resolver.Resolve(&response.Ref, response); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if response.Schema != nil {
0000000000000000000000000000000000000000;;			parentRefs := []string{response.Schema.Ref.String()}
0000000000000000000000000000000000000000;;			if err := resolver.Resolve(&response.Schema.Ref, &response.Schema); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s, err := expandSchema(*response.Schema, parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				*response.Schema = *s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func expandParameter(parameter *Parameter, resolver *schemaLoader) error {
0000000000000000000000000000000000000000;;		if parameter == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parameter.Ref.String() != "" {
0000000000000000000000000000000000000000;;			if err := resolver.Resolve(&parameter.Ref, parameter); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parameter.Schema != nil {
0000000000000000000000000000000000000000;;			parentRefs := []string{parameter.Schema.Ref.String()}
0000000000000000000000000000000000000000;;			if err := resolver.Resolve(&parameter.Schema.Ref, &parameter.Schema); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s, err := expandSchema(*parameter.Schema, parentRefs, resolver); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				*parameter.Schema = *s
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
