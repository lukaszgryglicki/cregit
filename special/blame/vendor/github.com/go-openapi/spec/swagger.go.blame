0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonpointer"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Swagger this is the root document object for the API specification.
0000000000000000000000000000000000000000;;	// It combines what previously was the Resource Listing and API Declaration (version 1.2 and earlier) together into one document.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information: http://goo.gl/8us55a#swagger-object-
0000000000000000000000000000000000000000;;	type Swagger struct {
0000000000000000000000000000000000000000;;		VendorExtensible
0000000000000000000000000000000000000000;;		SwaggerProps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONLookup look up a value by the json property name
0000000000000000000000000000000000000000;;	func (s Swagger) JSONLookup(token string) (interface{}, error) {
0000000000000000000000000000000000000000;;		if ex, ok := s.Extensions[token]; ok {
0000000000000000000000000000000000000000;;			return &ex, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, _, err := jsonpointer.GetForToken(s.SwaggerProps, token)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshals this swagger structure to json
0000000000000000000000000000000000000000;;	func (s Swagger) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		b1, err := json.Marshal(s.SwaggerProps)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b2, err := json.Marshal(s.VendorExtensible)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return swag.ConcatJSON(b1, b2), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON unmarshals a swagger spec from json
0000000000000000000000000000000000000000;;	func (s *Swagger) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var sw Swagger
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &sw.SwaggerProps); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &sw.VendorExtensible); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*s = sw
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type SwaggerProps struct {
0000000000000000000000000000000000000000;;		ID                  string                 `json:"id,omitempty"`
0000000000000000000000000000000000000000;;		Consumes            []string               `json:"consumes,omitempty"`
0000000000000000000000000000000000000000;;		Produces            []string               `json:"produces,omitempty"`
0000000000000000000000000000000000000000;;		Schemes             []string               `json:"schemes,omitempty"` // the scheme, when present must be from [http, https, ws, wss]
0000000000000000000000000000000000000000;;		Swagger             string                 `json:"swagger,omitempty"`
0000000000000000000000000000000000000000;;		Info                *Info                  `json:"info,omitempty"`
0000000000000000000000000000000000000000;;		Host                string                 `json:"host,omitempty"`
0000000000000000000000000000000000000000;;		BasePath            string                 `json:"basePath,omitempty"` // must start with a leading "/"
0000000000000000000000000000000000000000;;		Paths               *Paths                 `json:"paths"`              // required
0000000000000000000000000000000000000000;;		Definitions         Definitions            `json:"definitions"`
0000000000000000000000000000000000000000;;		Parameters          map[string]Parameter   `json:"parameters,omitempty"`
0000000000000000000000000000000000000000;;		Responses           map[string]Response    `json:"responses,omitempty"`
0000000000000000000000000000000000000000;;		SecurityDefinitions SecurityDefinitions    `json:"securityDefinitions,omitempty"`
0000000000000000000000000000000000000000;;		Security            []map[string][]string  `json:"security,omitempty"`
0000000000000000000000000000000000000000;;		Tags                []Tag                  `json:"tags,omitempty"`
0000000000000000000000000000000000000000;;		ExternalDocs        *ExternalDocumentation `json:"externalDocs,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Dependencies represent a dependencies property
0000000000000000000000000000000000000000;;	type Dependencies map[string]SchemaOrStringArray
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchemaOrBool represents a schema or boolean value, is biased towards true for the boolean property
0000000000000000000000000000000000000000;;	type SchemaOrBool struct {
0000000000000000000000000000000000000000;;		Allows bool
0000000000000000000000000000000000000000;;		Schema *Schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONLookup implements an interface to customize json pointer lookup
0000000000000000000000000000000000000000;;	func (s SchemaOrBool) JSONLookup(token string) (interface{}, error) {
0000000000000000000000000000000000000000;;		if token == "allows" {
0000000000000000000000000000000000000000;;			return s.Allows, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, _, err := jsonpointer.GetForToken(s.Schema, token)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var jsTrue = []byte("true")
0000000000000000000000000000000000000000;;	var jsFalse = []byte("false")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON convert this object to JSON
0000000000000000000000000000000000000000;;	func (s SchemaOrBool) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if s.Schema != nil {
0000000000000000000000000000000000000000;;			return json.Marshal(s.Schema)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Schema == nil && !s.Allows {
0000000000000000000000000000000000000000;;			return jsFalse, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return jsTrue, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON converts this bool or schema object from a JSON structure
0000000000000000000000000000000000000000;;	func (s *SchemaOrBool) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var nw SchemaOrBool
0000000000000000000000000000000000000000;;		if len(data) >= 4 {
0000000000000000000000000000000000000000;;			if data[0] == '{' {
0000000000000000000000000000000000000000;;				var sch Schema
0000000000000000000000000000000000000000;;				if err := json.Unmarshal(data, &sch); err != nil {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				nw.Schema = &sch
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nw.Allows = !(data[0] == 'f' && data[1] == 'a' && data[2] == 'l' && data[3] == 's' && data[4] == 'e')
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*s = nw
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchemaOrStringArray represents a schema or a string array
0000000000000000000000000000000000000000;;	type SchemaOrStringArray struct {
0000000000000000000000000000000000000000;;		Schema   *Schema
0000000000000000000000000000000000000000;;		Property []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONLookup implements an interface to customize json pointer lookup
0000000000000000000000000000000000000000;;	func (s SchemaOrStringArray) JSONLookup(token string) (interface{}, error) {
0000000000000000000000000000000000000000;;		r, _, err := jsonpointer.GetForToken(s.Schema, token)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON converts this schema object or array into JSON structure
0000000000000000000000000000000000000000;;	func (s SchemaOrStringArray) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(s.Property) > 0 {
0000000000000000000000000000000000000000;;			return json.Marshal(s.Property)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.Schema != nil {
0000000000000000000000000000000000000000;;			return json.Marshal(s.Schema)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON converts this schema object or array from a JSON structure
0000000000000000000000000000000000000000;;	func (s *SchemaOrStringArray) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var first byte
0000000000000000000000000000000000000000;;		if len(data) > 1 {
0000000000000000000000000000000000000000;;			first = data[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var nw SchemaOrStringArray
0000000000000000000000000000000000000000;;		if first == '{' {
0000000000000000000000000000000000000000;;			var sch Schema
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &sch); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nw.Schema = &sch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if first == '[' {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &nw.Property); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*s = nw
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Definitions contains the models explicitly defined in this spec
0000000000000000000000000000000000000000;;	// An object to hold data types that can be consumed and produced by operations.
0000000000000000000000000000000000000000;;	// These data types can be primitives, arrays or models.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information: http://goo.gl/8us55a#definitionsObject
0000000000000000000000000000000000000000;;	type Definitions map[string]Schema
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SecurityDefinitions a declaration of the security schemes available to be used in the specification.
0000000000000000000000000000000000000000;;	// This does not enforce the security schemes on the operations and only serves to provide
0000000000000000000000000000000000000000;;	// the relevant details for each scheme.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information: http://goo.gl/8us55a#securityDefinitionsObject
0000000000000000000000000000000000000000;;	type SecurityDefinitions map[string]*SecurityScheme
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// StringOrArray represents a value that can either be a string
0000000000000000000000000000000000000000;;	// or an array of strings. Mainly here for serialization purposes
0000000000000000000000000000000000000000;;	type StringOrArray []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Contains returns true when the value is contained in the slice
0000000000000000000000000000000000000000;;	func (s StringOrArray) Contains(value string) bool {
0000000000000000000000000000000000000000;;		for _, str := range s {
0000000000000000000000000000000000000000;;			if str == value {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONLookup implements an interface to customize json pointer lookup
0000000000000000000000000000000000000000;;	func (s SchemaOrArray) JSONLookup(token string) (interface{}, error) {
0000000000000000000000000000000000000000;;		if _, err := strconv.Atoi(token); err == nil {
0000000000000000000000000000000000000000;;			r, _, err := jsonpointer.GetForToken(s.Schemas, token)
0000000000000000000000000000000000000000;;			return r, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, _, err := jsonpointer.GetForToken(s.Schema, token)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON unmarshals this string or array object from a JSON array or JSON string
0000000000000000000000000000000000000000;;	func (s *StringOrArray) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var first byte
0000000000000000000000000000000000000000;;		if len(data) > 1 {
0000000000000000000000000000000000000000;;			first = data[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if first == '[' {
0000000000000000000000000000000000000000;;			var parsed []string
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &parsed); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*s = StringOrArray(parsed)
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var single interface{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &single); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if single == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		switch single.(type) {
0000000000000000000000000000000000000000;;		case string:
0000000000000000000000000000000000000000;;			*s = StringOrArray([]string{single.(string)})
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("only string or array is allowed, not %T", single)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON converts this string or array to a JSON array or JSON string
0000000000000000000000000000000000000000;;	func (s StringOrArray) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(s) == 1 {
0000000000000000000000000000000000000000;;			return json.Marshal([]string(s)[0])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal([]string(s))
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchemaOrArray represents a value that can either be a Schema
0000000000000000000000000000000000000000;;	// or an array of Schema. Mainly here for serialization purposes
0000000000000000000000000000000000000000;;	type SchemaOrArray struct {
0000000000000000000000000000000000000000;;		Schema  *Schema
0000000000000000000000000000000000000000;;		Schemas []Schema
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Len returns the number of schemas in this property
0000000000000000000000000000000000000000;;	func (s SchemaOrArray) Len() int {
0000000000000000000000000000000000000000;;		if s.Schema != nil {
0000000000000000000000000000000000000000;;			return 1
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(s.Schemas)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainsType returns true when one of the schemas is of the specified type
0000000000000000000000000000000000000000;;	func (s *SchemaOrArray) ContainsType(name string) bool {
0000000000000000000000000000000000000000;;		if s.Schema != nil {
0000000000000000000000000000000000000000;;			return s.Schema.Type != nil && s.Schema.Type.Contains(name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON converts this schema object or array into JSON structure
0000000000000000000000000000000000000000;;	func (s SchemaOrArray) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		if len(s.Schemas) > 0 {
0000000000000000000000000000000000000000;;			return json.Marshal(s.Schemas)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(s.Schema)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON converts this schema object or array from a JSON structure
0000000000000000000000000000000000000000;;	func (s *SchemaOrArray) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var nw SchemaOrArray
0000000000000000000000000000000000000000;;		var first byte
0000000000000000000000000000000000000000;;		if len(data) > 1 {
0000000000000000000000000000000000000000;;			first = data[0]
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if first == '{' {
0000000000000000000000000000000000000000;;			var sch Schema
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &sch); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nw.Schema = &sch
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if first == '[' {
0000000000000000000000000000000000000000;;			if err := json.Unmarshal(data, &nw.Schemas); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*s = nw
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// vim:set ft=go noet sts=2 sw=2 ts=2:
