0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package spec
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonpointer"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extensions vendor specific extensions
0000000000000000000000000000000000000000;;	type Extensions map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a value to these extensions
0000000000000000000000000000000000000000;;	func (e Extensions) Add(key string, value interface{}) {
0000000000000000000000000000000000000000;;		realKey := strings.ToLower(key)
0000000000000000000000000000000000000000;;		e[realKey] = value
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetString gets a string value from the extensions
0000000000000000000000000000000000000000;;	func (e Extensions) GetString(key string) (string, bool) {
0000000000000000000000000000000000000000;;		if v, ok := e[strings.ToLower(key)]; ok {
0000000000000000000000000000000000000000;;			str, ok := v.(string)
0000000000000000000000000000000000000000;;			return str, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetBool gets a string value from the extensions
0000000000000000000000000000000000000000;;	func (e Extensions) GetBool(key string) (bool, bool) {
0000000000000000000000000000000000000000;;		if v, ok := e[strings.ToLower(key)]; ok {
0000000000000000000000000000000000000000;;			str, ok := v.(bool)
0000000000000000000000000000000000000000;;			return str, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetStringSlice gets a string value from the extensions
0000000000000000000000000000000000000000;;	func (e Extensions) GetStringSlice(key string) ([]string, bool) {
0000000000000000000000000000000000000000;;		if v, ok := e[strings.ToLower(key)]; ok {
0000000000000000000000000000000000000000;;			arr, ok := v.([]interface{})
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			var strs []string
0000000000000000000000000000000000000000;;			for _, iface := range arr {
0000000000000000000000000000000000000000;;				str, ok := iface.(string)
0000000000000000000000000000000000000000;;				if !ok {
0000000000000000000000000000000000000000;;					return nil, false
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				strs = append(strs, str)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return strs, ok
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// VendorExtensible composition block.
0000000000000000000000000000000000000000;;	type VendorExtensible struct {
0000000000000000000000000000000000000000;;		Extensions Extensions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddExtension adds an extension to this extensible object
0000000000000000000000000000000000000000;;	func (v *VendorExtensible) AddExtension(key string, value interface{}) {
0000000000000000000000000000000000000000;;		if value == nil {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if v.Extensions == nil {
0000000000000000000000000000000000000000;;			v.Extensions = make(map[string]interface{})
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		v.Extensions.Add(key, value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshals the extensions to json
0000000000000000000000000000000000000000;;	func (v VendorExtensible) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		toser := make(map[string]interface{})
0000000000000000000000000000000000000000;;		for k, v := range v.Extensions {
0000000000000000000000000000000000000000;;			lk := strings.ToLower(k)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(lk, "x-") {
0000000000000000000000000000000000000000;;				toser[k] = v
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(toser)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON for this extensible object
0000000000000000000000000000000000000000;;	func (v *VendorExtensible) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		var d map[string]interface{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &d); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, vv := range d {
0000000000000000000000000000000000000000;;			lk := strings.ToLower(k)
0000000000000000000000000000000000000000;;			if strings.HasPrefix(lk, "x-") {
0000000000000000000000000000000000000000;;				if v.Extensions == nil {
0000000000000000000000000000000000000000;;					v.Extensions = map[string]interface{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				v.Extensions[k] = vv
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// InfoProps the properties for an info definition
0000000000000000000000000000000000000000;;	type InfoProps struct {
0000000000000000000000000000000000000000;;		Description    string       `json:"description,omitempty"`
0000000000000000000000000000000000000000;;		Title          string       `json:"title,omitempty"`
0000000000000000000000000000000000000000;;		TermsOfService string       `json:"termsOfService,omitempty"`
0000000000000000000000000000000000000000;;		Contact        *ContactInfo `json:"contact,omitempty"`
0000000000000000000000000000000000000000;;		License        *License     `json:"license,omitempty"`
0000000000000000000000000000000000000000;;		Version        string       `json:"version,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Info object provides metadata about the API.
0000000000000000000000000000000000000000;;	// The metadata can be used by the clients if needed, and can be presented in the Swagger-UI for convenience.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// For more information: http://goo.gl/8us55a#infoObject
0000000000000000000000000000000000000000;;	type Info struct {
0000000000000000000000000000000000000000;;		VendorExtensible
0000000000000000000000000000000000000000;;		InfoProps
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONLookup look up a value by the json property name
0000000000000000000000000000000000000000;;	func (i Info) JSONLookup(token string) (interface{}, error) {
0000000000000000000000000000000000000000;;		if ex, ok := i.Extensions[token]; ok {
0000000000000000000000000000000000000000;;			return &ex, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r, _, err := jsonpointer.GetForToken(i.InfoProps, token)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshal this to JSON
0000000000000000000000000000000000000000;;	func (i Info) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		b1, err := json.Marshal(i.InfoProps)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		b2, err := json.Marshal(i.VendorExtensible)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return swag.ConcatJSON(b1, b2), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalJSON marshal this from JSON
0000000000000000000000000000000000000000;;	func (i *Info) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &i.InfoProps); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(data, &i.VendorExtensible); err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
