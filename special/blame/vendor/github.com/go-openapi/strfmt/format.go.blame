0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package strfmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Default is the default formats registry
0000000000000000000000000000000000000000;;	var Default = NewSeededFormats(nil, nil)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validator represents a validator for a string format
0000000000000000000000000000000000000000;;	type Validator func(string) bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Format represents a string format
0000000000000000000000000000000000000000;;	type Format interface {
0000000000000000000000000000000000000000;;		String() string
0000000000000000000000000000000000000000;;		encoding.TextMarshaler
0000000000000000000000000000000000000000;;		encoding.TextUnmarshaler
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Registry is a registry of string formats
0000000000000000000000000000000000000000;;	type Registry interface {
0000000000000000000000000000000000000000;;		Add(string, Format, Validator) bool
0000000000000000000000000000000000000000;;		DelByName(string) bool
0000000000000000000000000000000000000000;;		GetType(string) (reflect.Type, bool)
0000000000000000000000000000000000000000;;		ContainsName(string) bool
0000000000000000000000000000000000000000;;		Validates(string, string) bool
0000000000000000000000000000000000000000;;		Parse(string, string) (interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type knownFormat struct {
0000000000000000000000000000000000000000;;		Name      string
0000000000000000000000000000000000000000;;		OrigName  string
0000000000000000000000000000000000000000;;		Type      reflect.Type
0000000000000000000000000000000000000000;;		Validator Validator
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NameNormalizer is a function that normalizes a format name
0000000000000000000000000000000000000000;;	type NameNormalizer func(string) string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DefaultNameNormalizer removes all dashes
0000000000000000000000000000000000000000;;	func DefaultNameNormalizer(name string) string {
0000000000000000000000000000000000000000;;		return strings.Replace(name, "-", "", -1)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type defaultFormats struct {
0000000000000000000000000000000000000000;;		sync.Mutex
0000000000000000000000000000000000000000;;		data          []knownFormat
0000000000000000000000000000000000000000;;		normalizeName NameNormalizer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewFormats creates a new formats registry seeded with the values from the default
0000000000000000000000000000000000000000;;	func NewFormats() Registry {
0000000000000000000000000000000000000000;;		return NewSeededFormats(Default.(*defaultFormats).data, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSeededFormats creates a new formats registry
0000000000000000000000000000000000000000;;	func NewSeededFormats(seeds []knownFormat, normalizer NameNormalizer) Registry {
0000000000000000000000000000000000000000;;		if normalizer == nil {
0000000000000000000000000000000000000000;;			normalizer = DefaultNameNormalizer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// copy here, don't modify original
0000000000000000000000000000000000000000;;		d := append([]knownFormat(nil), seeds...)
0000000000000000000000000000000000000000;;		return &defaultFormats{
0000000000000000000000000000000000000000;;			data:          d,
0000000000000000000000000000000000000000;;			normalizeName: normalizer,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Add adds a new format, return true if this was a new item instead of a replacement
0000000000000000000000000000000000000000;;	func (f *defaultFormats) Add(name string, strfmt Format, validator Validator) bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nme := f.normalizeName(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tpe := reflect.TypeOf(strfmt)
0000000000000000000000000000000000000000;;		if tpe.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			tpe = tpe.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i := range f.data {
0000000000000000000000000000000000000000;;			v := &f.data[i]
0000000000000000000000000000000000000000;;			if v.Name == nme {
0000000000000000000000000000000000000000;;				v.Type = tpe
0000000000000000000000000000000000000000;;				v.Validator = validator
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// turns out it's new after all
0000000000000000000000000000000000000000;;		f.data = append(f.data, knownFormat{Name: nme, OrigName: name, Type: tpe, Validator: validator})
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetType gets the type for the specified name
0000000000000000000000000000000000000000;;	func (f *defaultFormats) GetType(name string) (reflect.Type, bool) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		nme := f.normalizeName(name)
0000000000000000000000000000000000000000;;		for _, v := range f.data {
0000000000000000000000000000000000000000;;			if v.Name == nme {
0000000000000000000000000000000000000000;;				return v.Type, true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelByName removes the format by the specified name, returns true when an item was actually removed
0000000000000000000000000000000000000000;;	func (f *defaultFormats) DelByName(name string) bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		nme := f.normalizeName(name)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, v := range f.data {
0000000000000000000000000000000000000000;;			if v.Name == nme {
0000000000000000000000000000000000000000;;				f.data[i] = knownFormat{} // release
0000000000000000000000000000000000000000;;				f.data = append(f.data[:i], f.data[i+1:]...)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DelByType removes the specified format, returns true when an item was actually removed
0000000000000000000000000000000000000000;;	func (f *defaultFormats) DelByFormat(strfmt Format) bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tpe := reflect.TypeOf(strfmt)
0000000000000000000000000000000000000000;;		if tpe.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			tpe = tpe.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for i, v := range f.data {
0000000000000000000000000000000000000000;;			if v.Type == tpe {
0000000000000000000000000000000000000000;;				f.data[i] = knownFormat{} // release
0000000000000000000000000000000000000000;;				f.data = append(f.data[:i], f.data[i+1:]...)
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainsName returns true if this registry contains the specified name
0000000000000000000000000000000000000000;;	func (f *defaultFormats) ContainsName(name string) bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		nme := f.normalizeName(name)
0000000000000000000000000000000000000000;;		for _, v := range f.data {
0000000000000000000000000000000000000000;;			if v.Name == nme {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ContainsFormat returns true if this registry contains the specified format
0000000000000000000000000000000000000000;;	func (f *defaultFormats) ContainsFormat(strfmt Format) bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		tpe := reflect.TypeOf(strfmt)
0000000000000000000000000000000000000000;;		if tpe.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			tpe = tpe.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range f.data {
0000000000000000000000000000000000000000;;			if v.Type == tpe {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *defaultFormats) Validates(name, data string) bool {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		nme := f.normalizeName(name)
0000000000000000000000000000000000000000;;		for _, v := range f.data {
0000000000000000000000000000000000000000;;			if v.Name == nme {
0000000000000000000000000000000000000000;;				return v.Validator(data)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *defaultFormats) Parse(name, data string) (interface{}, error) {
0000000000000000000000000000000000000000;;		f.Lock()
0000000000000000000000000000000000000000;;		defer f.Unlock()
0000000000000000000000000000000000000000;;		nme := f.normalizeName(name)
0000000000000000000000000000000000000000;;		for _, v := range f.data {
0000000000000000000000000000000000000000;;			if v.Name == nme {
0000000000000000000000000000000000000000;;				nw := reflect.New(v.Type).Interface()
0000000000000000000000000000000000000000;;				if dec, ok := nw.(encoding.TextUnmarshaler); ok {
0000000000000000000000000000000000000000;;					if err := dec.UnmarshalText([]byte(data)); err != nil {
0000000000000000000000000000000000000000;;						return nil, err
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					return nw, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, errors.InvalidTypeName(name)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil, errors.InvalidTypeName(name)
0000000000000000000000000000000000000000;;	}
