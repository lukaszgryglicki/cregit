0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package strfmt
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"database/sql/driver"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/mailru/easyjson/jlexer"
0000000000000000000000000000000000000000;;		"github.com/mailru/easyjson/jwriter"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func init() {
0000000000000000000000000000000000000000;;		d := Duration(0)
0000000000000000000000000000000000000000;;		Default.Add("duration", &d, IsDuration)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		timeUnits = [][]string{
0000000000000000000000000000000000000000;;			{"ns", "nano"},
0000000000000000000000000000000000000000;;			{"us", "µs", "micro"},
0000000000000000000000000000000000000000;;			{"ms", "milli"},
0000000000000000000000000000000000000000;;			{"s", "sec"},
0000000000000000000000000000000000000000;;			{"m", "min"},
0000000000000000000000000000000000000000;;			{"h", "hr", "hour"},
0000000000000000000000000000000000000000;;			{"d", "day"},
0000000000000000000000000000000000000000;;			{"w", "wk", "week"},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeMultiplier = map[string]time.Duration{
0000000000000000000000000000000000000000;;			"ns": time.Nanosecond,
0000000000000000000000000000000000000000;;			"us": time.Microsecond,
0000000000000000000000000000000000000000;;			"ms": time.Millisecond,
0000000000000000000000000000000000000000;;			"s":  time.Second,
0000000000000000000000000000000000000000;;			"m":  time.Minute,
0000000000000000000000000000000000000000;;			"h":  time.Hour,
0000000000000000000000000000000000000000;;			"d":  24 * time.Hour,
0000000000000000000000000000000000000000;;			"w":  7 * 24 * time.Hour,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		durationMatcher = regexp.MustCompile(`((\d+)\s*([A-Za-zµ]+))`)
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsDuration returns true if the provided string is a valid duration
0000000000000000000000000000000000000000;;	func IsDuration(str string) bool {
0000000000000000000000000000000000000000;;		_, err := ParseDuration(str)
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Duration represents a duration
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// swagger:strfmt duration
0000000000000000000000000000000000000000;;	type Duration time.Duration
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalText turns this instance into text
0000000000000000000000000000000000000000;;	func (d Duration) MarshalText() ([]byte, error) {
0000000000000000000000000000000000000000;;		return []byte(time.Duration(d).String()), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnmarshalText hydrates this instance from text
0000000000000000000000000000000000000000;;	func (d *Duration) UnmarshalText(data []byte) error { // validation is performed later on
0000000000000000000000000000000000000000;;		dd, err := ParseDuration(string(data))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		*d = Duration(dd)
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ParseDuration parses a duration from a string, compatible with scala duration syntax
0000000000000000000000000000000000000000;;	func ParseDuration(cand string) (time.Duration, error) {
0000000000000000000000000000000000000000;;		if dur, err := time.ParseDuration(cand); err == nil {
0000000000000000000000000000000000000000;;			return dur, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var dur time.Duration
0000000000000000000000000000000000000000;;		ok := false
0000000000000000000000000000000000000000;;		for _, match := range durationMatcher.FindAllStringSubmatch(cand, -1) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			factor, err := strconv.Atoi(match[2]) // converts string to int
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return 0, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unit := strings.ToLower(strings.TrimSpace(match[3]))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, variants := range timeUnits {
0000000000000000000000000000000000000000;;				last := len(variants) - 1
0000000000000000000000000000000000000000;;				multiplier := timeMultiplier[variants[0]]
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for i, variant := range variants {
0000000000000000000000000000000000000000;;					if (last == i && strings.HasPrefix(unit, variant)) || strings.EqualFold(variant, unit) {
0000000000000000000000000000000000000000;;						ok = true
0000000000000000000000000000000000000000;;						dur += (time.Duration(factor) * multiplier)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if ok {
0000000000000000000000000000000000000000;;			return dur, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0, fmt.Errorf("Unable to parse %s as duration", cand)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scan reads a Duration value from database driver type.
0000000000000000000000000000000000000000;;	func (d *Duration) Scan(raw interface{}) error {
0000000000000000000000000000000000000000;;		switch v := raw.(type) {
0000000000000000000000000000000000000000;;		// TODO: case []byte: // ?
0000000000000000000000000000000000000000;;		case int64:
0000000000000000000000000000000000000000;;			*d = Duration(v)
0000000000000000000000000000000000000000;;		case float64:
0000000000000000000000000000000000000000;;			*d = Duration(int64(v))
0000000000000000000000000000000000000000;;		case nil:
0000000000000000000000000000000000000000;;			*d = Duration(0)
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return fmt.Errorf("cannot sql.Scan() strfmt.Duration from: %#v", v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Value converts Duration to a primitive value ready to written to a database.
0000000000000000000000000000000000000000;;	func (d Duration) Value() (driver.Value, error) {
0000000000000000000000000000000000000000;;		return driver.Value(int64(d)), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String converts this duration to a string
0000000000000000000000000000000000000000;;	func (d Duration) String() string {
0000000000000000000000000000000000000000;;		return time.Duration(d).String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Duration) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		var w jwriter.Writer
0000000000000000000000000000000000000000;;		d.MarshalEasyJSON(&w)
0000000000000000000000000000000000000000;;		return w.BuildBytes()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d Duration) MarshalEasyJSON(w *jwriter.Writer) {
0000000000000000000000000000000000000000;;		w.String(time.Duration(d).String())
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Duration) UnmarshalJSON(data []byte) error {
0000000000000000000000000000000000000000;;		l := jlexer.Lexer{Data: data}
0000000000000000000000000000000000000000;;		d.UnmarshalEasyJSON(&l)
0000000000000000000000000000000000000000;;		return l.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (d *Duration) UnmarshalEasyJSON(in *jlexer.Lexer) {
0000000000000000000000000000000000000000;;		if data := in.String(); in.Ok() {
0000000000000000000000000000000000000000;;			tt, err := ParseDuration(data)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				in.AddError(err)
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			*d = Duration(tt)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
