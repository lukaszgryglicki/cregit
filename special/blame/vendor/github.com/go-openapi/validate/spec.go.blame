0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"log"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/analysis"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonpointer"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/loads"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Spec validates a spec document
0000000000000000000000000000000000000000;;	// It validates the spec json against the json schema for swagger
0000000000000000000000000000000000000000;;	// and then validates a number of extra rules that can't be expressed in json schema:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// 	- definition can't declare a property that's already defined by one of its ancestors
0000000000000000000000000000000000000000;;	// 	- definition's ancestor can't be a descendant of the same model
0000000000000000000000000000000000000000;;	// 	- each api path should be non-verbatim (account for path param names) unique per method
0000000000000000000000000000000000000000;;	// 	- each security reference should contain only unique scopes
0000000000000000000000000000000000000000;;	// 	- each security scope in a security definition should be unique
0000000000000000000000000000000000000000;;	// 	- each path parameter should correspond to a parameter placeholder and vice versa
0000000000000000000000000000000000000000;;	// 	- each referencable definition must have references
0000000000000000000000000000000000000000;;	// 	- each definition property listed in the required array must be defined in the properties of the model
0000000000000000000000000000000000000000;;	// 	- each parameter should have a unique `name` and `type` combination
0000000000000000000000000000000000000000;;	// 	- each operation should have only 1 parameter of type body
0000000000000000000000000000000000000000;;	// 	- each reference must point to a valid object
0000000000000000000000000000000000000000;;	// 	- every default value that is specified must validate against the schema for that property
0000000000000000000000000000000000000000;;	// 	- items property is required for all schemas/definitions of type `array`
0000000000000000000000000000000000000000;;	func Spec(doc *loads.Document, formats strfmt.Registry) error {
0000000000000000000000000000000000000000;;		errs, _ /*warns*/ := NewSpecValidator(doc.Schema(), formats).Validate(doc)
0000000000000000000000000000000000000000;;		if errs.HasErrors() {
0000000000000000000000000000000000000000;;			return errors.CompositeValidationError(errs.Errors...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AgainstSchema validates the specified data with the provided schema, when no schema
0000000000000000000000000000000000000000;;	// is provided it uses the json schema as default
0000000000000000000000000000000000000000;;	func AgainstSchema(schema *spec.Schema, data interface{}, formats strfmt.Registry) error {
0000000000000000000000000000000000000000;;		res := NewSchemaValidator(schema, nil, "", formats).Validate(data)
0000000000000000000000000000000000000000;;		if res.HasErrors() {
0000000000000000000000000000000000000000;;			return errors.CompositeValidationError(res.Errors...)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SpecValidator validates a swagger spec
0000000000000000000000000000000000000000;;	type SpecValidator struct {
0000000000000000000000000000000000000000;;		schema       *spec.Schema // swagger 2.0 schema
0000000000000000000000000000000000000000;;		spec         *loads.Document
0000000000000000000000000000000000000000;;		analyzer     *analysis.Spec
0000000000000000000000000000000000000000;;		expanded     *loads.Document
0000000000000000000000000000000000000000;;		KnownFormats strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSpecValidator creates a new swagger spec validator instance
0000000000000000000000000000000000000000;;	func NewSpecValidator(schema *spec.Schema, formats strfmt.Registry) *SpecValidator {
0000000000000000000000000000000000000000;;		return &SpecValidator{
0000000000000000000000000000000000000000;;			schema:       schema,
0000000000000000000000000000000000000000;;			KnownFormats: formats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates the swagger spec
0000000000000000000000000000000000000000;;	func (s *SpecValidator) Validate(data interface{}) (errs *Result, warnings *Result) {
0000000000000000000000000000000000000000;;		var sd *loads.Document
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch v := data.(type) {
0000000000000000000000000000000000000000;;		case *loads.Document:
0000000000000000000000000000000000000000;;			sd = v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if sd == nil {
0000000000000000000000000000000000000000;;			errs = sErr(errors.New(500, "spec validator can only validate spec.Document objects"))
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s.spec = sd
0000000000000000000000000000000000000000;;		s.analyzer = analysis.New(sd.Spec())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs = new(Result)
0000000000000000000000000000000000000000;;		warnings = new(Result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schv := NewSchemaValidator(s.schema, nil, "", s.KnownFormats)
0000000000000000000000000000000000000000;;		var obj interface{}
0000000000000000000000000000000000000000;;		if err := json.Unmarshal(sd.Raw(), &obj); err != nil {
0000000000000000000000000000000000000000;;			errs.AddErrors(err)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		errs.Merge(schv.Validate(obj)) // error -
0000000000000000000000000000000000000000;;		if errs.HasErrors() {
0000000000000000000000000000000000000000;;			return // no point in continuing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs.Merge(s.validateReferencesValid()) // error -
0000000000000000000000000000000000000000;;		if errs.HasErrors() {
0000000000000000000000000000000000000000;;			return // no point in continuing
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errs.Merge(s.validateDuplicateOperationIDs())
0000000000000000000000000000000000000000;;		errs.Merge(s.validateDuplicatePropertyNames())         // error -
0000000000000000000000000000000000000000;;		errs.Merge(s.validateParameters())                     // error -
0000000000000000000000000000000000000000;;		errs.Merge(s.validateItems())                          // error -
0000000000000000000000000000000000000000;;		errs.Merge(s.validateRequiredDefinitions())            // error -
0000000000000000000000000000000000000000;;		errs.Merge(s.validateDefaultValueValidAgainstSchema()) // error -
0000000000000000000000000000000000000000;;		errs.Merge(s.validateExamplesValidAgainstSchema())     // error -
0000000000000000000000000000000000000000;;		errs.Merge(s.validateNonEmptyPathParamNames())
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		warnings.Merge(s.validateUniqueSecurityScopes()) // warning
0000000000000000000000000000000000000000;;		warnings.Merge(s.validateReferenced())           // warning
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateNonEmptyPathParamNames() *Result {
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		for k := range s.spec.Spec().Paths.Paths {
0000000000000000000000000000000000000000;;			if strings.Contains(k, "{}") {
0000000000000000000000000000000000000000;;				res.AddErrors(errors.New(422, "%q contains an empty path parameter", k))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateDuplicateOperationIDs() *Result {
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		known := make(map[string]int)
0000000000000000000000000000000000000000;;		for _, v := range s.analyzer.OperationIDs() {
0000000000000000000000000000000000000000;;			if v != "" {
0000000000000000000000000000000000000000;;				known[v]++
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for k, v := range known {
0000000000000000000000000000000000000000;;			if v > 1 {
0000000000000000000000000000000000000000;;				res.AddErrors(errors.New(422, "%q is defined %d times", k, v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type dupProp struct {
0000000000000000000000000000000000000000;;		Name       string
0000000000000000000000000000000000000000;;		Definition string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateDuplicatePropertyNames() *Result {
0000000000000000000000000000000000000000;;		// definition can't declare a property that's already defined by one of its ancestors
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		for k, sch := range s.spec.Spec().Definitions {
0000000000000000000000000000000000000000;;			if len(sch.AllOf) == 0 {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			knownanc := map[string]struct{}{
0000000000000000000000000000000000000000;;				"#/definitions/" + k: struct{}{},
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			ancs := s.validateCircularAncestry(k, sch, knownanc)
0000000000000000000000000000000000000000;;			if len(ancs) > 0 {
0000000000000000000000000000000000000000;;				res.AddErrors(errors.New(422, "definition %q has circular ancestry: %v", k, ancs))
0000000000000000000000000000000000000000;;				return res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			knowns := make(map[string]struct{})
0000000000000000000000000000000000000000;;			dups := s.validateSchemaPropertyNames(k, sch, knowns)
0000000000000000000000000000000000000000;;			if len(dups) > 0 {
0000000000000000000000000000000000000000;;				var pns []string
0000000000000000000000000000000000000000;;				for _, v := range dups {
0000000000000000000000000000000000000000;;					pns = append(pns, v.Definition+"."+v.Name)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				res.AddErrors(errors.New(422, "definition %q contains duplicate properties: %v", k, pns))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateSchemaPropertyNames(nm string, sch spec.Schema, knowns map[string]struct{}) []dupProp {
0000000000000000000000000000000000000000;;		var dups []dupProp
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schn := nm
0000000000000000000000000000000000000000;;		schc := &sch
0000000000000000000000000000000000000000;;		for schc.Ref.String() != "" {
0000000000000000000000000000000000000000;;			// gather property names
0000000000000000000000000000000000000000;;			reso, err := spec.ResolveRef(s.spec.Spec(), &schc.Ref)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			schc = reso
0000000000000000000000000000000000000000;;			schn = sch.Ref.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(schc.AllOf) > 0 {
0000000000000000000000000000000000000000;;			for _, chld := range schc.AllOf {
0000000000000000000000000000000000000000;;				dups = append(dups, s.validateSchemaPropertyNames(schn, chld, knowns)...)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return dups
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k := range schc.Properties {
0000000000000000000000000000000000000000;;			_, ok := knowns[k]
0000000000000000000000000000000000000000;;			if ok {
0000000000000000000000000000000000000000;;				dups = append(dups, dupProp{Name: k, Definition: schn})
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				knowns[k] = struct{}{}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return dups
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateCircularAncestry(nm string, sch spec.Schema, knowns map[string]struct{}) []string {
0000000000000000000000000000000000000000;;		if sch.Ref.String() == "" && len(sch.AllOf) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var ancs []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schn := nm
0000000000000000000000000000000000000000;;		schc := &sch
0000000000000000000000000000000000000000;;		for schc.Ref.String() != "" {
0000000000000000000000000000000000000000;;			reso, err := spec.ResolveRef(s.spec.Spec(), &schc.Ref)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			schc = reso
0000000000000000000000000000000000000000;;			schn = sch.Ref.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if schn != nm && schn != "" {
0000000000000000000000000000000000000000;;			if _, ok := knowns[schn]; ok {
0000000000000000000000000000000000000000;;				ancs = append(ancs, schn)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			knowns[schn] = struct{}{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if len(ancs) > 0 {
0000000000000000000000000000000000000000;;				return ancs
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(schc.AllOf) > 0 {
0000000000000000000000000000000000000000;;			for _, chld := range schc.AllOf {
0000000000000000000000000000000000000000;;				if chld.Ref.String() != "" || len(chld.AllOf) > 0 {
0000000000000000000000000000000000000000;;					ancs = append(ancs, s.validateCircularAncestry(schn, chld, knowns)...)
0000000000000000000000000000000000000000;;					if len(ancs) > 0 {
0000000000000000000000000000000000000000;;						return ancs
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return ancs
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateItems() *Result {
0000000000000000000000000000000000000000;;		// validate parameter, items, schema and response objects for presence of item if type is array
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: implement support for lookups of refs
0000000000000000000000000000000000000000;;		for method, pi := range s.analyzer.Operations() {
0000000000000000000000000000000000000000;;			for path, op := range pi {
0000000000000000000000000000000000000000;;				for _, param := range s.analyzer.ParamsFor(method, path) {
0000000000000000000000000000000000000000;;					if param.TypeName() == "array" && param.ItemsTypeName() == "" {
0000000000000000000000000000000000000000;;						res.AddErrors(errors.New(422, "param %q for %q is a collection without an element type", param.Name, op.ID))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if param.In != "body" {
0000000000000000000000000000000000000000;;						if param.Items != nil {
0000000000000000000000000000000000000000;;							items := param.Items
0000000000000000000000000000000000000000;;							for items.TypeName() == "array" {
0000000000000000000000000000000000000000;;								if items.ItemsTypeName() == "" {
0000000000000000000000000000000000000000;;									res.AddErrors(errors.New(422, "param %q for %q is a collection without an element type", param.Name, op.ID))
0000000000000000000000000000000000000000;;									break
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;								items = items.Items
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						if err := s.validateSchemaItems(*param.Schema, fmt.Sprintf("body param %q", param.Name), op.ID); err != nil {
0000000000000000000000000000000000000000;;							res.AddErrors(err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				var responses []spec.Response
0000000000000000000000000000000000000000;;				if op.Responses != nil {
0000000000000000000000000000000000000000;;					if op.Responses.Default != nil {
0000000000000000000000000000000000000000;;						responses = append(responses, *op.Responses.Default)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					for _, v := range op.Responses.StatusCodeResponses {
0000000000000000000000000000000000000000;;						responses = append(responses, v)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for _, resp := range responses {
0000000000000000000000000000000000000000;;					for hn, hv := range resp.Headers {
0000000000000000000000000000000000000000;;						if hv.TypeName() == "array" && hv.ItemsTypeName() == "" {
0000000000000000000000000000000000000000;;							res.AddErrors(errors.New(422, "header %q for %q is a collection without an element type", hn, op.ID))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if resp.Schema != nil {
0000000000000000000000000000000000000000;;						if err := s.validateSchemaItems(*resp.Schema, "response body", op.ID); err != nil {
0000000000000000000000000000000000000000;;							res.AddErrors(err)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateSchemaItems(schema spec.Schema, prefix, opID string) error {
0000000000000000000000000000000000000000;;		if !schema.Type.Contains("array") {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if schema.Items == nil || schema.Items.Len() == 0 {
0000000000000000000000000000000000000000;;			return errors.New(422, "%s for %q is a collection without an element type", prefix, opID)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schemas := schema.Items.Schemas
0000000000000000000000000000000000000000;;		if schema.Items.Schema != nil {
0000000000000000000000000000000000000000;;			schemas = []spec.Schema{*schema.Items.Schema}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, sch := range schemas {
0000000000000000000000000000000000000000;;			if err := s.validateSchemaItems(sch, prefix, opID); err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateUniqueSecurityScopes() *Result {
0000000000000000000000000000000000000000;;		// Each authorization/security reference should contain only unique scopes.
0000000000000000000000000000000000000000;;		// (Example: For an oauth2 authorization/security requirement, when listing the required scopes,
0000000000000000000000000000000000000000;;		// each scope should only be listed once.)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validatePathParamPresence(path string, fromPath, fromOperation []string) *Result {
0000000000000000000000000000000000000000;;		// Each defined operation path parameters must correspond to a named element in the API's path pattern.
0000000000000000000000000000000000000000;;		// (For example, you cannot have a path parameter named id for the following path /pets/{petId} but you must have a path parameter named petId.)
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		for _, l := range fromPath {
0000000000000000000000000000000000000000;;			var matched bool
0000000000000000000000000000000000000000;;			for _, r := range fromOperation {
0000000000000000000000000000000000000000;;				if l == "{"+r+"}" {
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !matched {
0000000000000000000000000000000000000000;;				res.Errors = append(res.Errors, errors.New(422, "path param %q has no parameter definition", l))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, p := range fromOperation {
0000000000000000000000000000000000000000;;			var matched bool
0000000000000000000000000000000000000000;;			for _, r := range fromPath {
0000000000000000000000000000000000000000;;				if "{"+p+"}" == r {
0000000000000000000000000000000000000000;;					matched = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if !matched {
0000000000000000000000000000000000000000;;				res.AddErrors(errors.New(422, "path param %q is not present in path %q", p, path))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateReferenced() *Result {
0000000000000000000000000000000000000000;;		var res Result
0000000000000000000000000000000000000000;;		res.Merge(s.validateReferencedParameters())
0000000000000000000000000000000000000000;;		res.Merge(s.validateReferencedResponses())
0000000000000000000000000000000000000000;;		res.Merge(s.validateReferencedDefinitions())
0000000000000000000000000000000000000000;;		return &res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateReferencedParameters() *Result {
0000000000000000000000000000000000000000;;		// Each referenceable definition must have references.
0000000000000000000000000000000000000000;;		params := s.spec.Spec().Parameters
0000000000000000000000000000000000000000;;		if len(params) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for k := range params {
0000000000000000000000000000000000000000;;			expected["#/parameters/"+jsonpointer.Escape(k)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, k := range s.analyzer.AllParameterReferences() {
0000000000000000000000000000000000000000;;			if _, ok := expected[k]; ok {
0000000000000000000000000000000000000000;;				delete(expected, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(expected) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var result Result
0000000000000000000000000000000000000000;;		for k := range expected {
0000000000000000000000000000000000000000;;			result.AddErrors(errors.New(422, "parameter %q is not used anywhere", k))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateReferencedResponses() *Result {
0000000000000000000000000000000000000000;;		// Each referenceable definition must have references.
0000000000000000000000000000000000000000;;		responses := s.spec.Spec().Responses
0000000000000000000000000000000000000000;;		if len(responses) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for k := range responses {
0000000000000000000000000000000000000000;;			expected["#/responses/"+jsonpointer.Escape(k)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, k := range s.analyzer.AllResponseReferences() {
0000000000000000000000000000000000000000;;			if _, ok := expected[k]; ok {
0000000000000000000000000000000000000000;;				delete(expected, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(expected) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var result Result
0000000000000000000000000000000000000000;;		for k := range expected {
0000000000000000000000000000000000000000;;			result.AddErrors(errors.New(422, "response %q is not used anywhere", k))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateReferencedDefinitions() *Result {
0000000000000000000000000000000000000000;;		// Each referenceable definition must have references.
0000000000000000000000000000000000000000;;		defs := s.spec.Spec().Definitions
0000000000000000000000000000000000000000;;		if len(defs) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expected := make(map[string]struct{})
0000000000000000000000000000000000000000;;		for k := range defs {
0000000000000000000000000000000000000000;;			expected["#/definitions/"+jsonpointer.Escape(k)] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		for _, k := range s.analyzer.AllDefinitionReferences() {
0000000000000000000000000000000000000000;;			if _, ok := expected[k]; ok {
0000000000000000000000000000000000000000;;				delete(expected, k)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(expected) == 0 {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var result Result
0000000000000000000000000000000000000000;;		for k := range expected {
0000000000000000000000000000000000000000;;			result.AddErrors(errors.New(422, "definition %q is not used anywhere", k))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateRequiredDefinitions() *Result {
0000000000000000000000000000000000000000;;		// Each definition property listed in the required array must be defined in the properties of the model
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		for d, v := range s.spec.Spec().Definitions {
0000000000000000000000000000000000000000;;		REQUIRED:
0000000000000000000000000000000000000000;;			for _, pn := range v.Required {
0000000000000000000000000000000000000000;;				if _, ok := v.Properties[pn]; ok {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for pp := range v.PatternProperties {
0000000000000000000000000000000000000000;;					re := regexp.MustCompile(pp)
0000000000000000000000000000000000000000;;					if re.MatchString(pn) {
0000000000000000000000000000000000000000;;						continue REQUIRED
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if v.AdditionalProperties != nil {
0000000000000000000000000000000000000000;;					if v.AdditionalProperties.Allows {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if v.AdditionalProperties.Schema != nil {
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				res.AddErrors(errors.New(422, "%q is present in required but not defined as property in definition %q", pn, d))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateParameters() *Result {
0000000000000000000000000000000000000000;;		// each parameter should have a unique `name` and `type` combination
0000000000000000000000000000000000000000;;		// each operation should have only 1 parameter of type body
0000000000000000000000000000000000000000;;		// each api path should be non-verbatim (account for path param names) unique per method
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		for method, pi := range s.analyzer.Operations() {
0000000000000000000000000000000000000000;;			knownPaths := make(map[string]string)
0000000000000000000000000000000000000000;;			for path, op := range pi {
0000000000000000000000000000000000000000;;				segments, params := parsePath(path)
0000000000000000000000000000000000000000;;				knowns := make([]string, 0, len(segments))
0000000000000000000000000000000000000000;;				for _, s := range segments {
0000000000000000000000000000000000000000;;					knowns = append(knowns, s)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				var fromPath []string
0000000000000000000000000000000000000000;;				for _, i := range params {
0000000000000000000000000000000000000000;;					fromPath = append(fromPath, knowns[i])
0000000000000000000000000000000000000000;;					knowns[i] = "!"
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				knownPath := strings.Join(knowns, "/")
0000000000000000000000000000000000000000;;				if orig, ok := knownPaths[knownPath]; ok {
0000000000000000000000000000000000000000;;					res.AddErrors(errors.New(422, "path %s overlaps with %s", path, orig))
0000000000000000000000000000000000000000;;				} else {
0000000000000000000000000000000000000000;;					knownPaths[knownPath] = path
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				ptypes := make(map[string]map[string]struct{})
0000000000000000000000000000000000000000;;				var firstBodyParam string
0000000000000000000000000000000000000000;;				sw := s.spec.Spec()
0000000000000000000000000000000000000000;;				var paramNames []string
0000000000000000000000000000000000000000;;			PARAMETERS:
0000000000000000000000000000000000000000;;				for _, ppr := range op.Parameters {
0000000000000000000000000000000000000000;;					pr := ppr
0000000000000000000000000000000000000000;;					for pr.Ref.String() != "" {
0000000000000000000000000000000000000000;;						obj, _, err := pr.Ref.GetPointer().Get(sw)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							log.Println(err)
0000000000000000000000000000000000000000;;							res.AddErrors(err)
0000000000000000000000000000000000000000;;							break PARAMETERS
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						pr = obj.(spec.Parameter)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pnames, ok := ptypes[pr.In]
0000000000000000000000000000000000000000;;					if !ok {
0000000000000000000000000000000000000000;;						pnames = make(map[string]struct{})
0000000000000000000000000000000000000000;;						ptypes[pr.In] = pnames
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					_, ok = pnames[pr.Name]
0000000000000000000000000000000000000000;;					if ok {
0000000000000000000000000000000000000000;;						res.AddErrors(errors.New(422, "duplicate parameter name %q for %q in operation %q", pr.Name, pr.In, op.ID))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					pnames[pr.Name] = struct{}{}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			PARAMETERS2:
0000000000000000000000000000000000000000;;				for _, ppr := range s.analyzer.ParamsFor(method, path) {
0000000000000000000000000000000000000000;;					pr := ppr
0000000000000000000000000000000000000000;;					for pr.Ref.String() != "" {
0000000000000000000000000000000000000000;;						obj, _, err := pr.Ref.GetPointer().Get(sw)
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							res.AddErrors(err)
0000000000000000000000000000000000000000;;							break PARAMETERS2
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						pr = obj.(spec.Parameter)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if pr.In == "body" {
0000000000000000000000000000000000000000;;						if firstBodyParam != "" {
0000000000000000000000000000000000000000;;							res.AddErrors(errors.New(422, "operation %q has more than 1 body param (accepted: %q, dropped: %q)", op.ID, firstBodyParam, pr.Name))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						firstBodyParam = pr.Name
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if pr.In == "path" {
0000000000000000000000000000000000000000;;						paramNames = append(paramNames, pr.Name)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				res.Merge(s.validatePathParamPresence(path, fromPath, paramNames))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func parsePath(path string) (segments []string, params []int) {
0000000000000000000000000000000000000000;;		for i, p := range strings.Split(path, "/") {
0000000000000000000000000000000000000000;;			segments = append(segments, p)
0000000000000000000000000000000000000000;;			if len(p) > 0 && p[0] == '{' && p[len(p)-1] == '}' {
0000000000000000000000000000000000000000;;				params = append(params, i)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateReferencesValid() *Result {
0000000000000000000000000000000000000000;;		// each reference must point to a valid object
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		for _, r := range s.analyzer.AllRefs() {
0000000000000000000000000000000000000000;;			if !r.IsValidURI() {
0000000000000000000000000000000000000000;;				res.AddErrors(errors.New(404, "invalid ref %q", r.String()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !res.HasErrors() {
0000000000000000000000000000000000000000;;			exp, err := s.spec.Expanded()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				res.AddErrors(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			s.expanded = exp
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateResponseExample(path string, r *spec.Response) *Result {
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		if r.Ref.String() != "" {
0000000000000000000000000000000000000000;;			nr, _, err := r.Ref.GetPointer().Get(s.spec.Spec())
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				res.AddErrors(err)
0000000000000000000000000000000000000000;;				return res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			rr := nr.(spec.Response)
0000000000000000000000000000000000000000;;			return s.validateResponseExample(path, &rr)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Examples != nil {
0000000000000000000000000000000000000000;;			if r.Schema != nil {
0000000000000000000000000000000000000000;;				if example, ok := r.Examples["application/json"]; ok {
0000000000000000000000000000000000000000;;					res.Merge(NewSchemaValidator(r.Schema, s.spec.Spec(), path, s.KnownFormats).Validate(example))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// TODO: validate other media types too
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateExamplesValidAgainstSchema() *Result {
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, pathItem := range s.analyzer.Operations() {
0000000000000000000000000000000000000000;;			for path, op := range pathItem {
0000000000000000000000000000000000000000;;				if op.Responses.Default != nil {
0000000000000000000000000000000000000000;;					dr := op.Responses.Default
0000000000000000000000000000000000000000;;					res.Merge(s.validateResponseExample(path, dr))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, r := range op.Responses.StatusCodeResponses {
0000000000000000000000000000000000000000;;					res.Merge(s.validateResponseExample(path, &r))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateDefaultValueValidAgainstSchema() *Result {
0000000000000000000000000000000000000000;;		// every default value that is specified must validate against the schema for that property
0000000000000000000000000000000000000000;;		// headers, items, parameters, schema
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for method, pathItem := range s.analyzer.Operations() {
0000000000000000000000000000000000000000;;			for path, op := range pathItem {
0000000000000000000000000000000000000000;;				// parameters
0000000000000000000000000000000000000000;;				var hasForm, hasBody bool
0000000000000000000000000000000000000000;;			PARAMETERS:
0000000000000000000000000000000000000000;;				for _, pr := range s.analyzer.ParamsFor(method, path) {
0000000000000000000000000000000000000000;;					// expand ref is necessary
0000000000000000000000000000000000000000;;					param := pr
0000000000000000000000000000000000000000;;					for param.Ref.String() != "" {
0000000000000000000000000000000000000000;;						obj, _, err := param.Ref.GetPointer().Get(s.spec.Spec())
0000000000000000000000000000000000000000;;						if err != nil {
0000000000000000000000000000000000000000;;							res.AddErrors(err)
0000000000000000000000000000000000000000;;							break PARAMETERS
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						param = obj.(spec.Parameter)
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if param.In == "formData" {
0000000000000000000000000000000000000000;;						if hasBody && !hasForm {
0000000000000000000000000000000000000000;;							res.AddErrors(errors.New(422, "operation %q has both formData and body parameters", op.ID))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						hasForm = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					if param.In == "body" {
0000000000000000000000000000000000000000;;						if hasForm && !hasBody {
0000000000000000000000000000000000000000;;							res.AddErrors(errors.New(422, "operation %q has both body and formData parameters", op.ID))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						hasBody = true
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;					// check simple paramters first
0000000000000000000000000000000000000000;;					if param.Default != nil && param.Schema == nil {
0000000000000000000000000000000000000000;;						//fmt.Println(param.Name, "in", param.In, "has a default without a schema")
0000000000000000000000000000000000000000;;						// check param valid
0000000000000000000000000000000000000000;;						res.Merge(NewParamValidator(&param, s.KnownFormats).Validate(param.Default))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if param.Items != nil {
0000000000000000000000000000000000000000;;						res.Merge(s.validateDefaultValueItemsAgainstSchema(param.Name, param.In, &param, param.Items))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if param.Schema != nil {
0000000000000000000000000000000000000000;;						res.Merge(s.validateDefaultValueSchemaAgainstSchema(param.Name, param.In, param.Schema))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if op.Responses.Default != nil {
0000000000000000000000000000000000000000;;					dr := op.Responses.Default
0000000000000000000000000000000000000000;;					for nm, h := range dr.Headers {
0000000000000000000000000000000000000000;;						if h.Default != nil {
0000000000000000000000000000000000000000;;							res.Merge(NewHeaderValidator(nm, &h, s.KnownFormats).Validate(h.Default))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if h.Items != nil {
0000000000000000000000000000000000000000;;							res.Merge(s.validateDefaultValueItemsAgainstSchema(nm, "header", &h, h.Items))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for _, r := range op.Responses.StatusCodeResponses {
0000000000000000000000000000000000000000;;					for nm, h := range r.Headers {
0000000000000000000000000000000000000000;;						if h.Default != nil {
0000000000000000000000000000000000000000;;							res.Merge(NewHeaderValidator(nm, &h, s.KnownFormats).Validate(h.Default))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;						if h.Items != nil {
0000000000000000000000000000000000000000;;							res.Merge(s.validateDefaultValueItemsAgainstSchema(nm, "header", &h, h.Items))
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for nm, sch := range s.spec.Spec().Definitions {
0000000000000000000000000000000000000000;;			res.Merge(s.validateDefaultValueSchemaAgainstSchema(fmt.Sprintf("definitions.%s", nm), "body", &sch))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateDefaultValueSchemaAgainstSchema(path, in string, schema *spec.Schema) *Result {
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		if schema != nil {
0000000000000000000000000000000000000000;;			if schema.Default != nil {
0000000000000000000000000000000000000000;;				res.Merge(NewSchemaValidator(schema, s.spec.Spec(), path, s.KnownFormats).Validate(schema.Default))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if schema.Items != nil {
0000000000000000000000000000000000000000;;				if schema.Items.Schema != nil {
0000000000000000000000000000000000000000;;					res.Merge(s.validateDefaultValueSchemaAgainstSchema(path+".items", in, schema.Items.Schema))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				for i, sch := range schema.Items.Schemas {
0000000000000000000000000000000000000000;;					res.Merge(s.validateDefaultValueSchemaAgainstSchema(fmt.Sprintf("%s.items[%d]", path, i), in, &sch))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if schema.AdditionalItems != nil && schema.AdditionalItems.Schema != nil {
0000000000000000000000000000000000000000;;				res.Merge(s.validateDefaultValueSchemaAgainstSchema(fmt.Sprintf("%s.additionalItems", path), in, schema.AdditionalItems.Schema))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for propName, prop := range schema.Properties {
0000000000000000000000000000000000000000;;				res.Merge(s.validateDefaultValueSchemaAgainstSchema(path+"."+propName, in, &prop))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for propName, prop := range schema.PatternProperties {
0000000000000000000000000000000000000000;;				res.Merge(s.validateDefaultValueSchemaAgainstSchema(path+"."+propName, in, &prop))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if schema.AdditionalProperties != nil && schema.AdditionalProperties.Schema != nil {
0000000000000000000000000000000000000000;;				res.Merge(s.validateDefaultValueSchemaAgainstSchema(fmt.Sprintf("%s.additionalProperties", path), in, schema.AdditionalProperties.Schema))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i, aoSch := range schema.AllOf {
0000000000000000000000000000000000000000;;				res.Merge(s.validateDefaultValueSchemaAgainstSchema(fmt.Sprintf("%s.allOf[%d]", path, i), in, &aoSch))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SpecValidator) validateDefaultValueItemsAgainstSchema(path, in string, root interface{}, items *spec.Items) *Result {
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		if items != nil {
0000000000000000000000000000000000000000;;			if items.Default != nil {
0000000000000000000000000000000000000000;;				res.Merge(newItemsValidator(path, in, items, root, s.KnownFormats).Validate(0, items.Default))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if items.Items != nil {
0000000000000000000000000000000000000000;;				res.Merge(s.validateDefaultValueItemsAgainstSchema(path+"[0]", in, root, items.Items))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
