0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type objectValidator struct {
0000000000000000000000000000000000000000;;		Path                 string
0000000000000000000000000000000000000000;;		In                   string
0000000000000000000000000000000000000000;;		MaxProperties        *int64
0000000000000000000000000000000000000000;;		MinProperties        *int64
0000000000000000000000000000000000000000;;		Required             []string
0000000000000000000000000000000000000000;;		Properties           map[string]spec.Schema
0000000000000000000000000000000000000000;;		AdditionalProperties *spec.SchemaOrBool
0000000000000000000000000000000000000000;;		PatternProperties    map[string]spec.Schema
0000000000000000000000000000000000000000;;		Root                 interface{}
0000000000000000000000000000000000000000;;		KnownFormats         strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *objectValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		o.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *objectValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		// TODO: this should also work for structs
0000000000000000000000000000000000000000;;		// there is a problem in the type validator where it will be unhappy about null values
0000000000000000000000000000000000000000;;		// so that requires more testing
0000000000000000000000000000000000000000;;		r := reflect.TypeOf(source) == specSchemaType && (kind == reflect.Map || kind == reflect.Struct)
0000000000000000000000000000000000000000;;		//fmt.Printf("object validator for %q applies %t for %T (kind: %v)\n", o.Path, r, source, kind)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *objectValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		val := data.(map[string]interface{})
0000000000000000000000000000000000000000;;		numKeys := int64(len(val))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.MinProperties != nil && numKeys < *o.MinProperties {
0000000000000000000000000000000000000000;;			return sErr(errors.TooFewProperties(o.Path, o.In, *o.MinProperties))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if o.MaxProperties != nil && numKeys > *o.MaxProperties {
0000000000000000000000000000000000000000;;			return sErr(errors.TooManyProperties(o.Path, o.In, *o.MaxProperties))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res := new(Result)
0000000000000000000000000000000000000000;;		if len(o.Required) > 0 {
0000000000000000000000000000000000000000;;			for _, k := range o.Required {
0000000000000000000000000000000000000000;;				if _, ok := val[k]; !ok {
0000000000000000000000000000000000000000;;					res.AddErrors(errors.Required(o.Path+"."+k, o.In))
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if o.AdditionalProperties != nil && !o.AdditionalProperties.Allows {
0000000000000000000000000000000000000000;;			for k := range val {
0000000000000000000000000000000000000000;;				_, regularProperty := o.Properties[k]
0000000000000000000000000000000000000000;;				matched := false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				for pk := range o.PatternProperties {
0000000000000000000000000000000000000000;;					if matches, _ := regexp.MatchString(pk, k); matches {
0000000000000000000000000000000000000000;;						matched = true
0000000000000000000000000000000000000000;;						break
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !regularProperty && k != "$schema" && k != "id" && !matched {
0000000000000000000000000000000000000000;;					res.AddErrors(errors.PropertyNotAllowed(o.Path, o.In, k))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			for key, value := range val {
0000000000000000000000000000000000000000;;				_, regularProperty := o.Properties[key]
0000000000000000000000000000000000000000;;				matched, succeededOnce, _ := o.validatePatternProperty(key, value, res)
0000000000000000000000000000000000000000;;				if !(regularProperty || matched || succeededOnce) {
0000000000000000000000000000000000000000;;					if o.AdditionalProperties != nil && o.AdditionalProperties.Schema != nil {
0000000000000000000000000000000000000000;;						res.Merge(NewSchemaValidator(o.AdditionalProperties.Schema, o.Root, o.Path+"."+key, o.KnownFormats).Validate(value))
0000000000000000000000000000000000000000;;					} else if regularProperty && !(matched || succeededOnce) {
0000000000000000000000000000000000000000;;						res.AddErrors(errors.FailedAllPatternProperties(o.Path, o.In, key))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for pName, pSchema := range o.Properties {
0000000000000000000000000000000000000000;;			rName := pName
0000000000000000000000000000000000000000;;			if o.Path != "" {
0000000000000000000000000000000000000000;;				rName = o.Path + "." + pName
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if v, ok := val[pName]; ok {
0000000000000000000000000000000000000000;;				res.Merge(NewSchemaValidator(&pSchema, o.Root, rName, o.KnownFormats).Validate(v))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for key, value := range val {
0000000000000000000000000000000000000000;;			_, regularProperty := o.Properties[key]
0000000000000000000000000000000000000000;;			matched, succeededOnce, patterns := o.validatePatternProperty(key, value, res)
0000000000000000000000000000000000000000;;			if !regularProperty && (matched || succeededOnce) {
0000000000000000000000000000000000000000;;				for _, pName := range patterns {
0000000000000000000000000000000000000000;;					if v, ok := o.PatternProperties[pName]; ok {
0000000000000000000000000000000000000000;;						res.Merge(NewSchemaValidator(&v, o.Root, o.Path+"."+key, o.KnownFormats).Validate(value))
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (o *objectValidator) validatePatternProperty(key string, value interface{}, result *Result) (bool, bool, []string) {
0000000000000000000000000000000000000000;;		matched := false
0000000000000000000000000000000000000000;;		succeededOnce := false
0000000000000000000000000000000000000000;;		var patterns []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for k, schema := range o.PatternProperties {
0000000000000000000000000000000000000000;;			if match, _ := regexp.MatchString(k, key); match {
0000000000000000000000000000000000000000;;				patterns = append(patterns, k)
0000000000000000000000000000000000000000;;				matched = true
0000000000000000000000000000000000000000;;				validator := NewSchemaValidator(&schema, o.Root, o.Path+"."+key, o.KnownFormats)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				res := validator.Validate(value)
0000000000000000000000000000000000000000;;				result.Merge(res)
0000000000000000000000000000000000000000;;				if res.IsValid() {
0000000000000000000000000000000000000000;;					succeededOnce = true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if succeededOnce {
0000000000000000000000000000000000000000;;			result.Inc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return matched, succeededOnce, patterns
0000000000000000000000000000000000000000;;	}
