0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"regexp"
0000000000000000000000000000000000000000;;		"unicode/utf8"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Enum validates if the data is a member of the enum
0000000000000000000000000000000000000000;;	func Enum(path, in string, data interface{}, enum interface{}) *errors.Validation {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(enum)
0000000000000000000000000000000000000000;;		if val.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var values []interface{}
0000000000000000000000000000000000000000;;		for i := 0; i < val.Len(); i++ {
0000000000000000000000000000000000000000;;			ele := val.Index(i)
0000000000000000000000000000000000000000;;			enumValue := ele.Interface()
0000000000000000000000000000000000000000;;			if data != nil {
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(data, enumValue) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				actualType := reflect.TypeOf(enumValue)
0000000000000000000000000000000000000000;;				if actualType == nil {
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				expectedValue := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;				if expectedValue.IsValid() && expectedValue.Type().ConvertibleTo(actualType) {
0000000000000000000000000000000000000000;;					// Attempt comparison after type conversion
0000000000000000000000000000000000000000;;					if reflect.DeepEqual(expectedValue.Convert(actualType).Interface(), enumValue) {
0000000000000000000000000000000000000000;;						return nil
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			values = append(values, enumValue)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.EnumFail(path, in, data, values)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinItems validates that there are at least n items in a slice
0000000000000000000000000000000000000000;;	func MinItems(path, in string, size, min int64) *errors.Validation {
0000000000000000000000000000000000000000;;		if size < min {
0000000000000000000000000000000000000000;;			return errors.TooFewItems(path, in, min)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxItems validates that there are at most n items in a slice
0000000000000000000000000000000000000000;;	func MaxItems(path, in string, size, max int64) *errors.Validation {
0000000000000000000000000000000000000000;;		if size > max {
0000000000000000000000000000000000000000;;			return errors.TooManyItems(path, in, max)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UniqueItems validates that the provided slice has unique elements
0000000000000000000000000000000000000000;;	func UniqueItems(path, in string, data interface{}) *errors.Validation {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		if val.Kind() != reflect.Slice {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var unique []interface{}
0000000000000000000000000000000000000000;;		for i := 0; i < val.Len(); i++ {
0000000000000000000000000000000000000000;;			v := val.Index(i).Interface()
0000000000000000000000000000000000000000;;			for _, u := range unique {
0000000000000000000000000000000000000000;;				if reflect.DeepEqual(v, u) {
0000000000000000000000000000000000000000;;					return errors.DuplicateItems(path, in)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			unique = append(unique, v)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinLength validates a string for minimum length
0000000000000000000000000000000000000000;;	func MinLength(path, in, data string, minLength int64) *errors.Validation {
0000000000000000000000000000000000000000;;		strLen := int64(utf8.RuneCount([]byte(data)))
0000000000000000000000000000000000000000;;		if strLen < minLength {
0000000000000000000000000000000000000000;;			return errors.TooShort(path, in, minLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaxLength validates a string for maximum length
0000000000000000000000000000000000000000;;	func MaxLength(path, in, data string, maxLength int64) *errors.Validation {
0000000000000000000000000000000000000000;;		strLen := int64(utf8.RuneCount([]byte(data)))
0000000000000000000000000000000000000000;;		if strLen > maxLength {
0000000000000000000000000000000000000000;;			return errors.TooLong(path, in, maxLength)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Required validates an interface for requiredness
0000000000000000000000000000000000000000;;	func Required(path, in string, data interface{}) *errors.Validation {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		if val.IsValid() {
0000000000000000000000000000000000000000;;			if reflect.DeepEqual(reflect.Zero(val.Type()).Interface(), val.Interface()) {
0000000000000000000000000000000000000000;;				return errors.Required(path, in)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return errors.Required(path, in)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequiredString validates a string for requiredness
0000000000000000000000000000000000000000;;	func RequiredString(path, in, data string) *errors.Validation {
0000000000000000000000000000000000000000;;		if data == "" {
0000000000000000000000000000000000000000;;			return errors.Required(path, in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RequiredNumber validates a number for requiredness
0000000000000000000000000000000000000000;;	func RequiredNumber(path, in string, data float64) *errors.Validation {
0000000000000000000000000000000000000000;;		if data == 0 {
0000000000000000000000000000000000000000;;			return errors.Required(path, in)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pattern validates a string against a regular expression
0000000000000000000000000000000000000000;;	func Pattern(path, in, data, pattern string) *errors.Validation {
0000000000000000000000000000000000000000;;		re := regexp.MustCompile(pattern)
0000000000000000000000000000000000000000;;		if !re.MatchString(data) {
0000000000000000000000000000000000000000;;			return errors.FailedPattern(path, in, pattern)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaximumInt validates if a number is smaller than a given maximum
0000000000000000000000000000000000000000;;	func MaximumInt(path, in string, data, max int64, exclusive bool) *errors.Validation {
0000000000000000000000000000000000000000;;		if (!exclusive && data > max) || (exclusive && data >= max) {
0000000000000000000000000000000000000000;;			return errors.ExceedsMaximumInt(path, in, max, exclusive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MaximumUint validates if a number is smaller than a given maximum
0000000000000000000000000000000000000000;;	func MaximumUint(path, in string, data, max uint64, exclusive bool) *errors.Validation {
0000000000000000000000000000000000000000;;		if (!exclusive && data > max) || (exclusive && data >= max) {
0000000000000000000000000000000000000000;;			return errors.ExceedsMaximumUint(path, in, max, exclusive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Maximum validates if a number is smaller than a given maximum
0000000000000000000000000000000000000000;;	func Maximum(path, in string, data, max float64, exclusive bool) *errors.Validation {
0000000000000000000000000000000000000000;;		if (!exclusive && data > max) || (exclusive && data >= max) {
0000000000000000000000000000000000000000;;			return errors.ExceedsMaximum(path, in, max, exclusive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Minimum validates if a number is smaller than a given minimum
0000000000000000000000000000000000000000;;	func Minimum(path, in string, data, min float64, exclusive bool) *errors.Validation {
0000000000000000000000000000000000000000;;		if (!exclusive && data < min) || (exclusive && data <= min) {
0000000000000000000000000000000000000000;;			return errors.ExceedsMinimum(path, in, min, exclusive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinimumInt validates if a number is smaller than a given minimum
0000000000000000000000000000000000000000;;	func MinimumInt(path, in string, data, min int64, exclusive bool) *errors.Validation {
0000000000000000000000000000000000000000;;		if (!exclusive && data < min) || (exclusive && data <= min) {
0000000000000000000000000000000000000000;;			return errors.ExceedsMinimumInt(path, in, min, exclusive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MinimumUint validates if a number is smaller than a given minimum
0000000000000000000000000000000000000000;;	func MinimumUint(path, in string, data, min uint64, exclusive bool) *errors.Validation {
0000000000000000000000000000000000000000;;		if (!exclusive && data < min) || (exclusive && data <= min) {
0000000000000000000000000000000000000000;;			return errors.ExceedsMinimumUint(path, in, min, exclusive)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MultipleOf validates if the provided number is a multiple of the factor
0000000000000000000000000000000000000000;;	func MultipleOf(path, in string, data, factor float64) *errors.Validation {
0000000000000000000000000000000000000000;;		if !swag.IsFloat64AJSONInteger(data / factor) {
0000000000000000000000000000000000000000;;			return errors.NotMultipleOf(path, in, factor)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FormatOf validates if a string matches a format in the format registry
0000000000000000000000000000000000000000;;	func FormatOf(path, in, format, data string, registry strfmt.Registry) *errors.Validation {
0000000000000000000000000000000000000000;;		if registry == nil {
0000000000000000000000000000000000000000;;			registry = strfmt.Default
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok := registry.ContainsName(format); !ok {
0000000000000000000000000000000000000000;;			return errors.InvalidTypeName(format)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if ok := registry.Validates(format, data); !ok {
0000000000000000000000000000000000000000;;			return errors.InvalidType(path, in, format, data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
