0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var specSchemaType = reflect.TypeOf(&spec.Schema{})
0000000000000000000000000000000000000000;;	var specParameterType = reflect.TypeOf(&spec.Parameter{})
0000000000000000000000000000000000000000;;	var specItemsType = reflect.TypeOf(&spec.Items{})
0000000000000000000000000000000000000000;;	var specHeaderType = reflect.TypeOf(&spec.Header{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SchemaValidator like param validator but for a full json schema
0000000000000000000000000000000000000000;;	type SchemaValidator struct {
0000000000000000000000000000000000000000;;		Path         string
0000000000000000000000000000000000000000;;		in           string
0000000000000000000000000000000000000000;;		Schema       *spec.Schema
0000000000000000000000000000000000000000;;		validators   []valueValidator
0000000000000000000000000000000000000000;;		Root         interface{}
0000000000000000000000000000000000000000;;		KnownFormats strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewSchemaValidator creates a new schema validator
0000000000000000000000000000000000000000;;	func NewSchemaValidator(schema *spec.Schema, rootSchema interface{}, root string, formats strfmt.Registry) *SchemaValidator {
0000000000000000000000000000000000000000;;		if schema == nil {
0000000000000000000000000000000000000000;;			return nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if rootSchema == nil {
0000000000000000000000000000000000000000;;			rootSchema = schema
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if schema.ID != "" || schema.Ref.String() != "" || schema.Ref.IsRoot() {
0000000000000000000000000000000000000000;;			err := spec.ExpandSchema(schema, rootSchema, nil)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				panic(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		s := SchemaValidator{Path: root, in: "body", Schema: schema, Root: rootSchema, KnownFormats: formats}
0000000000000000000000000000000000000000;;		s.validators = []valueValidator{
0000000000000000000000000000000000000000;;			s.typeValidator(),
0000000000000000000000000000000000000000;;			s.schemaPropsValidator(),
0000000000000000000000000000000000000000;;			s.stringValidator(),
0000000000000000000000000000000000000000;;			s.formatValidator(),
0000000000000000000000000000000000000000;;			s.numberValidator(),
0000000000000000000000000000000000000000;;			s.sliceValidator(),
0000000000000000000000000000000000000000;;			s.commonValidator(),
0000000000000000000000000000000000000000;;			s.objectValidator(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &s
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetPath sets the path for this schema valdiator
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		s.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Applies returns true when this schema validator applies
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		_, ok := source.(*spec.Schema)
0000000000000000000000000000000000000000;;		return ok
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate validates the data against the schema
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			v := s.validators[0].Validate(data)
0000000000000000000000000000000000000000;;			v.Merge(s.validators[6].Validate(data))
0000000000000000000000000000000000000000;;			return v
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := new(Result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		tpe := reflect.TypeOf(data)
0000000000000000000000000000000000000000;;		kind := tpe.Kind()
0000000000000000000000000000000000000000;;		for kind == reflect.Ptr {
0000000000000000000000000000000000000000;;			tpe = tpe.Elem()
0000000000000000000000000000000000000000;;			kind = tpe.Kind()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		d := data
0000000000000000000000000000000000000000;;		if kind == reflect.Struct {
0000000000000000000000000000000000000000;;			d = swag.ToDynamicJSON(data)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, v := range s.validators {
0000000000000000000000000000000000000000;;			if !v.Applies(s.Schema, kind) {
0000000000000000000000000000000000000000;;				continue
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			err := v.Validate(d)
0000000000000000000000000000000000000000;;			result.Merge(err)
0000000000000000000000000000000000000000;;			result.Inc()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.Inc()
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) typeValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &typeValidator{Type: s.Schema.Type, Format: s.Schema.Format, In: s.in, Path: s.Path}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) commonValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &basicCommonValidator{
0000000000000000000000000000000000000000;;			Path:    s.Path,
0000000000000000000000000000000000000000;;			In:      s.in,
0000000000000000000000000000000000000000;;			Default: s.Schema.Default,
0000000000000000000000000000000000000000;;			Enum:    s.Schema.Enum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) sliceValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &schemaSliceValidator{
0000000000000000000000000000000000000000;;			Path:            s.Path,
0000000000000000000000000000000000000000;;			In:              s.in,
0000000000000000000000000000000000000000;;			MaxItems:        s.Schema.MaxItems,
0000000000000000000000000000000000000000;;			MinItems:        s.Schema.MinItems,
0000000000000000000000000000000000000000;;			UniqueItems:     s.Schema.UniqueItems,
0000000000000000000000000000000000000000;;			AdditionalItems: s.Schema.AdditionalItems,
0000000000000000000000000000000000000000;;			Items:           s.Schema.Items,
0000000000000000000000000000000000000000;;			Root:            s.Root,
0000000000000000000000000000000000000000;;			KnownFormats:    s.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) numberValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &numberValidator{
0000000000000000000000000000000000000000;;			Path:             s.Path,
0000000000000000000000000000000000000000;;			In:               s.in,
0000000000000000000000000000000000000000;;			Default:          s.Schema.Default,
0000000000000000000000000000000000000000;;			MultipleOf:       s.Schema.MultipleOf,
0000000000000000000000000000000000000000;;			Maximum:          s.Schema.Maximum,
0000000000000000000000000000000000000000;;			ExclusiveMaximum: s.Schema.ExclusiveMaximum,
0000000000000000000000000000000000000000;;			Minimum:          s.Schema.Minimum,
0000000000000000000000000000000000000000;;			ExclusiveMinimum: s.Schema.ExclusiveMinimum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) stringValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &stringValidator{
0000000000000000000000000000000000000000;;			Path:      s.Path,
0000000000000000000000000000000000000000;;			In:        s.in,
0000000000000000000000000000000000000000;;			Default:   s.Schema.Default,
0000000000000000000000000000000000000000;;			MaxLength: s.Schema.MaxLength,
0000000000000000000000000000000000000000;;			MinLength: s.Schema.MinLength,
0000000000000000000000000000000000000000;;			Pattern:   s.Schema.Pattern,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) formatValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &formatValidator{
0000000000000000000000000000000000000000;;			Path: s.Path,
0000000000000000000000000000000000000000;;			In:   s.in,
0000000000000000000000000000000000000000;;			//Default:      s.Schema.Default,
0000000000000000000000000000000000000000;;			Format:       s.Schema.Format,
0000000000000000000000000000000000000000;;			KnownFormats: s.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) schemaPropsValidator() valueValidator {
0000000000000000000000000000000000000000;;		sch := s.Schema
0000000000000000000000000000000000000000;;		return newSchemaPropsValidator(s.Path, s.in, sch.AllOf, sch.OneOf, sch.AnyOf, sch.Not, sch.Dependencies, s.Root, s.KnownFormats)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *SchemaValidator) objectValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &objectValidator{
0000000000000000000000000000000000000000;;			Path:                 s.Path,
0000000000000000000000000000000000000000;;			In:                   s.in,
0000000000000000000000000000000000000000;;			MaxProperties:        s.Schema.MaxProperties,
0000000000000000000000000000000000000000;;			MinProperties:        s.Schema.MinProperties,
0000000000000000000000000000000000000000;;			Required:             s.Schema.Required,
0000000000000000000000000000000000000000;;			Properties:           s.Schema.Properties,
0000000000000000000000000000000000000000;;			AdditionalProperties: s.Schema.AdditionalProperties,
0000000000000000000000000000000000000000;;			PatternProperties:    s.Schema.PatternProperties,
0000000000000000000000000000000000000000;;			Root:                 s.Root,
0000000000000000000000000000000000000000;;			KnownFormats:         s.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
