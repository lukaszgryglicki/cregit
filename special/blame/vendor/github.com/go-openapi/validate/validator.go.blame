0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// An EntityValidator is an interface for things that can validate entities
0000000000000000000000000000000000000000;;	type EntityValidator interface {
0000000000000000000000000000000000000000;;		Validate(interface{}) *Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type valueValidator interface {
0000000000000000000000000000000000000000;;		SetPath(path string)
0000000000000000000000000000000000000000;;		Applies(interface{}, reflect.Kind) bool
0000000000000000000000000000000000000000;;		Validate(interface{}) *Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type itemsValidator struct {
0000000000000000000000000000000000000000;;		items        *spec.Items
0000000000000000000000000000000000000000;;		root         interface{}
0000000000000000000000000000000000000000;;		path         string
0000000000000000000000000000000000000000;;		in           string
0000000000000000000000000000000000000000;;		validators   []valueValidator
0000000000000000000000000000000000000000;;		KnownFormats strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newItemsValidator(path, in string, items *spec.Items, root interface{}, formats strfmt.Registry) *itemsValidator {
0000000000000000000000000000000000000000;;		iv := &itemsValidator{path: path, in: in, items: items, root: root, KnownFormats: formats}
0000000000000000000000000000000000000000;;		iv.validators = []valueValidator{
0000000000000000000000000000000000000000;;			&typeValidator{
0000000000000000000000000000000000000000;;				Type:   spec.StringOrArray([]string{items.Type}),
0000000000000000000000000000000000000000;;				Format: items.Format,
0000000000000000000000000000000000000000;;				In:     in,
0000000000000000000000000000000000000000;;				Path:   path,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			iv.stringValidator(),
0000000000000000000000000000000000000000;;			iv.formatValidator(),
0000000000000000000000000000000000000000;;			iv.numberValidator(),
0000000000000000000000000000000000000000;;			iv.sliceValidator(),
0000000000000000000000000000000000000000;;			iv.commonValidator(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return iv
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *itemsValidator) Validate(index int, data interface{}) *Result {
0000000000000000000000000000000000000000;;		tpe := reflect.TypeOf(data)
0000000000000000000000000000000000000000;;		kind := tpe.Kind()
0000000000000000000000000000000000000000;;		mainResult := new(Result)
0000000000000000000000000000000000000000;;		path := fmt.Sprintf("%s.%d", i.path, index)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, validator := range i.validators {
0000000000000000000000000000000000000000;;			validator.SetPath(path)
0000000000000000000000000000000000000000;;			if validator.Applies(i.root, kind) {
0000000000000000000000000000000000000000;;				result := validator.Validate(data)
0000000000000000000000000000000000000000;;				mainResult.Merge(result)
0000000000000000000000000000000000000000;;				mainResult.Inc()
0000000000000000000000000000000000000000;;				if result != nil && result.HasErrors() {
0000000000000000000000000000000000000000;;					return mainResult
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return mainResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *itemsValidator) commonValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &basicCommonValidator{
0000000000000000000000000000000000000000;;			In:      i.in,
0000000000000000000000000000000000000000;;			Default: i.items.Default,
0000000000000000000000000000000000000000;;			Enum:    i.items.Enum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *itemsValidator) sliceValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &basicSliceValidator{
0000000000000000000000000000000000000000;;			In:           i.in,
0000000000000000000000000000000000000000;;			Default:      i.items.Default,
0000000000000000000000000000000000000000;;			MaxItems:     i.items.MaxItems,
0000000000000000000000000000000000000000;;			MinItems:     i.items.MinItems,
0000000000000000000000000000000000000000;;			UniqueItems:  i.items.UniqueItems,
0000000000000000000000000000000000000000;;			Source:       i.root,
0000000000000000000000000000000000000000;;			Items:        i.items.Items,
0000000000000000000000000000000000000000;;			KnownFormats: i.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *itemsValidator) numberValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &numberValidator{
0000000000000000000000000000000000000000;;			In:               i.in,
0000000000000000000000000000000000000000;;			Default:          i.items.Default,
0000000000000000000000000000000000000000;;			MultipleOf:       i.items.MultipleOf,
0000000000000000000000000000000000000000;;			Maximum:          i.items.Maximum,
0000000000000000000000000000000000000000;;			ExclusiveMaximum: i.items.ExclusiveMaximum,
0000000000000000000000000000000000000000;;			Minimum:          i.items.Minimum,
0000000000000000000000000000000000000000;;			ExclusiveMinimum: i.items.ExclusiveMinimum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *itemsValidator) stringValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &stringValidator{
0000000000000000000000000000000000000000;;			In:              i.in,
0000000000000000000000000000000000000000;;			Default:         i.items.Default,
0000000000000000000000000000000000000000;;			MaxLength:       i.items.MaxLength,
0000000000000000000000000000000000000000;;			MinLength:       i.items.MinLength,
0000000000000000000000000000000000000000;;			Pattern:         i.items.Pattern,
0000000000000000000000000000000000000000;;			AllowEmptyValue: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (i *itemsValidator) formatValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &formatValidator{
0000000000000000000000000000000000000000;;			In: i.in,
0000000000000000000000000000000000000000;;			//Default:      i.items.Default,
0000000000000000000000000000000000000000;;			Format:       i.items.Format,
0000000000000000000000000000000000000000;;			KnownFormats: i.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type basicCommonValidator struct {
0000000000000000000000000000000000000000;;		Path    string
0000000000000000000000000000000000000000;;		In      string
0000000000000000000000000000000000000000;;		Default interface{}
0000000000000000000000000000000000000000;;		Enum    []interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *basicCommonValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		b.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *basicCommonValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		switch source.(type) {
0000000000000000000000000000000000000000;;		case *spec.Parameter, *spec.Schema, *spec.Header:
0000000000000000000000000000000000000000;;			return true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (b *basicCommonValidator) Validate(data interface{}) (res *Result) {
0000000000000000000000000000000000000000;;		if len(b.Enum) > 0 {
0000000000000000000000000000000000000000;;			for _, enumValue := range b.Enum {
0000000000000000000000000000000000000000;;				if data != nil && reflect.DeepEqual(enumValue, data) {
0000000000000000000000000000000000000000;;					return nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return sErr(errors.EnumFail(b.Path, b.In, data, b.Enum))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A HeaderValidator has very limited subset of validations to apply
0000000000000000000000000000000000000000;;	type HeaderValidator struct {
0000000000000000000000000000000000000000;;		name         string
0000000000000000000000000000000000000000;;		header       *spec.Header
0000000000000000000000000000000000000000;;		validators   []valueValidator
0000000000000000000000000000000000000000;;		KnownFormats strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewHeaderValidator creates a new header validator object
0000000000000000000000000000000000000000;;	func NewHeaderValidator(name string, header *spec.Header, formats strfmt.Registry) *HeaderValidator {
0000000000000000000000000000000000000000;;		p := &HeaderValidator{name: name, header: header, KnownFormats: formats}
0000000000000000000000000000000000000000;;		p.validators = []valueValidator{
0000000000000000000000000000000000000000;;			&typeValidator{
0000000000000000000000000000000000000000;;				Type:   spec.StringOrArray([]string{header.Type}),
0000000000000000000000000000000000000000;;				Format: header.Format,
0000000000000000000000000000000000000000;;				In:     "header",
0000000000000000000000000000000000000000;;				Path:   name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			p.stringValidator(),
0000000000000000000000000000000000000000;;			p.formatValidator(),
0000000000000000000000000000000000000000;;			p.numberValidator(),
0000000000000000000000000000000000000000;;			p.sliceValidator(),
0000000000000000000000000000000000000000;;			p.commonValidator(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate the value of the header against its schema
0000000000000000000000000000000000000000;;	func (p *HeaderValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		result := new(Result)
0000000000000000000000000000000000000000;;		tpe := reflect.TypeOf(data)
0000000000000000000000000000000000000000;;		kind := tpe.Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, validator := range p.validators {
0000000000000000000000000000000000000000;;			if validator.Applies(p.header, kind) {
0000000000000000000000000000000000000000;;				if err := validator.Validate(data); err != nil {
0000000000000000000000000000000000000000;;					result.Merge(err)
0000000000000000000000000000000000000000;;					if err.HasErrors() {
0000000000000000000000000000000000000000;;						return result
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *HeaderValidator) commonValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &basicCommonValidator{
0000000000000000000000000000000000000000;;			Path:    p.name,
0000000000000000000000000000000000000000;;			In:      "response",
0000000000000000000000000000000000000000;;			Default: p.header.Default,
0000000000000000000000000000000000000000;;			Enum:    p.header.Enum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *HeaderValidator) sliceValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &basicSliceValidator{
0000000000000000000000000000000000000000;;			Path:         p.name,
0000000000000000000000000000000000000000;;			In:           "response",
0000000000000000000000000000000000000000;;			Default:      p.header.Default,
0000000000000000000000000000000000000000;;			MaxItems:     p.header.MaxItems,
0000000000000000000000000000000000000000;;			MinItems:     p.header.MinItems,
0000000000000000000000000000000000000000;;			UniqueItems:  p.header.UniqueItems,
0000000000000000000000000000000000000000;;			Items:        p.header.Items,
0000000000000000000000000000000000000000;;			Source:       p.header,
0000000000000000000000000000000000000000;;			KnownFormats: p.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *HeaderValidator) numberValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &numberValidator{
0000000000000000000000000000000000000000;;			Path:             p.name,
0000000000000000000000000000000000000000;;			In:               "response",
0000000000000000000000000000000000000000;;			Default:          p.header.Default,
0000000000000000000000000000000000000000;;			MultipleOf:       p.header.MultipleOf,
0000000000000000000000000000000000000000;;			Maximum:          p.header.Maximum,
0000000000000000000000000000000000000000;;			ExclusiveMaximum: p.header.ExclusiveMaximum,
0000000000000000000000000000000000000000;;			Minimum:          p.header.Minimum,
0000000000000000000000000000000000000000;;			ExclusiveMinimum: p.header.ExclusiveMinimum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *HeaderValidator) stringValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &stringValidator{
0000000000000000000000000000000000000000;;			Path:            p.name,
0000000000000000000000000000000000000000;;			In:              "response",
0000000000000000000000000000000000000000;;			Default:         p.header.Default,
0000000000000000000000000000000000000000;;			Required:        true,
0000000000000000000000000000000000000000;;			MaxLength:       p.header.MaxLength,
0000000000000000000000000000000000000000;;			MinLength:       p.header.MinLength,
0000000000000000000000000000000000000000;;			Pattern:         p.header.Pattern,
0000000000000000000000000000000000000000;;			AllowEmptyValue: false,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *HeaderValidator) formatValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &formatValidator{
0000000000000000000000000000000000000000;;			Path: p.name,
0000000000000000000000000000000000000000;;			In:   "response",
0000000000000000000000000000000000000000;;			//Default:      p.header.Default,
0000000000000000000000000000000000000000;;			Format:       p.header.Format,
0000000000000000000000000000000000000000;;			KnownFormats: p.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A ParamValidator has very limited subset of validations to apply
0000000000000000000000000000000000000000;;	type ParamValidator struct {
0000000000000000000000000000000000000000;;		param        *spec.Parameter
0000000000000000000000000000000000000000;;		validators   []valueValidator
0000000000000000000000000000000000000000;;		KnownFormats strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewParamValidator creates a new param validator object
0000000000000000000000000000000000000000;;	func NewParamValidator(param *spec.Parameter, formats strfmt.Registry) *ParamValidator {
0000000000000000000000000000000000000000;;		p := &ParamValidator{param: param, KnownFormats: formats}
0000000000000000000000000000000000000000;;		p.validators = []valueValidator{
0000000000000000000000000000000000000000;;			&typeValidator{
0000000000000000000000000000000000000000;;				Type:   spec.StringOrArray([]string{param.Type}),
0000000000000000000000000000000000000000;;				Format: param.Format,
0000000000000000000000000000000000000000;;				In:     param.In,
0000000000000000000000000000000000000000;;				Path:   param.Name,
0000000000000000000000000000000000000000;;			},
0000000000000000000000000000000000000000;;			p.stringValidator(),
0000000000000000000000000000000000000000;;			p.formatValidator(),
0000000000000000000000000000000000000000;;			p.numberValidator(),
0000000000000000000000000000000000000000;;			p.sliceValidator(),
0000000000000000000000000000000000000000;;			p.commonValidator(),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return p
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate the data against the description of the parameter
0000000000000000000000000000000000000000;;	func (p *ParamValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		result := new(Result)
0000000000000000000000000000000000000000;;		tpe := reflect.TypeOf(data)
0000000000000000000000000000000000000000;;		kind := tpe.Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TODO: validate type
0000000000000000000000000000000000000000;;		for _, validator := range p.validators {
0000000000000000000000000000000000000000;;			if validator.Applies(p.param, kind) {
0000000000000000000000000000000000000000;;				if err := validator.Validate(data); err != nil {
0000000000000000000000000000000000000000;;					result.Merge(err)
0000000000000000000000000000000000000000;;					if err.HasErrors() {
0000000000000000000000000000000000000000;;						return result
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ParamValidator) commonValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &basicCommonValidator{
0000000000000000000000000000000000000000;;			Path:    p.param.Name,
0000000000000000000000000000000000000000;;			In:      p.param.In,
0000000000000000000000000000000000000000;;			Default: p.param.Default,
0000000000000000000000000000000000000000;;			Enum:    p.param.Enum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ParamValidator) sliceValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &basicSliceValidator{
0000000000000000000000000000000000000000;;			Path:         p.param.Name,
0000000000000000000000000000000000000000;;			In:           p.param.In,
0000000000000000000000000000000000000000;;			Default:      p.param.Default,
0000000000000000000000000000000000000000;;			MaxItems:     p.param.MaxItems,
0000000000000000000000000000000000000000;;			MinItems:     p.param.MinItems,
0000000000000000000000000000000000000000;;			UniqueItems:  p.param.UniqueItems,
0000000000000000000000000000000000000000;;			Items:        p.param.Items,
0000000000000000000000000000000000000000;;			Source:       p.param,
0000000000000000000000000000000000000000;;			KnownFormats: p.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ParamValidator) numberValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &numberValidator{
0000000000000000000000000000000000000000;;			Path:             p.param.Name,
0000000000000000000000000000000000000000;;			In:               p.param.In,
0000000000000000000000000000000000000000;;			Default:          p.param.Default,
0000000000000000000000000000000000000000;;			MultipleOf:       p.param.MultipleOf,
0000000000000000000000000000000000000000;;			Maximum:          p.param.Maximum,
0000000000000000000000000000000000000000;;			ExclusiveMaximum: p.param.ExclusiveMaximum,
0000000000000000000000000000000000000000;;			Minimum:          p.param.Minimum,
0000000000000000000000000000000000000000;;			ExclusiveMinimum: p.param.ExclusiveMinimum,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ParamValidator) stringValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &stringValidator{
0000000000000000000000000000000000000000;;			Path:            p.param.Name,
0000000000000000000000000000000000000000;;			In:              p.param.In,
0000000000000000000000000000000000000000;;			Default:         p.param.Default,
0000000000000000000000000000000000000000;;			AllowEmptyValue: p.param.AllowEmptyValue,
0000000000000000000000000000000000000000;;			Required:        p.param.Required,
0000000000000000000000000000000000000000;;			MaxLength:       p.param.MaxLength,
0000000000000000000000000000000000000000;;			MinLength:       p.param.MinLength,
0000000000000000000000000000000000000000;;			Pattern:         p.param.Pattern,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *ParamValidator) formatValidator() valueValidator {
0000000000000000000000000000000000000000;;		return &formatValidator{
0000000000000000000000000000000000000000;;			Path: p.param.Name,
0000000000000000000000000000000000000000;;			In:   p.param.In,
0000000000000000000000000000000000000000;;			//Default:      p.param.Default,
0000000000000000000000000000000000000000;;			Format:       p.param.Format,
0000000000000000000000000000000000000000;;			KnownFormats: p.KnownFormats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type basicSliceValidator struct {
0000000000000000000000000000000000000000;;		Path           string
0000000000000000000000000000000000000000;;		In             string
0000000000000000000000000000000000000000;;		Default        interface{}
0000000000000000000000000000000000000000;;		MaxItems       *int64
0000000000000000000000000000000000000000;;		MinItems       *int64
0000000000000000000000000000000000000000;;		UniqueItems    bool
0000000000000000000000000000000000000000;;		Items          *spec.Items
0000000000000000000000000000000000000000;;		Source         interface{}
0000000000000000000000000000000000000000;;		itemsValidator *itemsValidator
0000000000000000000000000000000000000000;;		KnownFormats   strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *basicSliceValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		s.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *basicSliceValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		switch source.(type) {
0000000000000000000000000000000000000000;;		case *spec.Parameter, *spec.Items, *spec.Header:
0000000000000000000000000000000000000000;;			return kind == reflect.Slice
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func sErr(err errors.Error) *Result {
0000000000000000000000000000000000000000;;		return &Result{Errors: []error{err}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *basicSliceValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		size := int64(val.Len())
0000000000000000000000000000000000000000;;		if s.MinItems != nil {
0000000000000000000000000000000000000000;;			if err := MinItems(s.Path, s.In, size, *s.MinItems); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.MaxItems != nil {
0000000000000000000000000000000000000000;;			if err := MaxItems(s.Path, s.In, size, *s.MaxItems); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.UniqueItems {
0000000000000000000000000000000000000000;;			if err := UniqueItems(s.Path, s.In, data); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.itemsValidator == nil && s.Items != nil {
0000000000000000000000000000000000000000;;			s.itemsValidator = newItemsValidator(s.Path, s.In, s.Items, s.Source, s.KnownFormats)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.itemsValidator != nil {
0000000000000000000000000000000000000000;;			for i := 0; i < int(size); i++ {
0000000000000000000000000000000000000000;;				ele := val.Index(i)
0000000000000000000000000000000000000000;;				if err := s.itemsValidator.Validate(i, ele.Interface()); err != nil && err.HasErrors() {
0000000000000000000000000000000000000000;;					return err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *basicSliceValidator) hasDuplicates(value reflect.Value, size int) bool {
0000000000000000000000000000000000000000;;		dict := make(map[interface{}]struct{})
0000000000000000000000000000000000000000;;		for i := 0; i < size; i++ {
0000000000000000000000000000000000000000;;			ele := value.Index(i)
0000000000000000000000000000000000000000;;			if _, ok := dict[ele.Interface()]; ok {
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			dict[ele.Interface()] = struct{}{}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type numberValidator struct {
0000000000000000000000000000000000000000;;		Path             string
0000000000000000000000000000000000000000;;		In               string
0000000000000000000000000000000000000000;;		Default          interface{}
0000000000000000000000000000000000000000;;		MultipleOf       *float64
0000000000000000000000000000000000000000;;		Maximum          *float64
0000000000000000000000000000000000000000;;		ExclusiveMaximum bool
0000000000000000000000000000000000000000;;		Minimum          *float64
0000000000000000000000000000000000000000;;		ExclusiveMinimum bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *numberValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		n.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *numberValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		switch source.(type) {
0000000000000000000000000000000000000000;;		case *spec.Parameter, *spec.Schema, *spec.Items, *spec.Header:
0000000000000000000000000000000000000000;;			isInt := kind >= reflect.Int && kind <= reflect.Uint64
0000000000000000000000000000000000000000;;			isFloat := kind == reflect.Float32 || kind == reflect.Float64
0000000000000000000000000000000000000000;;			r := isInt || isFloat
0000000000000000000000000000000000000000;;			// fmt.Printf("schema props validator for %q applies %t for %T (kind: %v)\n", n.Path, r, source, kind)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// fmt.Printf("schema props validator for %q applies %t for %T (kind: %v)\n", n.Path, false, source, kind)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *numberValidator) convertToFloat(val interface{}) float64 {
0000000000000000000000000000000000000000;;		v := reflect.ValueOf(val)
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
0000000000000000000000000000000000000000;;			return float64(v.Int())
0000000000000000000000000000000000000000;;		case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
0000000000000000000000000000000000000000;;			return float64(v.Uint())
0000000000000000000000000000000000000000;;		case reflect.Float32, reflect.Float64:
0000000000000000000000000000000000000000;;			return v.Float()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (n *numberValidator) Validate(val interface{}) *Result {
0000000000000000000000000000000000000000;;		data := n.convertToFloat(val)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if n.MultipleOf != nil {
0000000000000000000000000000000000000000;;			if err := MultipleOf(n.Path, n.In, data, *n.MultipleOf); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.Maximum != nil {
0000000000000000000000000000000000000000;;			if err := Maximum(n.Path, n.In, data, *n.Maximum, n.ExclusiveMaximum); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if n.Minimum != nil {
0000000000000000000000000000000000000000;;			if err := Minimum(n.Path, n.In, data, *n.Minimum, n.ExclusiveMinimum); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result := new(Result)
0000000000000000000000000000000000000000;;		result.Inc()
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type stringValidator struct {
0000000000000000000000000000000000000000;;		Default         interface{}
0000000000000000000000000000000000000000;;		Required        bool
0000000000000000000000000000000000000000;;		AllowEmptyValue bool
0000000000000000000000000000000000000000;;		MaxLength       *int64
0000000000000000000000000000000000000000;;		MinLength       *int64
0000000000000000000000000000000000000000;;		Pattern         string
0000000000000000000000000000000000000000;;		Path            string
0000000000000000000000000000000000000000;;		In              string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stringValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		s.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stringValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		switch source.(type) {
0000000000000000000000000000000000000000;;		case *spec.Parameter, *spec.Schema, *spec.Items, *spec.Header:
0000000000000000000000000000000000000000;;			r := kind == reflect.String
0000000000000000000000000000000000000000;;			// fmt.Printf("string validator for %q applies %t for %T (kind: %v)\n", s.Path, r, source, kind)
0000000000000000000000000000000000000000;;			return r
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// fmt.Printf("string validator for %q applies %t for %T (kind: %v)\n", s.Path, false, source, kind)
0000000000000000000000000000000000000000;;		return false
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *stringValidator) Validate(val interface{}) *Result {
0000000000000000000000000000000000000000;;		data := val.(string)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Required && !s.AllowEmptyValue && (s.Default == nil || s.Default == "") {
0000000000000000000000000000000000000000;;			if err := RequiredString(s.Path, s.In, data); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.MaxLength != nil {
0000000000000000000000000000000000000000;;			if err := MaxLength(s.Path, s.In, data, *s.MaxLength); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.MinLength != nil {
0000000000000000000000000000000000000000;;			if err := MinLength(s.Path, s.In, data, *s.MinLength); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Pattern != "" {
0000000000000000000000000000000000000000;;			if err := Pattern(s.Path, s.In, data, s.Pattern); err != nil {
0000000000000000000000000000000000000000;;				return sErr(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
