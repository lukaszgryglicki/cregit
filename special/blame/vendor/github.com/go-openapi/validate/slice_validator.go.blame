0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type schemaSliceValidator struct {
0000000000000000000000000000000000000000;;		Path            string
0000000000000000000000000000000000000000;;		In              string
0000000000000000000000000000000000000000;;		MaxItems        *int64
0000000000000000000000000000000000000000;;		MinItems        *int64
0000000000000000000000000000000000000000;;		UniqueItems     bool
0000000000000000000000000000000000000000;;		AdditionalItems *spec.SchemaOrBool
0000000000000000000000000000000000000000;;		Items           *spec.SchemaOrArray
0000000000000000000000000000000000000000;;		Root            interface{}
0000000000000000000000000000000000000000;;		KnownFormats    strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *schemaSliceValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		s.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *schemaSliceValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		_, ok := source.(*spec.Schema)
0000000000000000000000000000000000000000;;		r := ok && kind == reflect.Slice
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *schemaSliceValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		result := new(Result)
0000000000000000000000000000000000000000;;		if data == nil {
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		val := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;		size := val.Len()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Items != nil && s.Items.Schema != nil {
0000000000000000000000000000000000000000;;			validator := NewSchemaValidator(s.Items.Schema, s.Root, s.Path, s.KnownFormats)
0000000000000000000000000000000000000000;;			for i := 0; i < size; i++ {
0000000000000000000000000000000000000000;;				validator.SetPath(fmt.Sprintf("%s.%d", s.Path, i))
0000000000000000000000000000000000000000;;				value := val.Index(i)
0000000000000000000000000000000000000000;;				result.Merge(validator.Validate(value.Interface()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		itemsSize := int64(0)
0000000000000000000000000000000000000000;;		if s.Items != nil && len(s.Items.Schemas) > 0 {
0000000000000000000000000000000000000000;;			itemsSize = int64(len(s.Items.Schemas))
0000000000000000000000000000000000000000;;			for i := int64(0); i < itemsSize; i++ {
0000000000000000000000000000000000000000;;				validator := NewSchemaValidator(&s.Items.Schemas[i], s.Root, fmt.Sprintf("%s.%d", s.Path, i), s.KnownFormats)
0000000000000000000000000000000000000000;;				result.Merge(validator.Validate(val.Index(int(i)).Interface()))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.AdditionalItems != nil && itemsSize < int64(size) {
0000000000000000000000000000000000000000;;			if s.Items != nil && len(s.Items.Schemas) > 0 && !s.AdditionalItems.Allows {
0000000000000000000000000000000000000000;;				result.AddErrors(errors.New(422, "array doesn't allow for additional items"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if s.AdditionalItems.Schema != nil {
0000000000000000000000000000000000000000;;				for i := itemsSize; i < (int64(size)-itemsSize)+1; i++ {
0000000000000000000000000000000000000000;;					validator := NewSchemaValidator(s.AdditionalItems.Schema, s.Root, fmt.Sprintf("%s.%d", s.Path, i), s.KnownFormats)
0000000000000000000000000000000000000000;;					result.Merge(validator.Validate(val.Index(int(i)).Interface()))
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.MinItems != nil {
0000000000000000000000000000000000000000;;			if err := MinItems(s.Path, s.In, int64(size), *s.MinItems); err != nil {
0000000000000000000000000000000000000000;;				result.AddErrors(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.MaxItems != nil {
0000000000000000000000000000000000000000;;			if err := MaxItems(s.Path, s.In, int64(size), *s.MaxItems); err != nil {
0000000000000000000000000000000000000000;;				result.AddErrors(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if s.UniqueItems {
0000000000000000000000000000000000000000;;			if err := UniqueItems(s.Path, s.In, val.Interface()); err != nil {
0000000000000000000000000000000000000000;;				result.AddErrors(err)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.Inc()
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
