0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type schemaPropsValidator struct {
0000000000000000000000000000000000000000;;		Path            string
0000000000000000000000000000000000000000;;		In              string
0000000000000000000000000000000000000000;;		AllOf           []spec.Schema
0000000000000000000000000000000000000000;;		OneOf           []spec.Schema
0000000000000000000000000000000000000000;;		AnyOf           []spec.Schema
0000000000000000000000000000000000000000;;		Not             *spec.Schema
0000000000000000000000000000000000000000;;		Dependencies    spec.Dependencies
0000000000000000000000000000000000000000;;		anyOfValidators []SchemaValidator
0000000000000000000000000000000000000000;;		allOfValidators []SchemaValidator
0000000000000000000000000000000000000000;;		oneOfValidators []SchemaValidator
0000000000000000000000000000000000000000;;		notValidator    *SchemaValidator
0000000000000000000000000000000000000000;;		Root            interface{}
0000000000000000000000000000000000000000;;		KnownFormats    strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *schemaPropsValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		s.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func newSchemaPropsValidator(path string, in string, allOf, oneOf, anyOf []spec.Schema, not *spec.Schema, deps spec.Dependencies, root interface{}, formats strfmt.Registry) *schemaPropsValidator {
0000000000000000000000000000000000000000;;		var anyValidators []SchemaValidator
0000000000000000000000000000000000000000;;		for _, v := range anyOf {
0000000000000000000000000000000000000000;;			anyValidators = append(anyValidators, *NewSchemaValidator(&v, root, path, formats))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var allValidators []SchemaValidator
0000000000000000000000000000000000000000;;		for _, v := range allOf {
0000000000000000000000000000000000000000;;			allValidators = append(allValidators, *NewSchemaValidator(&v, root, path, formats))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var oneValidators []SchemaValidator
0000000000000000000000000000000000000000;;		for _, v := range oneOf {
0000000000000000000000000000000000000000;;			oneValidators = append(oneValidators, *NewSchemaValidator(&v, root, path, formats))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var notValidator *SchemaValidator
0000000000000000000000000000000000000000;;		if not != nil {
0000000000000000000000000000000000000000;;			notValidator = NewSchemaValidator(not, root, path, formats)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &schemaPropsValidator{
0000000000000000000000000000000000000000;;			Path:            path,
0000000000000000000000000000000000000000;;			In:              in,
0000000000000000000000000000000000000000;;			AllOf:           allOf,
0000000000000000000000000000000000000000;;			OneOf:           oneOf,
0000000000000000000000000000000000000000;;			AnyOf:           anyOf,
0000000000000000000000000000000000000000;;			Not:             not,
0000000000000000000000000000000000000000;;			Dependencies:    deps,
0000000000000000000000000000000000000000;;			anyOfValidators: anyValidators,
0000000000000000000000000000000000000000;;			allOfValidators: allValidators,
0000000000000000000000000000000000000000;;			oneOfValidators: oneValidators,
0000000000000000000000000000000000000000;;			notValidator:    notValidator,
0000000000000000000000000000000000000000;;			Root:            root,
0000000000000000000000000000000000000000;;			KnownFormats:    formats,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *schemaPropsValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		r := reflect.TypeOf(source) == specSchemaType
0000000000000000000000000000000000000000;;		// fmt.Printf("schema props validator for %q applies %t for %T (kind: %v)\n", s.Path, r, source, kind)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (s *schemaPropsValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		mainResult := new(Result)
0000000000000000000000000000000000000000;;		if len(s.anyOfValidators) > 0 {
0000000000000000000000000000000000000000;;			var bestFailures *Result
0000000000000000000000000000000000000000;;			succeededOnce := false
0000000000000000000000000000000000000000;;			for _, anyOfSchema := range s.anyOfValidators {
0000000000000000000000000000000000000000;;				result := anyOfSchema.Validate(data)
0000000000000000000000000000000000000000;;				if result.IsValid() {
0000000000000000000000000000000000000000;;					bestFailures = nil
0000000000000000000000000000000000000000;;					succeededOnce = true
0000000000000000000000000000000000000000;;					break
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if bestFailures == nil || result.MatchCount > bestFailures.MatchCount {
0000000000000000000000000000000000000000;;					bestFailures = result
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if !succeededOnce {
0000000000000000000000000000000000000000;;				mainResult.AddErrors(errors.New(422, "must validate at least one schema (anyOf)"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if bestFailures != nil {
0000000000000000000000000000000000000000;;				mainResult.Merge(bestFailures)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s.oneOfValidators) > 0 {
0000000000000000000000000000000000000000;;			var bestFailures *Result
0000000000000000000000000000000000000000;;			validated := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, oneOfSchema := range s.oneOfValidators {
0000000000000000000000000000000000000000;;				result := oneOfSchema.Validate(data)
0000000000000000000000000000000000000000;;				if result.IsValid() {
0000000000000000000000000000000000000000;;					validated++
0000000000000000000000000000000000000000;;					bestFailures = nil
0000000000000000000000000000000000000000;;					continue
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if validated == 0 && (bestFailures == nil || result.MatchCount > bestFailures.MatchCount) {
0000000000000000000000000000000000000000;;					bestFailures = result
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if validated != 1 {
0000000000000000000000000000000000000000;;				mainResult.AddErrors(errors.New(422, "must validate one and only one schema (oneOf)"))
0000000000000000000000000000000000000000;;				if bestFailures != nil {
0000000000000000000000000000000000000000;;					mainResult.Merge(bestFailures)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(s.allOfValidators) > 0 {
0000000000000000000000000000000000000000;;			validated := 0
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, allOfSchema := range s.allOfValidators {
0000000000000000000000000000000000000000;;				result := allOfSchema.Validate(data)
0000000000000000000000000000000000000000;;				if result.IsValid() {
0000000000000000000000000000000000000000;;					validated++
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				mainResult.Merge(result)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if validated != len(s.allOfValidators) {
0000000000000000000000000000000000000000;;				mainResult.AddErrors(errors.New(422, "must validate all the schemas (allOf)"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.notValidator != nil {
0000000000000000000000000000000000000000;;			result := s.notValidator.Validate(data)
0000000000000000000000000000000000000000;;			if result.IsValid() {
0000000000000000000000000000000000000000;;				mainResult.AddErrors(errors.New(422, "must not validate the schema (not)"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if s.Dependencies != nil && len(s.Dependencies) > 0 && reflect.TypeOf(data).Kind() == reflect.Map {
0000000000000000000000000000000000000000;;			val := data.(map[string]interface{})
0000000000000000000000000000000000000000;;			for key := range val {
0000000000000000000000000000000000000000;;				if dep, ok := s.Dependencies[key]; ok {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if dep.Schema != nil {
0000000000000000000000000000000000000000;;						mainResult.Merge(NewSchemaValidator(dep.Schema, s.Root, s.Path+"."+key, s.KnownFormats).Validate(data))
0000000000000000000000000000000000000000;;						continue
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					if len(dep.Property) > 0 {
0000000000000000000000000000000000000000;;						for _, depKey := range dep.Property {
0000000000000000000000000000000000000000;;							if _, ok := val[depKey]; !ok {
0000000000000000000000000000000000000000;;								mainResult.AddErrors(errors.New(422, "has a dependency on %s", depKey))
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		mainResult.Inc()
0000000000000000000000000000000000000000;;		return mainResult
0000000000000000000000000000000000000000;;	}
