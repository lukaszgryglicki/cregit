0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type formatValidator struct {
0000000000000000000000000000000000000000;;		Format       string
0000000000000000000000000000000000000000;;		Path         string
0000000000000000000000000000000000000000;;		In           string
0000000000000000000000000000000000000000;;		KnownFormats strfmt.Registry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *formatValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		f.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *formatValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		doit := func() bool {
0000000000000000000000000000000000000000;;			if source == nil {
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			switch source.(type) {
0000000000000000000000000000000000000000;;			case *spec.Items:
0000000000000000000000000000000000000000;;				it := source.(*spec.Items)
0000000000000000000000000000000000000000;;				return kind == reflect.String && f.KnownFormats.ContainsName(it.Format)
0000000000000000000000000000000000000000;;			case *spec.Parameter:
0000000000000000000000000000000000000000;;				par := source.(*spec.Parameter)
0000000000000000000000000000000000000000;;				return kind == reflect.String && f.KnownFormats.ContainsName(par.Format)
0000000000000000000000000000000000000000;;			case *spec.Schema:
0000000000000000000000000000000000000000;;				sch := source.(*spec.Schema)
0000000000000000000000000000000000000000;;				return kind == reflect.String && f.KnownFormats.ContainsName(sch.Format)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		r := doit()
0000000000000000000000000000000000000000;;		// fmt.Printf("schema props validator for %q applies %t for %T (kind: %v)\n", f.Path, r, source, kind)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (f *formatValidator) Validate(val interface{}) *Result {
0000000000000000000000000000000000000000;;		result := new(Result)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err := FormatOf(f.Path, f.In, f.Format, val.(string), f.KnownFormats); err != nil {
0000000000000000000000000000000000000000;;			result.AddErrors(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if result.HasErrors() {
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
