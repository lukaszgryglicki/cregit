0000000000000000000000000000000000000000;;	// Copyright 2015 go-swagger maintainers
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//    http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	package validate
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/errors"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/runtime"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/spec"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/strfmt"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type typeValidator struct {
0000000000000000000000000000000000000000;;		Type   spec.StringOrArray
0000000000000000000000000000000000000000;;		Format string
0000000000000000000000000000000000000000;;		In     string
0000000000000000000000000000000000000000;;		Path   string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var jsonTypeNames = map[string]struct{}{
0000000000000000000000000000000000000000;;		"array":   struct{}{},
0000000000000000000000000000000000000000;;		"boolean": struct{}{},
0000000000000000000000000000000000000000;;		"integer": struct{}{},
0000000000000000000000000000000000000000;;		"null":    struct{}{},
0000000000000000000000000000000000000000;;		"number":  struct{}{},
0000000000000000000000000000000000000000;;		"object":  struct{}{},
0000000000000000000000000000000000000000;;		"string":  struct{}{},
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *typeValidator) schemaInfoForType(data interface{}) (string, string) {
0000000000000000000000000000000000000000;;		switch data.(type) {
0000000000000000000000000000000000000000;;		case []byte:
0000000000000000000000000000000000000000;;			return "string", "byte"
0000000000000000000000000000000000000000;;		case strfmt.Date, *strfmt.Date:
0000000000000000000000000000000000000000;;			return "string", "date"
0000000000000000000000000000000000000000;;		case strfmt.DateTime, *strfmt.DateTime:
0000000000000000000000000000000000000000;;			return "string", "datetime"
0000000000000000000000000000000000000000;;		case runtime.File, *runtime.File:
0000000000000000000000000000000000000000;;			return "file", ""
0000000000000000000000000000000000000000;;		case strfmt.URI, *strfmt.URI:
0000000000000000000000000000000000000000;;			return "string", "uri"
0000000000000000000000000000000000000000;;		case strfmt.Email, *strfmt.Email:
0000000000000000000000000000000000000000;;			return "string", "email"
0000000000000000000000000000000000000000;;		case strfmt.Hostname, *strfmt.Hostname:
0000000000000000000000000000000000000000;;			return "string", "hostname"
0000000000000000000000000000000000000000;;		case strfmt.IPv4, *strfmt.IPv4:
0000000000000000000000000000000000000000;;			return "string", "ipv4"
0000000000000000000000000000000000000000;;		case strfmt.IPv6, *strfmt.IPv6:
0000000000000000000000000000000000000000;;			return "string", "ipv6"
0000000000000000000000000000000000000000;;		case strfmt.UUID, *strfmt.UUID:
0000000000000000000000000000000000000000;;			return "string", "uuid"
0000000000000000000000000000000000000000;;		case strfmt.UUID3, *strfmt.UUID3:
0000000000000000000000000000000000000000;;			return "string", "uuid3"
0000000000000000000000000000000000000000;;		case strfmt.UUID4, *strfmt.UUID4:
0000000000000000000000000000000000000000;;			return "string", "uuid4"
0000000000000000000000000000000000000000;;		case strfmt.UUID5, *strfmt.UUID5:
0000000000000000000000000000000000000000;;			return "string", "uuid5"
0000000000000000000000000000000000000000;;		case strfmt.ISBN, *strfmt.ISBN:
0000000000000000000000000000000000000000;;			return "string", "isbn"
0000000000000000000000000000000000000000;;		case strfmt.ISBN10, *strfmt.ISBN10:
0000000000000000000000000000000000000000;;			return "string", "isbn10"
0000000000000000000000000000000000000000;;		case strfmt.ISBN13, *strfmt.ISBN13:
0000000000000000000000000000000000000000;;			return "string", "isbn13"
0000000000000000000000000000000000000000;;		case strfmt.CreditCard, *strfmt.CreditCard:
0000000000000000000000000000000000000000;;			return "string", "creditcard"
0000000000000000000000000000000000000000;;		case strfmt.SSN, *strfmt.SSN:
0000000000000000000000000000000000000000;;			return "string", "ssn"
0000000000000000000000000000000000000000;;		case strfmt.HexColor, *strfmt.HexColor:
0000000000000000000000000000000000000000;;			return "string", "hexcolor"
0000000000000000000000000000000000000000;;		case strfmt.RGBColor, *strfmt.RGBColor:
0000000000000000000000000000000000000000;;			return "string", "rgbcolor"
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			val := reflect.ValueOf(data)
0000000000000000000000000000000000000000;;			tpe := val.Type()
0000000000000000000000000000000000000000;;			switch tpe.Kind() {
0000000000000000000000000000000000000000;;			case reflect.Bool:
0000000000000000000000000000000000000000;;				return "boolean", ""
0000000000000000000000000000000000000000;;			case reflect.String:
0000000000000000000000000000000000000000;;				return "string", ""
0000000000000000000000000000000000000000;;			case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32:
0000000000000000000000000000000000000000;;				return "integer", "int32"
0000000000000000000000000000000000000000;;			case reflect.Int, reflect.Int64, reflect.Uint, reflect.Uint64:
0000000000000000000000000000000000000000;;				return "integer", "int64"
0000000000000000000000000000000000000000;;			case reflect.Float32:
0000000000000000000000000000000000000000;;				return "number", "float32"
0000000000000000000000000000000000000000;;			case reflect.Float64:
0000000000000000000000000000000000000000;;				return "number", "float64"
0000000000000000000000000000000000000000;;			case reflect.Slice:
0000000000000000000000000000000000000000;;				return "array", ""
0000000000000000000000000000000000000000;;			case reflect.Map, reflect.Struct:
0000000000000000000000000000000000000000;;				return "object", ""
0000000000000000000000000000000000000000;;			case reflect.Interface:
0000000000000000000000000000000000000000;;				// What to do here?
0000000000000000000000000000000000000000;;				panic("dunno what to do here")
0000000000000000000000000000000000000000;;			case reflect.Ptr:
0000000000000000000000000000000000000000;;				return t.schemaInfoForType(reflect.Indirect(val).Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *typeValidator) SetPath(path string) {
0000000000000000000000000000000000000000;;		t.Path = path
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *typeValidator) Applies(source interface{}, kind reflect.Kind) bool {
0000000000000000000000000000000000000000;;		stpe := reflect.TypeOf(source)
0000000000000000000000000000000000000000;;		r := (len(t.Type) > 0 || t.Format != "") && (stpe == specSchemaType || stpe == specParameterType || stpe == specHeaderType)
0000000000000000000000000000000000000000;;		//fmt.Printf("type validator for %q applies %t for %T (kind: %v)\n", t.Path, r, source, kind)
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (t *typeValidator) Validate(data interface{}) *Result {
0000000000000000000000000000000000000000;;		result := new(Result)
0000000000000000000000000000000000000000;;		result.Inc()
0000000000000000000000000000000000000000;;		if data == nil || reflect.DeepEqual(reflect.Zero(reflect.TypeOf(data)), reflect.ValueOf(data)) {
0000000000000000000000000000000000000000;;			if len(t.Type) > 0 && !t.Type.Contains("null") { // TODO: if a property is not required it also passes this
0000000000000000000000000000000000000000;;				return sErr(errors.InvalidType(t.Path, t.In, strings.Join(t.Type, ","), "null"))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// check if the type matches, should be used in every validator chain as first item
0000000000000000000000000000000000000000;;		val := reflect.Indirect(reflect.ValueOf(data))
0000000000000000000000000000000000000000;;		kind := val.Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schType, format := t.schemaInfoForType(data)
0000000000000000000000000000000000000000;;		//fmt.Println("path:", t.Path, "schType:", schType, "format:", format, "expType:", t.Type, "expFmt:", t.Format, "kind:", val.Kind().String())
0000000000000000000000000000000000000000;;		isLowerInt := t.Format == "int64" && format == "int32"
0000000000000000000000000000000000000000;;		isLowerFloat := t.Format == "float64" && format == "float32"
0000000000000000000000000000000000000000;;		isFloatInt := schType == "number" && swag.IsFloat64AJSONInteger(val.Float()) && t.Type.Contains("integer")
0000000000000000000000000000000000000000;;		isIntFloat := schType == "integer" && t.Type.Contains("number")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if kind != reflect.String && kind != reflect.Slice && t.Format != "" && !(t.Type.Contains(schType) || format == t.Format || isFloatInt || isIntFloat || isLowerInt || isLowerFloat) {
0000000000000000000000000000000000000000;;			return sErr(errors.InvalidType(t.Path, t.In, t.Format, format))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !(t.Type.Contains("number") || t.Type.Contains("integer")) && t.Format != "" && (kind == reflect.String || kind == reflect.Slice) {
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !(t.Type.Contains(schType) || isFloatInt || isIntFloat) {
0000000000000000000000000000000000000000;;			return sErr(errors.InvalidType(t.Path, t.In, strings.Join(t.Type, ","), schType))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
