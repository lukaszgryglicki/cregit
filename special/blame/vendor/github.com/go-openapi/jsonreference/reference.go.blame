0000000000000000000000000000000000000000;;	// Copyright 2013 sigu-399 ( https://github.com/sigu-399 )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// author       sigu-399
0000000000000000000000000000000000000000;;	// author-github  https://github.com/sigu-399
0000000000000000000000000000000000000000;;	// author-mail    sigu.399@gmail.com
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// repository-name  jsonreference
0000000000000000000000000000000000000000;;	// repository-desc  An implementation of JSON Reference - Go language
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// description    Main and unique file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// created        26-02-2013
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonreference
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/PuerkitoBio/purell"
0000000000000000000000000000000000000000;;		"github.com/go-openapi/jsonpointer"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		fragmentRune = `#`
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new reference for the given string
0000000000000000000000000000000000000000;;	func New(jsonReferenceString string) (Ref, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r Ref
0000000000000000000000000000000000000000;;		err := r.parse(jsonReferenceString)
0000000000000000000000000000000000000000;;		return r, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MustCreateRef parses the ref string and panics when it's invalid.
0000000000000000000000000000000000000000;;	// Use the New method for a version that returns an error
0000000000000000000000000000000000000000;;	func MustCreateRef(ref string) Ref {
0000000000000000000000000000000000000000;;		r, err := New(ref)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			panic(err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return r
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Ref represents a json reference object
0000000000000000000000000000000000000000;;	type Ref struct {
0000000000000000000000000000000000000000;;		referenceURL     *url.URL
0000000000000000000000000000000000000000;;		referencePointer jsonpointer.Pointer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HasFullURL      bool
0000000000000000000000000000000000000000;;		HasURLPathOnly  bool
0000000000000000000000000000000000000000;;		HasFragmentOnly bool
0000000000000000000000000000000000000000;;		HasFileScheme   bool
0000000000000000000000000000000000000000;;		HasFullFilePath bool
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetURL gets the URL for this reference
0000000000000000000000000000000000000000;;	func (r *Ref) GetURL() *url.URL {
0000000000000000000000000000000000000000;;		return r.referenceURL
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPointer gets the json pointer for this reference
0000000000000000000000000000000000000000;;	func (r *Ref) GetPointer() *jsonpointer.Pointer {
0000000000000000000000000000000000000000;;		return &r.referencePointer
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// String returns the best version of the url for this reference
0000000000000000000000000000000000000000;;	func (r *Ref) String() string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.referenceURL != nil {
0000000000000000000000000000000000000000;;			return r.referenceURL.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.HasFragmentOnly {
0000000000000000000000000000000000000000;;			return fragmentRune + r.referencePointer.String()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return r.referencePointer.String()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsRoot returns true if this reference is a root document
0000000000000000000000000000000000000000;;	func (r *Ref) IsRoot() bool {
0000000000000000000000000000000000000000;;		return r.referenceURL != nil &&
0000000000000000000000000000000000000000;;			!r.IsCanonical() &&
0000000000000000000000000000000000000000;;			!r.HasURLPathOnly &&
0000000000000000000000000000000000000000;;			r.referenceURL.Fragment == ""
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsCanonical returns true when this pointer starts with http(s):// or file://
0000000000000000000000000000000000000000;;	func (r *Ref) IsCanonical() bool {
0000000000000000000000000000000000000000;;		return (r.HasFileScheme && r.HasFullFilePath) || (!r.HasFileScheme && r.HasFullURL)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// "Constructor", parses the given string JSON reference
0000000000000000000000000000000000000000;;	func (r *Ref) parse(jsonReferenceString string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		parsed, err := url.Parse(jsonReferenceString)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.referenceURL, _ = url.Parse(purell.NormalizeURL(parsed, purell.FlagsSafe|purell.FlagRemoveDuplicateSlashes))
0000000000000000000000000000000000000000;;		refURL := r.referenceURL
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if refURL.Scheme != "" && refURL.Host != "" {
0000000000000000000000000000000000000000;;			r.HasFullURL = true
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			if refURL.Path != "" {
0000000000000000000000000000000000000000;;				r.HasURLPathOnly = true
0000000000000000000000000000000000000000;;			} else if refURL.RawQuery == "" && refURL.Fragment != "" {
0000000000000000000000000000000000000000;;				r.HasFragmentOnly = true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		r.HasFileScheme = refURL.Scheme == "file"
0000000000000000000000000000000000000000;;		r.HasFullFilePath = strings.HasPrefix(refURL.Path, "/")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// invalid json-pointer error means url has no json-pointer fragment. simply ignore error
0000000000000000000000000000000000000000;;		r.referencePointer, _ = jsonpointer.New(refURL.Fragment)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Inherits creates a new reference from a parent and a child
0000000000000000000000000000000000000000;;	// If the child cannot inherit from the parent, an error is returned
0000000000000000000000000000000000000000;;	func (r *Ref) Inherits(child Ref) (*Ref, error) {
0000000000000000000000000000000000000000;;		childURL := child.GetURL()
0000000000000000000000000000000000000000;;		parentURL := r.GetURL()
0000000000000000000000000000000000000000;;		if childURL == nil {
0000000000000000000000000000000000000000;;			return nil, errors.New("child url is nil")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if parentURL == nil {
0000000000000000000000000000000000000000;;			return &child, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ref, err := New(parentURL.ResolveReference(childURL).String())
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return &ref, nil
0000000000000000000000000000000000000000;;	}
