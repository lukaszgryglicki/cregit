0000000000000000000000000000000000000000;;	// Copyright 2013 sigu-399 ( https://github.com/sigu-399 )
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Licensed under the Apache License, Version 2.0 (the "License");
0000000000000000000000000000000000000000;;	// you may not use this file except in compliance with the License.
0000000000000000000000000000000000000000;;	// You may obtain a copy of the License at
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	//   http://www.apache.org/licenses/LICENSE-2.0
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Unless required by applicable law or agreed to in writing, software
0000000000000000000000000000000000000000;;	// distributed under the License is distributed on an "AS IS" BASIS,
0000000000000000000000000000000000000000;;	// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
0000000000000000000000000000000000000000;;	// See the License for the specific language governing permissions and
0000000000000000000000000000000000000000;;	// limitations under the License.
20a23b516161fc6e4e2d00ed067520ad63629162;;	
0000000000000000000000000000000000000000;;	// author       sigu-399
0000000000000000000000000000000000000000;;	// author-github  https://github.com/sigu-399
0000000000000000000000000000000000000000;;	// author-mail    sigu.399@gmail.com
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// repository-name  jsonpointer
0000000000000000000000000000000000000000;;	// repository-desc  An implementation of JSON Pointer - Go language
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// description    Main and unique file.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// created        25-02-2013
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	package jsonpointer
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/go-openapi/swag"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		emptyPointer     = ``
0000000000000000000000000000000000000000;;		pointerSeparator = `/`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		invalidStart = `JSON pointer must be empty or start with a "` + pointerSeparator
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var jsonPointableType = reflect.TypeOf(new(JSONPointable)).Elem()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// JSONPointable is an interface for structs to implement when they need to customize the
0000000000000000000000000000000000000000;;	// json pointer process
0000000000000000000000000000000000000000;;	type JSONPointable interface {
0000000000000000000000000000000000000000;;		JSONLookup(string) (interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type implStruct struct {
0000000000000000000000000000000000000000;;		mode string // "SET" or "GET"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		inDocument interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		setInValue interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		getOutNode interface{}
0000000000000000000000000000000000000000;;		getOutKind reflect.Kind
0000000000000000000000000000000000000000;;		outError   error
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// New creates a new json pointer for the given string
0000000000000000000000000000000000000000;;	func New(jsonPointerString string) (Pointer, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var p Pointer
0000000000000000000000000000000000000000;;		err := p.parse(jsonPointerString)
0000000000000000000000000000000000000000;;		return p, err
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pointer the json pointer reprsentation
0000000000000000000000000000000000000000;;	type Pointer struct {
0000000000000000000000000000000000000000;;		referenceTokens []string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// "Constructor", parses the given string JSON pointer
0000000000000000000000000000000000000000;;	func (p *Pointer) parse(jsonPointerString string) error {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if jsonPointerString != emptyPointer {
0000000000000000000000000000000000000000;;			if !strings.HasPrefix(jsonPointerString, pointerSeparator) {
0000000000000000000000000000000000000000;;				err = errors.New(invalidStart)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				referenceTokens := strings.Split(jsonPointerString, pointerSeparator)
0000000000000000000000000000000000000000;;				for _, referenceToken := range referenceTokens[1:] {
0000000000000000000000000000000000000000;;					p.referenceTokens = append(p.referenceTokens, referenceToken)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get uses the pointer to retrieve a value from a JSON document
0000000000000000000000000000000000000000;;	func (p *Pointer) Get(document interface{}) (interface{}, reflect.Kind, error) {
0000000000000000000000000000000000000000;;		return p.get(document, swag.DefaultJSONNameProvider)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetForToken gets a value for a json pointer token 1 level deep
0000000000000000000000000000000000000000;;	func GetForToken(document interface{}, decodedToken string) (interface{}, reflect.Kind, error) {
0000000000000000000000000000000000000000;;		return getSingleImpl(document, decodedToken, swag.DefaultJSONNameProvider)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getSingleImpl(node interface{}, decodedToken string, nameProvider *swag.NameProvider) (interface{}, reflect.Kind, error) {
0000000000000000000000000000000000000000;;		kind := reflect.Invalid
0000000000000000000000000000000000000000;;		rValue := reflect.Indirect(reflect.ValueOf(node))
0000000000000000000000000000000000000000;;		kind = rValue.Kind()
0000000000000000000000000000000000000000;;		switch kind {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if rValue.Type().Implements(jsonPointableType) {
0000000000000000000000000000000000000000;;				r, err := node.(JSONPointable).JSONLookup(decodedToken)
0000000000000000000000000000000000000000;;				if err != nil {
0000000000000000000000000000000000000000;;					return nil, kind, err
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return r, kind, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			nm, ok := nameProvider.GetGoNameForType(rValue.Type(), decodedToken)
0000000000000000000000000000000000000000;;			if !ok {
0000000000000000000000000000000000000000;;				return nil, kind, fmt.Errorf("object has no field %q", decodedToken)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			fld := rValue.FieldByName(nm)
0000000000000000000000000000000000000000;;			return fld.Interface(), kind, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			kv := reflect.ValueOf(decodedToken)
0000000000000000000000000000000000000000;;			mv := rValue.MapIndex(kv)
0000000000000000000000000000000000000000;;			if mv.IsValid() && !swag.IsZero(mv) {
0000000000000000000000000000000000000000;;				return mv.Interface(), kind, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, kind, fmt.Errorf("object has no key %q", decodedToken)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			tokenIndex, err := strconv.Atoi(decodedToken)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, kind, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			sLength := rValue.Len()
0000000000000000000000000000000000000000;;			if tokenIndex < 0 || tokenIndex >= sLength {
0000000000000000000000000000000000000000;;				return nil, kind, fmt.Errorf("index out of bounds array[0,%d] index '%d'", sLength, tokenIndex)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			elem := rValue.Index(tokenIndex)
0000000000000000000000000000000000000000;;			return elem.Interface(), kind, nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return nil, kind, fmt.Errorf("invalid token reference %q", decodedToken)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (p *Pointer) get(node interface{}, nameProvider *swag.NameProvider) (interface{}, reflect.Kind, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if nameProvider == nil {
0000000000000000000000000000000000000000;;			nameProvider = swag.DefaultJSONNameProvider
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		kind := reflect.Invalid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Full document when empty
0000000000000000000000000000000000000000;;		if len(p.referenceTokens) == 0 {
0000000000000000000000000000000000000000;;			return node, kind, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, token := range p.referenceTokens {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			decodedToken := Unescape(token)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			r, knd, err := getSingleImpl(node, decodedToken, nameProvider)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, knd, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			node, kind = r, knd
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		rValue := reflect.ValueOf(node)
0000000000000000000000000000000000000000;;		kind = rValue.Kind()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return node, kind, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DecodedTokens returns the decoded tokens
0000000000000000000000000000000000000000;;	func (p *Pointer) DecodedTokens() []string {
0000000000000000000000000000000000000000;;		result := make([]string, 0, len(p.referenceTokens))
0000000000000000000000000000000000000000;;		for _, t := range p.referenceTokens {
0000000000000000000000000000000000000000;;			result = append(result, Unescape(t))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if this is an empty json pointer
0000000000000000000000000000000000000000;;	// this indicates that it points to the root document
0000000000000000000000000000000000000000;;	func (p *Pointer) IsEmpty() bool {
0000000000000000000000000000000000000000;;		return len(p.referenceTokens) == 0
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Pointer to string representation function
0000000000000000000000000000000000000000;;	func (p *Pointer) String() string {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(p.referenceTokens) == 0 {
0000000000000000000000000000000000000000;;			return emptyPointer
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		pointerString := pointerSeparator + strings.Join(p.referenceTokens, pointerSeparator)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pointerString
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Specific JSON pointer encoding here
0000000000000000000000000000000000000000;;	// ~0 => ~
0000000000000000000000000000000000000000;;	// ~1 => /
0000000000000000000000000000000000000000;;	// ... and vice versa
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		encRefTok0 = `~0`
0000000000000000000000000000000000000000;;		encRefTok1 = `~1`
0000000000000000000000000000000000000000;;		decRefTok0 = `~`
0000000000000000000000000000000000000000;;		decRefTok1 = `/`
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Unescape unescapes a json pointer reference token string to the original representation
0000000000000000000000000000000000000000;;	func Unescape(token string) string {
0000000000000000000000000000000000000000;;		step1 := strings.Replace(token, encRefTok1, decRefTok1, -1)
0000000000000000000000000000000000000000;;		step2 := strings.Replace(step1, encRefTok0, decRefTok0, -1)
0000000000000000000000000000000000000000;;		return step2
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Escape escapes a pointer reference token string
0000000000000000000000000000000000000000;;	func Escape(token string) string {
0000000000000000000000000000000000000000;;		step1 := strings.Replace(token, decRefTok0, encRefTok0, -1)
0000000000000000000000000000000000000000;;		step2 := strings.Replace(step1, decRefTok1, encRefTok1, -1)
0000000000000000000000000000000000000000;;		return step2
0000000000000000000000000000000000000000;;	}
