0000000000000000000000000000000000000000;;	// Copyright 2011 Google Inc.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
268e3120b2e4a7425b04801561b9aaf732ed6369;third_party/src/code.google.com/p/go-uuid/uuid/util.go[third_party/src/code.google.com/p/go-uuid/uuid/util.go][vendor/github.com/pborman/uuid/util.go];	
0000000000000000000000000000000000000000;;	package uuid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// randomBits completely fills slice b with random data.
0000000000000000000000000000000000000000;;	func randomBits(b []byte) {
0000000000000000000000000000000000000000;;		if _, err := io.ReadFull(rander, b); err != nil {
0000000000000000000000000000000000000000;;			panic(err.Error()) // rand should never fail
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// xvalues returns the value of a byte as a hexadecimal digit or 255.
0000000000000000000000000000000000000000;;	var xvalues = []byte{
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 10, 11, 12, 13, 14, 15, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;		255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// xtob converts the the first two hex bytes of x into a byte.
0000000000000000000000000000000000000000;;	func xtob(x string) (byte, bool) {
0000000000000000000000000000000000000000;;		b1 := xvalues[x[0]]
0000000000000000000000000000000000000000;;		b2 := xvalues[x[1]]
0000000000000000000000000000000000000000;;		return (b1 << 4) | b2, b1 != 255 && b2 != 255
0000000000000000000000000000000000000000;;	}
