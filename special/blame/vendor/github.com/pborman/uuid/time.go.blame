0000000000000000000000000000000000000000;;	// Copyright 2014 Google Inc.  All rights reserved.
0000000000000000000000000000000000000000;;	// Use of this source code is governed by a BSD-style
0000000000000000000000000000000000000000;;	// license that can be found in the LICENSE file.
268e3120b2e4a7425b04801561b9aaf732ed6369;third_party/src/code.google.com/p/go-uuid/uuid/time.go[third_party/src/code.google.com/p/go-uuid/uuid/time.go][vendor/github.com/pborman/uuid/time.go];	
0000000000000000000000000000000000000000;;	package uuid
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/binary"
0000000000000000000000000000000000000000;;		"sync"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// A Time represents a time as the number of 100's of nanoseconds since 15 Oct
0000000000000000000000000000000000000000;;	// 1582.
0000000000000000000000000000000000000000;;	type Time int64
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		lillian    = 2299160          // Julian day of 15 Oct 1582
0000000000000000000000000000000000000000;;		unix       = 2440587          // Julian day of 1 Jan 1970
0000000000000000000000000000000000000000;;		epoch      = unix - lillian   // Days between epochs
0000000000000000000000000000000000000000;;		g1582      = epoch * 86400    // seconds between epochs
0000000000000000000000000000000000000000;;		g1582ns100 = g1582 * 10000000 // 100s of a nanoseconds between epochs
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		mu        sync.Mutex
0000000000000000000000000000000000000000;;		lasttime  uint64 // last time we returned
0000000000000000000000000000000000000000;;		clock_seq uint16 // clock sequence for this run
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		timeNow = time.Now // for testing
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UnixTime converts t the number of seconds and nanoseconds using the Unix
0000000000000000000000000000000000000000;;	// epoch of 1 Jan 1970.
0000000000000000000000000000000000000000;;	func (t Time) UnixTime() (sec, nsec int64) {
0000000000000000000000000000000000000000;;		sec = int64(t - g1582ns100)
0000000000000000000000000000000000000000;;		nsec = (sec % 10000000) * 100
0000000000000000000000000000000000000000;;		sec /= 10000000
0000000000000000000000000000000000000000;;		return sec, nsec
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetTime returns the current Time (100s of nanoseconds since 15 Oct 1582) and
0000000000000000000000000000000000000000;;	// clock sequence as well as adjusting the clock sequence as needed.  An error
0000000000000000000000000000000000000000;;	// is returned if the current time cannot be determined.
0000000000000000000000000000000000000000;;	func GetTime() (Time, uint16, error) {
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		return getTime()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func getTime() (Time, uint16, error) {
0000000000000000000000000000000000000000;;		t := timeNow()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If we don't have a clock sequence already, set one.
0000000000000000000000000000000000000000;;		if clock_seq == 0 {
0000000000000000000000000000000000000000;;			setClockSequence(-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		now := uint64(t.UnixNano()/100) + g1582ns100
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If time has gone backwards with this clock sequence then we
0000000000000000000000000000000000000000;;		// increment the clock sequence
0000000000000000000000000000000000000000;;		if now <= lasttime {
0000000000000000000000000000000000000000;;			clock_seq = ((clock_seq + 1) & 0x3fff) | 0x8000
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		lasttime = now
0000000000000000000000000000000000000000;;		return Time(now), clock_seq, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClockSequence returns the current clock sequence, generating one if not
0000000000000000000000000000000000000000;;	// already set.  The clock sequence is only used for Version 1 UUIDs.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// The uuid package does not use global static storage for the clock sequence or
0000000000000000000000000000000000000000;;	// the last time a UUID was generated.  Unless SetClockSequence a new random
0000000000000000000000000000000000000000;;	// clock sequence is generated the first time a clock sequence is requested by
0000000000000000000000000000000000000000;;	// ClockSequence, GetTime, or NewUUID.  (section 4.2.1.1) sequence is generated
0000000000000000000000000000000000000000;;	// for
0000000000000000000000000000000000000000;;	func ClockSequence() int {
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		return clockSequence()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func clockSequence() int {
0000000000000000000000000000000000000000;;		if clock_seq == 0 {
0000000000000000000000000000000000000000;;			setClockSequence(-1)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(clock_seq & 0x3fff)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// SetClockSeq sets the clock sequence to the lower 14 bits of seq.  Setting to
0000000000000000000000000000000000000000;;	// -1 causes a new sequence to be generated.
0000000000000000000000000000000000000000;;	func SetClockSequence(seq int) {
0000000000000000000000000000000000000000;;		defer mu.Unlock()
0000000000000000000000000000000000000000;;		mu.Lock()
0000000000000000000000000000000000000000;;		setClockSequence(seq)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func setClockSequence(seq int) {
0000000000000000000000000000000000000000;;		if seq == -1 {
0000000000000000000000000000000000000000;;			var b [2]byte
0000000000000000000000000000000000000000;;			randomBits(b[:]) // clock sequence
0000000000000000000000000000000000000000;;			seq = int(b[0])<<8 | int(b[1])
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		old_seq := clock_seq
0000000000000000000000000000000000000000;;		clock_seq = uint16(seq&0x3fff) | 0x8000 // Set our variant
0000000000000000000000000000000000000000;;		if old_seq != clock_seq {
0000000000000000000000000000000000000000;;			lasttime = 0
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Time returns the time in 100s of nanoseconds since 15 Oct 1582 encoded in
0000000000000000000000000000000000000000;;	// uuid.  It returns false if uuid is not valid.  The time is only well defined
0000000000000000000000000000000000000000;;	// for version 1 and 2 UUIDs.
0000000000000000000000000000000000000000;;	func (uuid UUID) Time() (Time, bool) {
0000000000000000000000000000000000000000;;		if len(uuid) != 16 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		time := int64(binary.BigEndian.Uint32(uuid[0:4]))
0000000000000000000000000000000000000000;;		time |= int64(binary.BigEndian.Uint16(uuid[4:6])) << 32
0000000000000000000000000000000000000000;;		time |= int64(binary.BigEndian.Uint16(uuid[6:8])&0xfff) << 48
0000000000000000000000000000000000000000;;		return Time(time), true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ClockSequence returns the clock sequence encoded in uuid.  It returns false
0000000000000000000000000000000000000000;;	// if uuid is not valid.  The clock sequence is only well defined for version 1
0000000000000000000000000000000000000000;;	// and 2 UUIDs.
0000000000000000000000000000000000000000;;	func (uuid UUID) ClockSequence() (int, bool) {
0000000000000000000000000000000000000000;;		if len(uuid) != 16 {
0000000000000000000000000000000000000000;;			return 0, false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return int(binary.BigEndian.Uint16(uuid[8:10])) & 0x3fff, true
0000000000000000000000000000000000000000;;	}
