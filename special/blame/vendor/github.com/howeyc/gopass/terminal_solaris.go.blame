0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	 * CDDL HEADER START
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * The contents of this file are subject to the terms of the
0000000000000000000000000000000000000000;;	 * Common Development and Distribution License, Version 1.0 only
0000000000000000000000000000000000000000;;	 * (the "License").  You may not use this file except in compliance
0000000000000000000000000000000000000000;;	 * with the License.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
0000000000000000000000000000000000000000;;	 * or http://www.opensolaris.org/os/licensing.
0000000000000000000000000000000000000000;;	 * See the License for the specific language governing permissions
0000000000000000000000000000000000000000;;	 * and limitations under the License.
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * When distributing Covered Code, include this CDDL HEADER in each
0000000000000000000000000000000000000000;;	 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
0000000000000000000000000000000000000000;;	 * If applicable, add the following below this CDDL HEADER, with the
0000000000000000000000000000000000000000;;	 * fields enclosed by brackets "[]" replaced with your own identifying
0000000000000000000000000000000000000000;;	 * information: Portions Copyright [yyyy] [name of copyright owner]
0000000000000000000000000000000000000000;;	 *
0000000000000000000000000000000000000000;;	 * CDDL HEADER END
0000000000000000000000000000000000000000;;	 */
0000000000000000000000000000000000000000;;	// Below is derived from Solaris source, so CDDL license is included.
fd67f7b54069fd4e3fd5dcc2238cb8c3266f5202;;	
0000000000000000000000000000000000000000;;	package gopass
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"syscall"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"golang.org/x/sys/unix"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type terminalState struct {
0000000000000000000000000000000000000000;;		state *unix.Termios
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isTerminal returns true if there is a terminal attached to the given
0000000000000000000000000000000000000000;;	// file descriptor.
0000000000000000000000000000000000000000;;	// Source: http://src.illumos.org/source/xref/illumos-gate/usr/src/lib/libbc/libc/gen/common/isatty.c
0000000000000000000000000000000000000000;;	func isTerminal(fd uintptr) bool {
0000000000000000000000000000000000000000;;		var termio unix.Termio
0000000000000000000000000000000000000000;;		err := unix.IoctlSetTermio(int(fd), unix.TCGETA, &termio)
0000000000000000000000000000000000000000;;		return err == nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// makeRaw puts the terminal connected to the given file descriptor into raw
0000000000000000000000000000000000000000;;	// mode and returns the previous state of the terminal so that it can be
0000000000000000000000000000000000000000;;	// restored.
0000000000000000000000000000000000000000;;	// Source: http://src.illumos.org/source/xref/illumos-gate/usr/src/lib/libast/common/uwin/getpass.c
0000000000000000000000000000000000000000;;	func makeRaw(fd uintptr) (*terminalState, error) {
0000000000000000000000000000000000000000;;		oldTermiosPtr, err := unix.IoctlGetTermios(int(fd), unix.TCGETS)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		oldTermios := *oldTermiosPtr
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		newTermios := oldTermios
0000000000000000000000000000000000000000;;		newTermios.Lflag &^= syscall.ECHO | syscall.ECHOE | syscall.ECHOK | syscall.ECHONL
0000000000000000000000000000000000000000;;		if err := unix.IoctlSetTermios(int(fd), unix.TCSETS, &newTermios); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &terminalState{
0000000000000000000000000000000000000000;;			state: oldTermiosPtr,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func restore(fd uintptr, oldState *terminalState) error {
0000000000000000000000000000000000000000;;		return unix.IoctlSetTermios(int(fd), unix.TCSETS, oldState.state)
0000000000000000000000000000000000000000;;	}
