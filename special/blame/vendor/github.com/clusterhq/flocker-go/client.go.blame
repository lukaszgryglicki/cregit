0000000000000000000000000000000000000000;;	package flocker
52aca6320194613121f2976fe3fd02df58abf14d;Godeps/_workspace/src/github.com/ClusterHQ/flocker-go/client.go[Godeps/_workspace/src/github.com/ClusterHQ/flocker-go/client.go][vendor/github.com/clusterhq/flocker-go/client.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"io"
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// From https://github.com/ClusterHQ/flocker-docker-plugin/blob/master/flockerdockerplugin/adapter.py#L18
0000000000000000000000000000000000000000;;	const defaultVolumeSize = json.Number("107374182400")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		// A volume can take a long time to be available, if we don't want
0000000000000000000000000000000000000000;;		// Kubernetes to wait forever we need to stop trying after some time, that
0000000000000000000000000000000000000000;;		// time is defined here
0000000000000000000000000000000000000000;;		timeoutWaitingForVolume = 2 * time.Minute
0000000000000000000000000000000000000000;;		tickerWaitingForVolume  = 5 * time.Second
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errStateNotFound         = errors.New("State not found by Dataset ID")
0000000000000000000000000000000000000000;;		errConfigurationNotFound = errors.New("Configuration not found by Name")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errFlockerControlServiceHost = errors.New("The volume config must have a key CONTROL_SERVICE_HOST defined in the OtherAttributes field")
0000000000000000000000000000000000000000;;		errFlockerControlServicePort = errors.New("The volume config must have a key CONTROL_SERVICE_PORT defined in the OtherAttributes field")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errVolumeAlreadyExists = errors.New("The volume already exists")
0000000000000000000000000000000000000000;;		errVolumeDoesNotExist  = errors.New("The volume does not exist")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		errUpdatingDataset = errors.New("It was impossible to update the dataset")
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Clientable exposes the needed methods to implement your own Flocker Client.
0000000000000000000000000000000000000000;;	type Clientable interface {
0000000000000000000000000000000000000000;;		CreateDataset(options *CreateDatasetOptions) (*DatasetState, error)
0000000000000000000000000000000000000000;;		DeleteDataset(datasetID string) error
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		GetDatasetState(datasetID string) (*DatasetState, error)
0000000000000000000000000000000000000000;;		GetDatasetID(metaName string) (datasetID string, err error)
0000000000000000000000000000000000000000;;		GetPrimaryUUID() (primaryUUID string, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		ListNodes() (nodes []NodeState, err error)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		UpdatePrimaryForDataset(primaryUUID, datasetID string) (*DatasetState, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Client is a default Flocker Client.
0000000000000000000000000000000000000000;;	type Client struct {
0000000000000000000000000000000000000000;;		*http.Client
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		schema  string
0000000000000000000000000000000000000000;;		host    string
0000000000000000000000000000000000000000;;		port    int
0000000000000000000000000000000000000000;;		version string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		clientIP string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		maximumSize json.Number
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var _ Clientable = &Client{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NewClient creates a wrapper over http.Client to communicate with the flocker control service.
0000000000000000000000000000000000000000;;	func NewClient(host string, port int, clientIP string, caCertPath, keyPath, certPath string) (*Client, error) {
0000000000000000000000000000000000000000;;		client, err := newTLSClient(caCertPath, keyPath, certPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Client{
0000000000000000000000000000000000000000;;			Client:      client,
0000000000000000000000000000000000000000;;			schema:      "https",
0000000000000000000000000000000000000000;;			host:        host,
0000000000000000000000000000000000000000;;			port:        port,
0000000000000000000000000000000000000000;;			version:     "v1",
0000000000000000000000000000000000000000;;			maximumSize: defaultVolumeSize,
0000000000000000000000000000000000000000;;			clientIP:    clientIP,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	request do a request using the http.Client embedded to the control service
0000000000000000000000000000000000000000;;	and returns the response or an error in case it happens.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Note: you will need to deal with the response body call to Close if you
0000000000000000000000000000000000000000;;	don't want to deal with problems later.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (c Client) request(method, url string, payload interface{}) (*http.Response, error) {
0000000000000000000000000000000000000000;;		var (
0000000000000000000000000000000000000000;;			b   []byte
0000000000000000000000000000000000000000;;			err error
0000000000000000000000000000000000000000;;		)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if method == "POST" { // Just allow payload on POST
0000000000000000000000000000000000000000;;			b, err = json.Marshal(payload)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req, err := http.NewRequest(method, url, bytes.NewBuffer(b))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		req.Header.Set("Content-Type", "application/json")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// REMEMBER TO CLOSE THE BODY IN THE OUTSIDE FUNCTION
0000000000000000000000000000000000000000;;		return c.Do(req)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// post performs a post request with the indicated payload
0000000000000000000000000000000000000000;;	func (c Client) post(url string, payload interface{}) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return c.request("POST", url, payload)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// delete performs a delete request with the indicated payload
0000000000000000000000000000000000000000;;	func (c Client) delete(url string, payload interface{}) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return c.request("DELETE", url, payload)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// get performs a get request
0000000000000000000000000000000000000000;;	func (c Client) get(url string) (*http.Response, error) {
0000000000000000000000000000000000000000;;		return c.request("GET", url, nil)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// getURL returns a full URI to the control service
0000000000000000000000000000000000000000;;	func (c Client) getURL(path string) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s://%s:%d/%s/%s", c.schema, c.host, c.port, c.version, path)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type configurationPayload struct {
0000000000000000000000000000000000000000;;		Deleted     bool            `json:"deleted"`
0000000000000000000000000000000000000000;;		Primary     string          `json:"primary"`
0000000000000000000000000000000000000000;;		DatasetID   string          `json:"dataset_id,omitempty"`
0000000000000000000000000000000000000000;;		MaximumSize json.Number     `json:"maximum_size,omitempty"`
0000000000000000000000000000000000000000;;		Metadata    metadataPayload `json:"metadata,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateDatasetOptions struct {
0000000000000000000000000000000000000000;;		Primary     string            `json:"primary"`
0000000000000000000000000000000000000000;;		DatasetID   string            `json:"dataset_id,omitempty"`
0000000000000000000000000000000000000000;;		MaximumSize int64             `json:"maximum_size,omitempty"`
0000000000000000000000000000000000000000;;		Metadata    map[string]string `json:"metadata,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type metadataPayload struct {
0000000000000000000000000000000000000000;;		Name string `json:"name,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type DatasetState struct {
0000000000000000000000000000000000000000;;		Path        string      `json:"path"`
0000000000000000000000000000000000000000;;		DatasetID   string      `json:"dataset_id"`
0000000000000000000000000000000000000000;;		Primary     string      `json:"primary,omitempty"`
0000000000000000000000000000000000000000;;		MaximumSize json.Number `json:"maximum_size,omitempty"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type datasetStatePayload struct {
0000000000000000000000000000000000000000;;		*DatasetState
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type NodeState struct {
0000000000000000000000000000000000000000;;		UUID string `json:"uuid"`
0000000000000000000000000000000000000000;;		Host string `json:"host"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// findIDInConfigurationsPayload returns the datasetID if it was found in the
0000000000000000000000000000000000000000;;	// configurations payload, otherwise it will return an error.
0000000000000000000000000000000000000000;;	func (c Client) findIDInConfigurationsPayload(body io.ReadCloser, name string) (datasetID string, err error) {
0000000000000000000000000000000000000000;;		var configurations []configurationPayload
0000000000000000000000000000000000000000;;		if err = json.NewDecoder(body).Decode(&configurations); err == nil {
0000000000000000000000000000000000000000;;			for _, r := range configurations {
0000000000000000000000000000000000000000;;				if r.Metadata.Name == name {
0000000000000000000000000000000000000000;;					return r.DatasetID, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", errConfigurationNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListNodes returns a list of dataset agent nodes from Flocker Control Service
0000000000000000000000000000000000000000;;	func (c *Client) ListNodes() (nodes []NodeState, err error) {
0000000000000000000000000000000000000000;;		resp, err := c.get(c.getURL("state/nodes"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []NodeState{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			return []NodeState{}, fmt.Errorf("Expected: {1,2}xx listing nodes, got: %d", resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = json.NewDecoder(resp.Body).Decode(&nodes)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return []NodeState{}, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nodes, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPrimaryUUID returns the UUID of the primary Flocker Control Service for
0000000000000000000000000000000000000000;;	// the given host.
0000000000000000000000000000000000000000;;	func (c Client) GetPrimaryUUID() (uuid string, err error) {
0000000000000000000000000000000000000000;;		states, err := c.ListNodes()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for _, s := range states {
0000000000000000000000000000000000000000;;			if s.Host == c.clientIP {
0000000000000000000000000000000000000000;;				return s.UUID, nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", fmt.Errorf("No node found with IP '%s', available nodes %+v", c.clientIP, states)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteDataset performs a delete request to the given datasetID
0000000000000000000000000000000000000000;;	func (c *Client) DeleteDataset(datasetID string) error {
0000000000000000000000000000000000000000;;		url := c.getURL(fmt.Sprintf("configuration/datasets/%s", datasetID))
0000000000000000000000000000000000000000;;		resp, err := c.delete(url, nil)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			return fmt.Errorf("Expected: {1,2}xx deleting the dataset %s, got: %d", datasetID, resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDatasetState performs a get request to get the state of the given datasetID, if
0000000000000000000000000000000000000000;;	// something goes wrong or the datasetID was not found it returns an error.
0000000000000000000000000000000000000000;;	func (c Client) GetDatasetState(datasetID string) (*DatasetState, error) {
0000000000000000000000000000000000000000;;		resp, err := c.get(c.getURL("state/datasets"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var states []datasetStatePayload
0000000000000000000000000000000000000000;;		if err = json.NewDecoder(resp.Body).Decode(&states); err == nil {
0000000000000000000000000000000000000000;;			for _, s := range states {
0000000000000000000000000000000000000000;;				if s.DatasetID == datasetID {
0000000000000000000000000000000000000000;;					return s.DatasetState, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return nil, errStateNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return nil, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	CreateDataset creates a volume in Flocker, waits for it to be ready and
0000000000000000000000000000000000000000;;	returns the dataset id.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	This process is a little bit complex but follows this flow:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	1. Find the Flocker Control Service UUID
0000000000000000000000000000000000000000;;	2. If it already exists an error is returned
0000000000000000000000000000000000000000;;	3. If it didn't previously exist, wait for it to be ready
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func (c *Client) CreateDataset(options *CreateDatasetOptions) (datasetState *DatasetState, err error) {
0000000000000000000000000000000000000000;;		// 1) Find the primary Flocker UUID
0000000000000000000000000000000000000000;;		// Note: it could be cached, but doing this query we health check it
0000000000000000000000000000000000000000;;		if options.Primary == "" {
0000000000000000000000000000000000000000;;			options.Primary, err = c.GetPrimaryUUID()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.MaximumSize == 0 {
0000000000000000000000000000000000000000;;			options.MaximumSize, _ = c.maximumSize.Int64()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		resp, err := c.post(c.getURL("configuration/datasets"), options)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 2) Return if the dataset was previously created
0000000000000000000000000000000000000000;;		if resp.StatusCode == http.StatusConflict {
0000000000000000000000000000000000000000;;			return nil, errVolumeAlreadyExists
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Expected: {1,2}xx creating the volume, got: %d", resp.StatusCode)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var p configurationPayload
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&p); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// 3) Wait until the dataset is ready for usage. In case it never gets
0000000000000000000000000000000000000000;;		// ready there is a timeoutChan that will return an error
0000000000000000000000000000000000000000;;		timeoutChan := time.NewTimer(timeoutWaitingForVolume).C
0000000000000000000000000000000000000000;;		tickChan := time.NewTicker(tickerWaitingForVolume).C
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			var strErrDel string
0000000000000000000000000000000000000000;;			s, err := c.GetDatasetState(p.DatasetID)
0000000000000000000000000000000000000000;;			if err == nil {
0000000000000000000000000000000000000000;;				return s, nil
0000000000000000000000000000000000000000;;			} else if err != errStateNotFound {
0000000000000000000000000000000000000000;;				errDel := c.DeleteDataset(p.DatasetID)
0000000000000000000000000000000000000000;;				if errDel != nil {
0000000000000000000000000000000000000000;;					strErrDel = fmt.Sprintf(", deletion of dataset failed with %s", errDel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Flocker API error during dataset creation (datasetID %s): %s%s", p.DatasetID, err, strErrDel)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			select {
0000000000000000000000000000000000000000;;			case <-timeoutChan:
0000000000000000000000000000000000000000;;				errDel := c.DeleteDataset(p.DatasetID)
0000000000000000000000000000000000000000;;				if errDel != nil {
0000000000000000000000000000000000000000;;					strErrDel = fmt.Sprintf(", deletion of dataset failed with %s", errDel)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return nil, fmt.Errorf("Flocker API timeout during dataset creation (datasetID %s): %s%s", p.DatasetID, err, strErrDel)
0000000000000000000000000000000000000000;;			case <-tickChan:
0000000000000000000000000000000000000000;;				break
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdatePrimaryForDataset will update the Primary for the given dataset
0000000000000000000000000000000000000000;;	// returning the current DatasetState.
0000000000000000000000000000000000000000;;	func (c Client) UpdatePrimaryForDataset(newPrimaryUUID, datasetID string) (*DatasetState, error) {
0000000000000000000000000000000000000000;;		payload := struct {
0000000000000000000000000000000000000000;;			Primary string `json:"primary"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Primary: newPrimaryUUID,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		url := c.getURL(fmt.Sprintf("configuration/datasets/%s", datasetID))
0000000000000000000000000000000000000000;;		resp, err := c.post(url, payload)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if resp.StatusCode >= 300 {
0000000000000000000000000000000000000000;;			return nil, errUpdatingDataset
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var s DatasetState
0000000000000000000000000000000000000000;;		if err := json.NewDecoder(resp.Body).Decode(&s); err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &s, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetDatasetID will return the DatasetID found for the given metadata name.
0000000000000000000000000000000000000000;;	func (c Client) GetDatasetID(metaName string) (datasetID string, err error) {
0000000000000000000000000000000000000000;;		resp, err := c.get(c.getURL("configuration/datasets"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		defer resp.Body.Close()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var configurations []configurationPayload
0000000000000000000000000000000000000000;;		if err = json.NewDecoder(resp.Body).Decode(&configurations); err == nil {
0000000000000000000000000000000000000000;;			for _, c := range configurations {
0000000000000000000000000000000000000000;;				if c.Metadata.Name == metaName && c.Deleted == false {
0000000000000000000000000000000000000000;;					return c.DatasetID, nil
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return "", errConfigurationNotFound
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return "", err
0000000000000000000000000000000000000000;;	}
