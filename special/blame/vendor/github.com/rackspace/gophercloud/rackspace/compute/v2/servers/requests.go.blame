0000000000000000000000000000000000000000;;	package servers
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/rackspace/compute/v2/servers/requests.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/rackspace/compute/v2/servers/requests.go][vendor/github.com/rackspace/gophercloud/rackspace/compute/v2/servers/requests.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/openstack/compute/v2/extensions/bootfromvolume"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/openstack/compute/v2/extensions/diskconfig"
0000000000000000000000000000000000000000;;		os "github.com/rackspace/gophercloud/openstack/compute/v2/servers"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOpts specifies all of the options that Rackspace accepts in its Create request, including
0000000000000000000000000000000000000000;;	// the union of all extensions that Rackspace supports.
0000000000000000000000000000000000000000;;	type CreateOpts struct {
0000000000000000000000000000000000000000;;		// Name [required] is the name to assign to the newly launched server.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImageRef [optional; required if ImageName is not provided] is the ID or full
0000000000000000000000000000000000000000;;		// URL to the image that contains the server's OS and initial state.
0000000000000000000000000000000000000000;;		// Also optional if using the boot-from-volume extension.
0000000000000000000000000000000000000000;;		ImageRef string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImageName [optional; required if ImageRef is not provided] is the name of the
0000000000000000000000000000000000000000;;		// image that contains the server's OS and initial state.
0000000000000000000000000000000000000000;;		// Also optional if using the boot-from-volume extension.
0000000000000000000000000000000000000000;;		ImageName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FlavorRef [optional; required if FlavorName is not provided] is the ID or
0000000000000000000000000000000000000000;;		// full URL to the flavor that describes the server's specs.
0000000000000000000000000000000000000000;;		FlavorRef string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FlavorName [optional; required if FlavorRef is not provided] is the name of
0000000000000000000000000000000000000000;;		// the flavor that describes the server's specs.
0000000000000000000000000000000000000000;;		FlavorName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecurityGroups [optional] lists the names of the security groups to which this server should belong.
0000000000000000000000000000000000000000;;		SecurityGroups []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserData [optional] contains configuration information or scripts to use upon launch.
0000000000000000000000000000000000000000;;		// Create will base64-encode it for you.
0000000000000000000000000000000000000000;;		UserData []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AvailabilityZone [optional] in which to launch the server.
0000000000000000000000000000000000000000;;		AvailabilityZone string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Networks [optional] dictates how this server will be attached to available networks.
0000000000000000000000000000000000000000;;		// By default, the server will be attached to all isolated networks for the tenant.
0000000000000000000000000000000000000000;;		Networks []os.Network
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata [optional] contains key-value pairs (up to 255 bytes each) to attach to the server.
0000000000000000000000000000000000000000;;		Metadata map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Personality [optional] includes files to inject into the server at launch.
0000000000000000000000000000000000000000;;		// Create will base64-encode file contents for you.
0000000000000000000000000000000000000000;;		Personality os.Personality
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConfigDrive [optional] enables metadata injection through a configuration drive.
0000000000000000000000000000000000000000;;		ConfigDrive bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AdminPass [optional] sets the root user password. If not set, a randomly-generated
0000000000000000000000000000000000000000;;		// password will be created and returned in the response.
0000000000000000000000000000000000000000;;		AdminPass string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rackspace-specific extensions begin here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyPair [optional] specifies the name of the SSH KeyPair to be injected into the newly launched
0000000000000000000000000000000000000000;;		// server. See the "keypairs" extension in OpenStack compute v2.
0000000000000000000000000000000000000000;;		KeyPair string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DiskConfig [optional] controls how the created server's disk is partitioned. See the "diskconfig"
0000000000000000000000000000000000000000;;		// extension in OpenStack compute v2.
0000000000000000000000000000000000000000;;		DiskConfig diskconfig.DiskConfig
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// BlockDevice [optional] will create the server from a volume, which is created from an image,
0000000000000000000000000000000000000000;;		// a snapshot, or another volume.
0000000000000000000000000000000000000000;;		BlockDevice []bootfromvolume.BlockDevice
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerCreateMap constructs a request body using all of the OpenStack extensions that are
0000000000000000000000000000000000000000;;	// active on Rackspace.
0000000000000000000000000000000000000000;;	func (opts CreateOpts) ToServerCreateMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		base := os.CreateOpts{
0000000000000000000000000000000000000000;;			Name:             opts.Name,
0000000000000000000000000000000000000000;;			ImageRef:         opts.ImageRef,
0000000000000000000000000000000000000000;;			ImageName:        opts.ImageName,
0000000000000000000000000000000000000000;;			FlavorRef:        opts.FlavorRef,
0000000000000000000000000000000000000000;;			FlavorName:       opts.FlavorName,
0000000000000000000000000000000000000000;;			SecurityGroups:   opts.SecurityGroups,
0000000000000000000000000000000000000000;;			UserData:         opts.UserData,
0000000000000000000000000000000000000000;;			AvailabilityZone: opts.AvailabilityZone,
0000000000000000000000000000000000000000;;			Networks:         opts.Networks,
0000000000000000000000000000000000000000;;			Metadata:         opts.Metadata,
0000000000000000000000000000000000000000;;			Personality:      opts.Personality,
0000000000000000000000000000000000000000;;			ConfigDrive:      opts.ConfigDrive,
0000000000000000000000000000000000000000;;			AdminPass:        opts.AdminPass,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		drive := diskconfig.CreateOptsExt{
0000000000000000000000000000000000000000;;			CreateOptsBuilder: base,
0000000000000000000000000000000000000000;;			DiskConfig:        opts.DiskConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		res, err := drive.ToServerCreateMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(opts.BlockDevice) != 0 {
0000000000000000000000000000000000000000;;			bfv := bootfromvolume.CreateOptsExt{
0000000000000000000000000000000000000000;;				CreateOptsBuilder: drive,
0000000000000000000000000000000000000000;;				BlockDevice:       opts.BlockDevice,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			res, err = bfv.ToServerCreateMap()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return nil, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// key_name doesn't actually come from the extension (or at least isn't documented there) so
0000000000000000000000000000000000000000;;		// we need to add it manually.
0000000000000000000000000000000000000000;;		serverMap := res["server"].(map[string]interface{})
0000000000000000000000000000000000000000;;		if opts.KeyPair != "" {
0000000000000000000000000000000000000000;;			serverMap["key_name"] = opts.KeyPair
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return res, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RebuildOpts represents all of the configuration options used in a server rebuild operation that
0000000000000000000000000000000000000000;;	// are supported by Rackspace.
0000000000000000000000000000000000000000;;	type RebuildOpts struct {
0000000000000000000000000000000000000000;;		// Required. The ID of the image you want your server to be provisioned on
0000000000000000000000000000000000000000;;		ImageID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name to set the server to
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Required. The server's admin password
0000000000000000000000000000000000000000;;		AdminPass string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv4 [optional] provides a new IPv4 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv4 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv6 [optional] provides a new IPv6 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv6 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata [optional] contains key-value pairs (up to 255 bytes each) to attach to the server.
0000000000000000000000000000000000000000;;		Metadata map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Personality [optional] includes files to inject into the server at launch.
0000000000000000000000000000000000000000;;		// Rebuild will base64-encode file contents for you.
0000000000000000000000000000000000000000;;		Personality os.Personality
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Rackspace-specific stuff begins here.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// DiskConfig [optional] controls how the created server's disk is partitioned. See the "diskconfig"
0000000000000000000000000000000000000000;;		// extension in OpenStack compute v2.
0000000000000000000000000000000000000000;;		DiskConfig diskconfig.DiskConfig
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerRebuildMap constructs a request body using all of the OpenStack extensions that are
0000000000000000000000000000000000000000;;	// active on Rackspace.
0000000000000000000000000000000000000000;;	func (opts RebuildOpts) ToServerRebuildMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		base := os.RebuildOpts{
0000000000000000000000000000000000000000;;			ImageID:     opts.ImageID,
0000000000000000000000000000000000000000;;			Name:        opts.Name,
0000000000000000000000000000000000000000;;			AdminPass:   opts.AdminPass,
0000000000000000000000000000000000000000;;			AccessIPv4:  opts.AccessIPv4,
0000000000000000000000000000000000000000;;			AccessIPv6:  opts.AccessIPv6,
0000000000000000000000000000000000000000;;			Metadata:    opts.Metadata,
0000000000000000000000000000000000000000;;			Personality: opts.Personality,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		drive := diskconfig.RebuildOptsExt{
0000000000000000000000000000000000000000;;			RebuildOptsBuilder: base,
0000000000000000000000000000000000000000;;			DiskConfig:         opts.DiskConfig,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return drive.ToServerRebuildMap()
0000000000000000000000000000000000000000;;	}
