0000000000000000000000000000000000000000;;	package gophercloud
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/params.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/params.go][vendor/github.com/rackspace/gophercloud/params.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"strconv"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// EnabledState is a convenience type, mostly used in Create and Update
0000000000000000000000000000000000000000;;	// operations. Because the zero value of a bool is FALSE, we need to use a
0000000000000000000000000000000000000000;;	// pointer instead to indicate zero-ness.
0000000000000000000000000000000000000000;;	type EnabledState *bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Convenience vars for EnabledState values.
0000000000000000000000000000000000000000;;	var (
0000000000000000000000000000000000000000;;		iTrue  = true
0000000000000000000000000000000000000000;;		iFalse = false
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		Enabled  EnabledState = &iTrue
0000000000000000000000000000000000000000;;		Disabled EnabledState = &iFalse
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntToPointer is a function for converting integers into integer pointers.
0000000000000000000000000000000000000000;;	// This is useful when passing in options to operations.
0000000000000000000000000000000000000000;;	func IntToPointer(i int) *int {
0000000000000000000000000000000000000000;;		return &i
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	MaybeString is an internal function to be used by request methods in individual
0000000000000000000000000000000000000000;;	resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It takes a string that might be a zero value and returns either a pointer to its
0000000000000000000000000000000000000000;;	address or nil. This is useful for allowing users to conveniently omit values
0000000000000000000000000000000000000000;;	from an options struct by leaving them zeroed, but still pass nil to the JSON
0000000000000000000000000000000000000000;;	serializer so they'll be omitted from the request body.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func MaybeString(original string) *string {
0000000000000000000000000000000000000000;;		if original != "" {
0000000000000000000000000000000000000000;;			return &original
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	MaybeInt is an internal function to be used by request methods in individual
0000000000000000000000000000000000000000;;	resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Like MaybeString, it accepts an int that may or may not be a zero value, and
0000000000000000000000000000000000000000;;	returns either a pointer to its address or nil. It's intended to hint that the
0000000000000000000000000000000000000000;;	JSON serializer should omit its field.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func MaybeInt(original int) *int {
0000000000000000000000000000000000000000;;		if original != 0 {
0000000000000000000000000000000000000000;;			return &original
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	var t time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isZero(v reflect.Value) bool {
0000000000000000000000000000000000000000;;		switch v.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Func, reflect.Map, reflect.Slice:
0000000000000000000000000000000000000000;;			return v.IsNil()
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			z := true
0000000000000000000000000000000000000000;;			for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;				z = z && isZero(v.Index(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return z
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			if v.Type() == reflect.TypeOf(t) {
0000000000000000000000000000000000000000;;				if v.Interface().(time.Time).IsZero() {
0000000000000000000000000000000000000000;;					return true
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				return false
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			z := true
0000000000000000000000000000000000000000;;			for i := 0; i < v.NumField(); i++ {
0000000000000000000000000000000000000000;;				z = z && isZero(v.Field(i))
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return z
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Compare other types directly:
0000000000000000000000000000000000000000;;		z := reflect.Zero(v.Type())
0000000000000000000000000000000000000000;;		return v.Interface() == z.Interface()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	BuildQueryString is an internal function to be used by request methods in
0000000000000000000000000000000000000000;;	individual resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It accepts a tagged structure and expands it into a URL struct. Field names are
0000000000000000000000000000000000000000;;	converted into query parameters based on a "q" tag. For example:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		type struct Something {
0000000000000000000000000000000000000000;;		   Bar string `q:"x_bar"`
0000000000000000000000000000000000000000;;		   Baz int    `q:"lorem_ipsum"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		instance := Something{
0000000000000000000000000000000000000000;;		   Bar: "AAA",
0000000000000000000000000000000000000000;;		   Baz: "BBB",
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	will be converted into "?x_bar=AAA&lorem_ipsum=BBB".
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	The struct's fields may be strings, integers, or boolean values. Fields left at
0000000000000000000000000000000000000000;;	their type's zero value will be omitted from the query.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func BuildQueryString(opts interface{}) (*url.URL, error) {
0000000000000000000000000000000000000000;;		optsValue := reflect.ValueOf(opts)
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsValue = optsValue.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsType := reflect.TypeOf(opts)
0000000000000000000000000000000000000000;;		if optsType.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsType = optsType.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		params := url.Values{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			for i := 0; i < optsValue.NumField(); i++ {
0000000000000000000000000000000000000000;;				v := optsValue.Field(i)
0000000000000000000000000000000000000000;;				f := optsType.Field(i)
0000000000000000000000000000000000000000;;				qTag := f.Tag.Get("q")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if the field has a 'q' tag, it goes in the query string
0000000000000000000000000000000000000000;;				if qTag != "" {
0000000000000000000000000000000000000000;;					tags := strings.Split(qTag, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// if the field is set, add it to the slice of query pieces
0000000000000000000000000000000000000000;;					if !isZero(v) {
0000000000000000000000000000000000000000;;						switch v.Kind() {
0000000000000000000000000000000000000000;;						case reflect.String:
0000000000000000000000000000000000000000;;							params.Add(tags[0], v.String())
0000000000000000000000000000000000000000;;						case reflect.Int:
0000000000000000000000000000000000000000;;							params.Add(tags[0], strconv.FormatInt(v.Int(), 10))
0000000000000000000000000000000000000000;;						case reflect.Bool:
0000000000000000000000000000000000000000;;							params.Add(tags[0], strconv.FormatBool(v.Bool()))
0000000000000000000000000000000000000000;;						case reflect.Slice:
0000000000000000000000000000000000000000;;							switch v.Type().Elem() {
0000000000000000000000000000000000000000;;							case reflect.TypeOf(0):
0000000000000000000000000000000000000000;;								for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;									params.Add(tags[0], strconv.FormatInt(v.Index(i).Int(), 10))
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							default:
0000000000000000000000000000000000000000;;								for i := 0; i < v.Len(); i++ {
0000000000000000000000000000000000000000;;									params.Add(tags[0], v.Index(i).String())
0000000000000000000000000000000000000000;;								}
0000000000000000000000000000000000000000;;							}
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// Otherwise, the field is not set.
0000000000000000000000000000000000000000;;						if len(tags) == 2 && tags[1] == "required" {
0000000000000000000000000000000000000000;;							// And the field is required. Return an error.
0000000000000000000000000000000000000000;;							return nil, fmt.Errorf("Required query parameter [%s] not set.", f.Name)
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return &url.URL{RawQuery: params.Encode()}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return an error if the underlying type of 'opts' isn't a struct.
0000000000000000000000000000000000000000;;		return nil, fmt.Errorf("Options type is not a struct.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	/*
0000000000000000000000000000000000000000;;	BuildHeaders is an internal function to be used by request methods in
0000000000000000000000000000000000000000;;	individual resource packages.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	It accepts an arbitrary tagged structure and produces a string map that's
0000000000000000000000000000000000000000;;	suitable for use as the HTTP headers of an outgoing request. Field names are
0000000000000000000000000000000000000000;;	mapped to header names based in "h" tags.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  type struct Something {
0000000000000000000000000000000000000000;;	    Bar string `h:"x_bar"`
0000000000000000000000000000000000000000;;	    Baz int    `h:"lorem_ipsum"`
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  instance := Something{
0000000000000000000000000000000000000000;;	    Bar: "AAA",
0000000000000000000000000000000000000000;;	    Baz: "BBB",
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	will be converted into:
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	  map[string]string{
0000000000000000000000000000000000000000;;	    "x_bar": "AAA",
0000000000000000000000000000000000000000;;	    "lorem_ipsum": "BBB",
0000000000000000000000000000000000000000;;	  }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	Untagged fields and fields left at their zero values are skipped. Integers,
0000000000000000000000000000000000000000;;	booleans and string values are supported.
0000000000000000000000000000000000000000;;	*/
0000000000000000000000000000000000000000;;	func BuildHeaders(opts interface{}) (map[string]string, error) {
0000000000000000000000000000000000000000;;		optsValue := reflect.ValueOf(opts)
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsValue = optsValue.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsType := reflect.TypeOf(opts)
0000000000000000000000000000000000000000;;		if optsType.Kind() == reflect.Ptr {
0000000000000000000000000000000000000000;;			optsType = optsType.Elem()
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		optsMap := make(map[string]string)
0000000000000000000000000000000000000000;;		if optsValue.Kind() == reflect.Struct {
0000000000000000000000000000000000000000;;			for i := 0; i < optsValue.NumField(); i++ {
0000000000000000000000000000000000000000;;				v := optsValue.Field(i)
0000000000000000000000000000000000000000;;				f := optsType.Field(i)
0000000000000000000000000000000000000000;;				hTag := f.Tag.Get("h")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// if the field has a 'h' tag, it goes in the header
0000000000000000000000000000000000000000;;				if hTag != "" {
0000000000000000000000000000000000000000;;					tags := strings.Split(hTag, ",")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// if the field is set, add it to the slice of query pieces
0000000000000000000000000000000000000000;;					if !isZero(v) {
0000000000000000000000000000000000000000;;						switch v.Kind() {
0000000000000000000000000000000000000000;;						case reflect.String:
0000000000000000000000000000000000000000;;							optsMap[tags[0]] = v.String()
0000000000000000000000000000000000000000;;						case reflect.Int:
0000000000000000000000000000000000000000;;							optsMap[tags[0]] = strconv.FormatInt(v.Int(), 10)
0000000000000000000000000000000000000000;;						case reflect.Bool:
0000000000000000000000000000000000000000;;							optsMap[tags[0]] = strconv.FormatBool(v.Bool())
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					} else {
0000000000000000000000000000000000000000;;						// Otherwise, the field is not set.
0000000000000000000000000000000000000000;;						if len(tags) == 2 && tags[1] == "required" {
0000000000000000000000000000000000000000;;							// And the field is required. Return an error.
0000000000000000000000000000000000000000;;							return optsMap, fmt.Errorf("Required header not set.")
0000000000000000000000000000000000000000;;						}
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return optsMap, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Return an error if the underlying type of 'opts' isn't a struct.
0000000000000000000000000000000000000000;;		return optsMap, fmt.Errorf("Options type is not a struct.")
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IDSliceToQueryString takes a slice of elements and converts them into a query
0000000000000000000000000000000000000000;;	// string. For example, if name=foo and slice=[]int{20, 40, 60}, then the
0000000000000000000000000000000000000000;;	// result would be `?name=20&name=40&name=60'
0000000000000000000000000000000000000000;;	func IDSliceToQueryString(name string, ids []int) string {
0000000000000000000000000000000000000000;;		str := ""
0000000000000000000000000000000000000000;;		for k, v := range ids {
0000000000000000000000000000000000000000;;			if k == 0 {
0000000000000000000000000000000000000000;;				str += "?"
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				str += "&"
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			str += fmt.Sprintf("%s=%s", name, strconv.Itoa(v))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return str
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IntWithinRange returns TRUE if an integer falls within a defined range, and
0000000000000000000000000000000000000000;;	// FALSE if not.
0000000000000000000000000000000000000000;;	func IntWithinRange(val, min, max int) bool {
0000000000000000000000000000000000000000;;		return val > min && val < max
0000000000000000000000000000000000000000;;	}
