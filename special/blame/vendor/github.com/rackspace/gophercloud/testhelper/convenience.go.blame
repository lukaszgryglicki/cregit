0000000000000000000000000000000000000000;;	package testhelper
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/testhelper/convenience.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/testhelper/convenience.go][vendor/github.com/rackspace/gophercloud/testhelper/convenience.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"bytes"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;		"runtime"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"testing"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		logBodyFmt = "\033[1;31m%s %s\033[0m"
0000000000000000000000000000000000000000;;		greenCode  = "\033[0m\033[1;32m"
0000000000000000000000000000000000000000;;		yellowCode = "\033[0m\033[1;33m"
0000000000000000000000000000000000000000;;		resetCode  = "\033[0m\033[1;31m"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func prefix(depth int) string {
0000000000000000000000000000000000000000;;		_, file, line, _ := runtime.Caller(depth)
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Failure in %s, line %d:", filepath.Base(file), line)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func green(str interface{}) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%#v%s", greenCode, str, resetCode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func yellow(str interface{}) string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("%s%#v%s", yellowCode, str, resetCode)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logFatal(t *testing.T, str string) {
0000000000000000000000000000000000000000;;		t.Fatalf(logBodyFmt, prefix(3), str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func logError(t *testing.T, str string) {
0000000000000000000000000000000000000000;;		t.Errorf(logBodyFmt, prefix(3), str)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type diffLogger func([]string, interface{}, interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type visit struct {
0000000000000000000000000000000000000000;;		a1  uintptr
0000000000000000000000000000000000000000;;		a2  uintptr
0000000000000000000000000000000000000000;;		typ reflect.Type
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Recursively visits the structures of "expected" and "actual". The diffLogger function will be
0000000000000000000000000000000000000000;;	// invoked with each different value encountered, including the reference path that was followed
0000000000000000000000000000000000000000;;	// to get there.
0000000000000000000000000000000000000000;;	func deepDiffEqual(expected, actual reflect.Value, visited map[visit]bool, path []string, logDifference diffLogger) {
0000000000000000000000000000000000000000;;		defer func() {
0000000000000000000000000000000000000000;;			// Fall back to the regular reflect.DeepEquals function.
0000000000000000000000000000000000000000;;			if r := recover(); r != nil {
0000000000000000000000000000000000000000;;				var e, a interface{}
0000000000000000000000000000000000000000;;				if expected.IsValid() {
0000000000000000000000000000000000000000;;					e = expected.Interface()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if actual.IsValid() {
0000000000000000000000000000000000000000;;					a = actual.Interface()
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !reflect.DeepEqual(e, a) {
0000000000000000000000000000000000000000;;					logDifference(path, e, a)
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !expected.IsValid() && actual.IsValid() {
0000000000000000000000000000000000000000;;			logDifference(path, nil, actual.Interface())
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if expected.IsValid() && !actual.IsValid() {
0000000000000000000000000000000000000000;;			logDifference(path, expected.Interface(), nil)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if !expected.IsValid() && !actual.IsValid() {
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		hard := func(k reflect.Kind) bool {
0000000000000000000000000000000000000000;;			switch k {
0000000000000000000000000000000000000000;;			case reflect.Array, reflect.Map, reflect.Slice, reflect.Struct:
0000000000000000000000000000000000000000;;				return true
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expected.CanAddr() && actual.CanAddr() && hard(expected.Kind()) {
0000000000000000000000000000000000000000;;			addr1 := expected.UnsafeAddr()
0000000000000000000000000000000000000000;;			addr2 := actual.UnsafeAddr()
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if addr1 > addr2 {
0000000000000000000000000000000000000000;;				addr1, addr2 = addr2, addr1
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if addr1 == addr2 {
0000000000000000000000000000000000000000;;				// References are identical. We can short-circuit
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			typ := expected.Type()
0000000000000000000000000000000000000000;;			v := visit{addr1, addr2, typ}
0000000000000000000000000000000000000000;;			if visited[v] {
0000000000000000000000000000000000000000;;				// Already visited.
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Remember this visit for later.
0000000000000000000000000000000000000000;;			visited[v] = true
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch expected.Kind() {
0000000000000000000000000000000000000000;;		case reflect.Array:
0000000000000000000000000000000000000000;;			for i := 0; i < expected.Len(); i++ {
0000000000000000000000000000000000000000;;				hop := append(path, fmt.Sprintf("[%d]", i))
0000000000000000000000000000000000000000;;				deepDiffEqual(expected.Index(i), actual.Index(i), visited, hop, logDifference)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Slice:
0000000000000000000000000000000000000000;;			if expected.IsNil() != actual.IsNil() {
0000000000000000000000000000000000000000;;				logDifference(path, expected.Interface(), actual.Interface())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if expected.Len() == actual.Len() && expected.Pointer() == actual.Pointer() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			for i := 0; i < expected.Len(); i++ {
0000000000000000000000000000000000000000;;				hop := append(path, fmt.Sprintf("[%d]", i))
0000000000000000000000000000000000000000;;				deepDiffEqual(expected.Index(i), actual.Index(i), visited, hop, logDifference)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Interface:
0000000000000000000000000000000000000000;;			if expected.IsNil() != actual.IsNil() {
0000000000000000000000000000000000000000;;				logDifference(path, expected.Interface(), actual.Interface())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			deepDiffEqual(expected.Elem(), actual.Elem(), visited, path, logDifference)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Ptr:
0000000000000000000000000000000000000000;;			deepDiffEqual(expected.Elem(), actual.Elem(), visited, path, logDifference)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Struct:
0000000000000000000000000000000000000000;;			for i, n := 0, expected.NumField(); i < n; i++ {
0000000000000000000000000000000000000000;;				field := expected.Type().Field(i)
0000000000000000000000000000000000000000;;				hop := append(path, "."+field.Name)
0000000000000000000000000000000000000000;;				deepDiffEqual(expected.Field(i), actual.Field(i), visited, hop, logDifference)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Map:
0000000000000000000000000000000000000000;;			if expected.IsNil() != actual.IsNil() {
0000000000000000000000000000000000000000;;				logDifference(path, expected.Interface(), actual.Interface())
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if expected.Len() == actual.Len() && expected.Pointer() == actual.Pointer() {
0000000000000000000000000000000000000000;;				return
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			var keys []reflect.Value
0000000000000000000000000000000000000000;;			if expected.Len() >= actual.Len() {
0000000000000000000000000000000000000000;;				keys = expected.MapKeys()
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				keys = actual.MapKeys()
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, k := range keys {
0000000000000000000000000000000000000000;;				expectedValue := expected.MapIndex(k)
0000000000000000000000000000000000000000;;				actualValue := expected.MapIndex(k)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if !expectedValue.IsValid() {
0000000000000000000000000000000000000000;;					logDifference(path, nil, actual.Interface())
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if !actualValue.IsValid() {
0000000000000000000000000000000000000000;;					logDifference(path, expected.Interface(), nil)
0000000000000000000000000000000000000000;;					return
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				hop := append(path, fmt.Sprintf("[%v]", k))
0000000000000000000000000000000000000000;;				deepDiffEqual(expectedValue, actualValue, visited, hop, logDifference)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		case reflect.Func:
0000000000000000000000000000000000000000;;			if expected.IsNil() != actual.IsNil() {
0000000000000000000000000000000000000000;;				logDifference(path, expected.Interface(), actual.Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			if expected.Interface() != actual.Interface() {
0000000000000000000000000000000000000000;;				logDifference(path, expected.Interface(), actual.Interface())
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func deepDiff(expected, actual interface{}, logDifference diffLogger) {
0000000000000000000000000000000000000000;;		if expected == nil || actual == nil {
0000000000000000000000000000000000000000;;			logDifference([]string{}, expected, actual)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expectedValue := reflect.ValueOf(expected)
0000000000000000000000000000000000000000;;		actualValue := reflect.ValueOf(actual)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if expectedValue.Type() != actualValue.Type() {
0000000000000000000000000000000000000000;;			logDifference([]string{}, expected, actual)
0000000000000000000000000000000000000000;;			return
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		deepDiffEqual(expectedValue, actualValue, map[visit]bool{}, []string{}, logDifference)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertEquals compares two arbitrary values and performs a comparison. If the
0000000000000000000000000000000000000000;;	// comparison fails, a fatal error is raised that will fail the test
0000000000000000000000000000000000000000;;	func AssertEquals(t *testing.T, expected, actual interface{}) {
0000000000000000000000000000000000000000;;		if expected != actual {
0000000000000000000000000000000000000000;;			logFatal(t, fmt.Sprintf("expected %s but got %s", green(expected), yellow(actual)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckEquals is similar to AssertEquals, except with a non-fatal error
0000000000000000000000000000000000000000;;	func CheckEquals(t *testing.T, expected, actual interface{}) {
0000000000000000000000000000000000000000;;		if expected != actual {
0000000000000000000000000000000000000000;;			logError(t, fmt.Sprintf("expected %s but got %s", green(expected), yellow(actual)))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertErr is a convenience function for checking that an error occurred
0000000000000000000000000000000000000000;;	func AssertErr(t *testing.T, e error) {
0000000000000000000000000000000000000000;;		if e == nil {
0000000000000000000000000000000000000000;;			logFatal(t, fmt.Sprintf("expected an error but none occurred"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckErr is a convenience function for checking that an error occurred,
0000000000000000000000000000000000000000;;	// except with a non-fatal error
0000000000000000000000000000000000000000;;	func CheckErr(t *testing.T, e error) {
0000000000000000000000000000000000000000;;		if e == nil {
0000000000000000000000000000000000000000;;			logError(t, fmt.Sprintf("expected an error but none occurred"))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertDeepEquals - like Equals - performs a comparison - but on more complex
0000000000000000000000000000000000000000;;	// structures that requires deeper inspection
0000000000000000000000000000000000000000;;	func AssertDeepEquals(t *testing.T, expected, actual interface{}) {
0000000000000000000000000000000000000000;;		pre := prefix(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		differed := false
0000000000000000000000000000000000000000;;		deepDiff(expected, actual, func(path []string, expected, actual interface{}) {
0000000000000000000000000000000000000000;;			differed = true
0000000000000000000000000000000000000000;;			t.Errorf("\033[1;31m%sat %s expected %s, but got %s\033[0m",
0000000000000000000000000000000000000000;;				pre,
0000000000000000000000000000000000000000;;				strings.Join(path, ""),
0000000000000000000000000000000000000000;;				green(expected),
0000000000000000000000000000000000000000;;				yellow(actual))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if differed {
0000000000000000000000000000000000000000;;			logFatal(t, "The structures were different.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckDeepEquals is similar to AssertDeepEquals, except with a non-fatal error
0000000000000000000000000000000000000000;;	func CheckDeepEquals(t *testing.T, expected, actual interface{}) {
0000000000000000000000000000000000000000;;		pre := prefix(2)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		deepDiff(expected, actual, func(path []string, expected, actual interface{}) {
0000000000000000000000000000000000000000;;			t.Errorf("\033[1;31m%s at %s expected %s, but got %s\033[0m",
0000000000000000000000000000000000000000;;				pre,
0000000000000000000000000000000000000000;;				strings.Join(path, ""),
0000000000000000000000000000000000000000;;				green(expected),
0000000000000000000000000000000000000000;;				yellow(actual))
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func isByteArrayEquals(t *testing.T, expectedBytes []byte, actualBytes []byte) bool {
0000000000000000000000000000000000000000;;		return bytes.Equal(expectedBytes, actualBytes)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertByteArrayEquals a convenience function for checking whether two byte arrays are equal
0000000000000000000000000000000000000000;;	func AssertByteArrayEquals(t *testing.T, expectedBytes []byte, actualBytes []byte) {
0000000000000000000000000000000000000000;;		if !isByteArrayEquals(t, expectedBytes, actualBytes) {
0000000000000000000000000000000000000000;;			logFatal(t, "The bytes differed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckByteArrayEquals a convenience function for silent checking whether two byte arrays are equal
0000000000000000000000000000000000000000;;	func CheckByteArrayEquals(t *testing.T, expectedBytes []byte, actualBytes []byte) {
0000000000000000000000000000000000000000;;		if !isByteArrayEquals(t, expectedBytes, actualBytes) {
0000000000000000000000000000000000000000;;			logError(t, "The bytes differed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// isJSONEquals is a utility function that implements JSON comparison for AssertJSONEquals and
0000000000000000000000000000000000000000;;	// CheckJSONEquals.
0000000000000000000000000000000000000000;;	func isJSONEquals(t *testing.T, expectedJSON string, actual interface{}) bool {
0000000000000000000000000000000000000000;;		var parsedExpected, parsedActual interface{}
0000000000000000000000000000000000000000;;		err := json.Unmarshal([]byte(expectedJSON), &parsedExpected)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			t.Errorf("Unable to parse expected value as JSON: %v", err)
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		jsonActual, err := json.Marshal(actual)
0000000000000000000000000000000000000000;;		AssertNoErr(t, err)
0000000000000000000000000000000000000000;;		err = json.Unmarshal(jsonActual, &parsedActual)
0000000000000000000000000000000000000000;;		AssertNoErr(t, err)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if !reflect.DeepEqual(parsedExpected, parsedActual) {
0000000000000000000000000000000000000000;;			prettyExpected, err := json.MarshalIndent(parsedExpected, "", "  ")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("Unable to pretty-print expected JSON: %v\n%s", err, expectedJSON)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// We can't use green() here because %#v prints prettyExpected as a byte array literal, which
0000000000000000000000000000000000000000;;				// is... unhelpful. Converting it to a string first leaves "\n" uninterpreted for some reason.
0000000000000000000000000000000000000000;;				t.Logf("Expected JSON:\n%s%s%s", greenCode, prettyExpected, resetCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			prettyActual, err := json.MarshalIndent(actual, "", "  ")
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				t.Logf("Unable to pretty-print actual JSON: %v\n%#v", err, actual)
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// We can't use yellow() for the same reason.
0000000000000000000000000000000000000000;;				t.Logf("Actual JSON:\n%s%s%s", yellowCode, prettyActual, resetCode)
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			return false
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return true
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertJSONEquals serializes a value as JSON, parses an expected string as JSON, and ensures that
0000000000000000000000000000000000000000;;	// both are consistent. If they aren't, the expected and actual structures are pretty-printed and
0000000000000000000000000000000000000000;;	// shown for comparison.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// This is useful for comparing structures that are built as nested map[string]interface{} values,
0000000000000000000000000000000000000000;;	// which are a pain to construct as literals.
0000000000000000000000000000000000000000;;	func AssertJSONEquals(t *testing.T, expectedJSON string, actual interface{}) {
0000000000000000000000000000000000000000;;		if !isJSONEquals(t, expectedJSON, actual) {
0000000000000000000000000000000000000000;;			logFatal(t, "The generated JSON structure differed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckJSONEquals is similar to AssertJSONEquals, but nonfatal.
0000000000000000000000000000000000000000;;	func CheckJSONEquals(t *testing.T, expectedJSON string, actual interface{}) {
0000000000000000000000000000000000000000;;		if !isJSONEquals(t, expectedJSON, actual) {
0000000000000000000000000000000000000000;;			logError(t, "The generated JSON structure differed.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertNoErr is a convenience function for checking whether an error value is
0000000000000000000000000000000000000000;;	// an actual error
0000000000000000000000000000000000000000;;	func AssertNoErr(t *testing.T, e error) {
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			logFatal(t, fmt.Sprintf("unexpected error %s", yellow(e.Error())))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AssertNotNil is a convenience function for checking whether given value is not nil
0000000000000000000000000000000000000000;;	func AssertNotNil(t *testing.T, actual interface{}) {
0000000000000000000000000000000000000000;;		if actual == nil || !reflect.ValueOf(actual).Elem().IsValid() {
0000000000000000000000000000000000000000;;			logFatal(t, fmt.Sprintf("Not nil expexted, but was %v", actual))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CheckNoErr is similar to AssertNoErr, except with a non-fatal error
0000000000000000000000000000000000000000;;	func CheckNoErr(t *testing.T, e error) {
0000000000000000000000000000000000000000;;		if e != nil {
0000000000000000000000000000000000000000;;			logError(t, fmt.Sprintf("unexpected error %s", yellow(e.Error())))
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
