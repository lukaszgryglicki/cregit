0000000000000000000000000000000000000000;;	package tokens
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/identity/v3/tokens/requests.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/identity/v3/tokens/requests.go][vendor/github.com/rackspace/gophercloud/openstack/identity/v3/tokens/requests.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"net/http"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Scope allows a created token to be limited to a specific domain or project.
0000000000000000000000000000000000000000;;	type Scope struct {
0000000000000000000000000000000000000000;;		ProjectID   string
0000000000000000000000000000000000000000;;		ProjectName string
0000000000000000000000000000000000000000;;		DomainID    string
0000000000000000000000000000000000000000;;		DomainName  string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func subjectTokenHeaders(c *gophercloud.ServiceClient, subjectToken string) map[string]string {
0000000000000000000000000000000000000000;;		return map[string]string{
0000000000000000000000000000000000000000;;			"X-Subject-Token": subjectToken,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthOptionsV3er describes any argument that may be passed to the Create call.
0000000000000000000000000000000000000000;;	type AuthOptionsV3er interface {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	        // ToTokenCreateMap assembles the Create request body, returning an error if parameters are
0000000000000000000000000000000000000000;;	        // missing or inconsistent.
0000000000000000000000000000000000000000;;	        ToAuthOptionsV3Map(c *gophercloud.ServiceClient, scope *Scope) (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AuthOptions wraps a gophercloud AuthOptions in order to adhere to the AuthOptionsV3er
0000000000000000000000000000000000000000;;	// interface.
0000000000000000000000000000000000000000;;	type AuthOptions struct {
0000000000000000000000000000000000000000;;	        gophercloud.AuthOptions
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (options AuthOptions) ToAuthOptionsV3Map(c *gophercloud.ServiceClient, scope *Scope) (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		// tokens3.Create logic
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Populate the request structure based on the provided arguments. Create and return an error
0000000000000000000000000000000000000000;;		// if insufficient or incompatible information is present.
0000000000000000000000000000000000000000;;		authMap := make(map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Test first for unrecognized arguments.
0000000000000000000000000000000000000000;;		if options.APIKey != "" {
0000000000000000000000000000000000000000;;			return nil, ErrAPIKeyProvided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.TenantID != "" {
0000000000000000000000000000000000000000;;			return nil, ErrTenantIDProvided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if options.TenantName != "" {
0000000000000000000000000000000000000000;;			return nil, ErrTenantNameProvided
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if options.Password == "" {
0000000000000000000000000000000000000000;;			if options.TokenID != "" {
0000000000000000000000000000000000000000;;				c.TokenID = options.TokenID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if c.TokenID != "" {
0000000000000000000000000000000000000000;;				// Because we aren't using password authentication, it's an error to also provide any of the user-based authentication
0000000000000000000000000000000000000000;;				// parameters.
0000000000000000000000000000000000000000;;				if options.Username != "" {
0000000000000000000000000000000000000000;;					return nil, ErrUsernameWithToken
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if options.UserID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrUserIDWithToken
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Configure the request for Token authentication.
0000000000000000000000000000000000000000;;	                        authMap["identity"] = map[string]interface{}{
0000000000000000000000000000000000000000;;	                                "methods": []string{"token"},
0000000000000000000000000000000000000000;;	                                "token": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                        "id": c.TokenID,
0000000000000000000000000000000000000000;;					},
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				// If no password or token ID are available, authentication can't continue.
0000000000000000000000000000000000000000;;				return nil, ErrMissingPassword
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		} else {
0000000000000000000000000000000000000000;;			// Password authentication.
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// At least one of Username and UserID must be specified.
0000000000000000000000000000000000000000;;			if options.Username == "" && options.UserID == "" {
0000000000000000000000000000000000000000;;				return nil, ErrUsernameOrUserID
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if options.Username != "" {
0000000000000000000000000000000000000000;;				// If Username is provided, UserID may not be provided.
0000000000000000000000000000000000000000;;				if options.UserID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrUsernameOrUserID
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Either DomainID or DomainName must also be specified.
0000000000000000000000000000000000000000;;				if options.DomainID == "" && options.DomainName == "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainIDOrDomainName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if options.DomainID != "" {
0000000000000000000000000000000000000000;;					if options.DomainName != "" {
0000000000000000000000000000000000000000;;						return nil, ErrDomainIDOrDomainName
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;					// Configure the request for Username and Password authentication with a DomainID.
0000000000000000000000000000000000000000;;	                                authMap["identity"] = map[string]interface{}{
0000000000000000000000000000000000000000;;						"methods": []string{"password"},
0000000000000000000000000000000000000000;;	                                	"password" : map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                "user": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                        "name": &options.Username,
0000000000000000000000000000000000000000;;	                                                        "password": options.Password,
0000000000000000000000000000000000000000;;	                                                        "domain": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                                "id": &options.DomainID,
0000000000000000000000000000000000000000;;	                                                        },
0000000000000000000000000000000000000000;;	                                                },
0000000000000000000000000000000000000000;;						},
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if options.DomainName != "" {
0000000000000000000000000000000000000000;;					// Configure the request for Username and Password authentication with a DomainName.
0000000000000000000000000000000000000000;;	                                authMap["identity"] = map[string]interface{}{
0000000000000000000000000000000000000000;;						"methods": []string{"password"},
0000000000000000000000000000000000000000;;	                                        "password": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                 "user": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                         "name": &options.Username,
0000000000000000000000000000000000000000;;	                                                         "password": options.Password,
0000000000000000000000000000000000000000;;	                                                         "domain": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                                 "name": &options.DomainName,
0000000000000000000000000000000000000000;;	                                                         },
0000000000000000000000000000000000000000;;	                                                },
0000000000000000000000000000000000000000;;	                                         },
0000000000000000000000000000000000000000;;	                                 }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			if options.UserID != "" {
0000000000000000000000000000000000000000;;				// If UserID is specified, neither DomainID nor DomainName may be.
0000000000000000000000000000000000000000;;				if options.DomainID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainIDWithUserID
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if options.DomainName != "" {
0000000000000000000000000000000000000000;;					return nil, ErrDomainNameWithUserID
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// Configure the request for UserID and Password authentication.
0000000000000000000000000000000000000000;;	                        authMap["identity"] = map[string]interface{}{
0000000000000000000000000000000000000000;;					"methods": []string{"password"},
0000000000000000000000000000000000000000;;	                                "password" : map[string]interface{}{
0000000000000000000000000000000000000000;;	                                        "user": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                "id": &options.UserID,
0000000000000000000000000000000000000000;;	                                                "password": options.Password,
0000000000000000000000000000000000000000;;	                                        },
0000000000000000000000000000000000000000;;	                                },
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Add a "scope" element if a Scope has been provided.
0000000000000000000000000000000000000000;;		if scope != nil {
0000000000000000000000000000000000000000;;			if scope.ProjectName != "" {
0000000000000000000000000000000000000000;;				// ProjectName provided: either DomainID or DomainName must also be supplied.
0000000000000000000000000000000000000000;;				// ProjectID may not be supplied.
0000000000000000000000000000000000000000;;				if scope.DomainID == "" && scope.DomainName == "" {
0000000000000000000000000000000000000000;;					return nil, ErrScopeDomainIDOrDomainName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if scope.ProjectID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrScopeProjectIDOrProjectName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if scope.DomainID != "" {
0000000000000000000000000000000000000000;;					// ProjectName + DomainID
0000000000000000000000000000000000000000;;	                                authMap["scope"] = map[string]interface{}{
0000000000000000000000000000000000000000;;	                                        "project": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                "domain": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                        "id": &scope.DomainID,
0000000000000000000000000000000000000000;;	                                                        },
0000000000000000000000000000000000000000;;	                                                "name": &scope.ProjectName,
0000000000000000000000000000000000000000;;	                                        },
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				if scope.DomainName != "" {
0000000000000000000000000000000000000000;;					// ProjectName + DomainName
0000000000000000000000000000000000000000;;	                                authMap["scope"] = map[string]interface{}{
0000000000000000000000000000000000000000;;	                                        "project": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                "domain": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                                        "name": &scope.DomainName,
0000000000000000000000000000000000000000;;	                                                        },
0000000000000000000000000000000000000000;;	                                                "name": &scope.ProjectName,
0000000000000000000000000000000000000000;;	                                        },
0000000000000000000000000000000000000000;;					}
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if scope.ProjectID != "" {
0000000000000000000000000000000000000000;;				// ProjectID provided. ProjectName, DomainID, and DomainName may not be provided.
0000000000000000000000000000000000000000;;				if scope.DomainID != "" {
0000000000000000000000000000000000000000;;					return nil, ErrScopeProjectIDAlone
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if scope.DomainName != "" {
0000000000000000000000000000000000000000;;					return nil, ErrScopeProjectIDAlone
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// ProjectID
0000000000000000000000000000000000000000;;	                        authMap["scope"] = map[string]interface{}{
0000000000000000000000000000000000000000;;	                                "project": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                        "id": &scope.ProjectID,
0000000000000000000000000000000000000000;;	                                        },
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if scope.DomainID != "" {
0000000000000000000000000000000000000000;;				// DomainID provided. ProjectID, ProjectName, and DomainName may not be provided.
0000000000000000000000000000000000000000;;				if scope.DomainName != "" {
0000000000000000000000000000000000000000;;					return nil, ErrScopeDomainIDOrDomainName
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;				// DomainID
0000000000000000000000000000000000000000;;	                        authMap["scope"] = map[string]interface{}{
0000000000000000000000000000000000000000;;	                                 "domain": map[string]interface{}{
0000000000000000000000000000000000000000;;	                                         "id": &scope.DomainID,
0000000000000000000000000000000000000000;;	                                         },
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			} else if scope.DomainName != "" {
0000000000000000000000000000000000000000;;				return nil, ErrScopeDomainName
0000000000000000000000000000000000000000;;			} else {
0000000000000000000000000000000000000000;;				return nil, ErrScopeEmpty
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return map[string]interface{}{"auth": authMap}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create authenticates and either generates a new token, or changes the Scope of an existing token.
0000000000000000000000000000000000000000;;	func Create(c *gophercloud.ServiceClient, options AuthOptionsV3er, scope *Scope) CreateResult {
0000000000000000000000000000000000000000;;	        request, err := options.ToAuthOptionsV3Map(c, scope)
0000000000000000000000000000000000000000;;	        if err != nil {
0000000000000000000000000000000000000000;;	                return CreateResult{commonResult{gophercloud.Result{Err: err}}}
0000000000000000000000000000000000000000;;	        }
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result CreateResult
0000000000000000000000000000000000000000;;		var response *http.Response
0000000000000000000000000000000000000000;;		response, result.Err = c.Post(tokenURL(c), request, &result.Body, nil)
0000000000000000000000000000000000000000;;		if result.Err != nil {
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.Header = response.Header
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get validates and retrieves information about another token.
0000000000000000000000000000000000000000;;	func Get(c *gophercloud.ServiceClient, token string) GetResult {
0000000000000000000000000000000000000000;;		var result GetResult
0000000000000000000000000000000000000000;;		var response *http.Response
0000000000000000000000000000000000000000;;		response, result.Err = c.Get(tokenURL(c), &result.Body, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			MoreHeaders: subjectTokenHeaders(c, token),
0000000000000000000000000000000000000000;;			OkCodes:     []int{200, 203},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if result.Err != nil {
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		result.Header = response.Header
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Validate determines if a specified token is valid or not.
0000000000000000000000000000000000000000;;	func Validate(c *gophercloud.ServiceClient, token string) (bool, error) {
0000000000000000000000000000000000000000;;		response, err := c.Request("HEAD", tokenURL(c), gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			MoreHeaders: subjectTokenHeaders(c, token),
0000000000000000000000000000000000000000;;			OkCodes:     []int{204, 404},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return false, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return response.StatusCode == 204, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Revoke immediately makes specified token invalid.
0000000000000000000000000000000000000000;;	func Revoke(c *gophercloud.ServiceClient, token string) RevokeResult {
0000000000000000000000000000000000000000;;		var res RevokeResult
0000000000000000000000000000000000000000;;		_, res.Err = c.Delete(tokenURL(c), &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			MoreHeaders: subjectTokenHeaders(c, token),
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
