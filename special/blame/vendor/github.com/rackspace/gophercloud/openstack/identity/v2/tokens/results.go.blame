0000000000000000000000000000000000000000;;	package tokens
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/identity/v2/tokens/results.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/identity/v2/tokens/results.go][vendor/github.com/rackspace/gophercloud/openstack/identity/v2/tokens/results.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/mitchellh/mapstructure"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/openstack/identity/v2/tenants"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Token provides only the most basic information related to an authentication token.
0000000000000000000000000000000000000000;;	type Token struct {
0000000000000000000000000000000000000000;;		// ID provides the primary means of identifying a user to the OpenStack API.
0000000000000000000000000000000000000000;;		// OpenStack defines this field as an opaque value, so do not depend on its content.
0000000000000000000000000000000000000000;;		// It is safe, however, to compare for equality.
0000000000000000000000000000000000000000;;		ID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ExpiresAt provides a timestamp in ISO 8601 format, indicating when the authentication token becomes invalid.
0000000000000000000000000000000000000000;;		// After this point in time, future API requests made using this authentication token will respond with errors.
0000000000000000000000000000000000000000;;		// Either the caller will need to reauthenticate manually, or more preferably, the caller should exploit automatic re-authentication.
0000000000000000000000000000000000000000;;		// See the AuthOptions structure for more details.
0000000000000000000000000000000000000000;;		ExpiresAt time.Time
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Tenant provides information about the tenant to which this token grants access.
0000000000000000000000000000000000000000;;		Tenant tenants.Tenant
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Authorization need user info which can get from token authentication's response
0000000000000000000000000000000000000000;;	type Role struct {
0000000000000000000000000000000000000000;;		Name string `mapstructure:"name"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	type User struct {
0000000000000000000000000000000000000000;;		ID       string `mapstructure:"id"`
0000000000000000000000000000000000000000;;		Name     string `mapstructure:"name"`
0000000000000000000000000000000000000000;;		UserName string `mapstructure:"username"`
0000000000000000000000000000000000000000;;		Roles    []Role `mapstructure:"roles"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Endpoint represents a single API endpoint offered by a service.
0000000000000000000000000000000000000000;;	// It provides the public and internal URLs, if supported, along with a region specifier, again if provided.
0000000000000000000000000000000000000000;;	// The significance of the Region field will depend upon your provider.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In addition, the interface offered by the service will have version information associated with it
0000000000000000000000000000000000000000;;	// through the VersionId, VersionInfo, and VersionList fields, if provided or supported.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// In all cases, fields which aren't supported by the provider and service combined will assume a zero-value ("").
0000000000000000000000000000000000000000;;	type Endpoint struct {
0000000000000000000000000000000000000000;;		TenantID    string `mapstructure:"tenantId"`
0000000000000000000000000000000000000000;;		PublicURL   string `mapstructure:"publicURL"`
0000000000000000000000000000000000000000;;		InternalURL string `mapstructure:"internalURL"`
0000000000000000000000000000000000000000;;		AdminURL    string `mapstructure:"adminURL"`
0000000000000000000000000000000000000000;;		Region      string `mapstructure:"region"`
0000000000000000000000000000000000000000;;		VersionID   string `mapstructure:"versionId"`
0000000000000000000000000000000000000000;;		VersionInfo string `mapstructure:"versionInfo"`
0000000000000000000000000000000000000000;;		VersionList string `mapstructure:"versionList"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CatalogEntry provides a type-safe interface to an Identity API V2 service catalog listing.
0000000000000000000000000000000000000000;;	// Each class of service, such as cloud DNS or block storage services, will have a single
0000000000000000000000000000000000000000;;	// CatalogEntry representing it.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Note: when looking for the desired service, try, whenever possible, to key off the type field.
0000000000000000000000000000000000000000;;	// Otherwise, you'll tie the representation of the service to a specific provider.
0000000000000000000000000000000000000000;;	type CatalogEntry struct {
0000000000000000000000000000000000000000;;		// Name will contain the provider-specified name for the service.
0000000000000000000000000000000000000000;;		Name string `mapstructure:"name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Type will contain a type string if OpenStack defines a type for the service.
0000000000000000000000000000000000000000;;		// Otherwise, for provider-specific services, the provider may assign their own type strings.
0000000000000000000000000000000000000000;;		Type string `mapstructure:"type"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Endpoints will let the caller iterate over all the different endpoints that may exist for
0000000000000000000000000000000000000000;;		// the service.
0000000000000000000000000000000000000000;;		Endpoints []Endpoint `mapstructure:"endpoints"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServiceCatalog provides a view into the service catalog from a previous, successful authentication.
0000000000000000000000000000000000000000;;	type ServiceCatalog struct {
0000000000000000000000000000000000000000;;		Entries []CatalogEntry
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateResult defers the interpretation of a created token.
0000000000000000000000000000000000000000;;	// Use ExtractToken() to interpret it as a Token, or ExtractServiceCatalog() to interpret it as a service catalog.
0000000000000000000000000000000000000000;;	type CreateResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResult is the deferred response from a Get call, which is the same with a Created token.
0000000000000000000000000000000000000000;;	// Use ExtractUser() to interpret it as a User.
0000000000000000000000000000000000000000;;	type GetResult struct {
0000000000000000000000000000000000000000;;		CreateResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractToken returns the just-created Token from a CreateResult.
0000000000000000000000000000000000000000;;	func (result CreateResult) ExtractToken() (*Token, error) {
0000000000000000000000000000000000000000;;		if result.Err != nil {
0000000000000000000000000000000000000000;;			return nil, result.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Access struct {
0000000000000000000000000000000000000000;;				Token struct {
0000000000000000000000000000000000000000;;					Expires string         `mapstructure:"expires"`
0000000000000000000000000000000000000000;;					ID      string         `mapstructure:"id"`
0000000000000000000000000000000000000000;;					Tenant  tenants.Tenant `mapstructure:"tenant"`
0000000000000000000000000000000000000000;;				} `mapstructure:"token"`
0000000000000000000000000000000000000000;;			} `mapstructure:"access"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(result.Body, &response)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		expiresTs, err := time.Parse(gophercloud.RFC3339Milli, response.Access.Token.Expires)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &Token{
0000000000000000000000000000000000000000;;			ID:        response.Access.Token.ID,
0000000000000000000000000000000000000000;;			ExpiresAt: expiresTs,
0000000000000000000000000000000000000000;;			Tenant:    response.Access.Token.Tenant,
0000000000000000000000000000000000000000;;		}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractServiceCatalog returns the ServiceCatalog that was generated along with the user's Token.
0000000000000000000000000000000000000000;;	func (result CreateResult) ExtractServiceCatalog() (*ServiceCatalog, error) {
0000000000000000000000000000000000000000;;		if result.Err != nil {
0000000000000000000000000000000000000000;;			return nil, result.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Access struct {
0000000000000000000000000000000000000000;;				Entries []CatalogEntry `mapstructure:"serviceCatalog"`
0000000000000000000000000000000000000000;;			} `mapstructure:"access"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(result.Body, &response)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &ServiceCatalog{Entries: response.Access.Entries}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// createErr quickly packs an error in a CreateResult.
0000000000000000000000000000000000000000;;	func createErr(err error) CreateResult {
0000000000000000000000000000000000000000;;		return CreateResult{gophercloud.Result{Err: err}}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractUser returns the User from a GetResult.
0000000000000000000000000000000000000000;;	func (result GetResult) ExtractUser() (*User, error) {
0000000000000000000000000000000000000000;;		if result.Err != nil {
0000000000000000000000000000000000000000;;			return nil, result.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Access struct {
0000000000000000000000000000000000000000;;				User User `mapstructure:"user"`
0000000000000000000000000000000000000000;;			} `mapstructure:"access"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(result.Body, &response)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &response.Access.User, nil
0000000000000000000000000000000000000000;;	}
