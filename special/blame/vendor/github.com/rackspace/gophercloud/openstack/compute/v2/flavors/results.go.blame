0000000000000000000000000000000000000000;;	package flavors
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/compute/v2/flavors/results.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/compute/v2/flavors/results.go][vendor/github.com/rackspace/gophercloud/openstack/compute/v2/flavors/results.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/mitchellh/mapstructure"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/pagination"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrCannotInterpret is returned by an Extract call if the response body doesn't have the expected structure.
0000000000000000000000000000000000000000;;	var ErrCannotInterpet = errors.New("Unable to interpret a response body.")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResult temporarily holds the response from a Get call.
0000000000000000000000000000000000000000;;	type GetResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract provides access to the individual Flavor returned by the Get function.
0000000000000000000000000000000000000000;;	func (gr GetResult) Extract() (*Flavor, error) {
0000000000000000000000000000000000000000;;		if gr.Err != nil {
0000000000000000000000000000000000000000;;			return nil, gr.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var result struct {
0000000000000000000000000000000000000000;;			Flavor Flavor `mapstructure:"flavor"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &mapstructure.DecoderConfig{
0000000000000000000000000000000000000000;;			DecodeHook: defaulter,
0000000000000000000000000000000000000000;;			Result:     &result,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoder, err := mapstructure.NewDecoder(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = decoder.Decode(gr.Body)
0000000000000000000000000000000000000000;;		return &result.Flavor, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Flavor records represent (virtual) hardware configurations for server resources in a region.
0000000000000000000000000000000000000000;;	type Flavor struct {
0000000000000000000000000000000000000000;;		// The Id field contains the flavor's unique identifier.
0000000000000000000000000000000000000000;;		// For example, this identifier will be useful when specifying which hardware configuration to use for a new server instance.
0000000000000000000000000000000000000000;;		ID string `mapstructure:"id"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Disk and RA< fields provide a measure of storage space offered by the flavor, in GB and MB, respectively.
0000000000000000000000000000000000000000;;		Disk int `mapstructure:"disk"`
0000000000000000000000000000000000000000;;		RAM  int `mapstructure:"ram"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// The Name field provides a human-readable moniker for the flavor.
0000000000000000000000000000000000000000;;		Name string `mapstructure:"name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		RxTxFactor float64 `mapstructure:"rxtx_factor"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Swap indicates how much space is reserved for swap.
0000000000000000000000000000000000000000;;		// If not provided, this field will be set to 0.
0000000000000000000000000000000000000000;;		Swap int `mapstructure:"swap"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// VCPUs indicates how many (virtual) CPUs are available for this flavor.
0000000000000000000000000000000000000000;;		VCPUs int `mapstructure:"vcpus"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// FlavorPage contains a single page of the response from a List call.
0000000000000000000000000000000000000000;;	type FlavorPage struct {
0000000000000000000000000000000000000000;;		pagination.LinkedPageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty determines if a page contains any results.
0000000000000000000000000000000000000000;;	func (p FlavorPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		flavors, err := ExtractFlavors(p)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(flavors) == 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextPageURL uses the response's embedded link reference to navigate to the next page of results.
0000000000000000000000000000000000000000;;	func (p FlavorPage) NextPageURL() (string, error) {
0000000000000000000000000000000000000000;;		type resp struct {
0000000000000000000000000000000000000000;;			Links []gophercloud.Link `mapstructure:"flavors_links"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r resp
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(p.Body, &r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gophercloud.ExtractNextURL(r.Links)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func defaulter(from, to reflect.Kind, v interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if (from == reflect.String) && (to == reflect.Int) {
0000000000000000000000000000000000000000;;			return 0, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return v, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractFlavors provides access to the list of flavors in a page acquired from the List operation.
0000000000000000000000000000000000000000;;	func ExtractFlavors(page pagination.Page) ([]Flavor, error) {
0000000000000000000000000000000000000000;;		casted := page.(FlavorPage).Body
0000000000000000000000000000000000000000;;		var container struct {
0000000000000000000000000000000000000000;;			Flavors []Flavor `mapstructure:"flavors"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		cfg := &mapstructure.DecoderConfig{
0000000000000000000000000000000000000000;;			DecodeHook: defaulter,
0000000000000000000000000000000000000000;;			Result:     &container,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoder, err := mapstructure.NewDecoder(cfg)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return container.Flavors, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		err = decoder.Decode(casted)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return container.Flavors, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return container.Flavors, nil
0000000000000000000000000000000000000000;;	}
