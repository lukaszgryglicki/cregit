0000000000000000000000000000000000000000;;	package servers
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/compute/v2/servers/results.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/compute/v2/servers/results.go][vendor/github.com/rackspace/gophercloud/openstack/compute/v2/servers/results.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"crypto/rsa"
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path"
0000000000000000000000000000000000000000;;		"reflect"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/mitchellh/mapstructure"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/pagination"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type serverResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any serverResult as a Server, if possible.
0000000000000000000000000000000000000000;;	func (r serverResult) Extract() (*Server, error) {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return nil, r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Server Server `mapstructure:"server"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := &mapstructure.DecoderConfig{
0000000000000000000000000000000000000000;;			DecodeHook: toMapFromString,
0000000000000000000000000000000000000000;;			Result:     &response,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoder, err := mapstructure.NewDecoder(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = decoder.Decode(r.Body)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return &response.Server, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateResult temporarily contains the response from a Create call.
0000000000000000000000000000000000000000;;	type CreateResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetResult temporarily contains the response from a Get call.
0000000000000000000000000000000000000000;;	type GetResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateResult temporarily contains the response from an Update call.
0000000000000000000000000000000000000000;;	type UpdateResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteResult temporarily contains the response from a Delete call.
0000000000000000000000000000000000000000;;	type DeleteResult struct {
0000000000000000000000000000000000000000;;		gophercloud.ErrResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RebuildResult temporarily contains the response from a Rebuild call.
0000000000000000000000000000000000000000;;	type RebuildResult struct {
0000000000000000000000000000000000000000;;		serverResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ActionResult represents the result of server action operations, like reboot
0000000000000000000000000000000000000000;;	type ActionResult struct {
0000000000000000000000000000000000000000;;		gophercloud.ErrResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RescueResult represents the result of a server rescue operation
0000000000000000000000000000000000000000;;	type RescueResult struct {
0000000000000000000000000000000000000000;;		ActionResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateImageResult represents the result of an image creation operation
0000000000000000000000000000000000000000;;	type CreateImageResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPasswordResult represent the result of a get os-server-password operation.
0000000000000000000000000000000000000000;;	type GetPasswordResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractPassword gets the encrypted password.
0000000000000000000000000000000000000000;;	// If privateKey != nil the password is decrypted with the private key.
0000000000000000000000000000000000000000;;	// If privateKey == nil the encrypted password is returned and can be decrypted with:
0000000000000000000000000000000000000000;;	//   echo '<pwd>' | base64 -D | openssl rsautl -decrypt -inkey <private_key>
0000000000000000000000000000000000000000;;	func (r GetPasswordResult) ExtractPassword(privateKey *rsa.PrivateKey) (string, error) {
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return "", r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Password string `mapstructure:"password"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(r.Body, &response)
0000000000000000000000000000000000000000;;		if err == nil && privateKey != nil && response.Password != "" {
0000000000000000000000000000000000000000;;			return decryptPassword(response.Password, privateKey)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return response.Password, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func decryptPassword(encryptedPassword string, privateKey *rsa.PrivateKey) (string, error) {
0000000000000000000000000000000000000000;;		b64EncryptedPassword := make([]byte, base64.StdEncoding.DecodedLen(len(encryptedPassword)))
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		n, err := base64.StdEncoding.Decode(b64EncryptedPassword, []byte(encryptedPassword))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to base64 decode encrypted password: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		password, err := rsa.DecryptPKCS1v15(nil, privateKey, b64EncryptedPassword[0:n])
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to decrypt password: %s", err)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return string(password), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractImageID gets the ID of the newly created server image from the header
0000000000000000000000000000000000000000;;	func (res CreateImageResult) ExtractImageID() (string, error) {
0000000000000000000000000000000000000000;;		if res.Err != nil {
0000000000000000000000000000000000000000;;			return "", res.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// Get the image id from the header
0000000000000000000000000000000000000000;;		u, err := url.ParseRequestURI(res.Header.Get("Location"))
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to parse the image id: %s", err.Error())
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		imageId := path.Base(u.Path)
0000000000000000000000000000000000000000;;		if imageId == "." || imageId == "/" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Failed to parse the ID of newly created image: %s", u)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return imageId, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any RescueResult as an AdminPass, if possible.
0000000000000000000000000000000000000000;;	func (r RescueResult) Extract() (string, error) {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return "", r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			AdminPass string `mapstructure:"adminPass"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(r.Body, &response)
0000000000000000000000000000000000000000;;		return response.AdminPass, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Server exposes only the standard OpenStack fields corresponding to a given server on the user's account.
0000000000000000000000000000000000000000;;	type Server struct {
0000000000000000000000000000000000000000;;		// ID uniquely identifies this server amongst all other servers, including those not accessible to the current tenant.
0000000000000000000000000000000000000000;;		ID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// TenantID identifies the tenant owning this server resource.
0000000000000000000000000000000000000000;;		TenantID string `mapstructure:"tenant_id"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserID uniquely identifies the user account owning the tenant.
0000000000000000000000000000000000000000;;		UserID string `mapstructure:"user_id"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name contains the human-readable name for the server.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Updated and Created contain ISO-8601 timestamps of when the state of the server last changed, and when it was created.
0000000000000000000000000000000000000000;;		Updated string
0000000000000000000000000000000000000000;;		Created string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		HostID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Status contains the current operational status of the server, such as IN_PROGRESS or ACTIVE.
0000000000000000000000000000000000000000;;		Status string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Progress ranges from 0..100.
0000000000000000000000000000000000000000;;		// A request made against the server completes only once Progress reaches 100.
0000000000000000000000000000000000000000;;		Progress int
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv4 and AccessIPv6 contain the IP addresses of the server, suitable for remote access for administration.
0000000000000000000000000000000000000000;;		AccessIPv4, AccessIPv6 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Image refers to a JSON object, which itself indicates the OS image used to deploy the server.
0000000000000000000000000000000000000000;;		Image map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Flavor refers to a JSON object, which itself indicates the hardware configuration of the deployed server.
0000000000000000000000000000000000000000;;		Flavor map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Addresses includes a list of all IP addresses assigned to the server, keyed by pool.
0000000000000000000000000000000000000000;;		Addresses map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata includes a list of all user-specified key-value pairs attached to the server.
0000000000000000000000000000000000000000;;		Metadata map[string]interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Links includes HTTP references to the itself, useful for passing along to other APIs that might want a server reference.
0000000000000000000000000000000000000000;;		Links []interface{}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// KeyName indicates which public key was injected into the server on launch.
0000000000000000000000000000000000000000;;		KeyName string `json:"key_name" mapstructure:"key_name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AdminPass will generally be empty ("").  However, it will contain the administrative password chosen when provisioning a new server without a set AdminPass setting in the first place.
0000000000000000000000000000000000000000;;		// Note that this is the ONLY time this field will be valid.
0000000000000000000000000000000000000000;;		AdminPass string `json:"adminPass" mapstructure:"adminPass"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecurityGroups includes the security groups that this instance has applied to it
0000000000000000000000000000000000000000;;		SecurityGroups []map[string]interface{} `json:"security_groups" mapstructure:"security_groups"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ServerPage abstracts the raw results of making a List() request against the API.
0000000000000000000000000000000000000000;;	// As OpenStack extensions may freely alter the response bodies of structures returned to the client, you may only safely access the
0000000000000000000000000000000000000000;;	// data provided through the ExtractServers call.
0000000000000000000000000000000000000000;;	type ServerPage struct {
0000000000000000000000000000000000000000;;		pagination.LinkedPageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if a page contains no Server results.
0000000000000000000000000000000000000000;;	func (page ServerPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		servers, err := ExtractServers(page)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(servers) == 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NextPageURL uses the response's embedded link reference to navigate to the next page of results.
0000000000000000000000000000000000000000;;	func (page ServerPage) NextPageURL() (string, error) {
0000000000000000000000000000000000000000;;		type resp struct {
0000000000000000000000000000000000000000;;			Links []gophercloud.Link `mapstructure:"servers_links"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var r resp
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(page.Body, &r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return gophercloud.ExtractNextURL(r.Links)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractServers interprets the results of a single page from a List() call, producing a slice of Server entities.
0000000000000000000000000000000000000000;;	func ExtractServers(page pagination.Page) ([]Server, error) {
0000000000000000000000000000000000000000;;		casted := page.(ServerPage).Body
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Servers []Server `mapstructure:"servers"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		config := &mapstructure.DecoderConfig{
0000000000000000000000000000000000000000;;			DecodeHook: toMapFromString,
0000000000000000000000000000000000000000;;			Result:     &response,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		decoder, err := mapstructure.NewDecoder(config)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err = decoder.Decode(casted)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return response.Servers, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadataResult contains the result of a call for (potentially) multiple key-value pairs.
0000000000000000000000000000000000000000;;	type MetadataResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetadataResult temporarily contains the response from a metadata Get call.
0000000000000000000000000000000000000000;;	type GetMetadataResult struct {
0000000000000000000000000000000000000000;;		MetadataResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetMetadataResult temporarily contains the response from a metadata Reset call.
0000000000000000000000000000000000000000;;	type ResetMetadataResult struct {
0000000000000000000000000000000000000000;;		MetadataResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateMetadataResult temporarily contains the response from a metadata Update call.
0000000000000000000000000000000000000000;;	type UpdateMetadataResult struct {
0000000000000000000000000000000000000000;;		MetadataResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadatumResult contains the result of a call for individual a single key-value pair.
0000000000000000000000000000000000000000;;	type MetadatumResult struct {
0000000000000000000000000000000000000000;;		gophercloud.Result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetMetadatumResult temporarily contains the response from a metadatum Get call.
0000000000000000000000000000000000000000;;	type GetMetadatumResult struct {
0000000000000000000000000000000000000000;;		MetadatumResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateMetadatumResult temporarily contains the response from a metadatum Create call.
0000000000000000000000000000000000000000;;	type CreateMetadatumResult struct {
0000000000000000000000000000000000000000;;		MetadatumResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteMetadatumResult temporarily contains the response from a metadatum Delete call.
0000000000000000000000000000000000000000;;	type DeleteMetadatumResult struct {
0000000000000000000000000000000000000000;;		gophercloud.ErrResult
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any MetadataResult as a Metadata, if possible.
0000000000000000000000000000000000000000;;	func (r MetadataResult) Extract() (map[string]string, error) {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return nil, r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Metadata map[string]string `mapstructure:"metadata"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(r.Body, &response)
0000000000000000000000000000000000000000;;		return response.Metadata, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Extract interprets any MetadatumResult as a Metadatum, if possible.
0000000000000000000000000000000000000000;;	func (r MetadatumResult) Extract() (map[string]string, error) {
0000000000000000000000000000000000000000;;		if r.Err != nil {
0000000000000000000000000000000000000000;;			return nil, r.Err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Metadatum map[string]string `mapstructure:"meta"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(r.Body, &response)
0000000000000000000000000000000000000000;;		return response.Metadatum, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func toMapFromString(from reflect.Kind, to reflect.Kind, data interface{}) (interface{}, error) {
0000000000000000000000000000000000000000;;		if (from == reflect.String) && (to == reflect.Map) {
0000000000000000000000000000000000000000;;			return map[string]interface{}{}, nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return data, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Address represents an IP address.
0000000000000000000000000000000000000000;;	type Address struct {
0000000000000000000000000000000000000000;;		Version int    `mapstructure:"version"`
0000000000000000000000000000000000000000;;		Address string `mapstructure:"addr"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// AddressPage abstracts the raw results of making a ListAddresses() request against the API.
0000000000000000000000000000000000000000;;	// As OpenStack extensions may freely alter the response bodies of structures returned
0000000000000000000000000000000000000000;;	// to the client, you may only safely access the data provided through the ExtractAddresses call.
0000000000000000000000000000000000000000;;	type AddressPage struct {
0000000000000000000000000000000000000000;;		pagination.SinglePageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if an AddressPage contains no networks.
0000000000000000000000000000000000000000;;	func (r AddressPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		addresses, err := ExtractAddresses(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(addresses) == 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractAddresses interprets the results of a single page from a ListAddresses() call,
0000000000000000000000000000000000000000;;	// producing a map of addresses.
0000000000000000000000000000000000000000;;	func ExtractAddresses(page pagination.Page) (map[string][]Address, error) {
0000000000000000000000000000000000000000;;		casted := page.(AddressPage).Body
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response struct {
0000000000000000000000000000000000000000;;			Addresses map[string][]Address `mapstructure:"addresses"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(casted, &response)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return response.Addresses, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NetworkAddressPage abstracts the raw results of making a ListAddressesByNetwork() request against the API.
0000000000000000000000000000000000000000;;	// As OpenStack extensions may freely alter the response bodies of structures returned
0000000000000000000000000000000000000000;;	// to the client, you may only safely access the data provided through the ExtractAddresses call.
0000000000000000000000000000000000000000;;	type NetworkAddressPage struct {
0000000000000000000000000000000000000000;;		pagination.SinglePageBase
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IsEmpty returns true if a NetworkAddressPage contains no addresses.
0000000000000000000000000000000000000000;;	func (r NetworkAddressPage) IsEmpty() (bool, error) {
0000000000000000000000000000000000000000;;		addresses, err := ExtractNetworkAddresses(r)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return true, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return len(addresses) == 0, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ExtractNetworkAddresses interprets the results of a single page from a ListAddressesByNetwork() call,
0000000000000000000000000000000000000000;;	// producing a slice of addresses.
0000000000000000000000000000000000000000;;	func ExtractNetworkAddresses(page pagination.Page) ([]Address, error) {
0000000000000000000000000000000000000000;;		casted := page.(NetworkAddressPage).Body
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var response map[string][]Address
0000000000000000000000000000000000000000;;		err := mapstructure.Decode(casted, &response)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return nil, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var key string
0000000000000000000000000000000000000000;;		for k := range response {
0000000000000000000000000000000000000000;;			key = k
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return response[key], err
0000000000000000000000000000000000000000;;	}
