0000000000000000000000000000000000000000;;	package servers
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/compute/v2/servers/requests.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/openstack/compute/v2/servers/requests.go][vendor/github.com/rackspace/gophercloud/openstack/compute/v2/servers/requests.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"encoding/base64"
0000000000000000000000000000000000000000;;		"encoding/json"
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"fmt"
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/openstack/compute/v2/flavors"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/openstack/compute/v2/images"
0000000000000000000000000000000000000000;;		"github.com/rackspace/gophercloud/pagination"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListOptsBuilder allows extensions to add additional parameters to the
0000000000000000000000000000000000000000;;	// List request.
0000000000000000000000000000000000000000;;	type ListOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToServerListQuery() (string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListOpts allows the filtering and sorting of paginated collections through
0000000000000000000000000000000000000000;;	// the API. Filtering is achieved by passing in struct field values that map to
0000000000000000000000000000000000000000;;	// the server attributes you want to see returned. Marker and Limit are used
0000000000000000000000000000000000000000;;	// for pagination.
0000000000000000000000000000000000000000;;	type ListOpts struct {
0000000000000000000000000000000000000000;;		// A time/date stamp for when the server last changed status.
0000000000000000000000000000000000000000;;		ChangesSince string `q:"changes-since"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the image in URL format.
0000000000000000000000000000000000000000;;		Image string `q:"image"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the flavor in URL format.
0000000000000000000000000000000000000000;;		Flavor string `q:"flavor"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the server as a string; can be queried with regular expressions.
0000000000000000000000000000000000000000;;		// Realize that ?name=bob returns both bob and bobb. If you need to match bob
0000000000000000000000000000000000000000;;		// only, you can use a regular expression matching the syntax of the
0000000000000000000000000000000000000000;;		// underlying database server implemented for Compute.
0000000000000000000000000000000000000000;;		Name string `q:"name"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Value of the status of the server so that you can filter on "ACTIVE" for example.
0000000000000000000000000000000000000000;;		Status string `q:"status"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name of the host as a string.
0000000000000000000000000000000000000000;;		Host string `q:"host"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UUID of the server at which you want to set a marker.
0000000000000000000000000000000000000000;;		Marker string `q:"marker"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Integer value for the limit of values to return.
0000000000000000000000000000000000000000;;		Limit int `q:"limit"`
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Bool to show all tenants
0000000000000000000000000000000000000000;;		AllTenants bool `q:"all_tenants"`
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerListQuery formats a ListOpts into a query string.
0000000000000000000000000000000000000000;;	func (opts ListOpts) ToServerListQuery() (string, error) {
0000000000000000000000000000000000000000;;		q, err := gophercloud.BuildQueryString(opts)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return q.String(), nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// List makes a request against the API to list servers accessible to you.
0000000000000000000000000000000000000000;;	func List(client *gophercloud.ServiceClient, opts ListOptsBuilder) pagination.Pager {
0000000000000000000000000000000000000000;;		url := listDetailURL(client)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts != nil {
0000000000000000000000000000000000000000;;			query, err := opts.ToServerListQuery()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return pagination.Pager{Err: err}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			url += query
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		createPageFn := func(r pagination.PageResult) pagination.Page {
0000000000000000000000000000000000000000;;			return ServerPage{pagination.LinkedPageBase{PageResult: r}}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return pagination.NewPager(client, url, createPageFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOptsBuilder describes struct types that can be accepted by the Create call.
0000000000000000000000000000000000000000;;	// The CreateOpts struct in this package does.
0000000000000000000000000000000000000000;;	type CreateOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToServerCreateMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Network is used within CreateOpts to control a new server's network attachments.
0000000000000000000000000000000000000000;;	type Network struct {
0000000000000000000000000000000000000000;;		// UUID of a nova-network to attach to the newly provisioned server.
0000000000000000000000000000000000000000;;		// Required unless Port is provided.
0000000000000000000000000000000000000000;;		UUID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Port of a neutron network to attach to the newly provisioned server.
0000000000000000000000000000000000000000;;		// Required unless UUID is provided.
0000000000000000000000000000000000000000;;		Port string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FixedIP [optional] specifies a fixed IPv4 address to be used on this network.
0000000000000000000000000000000000000000;;		FixedIP string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Personality is an array of files that are injected into the server at launch.
0000000000000000000000000000000000000000;;	type Personality []*File
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// File is used within CreateOpts and RebuildOpts to inject a file into the server at launch.
0000000000000000000000000000000000000000;;	// File implements the json.Marshaler interface, so when a Create or Rebuild operation is requested,
0000000000000000000000000000000000000000;;	// json.Marshal will call File's MarshalJSON method.
0000000000000000000000000000000000000000;;	type File struct {
0000000000000000000000000000000000000000;;		// Path of the file
0000000000000000000000000000000000000000;;		Path string
0000000000000000000000000000000000000000;;		// Contents of the file. Maximum content size is 255 bytes.
0000000000000000000000000000000000000000;;		Contents []byte
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MarshalJSON marshals the escaped file, base64 encoding the contents.
0000000000000000000000000000000000000000;;	func (f *File) MarshalJSON() ([]byte, error) {
0000000000000000000000000000000000000000;;		file := struct {
0000000000000000000000000000000000000000;;			Path     string `json:"path"`
0000000000000000000000000000000000000000;;			Contents string `json:"contents"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			Path:     f.Path,
0000000000000000000000000000000000000000;;			Contents: base64.StdEncoding.EncodeToString(f.Contents),
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return json.Marshal(file)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateOpts specifies server creation parameters.
0000000000000000000000000000000000000000;;	type CreateOpts struct {
0000000000000000000000000000000000000000;;		// Name [required] is the name to assign to the newly launched server.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImageRef [optional; required if ImageName is not provided] is the ID or full
0000000000000000000000000000000000000000;;		// URL to the image that contains the server's OS and initial state.
0000000000000000000000000000000000000000;;		// Also optional if using the boot-from-volume extension.
0000000000000000000000000000000000000000;;		ImageRef string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ImageName [optional; required if ImageRef is not provided] is the name of the
0000000000000000000000000000000000000000;;		// image that contains the server's OS and initial state.
0000000000000000000000000000000000000000;;		// Also optional if using the boot-from-volume extension.
0000000000000000000000000000000000000000;;		ImageName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FlavorRef [optional; required if FlavorName is not provided] is the ID or
0000000000000000000000000000000000000000;;		// full URL to the flavor that describes the server's specs.
0000000000000000000000000000000000000000;;		FlavorRef string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// FlavorName [optional; required if FlavorRef is not provided] is the name of
0000000000000000000000000000000000000000;;		// the flavor that describes the server's specs.
0000000000000000000000000000000000000000;;		FlavorName string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// SecurityGroups [optional] lists the names of the security groups to which this server should belong.
0000000000000000000000000000000000000000;;		SecurityGroups []string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// UserData [optional] contains configuration information or scripts to use upon launch.
0000000000000000000000000000000000000000;;		// Create will base64-encode it for you.
0000000000000000000000000000000000000000;;		UserData []byte
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AvailabilityZone [optional] in which to launch the server.
0000000000000000000000000000000000000000;;		AvailabilityZone string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Networks [optional] dictates how this server will be attached to available networks.
0000000000000000000000000000000000000000;;		// By default, the server will be attached to all isolated networks for the tenant.
0000000000000000000000000000000000000000;;		Networks []Network
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata [optional] contains key-value pairs (up to 255 bytes each) to attach to the server.
0000000000000000000000000000000000000000;;		Metadata map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Personality [optional] includes files to inject into the server at launch.
0000000000000000000000000000000000000000;;		// Create will base64-encode file contents for you.
0000000000000000000000000000000000000000;;		Personality Personality
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// ConfigDrive [optional] enables metadata injection through a configuration drive.
0000000000000000000000000000000000000000;;		ConfigDrive bool
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AdminPass [optional] sets the root user password. If not set, a randomly-generated
0000000000000000000000000000000000000000;;		// password will be created and returned in the response.
0000000000000000000000000000000000000000;;		AdminPass string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv4 [optional] specifies an IPv4 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv4 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv6 [optional] specifies an IPv6 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv6 string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerCreateMap assembles a request body based on the contents of a CreateOpts.
0000000000000000000000000000000000000000;;	func (opts CreateOpts) ToServerCreateMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		server := make(map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server["name"] = opts.Name
0000000000000000000000000000000000000000;;		server["imageRef"] = opts.ImageRef
0000000000000000000000000000000000000000;;		server["imageName"] = opts.ImageName
0000000000000000000000000000000000000000;;		server["flavorRef"] = opts.FlavorRef
0000000000000000000000000000000000000000;;		server["flavorName"] = opts.FlavorName
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.UserData != nil {
0000000000000000000000000000000000000000;;			encoded := base64.StdEncoding.EncodeToString(opts.UserData)
0000000000000000000000000000000000000000;;			server["user_data"] = &encoded
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.ConfigDrive {
0000000000000000000000000000000000000000;;			server["config_drive"] = "true"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.AvailabilityZone != "" {
0000000000000000000000000000000000000000;;			server["availability_zone"] = opts.AvailabilityZone
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.Metadata != nil {
0000000000000000000000000000000000000000;;			server["metadata"] = opts.Metadata
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.AdminPass != "" {
0000000000000000000000000000000000000000;;			server["adminPass"] = opts.AdminPass
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.AccessIPv4 != "" {
0000000000000000000000000000000000000000;;			server["accessIPv4"] = opts.AccessIPv4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.AccessIPv6 != "" {
0000000000000000000000000000000000000000;;			server["accessIPv6"] = opts.AccessIPv6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(opts.SecurityGroups) > 0 {
0000000000000000000000000000000000000000;;			securityGroups := make([]map[string]interface{}, len(opts.SecurityGroups))
0000000000000000000000000000000000000000;;			for i, groupName := range opts.SecurityGroups {
0000000000000000000000000000000000000000;;				securityGroups[i] = map[string]interface{}{"name": groupName}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			server["security_groups"] = securityGroups
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(opts.Networks) > 0 {
0000000000000000000000000000000000000000;;			networks := make([]map[string]interface{}, len(opts.Networks))
0000000000000000000000000000000000000000;;			for i, net := range opts.Networks {
0000000000000000000000000000000000000000;;				networks[i] = make(map[string]interface{})
0000000000000000000000000000000000000000;;				if net.UUID != "" {
0000000000000000000000000000000000000000;;					networks[i]["uuid"] = net.UUID
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if net.Port != "" {
0000000000000000000000000000000000000000;;					networks[i]["port"] = net.Port
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;				if net.FixedIP != "" {
0000000000000000000000000000000000000000;;					networks[i]["fixed_ip"] = net.FixedIP
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			server["networks"] = networks
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(opts.Personality) > 0 {
0000000000000000000000000000000000000000;;			server["personality"] = opts.Personality
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return map[string]interface{}{"server": server}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Create requests a server to be provisioned to the user in the current tenant.
0000000000000000000000000000000000000000;;	func Create(client *gophercloud.ServiceClient, opts CreateOptsBuilder) CreateResult {
0000000000000000000000000000000000000000;;		var res CreateResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqBody, err := opts.ToServerCreateMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			res.Err = err
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If ImageRef isn't provided, use ImageName to ascertain the image ID.
0000000000000000000000000000000000000000;;		if reqBody["server"].(map[string]interface{})["imageRef"].(string) == "" {
0000000000000000000000000000000000000000;;			imageName := reqBody["server"].(map[string]interface{})["imageName"].(string)
0000000000000000000000000000000000000000;;			if imageName == "" {
0000000000000000000000000000000000000000;;				res.Err = errors.New("One and only one of ImageRef and ImageName must be provided.")
0000000000000000000000000000000000000000;;				return res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			imageID, err := images.IDFromName(client, imageName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				res.Err = err
0000000000000000000000000000000000000000;;				return res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reqBody["server"].(map[string]interface{})["imageRef"] = imageID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(reqBody["server"].(map[string]interface{}), "imageName")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// If FlavorRef isn't provided, use FlavorName to ascertain the flavor ID.
0000000000000000000000000000000000000000;;		if reqBody["server"].(map[string]interface{})["flavorRef"].(string) == "" {
0000000000000000000000000000000000000000;;			flavorName := reqBody["server"].(map[string]interface{})["flavorName"].(string)
0000000000000000000000000000000000000000;;			if flavorName == "" {
0000000000000000000000000000000000000000;;				res.Err = errors.New("One and only one of FlavorRef and FlavorName must be provided.")
0000000000000000000000000000000000000000;;				return res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			flavorID, err := flavors.IDFromName(client, flavorName)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				res.Err = err
0000000000000000000000000000000000000000;;				return res
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			reqBody["server"].(map[string]interface{})["flavorRef"] = flavorID
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		delete(reqBody["server"].(map[string]interface{}), "flavorName")
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(listURL(client), reqBody, &res.Body, nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Delete requests that a server previously provisioned be removed from your account.
0000000000000000000000000000000000000000;;	func Delete(client *gophercloud.ServiceClient, id string) DeleteResult {
0000000000000000000000000000000000000000;;		var res DeleteResult
0000000000000000000000000000000000000000;;		_, res.Err = client.Delete(deleteURL(client, id), nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func ForceDelete(client *gophercloud.ServiceClient, id string) ActionResult {
0000000000000000000000000000000000000000;;		var req struct {
0000000000000000000000000000000000000000;;			ForceDelete string `json:"forceDelete"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res ActionResult
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(actionURL(client, id), req, nil, nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Get requests details on a single server, by ID.
0000000000000000000000000000000000000000;;	func Get(client *gophercloud.ServiceClient, id string) GetResult {
0000000000000000000000000000000000000000;;		var result GetResult
0000000000000000000000000000000000000000;;		_, result.Err = client.Get(getURL(client, id), &result.Body, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{200, 203},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateOptsBuilder allows extensions to add additional attributes to the Update request.
0000000000000000000000000000000000000000;;	type UpdateOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToServerUpdateMap() map[string]interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateOpts specifies the base attributes that may be updated on an existing server.
0000000000000000000000000000000000000000;;	type UpdateOpts struct {
0000000000000000000000000000000000000000;;		// Name [optional] changes the displayed name of the server.
0000000000000000000000000000000000000000;;		// The server host name will *not* change.
0000000000000000000000000000000000000000;;		// Server names are not constrained to be unique, even within the same tenant.
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv4 [optional] provides a new IPv4 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv4 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv6 [optional] provides a new IPv6 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv6 string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerUpdateMap formats an UpdateOpts structure into a request body.
0000000000000000000000000000000000000000;;	func (opts UpdateOpts) ToServerUpdateMap() map[string]interface{} {
0000000000000000000000000000000000000000;;		server := make(map[string]string)
0000000000000000000000000000000000000000;;		if opts.Name != "" {
0000000000000000000000000000000000000000;;			server["name"] = opts.Name
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.AccessIPv4 != "" {
0000000000000000000000000000000000000000;;			server["accessIPv4"] = opts.AccessIPv4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		if opts.AccessIPv6 != "" {
0000000000000000000000000000000000000000;;			server["accessIPv6"] = opts.AccessIPv6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return map[string]interface{}{"server": server}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Update requests that various attributes of the indicated server be changed.
0000000000000000000000000000000000000000;;	func Update(client *gophercloud.ServiceClient, id string, opts UpdateOptsBuilder) UpdateResult {
0000000000000000000000000000000000000000;;		var result UpdateResult
0000000000000000000000000000000000000000;;		reqBody := opts.ToServerUpdateMap()
0000000000000000000000000000000000000000;;		_, result.Err = client.Put(updateURL(client, id), reqBody, &result.Body, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{200},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ChangeAdminPassword alters the administrator or root password for a specified server.
0000000000000000000000000000000000000000;;	func ChangeAdminPassword(client *gophercloud.ServiceClient, id, newPassword string) ActionResult {
0000000000000000000000000000000000000000;;		var req struct {
0000000000000000000000000000000000000000;;			ChangePassword struct {
0000000000000000000000000000000000000000;;				AdminPass string `json:"adminPass"`
0000000000000000000000000000000000000000;;			} `json:"changePassword"`
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		req.ChangePassword.AdminPass = newPassword
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		var res ActionResult
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(actionURL(client, id), req, nil, nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ErrArgument errors occur when an argument supplied to a package function
0000000000000000000000000000000000000000;;	// fails to fall within acceptable values.  For example, the Reboot() function
0000000000000000000000000000000000000000;;	// expects the "how" parameter to be one of HardReboot or SoftReboot.  These
0000000000000000000000000000000000000000;;	// constants are (currently) strings, leading someone to wonder if they can pass
0000000000000000000000000000000000000000;;	// other string values instead, perhaps in an effort to break the API of their
0000000000000000000000000000000000000000;;	// provider.  Reboot() returns this error in this situation.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// Function identifies which function was called/which function is generating
0000000000000000000000000000000000000000;;	// the error.
0000000000000000000000000000000000000000;;	// Argument identifies which formal argument was responsible for producing the
0000000000000000000000000000000000000000;;	// error.
0000000000000000000000000000000000000000;;	// Value provides the value as it was passed into the function.
0000000000000000000000000000000000000000;;	type ErrArgument struct {
0000000000000000000000000000000000000000;;		Function, Argument string
0000000000000000000000000000000000000000;;		Value              interface{}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Error yields a useful diagnostic for debugging purposes.
0000000000000000000000000000000000000000;;	func (e *ErrArgument) Error() string {
0000000000000000000000000000000000000000;;		return fmt.Sprintf("Bad argument in call to %s, formal parameter %s, value %#v", e.Function, e.Argument, e.Value)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	func (e *ErrArgument) String() string {
0000000000000000000000000000000000000000;;		return e.Error()
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RebootMethod describes the mechanisms by which a server reboot can be requested.
0000000000000000000000000000000000000000;;	type RebootMethod string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// These constants determine how a server should be rebooted.
0000000000000000000000000000000000000000;;	// See the Reboot() function for further details.
0000000000000000000000000000000000000000;;	const (
0000000000000000000000000000000000000000;;		SoftReboot RebootMethod = "SOFT"
0000000000000000000000000000000000000000;;		HardReboot RebootMethod = "HARD"
0000000000000000000000000000000000000000;;		OSReboot                = SoftReboot
0000000000000000000000000000000000000000;;		PowerCycle              = HardReboot
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Reboot requests that a given server reboot.
0000000000000000000000000000000000000000;;	// Two methods exist for rebooting a server:
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// HardReboot (aka PowerCycle) restarts the server instance by physically cutting power to the machine, or if a VM,
0000000000000000000000000000000000000000;;	// terminating it at the hypervisor level.
0000000000000000000000000000000000000000;;	// It's done. Caput. Full stop.
0000000000000000000000000000000000000000;;	// Then, after a brief while, power is restored or the VM instance restarted.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// SoftReboot (aka OSReboot) simply tells the OS to restart under its own procedures.
0000000000000000000000000000000000000000;;	// E.g., in Linux, asking it to enter runlevel 6, or executing "sudo shutdown -r now", or by asking Windows to restart the machine.
0000000000000000000000000000000000000000;;	func Reboot(client *gophercloud.ServiceClient, id string, how RebootMethod) ActionResult {
0000000000000000000000000000000000000000;;		var res ActionResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if (how != SoftReboot) && (how != HardReboot) {
0000000000000000000000000000000000000000;;			res.Err = &ErrArgument{
0000000000000000000000000000000000000000;;				Function: "Reboot",
0000000000000000000000000000000000000000;;				Argument: "how",
0000000000000000000000000000000000000000;;				Value:    how,
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqBody := struct {
0000000000000000000000000000000000000000;;			C map[string]string `json:"reboot"`
0000000000000000000000000000000000000000;;		}{
0000000000000000000000000000000000000000;;			map[string]string{"type": string(how)},
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(actionURL(client, id), reqBody, nil, nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RebuildOptsBuilder is an interface that allows extensions to override the
0000000000000000000000000000000000000000;;	// default behaviour of rebuild options
0000000000000000000000000000000000000000;;	type RebuildOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToServerRebuildMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RebuildOpts represents the configuration options used in a server rebuild
0000000000000000000000000000000000000000;;	// operation
0000000000000000000000000000000000000000;;	type RebuildOpts struct {
0000000000000000000000000000000000000000;;		// Required. The ID of the image you want your server to be provisioned on
0000000000000000000000000000000000000000;;		ImageID string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Name to set the server to
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Required. The server's admin password
0000000000000000000000000000000000000000;;		AdminPass string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv4 [optional] provides a new IPv4 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv4 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// AccessIPv6 [optional] provides a new IPv6 address for the instance.
0000000000000000000000000000000000000000;;		AccessIPv6 string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Metadata [optional] contains key-value pairs (up to 255 bytes each) to attach to the server.
0000000000000000000000000000000000000000;;		Metadata map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		// Personality [optional] includes files to inject into the server at launch.
0000000000000000000000000000000000000000;;		// Rebuild will base64-encode file contents for you.
0000000000000000000000000000000000000000;;		Personality Personality
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerRebuildMap formats a RebuildOpts struct into a map for use in JSON
0000000000000000000000000000000000000000;;	func (opts RebuildOpts) ToServerRebuildMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		server := make(map[string]interface{})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.AdminPass == "" {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("AdminPass is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.ImageID == "" {
0000000000000000000000000000000000000000;;			err = fmt.Errorf("ImageID is required")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return server, err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		server["name"] = opts.Name
0000000000000000000000000000000000000000;;		server["adminPass"] = opts.AdminPass
0000000000000000000000000000000000000000;;		server["imageRef"] = opts.ImageID
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.AccessIPv4 != "" {
0000000000000000000000000000000000000000;;			server["accessIPv4"] = opts.AccessIPv4
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.AccessIPv6 != "" {
0000000000000000000000000000000000000000;;			server["accessIPv6"] = opts.AccessIPv6
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if opts.Metadata != nil {
0000000000000000000000000000000000000000;;			server["metadata"] = opts.Metadata
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if len(opts.Personality) > 0 {
0000000000000000000000000000000000000000;;			server["personality"] = opts.Personality
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return map[string]interface{}{"rebuild": server}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rebuild will reprovision the server according to the configuration options
0000000000000000000000000000000000000000;;	// provided in the RebuildOpts struct.
0000000000000000000000000000000000000000;;	func Rebuild(client *gophercloud.ServiceClient, id string, opts RebuildOptsBuilder) RebuildResult {
0000000000000000000000000000000000000000;;		var result RebuildResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if id == "" {
0000000000000000000000000000000000000000;;			result.Err = fmt.Errorf("ID is required")
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqBody, err := opts.ToServerRebuildMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result.Err = err
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, result.Err = client.Post(actionURL(client, id), reqBody, &result.Body, nil)
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResizeOptsBuilder is an interface that allows extensions to override the default structure of
0000000000000000000000000000000000000000;;	// a Resize request.
0000000000000000000000000000000000000000;;	type ResizeOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToServerResizeMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResizeOpts represents the configuration options used to control a Resize operation.
0000000000000000000000000000000000000000;;	type ResizeOpts struct {
0000000000000000000000000000000000000000;;		// FlavorRef is the ID of the flavor you wish your server to become.
0000000000000000000000000000000000000000;;		FlavorRef string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerResizeMap formats a ResizeOpts as a map that can be used as a JSON request body for the
0000000000000000000000000000000000000000;;	// Resize request.
0000000000000000000000000000000000000000;;	func (opts ResizeOpts) ToServerResizeMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		resize := map[string]interface{}{
0000000000000000000000000000000000000000;;			"flavorRef": opts.FlavorRef,
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return map[string]interface{}{"resize": resize}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Resize instructs the provider to change the flavor of the server.
0000000000000000000000000000000000000000;;	// Note that this implies rebuilding it.
0000000000000000000000000000000000000000;;	// Unfortunately, one cannot pass rebuild parameters to the resize function.
0000000000000000000000000000000000000000;;	// When the resize completes, the server will be in RESIZE_VERIFY state.
0000000000000000000000000000000000000000;;	// While in this state, you can explore the use of the new server's configuration.
0000000000000000000000000000000000000000;;	// If you like it, call ConfirmResize() to commit the resize permanently.
0000000000000000000000000000000000000000;;	// Otherwise, call RevertResize() to restore the old configuration.
0000000000000000000000000000000000000000;;	func Resize(client *gophercloud.ServiceClient, id string, opts ResizeOptsBuilder) ActionResult {
0000000000000000000000000000000000000000;;		var res ActionResult
0000000000000000000000000000000000000000;;		reqBody, err := opts.ToServerResizeMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			res.Err = err
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(actionURL(client, id), reqBody, nil, nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ConfirmResize confirms a previous resize operation on a server.
0000000000000000000000000000000000000000;;	// See Resize() for more details.
0000000000000000000000000000000000000000;;	func ConfirmResize(client *gophercloud.ServiceClient, id string) ActionResult {
0000000000000000000000000000000000000000;;		var res ActionResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		reqBody := map[string]interface{}{"confirmResize": nil}
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(actionURL(client, id), reqBody, nil, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{201, 202, 204},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RevertResize cancels a previous resize operation on a server.
0000000000000000000000000000000000000000;;	// See Resize() for more details.
0000000000000000000000000000000000000000;;	func RevertResize(client *gophercloud.ServiceClient, id string) ActionResult {
0000000000000000000000000000000000000000;;		var res ActionResult
0000000000000000000000000000000000000000;;		reqBody := map[string]interface{}{"revertResize": nil}
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(actionURL(client, id), reqBody, nil, nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RescueOptsBuilder is an interface that allows extensions to override the
0000000000000000000000000000000000000000;;	// default structure of a Rescue request.
0000000000000000000000000000000000000000;;	type RescueOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToServerRescueMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// RescueOpts represents the configuration options used to control a Rescue
0000000000000000000000000000000000000000;;	// option.
0000000000000000000000000000000000000000;;	type RescueOpts struct {
0000000000000000000000000000000000000000;;		// AdminPass is the desired administrative password for the instance in
0000000000000000000000000000000000000000;;		// RESCUE mode. If it's left blank, the server will generate a password.
0000000000000000000000000000000000000000;;		AdminPass string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerRescueMap formats a RescueOpts as a map that can be used as a JSON
0000000000000000000000000000000000000000;;	// request body for the Rescue request.
0000000000000000000000000000000000000000;;	func (opts RescueOpts) ToServerRescueMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		server := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if opts.AdminPass != "" {
0000000000000000000000000000000000000000;;			server["adminPass"] = opts.AdminPass
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return map[string]interface{}{"rescue": server}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Rescue instructs the provider to place the server into RESCUE mode.
0000000000000000000000000000000000000000;;	func Rescue(client *gophercloud.ServiceClient, id string, opts RescueOptsBuilder) RescueResult {
0000000000000000000000000000000000000000;;		var result RescueResult
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		if id == "" {
0000000000000000000000000000000000000000;;			result.Err = fmt.Errorf("ID is required")
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		reqBody, err := opts.ToServerRescueMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			result.Err = err
0000000000000000000000000000000000000000;;			return result
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, result.Err = client.Post(actionURL(client, id), reqBody, &result.Body, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{200},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		return result
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetMetadataOptsBuilder allows extensions to add additional parameters to the
0000000000000000000000000000000000000000;;	// Reset request.
0000000000000000000000000000000000000000;;	type ResetMetadataOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToMetadataResetMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadataOpts is a map that contains key-value pairs.
0000000000000000000000000000000000000000;;	type MetadataOpts map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToMetadataResetMap assembles a body for a Reset request based on the contents of a MetadataOpts.
0000000000000000000000000000000000000000;;	func (opts MetadataOpts) ToMetadataResetMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		return map[string]interface{}{"metadata": opts}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToMetadataUpdateMap assembles a body for an Update request based on the contents of a MetadataOpts.
0000000000000000000000000000000000000000;;	func (opts MetadataOpts) ToMetadataUpdateMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		return map[string]interface{}{"metadata": opts}, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ResetMetadata will create multiple new key-value pairs for the given server ID.
0000000000000000000000000000000000000000;;	// Note: Using this operation will erase any already-existing metadata and create
0000000000000000000000000000000000000000;;	// the new metadata provided. To keep any already-existing metadata, use the
0000000000000000000000000000000000000000;;	// UpdateMetadatas or UpdateMetadata function.
0000000000000000000000000000000000000000;;	func ResetMetadata(client *gophercloud.ServiceClient, id string, opts ResetMetadataOptsBuilder) ResetMetadataResult {
0000000000000000000000000000000000000000;;		var res ResetMetadataResult
0000000000000000000000000000000000000000;;		metadata, err := opts.ToMetadataResetMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			res.Err = err
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, res.Err = client.Put(metadataURL(client, id), metadata, &res.Body, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{200},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Metadata requests all the metadata for the given server ID.
0000000000000000000000000000000000000000;;	func Metadata(client *gophercloud.ServiceClient, id string) GetMetadataResult {
0000000000000000000000000000000000000000;;		var res GetMetadataResult
0000000000000000000000000000000000000000;;		_, res.Err = client.Get(metadataURL(client, id), &res.Body, nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateMetadataOptsBuilder allows extensions to add additional parameters to the
0000000000000000000000000000000000000000;;	// Create request.
0000000000000000000000000000000000000000;;	type UpdateMetadataOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToMetadataUpdateMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// UpdateMetadata updates (or creates) all the metadata specified by opts for the given server ID.
0000000000000000000000000000000000000000;;	// This operation does not affect already-existing metadata that is not specified
0000000000000000000000000000000000000000;;	// by opts.
0000000000000000000000000000000000000000;;	func UpdateMetadata(client *gophercloud.ServiceClient, id string, opts UpdateMetadataOptsBuilder) UpdateMetadataResult {
0000000000000000000000000000000000000000;;		var res UpdateMetadataResult
0000000000000000000000000000000000000000;;		metadata, err := opts.ToMetadataUpdateMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			res.Err = err
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		_, res.Err = client.Post(metadataURL(client, id), metadata, &res.Body, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{200},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadatumOptsBuilder allows extensions to add additional parameters to the
0000000000000000000000000000000000000000;;	// Create request.
0000000000000000000000000000000000000000;;	type MetadatumOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToMetadatumCreateMap() (map[string]interface{}, string, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// MetadatumOpts is a map of length one that contains a key-value pair.
0000000000000000000000000000000000000000;;	type MetadatumOpts map[string]string
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToMetadatumCreateMap assembles a body for a Create request based on the contents of a MetadataumOpts.
0000000000000000000000000000000000000000;;	func (opts MetadatumOpts) ToMetadatumCreateMap() (map[string]interface{}, string, error) {
0000000000000000000000000000000000000000;;		if len(opts) != 1 {
0000000000000000000000000000000000000000;;			return nil, "", errors.New("CreateMetadatum operation must have 1 and only 1 key-value pair.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		metadatum := map[string]interface{}{"meta": opts}
0000000000000000000000000000000000000000;;		var key string
0000000000000000000000000000000000000000;;		for k := range metadatum["meta"].(MetadatumOpts) {
0000000000000000000000000000000000000000;;			key = k
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return metadatum, key, nil
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateMetadatum will create or update the key-value pair with the given key for the given server ID.
0000000000000000000000000000000000000000;;	func CreateMetadatum(client *gophercloud.ServiceClient, id string, opts MetadatumOptsBuilder) CreateMetadatumResult {
0000000000000000000000000000000000000000;;		var res CreateMetadatumResult
0000000000000000000000000000000000000000;;		metadatum, key, err := opts.ToMetadatumCreateMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			res.Err = err
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		_, res.Err = client.Put(metadatumURL(client, id, key), metadatum, &res.Body, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{200},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// Metadatum requests the key-value pair with the given key for the given server ID.
0000000000000000000000000000000000000000;;	func Metadatum(client *gophercloud.ServiceClient, id, key string) GetMetadatumResult {
0000000000000000000000000000000000000000;;		var res GetMetadatumResult
0000000000000000000000000000000000000000;;		_, res.Err = client.Request("GET", metadatumURL(client, id, key), gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			JSONResponse: &res.Body,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// DeleteMetadatum will delete the key-value pair with the given key for the given server ID.
0000000000000000000000000000000000000000;;	func DeleteMetadatum(client *gophercloud.ServiceClient, id, key string) DeleteMetadatumResult {
0000000000000000000000000000000000000000;;		var res DeleteMetadatumResult
0000000000000000000000000000000000000000;;		_, res.Err = client.Delete(metadatumURL(client, id, key), nil)
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListAddresses makes a request against the API to list the servers IP addresses.
0000000000000000000000000000000000000000;;	func ListAddresses(client *gophercloud.ServiceClient, id string) pagination.Pager {
0000000000000000000000000000000000000000;;		createPageFn := func(r pagination.PageResult) pagination.Page {
0000000000000000000000000000000000000000;;			return AddressPage{pagination.SinglePageBase(r)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pagination.NewPager(client, listAddressesURL(client, id), createPageFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ListAddressesByNetwork makes a request against the API to list the servers IP addresses
0000000000000000000000000000000000000000;;	// for the given network.
0000000000000000000000000000000000000000;;	func ListAddressesByNetwork(client *gophercloud.ServiceClient, id, network string) pagination.Pager {
0000000000000000000000000000000000000000;;		createPageFn := func(r pagination.PageResult) pagination.Page {
0000000000000000000000000000000000000000;;			return NetworkAddressPage{pagination.SinglePageBase(r)}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return pagination.NewPager(client, listAddressesByNetworkURL(client, id, network), createPageFn)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateImageOpts struct {
0000000000000000000000000000000000000000;;		// Name [required] of the image/snapshot
0000000000000000000000000000000000000000;;		Name string
0000000000000000000000000000000000000000;;		// Metadata [optional] contains key-value pairs (up to 255 bytes each) to attach to the created image.
0000000000000000000000000000000000000000;;		Metadata map[string]string
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	type CreateImageOptsBuilder interface {
0000000000000000000000000000000000000000;;		ToServerCreateImageMap() (map[string]interface{}, error)
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// ToServerCreateImageMap formats a CreateImageOpts structure into a request body.
0000000000000000000000000000000000000000;;	func (opts CreateImageOpts) ToServerCreateImageMap() (map[string]interface{}, error) {
0000000000000000000000000000000000000000;;		var err error
0000000000000000000000000000000000000000;;		img := make(map[string]interface{})
0000000000000000000000000000000000000000;;		if opts.Name == "" {
0000000000000000000000000000000000000000;;			return nil, fmt.Errorf("Cannot create a server image without a name")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		img["name"] = opts.Name
0000000000000000000000000000000000000000;;		if opts.Metadata != nil {
0000000000000000000000000000000000000000;;			img["metadata"] = opts.Metadata
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		createImage := make(map[string]interface{})
0000000000000000000000000000000000000000;;		createImage["createImage"] = img
0000000000000000000000000000000000000000;;		return createImage, err
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// CreateImage makes a request against the nova API to schedule an image to be created of the server
0000000000000000000000000000000000000000;;	func CreateImage(client *gophercloud.ServiceClient, serverId string, opts CreateImageOptsBuilder) CreateImageResult {
0000000000000000000000000000000000000000;;		var res CreateImageResult
0000000000000000000000000000000000000000;;		reqBody, err := opts.ToServerCreateImageMap()
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			res.Err = err
0000000000000000000000000000000000000000;;			return res
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		response, err := client.Post(actionURL(client, serverId), reqBody, nil, &gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			OkCodes: []int{202},
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		res.Err = err
0000000000000000000000000000000000000000;;		res.Header = response.Header
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// IDFromName is a convienience function that returns a server's ID given its name.
0000000000000000000000000000000000000000;;	func IDFromName(client *gophercloud.ServiceClient, name string) (string, error) {
0000000000000000000000000000000000000000;;		serverCount := 0
0000000000000000000000000000000000000000;;		serverID := ""
0000000000000000000000000000000000000000;;		if name == "" {
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("A server name must be provided.")
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		pager := List(client, nil)
0000000000000000000000000000000000000000;;		pager.EachPage(func(page pagination.Page) (bool, error) {
0000000000000000000000000000000000000000;;			serverList, err := ExtractServers(page)
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return false, err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			for _, s := range serverList {
0000000000000000000000000000000000000000;;				if s.Name == name {
0000000000000000000000000000000000000000;;					serverCount++
0000000000000000000000000000000000000000;;					serverID = s.ID
0000000000000000000000000000000000000000;;				}
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			return true, nil
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		switch serverCount {
0000000000000000000000000000000000000000;;		case 0:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Unable to find server: %s", name)
0000000000000000000000000000000000000000;;		case 1:
0000000000000000000000000000000000000000;;			return serverID, nil
0000000000000000000000000000000000000000;;		default:
0000000000000000000000000000000000000000;;			return "", fmt.Errorf("Found %d servers matching %s", serverCount, name)
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// GetPassword makes a request against the nova API to get the encrypted administrative password.
0000000000000000000000000000000000000000;;	func GetPassword(client *gophercloud.ServiceClient, serverId string) GetPasswordResult {
0000000000000000000000000000000000000000;;		var res GetPasswordResult
0000000000000000000000000000000000000000;;		_, res.Err = client.Request("GET", passwordURL(client, serverId), gophercloud.RequestOpts{
0000000000000000000000000000000000000000;;			JSONResponse: &res.Body,
0000000000000000000000000000000000000000;;		})
0000000000000000000000000000000000000000;;		return res
0000000000000000000000000000000000000000;;	}
