0000000000000000000000000000000000000000;;	package gophercloud
54f55c92d2241cbee62ced42c2bb584275ee6601;Godeps/_workspace/src/github.com/rackspace/gophercloud/util.go[Godeps/_workspace/src/github.com/rackspace/gophercloud/util.go][vendor/github.com/rackspace/gophercloud/util.go];	
0000000000000000000000000000000000000000;;	import (
0000000000000000000000000000000000000000;;		"errors"
0000000000000000000000000000000000000000;;		"net/url"
0000000000000000000000000000000000000000;;		"path/filepath"
0000000000000000000000000000000000000000;;		"strings"
0000000000000000000000000000000000000000;;		"time"
0000000000000000000000000000000000000000;;	)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// WaitFor polls a predicate function, once per second, up to a timeout limit.
0000000000000000000000000000000000000000;;	// It usually does this to wait for a resource to transition to a certain state.
0000000000000000000000000000000000000000;;	// Resource packages will wrap this in a more convenient function that's
0000000000000000000000000000000000000000;;	// specific to a certain resource, but it can also be useful on its own.
0000000000000000000000000000000000000000;;	func WaitFor(timeout int, predicate func() (bool, error)) error {
0000000000000000000000000000000000000000;;		start := time.Now().Second()
0000000000000000000000000000000000000000;;		for {
0000000000000000000000000000000000000000;;			// Force a 1s sleep
0000000000000000000000000000000000000000;;			time.Sleep(1 * time.Second)
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// If a timeout is set, and that's been exceeded, shut it down
0000000000000000000000000000000000000000;;			if timeout >= 0 && time.Now().Second()-start >= timeout {
0000000000000000000000000000000000000000;;				return errors.New("A timeout occurred")
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;			// Execute the function
0000000000000000000000000000000000000000;;			satisfied, err := predicate()
0000000000000000000000000000000000000000;;			if err != nil {
0000000000000000000000000000000000000000;;				return err
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;			if satisfied {
0000000000000000000000000000000000000000;;				return nil
0000000000000000000000000000000000000000;;			}
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NormalizeURL is an internal function to be used by provider clients.
0000000000000000000000000000000000000000;;	//
0000000000000000000000000000000000000000;;	// It ensures that each endpoint URL has a closing `/`, as expected by
0000000000000000000000000000000000000000;;	// ServiceClient's methods.
0000000000000000000000000000000000000000;;	func NormalizeURL(url string) string {
0000000000000000000000000000000000000000;;		if !strings.HasSuffix(url, "/") {
0000000000000000000000000000000000000000;;			return url + "/"
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		return url
0000000000000000000000000000000000000000;;	}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	// NormalizePathURL is used to convert rawPath to a fqdn, using basePath as
0000000000000000000000000000000000000000;;	// a reference in the filesystem, if necessary. basePath is assumed to contain
0000000000000000000000000000000000000000;;	// either '.' when first used, or the file:// type fqdn of the parent resource.
0000000000000000000000000000000000000000;;	// e.g. myFavScript.yaml => file://opt/lib/myFavScript.yaml
0000000000000000000000000000000000000000;;	func NormalizePathURL(basePath, rawPath string) (string, error) {
0000000000000000000000000000000000000000;;		u, err := url.Parse(rawPath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if a scheme is defined, it must be a fqdn already
0000000000000000000000000000000000000000;;		if u.Scheme != "" {
0000000000000000000000000000000000000000;;			return u.String(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		// if basePath is a url, then child resources are assumed to be relative to it
0000000000000000000000000000000000000000;;		bu, err := url.Parse(basePath)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		var basePathSys, absPathSys string
0000000000000000000000000000000000000000;;		if bu.Scheme != "" {
0000000000000000000000000000000000000000;;			basePathSys = filepath.FromSlash(bu.Path)
0000000000000000000000000000000000000000;;			absPathSys = filepath.Join(basePathSys, rawPath)
0000000000000000000000000000000000000000;;			bu.Path = filepath.ToSlash(absPathSys)
0000000000000000000000000000000000000000;;			return bu.String(), nil
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;		absPathSys = filepath.Join(basePath, rawPath)
0000000000000000000000000000000000000000;;		u.Path = filepath.ToSlash(absPathSys)
0000000000000000000000000000000000000000;;		if err != nil {
0000000000000000000000000000000000000000;;			return "", err
0000000000000000000000000000000000000000;;		}
0000000000000000000000000000000000000000;;		u.Scheme = "file"
0000000000000000000000000000000000000000;;		return u.String(), nil
0000000000000000000000000000000000000000;;	
0000000000000000000000000000000000000000;;	}
